<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apicloud不同页面传值</title>
    <url>/2018/08/13/Apicloud%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fu8e0x3j5hj30ci02xdg1.jpg" alt="apicloud"></p>
<p>标准开头，前一段时间因为需要开发一个简单的app,所以接触了一下Apicloud,因为没有native应用的开发知识，所以采用了Apicloud的web应用开发。其中不同页面的传值问题我具体研究一段时间，因为之前一直传值不成功。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="方法一：api-execScript"><a href="#方法一：api-execScript" class="headerlink" title="方法一：api.execScript"></a>方法一：api.execScript</h2><a id="more"></a>
<p>这个方法本来的功能是用来不同页面的函数的传递，当然，也可以用来传递值，将这个值作为函数的参数就可以传递到其他页面。具体：</p>
<p>index1：</p>
<pre><code>//name是该页面函数的参数，作为参数传递到另一个页面
var str=&quot;test(&quot;+name+&quot;)&quot;;
api.exeScript({
    name:&quot;index2&quot;,
    script:str});
</code></pre><p>index2:</p>
<pre><code>//index2页面代码
function test(name){
alert(name);
}
</code></pre><h2 id="方法：api-addEventListener-amp-amp-api-sendEvent"><a href="#方法：api-addEventListener-amp-amp-api-sendEvent" class="headerlink" title="方法：api.addEventListener&amp;&amp;api.sendEvent"></a>方法：api.addEventListener&amp;&amp;api.sendEvent</h2><p>这个是利用广播事件传递参数。</p>
<p>index1:发送广播</p>
<pre><code>api.sendEvent({
    name:&apos;myEvent&apos;,
    extra:{key1:&apos;value&apos;,key2:&apos;key2&apos;}
</code></pre><p>});</p>
<p>index2:接受广播</p>
<pre><code>api.addEventListener({
    name:&apos;myEvent&apos;},
    function(ret){
    if(ret&amp;&amp;ret.value){
    var value = ret.value;
    alert(value.key1+&apos;,&apos;+value.key2);
    }
});
</code></pre><h2 id="方法三-api-LocalStorage"><a href="#方法三-api-LocalStorage" class="headerlink" title="方法三 :api.LocalStorage"></a>方法三 :api.LocalStorage</h2><p>这个方法很简单，采用了本地数据存储的方法来交换数据。</p>
<p>index1:</p>
<pre><code>$api.setStorage(&apos;name&apos;,&apos;value&apos;);//数据存储
</code></pre><p>index2:</p>
<pre><code>$api.getStorage(&apos;name&apos;);//取出name值
</code></pre><p>另外：</p>
<pre><code>$api.rnStorage(&apos;name&apos;);//清除name值
$api.clearStorage(&apos;name&apos;);//清除所有本地数据
</code></pre><h2 id="方法四-：api-openWin-amp-api-openFrame-amp-api-openFrameGroup"><a href="#方法四-：api-openWin-amp-api-openFrame-amp-api-openFrameGroup" class="headerlink" title="方法四 ：api.openWin&amp;api.openFrame&amp;api.openFrameGroup"></a>方法四 ：api.openWin&amp;api.openFrame&amp;api.openFrameGroup</h2><p>最后最简单的是采用打开窗口时可以顺带传值。</p>
<p>index1:</p>
<pre><code>//打开新窗口
api.openWin({
    name:index2,
    url:index2.html,
    pageParam: {
        key : value,
        }
});


//打开frame组
api.openFrameGroup({
name: &apos;group1&apos;,
rect: {             //frame的位置
    x: 0,
    y: 0,
    w: &apos;auto&apos;,
    h: &apos;auto&apos;
},
frames: [{           //frame组 
    name: &apos;frame1&apos;,
    url: &apos;frame1.html&apos;,
    bgColor: &apos;#fff&apos;
}, {
    name: &apos;frame2&apos;,
    url: &apos;frame2.html&apos;,
    bgColor: &apos;#fff&apos;
}]
}, function(ret, err) {            //回调函数
var index = ret.index;
});      
</code></pre><p>index2:</p>
<pre><code>apiready=function(){
    var test=api.pageParam.key;
    alert(test);
    }
</code></pre>]]></content>
      <categories>
        <category>Apicloud</category>
      </categories>
      <tags>
        <tag>Apicloud</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3-文本效果和字体</title>
    <url>/2019/11/04/CSS3-%E6%96%87%E6%9C%AC%E6%95%88%E6%9E%9C%E5%92%8C%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<h1 id="CSS3中的文字效果及字体"><a href="#CSS3中的文字效果及字体" class="headerlink" title="CSS3中的文字效果及字体"></a>CSS3中的文字效果及字体</h1><p>CSS3本来规定了较多的文字属性，但是大部分没有被实现，所以只介绍已经被实现的属性。</p>
<h2 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h2><p>text-shadow用于创建一个文字阴影，其参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;offset-x&gt;</td>
<td>x轴的偏移量</td>
</tr>
<tr>
<td>&lt;offset-y&gt;</td>
<td>y轴的偏移量</td>
</tr>
<tr>
<td>&lt;blur-radius&gt;</td>
<td>模糊半径</td>
</tr>
</tbody>
</table>
<p>example1:</p>
<pre><code>text-shadow: 5px 5px 5px #FF0000;
</code></pre><p><img src="\images\CSS3-文字效果-字体\text-shadow_exxample1.png" alt="text-shadow_exxample1"></p>
<h3 id="text-shadow案例"><a href="#text-shadow案例" class="headerlink" title="text-shadow案例"></a>text-shadow案例</h3><p>利用text-shdow的叠加，可以实现多种文字特效：</p>
<h4 id="火焰文字效果"><a href="#火焰文字效果" class="headerlink" title="火焰文字效果"></a>火焰文字效果</h4><p>关键：在文字外层加上多层黄色，红色的阴影，并且模糊程度越来越大，颜色的掌控很关键。否则可能不会很逼真。</p>
<pre><code>background:black;   
text-align:left;   
text-shadow: 0 -5px 4px #FF3,2px -10px 6px #fd3,-2px -15px 11px #f80,2px -25px 18px #f20;   
color:red;   
</code></pre><p><img src="\images\CSS3-文字效果-字体\text-shadow_flame.png" alt="text-shadow_flame"></p>
<h4 id="立体凸起效果"><a href="#立体凸起效果" class="headerlink" title="立体凸起效果"></a>立体凸起效果</h4><p>关键：将背景颜色与温习颜色设为一致，再设置一个白色的阴影，一个黑色的阴影，x轴分别偏移-1px，1px即可达到效果。</p>
<pre><code>text-shadow: -1px -1px white,1px 1px #333;   
color:#D1D1D1;   
font-weight: bold;   
background: #CCC;
</code></pre><p><img src="\images\CSS3-文字效果-字体\text-shadow_heave.png" alt="text-shadow_heave"></p>
<h4 id="立体凹下效果"><a href="#立体凹下效果" class="headerlink" title="立体凹下效果"></a>立体凹下效果</h4><p>关键：与凸起相似，但是将两个偏移量交换一下，即可实现凹下效果。</p>
<pre><code>text-shadow: 1px 1px white,-1px -1px #333;   
color:#D1D1D1;   
font-weight: bold;   
background: #CCC;   
</code></pre><p><img src="\images\CSS3-文字效果-字体\text-shadow_sag.png" alt="text-shadow_sag"></p>
<h4 id="描边效果"><a href="#描边效果" class="headerlink" title="描边效果"></a>描边效果</h4><p>关键：设置4个黑色的阴影，模糊度为0，分别向上下左右各偏移1px，即可实现描边效果。</p>
<pre><code>text-shadow: -1px 0 black,0 1px black,1px 0 black,0 -1px black;   
color:#ffffff;   
background: #CCC;   
</code></pre><p><img src="\images\CSS3-文字效果-字体\text-shadow_outline.png" alt="text-shadow_outline"></p>
<h4 id="外发光效果"><a href="#外发光效果" class="headerlink" title="外发光效果"></a>外发光效果</h4><p>关键：不要为阴影设置x，y的偏移量，增大模糊度，即可实现。</p>
<pre><code>text-shadow: 0 0 0.2em #F87,0 0 0.2em #f87;   
color:#d1d1d1;   
background: #CCC;   
</code></pre><p><img src="\images\CSS3-文字效果-字体\text-shadow_outLight.png" alt="text-shadow_outLight"></p>
<h4 id="3D效果"><a href="#3D效果" class="headerlink" title="3D效果"></a>3D效果</h4><p>关键：在同一方向上多次叠加颜色更深的阴影。</p>
<pre><code>color:white;
font-size: 200px;
text-shadow: 0 1px hsl(0,0%,85%),
        0 2px hsl(0,0%,80%),
        0 3px hsl(0,0%,75%),
        0 4px hsl(0,0%,70%),
        0 5px hsl(0,0%,65%),
        0 5px 10px black;
</code></pre><p><img src="\images\CSS3-文字效果-字体\text-shadow_3D.png" alt="text-shadow_3D"></p>
<h4 id="关于text-shadow"><a href="#关于text-shadow" class="headerlink" title="关于text-shadow"></a>关于text-shadow</h4><p>对于各种文字效果，如果我们认真分析文字附加效果的颜色及光影效果，我们可以利用text-shadow模拟出很多的文字效果。</p>
<h2 id="word-wrap-overflow-wrap"><a href="#word-wrap-overflow-wrap" class="headerlink" title="word-wrap/overflow-wrap"></a>word-wrap/overflow-wrap</h2><p>word-wrap又叫做overflow-wrap：</p>
<p>word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”。 稳定的谷歌 Chrome 和 Opera 浏览器版本支持这种新语法。</p>
<p>该属性含有一个参数，其可以有以下值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td>表示在正常的单词结束处换行。</td>
</tr>
<tr>
<td>break-word</td>
<td>表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。</td>
</tr>
</tbody>
</table>
<h2 id="CSS3-font-face-规则"><a href="#CSS3-font-face-规则" class="headerlink" title="CSS3 @font-face 规则"></a>CSS3 @font-face 规则</h2><p>以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。</p>
<p>使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。</p>
<p>当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。</p>
<p>您所选择的字体在新的 CSS3 版本有关于 @font-face 规则描述。</p>
<p>您”自己的”的字体是在 CSS3 @font-face 规则中定义的。</p>
<p>实例：</p>
<pre><code>&lt;style&gt; 
@font-face
{
    font-family: myFirstFont;
    src: url(sansation_light.woff);
}

div
{
    font-family:myFirstFont;
}
&lt;/style&gt;
</code></pre><p>在font-family中，还可以定义字体的其他属性：</p>
<p><img src="\images\CSS3-文字效果-字体\@font-face_key_value.png" alt="@font-face_key_value"></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>通过text-shadow和自定义字体，我们可以实现多种我们想要的字体效果了！结合上一章的背景，网页肯定能换发生机！</p>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>text-shadow</tag>
        <tag>word-wrap</tag>
        <tag>overflow-wrap</tag>
        <tag>font-face</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3-转换</title>
    <url>/2019/11/05/CSS3-%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="CSS3中的转换"><a href="#CSS3中的转换" class="headerlink" title="CSS3中的转换"></a>CSS3中的转换</h1><p>CSS3中的转换可以形成简单的动画，对于页面的小优化有点金的效果。</p>
<p>CSS3中的转换都在<strong>transform</strong>属性中定义，在该属性中定义其他函数来进行不同的转换。</p>
<h2 id="CSS3的2D转换"><a href="#CSS3的2D转换" class="headerlink" title="CSS3的2D转换"></a>CSS3的2D转换</h2><h3 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h3><p>该函数接受两个参数，分别是其x，y轴的偏移量，右下为正方向。</p>
<pre><code>transform:translate(50px,100px);
</code></pre><p>将原元素向右、下移动50px、100px。</p>
<p>如果只填一个参数，则默认为x轴偏移。</p>
<pre><code>transform:translate(50px);
</code></pre><p>向x轴移动50px;</p>
<pre><code>transform:translate(0,100px);
</code></pre><p>向y轴移动100px；</p>
<h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h3><p>该函数接受一个参数，确定偏移的角度，正值为顺时针，负值即为逆时针。</p>
<pre><code>transform: rotate(30deg);//顺时针30度
transform: rotate(-30deg);//逆时针30度
</code></pre><h3 id="scale"><a href="#scale" class="headerlink" title="scale()"></a>scale()</h3><p>该函数接受两个参数，分别为x轴的倍数，y轴的倍数。</p>
<pre><code>scale(2,3);
</code></pre><p>将容器宽度放大2倍，高度放大3倍。</p>
<h3 id="skew"><a href="#skew" class="headerlink" title="skew()"></a>skew()</h3><p>通过 skew() 方法，元素将偏斜相应的角度，注意这个偏斜与rotate(旋转)不同，<strong>skew将会绕x,y轴偏斜x,y度，观察到的肉眼的形状会改变！</strong>比如只偏斜某一轴，则原元素会变成一个平行四边形。(与其他转换一样，其内容也会做对应的变换)</p>
<pre><code>transform: skew(30deg);
</code></pre><p><img src="\images\CSS3-转换\skew_x.png" alt="skew_x"></p>
<pre><code>transform: skew(0deg,30deg);
</code></pre><p><img src="\images\CSS3-转换\skew_y.png" alt="skew_y"></p>
<pre><code>transform: skew(30deg,30deg);
</code></pre><p><img src="\images\CSS3-转换\skew_xy.png" alt="skew_xy"></p>
<h3 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h3><p>matrix() 方法把所有 2D 转换方法组合在一起。默认值为：<code>transforms:matrix(1,0,0,1,0,0);</code></p>
<p>matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。</p>
<p>matrix原意是矩阵，所以这六个参数分别是矩阵的6个位置的值：</p>
<pre><code>matrix(a,b,c,d,e,f)
</code></pre><p><img src="\images\CSS3-转换\matrix1.jpg" alt="matrix1"></p>
<p>也就是利用这个矩阵与原容器做运算后获得新位置。</p>
<p><img src="\images\CSS3-转换\maxtrixCal.jpg" alt="maxtrixCal"></p>
<p>所以我们运算过后的结果就是：</p>
<p>x’=ax+cy+e</p>
<p>y’=bx+dy+f</p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p>所以根据这个式子，我们可以推算如果要对元素进行x轴移动，则x’直接增大固定数值，即改变<strong>e</strong>的值：</p>
<ol>
<li><p>向x轴移动10px，y不变</p>
<p> matrix(1,0,0,1,10,0)</p>
</li>
<li><p>向x,y轴都移动10px</p>
<p> matrix(1,0,0,1,10,10)</p>
</li>
</ol>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>缩放的实质就是奖x，y轴的数值放大n倍，即：</p>
<p>x’=2y</p>
<p>y’=2x</p>
<p>对于上面的：</p>
<p>x’=ax+cy+e</p>
<p>y’=bx+dy+f</p>
<p>可得到：</p>
<p>nx = ax+cy+e</p>
<p>ny = bx+dy+f</p>
<p>易得：</p>
<p>a = n<br>b = 0<br>c = 0<br>d = n<br>e = 0<br>f = 0</p>
<p>即，<strong>进行缩放的话，我们只需要修改a,d的值以修改宽,高的缩放程度</strong></p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>利用极坐标，我们可以算出偏移角度与元素某点的坐标的关系。</p>
<p><img src="\images\CSS3-转换\matrix_rotate.png" alt="matrix_rotate"></p>
<p>根据原理图得：</p>
<p><img src="\images\CSS3-转换\matrix_rotate1.png" alt="matrix_rotate1"></p>
<p>推算可以得到：</p>
<p><img src="\images\CSS3-转换\matrix_rotate2.png" alt="matrix_rotate2"></p>
<p>所以，我们得：</p>
<p>a = cosθ</p>
<p>b = -sinθ</p>
<p>d = sinθ</p>
<p>e = cosθ</p>
<p>所以改变abde，即可实现旋转。</p>
<h4 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h4><p>同样由数学知识</p>
<p><img src="\images\CSS3-转换\maxtrix_skew.png" alt="maxtrix_skew.png"></p>
<p>即：</p>
<p>b = tanθx<br>e = tanθy</p>
<p>所以，skew操作只与b、e相关。</p>
<p>不过如果不是利用CSS3来做一些复杂的变换，可以用这种方式来减少代码。否则最好不要使用这个函数，因为它可能会使你的调试复杂困难。</p>
<h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin()"></a>transform-origin()</h3><p>该属性确定转换的基点位置。</p>
<p>example:</p>
<pre><code>transform-origin:20px 20px;
</code></pre><p>规定变换的基点为：(x=)20px (y=)20px</p>
<p>其值可以为：</p>
<ul>
<li>left</li>
<li>center</li>
<li>right</li>
<li>length</li>
<li>%</li>
</ul>
<h2 id="CSS3的3D转换"><a href="#CSS3的3D转换" class="headerlink" title="CSS3的3D转换"></a>CSS3的3D转换</h2><p>我们在2D之中，我们看过“translate，scale，rotate”这三个变换属性。在3D变换中，这三个属性被拆分3个方向的分属性：</p>
<p><img src="\images\CSS3-转换\3d-rays.png" alt="3d-rays"></p>
<ol>
<li><p>translate()</p>
<ul>
<li>translateX()</li>
<li>translateY()</li>
<li>translateZ()</li>
</ul>
</li>
<li><p>scale()</p>
<ul>
<li>scaleX()</li>
<li>scaleY()</li>
<li>scaleZ()</li>
</ul>
</li>
<li><p>ratate()</p>
<ul>
<li>rotateX()</li>
<li>rotateY()</li>
<li>rotateZ()</li>
</ul>
</li>
</ol>
<p>每个方向上的分量分别是沿某一轴变换。比如：translateX(120)表示沿X轴正方向移动120px。</p>
<p>另外3D还有几个属性：</p>
<h4 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h4><p>CSS 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。</p>
<table>
<thead>
<tr>
<th>flat</th>
<th>设置元素的子元素位于该元素的平面中。</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>preserve-3d</td>
<td>指示元素的子元素应位于 3D 空间中。</td>
</tr>
</tbody>
</table>
<p><img src="\images\CSS3-转换\transform-style.png" alt="transform-style"></p>
<h4 id="perspective-origin"><a href="#perspective-origin" class="headerlink" title="perspective-origin"></a>perspective-origin</h4><p>perspective-origin属性也可以有3参数方式，第三个值为Z值。</p>
<h4 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h4><p>backface-visibility 属性定义当元素不面向屏幕时是否可见。</p>
<p><img src="\images\CSS3-转换\backface-visibible.png" alt="backface-visibible"></p>
<h4 id="perspective-amp-amp-perspective-origin"><a href="#perspective-amp-amp-perspective-origin" class="headerlink" title="perspective&amp;&amp;perspective-origin"></a>perspective&amp;&amp;perspective-origin</h4><p>perspective 属性定义 3D 元素距视图的距离，以像素计。(类似于AE相机中的属性值)。</p>
<p>当为元素定义 perspective 属性时，<strong>其子元素会获得透视效果，而不是元素本身。</strong></p>
<p>元素添加perspective属性后，可再添加perspec-origin控制观察位置(类似与AE中的相机的x,y位置)。</p>
<p>注释：<strong>perspective 属性只影响 3D 转换元素</strong>。</p>
<pre><code>.father{
width:400px;
height:400px;
perspective:120px;
perspective-origin:10px 10px;
background-color:blue;
margin: 60px;
}
.son{
margin:60px ;
width:120px;
height:120px;
background-color:gray;
transform: rotateX(30deg);
}
</code></pre><p>我们观察当perspective-origin值与perspective值改变时，元素发生的变化。</p>
<p><img src="\images\CSS3-转换\perspective.gif" alt="perspective"></p>
<p>可以明显看出，当perspective值改变的时候，相当于我们视觉的位置与元素的距离发生了改变。而当perspective-origin发生改变的时候，我们是视觉的x，y位置发生了改变，所以我们看到元素的形状及其位置发生了改变。</p>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>CSS3中的3D变换算是一门学问，下一章解析过渡的时候一起再解析一下，让自己多理解一下。</p>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>transform</tag>
        <tag>translate()</tag>
        <tag>scale()</tag>
        <tag>rotate()</tag>
        <tag>skew()</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3过渡与动画</title>
    <url>/2019/11/18/CSS3%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="CSS3-过渡"><a href="#CSS3-过渡" class="headerlink" title="CSS3-过渡"></a>CSS3-过渡</h1><p> CSS3中，我们为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript。 使用transition属性，CSS3会自动为属性的变化来添加过渡样式。这个属性一般可以用在<code>:hoevr</code> <code>:active</code>等伪元素切换。</p>
<p>transition也是一个复合属性：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tag</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>:transition-property ransition-duration transition-timing-function transition-delay;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称。</td>
</tr>
<tr>
<td>transition-duration</td>
<td>定义过渡效果花费的时间。默认是 0。</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线。默认是 “ease”。</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始。默认是 0。</td>
</tr>
</tbody>
</table>
<h2 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h2><p>该属性用于定义需要渐变的CSS属性，比如<code>color</code> <code>width</code>等。</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>没有过渡动画。</td>
</tr>
<tr>
<td>all</td>
<td>所有可被动画的属性都表现出过渡动画。</td>
</tr>
<tr>
<td>IDENT</td>
<td>性名称。由小写字母 <code>a</code> 到 <code>z</code>，数字 <code>0</code> 到 <code>9</code>，下划线（<code>_</code>）和破折号（<code>-</code>）。第一个非破折号字符不能是数字。同时，不能以两个破折号开头。</td>
</tr>
</tbody>
</table>
<h2 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a>transition-duration</h2><p>该属性定义渐变的时间，要带单位（s,ms）。</p>
<h2 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h2><p>这个属性是过渡的核心。引用MDN官方的描述：</p>
<p> CSS属性受到 <a href="https://developer.mozilla.org/en-US/docs/CSS/Tutorials/Using_CSS_transitions" target="_blank" rel="noopener">transition effect</a>的影响，会产生不断变化的中间值，而 <a href="https://developer.mozilla.org/en-US/docs/CSS" target="_blank" rel="noopener">CSS</a> <code>transition-timing-function</code> 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变。 </p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>linear</td>
<td>规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td>
</tr>
<tr>
<td>ease</td>
<td>规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。</td>
</tr>
<tr>
<td>ease-in</td>
<td>规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。</td>
</tr>
<tr>
<td>ease-out</td>
<td>规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。</td>
</tr>
<tr>
<td>cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</td>
</tr>
<tr>
<td>step-start</td>
<td>直接跳到结束处</td>
</tr>
<tr>
<td>step-end</td>
<td>transition-duration</td>
</tr>
<tr>
<td>steps()</td>
<td>步进函数将过渡时间分成大小相等的时间时隔来运行<br/>没有过度效果，而是一帧一帧的变化，integer等于几就分成几帧，阶跃函数</td>
</tr>
</tbody>
</table>
<h2 id="steps-函数"><a href="#steps-函数" class="headerlink" title="steps()函数"></a>steps()函数</h2><p><code>steps(&lt;integer&gt;[,start| end]?)</code></p>
<p> <integer>:用于指定间隔个数（该值只能是正整数） 第二个参数可选，默认是end,表示开始值保持一次，若参数为start，表示开始值不保持 </p>
<p><code>end</code>:用于指定在step中间隔数少于该有的变化次数时，因该丢弃前面的部分还是后面的部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">即每个关键帧都分成两次变化完成，则一共有七次变化。</span><br><span class="line">七帧      一共变化七次，  div本身没有颜色，所以最终的背景无色。但是，只变化七次，有七种颜色，加上无色，一种八种状态，所以需要丢弃一种状态</span><br><span class="line"></span><br><span class="line">start   橙、黄、灰、蓝、深灰蓝、绿、无色         </span><br><span class="line">原理：去掉第一帧的效果，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>    红、橙、黄、灰、蓝、深灰蓝、无色</span><br><span class="line">原理：去掉最后一帧的效果</span><br></pre></td></tr></table></figure>
<h2 id="cubic-bezier-n-n-n-n"><a href="#cubic-bezier-n-n-n-n" class="headerlink" title="cubic-bezier(n,n,n,n)"></a>cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</h2><p>贝塞尔曲线函数的四个值，具体原理后面研究一下再写一篇博客。</p>
<h2 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h2><p> CSS的<strong>transition-delay</strong>属性规定了在过渡效果开始作用之前需要等待的时间。 </p>
<p> 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 </p>
<p>下面写个例子</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">transition</span>:all <span class="number">0.5s</span> ease <span class="number">1s</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码设定在鼠标划过时，所有的属性在1s后开始过渡，过渡时间为0.5s，过渡方式为ease。</p>
<h1 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h1><p>CSS3中，我们可以用2个属性来定义函数。</p>
<ul>
<li>@keyframes</li>
<li>animation</li>
</ul>
<p>利用这两个属性可以制作简单或复杂的CSS东阿虎</p>
<h2 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h2><p> <code>@keyframes</code> 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。这比<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transitions" target="_blank" rel="noopener">转换</a>更能控制动画序列的中间步骤。</p>
<p>Point：</p>
<ol>
<li><p>如果一个关键帧规则没有指定动画的开始或结束状态（也就是，<code>0%</code>/<code>from</code> 和<code>100%</code>/<code>to</code>，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。 </p>
</li>
<li><p>如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 </p>
</li>
<li><p>如果多个关键帧使用同一个名称，以最后一次定义的为准。 <code>@keyframes</code> 不存在层叠样式(cascade)的情况，所以动画在一个时刻（阶段）只会使用一个的关键帧的数据。</p>
<p>如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 因为<code>@keyframes</code> 的规则不存在层叠样式(cascade)的情况，即使多个关键帧设置相同的百分值也不会全部执行。</p>
</li>
<li></li>
</ol>
<p>如果某一个关键帧出现了重复的定义，且重复的关键帧中的css属性值不同，以最后一次定义的属性为准。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> identifier &#123;</span><br><span class="line">  0% &#123; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0px</span>&#125;</span><br><span class="line">  50% &#123; <span class="attribute">top</span>: <span class="number">30px</span>; <span class="attribute">left</span>: <span class="number">20px</span>; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">top</span>: <span class="number">10px</span>; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">30px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子中，<code>50%</code> 关键帧中设置的属性<code>top: 10px</code>是有效的，但是其他的属性会被忽略</p>
<ol start="5">
<li>关键帧中出现的 !important 关键词将会被忽略</li>
</ol>
<p>@keyframes格式如下：</p>
<p>@keyframes 动画名字 {</p>
<p>​    阶段名:{</p>
<p>​        元素属性</p>
<p>​    }</p>
<p>}</p>
<p>其中阶段名可以<strong>百分比</strong>或者<strong>from/to</strong></p>
<p>example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> mykeyframes</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就新建了一个动画关键帧，现在我们就需要使用<code>animation</code>将其添加到对应的元素上。</p>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>过渡</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3-背景</title>
    <url>/2019/10/29/CSS3-%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<h1 id="background"><a href="#background" class="headerlink" title="background"></a>background</h1><p>CSS中，background是一个复合属性，是以下单属性的符合属性：</p>
<ul>
<li>background-color</li>
<li>background-position</li>
<li>background-size</li>
<li>background-repeat</li>
<li>background-origin</li>
<li>background-clip</li>
<li>background-attachment</li>
<li>background-image</li>
</ul>
<p>其格式如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</span><br></pre></td></tr></table></figure>
<h2 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h2><p>background-color属性设置一个元素的背景颜色。</p>
<p>元素的背景是元素的总大小，包括填充和边界（但不包括边框）。</p>
<p>example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span><span class="selector-pseudo">:yellow</span>;</span><br></pre></td></tr></table></figure>
<p>其属性支持以下内容：</p>
<ol>
<li>颜色关键值，如：red,blue…</li>
<li>Hex颜色值，如：#bbff00…</li>
<li>Hex含透明颜色值，如：#ffbb0036;（最后两位表示透明度，ff则为不透明，可省略，则变为普通Hex）</li>
<li>RGB颜色值，如：rgb(255,255,255)</li>
<li>RGBA颜色值，RGB可透明的颜色值，如：rgba(55,56,125,0.5)，透明度为0.5</li>
<li>特殊值：<ol>
<li>currentColor：该值是CSS3新增的一个颜色关键字，等会详细介绍。</li>
<li>transparent：透明背景</li>
</ol>
</li>
<li>全局变量：<ol>
<li>inherit：继承上一级的背景颜色。（注意，该值可用于所有的CSS属性）</li>
<li>initial：设置背景色的为默认值（每一个CSS属性都有一个默认值，有些为none，则设置没有效果），此属性可用于清除父级的继承属性。如p标签中的span标签的文字颜色继承问题。</li>
<li>unset：如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。换句话说这个unset关键字会优先用 inherit 的样式，其次会应该用initial的样式。</li>
</ol>
</li>
</ol>
<h3 id="currentColor关键字"><a href="#currentColor关键字" class="headerlink" title="currentColor关键字"></a>currentColor关键字</h3><p>CSS新增了currentColor关键字</p>
<p>currentColor代表了当前元素被应用上的color颜色值。 使用它可以将当前这个颜色值应用到其他属性上，或者嵌套元素的其他属性上。并且该属性会继承上级属性值。</p>
<p>example1:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:red;</span><br><span class="line">	background-color:currentColor; //此时currentColor=red;</span><br><span class="line">	<span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span><br><span class="line">	<span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exmaple2:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fatherBox</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sonBox</span>&#123;</span><br><span class="line">	background-color:currentColor;//此时currentColor继承父级的color属性，为red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h2><p>其属性有以下内容：</p>
<ol>
<li>url():该函数接受一个地址作为背景图片的url，可以是本地地址，也可以是网络地址。</li>
<li>color值：<code>&lt;rgb()&gt; | &lt;rgba()&gt; | &lt;hsl()&gt; | &lt;hsla()&gt; | &lt;hex-color&gt; | &lt;named-color&gt; | currentcolor | &lt;deprecated-system-color&gt;</code></li>
<li>linear-gradient():该函数用于生成一个线性渐变。</li>
<li>radial-gradient()：该函数用于生成一个径向渐变。</li>
<li>repeating-linear-gradient()：该函数用于生成一个重复的线性渐变</li>
<li>repeating-radial-gradient()：该函数用于生成一个重复的线性渐变。</li>
<li>关键字：inherit(从父级继承)</li>
</ol>
<h3 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient()"></a>linear-gradient()</h3><p>CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于<gradient>数据类型，是一种特别的<image>数据类型。</p>
<p>其参数有以下几个：</p>
<ol>
<li>angle：角度，可为以下值：<ol>
<li>角度值deg，如<code>45deg</code>，<code>-120deg</code>,方向递增方向为顺时针方向。</li>
<li>角度关键字，如，<code>to left</code>，<code>to bottom right</code>，这些关键字等同于相应的角度，如<code>to top</code> = <code>0deg</code>，<code>to right</code> = <code>90deg</code>，<code>to bottom right</code> = <code>135deg</code></li>
</ol>
</li>
</ol>
<p><img src="\images\CSS3-背景\linear-gradient_position.png" alt="linear-gradient_position"></p>
<ol start="2">
<li>color-stop:结束位置颜色值（渐变开始位置）,<ol>
<li>包含颜色及结束位置，如<code>red 30%</code>，<code>blue 50%</code></li>
<li>只包含颜色值，如<code>red</code>,<code>rgb(123,45,26)</code>，此时每一个颜色会被设置默认的结束位置值，即按颜色均分该区域。如，<code>red blue</code> = <code>red 0%,blue 100%</code></li>
</ol>
</li>
</ol>
<p><strong>值得注意的是，每个颜色结束位置之间的距离就是这两个颜色渐变的距离</strong></p>
<p>如：</p>
<ol>
<li><code>red 0%,blue 100%</code>，那么红色与蓝色在之间的渐变距离即为100%</li>
</ol>
<p><img src="\images\CSS3-背景\linear-gradient_ex1.png" alt="linear-gradient_ex1"></p>
<ol start="2">
<li><code>red 0%,blue 50%,brown 100%</code>，那么红色与蓝色之间的渐变距离则为50%，蓝色与棕色之间的渐变距离也为50%。</li>
</ol>
<p><img src="\images\CSS3-背景\linear-gradient_ex2.png" alt="linear-gradient_ex2"></p>
<p><strong>仔细思考一下会发现，如果两个颜色之间的渐变距离为0，那么他们之间的就不会有渐变，再利用角度的可改变与多次使用该属性，即可实现绘制图形</strong></p>
<p>比如：</p>
<ol>
<li><p>条形背景：</p>
<p>   background: linear-gradient(90deg,rgb(153, 153, 153) 50%,rgb(105, 105, 105) 50%);<br>   background-size: 20%;<br>   background-repeat: repeat;</p>
</li>
</ol>
<p><img src="\images\CSS3-背景\linear-gradient_stripe1.png" alt="linear-gradient_stripe1"></p>
<ol start="2">
<li><p>切角效果</p>
   <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(45<span class="selector-tag">deg</span>,<span class="selector-tag">red</span> 10%,<span class="selector-tag">transparent</span> 10%),</span><br><span class="line">         	  <span class="selector-tag">linear-gradient</span>(135<span class="selector-tag">deg</span>,<span class="selector-tag">red</span> 10%,<span class="selector-tag">transparent</span> 10%),</span><br><span class="line">        	  <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">-45deg</span>,<span class="selector-tag">red</span> 10%,<span class="selector-tag">transparent</span> 10%),</span><br><span class="line">       	  <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">-135deg</span>,<span class="selector-tag">red</span> 10%,<span class="selector-tag">transparent</span> 10%);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="\images\CSS3-背景\linear-gradient_corner.png" alt="linear-gradient_corner"></p>
<ol start="3">
<li><p>折角效果</p>
   <figure class="highlight"><table><tr><td class="code"><pre><span class="line">background:linear-gradient(-135deg,transparent 51%,rgba(0, 0, 0, 0.178)51%) no-repeat 100% 0 / 6em 6em,</span><br></pre></td></tr></table></figure>
<p>   linear-gradient(-135deg,transparent 10%,rgb(169, 169, 233) 10%);      </p>
</li>
</ol>
<p><img src="\images\CSS3-背景\linear-gradient_fold1.png" alt="linear-gradient_fold1"></p>
<p>利用其线性切割+重复性，可以实现多种图案，只要想象力足够，唯一需要考虑的就是性能问题，如果通过其绘制过于复杂的线性动画导致页面性能损失，那也是得不偿失的。</p>
<h3 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial-gradient()"></a>radial-gradient()</h3><p>该函数接受5个属性：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;size&gt;</td>
<td>整个渐变的尺寸大小，如果设置为circle,则可以在前面通过”100px”，”10%”的格式设置其半径，radius；如果设置为ellipse，则可以在前面通过”100px 200px”,”10% 20%”的格式设置其短半径与长半径的值。</td>
<td>绝对单位数值，如100px。相对单位数值，如20%</td>
</tr>
<tr>
<td>&lt;extent-keyword&gt;</td>
<td>此关键字的词用于确定渐变最外侧的边与哪个边相切，或与哪个角相距。实际上也是确定半径，所以也可以通过size属性直接设置半径。</td>
<td>见下表</td>
</tr>
<tr>
<td>&lt;shape&gt;</td>
<td>渐变的形状。圆形（渐变的形状是一个半径不变的正圆）或椭圆形（轴对称椭圆）。默认值为椭圆。椭圆半径与容器的长宽比例相同。</td>
<td>redius：绝对单位数值，如100px；shape：’circle’,’ellipse’</td>
</tr>
<tr>
<td>&lt;position&gt;</td>
<td>渐变圆的圆心位置</td>
<td>一般在前面加上 at 关键字 ， 绝对单位数值，如100px。相对单位数值，如20%</td>
</tr>
<tr>
<td>&lt;color-stop&gt;</td>
<td>渐变的颜色及其渐变结束位置</td>
<td>color:Hex值，rgb值，rgba值，颜色关键字；stop：绝对单位数值，如100px。相对单位数值，如20%</td>
</tr>
</tbody>
</table>
<p><extent-keyword>关键字</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>closest-side</td>
<td>渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。</td>
<td>closest-side</td>
<td>渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。</td>
</tr>
<tr>
<td>closest-corner</td>
<td>渐变的边缘形状与容器距离渐变中心点最近的一个角相交。</td>
<td>closest-corner</td>
<td>渐变的边缘形状与容器距离渐变中心点最近的一个角相交。</td>
</tr>
<tr>
<td>farthest-side</td>
<td>与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。</td>
<td>farthest-side</td>
<td>与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。</td>
</tr>
<tr>
<td>farthest-corner</td>
<td>渐变的边缘形状与容器距离渐变中心点最远的一个角相交。</td>
<td>farthest-corner</td>
<td>渐变的边缘形状与容器距离渐变中心点最远的一个角相交。</td>
</tr>
</tbody>
</table>
<h4 id="radial-gradient-基本应用"><a href="#radial-gradient-基本应用" class="headerlink" title="radial-gradient()基本应用"></a>radial-gradient()基本应用</h4><p>example1(自己设置半径)：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(100<span class="selector-tag">px</span> 150<span class="selector-tag">px</span> <span class="selector-tag">ellipse</span> <span class="selector-tag">at</span> 200<span class="selector-tag">px</span> 250<span class="selector-tag">px</span>,<span class="selector-tag">yellow</span> 50%,<span class="selector-tag">red</span> 70%);</span><br><span class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\radial-gradient_base1.png" alt="radial-gradient_base1"></p>
<p>example2(用关键字)：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    <span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">closest-side</span> <span class="selector-tag">ellipse</span> <span class="selector-tag">at</span> 200<span class="selector-tag">px</span> 250<span class="selector-tag">px</span>,<span class="selector-tag">yellow</span> 50%,<span class="selector-tag">red</span> 70%);</span><br><span class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\radial-gradient_base2.png" alt="radial-gradient_base2"></p>
<h4 id="radial-gradient-高级应用"><a href="#radial-gradient-高级应用" class="headerlink" title="radial-gradient()高级应用"></a>radial-gradient()高级应用</h4><p>与radial-gradient一样，如果设置两个结束颜色的渐变距离为0或为负值，则可形成径向切割，以此构成多样化的图形。</p>
<p>如：</p>
<p>example1(内凹角)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(100<span class="selector-tag">px</span> <span class="selector-tag">circle</span> <span class="selector-tag">at</span> 0 0,<span class="selector-tag">transparent</span> 50%,<span class="selector-tag">red</span> 50%);</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\radial-gradient_high1.png" alt="radial-gradient_high1"></p>
<p>但是我们一般会想要多个内凹圆角，当我们简单的将多个radial-gradient堆起来就会发现前一个背景无论如何都会把后面的背景给覆盖掉。所以我们最好的办法是结合background-size,backround-position,background-repeat结合起来，形成多个不叠加的背景！</p>
<p>example2(两个内凹角)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 100% / 50% 100%,</span><br><span class="line"> radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 100%;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\radial-gradient_high2.png" alt="radial-gradient_high2"></p>
<p>example3(四个内凹角)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">   background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 0% / 50% 50%,</span><br><span class="line">radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 0%/ 50% 50%,</span><br><span class="line">radial-gradient(100px circle at 0 100%,transparent 50%,red 50%) no-repeat 0% 100%/ 50% 50%,</span><br><span class="line">radial-gradient(100px circle at 100% 100%,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 50%;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\radial-gradient_high3.png" alt="radial-gradient_high3"></p>
<h3 id="repeating-linear-gradient"><a href="#repeating-linear-gradient" class="headerlink" title="repeating-linear-gradient()"></a>repeating-linear-gradient()</h3><p>repeating-linear-gradient() 函数用于创建重复的线性渐变 “图像”。该属性的参数与linear-gradient()相同，所以不在赘述。</p>
<p>由于可以重复的组成背景图形，因此用处更多，条形背景是一个典型的应用。</p>
<p>example1:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">repeating-linear-gradient</span>(<span class="selector-tag">yellow</span> 0%,<span class="selector-tag">yellow</span> 10%,<span class="selector-tag">black</span> 10%,<span class="selector-tag">black</span> 20%);</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\repeat-linear-gradient_high1.png" alt="repeat-linear-gradient_high1"></p>
<p>example2:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    <span class="selector-tag">background</span>: <span class="selector-tag">repeating-linear-gradient</span>(<span class="selector-tag">rgba</span>(255, 255, 0, 0<span class="selector-class">.397</span>) 0%,<span class="selector-tag">rgba</span>(255, 255, 0, 0<span class="selector-class">.397</span>) 10%,<span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.26</span>)</span><br><span class="line">10%,<span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.26</span>) 20%),</span><br><span class="line"><span class="selector-tag">repeating-linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>,<span class="selector-tag">rgba</span>(255, 255, 0, 0<span class="selector-class">.397</span>) 0%,<span class="selector-tag">rgba</span>(85, 243, 36, 0<span class="selector-class">.397</span>) 10%,<span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.26</span>)</span><br><span class="line">10%,<span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.26</span>) 20%);</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\repeat-linear-gradient_high2.png" alt="repeat-linear-gradient_high2"></p>
<h3 id="repeating-radial-gradient"><a href="#repeating-radial-gradient" class="headerlink" title="repeating-radial-gradient()"></a>repeating-radial-gradient()</h3><p>repeating-radial-gradient()用于创建多个repeating-radial原点辐射。参数与repeating-radial()一致。</p>
<p>example1:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    <span class="selector-tag">background</span>: <span class="selector-tag">repeating-radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">rgb</span>(146, 146, 146) 0, <span class="selector-tag">rgb</span>(146, 146, 146) 2%, <span class="selector-tag">black</span></span><br><span class="line">2%,<span class="selector-tag">black</span> 4%);</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\repeat-radial-gradient_high1.png" alt="repeat-radial-gradient_high1"></p>
<h3 id="渐变综合应用"><a href="#渐变综合应用" class="headerlink" title="渐变综合应用"></a>渐变综合应用</h3><p>用渐变生成一个复古胶盘：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">color</span>: cadetblue;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>:</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">30deg</span>, transparent <span class="number">40%</span>, rgba(<span class="number">42</span>, <span class="number">41</span>, <span class="number">40</span>, .<span class="number">85</span>) <span class="number">40%</span>) no-repeat <span class="number">100%</span> <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">60deg</span>, rgba(<span class="number">42</span>, <span class="number">41</span>, <span class="number">40</span>, .<span class="number">85</span>) <span class="number">60%</span>, transparent <span class="number">60%</span>) no-repeat <span class="number">0</span> <span class="number">100%</span>,</span><br><span class="line">    <span class="built_in">repeating-radial-gradient</span>(#<span class="number">2</span>a2928, #<span class="number">2</span>a2928 <span class="number">4px</span>, #ada9a0 <span class="number">5px</span>, #<span class="number">2</span>a2928 <span class="number">6px</span>);</span><br><span class="line">  <span class="attribute">background-size</span>:<span class="number">50%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">50%</span>, <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box3</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">50%</span>; <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">margin</span>: -<span class="number">35px</span>;</span><br><span class="line">   <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#d9a388</span>;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">68px</span>; <span class="attribute">height</span>: <span class="number">68px</span>;</span><br><span class="line">   <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4px</span> <span class="number">#da5b33</span>, inset <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">27px</span> <span class="number">#da5b33</span>;</span><br><span class="line">   <span class="attribute">background</span>: <span class="number">#b5ac9a</span>;</span><br><span class="line">   <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\gradient_summary.png" alt="gradient_summary"></p>
<h2 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h2><p>background-size 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。</p>
<p>其参数有以下内容：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;length&gt;</td>
<td>&lt;length&gt; 值，比如10px,10em…指定背景图片大小，不能为负值。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;percentage&gt;</td>
<td>&lt;percentage&gt; 值，如10%，指定背景图片相对背景区（background positioning area）的百分比。背景区由background-origin设置，默认为盒模型的内容区与内边距，也可设置为只有内容区，或者还包括边框。如果attachment 为fixed，背景区为浏览器可视区（即视口），不包括滚动条。不能为负值。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>auto</td>
<td>以背景图片的比例缩放背景图片。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>cover</td>
<td>缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>contain</td>
<td>缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>inherit/initial/unset</td>
<td>继承父级该属性的值/默认值/如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。</td>
<td></td>
</tr>
</tbody>
</table>
<p>注意，</p>
<ol>
<li><p>如果其值为&lt;length&gt;时，则可以分别设置其宽高，如：</p>
<p> background-size: 50% 25%;</p>
</li>
<li><p>如果background有多个值，那么在background-size就可以有多个值，并且与其一一对应。</p>
<p> background-size: 50% 25%, contain, 3em; //有3个背景图片</p>
</li>
</ol>
<h2 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h2><p>background-origin 规定了指定背景图片background-image 属性的原点位置的背景相对区域.</p>
<p>参数如下：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>border-box</td>
<td>背景图片的摆放以border区域为参考</td>
</tr>
<tr>
<td>padding-box</td>
<td>背景图片的摆放以padding区域为参考</td>
</tr>
<tr>
<td>content-box</td>
<td>背景图片的摆放以content区域为参考</td>
</tr>
</tbody>
</table>
<p>下面是效果图：</p>
<p><img src="\images\CSS3-背景\background-origin_border-box.png" alt="background-origin_border-box"></p>
<p><img src="\images\CSS3-背景\background-origin_content-box.png" alt="background-origin_content-box"></p>
<p><img src="\images\CSS3-背景\background-origin_padding-box.png" alt="background-origin_padding-box"></p>
<h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p>background-clip  设置元素的背景（背景图片或颜色）是否延伸到边框或padding下面。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>border-box</td>
<td>背景延伸至边框外沿（但是在边框下层）。</td>
</tr>
<tr>
<td>padding-box</td>
<td>背景延伸至内边距（padding）外沿。不会绘制到边框处。</td>
</tr>
<tr>
<td>content-box</td>
<td>背景被裁剪至内容区（content box）外沿。</td>
</tr>
<tr>
<td>text</td>
<td>背景被裁剪成文字的前景色。（实验性属性，chrome需加上-webkit-前缀）</td>
</tr>
</tbody>
</table>
<p>下面是效果图：</p>
<p><img src="\images\CSS3-背景\background-clip_border-box.png" alt="background-clip_border-box"></p>
<p><img src="\images\CSS3-背景\background-clip_content-box.png" alt="background-clip_content-box"></p>
<p><img src="\images\CSS3-背景\background-clip_padding-box.png" alt="background-clip_padding-box"></p>
<p>example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-background-clip</span>: <span class="selector-tag">text</span>;</span><br><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">transparent</span>;</span><br><span class="line"><span class="selector-tag">font-size</span>: 200<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\background-clip_text.png" alt="background-clip_text"></p>
<h2 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-position</span> 为每一个背景图片设置初始位置。 这个位置是相对于由 <span class="selector-tag">background-origin</span> 定义的位置图层的。</span><br></pre></td></tr></table></figure>
<p>参数如下：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>center</td>
<td>用来居中背景图片。</td>
</tr>
<tr>
<td>top, left, bottom, right</td>
<td>用来指定把这个项目（原文为 item）放在哪一个边缘。另一个维度被设置成 50%，所以这个项目（原文为 item）被放在指定边缘的中间位置。</td>
</tr>
<tr>
<td>&lt;length&gt;</td>
<td>指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。</td>
</tr>
<tr>
<td>&lt;percentage&gt;</td>
<td>指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>该属性可以分别用两个值规定x,y的距离</strong></p>
<p>如：<br>example1：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-position</span>：50<span class="selector-tag">px</span> 50<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\background-position_example1.png" alt="background-position_example1"></p>
<p>也可以向自己规定的边的距离：</p>
<p>example2：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">right</span> 50<span class="selector-tag">px</span> <span class="selector-tag">bottom</span> 50<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\background-position_example2.png" alt="background-position_example2"></p>
<p>我们也可以使用关键词center来居中背景：</p>
<p>example3：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\background-position_example3.png" alt="background-position_example3"></p>
<p>如果我们规定一个关键词，另一个关键词则为center：</p>
<p>example4：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">left</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\background-position_example4.png" alt="background-position_example4"></p>
<p>如果我们将距离值设置为负值，那么背景就会偏离出容器内部，延时到容器的外部（不会显示出来）。</p>
<p>example5:</p>
<p><img src="\images\CSS3-背景\background-position_example5.png" alt="background-position_example5"></p>
<p><strong>注意：background还可以拆分为background-position-x与background-position-y，用来分别设置x，y轴的距离。虽然这是一个是实验性属性，不过大部分浏览器都实现了该方法，一般不会出问题</strong></p>
<h2 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h2><p>background-repeat CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。</p>
<p>其参数包含以下，并且每一个单参数都可以改写成双参数（x,y两个方向）的形式：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>含义</th>
<th>双值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>repeat</td>
<td>默认值，图像在水平方向和垂直方向都重复以填满容器</td>
<td>repeat repeat</td>
<td></td>
</tr>
<tr>
<td>repeat-x</td>
<td>图像只在水平方向重复以填满容器</td>
<td>repeat no-repeat</td>
<td></td>
</tr>
<tr>
<td>repeat-y</td>
<td>图像只在垂直方向重复以填满容器</td>
<td>no-repeat repeat</td>
<td></td>
</tr>
<tr>
<td>space</td>
<td>图像向两端对齐重复以填满容器，多余空间用空白代替</td>
<td>space space</td>
<td></td>
</tr>
<tr>
<td>round</td>
<td>图像向两端对齐重复以填满容器，多余空间通过图像拉伸来填充</td>
<td>round round</td>
<td></td>
</tr>
<tr>
<td>no-repeat</td>
<td>不重复，图像只显示一次</td>
<td>no-repeat no-repeat</td>
</tr>
</tbody>
</table>
<p><strong>注意round与space的区别</strong></p>
<p>round通过图片拉伸将容器内部全部填满：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">round</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\background-repeat_round.png" alt="background-repeat_round"></p>
<p>space将对应数量的背景填入容器，多余的空间将background-color的颜色填充。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">space</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\background-repeat_space.png" alt="background-repeat_space"></p>
<p><strong>并且我们可以通过双值的方式，分别设置想，x，y上的重复方式</strong></p>
<p>example1：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">space</span> <span class="selector-tag">round</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-背景\background-repeat_example1.png" alt="background-repeat_example1"></p>
<h2 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h2><p>background-attachment CSS 属性决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>fixed</td>
<td>此关键字表示背景相对于window窗口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</td>
</tr>
<tr>
<td>local</td>
<td>此关键字表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。</td>
</tr>
<tr>
<td>scroll</td>
<td>此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。</td>
</tr>
</tbody>
</table>
<p>fixed的效果：当fixed时，背景图随着容器位置的改变而改变，也就是说背景图是以window位置为基础的（可以想想象为：背景图已经铺满了window，该容器的位置会截取对应位置的一部分作为其背景图）。</p>
<p><img src="\images\CSS3-背景\background-attachment_fix.gif" alt="background-attachment_fix"></p>
<p>local效果：当local时，背景会随着容器的的滚动而滚动，但是其基准任然是容器（随着容器的位置的改变，背景的位置并没有改变）</p>
<p><img src="\images\CSS3-背景\background-attachment_local.gif" alt="background-attachment_local"></p>
<p>scroll效果：当scroll时，当我们滚动容器时，背景图不会改变；而且当容器位置改变时，背景图也没有发送改变（相对于容器），也就是说，此时背景是以容器为基准的。</p>
<p><img src="\images\CSS3-背景\background-attachment_scroll.gif" alt="background-attachment_scroll"></p>
<h3 id="给容器添加滚动条"><a href="#给容器添加滚动条" class="headerlink" title="给容器添加滚动条"></a>给容器添加滚动条</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">height</span><span class="selector-pseudo">:300px</span>;</span><br><span class="line"><span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">scroll</span>;</span><br></pre></td></tr></table></figure>
<p>添加此属性后，无论容器的内容是否超过300px，滚动条都会被添加；</p>
<p>如果设置：<br>        height:300px;<br>        width:300px;<br>        overflow: auto;</p>
<p>那么，如果容器的内容超过300px，滚动条才会被添加。</p>
<p>overflow属性同样是一个复合属性。它是<code>overflow-x</code>,<code>overflow-y</code>两个属性的复合属性。同样的是，overflow可以写两个值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span> <span class="selector-tag">scroll</span>;</span><br></pre></td></tr></table></figure>
<p>设置x轴为自动，y轴为添加滚动条时。</p>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>背景图这一部分的样式很有意思，特别是渐变那一部分，可以组成很多有趣的图形，不过这一部分内容还是多，需要多看多实践，才能深入掌握！</p>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>background</tag>
        <tag>background-color</tag>
        <tag>background-image</tag>
        <tag>background-size</tag>
        <tag>background-origin</tag>
        <tag>background-clip</tag>
        <tag>background-position</tag>
        <tag>background-repeat</tag>
        <tag>background-attachment</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP缓存</title>
    <url>/2021/03/11/HTTP%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="http缓存概念"><a href="#http缓存概念" class="headerlink" title="http缓存概念"></a>http缓存概念</h1><p>http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源（是否使用缓存还需其他策略进行验证）。</p>
<p>常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。</p>
<p>http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。</p>
<h1 id="http缓存的分类"><a href="#http缓存的分类" class="headerlink" title="http缓存的分类"></a>http缓存的分类</h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，<strong>不会再向服务器发送任何请求</strong>。强制缓存生效时，http状态码为200。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>直接使用本地缓存，不发送请求，因此响应速度快</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>可能无法及时更新服务器资源，造成站点资源的滞后更新</li>
</ul>
<h3 id="header字段"><a href="#header字段" class="headerlink" title="header字段"></a>header字段</h3><p>强缓存是通过http返回头部重的<code>Expires</code>或者<code>Cache-Control</code>两个字段来控制的。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><code>Expires</code></h4><p>该字段会返回一个绝对时间，表示该资源的失效时间，在这个时间之前，都可以直接使用缓存，即命中缓存。</p>
<p><img src="\images\HTTP缓存\Expires.png" alt="Expires"></p>
<p>比如上面的图即表示在2021年3月11日03:28:54之前该缓存都有效，即服务器可以使用强缓存，不再请求服务器。</p>
<p>但是这样的绝对时间也会存在问题，即浏览器在校验时间的时候，是根据client的本地时间来确定的，当本地时间与服务器差距较大时，可能存在问题。所以衍生了<code>Cache-Control</code></p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a><code>Cache-Control</code></h4><p>由于上面的问题，<code>Cache-Control</code>返回的就是一个相对时间，以秒为单位。由于是相对时间，并且开始就是和客户端时间相比的，所以即使客户端与服务端时间存在误差，也不会存在误差问题。</p>
<p>其可以是键值对或者一个单值：</p>
<p>单值是一个数字，如：Cache-Control:3600，代表缓存的有效期为3600s。</p>
<p>键值对包含以下属性：</p>
<ol>
<li><p><strong>max-age</strong> 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 * 60）天，第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。</p>
</li>
<li><p><strong>s-maxage</strong> 同 max-age，覆盖 max-age、Expires，但仅适用于共享缓存，在私有缓存中被忽略。</p>
</li>
<li><p><strong>public</strong> 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。</p>
</li>
<li><p><strong>private</strong> 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。</p>
</li>
<li><p><strong>no-cache</strong> 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。</p>
</li>
<li><p><strong>no-store</strong> 禁止缓存，每次请求都要向服务器重新获取数据。</p>
</li>
<li><p><strong>must-revalidate</strong>指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。</p>
</li>
</ol>
<p><img src="\images\HTTP缓存\cache-control.png" alt="cache-control"></p>
<p>比如上面的<code>Cache-Control</code>的<code>max-control</code>为<code>max-age=600</code>，即600s，10mins的有效期</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>（当强缓存不满足的时候）协商缓存即还需要向服务器发送一个请求，根据服务器的返回消息来决定是否使用缓存。即如果命中，则http返回304，浏览器从缓存中加载资源。其是根据返回信息的HTTP头部的<code>Last-Modify/If-Modify-Since或Etag/If-None-Match</code>来决定是否命中协商缓存。</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>时效性更高，根据服务器的返回消息决定是否使用缓存。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>载入速度相对会降低，因为会向服务器发送请求。</li>
</ul>
<h3 id="header字段-1"><a href="#header字段-1" class="headerlink" title="header字段"></a>header字段</h3><h4 id="Last-Modify-If-Modify-Since"><a href="#Last-Modify-If-Modify-Since" class="headerlink" title="Last-Modify/If-Modify-Since"></a>Last-Modify/If-Modify-Since</h4><p>浏览器<strong>第一次</strong>请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p>
<p><img src="\images\HTTP缓存\Last-Modify.png" alt="Last-Modify"></p>
<p>当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p>
<p><img src="\images\HTTP缓存\If-Modify-Since.png" alt="If-Modify-Since"></p>
<p>如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。</p>
<h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h4><p>与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>
<p><img src="\images\HTTP缓存\ETag.png" alt="ETag"></p>
<h5 id="ETag生成因子"><a href="#ETag生成因子" class="headerlink" title="ETag生成因子"></a>ETag生成因子</h5><p>以Apache为例，ETag生成靠以下几种因子</p>
<ol>
<li>文件的i-node编号，此i-node非彼iNode。是Linux/Unix用来识别文件的编号。是的，识别文件用的不是文件名。使用命令’ls –I’可以看到。</li>
<li>文件最后修改时间</li>
<li>文件大小<br>生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。所以，理论上ETag也是会重复的，只是概率小到可以忽略。</li>
</ol>
<h5 id="Last-Modified相对与Etag的问题"><a href="#Last-Modified相对与Etag的问题" class="headerlink" title="Last-Modified相对与Etag的问题"></a>Last-Modified相对与Etag的问题</h5><ol>
<li><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。</p>
</li>
<li><p>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。</p>
</li>
<li><p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。</p>
</li>
</ol>
<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。</p>
<p><strong>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="\images\HTTP缓存\summery.png" alt="summery"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://www.jianshu.com/p/227cee9c8d15" target="_blank" rel="noopener">一文读懂http缓存（超详细）</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/ranyonsue/p/8918908.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/ranyonsue/p/8918908.html" target="_blank" rel="noopener">HTTP缓存机制</a></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Fetch方法的使用</title>
    <url>/2021/02/13/Fetch%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>Fetch</code>是基于<code>Promise</code>开发的用于访问和操纵 HTTP 管道的一个<code>API</code>。其提供了一个全局 <code>fetch()</code>方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p>
<p>以前浏览器中的网络请求只能通过<code>XMLHttpRequest</code>实现（虽然大多使用的是封装过后的接口）。而<code>Fetch</code>则结合<code>Promise</code>提供了一种更加简化的发送网络请求的方式（其调用方法与<code>axiso</code>相似）。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="Fetch-方法"><a href="#Fetch-方法" class="headerlink" title="Fetch()方法"></a><code>Fetch()</code>方法</h2><p><code>Fetch</code>接受两个参数：</p>
<p><code>Promise&lt;Response&gt; fetch(input[, init]);</code></p>
<ul>
<li><p><em>?input</em></p>
<p>定义要获取的资源。这可能是：一个 <code>USVString</code>字符串，包含要获取资源的 URL。一些浏览器会接受 <code>blob:</code> 和 <code>data:</code> 作为 schemes.一个 <code>Request</code>对象。</p>
</li>
<li><p><em>init</em> 可选</p>
<p>一个配置项对象，包括所有对请求的设置。可选的参数有：</p>
<ul>
<li><code>method</code>: 请求使用的方法，如 <code>GET、POST。</code> </li>
<li><code>headers</code>: 请求的头信息，形式为 <code>Headers</code>值的对象字面量。</li>
<li><code>body</code>: 请求的 body 信息：可能是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener"><code>Blob</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/BufferSource" target="_blank" rel="noopener"><code>BufferSource</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData" target="_blank" rel="noopener"><code>FormData</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams" target="_blank" rel="noopener"><code>URLSearchParams</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/USVString" target="_blank" rel="noopener"><code>USVString</code></a> 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。</li>
<li><code>mode</code>: 请求的模式，如 <code>cors、</code> <code>no-cors 或者</code> <code>same-origin。</code></li>
<li><code>credentials</code>: 请求的 credentials，如 <code>omit、same-origin 或者include</code>。为了在当前域名内自动发送 cookie ， 必须提供这个选项， 从 Chrome 50 开始， 这个属性也可以接受 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FederatedCredential" target="_blank" rel="noopener"><code>FederatedCredential</code></a> 实例或是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PasswordCredential" target="_blank" rel="noopener"><code>PasswordCredential</code></a> 实例。</li>
<li><code>cache</code>:  请求的 cache 模式: <code>default</code>、 <code>no-store</code>、 <code>reload</code> 、 <code>no-cache</code>、 <code>force-cache</code>或者 <code>only-if-cached</code> 。<code>redirect</code>: 可用的 redirect 模式: <code>follow</code> (自动重定向), <code>error</code> (如果产生重定向将自动终止并且抛出一个错误）, 或者 <code>manual</code> (手动处理重定向). 在Chrome中默认使用<code>follow（</code>Chrome 47之前的默认值是<code>manual</code>）。</li>
<li>referrer<code>: 一个 [</code>USVString<code>](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString) 可以是</code>no-referrer、<code></code>client<code>或一个 URL。默认是</code>client。`</li>
<li><code>referrerPolicy</code>: 指定了HTTP头部<code>referer</code>字段的值。可能为以下值之一： <code>no-referrer、no-referrer-when-downgrade、origin、origin-when-cross-origin、unsafe-url</code> 。</li>
<li><code>integrity</code>: 包括请求的  <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity" target="_blank" rel="noopener">subresource integrity</a> 值 （ 例如： <code>sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。</code></li>
</ul>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>一个 <code>Promise</code>对象。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="发送带凭据的请求"><a href="#发送带凭据的请求" class="headerlink" title="发送带凭据的请求"></a>发送带凭据的请求</h3><p>注意：<code>Fetch</code>默认是不携带凭据的请求（即使是跨域源），要将<code>credentials: &#39;include&#39;</code>添加到传递给 <code>fetch()</code>方法的<code>init</code>对象，才能使请求携带凭证。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'https://example.com'</span>, &#123;</span><br><span class="line">  credentials: <span class="string">'include'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加 <code>credentials: &#39;same-origin&#39;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The calling script is on the origin 'https://example.com'</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'https://example.com'</span>, &#123;</span><br><span class="line">  credentials: <span class="string">'same-origin'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="上传-JSON-数据"><a href="#上传-JSON-数据" class="headerlink" title="上传 JSON 数据"></a>上传 JSON 数据</h3><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch" target="_blank" rel="noopener"><code>fetch()</code></a> POST JSON数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'https://example.com/profile'</span>;</span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">username</span>: <span class="string">'example'</span>&#125;;</span><br><span class="line"></span><br><span class="line">fetch(url, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>, <span class="comment">// or 'PUT'</span></span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(data), <span class="comment">// data can be `string` or &#123;object&#125;!</span></span><br><span class="line">  headers: <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, error))</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Success:'</span>, response));</span><br></pre></td></tr></table></figure>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>可以通过 HTML <code>&lt;input type=&quot;file&quot; /&gt;</code> 元素，<code>FormData()</code>和 <code>fetch()</code>上传文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">var</span> fileField = <span class="built_in">document</span>.querySelector(<span class="string">"input[type='file']"</span>);</span><br><span class="line"></span><br><span class="line">formData.append(<span class="string">'username'</span>, <span class="string">'abc123'</span>);</span><br><span class="line">formData.append(<span class="string">'avatar'</span>, fileField.files[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'https://example.com/profile/avatar'</span>, &#123;</span><br><span class="line">  method: <span class="string">'PUT'</span>,</span><br><span class="line">  body: formData</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, error))</span><br></pre></td></tr></table></figure>
<h3 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h3><p>可以通过HTML <code>&lt;input type=&quot;file&quot; mutiple/&gt;</code> 元素，<code>FormData()</code>和 <code>fetch()</code>上传多个文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">var</span> photos = <span class="built_in">document</span>.querySelector(<span class="string">"input[type='file'][multiple]"</span>);</span><br><span class="line"></span><br><span class="line">formData.append(<span class="string">'title'</span>, <span class="string">'My Vegas Vacation'</span>);</span><br><span class="line"><span class="comment">// formData 只接受文件、Blob 或字符串，不能直接传递数组，所以必须循环嵌入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; photos.files.length; i++) &#123;</span><br><span class="line">    formData.append(<span class="string">'photo'</span>, photos.files[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'https://example.com/posts'</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  body: formData</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Success:'</span>, <span class="built_in">JSON</span>.stringify(response)))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, error));</span><br></pre></td></tr></table></figure>
<h3 id="自定义请求对象"><a href="#自定义请求对象" class="headerlink" title="自定义请求对象"></a>自定义请求对象</h3><p>除了传给 <code>fetch()</code> 一个资源的地址，你还可以通过使用 <code>Request()</code>构造函数来创建一个 request 对象，然后再作为参数传给 <code>fetch()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myHeaders = <span class="keyword">new</span> Headers();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myInit = &#123; <span class="attr">method</span>: <span class="string">'GET'</span>,</span><br><span class="line">               headers: myHeaders,</span><br><span class="line">               mode: <span class="string">'cors'</span>,</span><br><span class="line">               cache: <span class="string">'default'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myRequest = <span class="keyword">new</span> Request(<span class="string">'flowers.jpg'</span>, myInit);</span><br><span class="line"></span><br><span class="line">fetch(myRequest).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.blob();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  myImage.src = objectURL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Request()</code> 和 <code>fetch()</code> 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherRequest = <span class="keyword">new</span> Request(myRequest,myInit);</span><br></pre></td></tr></table></figure>
<h2 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a><code>Request</code>对象</h2><p><code>Request</code>构造器可以构造一个<code>Request</code>对象，其作为<code>Fetch</code>方法的参数。</p>
<p>该构造器接受的参数与<code>Fetch</code>一致：</p>
<ol>
<li>请求地址</li>
<li><code>init</code>对象</li>
</ol>
<p>此处不再赘述。</p>
<p>此外，我们可直接通过<code>const method = Request.method</code>的方式来获取<code>init</code>属性。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myRequest = <span class="keyword">new</span> Request(<span class="string">'http://localhost/flowers.jpg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myURL = myRequest.url; <span class="comment">// http://localhost/flowers.jpg</span></span><br><span class="line"><span class="keyword">const</span> myMethod = myRequest.method; <span class="comment">// GET</span></span><br><span class="line"><span class="keyword">const</span> myCred = myRequest.credentials; <span class="comment">// omit</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>Request</code>对象有以下方法可以调用：</p>
<ul>
<li><p><code>Request.clone()</code></p>
<p>创建当前request的副本。</p>
</li>
</ul>
<p><code>Request</code>实现 Body`， 因此它也有以下方法可用:</p>
<ul>
<li><p><code>Body.arrayBuffer()</code></p>
<p>返回解决一个<code>ArrayBuffer</code>表示的请求主体的promise.</p>
</li>
<li><p><code>Body.blob()</code></p>
<p>返回解决一个<code>Blob</code>表示的请求主体的promise.</p>
</li>
<li><p><code>Body.formData()</code></p>
<p>返回解决一个<code>FormData</code>表示的请求主体的promise.</p>
</li>
<li><p><code>Body.json()</code></p>
<p>返回解决一个<code>JSON</code>表示的请求主体的promise.</p>
</li>
<li><p><code>Body.text()</code></p>
<p>返回解决一个<code>USVString</code>(文本)表示的请求主体的promise.</p>
</li>
</ul>
<p>注意：这些Body功能只能运行一次; 随后的调用将通过空<code>strings/ ArrayBuffers</code>解析.</p>
<h2 id="header对象"><a href="#header对象" class="headerlink" title="header对象"></a><code>header</code>对象</h2><p>使用 <code>Headers</code>的接口，你可以通过 <code>Headers()</code>构造函数来创建一个你自己的 headers 对象。一个 headers 对象是一个简单的多名值对：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> content = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">let</span> myHeaders = <span class="keyword">new</span> Headers();</span><br><span class="line">myHeaders.append(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>);</span><br><span class="line">myHeaders.append(<span class="string">"Content-Length"</span>, content.length.toString());</span><br><span class="line">myHeaders.append(<span class="string">"X-Custom-Header"</span>, <span class="string">"ProcessThisImmediately"</span>);</span><br></pre></td></tr></table></figure>
<p>也可以直接接受一个字面量对象来构造<code>header</code>对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myHeaders = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">  <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">"Content-Length"</span>: content.length.toString(),</span><br><span class="line">  <span class="string">"X-Custom-Header"</span>: <span class="string">"ProcessThisImmediately"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p><code>Headers.append()</code></p>
<p>给现有的header添加一个值, 或者添加一个未存在的header并赋值.</p>
</li>
<li><p><code>Headers.delete()</code></p>
<p>从Headers对象中删除指定header.</p>
</li>
<li><p><code>Headers.entries()</code></p>
<p>以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener"><code>迭代器</code></a> 的形式返回Headers对象中所有的键值对.</p>
</li>
<li><p><code>Headers.get()</code></p>
<p>以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ByteString" target="_blank" rel="noopener"><code>ByteString</code></a> 的形式从Headers对象中返回指定header的全部值.</p>
</li>
<li><p><code>Headers.has()</code></p>
<p>以布尔值的形式从Headers对象中返回是否存在指定的header.</p>
</li>
<li><p><code>Headers.keys()</code></p>
<p>以<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener"><code>迭代器</code></a>的形式返回Headers对象中所有存在的header名.</p>
</li>
<li><p><code>Headers.set()</code></p>
<p>替换现有的header的值, 或者添加一个未存在的header并赋值.</p>
</li>
<li><p><code>Headers.values()</code></p>
<p>以<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener"><code>迭代器</code></a>的形式返回Headers对象中所有存在的header的值.</p>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>在header已存在或者有多个值的状态下<code>Headers.set()</code>和 <code>Headers.append()</code>的使用有如下区别, <code>Headers.set()</code>将会用新的值覆盖已存在的值, 但是<code>Headers.append()</code>会将新的值添加到已存在的值的队列末尾. </li>
<li>如果您尝试传入名称不是<a href="https://fetch.spec.whatwg.org/#concept-header-name" target="_blank" rel="noopener">有效的HTTP头名称</a>的引用，则所有Headers方法都将引发 <code>TypeError</code> 。 如果头部有一个不变的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Guard" target="_blank" rel="noopener">Guard</a>，则变异操作将会抛出一个 <code>TypeError</code> 。 在其他任何失败的情况下，他们默默地失败。</li>
<li>出于安全考虑，某些头只能由用户代理控制。这些头信息包括 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name" target="_blank" rel="noopener">forbidden header names</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_response_header_name" target="_blank" rel="noopener">forbidden response header names</a>。</li>
<li>一个Headers对象也有一个关联的guard，它具有不可变的值，<code>request</code>，<code>request-no-cors</code>，<code>response</code>或<code>none</code>。 这会影响 set()<code>，</code>delete()<code>, 和</code>append()`方法 改变header. </li>
</ul>
<h3 id="Guard属性"><a href="#Guard属性" class="headerlink" title="Guard属性"></a>Guard属性</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>Guard 是 <code>Headers</code>对象的特性，基于不同的情况，它可以有以下取值：<code>immutable、request、request-no-cors、response 或 none。</code></p>
<p>由于 Headers 可以在 request 请求中被发送或者在 response 请求中被接收，并且规定了哪些参数是可写的，Headers 对象中的 guard 属性。这个属性没有暴露给 Web，但是它影响到哪些内容可以在 Headers 对象中被操作。</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>当使用 <code>Headers()constructor</code>创建一个新的 <code>Headers</code>对象的时候，它的 guard 被设置成 <code>none（默认值）</code>。当创建 <code>Request</code>或 <code>Response</code>对象的时候，它将拥有一个按照以下规则实现的与之关联的 Headers`对象：</p>
<table>
<thead>
<tr>
<th style="text-align:left">新对象的类型</th>
<th style="text-align:left">创建时的构造函数</th>
<th style="text-align:left">关联的 <code>Headers</code>对象的 guard</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Request</code></td>
<td style="text-align:left"><code>Request()</code></td>
<td style="text-align:left"><code>request</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Request</code></td>
<td style="text-align:left">Request()，mode 设置成 no-cors</td>
<td style="text-align:left"><code>request-no-cors</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Response</code></td>
<td style="text-align:left"><code>Response()</code></td>
<td style="text-align:left"><code>response</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Response</code></td>
<td style="text-align:left"><code>immutable</code></td>
<td style="text-align:left"><code>immutable</code></td>
</tr>
</tbody>
</table>
<p><code>guard</code>属性值的特征：</p>
<ul>
<li><code>none</code>：默认的</li>
<li><code>request</code>：从 request 中获得的 headers（<code>Request.headers</code>）只读</li>
<li><code>request-no-cors</code>：从不同域（<code>Request.mode</code> <code>no-cors</code>）的 request 中获得的 headers 只读</li>
<li><code>response</code>：从 response 中获得的 headers（<code>Response.headers</code>）只读</li>
<li><code>immutable</code>：在 <code>ServiceWorkers</code> 中最常用的，所有的 headers 都只读。</li>
</ul>
<h2 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>如上所述，<code>Response</code>实例是在 <code>fetch()</code> 处理完 promise 之后返回的。其呈现了对一次请求的响应数据。</p>
<p>我们可以通过一个构造函数来创建一个<code>Response</code>对象，但更多的是通过一个<code>Fetch</code>请求返回的<code>Response</code>对象。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p><code>Response.headers</code>只读</p>
<p>包含此 Response 所关联的 <code>Headers</code>对象。</p>
</li>
<li><p><code>Response.ok</code>只读</p>
<p>包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。</p>
</li>
<li><p><code>Response.redirected</code>只读</p>
<p>表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。</p>
</li>
<li><p><code>Response.status</code>只读</p>
<p>包含 Response 的状态码 （例如 <code>200</code> 表示成功）。</p>
</li>
<li><p><code>Response.statusText</code>只读</p>
<p>包含了与该 Response 状态码一致的状态信息（例如，OK对应 <code>200</code>）。</p>
</li>
<li><p><code>Response.type</code> 只读</p>
<p>包含 Response 的类型（例如，<code>basic</code>、<code>cors</code>）。</p>
</li>
<li><p><code>Response.url</code>只读</p>
<p>包含 Response 的URL。</p>
</li>
<li><p><code>Response.useFinalURL</code></p>
<p>包含了一个布尔值，来标示这是否是该 Response 的最终 URL。</p>
</li>
</ul>
<p><code>Response</code> 实现了 <code>Body</code>接口，所以以下属性亦可用：</p>
<ul>
<li><p><code>Body.body</code> 只读</p>
<p>一个简单的 getter，用于暴露一个 <code>ReadableStream</code>类型的 body 内容。</p>
</li>
<li><p><code>Body.bodyUsed</code>只读</p>
<p>包含了一个<code>布尔值</code>来标示该 Response 是否读取过 <code>Body</code>。</p>
</li>
</ul>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p><code>Response.clone()</code></p>
<p>创建一个 <code>Response</code> 对象的克隆。</p>
</li>
<li><p><code>Response.error()</code></p>
<p>返回一个绑定了网络错误的新的 <code>Response</code> 对象。</p>
</li>
<li><p><code>Response.redirect()</code></p>
<p>用另一个 URL 创建一个新的 <code>Response</code>。</p>
</li>
</ul>
<p><code>Response</code> 实现了 <code>Body</code>接口，所以以下方法同样可用：</p>
<ul>
<li><p><code>Body.arrayBuffer()</code></p>
<p>读取 <code>Response</code>对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <code>ArrayBuffer</code>格式的 Promise 对象。</p>
</li>
<li><p><code>Body.blob()</code></p>
<p>读取 <code>Response</code>对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener"><code>Blob</code></a> 格式的 Promise 对象。</p>
</li>
<li><p><code>Body.formData()</code></p>
<p>读取<code>Response</code>对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData" target="_blank" rel="noopener"><code>FormData</code></a> 格式的 Promise 对象。</p>
</li>
<li><p><code>Body.json()</code></p>
<p>读取 <code>Response</code>对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/JSON" target="_blank" rel="noopener"><code>JSON</code></a> 格式的 Promise 对象。</p>
</li>
<li><p><code>Body.text()</code></p>
<p>读取 <code>Response</code>对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 <code>USVString</code> 格式的 Promise 对象。 </p>
</li>
</ul>
<h2 id="body对象"><a href="#body对象" class="headerlink" title="body对象"></a><code>body</code>对象</h2><p><strong><code>Body</code></strong>代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。</p>
<p>一般我们也是从一个请求中得到一个<code>body</code>对象。当然，直接通过<code>body</code>构造器来创建一个<code>body</code>也是被允许的。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>Body.body</code> 只读<br>一个简单的getter用于暴露一个<code>ReadableStream</code>类型的主体内容。</li>
<li><code>Body.bodyUsed</code> 只读<br>一个<code>Boolean</code> 值指示是否<code>body</code>已经被标记读取。</li>
</ul>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p><code>Body.arrayBuffer()</code></p>
<p>使<code>Response</code>挂起一个流操作并且在完成时读取其值，它返回一个<code>Promise</code>对象，其resolve参数类型是<code>ArrayBuffer</code>。此操作会将<code>bodyUsed</code>状态改为已使用（true）。</p>
</li>
<li><p><code>Body.blob()</code></p>
<p>使<code>Response</code>挂起一个流操作并且在完成时读取其值，它返回一个<code>Promise</code>对象，其resolve参数类型是<code>Blob</code>。此操作会将<code>bodyUsed</code>状态改为已使用（true）。</p>
</li>
<li><p><code>Body.formData()</code></p>
<p>使<code>Response</code>挂起一个流操作并且在完成时读取其值，它返回一个<code>Promise</code>对象，其resolve参数类型是<code>FormData</code>表单。此操作会将<code>bodyUsed</code>状态改为已使用（true）。</p>
</li>
<li><p><code>Body.json()</code></p>
<p>使<code>Response</code>挂起一个流操作并且在完成时读取其值，它返回一个<code>Promise</code>对象，其resolve参数类型是使用<code>JSON</code>解析body文本的结果。此操作会将<code>bodyUsed</code>状态改为已使用（true）。</p>
</li>
<li><p><code>Body.text()</code></p>
<p>使<code>Response</code>挂起一个流操作并且在完成时读取其值，它返回一个<code>Promise</code>对象，其resolve参数类型是<code>USVString</code>（文本）。此操作会将<code>bodyUsed</code>状态改为已使用（true）。</p>
</li>
</ul>
<p>比起<code>XHR</code>来，这些方法让非文本化的数据使用起来更加简单。</p>
<h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p><img src="D:\myblog\myblog\source\images\Fetch\兼容性.png" alt=""></p>
<p>可以看到<code>Fetch</code>的兼容性还是有一定的问题，<code>Chrome</code>42版本才开始支持从与<code>Firefox</code>从39版本才支持，而IE到目前位置都不支持。这是一个很大的问题。如果要在生产环境中使用，必须引入很多<code>pollyfill</code>，相较于使用<code>Promise</code>封装的<code>XHR</code>，这样看来优势又荡然无存，随着版本的迭代，未来肯定是<code>Fetch</code>的，但不是现在。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">使用 Fetch-MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>Fetch</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title>Image对象的complete与onload()事件(以及Canvas的drawImage()函数)</title>
    <url>/2019/03/12/Image%E5%AF%B9%E8%B1%A1%E7%9A%84complete%E4%B8%8Eonload()%E4%BA%8B%E4%BB%B6(%E4%BB%A5%E5%8F%8ACanvas%E7%9A%84drawImage()%E5%87%BD%E6%95%B0)/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>之前基本看完了canvas的API，准备做一个小游戏，emmm，然后今天就遇到了问题，我本来以为是canvas的问题，但是仔细分析之后才发现是JS中的问题：<br><a id="more"></a></p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>关于HTML与JS的关系可以从网页的加载顺序来看，当浏览器打开网页的时候，网页由上至下的解析该网页，然后开始构建DOM树(Document Object Model)(属于JavaScript)，也就是说将HTML的每一个标签构建成一个相应的对象，但是DOM整体就是一个对象，每一个标签是其的一个子对象，对比与JSX有些相似,遇到JS或CSS时利用相应引擎进行解析。从这里就可以理解出，在网页完成加载后，每一个标签就成为了DOM这个对象里的一个子对象，我们使用相应的方法，比如Document.getElementById(“xxx”)就可以获取相应的对象，并进行操作。</p>
<h2 id="Image-对象"><a href="#Image-对象" class="headerlink" title="Image()对象"></a>Image()对象</h2><p>由上可知，Image()也是一个节点对象，只是是否渲染至页面上的问题。</p>
<h3 id="Image对象的属性"><a href="#Image对象的属性" class="headerlink" title="Image对象的属性"></a>Image对象的属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>align</td>
<td>设置或返回与内联内容的对齐方式。</td>
<td>align</td>
<td>设置或返回与内联内容的对齐方式。</td>
</tr>
<tr>
<td>alt</td>
<td>设置或返回无法显示图像时的替代文本。</td>
<td>alt</td>
<td>设置或返回无法显示图像时的替代文本。</td>
</tr>
<tr>
<td>border</td>
<td>设置或返回图像周围的边框。</td>
<td>border</td>
<td>设置或返回图像周围的边框。</td>
</tr>
<tr>
<td>complete</td>
<td>返回浏览器是否已完成对图像的加载。</td>
<td>complete</td>
<td>返回浏览器是否已完成对图像的加载。</td>
</tr>
<tr>
<td>height</td>
<td>设置或返回图像的高度。</td>
<td>height</td>
<td>设置或返回图像的高度。</td>
</tr>
<tr>
<td>hspace</td>
<td>设置或返回图像左侧和右侧的空白。</td>
<td>hspace</td>
<td>设置或返回图像左侧和右侧的空白。</td>
</tr>
<tr>
<td>id</td>
<td>设置或返回图像的 id。</td>
<td>id</td>
<td>设置或返回图像的 id。</td>
</tr>
<tr>
<td>isMap</td>
<td>返回图像是否是服务器端的图像映射。</td>
<td>isMap</td>
<td>返回图像是否是服务器端的图像映射。</td>
</tr>
<tr>
<td>longDesc</td>
<td>设置或返回指向包含图像描述的文档的 URL。</td>
<td>longDesc</td>
<td>设置或返回指向包含图像描述的文档的 URL。</td>
</tr>
<tr>
<td>lowsrc</td>
<td>设置或返回指向图像的低分辨率版本的 URL。</td>
<td>lowsrc</td>
<td>设置或返回指向图像的低分辨率版本的 URL。</td>
</tr>
<tr>
<td>name</td>
<td>设置或返回图像的名称。</td>
<td>name</td>
<td>设置或返回图像的名称。</td>
</tr>
<tr>
<td>src</td>
<td>设置或返回图像的 URL。</td>
<td>src</td>
<td>设置或返回图像的 URL。</td>
</tr>
<tr>
<td>useMap</td>
<td>设置或返回客户端图像映射的 usemap 属性的值。</td>
<td>useMap</td>
<td>设置或返回客户端图像映射的 usemap 属性的值。</td>
</tr>
<tr>
<td>vspace</td>
<td>设置或返回图像的顶部和底部的空白。</td>
<td>vspace</td>
<td>设置或返回图像的顶部和底部的空白。</td>
</tr>
<tr>
<td>width</td>
<td>设置或返回图像的宽度。</td>
<td>width</td>
<td>设置或返回图像的宽度。</td>
</tr>
</tbody>
</table>
<h3 id="标准属性"><a href="#标准属性" class="headerlink" title="标准属性"></a>标准属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>className</td>
<td>设置或返回元素的 class 属性。</td>
</tr>
<tr>
<td>title</td>
<td>设置或返回元素的 title。</td>
</tr>
</tbody>
</table>
<h3 id="Image对象的事件句柄"><a href="#Image对象的事件句柄" class="headerlink" title="Image对象的事件句柄"></a>Image对象的事件句柄</h3><table>
<thead>
<tr>
<th>事件句柄</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onabort</td>
<td>当用户放弃图像的装载时调用的事件句柄。</td>
</tr>
<tr>
<td>onerror</td>
<td>在装载图像的过程中发生错误时调用的事件句柄。</td>
</tr>
<tr>
<td>onload</td>
<td>当图像装载完毕时调用的事件句柄。</td>
</tr>
</tbody>
</table>
<h2 id="浅谈图片加载"><a href="#浅谈图片加载" class="headerlink" title="浅谈图片加载"></a>浅谈图片加载</h2><h3 id="complete属性：图片显示出来之后其属性由false变为true"><a href="#complete属性：图片显示出来之后其属性由false变为true" class="headerlink" title="complete属性：图片显示出来之后其属性由false变为true"></a>complete属性：图片显示出来之后其属性由<code>false</code>变为<code>true</code></h3><p>在这个属性上，IE与其他浏览器有所不同，IE是根据图片的src属性是否是一个有效的图片地址值。即，<strong>在IE下，只有当image()对象的src值为一个正确的图片地址时，complete值才为true，否则一直为false，但是在其他浏览器下，当image()对象呗定义完成的时候，其complete值就为true，不会检测其src属性的有效性</strong></p>
<p>也就是说：<strong>complete这个属性在IE系浏览器与其他浏览器的判断方式不一样，所以对于适配性来说，最好不用</strong></p>
<h3 id="onload-回调事件"><a href="#onload-回调事件" class="headerlink" title="onload()回调事件"></a>onload()回调事件</h3><p>onload()是当图像装载完毕后调用的函数。关键是如何才算是装载完毕，经测试，</p>
<ol>
<li>当我们直接在HTML中定义一个<img>标签，并且在其中规定其onload事件，只有当src属性填写正确时，才算是<strong>装载完成</strong>，否则onload事件一直不触发，直至修改其src值为有效图片地址的时候才算是<strong>装载完成</strong>。</li>
<li>当我们在JS代码中手动生成一个Image()对象时，无论其src值是否被赋值为有效的图片地址，其onload事件总会触发，即当我们手动生成一个 Image 对象时，一旦其被生成，则认定为装载完成，立即调用onload事件。至于原因，我还没弄明白，看来需要深入的去了解一下浏览器机制，才能明白这一点。</li>
</ol>
<h2 id="Canvas中悟到的Image对象的用发法"><a href="#Canvas中悟到的Image对象的用发法" class="headerlink" title="Canvas中悟到的Image对象的用发法"></a>Canvas中悟到的Image对象的用发法</h2><ol>
<li>ctx.drawImage(img,x,y)中的Img应当是一个Image对象，可以是从DOM树中获取的Image()子对象，也可以是一个自己定义的Image()对象，不管是这两者中的哪一者，再绘制到画板上时，都必须将绘制语句写到该对象的<code>onload()</code>函数中，其原因在于，Image()的定义是一个异步执行的操作，也就是说，在执行到<code>let img = new Image()</code>时，JS引擎不会等待该语句执行完毕在继续执行，而是直接继续执行，在对象定义完成时，就会自动调用其onlaod.onerror,onabort回调事件。那么问题就是，可能在对象还没有定义完成的时候，已经执行到了<code>ctx.drawImage()</code>这一条语句，所以绘制不出任何效果(而且大部分情况下，JS语句的执行都是快于对象的定义，所以基本上都绘制不出图形)。所以所有的Canvas图形绘制都必须是在onload中进行的。</li>
<li><p>问题又出现了，那如果要就行较大型的图形绘制，我不可能把所有代码都写到一个函数里吧，所以再写多个函数时就要多次调用onload事件，但是一个图片的onload事件只能执行一次。所以我想到了一种错误的方法，在不同寒暑表中多次载入同一张图片，并分别调用其回调函数onload，结果当然是失败了。这种情况下<strong>onload事件的顺序是无法确定的，即使你是前后分别执行，因为onload函数是异步进行的</strong>，现在惟一的办法就是把这张图片统一载入，然后想办法将下面的代码都建立在onlaod函数执行的前提下。然后我找到了一种方法：</p>
<p> let img = new Image();<br> img.addEventListener(‘onload’,’start’,’true’);</p>
<p> function start(){</p>
<pre><code>draw1();
draw2();
}
</code></pre><p> fucntion draw1(){</p>
<pre><code>ctx.drawImage();
...
</code></pre><p> }</p>
<p> fucntion draw1(){</p>
<pre><code>ctx.drawImage();
...
</code></pre><p> }</p>
</li>
</ol>
<p>上面这么写的好处在于，所有的函数后在onload回调函数之后执行了，确保了绘图的正确性。</p>
<h1 id="Last-but-not-least"><a href="#Last-but-not-least" class="headerlink" title="Last but not least"></a>Last but not least</h1><p> 我在网上搜了很久，在讲解onload()事件时基本就一篇文章，被抄了无数次，但是我试验却发现和文章中的结果完全不一样。文章中写到，即使是在JS代码中定义一个Image()对象时，只要src不赋值，其onload事件就不会触发，但是~像我上面实验的那样，我试验了很多次，都是那样的结果，测试了Chrome，Firefox，IE，Edge，每个浏览器的测试都一样。可能是那篇文章已经是很久之前的了，但是这些同学从未自己试过，直接就抄过去了。所以实践才是真理啊。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP中的表单编码问题</title>
    <url>/2019/01/28/JSP%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8D%95%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="JSP的编码"><a href="#JSP的编码" class="headerlink" title="JSP的编码"></a>JSP的编码</h1><p>才看了几天的JSP，把最重要的表单提交看了一下，遇到了中文编码的问题，然后我查了一下JSP的默认代码是：<strong>ISO-8859-1</strong><br>重新设编码的语句共有下面几句：<br><a id="more"></a></p>
<ol>
<li>pageEncoding=”UTF-8”</li>
<li>contentType=”text/html;charset=UTF-8”</li>
<li>request.setCharacterEncoding(“UTF-8”)</li>
<li>response.setCharacterEncoding(“UTF-8”)</li>
</ol>
<ol>
<li><p>pageEncoding=”UTF-8” 是在第一阶段，转换阶段（即将JSP文件转化为servlet文件的过程中使用该局代码提示的编码）</p>
</li>
<li><p>contentType=”text/html;charset=UTF-8” 是用在第二阶段，将servle渲染为html时，使用该语句的编码</p>
</li>
<li><p>request.setCharacterEncoding(“UTF-8”) 是用来指定对浏览器发送来的数据以特定的字符集进行重新编码，常用于对 POST 请求参数进行解码。</p>
</li>
<li><p>response.setCharacterEncoding(“UTF-8”) 是用来在服务器将响应返回到浏览器前，对响应使用指定字符集进行重新编码。一旦使用了该种方式，即使该响应页面指定了具体的 contentType，也将失效。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP实战项目:学生信息管理系统的总结</title>
    <url>/2019/02/09/JSP%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>简单学习了一下JSP，不知道以后老师怎么教的，不过我是感觉到JSP的真谛还是Java，无论是按照MVC或者三层模式，一般Control层都是servlet来写，Model层都是用纯java来写，当然，在JSP文件中，也是可以进行这些操作的，毕竟在JSP的&lt;%…%&gt;中完全可以写java代码，而servlet的本质就是java的一个类。但是一般在开始时总是界面与逻辑分开，否则整个项目结构混乱，代码冗余。所以我觉的学JSP本质还是学java，学servlet。<br><a id="more"></a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>整个项目差不多就包含学生信息的增删改，准备添加一个文件上传，不过还没添加，嘿嘿嘿。后面再说。</p>
<p>在这个过程中我遇到了不少问题，下面我就想起什么就讲什么吧~</p>
<h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><ol>
<li>前端完美居中之flex布局：</li>
</ol>
<p>在登陆界面这种只需要一个div完美居中的情况，flex布局是在一个不错的方法：</p>
<pre><code>body{
    display:flex;//设置body为flex布局
    justify-content:center;    //设置布局主轴上的对齐方式为居中
    align-items:center;//设置另一轴的对齐方式为居中
}
</code></pre><p>这种布局下，body里的内容就会完美居中。</p>
<p>另外在回顾一下flex布局里的所有属性：</p>
<ul>
<li><p>容器属性</p>
<ol>
<li>flex-direction:　决定主轴的方向，即项目排列的方向，有四个可能的值：row(默认)|row-reverse|column|column-reverse</li>
<li>flex-wrap:默认情况下，item排列在一条线上，即主轴上，flex-wrap决定当排列不下时是否换行以及换行的方式，可能的值nowrap(默认)|wrap|wrap-reverse</li>
<li>flex-flow:flex-direction和flex-wrap的简写形式，如：row wrap|column wrap-reverse等。默认值为row nowrap，即横向排列 不换行。</li>
<li>justify-content:决定item在主轴上的对齐方式，可能的值有flex-start（默认），flex-end，center，space-between，space-around。</li>
<li>align-items:决定了item在交叉轴上的对齐方式，可能的值有flex-start|flex-end|center|baseline|stretch</li>
<li>align-content:该属性定义了当有多根主轴时，即item不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，定义了align-content后，align-items属性将失效。</li>
</ol>
</li>
<li><p>容器属性</p>
<ol>
<li>order：order的值是整数，默认为0，整数越小，item排列越靠前。</li>
<li>flex-grow：定义了当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大；可能的值为整数，表示不同item的放大比例</li>
<li>flex-shrink：定义了当容器空间不足时，item是否缩小。默认值为1，表示当空间不足时，item自动缩小，其可能的值为整数，表示不同item的缩小比例。</li>
<li>flex-basis：表示项目在主轴上占据的空间，默认值为auto，其可为具体数值(px)。</li>
<li>flex：flex属性是flex-grow、flex-shrink和flex-basis三属性的简写总和。</li>
<li>align-self：　align-self属性允许item有自己独特的在交叉轴上的对齐方式，它有六个可能的值：auto|flex-start|flex-end|center|baseline|stretch。默认值为auto。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>前端onsubmit属性</li>
</ol>
<p>这个属性真有点用~这个属性是用在submit按钮上的，他可以在你提交表单之前进行数据的审核。在审核通过后再上传，如果审核不通过，则不提交。具体代码如下。</p>
<pre><code>//表单部分
&lt;input type=&quot;submit&quot; value=&quot;提交&quot; onsubmit=&quot;return check()&quot;&gt;

//JS部分
function check(){
    //执行判断，注意要返回一个boolean值，该值来确定是否需要提交表单    
}
</code></pre><ol start="3">
<li>Jquery的ajax请求</li>
</ol>
<p>由于原生JS的ajax请求有点负载，所以我还是采用了jquery。所以还是具体介绍一下jquery的ajax请求。</p>
<p><strong>1. $(“#id”).load(url,data,function(response,status,xhr))</strong></p>
<p>这种请求方法可以直接将请求到的数据添加到指定元素中（其本质还是get()方式）。</p>
<p>url：（必选）请求的地址</p>
<p>data:（可选）要发送的数据,采用键值存储发送，多个数据时采用花括号：{key1:value1,key2:value2}</p>
<p>function():（可选），在服务器反馈后执行的函数。</p>
<p>response：服务器返回的数据</p>
<p>status：服务器返回的status值</p>
<p>xhr：服务器返回的xhr对象</p>
<p><strong>2. $.get(url,data,function(response,status,xhr)</strong></p>
<p>这个基本的get请求，get()只请求数据，不对数据做任何处理。</p>
<p>但是jquery将jsonp也封装进了get方法中，所以我们再调用get方法时，可以使用jsonp进行传输，但一般是是直接传字符串:</p>
<pre><code>$.get(url,data,function(data,status,xhr){})
</code></pre><p>如果需要使用JSONP来请求，需要再声明：</p>
<pre><code>$.get(url,data.function(data,status,xhr){},&quot;JSONP&quot;)
</code></pre><p>关于JSON与JSONP，可以看一下<a href="https://www.cnblogs.com/GoCircle/p/6530699.html" target="_blank" rel="noopener">这一篇文章</a>，还是比较易懂。</p>
<p><strong>3. $.get(url,data,function(response,status,xhr)</strong></p>
<p>回顾一下，get与post：</p>
<p>get:</p>
<ul>
<li>数据追加到url中传输，因此保密性较差，直接可视化，不适用于账户，密码等信息的传输。</li>
<li>由于url的限制，也不适用于较长数据的传输，一般url的数据量在1KB左右。</li>
<li>由于使用url直接传输，因此传输效率会比post方式高。</li>
</ul>
<p>post：</p>
<ul>
<li>post是将数据封装为HTTP消息发送给服务器，这样做有以下优点：</li>
<li>数据传输量相较于get()方法得到提升，一般文件传输都是利用该方法</li>
<li>数据保密性得到一定性的保护，无法直接获取，但需要注意的是，通过抓包，任然可以获得post提交的所有数据。所以我们在传输密码时，一般是通过加密传输，不传明文密码。这一点，在<a href="https://www.cnblogs.com/wqhwe/p/5407468.html" target="_blank" rel="noopener">HTTPS</a>中得到了较好的解决。但是HTTPS需要申请且价格昂贵，所以目前对于数据的加密任是最好方法。</li>
</ul>
<p><strong>4.$.ajax({ type:”get”,url:”url”,data:””,async:true,function(data,status,xhr){} })</strong></p>
<p>注意：async即异步，一般默认是true，即，你删掉async这个选项，则默认为true，还记得ajax的含义么：</p>
<pre><code>Asynchronous JavaScript and XML
</code></pre><p>第一个就是async，所以如果是false，就没意义了对吧，不过也许有的情况有用，了解到就好。</p>
<p><strong>5. $.getJSON(url,data,function(response,status,xhr)</strong></p>
<p>我觉得这是jquery中最好用的一个方法了，因为他将请求到的JSON字符串直接转换为JSON对象了，直接用key和value属性就可以使用了，舒服的板~</p>
<ol start="4">
<li>JS的cookies的使用</li>
</ol>
<p>之前一直是使用的localStorage或者sessionStorage来存储数据，使用这个就很便捷，直接使用key来取value值就行了，我好像还有一个专门的<a href="http://michaelwang.top/2018/08/20/%E5%AF%B9%E4%BA%8EJS%E4%B8%ADlocalStorage%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">文章</a>来介绍，不过最终好像还是cookies使用的较多一点，可能是兼容性的原因，然年后我发现cookies的使用比localStorage要复杂一些，所以还是看一下：</p>
<p>设置cookie：</p>
<pre><code>function setCookie(cname,cvalue,exdays)
{
  var d = new Date();//实例化一个时间
  d.setTime(d.getTime()+(exdays*24*60*60*1000));//设置过期时间的变量
  var expires = &quot;expires=&quot;+d.toUTCString();//将Date()对象转化为数组
  document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;//设置cookie
}
</code></pre><p>获取cookie值：</p>
<pre><code>function getCookie(cname)
{
  var name = cname + &quot;=&quot;;
  var ca = document.cookie.split(&apos;;&apos;);//分割cookie字符串
  for(var i=0; i&lt;ca.length; i++) 
  {
    var c = ca[i].trim();//去除空格
    if (c.indexOf(name)==0) return c.substring(name.length,c.length);
  }//搜索是否存在该cookie，是则返回值
  return &quot;&quot;;
}
</code></pre><p>注意：可以看出，JS的cookie的API设计似乎没有localStorage那么友好，毕竟很多年前的东西了。所以document.cookie是直接获得整个cookie，以键值对用”=”连接起来，具体获得对应的值还需要我们自己来处理字符串，emmmm，从体验上来说，没有那么友好，但还有一点值得注意的是，document.cookie是一个方法，当你对他进行赋值操作的时候。他是直接识别”=”添加键值，而对其进行取值的时候，是以字符串返回所有的cookie值。</p>
<p><strong>上面获取cookie的方法不是唯一的，因为处理字符串的方式不是唯一的，包括正则也是不错的方法</strong></p>
<h2 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h2><ol>
<li><p>关于MVC的理解我觉得也是学到的一部分，即将视图，模型，控制分离，而且无论是哪种设计方式，最终目的是保证层次的清晰。这样无论是对一次开发还是重构，都是及其重要的。</p>
</li>
<li><p>另外对于JSP这门后端语言，我觉得要理解其精髓，还是要学习servlet，java。因为model，controller层，一般都是采用servlet或者java来开发，似乎很少有用JSP来写逻辑层面的东西的。</p>
</li>
<li><p>在开发时我遇到了一个BUG卡了我好几天，搜索也没有结果，知道我理解其原因，啧啧啧：</p>
</li>
</ol>
<p>我用java写好后端数据库交互层后，直接写了mian函数进行测试，成功！但是在我使用JSP文件发送ajax请求时，后端文件报错，无法找到sql驱动文件，我检查了sql文件，确实是在Java Resource的library中，并且直接运行java文件也通过了。。。搜索了很久，突然想到既然是javaweb程序，是不是在调用库文件时时使用的WebContent-&gt;WEB-INF-&gt;lib下的库文件，而不是调用java的库文件。我直接将sql驱动添加到javaweb的库中。nice，运行成功！</p>
<ol start="4">
<li><p>关于eclipse的问题，在测试的某一段时间，发现整个工程没有更新了，修改了代码也没有用，以前也发生过，一般重启一下server就ok了，可这次重启也没用，没办法，清除缓存把，我直接清除了工程的缓存。然后。。。就是java程序无法运行，一直报错：无法找到main函数入口。在网上看到很多这种情况，但一般都说是classpath设置不对，但我另一个工程却可以运行，所以明显不是这种情况，然后我看到了<a href="https://www.cnblogs.com/johnnyzen/p/7828503.html" target="_blank" rel="noopener">这篇文章</a><br>我按照第二条的方法，发现我有个库文件报错，直接移除，ok，解决（可是这和我的main函数有什么关系呢？？？）</p>
</li>
<li><p>最后在java那些库文件的语法方面我就不再BB了，反正是固定的API，按文档写就OK（其实是我懒，哈哈哈）~~~</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1></li>
</ol>
<p>最后我觉得我还是有个大问题，那就是变量的命名问题。。。This is a problem。很多不规范，这个在我以后的实践中尽量解决，比如~写个文档啊，哈哈哈。</p>
<p>所以这个项目就告一段落，前端的框架看一下就开学了~~~只能开学去看Python的GUI编程了~</p>
]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS伪类与伪元素</title>
    <url>/2019/11/20/CSS%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="伪类？伪元素？"><a href="#伪类？伪元素？" class="headerlink" title="伪类？伪元素？"></a>伪类？伪元素？</h1><p>之前一度认为伪类就是一组选择器，伪元素是不在DOM树的中的一些元素。但是当我看完MDN上的所有伪类与伪元素之后，才发现<strong>伪类与伪元素同属于CSS选择器的范畴</strong>，而伪元素其特殊之处在于伪元素可以选择的是一些不在DOM树中的元素，比如<code>::selection</code>用于选中用户用鼠标勾选的字符串；当然也可以选择在DOM树中的元素，比如<code>::first-line</code>用于选中元素的第一行，在特殊一点说，伪元素多用于选择一些特殊的东西，而伪类用于元素级别的选择，比如<code>:nth:child</code>用于选择某元素的第n个</p>
<p>伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。</p>
<p>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p>
<p> <strong>实际上最好的方法就是记住伪类与伪元素主要有哪些、特别是伪元素并不多。</strong></p>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><h3 id="状态伪类"><a href="#状态伪类" class="headerlink" title="状态伪类"></a>状态伪类</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:link</td>
<td>a:link</td>
<td>选择所有未访问的链接</td>
</tr>
<tr>
<td>:visited</td>
<td>a:visited</td>
<td>选择所有访问过的链接</td>
</tr>
<tr>
<td>:hover</td>
<td>a:hover</td>
<td>鼠标悬浮在链接上的状态</td>
</tr>
<tr>
<td>:active</td>
<td>a:active</td>
<td>选择在激活状态的链接</td>
</tr>
<tr>
<td>:focus</td>
<td>input:focus</td>
<td>选择获取焦点的输入框元素</td>
</tr>
<tr>
<td>:focus-within</td>
<td>form:focus-within</td>
<td>用在父级元素上，当子元素获得焦点时，父元素获得对应属性(IE未实现)</td>
</tr>
</tbody>
</table>
<h3 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>示例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:first-child</td>
<td>p:first-child</td>
<td>匹配一组兄弟元素中的第一个元素。（如果这个元素是p，就被匹配，否则不会被匹配。）</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>匹配一组兄弟元素中其类型的第一个元素。（即使第一个不是p，也会一次向下检索，直到找到这个p。）</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>匹配一组兄弟元素中的最后一个元素。（如果这个元素是p，就被匹配，否则不会被匹配。）</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>匹配一组兄弟元素中其类型的最后一个元素。（即使最后一个不是p，也会一次向上检索，直到找到这个p。）</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择所有p以外的元素（不支持伪类嵌套）</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>li:nth-child(2n+1)</td>
<td>首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3…）。<br />样例中即匹配所有奇数项的标签（注意所有的兄弟标签都会被算进去，即使不是li标签）</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>匹配一列兄弟元素，从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。（与上面相同，只是从后往前数）</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素）——兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2n+1)</td>
<td>匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素）——兄弟元素按照an+b形式的式子进行从后向前匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。<br />（与前面的类似，只是方向是从后往前数）<br />样例意思是匹配所有父元素下，是奇数位置的p元素。</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>匹配兄弟元素中某类型仅有的元素。<br />样例即为选择一个p元素，其兄弟元素都不是p元素。</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>匹配没有兄弟元素的元素。</td>
</tr>
<tr>
<td>:target</td>
<td>#news:target</td>
<td>匹配当前URL目标的元素（含锚点）。</td>
</tr>
</tbody>
</table>
<h3 id="表单伪类"><a href="#表单伪类" class="headerlink" title="表单伪类"></a>表单伪类</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>示例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择所有被禁用的元素。</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择所有被启用的（enabled）元素。</td>
</tr>
<tr>
<td>:required</td>
<td>input:required</td>
<td>选择设置 required 属性的表单元素</td>
</tr>
<tr>
<td>:read-only</td>
<td>input:read-only</td>
<td>选择设置 readonly 只读属性的元素</td>
</tr>
<tr>
<td>:read-write</td>
<td>input:read-write</td>
<td>选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。</td>
</tr>
<tr>
<td>:checked</td>
<td>input:checked</td>
<td>匹配被选中的 input 元素，input 元素包括 radio 和 checkbox</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>匹配所有没有子元素的 p 元素</td>
</tr>
<tr>
<td>:in-range</td>
<td>input:in-range</td>
<td>选择在指定区域内的元素</td>
</tr>
<tr>
<td>:out-of-range</td>
<td>input:out-of-range</td>
<td>选择不在指定区域内的元素</td>
</tr>
<tr>
<td>:valid</td>
<td>input:valid</td>
<td>选择条件验证正确的表单元素</td>
</tr>
<tr>
<td>:invalid</td>
<td>input:invalid</td>
<td>选择条件验证错误的表单元素</td>
</tr>
<tr>
<td>:optional</td>
<td>input:optional</td>
<td>选择没有 required 属性，即设置 optional 属性的表单元素</td>
</tr>
<tr>
<td>:default</td>
<td>-</td>
<td>匹配默认选中的元素(提交按钮总是表单的默认按钮)。</td>
</tr>
<tr>
<td>:indeterminate</td>
<td>-</td>
<td>当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。</td>
</tr>
<tr>
<td>:scope</td>
<td>-</td>
<td>匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。(试验阶段)</td>
</tr>
<tr>
<td>:root</td>
<td>:root</td>
<td>匹配文档树的根元素。</td>
</tr>
</tbody>
</table>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><h3 id="单双冒号"><a href="#单双冒号" class="headerlink" title="单双冒号"></a>单双冒号</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>::before/:before</td>
<td>在被选元素前插入内容。</td>
<td>需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。</td>
</tr>
<tr>
<td>::after/:after</td>
<td>在选被元素后插入内容</td>
<td>其用法和特性与:before相似。</td>
</tr>
<tr>
<td>::first-letter/:first-letter</td>
<td>匹配元素中文本的首字母。</td>
<td>匹配元素的第一个字母。</td>
</tr>
<tr>
<td>::first-line/:first-line</td>
<td>匹配元素中第一行的文本。</td>
<td>匹配包含此伪元素的元素的第一行。</td>
</tr>
</tbody>
</table>
<h3 id="双冒号"><a href="#双冒号" class="headerlink" title="双冒号"></a>双冒号</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>::selection</td>
<td>匹配被用户选中或者处于高亮状态的部分.</td>
<td>在火狐浏览器使用时需要添加 -moz 前缀。</td>
</tr>
<tr>
<td>::placeholder</td>
<td>匹配占位符的文本。</td>
<td>只有元素设置了 placeholder 属性时，该伪元素才能生效。</td>
</tr>
</tbody>
</table>
<h1 id="LAST"><a href="#LAST" class="headerlink" title="LAST"></a>LAST</h1><p>对于伪类与伪元素，最好的不是区分它们，而是记住常用的选择器是属于伪类还是伪元素。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>伪元素</tag>
        <tag>伪类</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP数据库处理</title>
    <url>/2019/01/31/JSP%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="JSP的数据库操作"><a href="#JSP的数据库操作" class="headerlink" title="JSP的数据库操作"></a>JSP的数据库操作</h1><p>经过这两天的操作，我觉得还是要看视频或者买书或者看官方文档学习，网上的资料缺点太多，写的过于简单，甚至兼容性也有问题。所以，搞了一天，终于，把数据库搞出来了~</p>
<a id="more"></a>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>sql.java</p>
<pre><code>package student.servlet;
import java.sql.*;


public class sql {
public static void Update(){
    Statement stmt = null;
    Connection connection = null;
    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    } catch (ClassNotFoundException e1) {
        // TODO Auto-generated catch block
        e1.printStackTrace();
    }
    String name=&quot;root&quot;;
    String pwd=&quot;957837&quot;;
    String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;;
    try {
     connection = DriverManager.getConnection(url,name,pwd);
     System.out.print(&quot;数据库连接成功！&quot;);
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    try {
        stmt = connection.createStatement();
        String sqlString = &quot;insert into blog values(5,&apos;https&apos;,&apos;hhhhh&apos;,&apos;2015-8-9&apos;)&quot;;
        int lines = stmt.executeUpdate(sqlString);
        System.out.print(&quot;插入成功&quot;+lines+&quot;受影响&quot;);
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } 
    try {
        if(stmt != null) {
        stmt.close();
        }
        connection.close();
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}

public static void Select() {
    Statement stmt = null;
    Connection connection = null;
    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    } catch (ClassNotFoundException e1) {
        // TODO Auto-generated catch block
        e1.printStackTrace();
    }
    String name=&quot;root&quot;;
    String pwd=&quot;957837&quot;;
    String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;;
    try {
     connection = DriverManager.getConnection(url,name,pwd);
     System.out.print(&quot;数据库连接成功&quot;);
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    try {
        stmt = connection.createStatement();
        String sqlString = &quot;select * from blog&quot;;
        ResultSet res = stmt.executeQuery(sqlString);
        System.out.println(&quot;查询数据库成功&quot;);
        while(res.next()) {
            int num= res.getInt(&quot;order_id&quot;);
            String title = res.getString(&quot;title&quot;);
            System.out.println(num);
            System.out.println(title);
        }
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } 
    try {
        if(stmt != null) {
        stmt.close();
        }
        connection.close();
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}

public static void main(String[] args){
//    Update();
    Select();
}

}
</code></pre><p>代码分析：</p>
<ol>
<li>对于连接数据库这种操作，一般不在JSP中操作，而是用javabean来操作，也就是说在创建一个java文件，将其作为数据库处理的文件，然后再JSP文件中连接该文件进行操作。</li>
</ol>
<ol start="2">
<li>引入数据库驱动，首先要去网上下载一个数据库驱动，不同的数据库系统驱动不同，这个是由数据库厂商提供的。下载完之后，就将其copy到Web App Libraries文件夹中。然后就可以使用该Class了。</li>
</ol>
<ol start="3">
<li>然后就是：<br> Statement connection = DriverManager.getConnection(url,name,pwd)</li>
</ol>
<p>使用该句来连接数据库（注意：在Java文件中，该句需要添加try…catch…）。</p>
<ol start="4">
<li><p>增删改数据库:</p>
<p> Statement stmt = connection.createStatement();</p>
<p> String sql = “insert…”;</p>
<p> //该方法返回的是受影响的行数<br>  int res =  connection.executeUpdate(sql)</p>
</li>
<li><p>查数据库：查数据唯一不同的是执行语句：</p>
<p> String sql =”…”;</p>
<p> ResultSet res = connection.executeQuery(sql);</p>
<p> while(res.next()) {</p>
<pre><code>    int num= res.getInt(&quot;...&quot;);
    String title = res.getString(&quot;...&quot;);
    System.out.println(num);
    System.out.println(title);
}
</code></pre></li>
</ol>
<p>注意：在获取数据库内容时，使用:ResultSet res =connection.executeQuery(sql),这个res是一个表的集合。可以类比遇一个Iterator</p>
<p>使用一个while循环来使用获取全部的数据。</p>
<p>res该对象含有：next(),hasNext()等方法来获取下一个。主要的还是get方法。但是获取不同类型的数据需要用不同的get方法：getInt(“name”);getString(“”)…like this。</p>
<ol start="6">
<li>最后需要注意的是，连接完数据库后，要把链接关闭。<ol>
<li>stmt.close();</li>
<li>connection();</li>
</ol>
</li>
</ol>
<p>这两个都要被关闭！</p>
<p>##Last but important##<br>就上面这几句代码，emmmm，在网上找了一天，现在才发现，网上的资料的参差不齐，终归还是要看文档，不行就看书，then，看视频。经验，哈哈哈。还有6天，做一个Demo吧，哈哈哈。</p>
]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP基础部分</title>
    <url>/2019/01/30/JSP%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>这几天把JSP基本部分看了，方便记忆，还是回顾一下。文件部分有一点复杂，所以后面直接单独解析一下。<br><a id="more"></a></p>
<h2 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h2><p>其实日期处理部分还是JAVA中的Date()对象提供的。只是之前学习JAVA是没认真看，哈哈哈。</p>
<h3 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h3><p>eg:</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ page import=&quot;java.io.*,java.util.*, javax.servlet.*&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;显示当前时间与日期&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;显示当前时间与日期&lt;/h1&gt;

&lt;%
   Date date = new Date();
   out.print( &quot;&lt;h2 align=\&quot;center\&quot;&gt;&quot; +date.toString()+&quot;&lt;/h2&gt;&quot;);
%&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>提示：任然是实例化Date对象，然后对该对象进行操作，其中该对象有以下方法：</p>
<p>序号    方法 &amp; 描述</p>
<ol>
<li><p>boolean after(Date date)<br>如果比给定的日期晚，则返回true，否则返回false</p>
</li>
<li><p>boolean before(Date date)<br>如果比给定的日期早，则返回true，否则返回false</p>
</li>
<li><p>Object clone( )<br>获取当前对象的一个副本</p>
</li>
<li><p>int compareTo(Date date)<br>如果与给定日期相等，则返回0，如果比给定日期早，则返回一个负数，如果比给定日期晚，则返回一个正数</p>
</li>
<li><p>int compareTo(Object obj)<br>与 compareTo(Date) 方法相同，如果 obj 不是Date类或其子类的对象，抛出ClassCastException异常</p>
</li>
<li><p>boolean equals(Object date)<br>如果与给定日期相同，则返回true，否则返回false</p>
</li>
<li><p>long getTime( )<br>返回从1970年1月1日凌晨至此对象所表示时间的毫秒数</p>
</li>
<li><p>int hashCode( )<br>返回此对象的哈希码</p>
</li>
<li><p>void setTime(long time)<br>使用给定参数设置时间和日期，参数time表示从1970年1月1日凌晨至time所经过的毫秒数</p>
</li>
<li><p>String toString( )<br>将此对象转换为字符串并返回这个字符串</p>
</li>
</ol>
<h3 id="日期的比较"><a href="#日期的比较" class="headerlink" title="日期的比较"></a>日期的比较</h3><ul>
<li>使用getTime()方法得到毫秒数，然后比较毫秒数就行了。</li>
<li>使用before()，after()，equals()方法。比如，new Date(99,2,12).before(new Date(99,2,18))返回true。</li>
<li>使用compareTo()方法，这个方法在Comparable接口中定义，在Date中实现。</li>
</ul>
<h3 id="使用SimpleDateFormat格式化日期"><a href="#使用SimpleDateFormat格式化日期" class="headerlink" title="使用SimpleDateFormat格式化日期"></a>使用SimpleDateFormat格式化日期</h3><p>eg:</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt;
&lt;%@ page import=&quot;javax.servlet.*,java.text.*&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;显示当前时间与日期&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;显示当前时间与日期&lt;/h1&gt;

&lt;%
   Date dNow = new Date( );
   SimpleDateFormat ft = 
   new SimpleDateFormat (&quot;yyyy-MM-dd HH:mm:ss&quot;);
   out.print( &quot;&lt;h2 align=\&quot;center\&quot;&gt;&quot; + ft.format(dNow) + &quot;&lt;/h2&gt;&quot;);
%&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>SimpleDateFormat格式码</strong></p>
<p>字符    描述    示例<br>G    时代标识符    AD</p>
<p>y    4位数年份    2001</p>
<p>M    月    July or 07</p>
<p>d    日    10</p>
<p>h    12小时制， A.M./P.M. (1~12)    12</p>
<p>H    24小时制    22</p>
<p>m    分钟    30</p>
<p>s    秒    55</p>
<p>S    毫秒    234</p>
<p>E    星期    Tuesday</p>
<p>D    一年中的某天    360</p>
<p>F    一个月中某星期的某天    2 (second Wed. in July)</p>
<p>w    一年中的某星期    40</p>
<p>W    一个月中的某星期    1</p>
<p>a    A.M./P.M. 标记    PM</p>
<p>k    一天中的某个小时 (1~24)    24</p>
<p>K    一天中的某个小时，A.M./P.M. (0~11)    10</p>
<p>z    时区    Eastern Standard Time</p>
<p>‘    文本分隔    Delimiter</p>
<p>“    单引号    `</p>
<h2 id="页面重定向"><a href="#页面重定向" class="headerlink" title="页面重定向"></a>页面重定向</h2><p>页面重定向是指在client访问a.jsp时，根据据需要，a.jsp页面将请求重定向至另一个页面。<br>注意这一个过程中，a.jsp的所有内容都不会返回至client，而是直接将请求引导至新页面，也就是说client会进行二次访问，新页面的加载还是又client来完成。</p>
<p>eg:</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt;
&lt;html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;页面重定向&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;页面重定向&lt;/h1&gt;

&lt;%
   // 重定向到新地址,关键部分
   String site = new String(&quot;http://www.runoob.com&quot;);
   response.setStatus(response.SC_MOVED_TEMPORARILY);
   response.setHeader(&quot;Location&quot;, site); 
%&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>还有一个类似的请求转发，而请求转发是在接手到client的请求后，在server端进行请求，然后再这个请求的基础上将新内容返回。也就是说，该种方法只经历了1次请求，<strong>并且转发只能是转发到本次请求的服务器，而重定向则可以定向到其他服务器。(进过我的测试暂时是这样)</strong></p>
<p>我在看这一部分时，想在重定向或者焕发之前给client一些提示，但是由于该页面的内容内容根本不会写入到response中，所以是不能实现的，在网上查找了一圈的资料，基本都是说使用前端来实现跳转，才能给客户端反馈。</p>
<p>比如:</p>
<pre><code>out.print(&quot;&lt;script&gt;
alert(&quot;即将跳转至百度！&quot;);
window.href=&quot;http:www.baidu.com&quot;;
&lt;/script&gt;&quot;)
</code></pre><p>所以，如果使用重定向或者是转发，是不能给客户端提示的，如果要提示，就要用前端实现跳转。</p>
<h2 id="JSP点击量统计"><a href="#JSP点击量统计" class="headerlink" title="JSP点击量统计"></a>JSP点击量统计</h2><p>在菜鸟上，对于统计量方法的实现，时使用application对象来存储一对键值，在访问时动态变化，实现访问量统计。所以我们看一下applicant这个对象，它有以下特点：</p>
<ol>
<li>在服务器启动时自动创建，<strong>在服务器关闭时自动销毁</strong></li>
<li>一个网站仅有一个application，也就是说所有的客户共享一个application。</li>
</ol>
<p>所以如果服务器遇到宕机，那么这个量就被销毁了，所以最保险的方法是将其储存到数据库中，并定期刷新。保证不会频繁访问数据库，又可以最大化的保存数据。</p>
<p>eg:</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt;
&lt;html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;访问量统计&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%
    Integer hitsCount = 
      (Integer)application.getAttribute(&quot;hitCounter&quot;);
    if( hitsCount ==null || hitsCount == 0 ){
       /* 第一次访问 */
       out.println(&quot;欢迎访问菜鸟教程!&quot;);
       hitsCount = 1;
    }else{
       /* 返回访问值 */
       out.println(&quot;欢迎再次访问菜鸟教程!&quot;);
       hitsCount += 1;
    }
    application.setAttribute(&quot;hitCounter&quot;, hitsCount);
%&gt;

&lt;p&gt;页面访问量为: &lt;%= hitsCount%&gt;&lt;/p&gt;


&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="JSP自动刷新"><a href="#JSP自动刷新" class="headerlink" title="JSP自动刷新"></a>JSP自动刷新</h2><p>我其实觉得这个功能可以在前端实现，不过也许有些时候必须要使用后端实现呢，所以还是看一下，其实就一句：</p>
<pre><code>response.setIntHeader(&quot;Refresh&quot;, 5);
</code></pre><p>eg:</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;自动刷新实例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;自动刷新实&lt;/h2&gt;
&lt;%
   // 设置每隔5秒刷新一次
   response.setIntHeader(&quot;Refresh&quot;, 5);
   // 获取当前时间
   Calendar calendar = new GregorianCalendar();
   String am_pm;
   int hour = calendar.get(Calendar.HOUR);
   int minute = calendar.get(Calendar.MINUTE);
   int second = calendar.get(Calendar.SECOND);
   if(calendar.get(Calendar.AM_PM) == 0)
      am_pm = &quot;AM&quot;;
   else
      am_pm = &quot;PM&quot;;
   String CT = hour+&quot;:&quot;+ minute +&quot;:&quot;+ second +&quot; &quot;+ am_pm;
   out.println(&quot;当前时间为: &quot; + CT + &quot;\n&quot;);
%&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>通过这个栗子可以看出效果，当然，对于日期的刷新，不肯能用这个东西，肯定是局部的ajax来实现。</p>
]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>JS代码段所放位置的区别</title>
    <url>/2018/10/19/JS%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%89%80%E6%94%BE%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很久之前就遇到了这个问题，由于代码段放的位置不对导致代码段无法生效。所以这次就简单写一下代码段不同位置的区别。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p><strong>JS是一种解释性脚本（不进行预编译）</strong></p>
<p>高级语言的两种翻译方式：</p>
<ol>
<li>编译</li>
</ol>
<p>以基本的C语言为例，大部分语言是直接通过编译器将高级语言编译成为机器可以懂的机器语言（二进制文件 .exe）。但是也有不一样的，比如JAVA这种跨平台语言，它是将高级语言先编译成为JAVA虚拟机能够识别的class文件，在不同的平台上再编译为相应的机器语言，实现跨平台。</p>
<ol start="2">
<li>解释</li>
</ol>
<p>解释性脚本脚本不需要编译，在执行时才进行解释。解释性脚本语言有专门的解释器，不过每次执行时都需要编译，所以效率比较低。</p>
<p>JavaScript也有自己的解释器–JavaScript引擎，他是浏览器的一部分。</p>
<h2 id="HTML-语言的执行顺序"><a href="#HTML-语言的执行顺序" class="headerlink" title="HTML 语言的执行顺序"></a>HTML 语言的执行顺序</h2><p>作为一门解释性脚本语言，它的执行顺序是从前到后顺序执行。</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  

&lt;head&gt;  
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.js&quot;&gt;&lt;/script&gt;  
&lt;title&gt;Html页面内容执行顺序&lt;/title&gt;
&lt;style&gt;&lt;/style&gt;     
&lt;/head&gt;  

&lt;body&gt;  

&lt;script type=&quot;text/javascript&quot;&gt;  
    var userId = $(&apos;#hiddenUserId&apos;).val();  
    var contextPath = $(&apos;#hiddenContextPath&apos;).val();  
    var userName = $(&apos;#hiddenUserName&apos;).val();  
    alert(userName);
&lt;/script&gt;  
&lt;/body&gt;  

&lt;/html&gt;
</code></pre><p>按照顺序执行，先解析该文档为HTML文档，接着解析head部分的script脚本，head部分的style样式，接着渲染body部分，接着解析body中的script脚本。</p>
<p>按照以上顺序，我就可以理解为什么我上一次引用的验证码脚本以及vue框架放在HTML中head部分时，无法生效。原因是在于如果将脚本放在head中，script脚本执行时DOM树还没有被渲染，所以脚本是无法执行对DOM进行修改的。而如果将脚本放在body尾部，执行此脚本时，DOM树已被渲染完毕，所以可执行修改操作。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>1.head中所放的JavaScript代码段主要功能应该是不会在页面加载时就进行执行的脚本功能，即后续通过其他操作触发的（比如onclik按键触发），这类脚本可以预先解释，在需要时再执行</strong></p>
<p><strong>2.body后面放的脚本应该是页面加载时就要触发的脚本，比如对DOM数内容的初始化（向上面的验证码系统，vue的脚本）</strong></p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p><strong>以下情况可以改变JS代码的执行顺序</strong></p>
<ol>
<li>window.onload:等到页面中的所有内容加载完成后才会执行。</li>
<li>$(document).ready():页面中所有的DOM结构绘制完成后就能够执行。</li>
<li>script脚本中，大部分浏览器支持async和defer属性。</li>
</ol>
<p><strong>async</strong>表示的意思是异步加载JavaScript文件，它的下载过程可以在HTML的解析过程中进行，加载完成之后立即执行这个文件的代码，执行文件代码的过程中会阻塞HTML的解析，它不保证文件加载的顺序。</p>
<p><strong>defer</strong>表示的意思是在HTML文档解析之后在执行加载完成的JavaScript文件，JavaScript文件的下载过程可以在HTML的解析过程中进行，它是按照script标签的先后顺序来加载文件的。</p>
<p>参考资料：</p>
<p>1.<a href="https://segmentfault.com/a/1190000009083504" target="_blank" rel="noopener">把JavaScript文件放在文档的头部还是尾部</a></p>
<p>2.<a href="https://blog.csdn.net/bigtree_3721/article/details/51006066?utm_source=blogxgwz0" target="_blank" rel="noopener">CSS、JS 放置位置与前端性能的关系？</a></p>
<p>3.<a href="https://blog.csdn.net/m0_37550086/article/details/77513676" target="_blank" rel="noopener">HTML页面的加载顺序</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的.与[]的区别</title>
    <url>/2019/03/03/JavaScript%E4%B8%AD%E7%9A%84.%E4%B8%8E%5B%5D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="叨叨一下"><a href="#叨叨一下" class="headerlink" title="叨叨一下"></a>叨叨一下</h1><p>最近在看ES6，感觉很有意思啊。然后就遇到了这个问题，.(点)与[] (方括号)的区别。</p>
<a id="more"></a>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这个问题是在遍历器(Iterator)这一部分发现的，其中对于不存在遍历器的数据结构，比如一个对象。我们可以自定义一个遍历器，就可以实现forEach,for…in…等方法。然后就出现下面这段语句：</p>
<pre><code>var arrlike = {
    0:a,
    1:b,
    2:c
}

arrlike.[Symbol.iterator](){
    //遍历器内容，略
}
</code></pre><p>问题就在：<code>arrlike.[Symbol.iterator]()</code>，如果Symbol是对象arrlike的一个属性，那么为什么不能用arrlike.Symbol…的方法来获取该属性。</p>
<p>下面就说一下这两个的区别：</p>
<ul>
<li><p>相同:</p>
<p>.与[]都可以获取元素的属性。</p>
</li>
<li><p>不同:</p>
</li>
</ul>
<ol>
<li>中括号运算符可以用字符串变量的内容作为属性名。点运算符不能。</li>
<li>中括号运算符可以用纯数字为属性名。点运算符不能。</li>
<li>中括号运算符可以用js的关键字和保留字作为属性名。点运算符不能。</li>
</ol>
<p>说回上面的<code>arrlike.[Symbol.iterator]()</code>,Symbol.iterator是一个JS内置的一个关键字，然后这个属性返回的是一个函数。</p>
<p>然后后面的括号就是执行该函数。</p>
<pre><code>function fun1(){return &quot;yes&quot;}

console.log(func1) //function...

console.log(func1()) //yes
</code></pre><h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>ES6还是真的有意思，加油鸭！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的&amp;，&amp;&amp;，|，||</title>
    <url>/2020/01/07/JavaScript%E4%B8%AD%E7%9A%84%E4%B8%8E%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="简单区分-amp-amp-amp"><a href="#简单区分-amp-amp-amp" class="headerlink" title="简单区分&amp;,&amp;&amp;,|,||"></a>简单区分&amp;,&amp;&amp;,|,||</h1><h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>&amp; 位与运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右全为1才为1</p>
<h2 id=""><a href="#" class="headerlink" title="|"></a>|</h2><p>| 位或运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右有一个1结果就为1</p>
<h2 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h2><p>&amp;&amp; 逻辑运算符（与） — 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- </p>
<ul>
<li><p>如果第一个值（转换后）为true，则返回后一个值。</p>
</li>
<li><p>如果第一个值（转换后）为false，则返回第一个值。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="||"></a>||</h2><p>|| 逻辑运算符（或）—- 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- </p>
</li>
<li><p>如果第一个值（转化后）为true，则返回第一个值。</p>
</li>
<li>如果第一个值（转化后）为false，则返回第二个值。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中数组与对象的遍历方法</title>
    <url>/2021/01/26/JavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>最传统的方法，按下标存取，也是最高效的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1，2，3，4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不用每次计算len，更加高效</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, <span class="keyword">let</span> len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1，2，3，4</span></span><br></pre></td></tr></table></figure>
<h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p><code>for...of</code>语句创建一个迭代器(ES6引入，迭代器只会便利可枚举属性)。每一次循环都会调用迭代器的<code>next</code>对象。并返回当前该迭代器的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1,2,3,4</span></span><br></pre></td></tr></table></figure>
<p>另外只要实现了迭代器的数据才能使用<code>for...of</code>循环。具体有：<code>Array</code>，<code>Maps</code>，<code>Set</code>，<code>String</code>，<code>Arguments Object参数对象</code>，<code>Generators(生成器)</code></p>
<h2 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h2><p><strong><code>for...in</code>语句</strong>以任意顺序遍历一个对象的除<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">Symbol</a>以外的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" target="_blank" rel="noopener">可枚举</a>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0，1，2，3</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><code>for ...in</code>循环遍历得到的结果为数据的键（数组即为下标）。</li>
<li>数组最好不要用<code>for...in</code>，因为<code>for...in</code>循环是为遍历对象而且设计的。</li>
<li>该方法也可用于<code>String</code>遍历下标。</li>
<li><code>for...in</code>会顺着原型链向上遍历，原型链上所有的可遍历对象都会被遍历。比如（定义<code>Array.prototype.max = () =&gt; {...}</code>来获取数组中最大值，如果这么定义，那么这个属性也会被<code>for...in</code>纳入遍历）</li>
</ol>
<h2 id="Array-prototype-entries"><a href="#Array-prototype-entries" class="headerlink" title="Array.prototype.entries()"></a>Array.prototype.entries()</h2><p>该方法一个新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array" target="_blank" rel="noopener"><code>Array</code></a> 迭代器对象。<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-createarrayiterator" target="_blank" rel="noopener">Array Iterator</a>是对象，它的原型（<strong>proto</strong>:Array Iterator）上有一个<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-%arrayiteratorprototype%.next" target="_blank" rel="noopener">next</a>方法，可用用于遍历迭代器取得原数组的[key,value]。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = arr.entries();</span><br><span class="line"><span class="built_in">console</span>.log(iterator);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="comment">         __proto__:Array Iterator</span></span><br><span class="line"><span class="comment">         next:ƒ next()</span></span><br><span class="line"><span class="comment">         Symbol(Symbol.toStringTag):"Array Iterator"</span></span><br><span class="line"><span class="comment">         __proto__:Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>用法一（直接使用<code>Iterator</code>的<code>next</code>对象）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator1 = array1.entries();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator1.next().value);</span><br><span class="line"><span class="comment">// expected output: Array [0, "a"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator1.next().value);</span><br><span class="line"><span class="comment">// expected output: Array [1, "b"]</span></span><br></pre></td></tr></table></figure>
<p>用法二（二维数组按行排序）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> goNext = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> entries = arr.entries();</span><br><span class="line">    <span class="keyword">while</span> (goNext) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = entries.next();</span><br><span class="line">        <span class="keyword">if</span> (result.done !== <span class="literal">true</span>) &#123;</span><br><span class="line">            result.value[<span class="number">1</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">            goNext = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goNext = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>,<span class="number">34</span>],[<span class="number">456</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">44</span>,<span class="number">234</span>],[<span class="number">4567</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">34</span>,<span class="number">78</span>,<span class="number">23</span>,<span class="number">1</span>]];</span><br><span class="line">sortArr(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*(4) [Array(2), Array(5), Array(5), Array(4)]</span></span><br><span class="line"><span class="comment">    0:(2) [1, 34]</span></span><br><span class="line"><span class="comment">    1:(5) [2, 3, 44, 234, 456]</span></span><br><span class="line"><span class="comment">    2:(5) [1, 4, 5, 6, 4567]</span></span><br><span class="line"><span class="comment">    3:(4) [1, 23, 34, 78]</span></span><br><span class="line"><span class="comment">    length:4</span></span><br><span class="line"><span class="comment">    __proto__:Array(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>法三（使用for…of 循环）最典型：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = arr.entries();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="comment">// [1, "b"]</span></span><br><span class="line"><span class="comment">// [2, "c"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, value] <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index+<span class="string">'---'</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-"a"</span></span><br><span class="line"><span class="comment">// 1-"b"</span></span><br><span class="line"><span class="comment">// 2-"c"</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-keys"><a href="#Array-prototype-keys" class="headerlink" title="Array.prototype.keys()"></a>Array.prototype.keys()</h2><p> <strong>keys()</strong> 方法返回一个包含数组中每个索引键的<strong>Array Iterator</strong>对象。</p>
<p>与上面的<code>Array.prototype.entries()</code>相同，只是遍历的是索引键。用法与上面完全一致，本质也是迭代器。</p>
<p>典型用法(结合<code>for...of</code>)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0，1，2，3</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-values"><a href="#Array-prototype-values" class="headerlink" title="Array.prototype.values()"></a>Array.prototype.values()</h2><p><strong><code>values()</code></strong> 方法返回一个新的 <strong><code>Array Iterator</code></strong> 对象，该对象包含数组每个索引的值</p>
<p>与上面的<code>Array.prototype.entries()</code>相同，只是遍历的是索引键。用法与上面完全一致，本质也是迭代器。</p>
<p>典型用法(结合<code>for...of</code>)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a，b，c</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-every"><a href="#Array-prototype-every" class="headerlink" title="Array.prototype.every()"></a>Array.prototype.every()</h2><p><strong>every()</strong>方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</p>
<p>其接收一个回调函数<code>callback</code>，<code>callback</code> 在被调用时可传入三个参数：元素值，元素的索引，原数组。</p>
<p><code>every</code> 不会改变原数组。</p>
<p><code>every</code> 和数学中的”所有”类似，<strong>当所有的元素都符合条件才会返回<code>true</code>。</strong>正因如此，若传入一个空数组，无论如何都会返回 <code>true</code>。（这种情况属于<a href="http://en.wikipedia.org/wiki/Vacuous_truth" target="_blank" rel="noopener">无条件正确</a>：正因为一个<a href="https://en.wikipedia.org/wiki/Empty_set#Properties" target="_blank" rel="noopener">空集合</a>没有元素，所以它其中的所有元素都符合给定的条件。)</p>
<p><strong>注意</strong>：若收到一个空数组，此方法在一切情况下都会返回 <code>true</code>。</p>
<p>典型用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">arr.every(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//true（因为所有的value都大于3）</span></span><br><span class="line"></span><br><span class="line">arr.every(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//false（其中4,5不满足条件）</span></span><br></pre></td></tr></table></figure>
<p><code>every</code>方法不会改变数组。</p>
<h3 id="Pollyfill（最基础，下同）"><a href="#Pollyfill（最基础，下同）" class="headerlink" title="Pollyfill（最基础，下同）"></a>Pollyfill（最基础，下同）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.every) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'every'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">          <span class="string">'Array.prototype.every '</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> res = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [i, v] <span class="keyword">of</span> <span class="keyword">this</span>.entries()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!callback(v)) &#123;</span><br><span class="line">          res = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-some"><a href="#Array-prototype-some" class="headerlink" title="Array.prototype.some()"></a>Array.prototype.some()</h2><p>这个方法与上面的方法使用方法完全相同，但是所用相反，<strong>some()</strong>方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。</p>
<p>其接收一个回调函数<code>callback</code>，<code>callback</code> 在被调用时可传入三个参数：元素值，元素的索引，原数组。</p>
<p><strong>注意：</strong>如果用一个空数组进行测试，在任何情况下它返回的都是<code>false</code>。</p>
<p>典型用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr.some(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">8</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//true（因为存在一个9大于8）</span></span><br><span class="line"></span><br><span class="line">arr.some(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">12</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//false（因为所有的value都小于12）</span></span><br></pre></td></tr></table></figure>
<p><code>some</code>方法不会改变数组。</p>
<h3 id="Pollyfill"><a href="#Pollyfill" class="headerlink" title="Pollyfill"></a>Pollyfill</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.prototype.some)&#123;</span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'some'</span>, &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> (<span class="params">callbakc</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">              <span class="string">'Array.prototype.some '</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> res = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> [i, v] <span class="keyword">of</span> <span class="keyword">this</span>.entries()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (callbakc(v, i, <span class="keyword">this</span>)) &#123;</span><br><span class="line">              res = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h2><p><strong>filter()</strong> 方法创建一个新数组, 其包含通过所提供函数实现的<strong>过滤</strong>的所有元素的结果。 </p>
<p><strong>接收</strong>：一个回调函数，函数包含3个参数。<code>value</code>(元素的值)，<code>index</code>(元素的索引)，<code>arr</code>(被遍历的数组本身)</p>
<p><strong>返回</strong>：一个数组，包含所有的元素的检测结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr.filter(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//[3, 4]</span></span><br></pre></td></tr></table></figure>
<p>该方法可用于剔除不合法数据，比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">arr.filter(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">undefined</span> &amp;&amp; value != <span class="literal">null</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p><code>flter</code>方法不会改变数组。</p>
<h3 id="Pollyfill-1"><a href="#Pollyfill-1" class="headerlink" title="Pollyfill"></a>Pollyfill</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.filter) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'filter'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">          <span class="string">'Array.prototype.filter '</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> res = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback(<span class="keyword">this</span>[i])) &#123;</span><br><span class="line">          res.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find()"></a>Array.prototype.find()</h2><p> <strong>find()</strong> 方法返回数组中满足提供的测试函数的<strong>第一个</strong>元素的值。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>。</p>
<p><strong>接收</strong>：一个回调函数，函数包含3个参数。<code>value</code>(元素的值)，<code>index</code>(元素的索引)，<code>arr</code>(被遍历的数组本身)</p>
<p><strong>返回</strong>：数组中满足提供的测试函数的<strong>第一个</strong>元素的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr.find(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2（由于3，4均大于2，但是3是第一个，所以返回3的下标2）</span></span><br></pre></td></tr></table></figure>
<p><code>find</code>方法不会改变数组。</p>
<h3 id="Pollyfill-2"><a href="#Pollyfill-2" class="headerlink" title="Pollyfill"></a>Pollyfill</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.find) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'find'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">          <span class="string">'Array.prototype.find '</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> res = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback(<span class="keyword">this</span>[i], i, <span class="keyword">this</span>)) &#123;</span><br><span class="line">          res = <span class="keyword">this</span>[i];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-findIndex"><a href="#Array-prototype-findIndex" class="headerlink" title="Array.prototype.findIndex()"></a>Array.prototype.findIndex()</h2><p><strong>findIndex()</strong>方法返回数组中满足提供的测试函数的第一个元素的<strong>索引</strong>。若没有找到对应元素则返回-1。</p>
<p><strong>接收</strong>：一个回调函数，函数包含3个参数。<code>value</code>(元素的值)，<code>index</code>(元素的索引)，<code>arr</code>(被遍历的数组本身)</p>
<p><strong>返回</strong>：数组中满足提供的测试函数的<strong>最后一个</strong>元素的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr.find(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3（由于3，4均大于2，但是4是最后一个，所以返回4的下标3）</span></span><br></pre></td></tr></table></figure>
<h3 id="Pollyfill-3"><a href="#Pollyfill-3" class="headerlink" title="Pollyfill"></a>Pollyfill</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.findIndex) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'findIndex'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">          <span class="string">'Array.prototype.findIndex '</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> res = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback(<span class="keyword">this</span>[i], i, <span class="keyword">this</span>)) &#123;</span><br><span class="line">          res = i;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h2><p><strong>forEach()</strong>方法对数组的每个元素执行一次给定的函数。</p>
<p><strong>接收</strong>：一个回调函数，函数包含3个参数。<code>value</code>(元素的值)，<code>index</code>(元素的索引)，<code>arr</code>(被遍历的数组本身)</p>
<p><strong>返回</strong>：<code>undefined</code>。</p>
<p><code>forEach()</code> 为每个数组元素执行一次 <code>callback</code> 函数；与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map()</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" target="_blank" rel="noopener"><code>reduce()</code></a> 不同的是，它总是返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a> 值，并且不可链式调用。其典型用例是在一个调用链的最后执行副作用（side effects，函数式编程上，指函数进行 返回结果值 以外的操作）。</p>
<p> <code>forEach</code> 不会直接改变调用它的对象，但是那个对象可能会被 <code>callback</code> 函数改变。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    res.push(value*<span class="number">2</span>) </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res)		<span class="comment">//[2,4,6,8]</span></span><br></pre></td></tr></table></figure>
<h3 id="Pollyfill-4"><a href="#Pollyfill-4" class="headerlink" title="Pollyfill"></a>Pollyfill</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.forEach) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'forEach'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">          <span class="string">'Array.prototype.forEach '</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        callback(<span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><p><strong>map()</strong>方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。（<code>forEach</code>类似，区别是<code>forEach</code>不用返回，一起操作都在回调函数中进行）</p>
<p><strong>接收</strong>：一个回调函数，函数包含3个参数。<code>value</code>(元素的值)，<code>index</code>(元素的索引)，<code>arr</code>(被遍历的数组本身)</p>
<p><strong>返回</strong>：一个由原数组每个元素执行回调函数的结果组成的<strong>新数组</strong>。</p>
<p>上面的示例重写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.map(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res)		<span class="comment">//[2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>callback</code> 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 <code>delete</code> 删除的索引则不会被调用。</li>
<li>因为<code>map</code>生成一个新数组，当你不打算使用返回的新数组却使用<code>map</code>是违背设计初衷的，请用<code>forEach</code>或者<code>for-of</code>替代。</li>
<li><code>map</code>不修改调用它的原数组本身（当然可以在 <code>callback</code> 执行时改变原数组）</li>
<li>根据规范中定义的算法，如果被map调用的数组是离散的（如：arr = [<em>empty</em>x2, 3]），新数组将也是离散的保持相同的索引为空。</li>
</ol>
<h3 id="Pollyfill-5"><a href="#Pollyfill-5" class="headerlink" title="Pollyfill"></a>Pollyfill</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.map) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'map'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">          <span class="string">'Array.prototype.map '</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> res = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        res.push(callback(<span class="keyword">this</span>[i], i, <span class="keyword">this</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h2><p><strong>reduce()</strong>方法对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。</p>
<p><strong>接受</strong>：函数累计处理的结果<strong>reducer</strong> 函数接收4个参数:</p>
<ol>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)</li>
</ol>
<p><code>callback</code> 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 <code>delete</code> 删除的索引则不会被调用。</p>
<p><strong>返回值</strong>：函数累计处理的结果</p>
<p>示例：</p>
<ol>
<li><strong>数组里所有值的和</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">accumulator, currentValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 和为 6</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>累加对象数组里的值</strong></li>
</ol>
<p>要累加对象数组中包含的值，必须提供初始值，以便各个item正确通过你的函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var initialValue &#x3D; 0;</span><br><span class="line">var sum &#x3D; [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce(function (accumulator, currentValue) &#123;</span><br><span class="line">    return accumulator + currentValue.x;</span><br><span class="line">&#125;,initialValue)</span><br><span class="line"></span><br><span class="line">console.log(sum) &#x2F;&#x2F; logs 6</span><br></pre></td></tr></table></figure>
<p>你也可以写成箭头函数的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var initialValue &#x3D; 0;</span><br><span class="line">var sum &#x3D; [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce(</span><br><span class="line">    (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue.x</span><br><span class="line">    ,initialValue</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(sum) &#x2F;&#x2F; logs 6</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>计算数组中每个元素出现的次数</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var names &#x3D; [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Tiff&#39;, &#39;Bruce&#39;, &#39;Alice&#39;];</span><br><span class="line"></span><br><span class="line">var countedNames &#x3D; names.reduce(function (allNames, name) &#123;</span><br><span class="line">  if (name in allNames) &#123;</span><br><span class="line">    allNames[name]++;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    allNames[name] &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return allNames;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">&#x2F;&#x2F; countedNames is:</span><br><span class="line">&#x2F;&#x2F; &#123; &#39;Alice&#39;: 2, &#39;Bob&#39;: 1, &#39;Tiff&#39;: 1, &#39;Bruce&#39;: 1 &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h4><p><code>reduce</code> 被添加到 ECMA-262 标准第 5 版，因此它在某些实现环境中可能不被支持。把下面的代码添加到脚本开头可以解决此问题，从而允许在那些没有原生支持 <code>reduceRight</code> 的实现环境中使用它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Production steps of ECMA-262, Edition 5, 15.4.4.21</span></span><br><span class="line"><span class="comment">// Reference: http://es5.github.io/#x15.4.4.21</span></span><br><span class="line"><span class="comment">// https://tc39.github.io/ecma262/#sec-array.prototype.reduce</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.reduce) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'reduce'</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">callback <span class="regexp">/*, initialValue*/</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>( <span class="string">'Array.prototype.reduce '</span> +</span><br><span class="line">          <span class="string">'called on null or undefined'</span> );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>( callback +</span><br><span class="line">          <span class="string">' is not a function'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1. Let O be ? ToObject(this value).</span></span><br><span class="line">      <span class="keyword">var</span> o = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. Let len be ? ToLength(? Get(O, "length")).</span></span><br><span class="line">      <span class="keyword">var</span> len = o.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Steps 3, 4, 5, 6, 7</span></span><br><span class="line">      <span class="keyword">var</span> k = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        value = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; len &amp;&amp; !(k <span class="keyword">in</span> o)) &#123;</span><br><span class="line">          k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. If len is 0 and initialValue is not present,</span></span><br><span class="line">        <span class="comment">//    throw a TypeError exception.</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt;= len) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>( <span class="string">'Reduce of empty array '</span> +</span><br><span class="line">            <span class="string">'with no initial value'</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        value = o[k++];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 8. Repeat, while k &lt; len</span></span><br><span class="line">      <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="comment">// a. Let Pk be ! ToString(k).</span></span><br><span class="line">        <span class="comment">// b. Let kPresent be ? HasProperty(O, Pk).</span></span><br><span class="line">        <span class="comment">// c. If kPresent is true, then</span></span><br><span class="line">        <span class="comment">//    i.  Let kValue be ? Get(O, Pk).</span></span><br><span class="line">        <span class="comment">//    ii. Let accumulator be ? Call(</span></span><br><span class="line">        <span class="comment">//          callbackfn, undefined,</span></span><br><span class="line">        <span class="comment">//          « accumulator, kValue, k, O »).</span></span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> o) &#123;</span><br><span class="line">          value = callback(value, o[k], k, o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. Increase k by 1.</span></span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 9. Return accumulator.</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//concise method     </span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.reduce) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'reduce'</span>, &#123;</span><br><span class="line">          enumerable: <span class="literal">false</span>,</span><br><span class="line">          value: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">                <span class="string">'Array.prototype.map '</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">              count += callback(count, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-reduceRight"><a href="#Array-prototype-reduceRight" class="headerlink" title="Array.prototype.reduceRight()"></a>Array.prototype.reduceRight()</h2><p>这个方法与<code>Array.prototype.reduce()</code>只是执行顺序上相反（从右到左）。</p>
<p><strong>reduceRight()</strong>方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。</p>
<p><strong>接收</strong>：一个回调函数，函数包含3个参数。<code>value</code>(元素的值)，<code>index</code>(元素的索引)，<code>arr</code>(被遍历的数组本身)</p>
<h3 id="求一个数组中所有值的和"><a href="#求一个数组中所有值的和" class="headerlink" title="求一个数组中所有值的和"></a>求一个数组中所有值的和</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sum is 6 （虽然结果相同，但是是从右到左加）</span></span><br></pre></td></tr></table></figure>
<h3 id="展示-reduce-与-reduceRight-之间的区别"><a href="#展示-reduce-与-reduceRight-之间的区别" class="headerlink" title="展示 reduce 与 reduceRight 之间的区别"></a>展示 <code>reduce</code> 与 <code>reduceRight</code> 之间的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;];</span><br><span class="line">var left  &#x3D; a.reduce(function(prev, cur)      &#123; return prev + cur; &#125;);</span><br><span class="line">var right &#x3D; a.reduceRight(function(prev, cur) &#123; return prev + cur; &#125;);</span><br><span class="line"></span><br><span class="line">console.log(left);  &#x2F;&#x2F; &quot;12345&quot;</span><br><span class="line">console.log(right); &#x2F;&#x2F; &quot;54321&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Polyfill-1"><a href="#Polyfill-1" class="headerlink" title="Polyfill"></a>Polyfill</h2><p><code>reduceRight</code> 被添加到 ECMA-262 标准第 5 版，因此它在某些实现环境中可能不被支持。把下面的代码添加到脚本开头可以解决此问题，从而允许在那些没有原生支持 <code>reduceRight</code> 的实现环境中使用它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Production steps of ECMA-262, Edition 5, 15.4.4.22</span></span><br><span class="line"><span class="comment">// Reference: http://es5.github.io/#x15.4.4.22</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'function'</span> !== <span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.reduceRight) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.reduceRight = <span class="function"><span class="keyword">function</span>(<span class="params">callback <span class="regexp">/*, initialValue*/</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === <span class="keyword">this</span> || <span class="string">'undefined'</span> === <span class="keyword">typeof</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Array.prototype.reduceRight called on null or undefined'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'function'</span> !== <span class="keyword">typeof</span> callback) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="built_in">Object</span>(<span class="keyword">this</span>), len = t.length &gt;&gt;&gt; <span class="number">0</span>, k = len - <span class="number">1</span>, value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      value = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; !(k <span class="keyword">in</span> t)) &#123;</span><br><span class="line">        k--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'reduceRight of empty array with no initial value'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      value = t[k--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> t) &#123;</span><br><span class="line">        value = callback(value, t[k], k, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是几种遍历方法的时间对比，可以看出传统<code>for...</code>耗时最少，；<code>for...in</code>最差。</p>
<p><img src="\images\循环遍历.png" alt="循环遍历"></p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="for…in方法"><a href="#for…in方法" class="headerlink" title="for…in方法"></a>for…in方法</h2><p>上面已经提到了<code>for...in</code>方法用于遍历数据的索引键。所以这个方法也可以用于遍历对象，具体方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span> : <span class="number">1</span>, <span class="attr">b</span> : <span class="number">2</span>, <span class="attr">c</span> : <span class="number">3</span>, <span class="attr">d</span> : <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;i&#125;</span>---<span class="subst">$&#123;obj[i]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*a---1</span></span><br><span class="line"><span class="comment">*b---2</span></span><br><span class="line"><span class="comment">*c---3</span></span><br><span class="line"><span class="comment">*d---4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2><p><strong>Object.entries()</strong>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener"><code>for...in</code></a> 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><p><code>obj</code></p>
<p>可以返回其可枚举属性的键值对的对象。</p>
</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><code>Object.entries()</code>返回一个数组，其元素是与直接在<code>object</code>上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ ['foo', 'bar'], ['baz', 42] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="keyword">const</span> anObj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(anObj)); <span class="comment">// [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo is property which isn't enumerable</span></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123; <span class="attr">getFoo</span>: &#123; value() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.foo; &#125; &#125; &#125;);</span><br><span class="line">myObj.foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(myObj)); <span class="comment">// [ ['foo', 'bar'] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// non-object argument will be coerced to an object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(<span class="string">'foo'</span>)); <span class="comment">// [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate through key-value gracefully</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">7</span>, <span class="attr">c</span>: <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// "a 5", "b 7", "c 9"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or, using array extras</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj).forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// "a 5", "b 7", "c 9"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p><strong>Object.keys()</strong>方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。</p>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p>obj</p>
<p>要返回其枚举自身属性的对象。</p>
</li>
</ul>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>一个表示给定对象的所有可枚举属性（索引键）的字符串数组。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>Object.keys</code> 返回一个所有元素为字符串的数组，其元素来自于从给定的<code>object</code>上面可直接枚举的属性（索引键）。这些属性的顺序与手动遍历该对象属性时的一致。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// simple array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr)); <span class="comment">// console: ['0', '1', '2']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// console: ['0', '1', '2']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="keyword">var</span> anObj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(anObj)); <span class="comment">// console: ['2', '7', '100']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo is a property which isn't enumerable</span></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  getFoo: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.foo; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">myObj.foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(myObj)); <span class="comment">// console: ['foo']</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h2><p><strong>Object.values()</strong>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener"><code>for...in</code></a>循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p><code>obj</code></p>
<p>被返回可枚举属性值的对象。</p>
</li>
</ul>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>一个包含对象自身的所有可枚举属性值的数组。</p>
<h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><code>Object.values()</code>返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// ['bar', 42]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="comment">// when we use numeric keys, the value returned in a numerical order according to the keys</span></span><br><span class="line"><span class="keyword">var</span> an_obj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(an_obj)); <span class="comment">// ['b', 'c', 'a']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo is property which isn't enumerable</span></span><br><span class="line"><span class="keyword">var</span> my_obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123; <span class="attr">getFoo</span>: &#123; <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.foo; &#125; &#125; &#125;);</span><br><span class="line">my_obj.foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(my_obj)); <span class="comment">// ['bar']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// non-object argument will be coerced to an object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(<span class="string">'foo'</span>)); <span class="comment">// ['f', 'o', 'o']</span></span><br></pre></td></tr></table></figure>
<p>本文大部分参考了<a href="https://developer.mozilla.org/" target="_blank" rel="noopener">MDN</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>遍历</tag>
        <tag>数组</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript宏任务，微任务与Event-loop</title>
    <url>/2021/02/09/JavaScript%E5%AE%8F%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8EEvent-loop/</url>
    <content><![CDATA[<h1 id="浏览器进程（chrome）"><a href="#浏览器进程（chrome）" class="headerlink" title="浏览器进程（chrome）"></a>浏览器进程（chrome）</h1><p>chrome中有5个主要进程：</p>
<ol>
<li>浏览器进程（<code>Browser Process</code>）：顶层进程，负责浏览器各进程工作，Tab外的工作由它负责。<ol>
<li><code>UI Thread</code>：负责浏览器按钮、地址栏。</li>
<li><code>storage Thread</code>：负责文件访问。</li>
</ol>
</li>
<li>渲染器进程（<code>Renderer Process</code>）：浏览器内核，负责Tab内的所有工作。<ol>
<li><code>Main Thread</code> ：构建dom树 -&gt; 加载资源 -&gt; js下载与执行 -&gt; 样式计算 -&gt; 构建布局树 -&gt; 绘制 -&gt; 创建层树。（注：Main不是一个线程，而是多个线程的集合，为了方便介绍先聚合一下，后面展开讲）。</li>
<li><code>Worker Thread</code>: Web Worker 运行在这个线程，可能存在多个。</li>
<li><code>Compositor Thread</code>: 合成器，将层合成帧，分成多个磁贴。</li>
<li><code>Raster Thread</code>: 栅格化磁贴后交给GPU。</li>
</ol>
</li>
<li>网络进程（<code>Network Process</code>）：负责真正的发送http请求，接收和发送网络请求。</li>
<li>插件控制进程（<code>Plugin Process</code>）：控制所有的插件。</li>
<li>GPU进程（<code>GPU Process</code>）：其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3DCSS的效果，只是随后网页、Chrome的UI界面都选择采取GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome也引入了GPU进程。</li>
</ol>
<h2 id="Main线程"><a href="#Main线程" class="headerlink" title="Main线程"></a><code>Main</code>线程</h2><p><code>Main</code>线程是一些线程的集合，主要用于整个网页的工作。</p>
<p>其包括：</p>
<ol>
<li><p>GUI渲染线            程：</p>
<p>负责渲染工作，包括解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</p>
<p><strong>注意</strong>：GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存等到JS引擎空闲时立即被执行。</p>
</li>
<li><p>JS引擎线程：</p>
<p>JS引擎线程负责解析Javascript脚本，运行代码（比如Chrome的V8)。</p>
<p>一个Tab页内中无论什么时候都只有一个JS线程在运行JS。</p>
<p>因为GUI渲染线程与JS引擎线程是互斥的，所以当JS执行的时间过长，页面的渲染也会阻塞。</p>
</li>
<li><p>事件触发线程：</p>
<p>主要用来控制事件循环，添加回调事件到队列中。</p>
<p>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会被添加到事件线程中。 当对应的事件符合触发条件并被触发时，该线程会把事件添加到队列的队尾，等待JS引擎的处理</p>
<p>注：由于JS单线程的关系，所以这些队列中的事件都得等JS引擎空闲了才会被执行</p>
</li>
<li><p>定时触发器线程：</p>
<p><code>setInterval</code>与<code>setTimeout</code>执行的线程。</p>
<p>由于js引擎是单线程的，如果由js来计时会影响计时准确性，因此额外使用一个线程来计时并触发定时。</p>
<p><strong>但是需要注意的是：</strong></p>
<p><code>setInterval</code>与<code>setTimeout</code>的计时并不是很准确的，其误差在（10~20ms）：</p>
<ol>
<li>再chrome底层中规定<code>setInterval</code>的最低时间为4ms。</li>
<li><code>windows</code>等系统底层的时间并不是完全准确的，普通的时间API误差在10~15ms（部分情况）。</li>
<li>由于JavaScript引擎是单线程，即使回调完全准确的将任务加入执行队列，但是前面的任务的执行时间仍然会增加回调任务的误差。</li>
</ol>
</li>
<li><p>异步http请求线程：</p>
<p>XMLHttpRequest连接后会新开一个线程。 将检测到状态变更时，如果设置有回调函数，该线程就产生状态变更事件。</p>
<p>当然，实际做请求工作的还是 <code>Network Process</code>。</p>
</li>
</ol>
<h1 id="JavaScript单线程"><a href="#JavaScript单线程" class="headerlink" title="JavaScript单线程"></a>JavaScript单线程</h1><p>JavaScript的一大特点就是单线程设计，这一特点也造成了JavaScript的众多特性。这样设计可以使程序的开发更加简单，因为其不会涉及线程的通信，管理，比如在操作DOM的时候，如果是多线程，就需要组织各个线程的先后关系，但是单线程就不会涉及这些问题。这也使得JavaScript成为了一门入门比较简单的语言。</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>而JavaScript的任务又分为同步任务和异步任务。</p>
<p>同步任务是指直接按照代码顺序将其加入到执行栈中任务。</p>
<p>而异步任务是指需要一定的时间才能完成，并且这段时间的操作不是JavaScript线程能够控制的，这个时候则需要其他线程予以辅助。比如上面的定时触发器线程，异步http请求线程等。都可以帮助JavaScript完成定时器和http请求的异步任务。而上面的事件触发线程则用来在异步任务完成时，将回调函数添加到执行栈中。其基本过程如图：</p>
<p><img src="\images\event-loop\同步-异步.jpg" alt="同步-异步"></p>
<h2 id="执行栈（Execution-Stack）"><a href="#执行栈（Execution-Stack）" class="headerlink" title="执行栈（Execution Stack）"></a><strong>执行栈</strong>（Execution Stack）</h2><p>当我们调用一个方法的时候，js会生成一个与这个方法相对应的执行环境，也叫<strong>执行上下文</strong>，这个执行环境存在着这个方法的私有作用域、参数、this对象等等。因为js是单线程的，同一时间只能执行一个方法，所以当一系列的方法被依次调用的时候，js会先解析这些方法，把其中的任务按照执行顺序排队到一个地方，这个地方叫做执行栈。</p>
<h2 id="事件表格（Event-Table）"><a href="#事件表格（Event-Table）" class="headerlink" title="事件表格（Event Table）"></a>事件表格（Event Table）</h2><p>JavaScript保有的一中数据结构，它会存储所有的延迟事件（回调函数）。在对应异步操作完成过后，会由事件触发线程将对应的回调函数添加到事件队列中等待执行。</p>
<h2 id="事件队列（Event-queue）"><a href="#事件队列（Event-queue）" class="headerlink" title="事件队列（Event queue）"></a><strong>事件队列</strong>（Event queue）</h2><p>当我们发出一个ajax请求或其他异步操作的时候，他并不会立刻返回结果，为了防止浏览器出现假死或者空白，主线程会把这个异步任务挂起(pending)，继续执行执行栈中的其他任务，等异步任务返回结果后，js会将这个<strong>异步任务</strong>按照执行顺序，加入到与执行栈不同的另一个队列，也就是事件队列。</p>
<h1 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event-loop"></a>Event-loop</h1><blockquote>
<p>Event-loop Definitions：</p>
<p>To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each <a href="https://tc39.es/ecma262/#sec-agents" target="_blank" rel="noopener">agent</a> has an associated event loop, which is unique to that agent.</p>
<p>翻译：为了协调事件、用户交互、脚本、渲染、网络等等，用户代理必须使用本节中描述的事件循环。每个代理都有一个相关的事件循环，该事件循环对该代理来说是唯一的。</p>
<p>每个Event-loop包含：</p>
<ul>
<li>正在运行任务，它可以是一个任务或者null。并且在最初的时候，其是一个null。其实为了处理可重入性。</li>
<li>一个微任务队列，这是一个微任务队列，起初是空的。</li>
<li>有一个标志微任务检查点的布尔值。</li>
</ul>
<h2 id="HTML-Living-Standard"><a href="#HTML-Living-Standard" class="headerlink" title="HTML Living Standard"></a>HTML Living Standard</h2></blockquote>
<blockquote>
<p>Agent Definitions：</p>
<p>An agent comprises a set of ECMAScript execution contexts, an <a href="https://tc39.es/ecma262/#execution-context-stack" target="_blank" rel="noopener">execution context stack</a>, a <a href="https://tc39.es/ecma262/#running-execution-context" target="_blank" rel="noopener">running execution context</a>, an Agent Record, and an executing thread. Except for the <a href="https://tc39.es/ecma262/#executing-thread" target="_blank" rel="noopener">executing thread</a>, the constituents of an <a href="https://tc39.es/ecma262/#agent" target="_blank" rel="noopener">agent</a> belong exclusively to that <a href="https://tc39.es/ecma262/#agent" target="_blank" rel="noopener">agent</a>.</p>
<p>翻译：代理包括一组ECMAScript执行上下文、一个执行上下文堆栈、一个正在运行的执行上下文、一个代理记录和一个正在执行的线程。除执行线程外，代理的组成部分专属于该代理。</p>
<h2 id="HTML-Living-Standard-1"><a href="#HTML-Living-Standard-1" class="headerlink" title="HTML Living Standard"></a>HTML Living Standard</h2></blockquote>
<p>所谓事件循环，就是浏览器中（此处只谈浏览器，不涉及<code>Node</code>）各项任务（同步任务，异步任务）的执行次序之间的协调。其基本过程如下图：</p>
<p><img src="\images\event-loop\event-loop.png" alt="event-loop"></p>
<p>其基本过程：</p>
<ol>
<li><p>主线程运行的时候会生成堆（heap）和栈（stack）；</p>
</li>
<li><p>js从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中；</p>
</li>
<li><p>当程序调用外部的API时，比如ajax、setTimeout等，会将此类异步任务挂起，继续执行执行栈中的任务，等异步任务返回结果后，再按照执行顺序排列到事件队列中；</p>
</li>
<li><p>主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到事件队列中。</p>
</li>
<li><p>主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个过程是循环往复的… …。</p>
<p><strong>这个过程被称为“Event Loop 事件循环”。</strong></p>
</li>
</ol>
<h1 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h1><p><strong>首先需要明确的是：宏任务和微任务都是异步任务，其不同在于回调执行的时机。</strong></p>
<p>在标准中，任务是分为<code>task</code>和<code>microtask</code>，任务和微任务。全文中提到宏任务（Macro task）的只有两处：</p>
<blockquote>
<p><em>Unlike other algorithms in this and other specifications, which behave similar to programming-language function calls,</em> <a href="https://html.spec.whatwg.org/multipage/webappapis.html#spin-the-event-loop" target="_blank" rel="noopener">spin the event loop</a> <em>is more like a macro, which saves typing and indentation at the usage site by expanding into a series of steps and operations.</em></p>
<p>翻译：与本规范和其他规范中的其他算法(其行为类似于编程语言函数调用)不同，spin事件循环更像是一个<strong>宏</strong>，它通过展开成一系列步骤和操作来节省使用站点上的输入和缩进。</p>
</blockquote>
<p>可能是由于这一处，我们多用<code>macro task</code>来描述<code>task</code>。</p>
<p>而在HTML Standard中，对于task的解释为：</p>
<p>形式上，一个task是一个包含如下内容的结构体：</p>
<ul>
<li>steps：完成该任务需要的一系列步骤。</li>
<li>A source：任务源之一，用于对相关任务进行分组和序列化。</li>
<li>A document：与任务相关联的文档，对于不在<a href="https://html.spec.whatwg.org/multipage/webappapis.html#window-event-loop" target="_blank" rel="noopener">窗口事件</a>循环中的任务，则为空。</li>
<li>A script evaluation environment settings object set：一组环境设置对象，用于在任务期间跟踪脚本评估。</li>
</ul>
<p>对于<code>microtask</code>定义有：</p>
<blockquote>
<p>A microtask is a colloquial way of referring to a <a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-task" target="_blank" rel="noopener">task</a> that was created via the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-microtask" target="_blank" rel="noopener">queue a microtask</a> algorithm.</p>
<p>翻译：微任务是指通过微任务算法队列创建的任务。</p>
</blockquote>
<p>从执行顺序上来看两者的不同：</p>
<p><img src="\images\event-loop\任务执行.png" alt="任务执行"></p>
<p>可以明确的是微任务是在一个宏任务结束后进行，此时即为上文提到的<strong>checkpoint</strong>，查看是否存在可执行的微任务。</p>
<p>具体宏任务和微任务为：</p>
<ol>
<li>宏任务<ul>
<li>整体script</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>其他</li>
</ul>
</li>
<li>微任务<ul>
<li>Promise的then方法（注意Promise内部的内容是同步内容，立即执行）</li>
<li>process.nextTick，</li>
<li>MutationObserver</li>
</ul>
</li>
</ol>
<h2 id="几个简单例子"><a href="#几个简单例子" class="headerlink" title="几个简单例子"></a>几个简单例子</h2><h3 id="定时器、Promise"><a href="#定时器、Promise" class="headerlink" title="定时器、Promise"></a>定时器、Promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'定时器开始'</span>)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'马上执行for循环'</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">         i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'执行then函数'</span>)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'代码执行结束'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 马上开始for循环</span></span><br><span class="line"><span class="comment">* 代码执行结束</span></span><br><span class="line"><span class="comment">* 执行then函数</span></span><br><span class="line"><span class="comment">* 定时器开始</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>执行到<code>setTimeout</code>，先由<code>Event Table</code>保留其回调函数。并且在其延迟任务完成后由事件触发线程将其加入到<code>Event Queue</code>。</li>
<li>执行到<code>new Promise</code>，由于其函数参数是同步的，所以立即执行。<strong>打印：马上执行for循环</strong>。并将then方法的回调加入到微任务队列。</li>
<li>执行到<code>console.log(&#39;代码执行结束&#39;);</code>，同步代码。<strong>直接打印：代码执行结束</strong></li>
<li>第一个事件循环结束，到<code>checkpoint</code>，检查是否有微任务，发现<code>then</code>方法回调，<strong>直接打印：执行then函数</strong>。</li>
<li>第二轮事件循环开始，执行第一个宏任务，<code>setTimeout</code>的回调进入执行栈，即执行 <code>console.log(&#39;定时器开始&#39;)</code>，<strong>直接打印：定时器开始</strong></li>
</ol>
<h3 id="定时器、Promise、async"><a href="#定时器、Promise、async" class="headerlink" title="定时器、Promise、async"></a>定时器、Promise、async</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序：</span></span><br><span class="line"><span class="comment">// script start </span></span><br><span class="line"><span class="comment">// async1 start </span></span><br><span class="line"><span class="comment">// async2 </span></span><br><span class="line"><span class="comment">// promise1 </span></span><br><span class="line"><span class="comment">// script end </span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>
<p>对于<code>async函数</code>，本质是基于<code>Promise</code>，所以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(async2()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就容易理解前面的答案了，根据<code>Promise</code>参数函数为同步，<code>then</code>方法为微任务，可以很容易推的结果。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>说实话，这一部分仍然没有很好的理解，主要是官方的文档解释的比较抽象并且没有定性的解释，加之我的英语不行，不能很好的理解整个流程，只能简单的确定执行次序。这一部分还需要在后面深入的理解。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.cn/post/6844903861174403086" target="_blank" rel="noopener">JS引擎的执行机制（event loop），宏任务和微任务</a></li>
<li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#microtask" target="_blank" rel="noopener">HTML Standard</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScrit</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>宏任务</tag>
        <tag>微任务</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的模块导入导出</title>
    <url>/2021/02/14/JavaScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<h1 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h1><blockquote>
<p>（Modular design）　所谓的<strong>模块化设计</strong>，简单地说就是将产品的某些要素组合在一起，构成一个具有特定功能的子系统，将这个子系统作为通用性的模块与其他产品要素进行多种组合，构成新的系统，产生多种不同功能或相同功能、不同性能的系列产品。</p>
</blockquote>
<p>这是在整个设计行业对模块化的定义。对于编程语言中的模块化设计，其基本思路就是将有相同功能的部分代码封装在一起，形成一个通用的，可复用的<strong>模块</strong>，使之在其它系统中可以重复利用，并不会对模块内部产生影响。所以设计模式中模块化设计的三大特征也要遵循：</p>
<ol>
<li><p>相对独立性</p>
</li>
<li><p>互换性</p>
</li>
<li><p>通用性</p>
</li>
</ol>
<p>换做在编程语言中，相对独立性即要使私有成员无法被外部访问并暴露给外部指定的方法。通用性在程序设计中多被称为<strong>可复用性</strong>，而模块设计的原则和目的也是可复用性。模块可以减少我们对重复代码的编写，提高开发的效率。</p>
<h2 id="JavaScript对模块的需求"><a href="#JavaScript对模块的需求" class="headerlink" title="JavaScript对模块的需求"></a>JavaScript对模块的需求</h2><p>最初JavaScript是作为网页开发的脚本而开发，Brendan Eich 可能也不会想到当初十几天开发出的一个脚本语言如今会焕发如此的生命力，也正是因为开发周期如此之短，使之缺点在当今工程化的JavaScript中被极大的放大。其中一个就是模块的概念，JavaScript原生并没有模块的概念，就如同没有原生的类一样（尽管ES6推出了所谓的类）。为此，开发者想出了很多方法从语言层面来模拟模块化。</p>
<h1 id="初期的模块化"><a href="#初期的模块化" class="headerlink" title="初期的模块化"></a>初期的模块化</h1><p>在各类框架，插件没有流行，JavaScript仅作为一门脚本语言的时候，开发人员想出了一些方法来对项目中一些方法集合进行封装，形成类似于模块的模式。</p>
<h2 id="原生写法"><a href="#原生写法" class="headerlink" title="原生写法"></a>原生写法</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>模块就是实现特定功能的一组方法。</p>
<p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>“污染”了全局变量，无法保证不与其他模块发生变量名冲突</li>
<li>模块成员之间看不出直接关系。</li>
</ol>
<h2 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>为了解决上面的“全局变量污染的问题”，又利用了对象这一数据类型，使一个模块成为一个对象，模块的成员作为对象的成员变量。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line"></span><br><span class="line">    _count : <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    m1 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    m2 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>私有变量被直接暴露给外部，如上面的<code>_count</code>应该是一个保留的私有变量，但是在外部我们也是可以访问到的。</li>
</ol>
<h2 id="立即执行函数（IIFE）写法"><a href="#立即执行函数（IIFE）写法" class="headerlink" title="立即执行函数（IIFE）写法"></a>立即执行函数（IIFE）写法</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>又为了解决无法保有私有成员的问题（其本质是JavaScript没有局部作用域的问题，具体看<a href="https://michaelwang.top/2021/01/31/%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/" target="_blank" rel="noopener">这里</a>），这里利用了立即执行函数形成一个闭包的同时也形成了一个局部作用域，这个作用域内的变量在外部是无法访问到的。这样就解决了上面的私有便变量的问题。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        m1 : m1,</span><br><span class="line">        m2 : m2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这里<code>module1</code>形成了一个闭包，返回一个对象，我们只能访问到对象暴露的<code>m1</code>和<code>m2</code>方法，内部的<code>_count</code>是无法被访问到了。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>提高性能：通过 IIFE 的参数传递常用全局对象 window、document，在作用域内引用这些全局对象。JavaScript 解释器首先在作用域内查找属性，然后一直沿着链向上查找，直到全局范围，因此将全局对象放在 IIFE 作用域内可以提升js解释器的查找速度和性能；</li>
<li>压缩空间：通过参数传递全局对象，压缩时可以将这些全局对象匿名为一个更加精简的变量名；</li>
</ol>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><p>不能很好的管理依赖，缺少一个依赖管理者。比如依赖的调用顺序，在没有管理者时，我们必须自己确定调用顺序，比如：</p>
<p>我们要调用<code>module1</code>的<code>mock</code>方法，</p>
<p>而<code>module1</code>又依赖<code>module2</code></p>
<p><code>module2</code>又依赖<code>module3</code></p>
<p><code>module4</code>又依赖<code>module3</code></p>
<p>我们则必须按这个顺序加载脚本文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./module4'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./module3'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./module2'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./module1'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">	module1.mock()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="立即执行函数（IIFE）的衍生写法"><a href="#立即执行函数（IIFE）的衍生写法" class="headerlink" title="立即执行函数（IIFE）的衍生写法"></a>立即执行函数（IIFE）的衍生写法</h3><h4 id="放大模式"><a href="#放大模式" class="headerlink" title="放大模式"></a>放大模式</h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。</p>
<h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line"></span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure>
<p>上面的代码为<code>module</code>添加了一个<code>m3</code>属性。并将新的模块实体返回。</p>
<h4 id="宽放大模式"><a href="#宽放大模式" class="headerlink" title="宽放大模式"></a>宽放大模式</h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>对于上面的放大模式，存在一定的问题。由于在浏览器中，所有的资源都是异步加载的，所以上面的参数可能不存在，所以我们必须要考虑这种情况，增强代码的健壮性。</p>
<h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = ( <span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码相当于是给函数参数设置了一个默认参数为<code>{}</code>，当<code>window.module1</code>不存在的时候，在对<code>{}</code>空对象进行操作。</p>
<h1 id="现代模块设计"><a href="#现代模块设计" class="headerlink" title="现代模块设计"></a>现代模块设计</h1><p>恩格斯说：“社会一旦有技术上的需要，则这种需要会比十所大学更能把科学院推向前进。”随着进入大前端时代，网站的规模越来越大，逻辑层面越来越复杂。模块化的管理成为必然，很多模块管理框架应运而生。具有代表性的有：</p>
<ul>
<li>Node.js中CommonJS </li>
<li>基于 AMD 的 RequireJS</li>
<li>基于 CMD 的 SeaJS</li>
<li>ECMAScript规定的ES Module</li>
</ul>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>CommonJS 是Node.js中采用的一种规范，其基本原则有：</p>
<ol>
<li><strong>由于<code>Node</code>是在服务端运行，所以<code>CommonJS</code>的模块加载是同步进行的，所以其在浏览器中并不适用，因为浏览器中的文件都是通过网络加载的，并不适合同步加载。</strong></li>
<li>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</li>
<li>每个模块内部有一个全局变量<code>module</code>，这个变量是一个对象，它的<code>exports</code>属性（即<code>module.export</code>）用于导出模块。</li>
<li>每个模块内部有一个全局变量<code>require</code>，其是一个函数，用于导入模块，参数即模块的地址。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ol>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><h5 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line"><span class="keyword">let</span> _temp = <span class="number">-1</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">let</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    _temp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = _temp</span><br><span class="line">    <span class="keyword">return</span> [a,b]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.export.pi = pi</span><br><span class="line"><span class="built_in">module</span>.export.exchange = exchange</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这么写</span></span><br><span class="line"><span class="built_in">module</span>.export.sum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> module1 = <span class="built_in">require</span>(<span class="string">'./module1.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(module1.exchange(<span class="number">1</span>, <span class="number">2</span>))		<span class="comment">//[2, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(module1.pi)					<span class="comment">//3.1415926</span></span><br></pre></td></tr></table></figure>
<h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><p><code>Node</code>内部提供一个<code>Module</code>构建函数。所有的模块都是<code>Module</code>的实例。</p>
<p>查看<code>Node</code>源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其是一个构造器函数，其中设置了以下属性：</p>
<ul>
<li><code>module.id</code>：模块的识别符，通常是带有绝对路径的模块文件名。</li>
<li><code>module.filename</code> 模块的文件名，带有绝对路径。</li>
<li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li>
<li><code>module.parent</code> 返回一个对象，表示调用该模块的父级块。</li>
<li><code>module.children</code> 返回一个数组，表示该模块要用到的其他子级模块。</li>
<li><code>module.exports</code> 表示模块对外输出的值。</li>
</ul>
<p>实际上我们模块导入的过程就是为对应模块的<code>module.exports</code>对象增加成员的过程。</p>
<h4 id="目录加载规则"><a href="#目录加载规则" class="headerlink" title="目录加载规则"></a>目录加载规则</h4><p>通常一个项目都有一个入口文件（或函数），比如C语言，Java中的<code>main</code>函数。在<code>Node</code>项目中，一般也会指定一个入口文件，让<code>require</code>方法可以通过这个入口文件，加载整个项目。</p>
<p>一般这个入口放在<code>packge.json</code>文件，并将入口文件写入<code>main</code>字段。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//packge.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"new_project"</span>,</span><br><span class="line">    <span class="string">"main"</span>: <span class="string">"./main/index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>require</code>发现参数字符串指向一个目录以后，会自动查看该目录的<code>packge.json</code>文件，然后加载<code>main</code>字段指定的入口文件。如果<code>packge.json</code>文件没有<code>main</code>字段，或者没有<code>packge.json</code>文件，则会加载该目录下的<code>index.js</code>文件或者<code>index.node</code>文件。</p>
<h4 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h4><p>Node会在第一次加载模块后，缓冲该模块（实际上是缓存该模块的<code>module.exports</code>属性）。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./moudle1.js'</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./moudle1.js'</span>).num = <span class="number">1</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./moudle1.js'</span>).num					<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>上面三次导入一个模块，但是我们添加的成员变量在第三次缓冲时仍然可以访问到，证明其是被缓冲在内存中的。</p>
<p>我们可以通过删除<code>require.cache</code>的对应属性来删除模块缓冲。</p>
<h5 id="删除模块缓冲"><a href="#删除模块缓冲" class="headerlink" title="删除模块缓冲"></a>删除模块缓冲</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除指定模块</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">require</span>.cache[moduleName]</span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(<span class="built_in">require</span>.cache, moduleName)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有模块的缓存</span></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">require</span>.cache).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">require</span>.cache[key];</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h4><p><code>CommonJS</code> 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。</p>
<p>下面是一个模块文件<code>lib.js</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码输出内部变量 <code>counter</code> 和改写这个变量的内部方法 <code>incCounter</code>。</p>
<p>然后，加载上面的模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>counter</code> 输出以后，<code>lib.js</code> 模块内部的变化就影响不到 <code>counter</code> 了。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h3><p>AMD 全称为 <strong>Asynchromous Module Definition（异步模块定义）</strong>。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，它是一个在浏览器端模块化开发的规范。 AMD 模式可以用于浏览器环境并且允许<strong>异步</strong>加载模块，同时又能保证正确的顺序，也可以按需动态加载模块。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><code>AMD</code>是依赖前置，即提前声明需要的依赖。</li>
<li>对依赖的加载是提前进行的，在运行前就加载所有的依赖。</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>模块通过 <code>define</code> 函数定义在闭包中，格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(id?: <span class="built_in">String</span>, dependencies?: <span class="built_in">String</span>[], <span class="attr">factory</span>: <span class="built_in">Function</span>|<span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure>
<p><code>id</code> 是模块的名字，它是可选的参数。</p>
<p><code>dependencies</code> 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 <code>factory</code> 中。如果没有指定 <code>dependencies</code>，那么它的默认值是 <code>[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;&#125;）</span><br></pre></td></tr></table></figure>
<p><code>factory</code> 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。</p>
<h3 id="例子-require-js"><a href="#例子-require-js" class="headerlink" title="例子(require.js)"></a>例子(<code>require.js</code>)</h3><h4 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>)<span class="title">P</span></span>&#123;</span><br><span class="line">	 <span class="keyword">var</span> num = <span class="number">555</span></span><br><span class="line">     <span class="keyword">var</span> _version = <span class="number">0.01</span></span><br><span class="line">       </span><br><span class="line">     <span class="keyword">var</span> showMessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    		<span class="keyword">if</span>(!message)&#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                $(<span class="string">'#messageBox'</span>).html(<span class="string">'欢迎访问'</span> + name)</span><br><span class="line">            &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	</span><br><span class="line">	 <span class="keyword">return</span>&#123;</span><br><span class="line">         <span class="string">'num'</span>:num,</span><br><span class="line">         <span class="string">'showMessage'</span>: showMessage</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//_version为内部维护变量，无法被外部访问到</span></span><br></pre></td></tr></table></figure>
<h4 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置文件</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'js'</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        jquery: <span class="string">'lib/jquery-1.11.1'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'script/hello'</span>],<span class="function"><span class="keyword">function</span> (<span class="params">$, hello</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      hello.showMessage(<span class="string">"test"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><h3 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h3><p>CMD（Common Module Definition） 是 SeaJS 在推广过程中对模块定义的规范化产出。CMD 规范的前身是 Modules/Wrappings 规范。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>CMD推崇依赖就近，即在依赖使用时才引入。</li>
<li>CMD是延迟执行的，即使用的时候才延迟执行的。</li>
</ul>
<h3 id="用法（SeaJS）"><a href="#用法（SeaJS）" class="headerlink" title="用法（SeaJS）"></a>用法（SeaJS）</h3><p>1、<strong><code>seajs.config</code></strong>({…});  //用来对 Sea.js 进行配置。<br>2、<strong><code>seajs.use</code></strong>([‘a’,’b’],function(a,b){…});  //用来在页面中加载一个或多个模块。<br>3、<strong><code>define</code></strong>(function(require, exports, module){…});  //用来定义模块。Sea.js 推崇一个模块一个文件，遵循统一的写法：<br>4、<strong><code>require</code></strong>(function(require){var a = require(“xModule”); … });  //require 用来获取指定模块的接口。<br>5、<strong><code>require.async</code></strong>,  //用来在模块内部异步加载一个或多个模块。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">require</span>.async([<span class="string">'aModule'</span>,<span class="string">'bModule'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;  <span class="comment">// 异步加载多个模块，在加载完成时，执行回调</span></span><br><span class="line">    a.func();</span><br><span class="line">    b.func();</span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>6、<strong><code>exports</code></strong>, //用来在模块内部对外提供接口。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>)</span>&#123;</span><br><span class="line">    exports.varName01 = <span class="string">'varValue'</span>;  <span class="comment">// 对外提供 varName01 属性    </span></span><br><span class="line">    exports.funName01 = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2</span>)</span>&#123;  <span class="comment">// 对外提供 funName01 方法</span></span><br><span class="line">    ....</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>7、<strong><code>module.exports</code></strong>, 与 exports 类似，用来在模块内部对外提供接口。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;  <span class="comment">// 对外提供接口</span></span><br><span class="line">    name: <span class="string">'a'</span>,</span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h3><h4 id="定义模块-1"><a href="#定义模块-1" class="headerlink" title="定义模块"></a>定义模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// seajs 的简单配置</span></span><br><span class="line">seajs.config(&#123;</span><br><span class="line">  base: <span class="string">"../sea-modules/"</span>,</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"jquery/jquery/1.10.1/jquery.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有模块都通过 define 来定义</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 require 引入依赖</span></span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">  <span class="keyword">var</span> Spinning = <span class="built_in">require</span>(<span class="string">'./spinning'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 exports 对外提供接口</span></span><br><span class="line">  exports.doSomething = ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者通过 module.exports 提供整个接口</span></span><br><span class="line">  <span class="built_in">module</span>.exports = ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//或者使用return向外提供接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      someVal: someVal,</span><br><span class="line">      doSomething: doSomething</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果<code>retunr</code>语句是模块的唯一代码，还可以简化为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">  someVal: someVal,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="引入模块-1"><a href="#引入模块-1" class="headerlink" title="引入模块"></a>引入模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//单一模式</span></span><br><span class="line">seajs.use(<span class="string">'./a'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//回调模式</span></span><br><span class="line">seajs.use(<span class="string">'./a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a.run()</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//多模块模式</span></span><br><span class="line">seajs.use([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a.run()</span><br><span class="line">  b.run()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个模块中引入其他模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//同步引入其他模块</span></span><br><span class="line">    <span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">'./module1'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异步引入其他模块</span></span><br><span class="line">    <span class="keyword">var</span> module2 = <span class="built_in">require</span>.async(<span class="string">'./module2'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>对 <code>module.exports</code> 的赋值需要同步执行，不能放在回调函数里。</li>
<li>在<code>html</code>中 ，为<code>script</code>标签添加<code>data-main = true</code>确定其为主入口。data-main通常用在只有一个入口的情况，use可以用在多个入口的情况</li>
</ul>
<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><h3 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h3><p>UMD（Universal Module Definition），AMD模块以浏览器第一的原则发展，异步加载模块。CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>兼容 AMD 和 CommonJS 规范的同时，还兼容全局引用的方式</li>
</ul>
<h3 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">//AMD</span></span><br><span class="line">        define([<span class="string">'jquery'</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">//Node, CommonJS之类的</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">'jquery'</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//浏览器全局变量(root 即 window)</span></span><br><span class="line">        root.returnExports = factory(root.jQuery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//暴露公共方法</span></span><br><span class="line">    <span class="keyword">return</span> myFunc;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h2><h3 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h3><p>在 ES Module 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES Module 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES Module 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</p>
<p>CommonJS 和 AMD 模块，其本质是在运行时生成一个<strong>对象</strong>进行导出，称为“运行时加载”，没法进行“编译优化”，而 ES Module 不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。这称为“编译时加载”或者静态加载，即 ES Module 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES Module 模块本身，因为它不是对象。</p>
<p>由于 ES Module 是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>
<p>除了静态加载带来的各种好处，ESz  Module 还有以下好处：</p>
<ul>
<li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES Module 格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。</li>
<li>不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。</li>
</ul>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>静态编译</li>
<li>输出的值引用，而非值拷贝</li>
<li><code>import</code> 只能写在顶层，因为是静态语法</li>
<li>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。（具体严格模式内容不再赘述）</li>
</ul>
<h3 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h3><h4 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">'default'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bactch1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> bactch2 = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> bactch3 = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导出已定义的变量</span></span><br><span class="line"><span class="keyword">export</span> pi</span><br><span class="line"><span class="keyword">export</span> sum</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接导出声明的变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> e = <span class="number">2.718281828459</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;bactch1, bactch2, bactch3&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出默认</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> d</span><br><span class="line"><span class="comment">//对导出变量重命名,并且重命名为default，与上面的说法一致</span></span><br><span class="line"><span class="keyword">export</span> &#123;d <span class="keyword">as</span> <span class="keyword">default</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p><code>export default</code> 命令用于指定模块的默认输出。<code>export default</code> 就是输出一个叫做 <code>default</code> 的变量或方法，然后系统允许你为它取任意名字</p>
</li>
<li><p><code>export default</code>只能导出变量，不能在后面声明变量。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> pi = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p>
</li>
</ul>
<h4 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接导入模块所有成员</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'module1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//批量导入模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;pi, e, sum&#125; <span class="keyword">from</span> <span class="string">'module1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接执行所加载的模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一条import语句中，同时输入默认方法和其他接口</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; each, forEach &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p><code>export</code>后无法直接接变量内容。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h4><p><code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中。如，下面的代码会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> MyModual <span class="keyword">from</span> <span class="string">'./myModual'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有时候我们需要按需引入又该怎么办，<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p>
<p><code>import(specifier)</code></p>
<h5 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h5><ol>
<li><code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。</li>
<li><p><code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p>
</li>
<li><p><code>import()</code>返回一个 Promise 对象。模块作为<code>Promise</code>的参数返回下面是一个例子。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">'main'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.loadPageInto(main);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="\images\JavaScript中的模块导入导出\ESModule兼容性.png" alt="ES Module兼容性"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前JavaScript的模块规范就是上面谈到的四种，CommonJS、AMD、CMD、ES Module。 CommonJS 用在服务器端，AMD 和CMD 用在浏览器环境，ES Module 是作为终极通用解决方案，时下热议的<a href="https://github.com/vitejs/vite" target="_blank" rel="noopener">vite</a>即利用了ES Module。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="AMD-和-CMD-的区别"><a href="#AMD-和-CMD-的区别" class="headerlink" title="AMD 和 CMD 的区别"></a>AMD 和 CMD 的区别</h3><ul>
<li>执行时机： AMD 是提前执行，CMD 是延迟执行。</li>
<li>对依赖的处理：AMD 推崇依赖前置，CMD 推崇依赖就近。</li>
<li>API 设计理念：AMD 的 API 默认是一个当多个用，非常灵活，CMD 的 API 严格区分，推崇职责单一。</li>
<li>遵循的规范：RequireJS 遵循的是 Modules/AMD 规范，SeaJS 遵循的是 Mdoules/Wrappings 规范的 define 形式。</li>
<li>设计理念：SeaJS 设计理念是 focus on web, 努力成为浏览器端的模块加载器，RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。</li>
</ul>
<h3 id="CommonJS-和-ES-Module-的区别"><a href="#CommonJS-和-ES-Module-的区别" class="headerlink" title="CommonJS 和 ES Module 的区别"></a>CommonJS 和 ES Module 的区别</h3><ul>
<li>加载时机：CommonJS 是运行时加载（动态加载），ES Module 是编译时加载（静态加载）</li>
<li>加载模块：CommonJS 模块就是对象，加载的是该对象，ES Module 模块不是对象，加载的不是对象，是接口</li>
<li>加载结果：CommonJS 加载的是整个模块，即将所有的接口全部加载进来，ES Module 可以单独加载其中的某个接口（方法）</li>
<li>输出：CommonJS 输出值的拷贝，ES Module 输出值的引用</li>
<li>this: CommonJS 指向当前模块，ES Module 指向 undefined</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.cn/post/6844903826600755214" target="_blank" rel="noopener">JavaScript 模块化总结</a></li>
<li><a href="https://es6.ruanyifeng.com/?search=import&amp;x=0&amp;y=0#docs/module" target="_blank" rel="noopener">Module 的语法-阮一峰</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">import-MDN</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">Javascript模块化编程（一）：模块的写法-阮一峰</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
        <tag>CommonJS</tag>
        <tag>ES Module</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数组（二，ES6部分）</title>
    <url>/2018/11/02/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%8CES6%E9%83%A8%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次介绍了ES5之前发布的JS的数组方法，这次再看一下ES5中发布的JS方法。</p>
<a id="more"></a>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ol>
<li>indexOf()和lastIndexOf()</li>
</ol>
<p>描述：</p>
<p>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 </p>
<p>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</p>
<p>应用：</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。</p>
<p>exp:</p>
<pre><code>var arr = [1,3,5,7,7,5,3,1];
console.log(arr.indexOf(5)); //2（5在该数组的第2位）
console.log(arr.lastIndexOf(5)); //5(从后向前，5在数组的第5位)
console.log(arr.indexOf(5,2)); //2（从第二位开始检索，任然2在第5位）
console.log(arr.lastIndexOf(5,4)); //2（从倒数第四位开始检索，5在倒数第四位）
console.log(arr.indexOf(&quot;5&quot;)); //-1（数组中没有字符&quot;5&quot;，所以返回-1）
</code></pre><ol start="2">
<li>forEach()</li>
</ol>
<p>描述：</p>
<p>对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</p>
<p>应用：</p>
<p>用于遍历数组，获得数组成员的内容，索引<br>，及其数组本身<br>    var arr = [1, 2, 3, 4, 5];<br>    arr.forEach(function(x, index, a){<br>    console.log(x + ‘|’ + index + ‘|’ + (a === arr));<br>    });<br>    // 输出为：<br>    // 1|0|true<br>    // 2|1|true<br>    // 3|2|true<br>    // 4|3|true<br>    // 5|4|true</p>
<ol start="3">
<li>map()</li>
</ol>
<p>描述：</p>
<p>遍历一个数组，并且经过处理后返回一个新的数组。</p>
<p>原型：</p>
<p>arr.map(function(currentValue，index，arr),thisValue) </p>
<p>currentValue 必须 当前元素值 </p>
<p>index 可选 当前元素的索引值 </p>
<p>arr 可选 当前元素属于的数组对象。 </p>
<p>exp:通过map方法返回数组元素的平方</p>
<pre><code>var arr = [1, 2, 3, 4, 5];
var arr2 = arr.map(function(item){
return item*item;
});
console.log(arr2); //[1, 4, 9, 16, 25]
</code></pre><p><strong>注意，map()方法不会改变原数组，而是返回一个新的数组，注意function中药返回值，否则为空数组</strong></p>
<p>exp2:</p>
<pre><code>var arr = [1,2,3,7,9];
var arr2 = arr.map(function(x,index,a){
   x=x+1;
 });
 console.log(arr2);//[undifined,undifined,undifined,undifined,undifine]
 console.log(arr);//[1,2,3,7,9]
</code></pre><p>即使在map()的函数中改变currentValue的值，原数组的职业不会改变。而如果没有返回值，则该数组为undefined。</p>
<ol start="4">
<li>filter()</li>
</ol>
<p>描述：</p>
<p>“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<p>原型：array.filter(function(currentValue,index,arr), thisValue)</p>
<p>currentValue    必须。当前元素的值</p>
<p>index    可选。当前元素的索引值</p>
<p>arr    可选。当前元素属于的数组对象</p>
<p>exp：</p>
<pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var arr2 = arr.filter(function(x, index) {
return index % 3 === 0 || x &gt;= 8;
}); 
console.log(arr2); //[1, 4, 7, 8, 9, 10]
</code></pre><p>该方法的注意事项和上一个方法差不多，也是不会改变原数组，并且必须要有返回值，否则数组为undefined。</p>
<ol start="5">
<li>every()</li>
</ol>
<p>描述： 判断数组中每一项都是否满足条件，<strong>只有所有项都满足条件，才会返回true</strong>。</p>
<p>原型：array.filter(function(currentValue,index,arr), thisValue)</p>
<p>currentValue    必须。当前元素的值</p>
<p>index    可选。当前元素的索引值</p>
<p>arr    可选。当前元素属于的数组对象</p>
<p>应用：</p>
<p>检测数组所有元素是否都符合指定条件（通过函数提供）。</p>
<p>exp：</p>
<pre><code>var arr = [1, 2, 3, 4, 5];
var arr2 = arr.every(function(x) {
return x &lt; 10;
}); 
console.log(arr2); //true
var arr3 = arr.every(function(x) {
return x &lt; 3;
}); 
console.log(arr3); // false
</code></pre><ol start="6">
<li>some()</li>
</ol>
<p>描述：</p>
<p>判断数组中是否存在满足条件的项，<strong>只要有一项满足条件，就会返回true</strong>。</p>
<p>应用：</p>
<p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p>
<p>exp：</p>
<pre><code>var arr = [1, 2, 3, 4, 5];
var arr2 = arr.some(function(x) {
return x &lt; 3;
}); 
console.log(arr2); //true
var arr3 = arr.some(function(x) {
return x &lt; 1;
}); 
console.log(arr3); // false
</code></pre><p>注意：</p>
<p><strong>some() 方法会依次执行数组的每个元素：</strong></p>
<p><strong>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</strong></p>
<p><strong>如果没有满足条件的元素，则返回false。</strong></p>
<ol start="7">
<li>reduce()和 reduceRight()</li>
</ol>
<p>描述：</p>
<p>这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</p>
<p>原型（以reduce为例）：</p>
<p>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</p>
<p>total    必需。初始值, 或者计算结束后的返回值。</p>
<p>currentValue    必需。当前元素</p>
<p>currentIndex    可选。当前元素的索引</p>
<p>arr    可选。当前元素所属的数组对象。</p>
<p>exp：</p>
<pre><code>var values = [1,2,3,4,5];
var sum = values.reduceRight(function(total, currentValue, currentIndex, arr){
return total + currenValue;
},10);
console.log(sum); //25
</code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这是ES6中提供的数组方法，对于ES6，我还没有认真研究，不过这些方法还是挺实用的，对于低版本的浏览器可能会不支持。感觉开发中还是要针对需求使用。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3-边框</title>
    <url>/2019/10/19/CSS3-%E8%BE%B9%E6%A1%86/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之所以想到重学CSS3，是因为最近在看《CSS揭秘》一书时，在发现原来CSS3的内容有很多当时没有深入去琢磨，只是简单学习了其基础用法。下面就通过其一些高级用法来深入的研究一下CSS3的内容。</p>
<p>该内容分为：</p>
<ol>
<li>边框</li>
<li>背景</li>
<li>文本效果</li>
<li>字体</li>
<li>2D、3D转换</li>
<li>过渡</li>
<li>动画</li>
<li>多列、用户界面（盒尺寸、轮廓）</li>
<li>媒体查询</li>
</ol>
<h1 id="CSS边框"><a href="#CSS边框" class="headerlink" title="CSS边框"></a>CSS边框</h1><h2 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h2><h3 id="border-radius参数解析"><a href="#border-radius参数解析" class="headerlink" title="border-radius参数解析"></a>border-radius参数解析</h3><p>该属性与padding、margin相同，可以有1、2、3、4个值，所以复习一次：</p>
<p>Example1: border-radius:10px;</p>
<p><strong>四个角的弧度相同，均为10px。</strong></p>
<p><img src="\images\CSS3-边框\border-radius-one.png" alt="border-radius-one"></p>
<hr>
<p>Example2: border-radisu:10px 50px;</p>
<p>左上、右下弧度为10px，左下、右上弧度为50px。</p>
<p><img src="\images\CSS3-边框\border-radius-two.png" alt="border-radius-two"></p>
<hr>
<p>Example3: border-radius:10px 50px 100px;</p>
<p>左上弧度10px，右上、左下弧度50px，右下弧度100px。</p>
<p><img src="\images\CSS3-边框\border-radius-three.png" alt="border-radius-three"></p>
<hr>
<p>Example4: border-radius:10px 50px 100px 200px;</p>
<p>左上、右上、右下、左下弧度分别为：10px 50px 100px 200px;</p>
<p><img src="\images\CSS3-边框\border-radius-three.png" alt="border-radius-three"></p>
<hr>
<p>实际上border-radius是一个简写属性，它是下面<strong>四个属性</strong>的简写：</p>
<ol>
<li>border-top-left-radius</li>
<li>border-top-right-radius</li>
<li>border-bottom-left-radius</li>
<li>border-bottom-right-radius</li>
</ol>
<p>所以也可以直接单独设置每个角的值。</p>
<h3 id="border-radius参数单位"><a href="#border-radius参数单位" class="headerlink" title="border-radius参数单位"></a>border-radius参数单位</h3><p>border-radius参数可以为：</p>
<ol>
<li>绝对值，比如px,em,rem等。</li>
<li>相对值，百分比值（参数为height、width）</li>
</ol>
<h3 id="border-radius参数意义"><a href="#border-radius参数意义" class="headerlink" title="border-radius参数意义"></a>border-radius参数意义</h3><p><img src="\images\CSS3-边框\border-radius-paraMean.png" alt="border-radius-paraMean"></p>
<p>这个值实际上就是这个圆角的半径值。</p>
<p>如果是百分比值，则通过这个容器的height\width算出对应的值。</p>
<h3 id="border-radius配置一个圆角两侧的不同弧度"><a href="#border-radius配置一个圆角两侧的不同弧度" class="headerlink" title="border-radius配置一个圆角两侧的不同弧度"></a>border-radius配置一个圆角两侧的不同弧度</h3><p>如上图所说，如果按照普通配置，圆角就是在容器的一角形成一个圆，将其1/4作为其圆角。</p>
<p>实际上我们可以分别配置一个圆角的两侧的弧度。即，将一个椭圆的1/4圆作为容器的圆角。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">borde-radius:x1 x2 x3 x4/y1 y2 y3 y4;</span><br></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-top-left-radius</span>: <span class="selector-tag">x1</span> <span class="selector-tag">y1</span>;</span><br><span class="line"><span class="selector-tag">border-top-right-radius</span>: <span class="selector-tag">x2</span> <span class="selector-tag">y2</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-right-radius</span>: <span class="selector-tag">x3</span> <span class="selector-tag">y3</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-left-radius</span>: <span class="selector-tag">x4</span> <span class="selector-tag">y4</span>;</span><br></pre></td></tr></table></figure>
<p>当然，/前后的属性可以简写：</p>
<p>一个值：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">borde-radius:x1/y1;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-top-left-radius</span>: <span class="selector-tag">x1</span> <span class="selector-tag">y1</span>;</span><br><span class="line"><span class="selector-tag">border-top-right-radius</span>: <span class="selector-tag">x1</span> <span class="selector-tag">y1</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-right-radius</span>: <span class="selector-tag">x1</span> <span class="selector-tag">y1</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-left-radius</span>: <span class="selector-tag">x1</span> <span class="selector-tag">y1</span>;</span><br></pre></td></tr></table></figure>
<p>两个值：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">borde-radius:x1 x2/y1 y2;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-top-left-radius</span>: <span class="selector-tag">x1</span> <span class="selector-tag">y1</span>;</span><br><span class="line"><span class="selector-tag">border-top-right-radius</span>: <span class="selector-tag">x2</span> <span class="selector-tag">y2</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-right-radius</span>: <span class="selector-tag">x2</span> <span class="selector-tag">y1</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-left-radius</span>: <span class="selector-tag">x2</span> <span class="selector-tag">y2</span>;</span><br></pre></td></tr></table></figure>
<p><strong>/前后的值是配置的是每个角的x半径、y的半径。可以为1，2，3，4个值，原理和上面一样。</strong></p>
<p><img src="\images\CSS3-边框\border-radius-ellipse.png" alt="border-radius-ellipse"></p>
<h2 id="border-radius高级应用"><a href="#border-radius高级应用" class="headerlink" title="border-radius高级应用"></a>border-radius高级应用</h2><h3 id="基础用法-圆角"><a href="#基础用法-圆角" class="headerlink" title="基础用法-圆角"></a>基础用法-圆角</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span>&#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">900px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid red; </span><br><span class="line">	<span class="attribute">bakcground-color</span>: brown;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-radius-ex1.png" alt="border-radius-ex1"></p>
<h3 id="圆形、椭圆"><a href="#圆形、椭圆" class="headerlink" title="圆形、椭圆"></a>圆形、椭圆</h3><p><strong>圆形</strong>（容器的height、width必须相同，height、width的值即为圆的直径）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">3px</span> solid red; </span><br><span class="line">      <span class="attribute">background</span>: brown;</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-radius-ex2-1.png" alt="border-radius-ex2-1"></p>
<p><strong>椭圆</strong>（height、width即为该椭圆的x轴、y轴的<strong>直径</strong>）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">700px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">3px</span> solid red; </span><br><span class="line">      <span class="attribute">background</span>: brown;</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-radius-ex2-2.png" alt="border-radius-ex2-2"></p>
<p><strong>标签图形</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid red; </span><br><span class="line">  <span class="attribute">background</span>: brown; </span><br><span class="line">  <span class="attribute">border-bottom-right-radius</span>: <span class="number">50%</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-bottom-left-radius</span>: <span class="number">50%</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-radius-ex3.png" alt="border-radius-ex3"></p>
<p><strong>烧杯</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid red; </span><br><span class="line">  <span class="attribute">background</span>: brown;</span><br><span class="line">  <span class="attribute">border-bottom-right-radius</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-bottom-left-radius</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-radius-ex4.png" alt="border-radius-ex4"></p>
<p><strong>树叶</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid red; </span><br><span class="line">  <span class="attribute">background</span>: brown;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">100%</span> / <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-radius-ex5.png" alt="border-radius-ex5"></p>
<p><strong>border-radius总结</strong></p>
<p>实际上只要是包含圆角的图形我们都可以通过border-radius来构造，通过多个元素的+定位+圆角来构成图形。</p>
<h2 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h2><h3 id="box-shadow参数解析"><a href="#box-shadow参数解析" class="headerlink" title="box-shadow参数解析"></a>box-shadow参数解析</h3><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>h-shadow</td>
<td>必需。水平阴影的位置。允许负值。</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必需。垂直阴影的位置。允许负值。</td>
</tr>
<tr>
<td>blur</td>
<td>可选。模糊距离。</td>
</tr>
<tr>
<td>spread</td>
<td>可选。阴影的尺寸。</td>
</tr>
<tr>
<td>color</td>
<td>可选。阴影的颜色。请参阅 CSS 颜色值。</td>
</tr>
<tr>
<td>inset</td>
<td>可选。将外部阴影 (outset) 改为内部阴影。</td>
</tr>
</tbody>
</table>
<p>基础用法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span><span class="selector-pseudo">:10px</span> 10<span class="selector-tag">px</span> 10<span class="selector-tag">x</span> 10<span class="selector-tag">px</span> <span class="selector-tag">blue</span>;</span><br></pre></td></tr></table></figure>
<p>值得注意的是：</p>
<p>box-shadow的值允许有多组值。</p>
<p>example1:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-tag">blue</span>,20<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> <span class="selector-tag">black</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\box-shadow-multiValue.png" alt="box-shadow-multiValue"></p>
<h3 id="高级应用-作为边框"><a href="#高级应用-作为边框" class="headerlink" title="高级应用-作为边框"></a>高级应用-作为边框</h3><p>如果我们将blur值设为0，即不模糊，再将其h-shadow、v-shadow设置为0，即不偏移，即可将其设置边框。</p>
<p>example2:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 10<span class="selector-tag">px</span> <span class="selector-tag">blue</span>；</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\box-shadow-border.png" alt="box-shadow-border"></p>
<p>再利用可以添加多个边框的性质，即可实现多边框。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    <span class="selector-tag">box-shadow</span>: 0 0 0 10<span class="selector-tag">px</span> <span class="selector-tag">blue</span>,</span><br><span class="line">0 0 0 20<span class="selector-tag">px</span> <span class="selector-tag">black</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\box-shadow-multiBorder.png" alt="box-shadow-multiBorder">   </p>
<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p>outline在元素外部绘制一条线。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">outline</span><span class="selector-pseudo">:outline-color</span>,<span class="selector-tag">outline-style</span>,<span class="selector-tag">outline-width</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>outline-color</td>
<td>规定边框的颜色。</td>
</tr>
<tr>
<td>outline-style</td>
<td>规定边框的样式。</td>
</tr>
<tr>
<td>outline-width</td>
<td>规定边框的宽度。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 outline 属性的设置。</td>
</tr>
</tbody>
</table>
<p>example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">outline</span>: <span class="selector-tag">greenyellow</span> 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\outline1.png" alt="outline1"></p>
<p>outline也是一个简写属性，即为：outline-color、outline-style、outline-width的简写。outline-style的风格繁多。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>默认。定义无轮廓。</td>
</tr>
<tr>
<td>dotted</td>
<td>定义点状的轮廓。</td>
</tr>
<tr>
<td>dashed</td>
<td>定义虚线轮廓。</td>
</tr>
<tr>
<td>solid</td>
<td>定义实线轮廓。</td>
</tr>
<tr>
<td>double</td>
<td>定义双线轮廓。双线的宽度等同于 outline-width 的值。</td>
</tr>
<tr>
<td>groove</td>
<td>定义 3D 凹槽轮廓。此效果取决于 outline-color 值。</td>
</tr>
<tr>
<td>ridge</td>
<td>定义 3D 凸槽轮廓。此效果取决于 outline-color 值。</td>
</tr>
<tr>
<td>inset</td>
<td>定义 3D 凹边轮廓。此效果取决于 outline-color 值。</td>
</tr>
<tr>
<td>outset</td>
<td>定义 3D 凸边轮廓。此效果取决于 outline-color 值。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承轮廓样式的设置。</td>
</tr>
</tbody>
</table>
<p><strong>注意，还有一个与outline相关的属性-&gt;outline-offset，该属性可以为负值</strong></p>
<p>利用outline的虚线轮廓与outline-offset可以实现缝线风格的边框。</p>
<h3 id="缝线风格"><a href="#缝线风格" class="headerlink" title="缝线风格"></a>缝线风格</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">outline</span><span class="selector-pseudo">:greenyellow</span> 2<span class="selector-tag">px</span> <span class="selector-tag">dashed</span>;</span><br><span class="line"><span class="selector-tag">outline-offset</span>: <span class="selector-tag">-10px</span>;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\outline-suture.png" alt="outline-suture"></p>
<h2 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a>border-image</h2><p><strong>注意：</strong></p>
<ol>
<li><strong>在大多数浏览器下，要应用border-image，必须要先设置边框border属性</strong></li>
<li><strong>当border-image存在且其第一个参数border-image-source不为none时，border-style属性将不会生效，若border-image-source为none，则border-style生效</strong></li>
</ol>
<h3 id="border-image参数"><a href="#border-image参数" class="headerlink" title="border-image参数"></a>border-image参数</h3><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>border-image-source</td>
<td>用在边框的图片的路径。</td>
</tr>
<tr>
<td>border-image-slice</td>
<td>图片边框向内偏移。</td>
</tr>
<tr>
<td>border-image-width</td>
<td>图片边框的宽度。</td>
</tr>
<tr>
<td>border-image-outset</td>
<td>边框图像区域超出边框的量。</td>
</tr>
<tr>
<td>border-image-repeat</td>
<td>图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。</td>
</tr>
</tbody>
</table>
<p>example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">243</span>, <span class="number">103</span>, <span class="number">103</span>);</span><br><span class="line">  <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">'/bg.png'</span>) <span class="number">30%</span> <span class="number">20%</span>/<span class="number">2</span>/<span class="number">1</span> repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-image1.png" alt="border-image1"></p>
<p>注意参数的格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-image:border-image-source border-image-slice/border-image-width/border-image-outset border-image-repeat</span><br></pre></td></tr></table></figure>
<p>接下来解析一下这几个参数</p>
<h4 id="border-image-source"><a href="#border-image-source" class="headerlink" title="border-image-source"></a>border-image-source</h4><p>解释：第一个参数，图片地址，这个不用解释。</p>
<h4 id="border-image-slice"><a href="#border-image-slice" class="headerlink" title="border-image-slice"></a>border-image-slice</h4><p>解释：第二个参数，图片边框向内偏移，即从何处裁剪背景图片。</p>
<p>   example:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-image: url('/bg.png') 33% 20% 50% 10% repeat; //省略其他参数</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-image-para1.png" alt="border-image-para1"></p>
<p><strong>该参数的个数与padding,margin相同，四参数则为上右下左的顺序，三参数则为上下、左、右，两参数则为上下、左右、一参数则全相同</strong></p>
<h4 id="border-image-width"><a href="#border-image-width" class="headerlink" title="border-image-width"></a>border-image-width</h4><p>解释：第三个参数，规定border-image的宽度，被borer-width也会被相应的缩放以适应border-iamge宽度。<strong>单位为倍数，2则为被border-image-slice切割后图片的2倍，0.3则为原来的0.3倍。</strong></p>
<p>  example:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-image: url('/bg.png') 33%/1/0 round;//默认该参数为1</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-image-para3-meta.png" alt="border-image-para3-meta"></p>
<p>  改变参数为2、0.3</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-image: url('/bg.png') 33%/2/0 round;</span><br><span class="line"></span><br><span class="line">border-image: url('/bg.png') 33%/0.2/0 round;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-image-para3-2.png" alt="border-image-para3-2"></p>
<p><img src="\images\CSS3-边框\border-image-para3-0.2.png" alt="border-image-para3-0.2"></p>
<p><strong>注意，这个参数并不会实际改变border-width中定义的宽度，如果该属性增加，则会向容器内部扩展</strong></p>
<h4 id="border-image-outset"><a href="#border-image-outset" class="headerlink" title="border-image-outset"></a>border-image-outset</h4><p>解释：该属性会将border-image向外偏移一定量。单位任然是倍数，默认为0，即占据border的位置，向外扩展0倍，1代表增加1倍，即直接与容器的border连接。向外扩展1倍。2倍则偏移两倍，则会在容器外部与边框相距边框的距离。</p>
<p>  默认值为0：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-image: url('/bg.png') 33%/1/0 round;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-image-para4-meta.png" alt="border-image-para4-meta"></p>
<p>  变为1：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-image: url('/bg.png') 33%/1/1 round;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-image-para4-1.png" alt="border-image-para4-1"></p>
<p>  变为2：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-image: url('/bg.png') 33%/1/2 round;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-image-para4-2.png" alt="border-image-para4-2"></p>
<p>  变为0.5：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-image: url('/bg.png') 33%/1/0.5 round;</span><br></pre></td></tr></table></figure>
<p><img src="\images\CSS3-边框\border-image-para4-0.5.png" alt="border-image-para4-0.5"></p>
<p>注意这里border-image向外偏移了0.5，即占据了border的一半width。</p>
<h4 id="border-image-repeat"><a href="#border-image-repeat" class="headerlink" title="border-image-repeat"></a>border-image-repeat</h4><p>解释：该属性用于如何分布border-image-slice切割后的部分该如何组合分布在边框上。它含有以下属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>stretch</td>
<td>默认值。拉伸图像来填充区域</td>
</tr>
<tr>
<td>repeat</td>
<td>平铺（repeated）图像来填充区域。</td>
</tr>
<tr>
<td>round</td>
<td>类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域。</td>
</tr>
<tr>
<td>space</td>
<td>类似 repeat 值。如果无法完整平铺所有图像，扩展空间会分布在图像周围</td>
</tr>
<tr>
<td>initial</td>
<td>将此属性设置为默认值。</td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素中继承该属性。</td>
</tr>
</tbody>
</table>
<p>特别解释一下：</p>
<ol>
<li>tretch只会将剪切过后的图片放置一张在边框位置，然后拉伸以适应边框的长度。 </li>
<li>repeat会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽<strong>大于</strong>border-width，居中后将多余的部分隐藏在两侧。</li>
<li>round会将多个切割后的图片组合放在边框位置，并且组合后的图片长/宽<strong>小于</strong>border-width，然后会缩放切割图片以适应长（宽）度。</li>
<li>space会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽<strong>小于</strong>border-width，多余的部分会空出来，如果有背景色，则用背景色填充。</li>
</ol>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>border-radius</tag>
        <tag>box-shadow</tag>
        <tag>border-image</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编译相关的JCTree和TreeMaker的API介绍</title>
    <url>/2022/04/28/JCTree%E5%92%8CTreeMaker%E7%9A%84API%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="关于编译原理"><a href="#关于编译原理" class="headerlink" title="关于编译原理"></a>关于编译原理</h1><p>在文章<a href="https://www.mw530.cn/2022/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM3-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">深入理解JVM3-1-程序编译与代码优化-前端编译与优化</a>中，其中介绍了javac的编译原理。其中简要流程如下：</p>
<ol>
<li>准备过程：初始化插入式注解处理器。</li>
<li>解析与填充符号表过程<ol>
<li>词法、语法分析：将源代码的字符流转变为标记集合，构造出<strong>抽象语法树</strong>。</li>
<li>填充符号表：产生符号地址和符号信息。</li>
</ol>
</li>
<li>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段。</li>
<li>分析与字节码生成过程<ol>
<li>标注检查：对语法的静态信息进行检查。</li>
<li>数据流及控制流分析：对程序动态运行过程进行检查。</li>
<li>解语法糖：将简化代码编写的语法糖还原为原有的形式。</li>
<li>字节码生成：将前面各个步骤所生成的信息转化成字节码。</li>
</ol>
</li>
</ol>
<p>而下面的两个API就是关于抽象语法树，javac给出了注释处理器（processAnnotations）可以让我们读取生成的语法树节点，也干预抽象语法树的生成，我们可以在其中进行更改。</p>
<p><strong>但是首先值得注意的是：下面的两个系类API都是Java私有。并不对外公开，也就是说要使用这些API，必须自行引入。并且要承担其随时改变的风险。</strong></p>
<h1 id="JCTree"><a href="#JCTree" class="headerlink" title="JCTree"></a>JCTree</h1><p>JCTree是语法树元素的基类。其解析出的所有抽象语法树节点都继承自该节点。但是我们在自定义节点时，值得注意的说，我们并不能直接newJCTree节点。因为树节点总是在一个语境中，有其对应的结构。其中的pos属性就用于代表该节点在该父节点中的位置。所以JCTree的逻辑是，必须用另一组<code>TreeMaker</code>API并依赖父级节点才能进行新建。</p>
<p>下面介绍JCTree的子类，其包含了所有Java的构成元素。</p>
<h3 id="常用节点"><a href="#常用节点" class="headerlink" title="常用节点"></a>常用节点</h3><h4 id="AnnotatedTypeTree"><a href="#AnnotatedTypeTree" class="headerlink" title="AnnotatedTypeTree"></a>AnnotatedTypeTree</h4><p>指被注释修饰的<strong>类型</strong>。</p>
<p>如下面的s和d：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@annotationType</span> String s</span><br><span class="line"><span class="meta">@annotationType</span> ( arguments ) Date d</span><br></pre></td></tr></table></figure>
<p>其可以用在变量申明中，也可以用在方法参数中。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@annotationType</span> <span class="keyword">private</span> String s;</span><br><span class="line">	<span class="meta">@annotationType</span> ( arguments ) <span class="keyword">private</span> Date d;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setS</span><span class="params">(@annotationType String s)</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AnnotationTree"><a href="#AnnotationTree" class="headerlink" title="AnnotationTree"></a>AnnotationTree</h4><p>注释树节点。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@annotationType</span></span><br><span class="line"><span class="meta">@annotationType</span>(arguments)</span><br></pre></td></tr></table></figure>
<h4 id="ArrayAccessTree"><a href="#ArrayAccessTree" class="headerlink" title="ArrayAccessTree"></a>ArrayAccessTree</h4><p>数组访问表达式的树节点。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="ArrayTypeTree"><a href="#ArrayTypeTree" class="headerlink" title="ArrayTypeTree"></a>ArrayTypeTree</h4><p>数组类型的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[]</span><br></pre></td></tr></table></figure>
<h4 id="AssignmentTree"><a href="#AssignmentTree" class="headerlink" title="AssignmentTree"></a>AssignmentTree</h4><p>赋值表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">variable = expression</span><br><span class="line"><span class="keyword">var</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<h4 id="BinaryTree"><a href="#BinaryTree" class="headerlink" title="BinaryTree"></a>BinaryTree</h4><p>二元表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">leftOperand operator rightOperand</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="number">3</span> * <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>#### </p>
<h4 id="BlockTree"><a href="#BlockTree" class="headerlink" title="BlockTree"></a>BlockTree</h4><p>语句块的树节点（一般指被花括号包围的语句块）。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123; statements &#125;</span><br></pre></td></tr></table></figure>
<h4 id="BreakTree"><a href="#BreakTree" class="headerlink" title="BreakTree"></a>BreakTree</h4><p>break语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span> label ;</span><br></pre></td></tr></table></figure>
<h4 id="CaseTree"><a href="#CaseTree" class="headerlink" title="CaseTree"></a>CaseTree</h4><p>switch语句或表达式中一个case的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> expression :</span><br><span class="line">	statements</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">	statements</span><br></pre></td></tr></table></figure>
<h4 id="CatchTree"><a href="#CatchTree" class="headerlink" title="CatchTree"></a>CatchTree</h4><p>try语句中catch块的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> ( parameter )</span><br><span class="line">    block</span><br></pre></td></tr></table></figure>
<h4 id="ClassTree"><a href="#ClassTree" class="headerlink" title="ClassTree"></a>ClassTree</h4><p>类、接口、枚举、记录或注释类型声明的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">modifiers <span class="class"><span class="keyword">class</span> <span class="title">simpleName</span> <span class="title">typeParameters</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">extendsClause</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">implementsClause</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    members</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CompoundAssignmentTree"><a href="#CompoundAssignmentTree" class="headerlink" title="CompoundAssignmentTree"></a>CompoundAssignmentTree</h4><p>用于<strong>复合赋值</strong>操作符的树节点。使用getKind确定操作符的类型。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">variable operator expression</span><br></pre></td></tr></table></figure>
<p>注意与简单赋值操作符区别在于操作符不仅仅是<code>=</code>。</p>
<h4 id="ConditionalExpressionTree"><a href="#ConditionalExpressionTree" class="headerlink" title="ConditionalExpressionTree"></a>ConditionalExpressionTree</h4><p>三目运算符<code>?:</code>的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">condition ? trueExpression : falseExpression</span><br></pre></td></tr></table></figure>
<h4 id="ContinueTree"><a href="#ContinueTree" class="headerlink" title="ContinueTree"></a>ContinueTree</h4><p>continue语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">continue</span> label ;</span><br></pre></td></tr></table></figure>
<h4 id="DoWhileLoopTree"><a href="#DoWhileLoopTree" class="headerlink" title="DoWhileLoopTree"></a>DoWhileLoopTree</h4><p><code>do...while</code>语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span> ( expression );</span><br></pre></td></tr></table></figure>
<h4 id="EnhancedForLoopTree"><a href="#EnhancedForLoopTree" class="headerlink" title="EnhancedForLoopTree"></a>EnhancedForLoopTree</h4><p>增强for循环语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( variable : expression )</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<h4 id="ExpressionStatementTree"><a href="#ExpressionStatementTree" class="headerlink" title="ExpressionStatementTree"></a>ExpressionStatementTree</h4><p>表达式语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">expression ;</span><br></pre></td></tr></table></figure>
<h4 id="ForLoopTree"><a href="#ForLoopTree" class="headerlink" title="ForLoopTree"></a>ForLoopTree</h4><p>基本的for循环语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( initializer ; condition ; update )</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<h4 id="IdentifierTree"><a href="#IdentifierTree" class="headerlink" title="IdentifierTree"></a>IdentifierTree</h4><p>标识符表达式的树节点。比较基本的树节点。比如用来在二元表达式中作为操作符左右的变量表示。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure>
<h4 id="IfTree"><a href="#IfTree" class="headerlink" title="IfTree"></a>IfTree</h4><p>if语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( condition )</span><br><span class="line">   thenStatement</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( condition )</span><br><span class="line">    thenStatement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    elseStatement</span><br></pre></td></tr></table></figure>
<h4 id="ImportTree"><a href="#ImportTree" class="headerlink" title="ImportTree"></a>ImportTree</h4><p>用于导入声明的树节点。（包括静态import）</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> qualifiedIdentifier ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">import</span> qualifiedIdentifier ;</span><br></pre></td></tr></table></figure>
<h4 id="InstanceOfTree"><a href="#InstanceOfTree" class="headerlink" title="InstanceOfTree"></a>InstanceOfTree</h4><p>instanceof表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">expression <span class="keyword">instanceof</span> type</span><br></pre></td></tr></table></figure>
<h4 id="LambdaExpressionTree"><a href="#LambdaExpressionTree" class="headerlink" title="LambdaExpressionTree"></a>LambdaExpressionTree</h4><p>lambda表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">()-&gt;&#123;&#125;</span><br><span class="line">(List&lt;String&gt; ls)-&gt;ls.size()</span><br><span class="line">(x,y)-&gt; &#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="LambdaExpressionTree-BodyKind"><a href="#LambdaExpressionTree-BodyKind" class="headerlink" title="LambdaExpressionTree.BodyKind"></a>LambdaExpressionTree.BodyKind</h4><p>lambda表达式的的body类型。</p>
<p>Lambda表达式有两种形式:</p>
<ul>
<li>expression  lambda：主体是一个表达式。</li>
<li>statement lambdas：主题是一个块。</li>
</ul>
<h4 id="LiteralTree"><a href="#LiteralTree" class="headerlink" title="LiteralTree"></a>LiteralTree</h4><p>字面表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">value</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>; <span class="comment">//中的123</span></span><br></pre></td></tr></table></figure>
<h4 id="MemberReferenceTree"><a href="#MemberReferenceTree" class="headerlink" title="MemberReferenceTree"></a>MemberReferenceTree</h4><p>成员引用表达式的树节点。</p>
<p>一般用在函数式接口的位置，可与lambda表达式混用。</p>
<p>例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">expression # [ identifier | new ]</span><br><span class="line">String#hashCode</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>#</code>与<code>::</code>一致，都可以表示方法引用。</p>
<p>如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">String::hashCode</span><br><span class="line">String#hashCode</span><br></pre></td></tr></table></figure>
<p>都表示String类的hashcode方法引用。其可以像lambda表达式一样传递。</p>
<h4 id="MemberReferenceTree-ReferenceMode"><a href="#MemberReferenceTree-ReferenceMode" class="headerlink" title="MemberReferenceTree.ReferenceMode"></a>MemberReferenceTree.ReferenceMode</h4><p>有两种成员引用:</p>
<ul>
<li>方法引用。</li>
<li>构造器引用。</li>
</ul>
<h4 id="MemberSelectTree"><a href="#MemberSelectTree" class="headerlink" title="MemberSelectTree"></a>MemberSelectTree</h4><p>成员访问表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">expression . identifier</span><br><span class="line">obj.prop</span><br></pre></td></tr></table></figure>
<h4 id="MethodInvocationTree"><a href="#MethodInvocationTree" class="headerlink" title="MethodInvocationTree"></a>MethodInvocationTree</h4><p>方法调用表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">identifier ( arguments )</span><br><span class="line"><span class="keyword">this</span> . <span class="function">typeArguments <span class="title">identifier</span> <span class="params">( arguments )</span></span></span><br></pre></td></tr></table></figure>
<h4 id="MethodTree"><a href="#MethodTree" class="headerlink" title="MethodTree"></a>MethodTree</h4><p>方法或注释类型元素声明的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">modifiers typeParameters type name</span><br><span class="line">    ( parameters )</span><br><span class="line">    body</span><br><span class="line"></span><br><span class="line"><span class="function">modifiers type <span class="title">name</span> <span class="params">()</span> <span class="keyword">default</span> defaultValue</span></span><br></pre></td></tr></table></figure>
<h4 id="ModifiersTree"><a href="#ModifiersTree" class="headerlink" title="ModifiersTree"></a>ModifiersTree</h4><p>用于修饰符(包括声明的注释)的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flags</span><br><span class="line"></span><br><span class="line">flags annotations</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> </span><br><span class="line"><span class="keyword">final</span></span><br></pre></td></tr></table></figure>
<h4 id="NewArrayTree"><a href="#NewArrayTree" class="headerlink" title="NewArrayTree"></a>NewArrayTree</h4><p>用于创建数组新实例的表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> type dimensions initializers</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> type dimensions [ ] initializers</span><br><span class="line">    </span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] a</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span> a[]</span><br></pre></td></tr></table></figure>
<h4 id="NewClassTree"><a href="#NewClassTree" class="headerlink" title="NewClassTree"></a>NewClassTree</h4><p>声明类的<strong>新实例</strong>的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> identifier ( )</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> identifier ( arguments )</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="function">typeArguments <span class="title">identifier</span> <span class="params">( arguments )</span></span></span><br><span class="line"><span class="function">classBody</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">enclosingExpression.new <span class="title">identifier</span> <span class="params">( arguments )</span></span></span><br></pre></td></tr></table></figure>
<h4 id="ParameterizedTypeTree"><a href="#ParameterizedTypeTree" class="headerlink" title="ParameterizedTypeTree"></a>ParameterizedTypeTree</h4><p>类型参数的类型表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type &lt; typeArguments &gt;</span><br></pre></td></tr></table></figure>
<h4 id="PrimitiveTypeTree"><a href="#PrimitiveTypeTree" class="headerlink" title="PrimitiveTypeTree"></a>PrimitiveTypeTree</h4><p>基本类型的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">primitiveTypeKind</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;	<span class="comment">//中的int</span></span><br></pre></td></tr></table></figure>
<h4 id="ReturnTree"><a href="#ReturnTree" class="headerlink" title="ReturnTree"></a>ReturnTree</h4><p>return语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>
<h4 id="StatementTree"><a href="#StatementTree" class="headerlink" title="StatementTree"></a>StatementTree</h4><p>用作不同类型语句的基类的树节点。</p>
<h4 id="SwitchExpressionTree"><a href="#SwitchExpressionTree" class="headerlink" title="SwitchExpressionTree"></a>SwitchExpressionTree</h4><p>switch表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( expression ) &#123;</span><br><span class="line">        cases</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SwitchTree"><a href="#SwitchTree" class="headerlink" title="SwitchTree"></a>SwitchTree</h4><p>switch语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( expression ) &#123;</span><br><span class="line">        cases</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SynchronizedTree"><a href="#SynchronizedTree" class="headerlink" title="SynchronizedTree"></a>SynchronizedTree</h4><p>synchronized语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> ( expression )</span><br><span class="line">    block</span><br></pre></td></tr></table></figure>
<h4 id="ThrowTree"><a href="#ThrowTree" class="headerlink" title="ThrowTree"></a>ThrowTree</h4><p>抛出语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> expression;</span><br></pre></td></tr></table></figure>
<h4 id="TryTree"><a href="#TryTree" class="headerlink" title="TryTree"></a>TryTree</h4><p>try语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">    block</span><br><span class="line">catches</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">    finallyBlock</span><br></pre></td></tr></table></figure>
<h4 id="TypeCastTree"><a href="#TypeCastTree" class="headerlink" title="TypeCastTree"></a>TypeCastTree</h4><p>类型转换表达式的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">( type ) expression</span><br></pre></td></tr></table></figure>
<h4 id="TypeParameterTree"><a href="#TypeParameterTree" class="headerlink" title="TypeParameterTree"></a>TypeParameterTree</h4><p>类型参数的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name</span><br><span class="line"></span><br><span class="line">name extends bounds</span><br><span class="line"></span><br><span class="line">annotations name</span><br></pre></td></tr></table></figure>
<h4 id="VariableTree"><a href="#VariableTree" class="headerlink" title="VariableTree"></a>VariableTree</h4><p>用于变量声明的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">modifiers type name initializer ;</span><br><span class="line">modifiers type qualified-name.<span class="keyword">this</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="WhileLoopTree"><a href="#WhileLoopTree" class="headerlink" title="WhileLoopTree"></a>WhileLoopTree</h4><p>一个while循环语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( condition )</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>
<h3 id="其他节点"><a href="#其他节点" class="headerlink" title="其他节点"></a>其他节点</h3><h3 id="AssertTree"><a href="#AssertTree" class="headerlink" title="AssertTree"></a>AssertTree</h3><p>断言树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition ;</span><br><span class="line"><span class="keyword">assert</span> condition : detail ;</span><br></pre></td></tr></table></figure>
<h3 id="BindingPatternTree"><a href="#BindingPatternTree" class="headerlink" title="BindingPatternTree"></a>BindingPatternTree</h3><p>预览特性，可能不稳定。</p>
<h3 id="CaseLabelTree"><a href="#CaseLabelTree" class="headerlink" title="CaseLabelTree"></a>CaseLabelTree</h3><p>预览特性，可能不稳定。</p>
<h3 id="CompoundAssignmentTree-1"><a href="#CompoundAssignmentTree-1" class="headerlink" title="CompoundAssignmentTree"></a>CompoundAssignmentTree</h3><p>表示普通编译单元和模块编译单元的抽象语法树。</p>
<h3 id="DefaultCaseLabelTree"><a href="#DefaultCaseLabelTree" class="headerlink" title="DefaultCaseLabelTree"></a>DefaultCaseLabelTree</h3><p>预览特性，可能不稳定。</p>
<p>一个case标号，在case中标记default (null, default)。</p>
<h3 id="DirectiveTree"><a href="#DirectiveTree" class="headerlink" title="DirectiveTree"></a>DirectiveTree</h3><p>模块树中所有指令的超类型。该指令一般指在<code>module-info.java</code>中的指令。</p>
<h3 id="EmptyStatementTree"><a href="#EmptyStatementTree" class="headerlink" title="EmptyStatementTree"></a>EmptyStatementTree</h3><p>一个空(跳过)语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure>
<h3 id="ErroneousTree"><a href="#ErroneousTree" class="headerlink" title="ErroneousTree"></a>ErroneousTree</h3><p>用来代替一个畸形的表达式的树节点。</p>
<h3 id="ExportsTree"><a href="#ExportsTree" class="headerlink" title="ExportsTree"></a>ExportsTree</h3><p>模块声明中’exports’指令的树节点。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exports</span> <span class="keyword">package</span>-name;</span><br><span class="line"><span class="keyword">exports</span> <span class="keyword">package</span>-name to <span class="keyword">module</span>-name;</span><br></pre></td></tr></table></figure>
<h3 id="ExpressionTree"><a href="#ExpressionTree" class="headerlink" title="ExpressionTree"></a>ExpressionTree</h3><p>预览特性，可能不稳定。</p>
<p>用作不同类型表达式的基类的树节点。</p>
<h3 id="GuardedPatternTree"><a href="#GuardedPatternTree" class="headerlink" title="GuardedPatternTree"></a>GuardedPatternTree</h3><p>预览特性，可能不稳定。</p>
<p>守护模式树。</p>
<h3 id="IntersectionTypeTree"><a href="#IntersectionTypeTree" class="headerlink" title="IntersectionTypeTree"></a>IntersectionTypeTree</h3><p>转换表达式中交集类型的树节点。</p>
<h3 id="LabeledStatementTree"><a href="#LabeledStatementTree" class="headerlink" title="LabeledStatementTree"></a>LabeledStatementTree</h3><p>带label的表达式的树节点。一般和带label的break语句一起使用。</p>
<h3 id="LineMap"><a href="#LineMap" class="headerlink" title="LineMap"></a>LineMap</h3><p>提供在编译单元的字符位置和行号之间进行转换的方法。</p>
<p>其包含以下方法：</p>
<ul>
<li>getColumnNumber：查找字符位置的列。</li>
<li>getLineNumber：查找包含位置的行;行终止字符在它终止的行上。</li>
<li>getPosition：找到对应于(行，列)的位置。</li>
<li>getStartPosition：查找一行的起始位置。</li>
</ul>
<h3 id="ModuleTree"><a href="#ModuleTree" class="headerlink" title="ModuleTree"></a>ModuleTree</h3><p>模块声明的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">annotations</span><br><span class="line">    [open] <span class="keyword">module</span> <span class="keyword">module</span>-name &#123;</span><br><span class="line">    directives</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModuleTree-ModuleKind"><a href="#ModuleTree-ModuleKind" class="headerlink" title="ModuleTree.ModuleKind"></a>ModuleTree.ModuleKind</h3><p>模块的类型。</p>
<h3 id="OpensTree"><a href="#OpensTree" class="headerlink" title="OpensTree"></a>OpensTree</h3><p>模块声明中’open ‘指令的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">opens   <span class="keyword">package</span>-name;</span><br><span class="line">opens   <span class="keyword">package</span>-name to <span class="keyword">module</span>-name;</span><br></pre></td></tr></table></figure>
<h3 id="PackageTree"><a href="#PackageTree" class="headerlink" title="PackageTree"></a>PackageTree</h3><p>表示包声明的树节点。</p>
<h3 id="ParenthesizedPatternTree"><a href="#ParenthesizedPatternTree" class="headerlink" title="ParenthesizedPatternTree"></a>ParenthesizedPatternTree</h3><p>预览特性，可能不稳定。</p>
<p>圆括号模式的树节点。</p>
<h3 id="ParenthesizedTree"><a href="#ParenthesizedTree" class="headerlink" title="ParenthesizedTree"></a>ParenthesizedTree</h3><p>用于圆括号表达式的树节点。注意:解析器不会保留圆括号。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">( expression )</span><br></pre></td></tr></table></figure>
<h3 id="PatternTree"><a href="#PatternTree" class="headerlink" title="PatternTree"></a>PatternTree</h3><p>预览特性，可能不稳定。</p>
<p>用作不同类型模式的基类的树节点。</p>
<h3 id="ProvidesTree"><a href="#ProvidesTree" class="headerlink" title="ProvidesTree"></a>ProvidesTree</h3><p>‘ providers ‘指令在模块声明中的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">provides service-name with implementation-name;</span><br></pre></td></tr></table></figure>
<h3 id="RequiresTree"><a href="#RequiresTree" class="headerlink" title="RequiresTree"></a>RequiresTree</h3><p>‘require ‘指令在模块声明中的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">requires</span> <span class="keyword">module</span>-name;</span><br><span class="line"><span class="keyword">requires</span> <span class="keyword">static</span> <span class="keyword">module</span>-name;</span><br><span class="line"><span class="keyword">requires</span> transitive <span class="keyword">module</span>-name;</span><br></pre></td></tr></table></figure>
<h3 id="Scope（作用域）"><a href="#Scope（作用域）" class="headerlink" title="Scope（作用域）"></a>Scope（作用域）</h3><p>用于决定本地可以用程序元素的接口，这些元素可能是本地变量或者import。在创建元素时，Scope与给定的程序位置相关联;例如，树节点。这个位置可以用来推断一个封闭的方法和/或类。</p>
<p>Scope本身不包含与包含其位置的方法和类的参数、方法和字段相对应的元素的详细信息。但是，这些元素可以从外围元素中确定。</p>
<p>Scope可以包含在封闭作用域中。最外层Scope包含那些通过”star import”声明可用的元素;其中的作用域包含编译单元的顶级元素，包括任何命名导入。</p>
<h3 id="UnionTypeTree"><a href="#UnionTypeTree" class="headerlink" title="UnionTypeTree"></a>UnionTypeTree</h3><p>多包变量声明中用于union类型表达式的树节点。</p>
<h3 id="UsesTree"><a href="#UsesTree" class="headerlink" title="UsesTree"></a>UsesTree</h3><p>在模块声明中用于’uses’指令的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">uses service-name;</span><br></pre></td></tr></table></figure>
<h3 id="WildcardTree"><a href="#WildcardTree" class="headerlink" title="WildcardTree"></a>WildcardTree</h3><p>通配符类型参数的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">?</span><br><span class="line"></span><br><span class="line">? extends bound</span><br><span class="line"></span><br><span class="line">? <span class="keyword">super</span> bound</span><br></pre></td></tr></table></figure>
<h3 id="YieldTree"><a href="#YieldTree" class="headerlink" title="YieldTree"></a>YieldTree</h3><p>yield语句的树节点。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yield expression ;</span><br></pre></td></tr></table></figure>
<h2 id="Blocks-Statements"><a href="#Blocks-Statements" class="headerlink" title="Blocks, Statements"></a>Blocks, Statements</h2><ul>
<li><p>Blocks是一个Statements序列、局部变量声明语句、局部类和大括号内的接口声明。</p>
</li>
<li><p>Statements也是Statements的序列。其由多种类型，比如</p>
<ul>
<li><p>空语句：空语句什么也不做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EmptyStatement:</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标签语句：语句可以有标签前缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LabeledStatement:</span><br><span class="line">	Identifier : Statement</span><br><span class="line">LabeledStatementNoShortIf:</span><br><span class="line">	Identifier : StatementNoShortIf</span><br></pre></td></tr></table></figure>
</li>
<li><p>表达式语句：某些类型的表达式可以通过后跟分号作为语句来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExpressionStatement:</span><br><span class="line">	StatementExpression ;</span><br><span class="line">StatementExpression:</span><br><span class="line">    Assignment</span><br><span class="line">    PreIncrementExpression</span><br><span class="line">    PreDecrementExpression</span><br><span class="line">    PostIncrementExpression</span><br><span class="line">    PostDecrementExpression</span><br><span class="line">    MethodInvocation</span><br><span class="line">    ClassInstanceCreationExpression</span><br></pre></td></tr></table></figure>
</li>
<li><p>if语句:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IfThenStatement:</span><br><span class="line">	<span class="keyword">if</span> ( Expression ) Statement</span><br><span class="line">IfThenElseStatement:</span><br><span class="line">	<span class="keyword">if</span> ( Expression ) StatementNoShortIf <span class="keyword">else</span> Statement</span><br><span class="line">IfThenElseStatementNoShortIf:</span><br><span class="line">	<span class="keyword">if</span> ( Expression ) StatementNoShortIf <span class="keyword">else</span> StatementNoShortIf</span><br></pre></td></tr></table></figure>
</li>
<li><p>if - then - else语句</p>
</li>
<li><p>断言语句</p>
</li>
<li><p>switch语句</p>
</li>
<li><p>while语句</p>
</li>
<li><p>do语句</p>
</li>
<li><p>for语句</p>
</li>
<li><p>增强for循环语句</p>
</li>
<li><p>break语句</p>
</li>
<li><p>continue语句</p>
</li>
<li><p>return语句</p>
</li>
<li><p>throw语句</p>
</li>
<li><p>synchronized 语句</p>
</li>
<li><p>try语句</p>
</li>
<li><p>yield语句</p>
</li>
<li><p>无法到达语句（Unreachable Statements）：如果语句由于无法访问而无法执行，则为编译时错误。</p>
</li>
</ul>
</li>
</ul>
<p>具体见<a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-14.html#jls-14.1" target="_blank" rel="noopener">Java Language Specification</a>。</p>
<p>其继承关系如下：</p>
<p><img src="/images/Java编译相关的JCTree和TreeMaker的API介绍/Tree继承图.jpg" alt="Tree继承图"></p>
<h1 id="TreeMaker"><a href="#TreeMaker" class="headerlink" title="TreeMaker"></a>TreeMaker</h1><p>既然上面说到抽象语法树节点必须依赖一个context，则无法直接new。所以就有了TreeMaker，用来在指定下文中来新建抽象语法树节点。</p>
<h2 id="instance-Context-context"><a href="#instance-Context-context" class="headerlink" title="instance(Context context)"></a><code>instance(Context context)</code></h2><p>该方法用于获取TreeMaker实例。其中context可以通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Context context = ((JavacProcessingEnvironment) processingEnv).getContext();</span><br></pre></td></tr></table></figure>
<p>来获取。</p>
<h2 id="at"><a href="#at" class="headerlink" title="at"></a><code>at</code></h2><p>这个函数是用来改变当前树节点在context的位置。并不会产生新的树节点。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Reassign current position.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeMaker <span class="title">at</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = pos;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Modifiers-long-flags"><a href="#Modifiers-long-flags" class="headerlink" title="Modifiers(long flags)"></a><code>Modifiers(long flags)</code></h2><p>用于新建一个标识符。其中入参<code>flags</code>可以用枚举类型<code>com.sun.tools.javac.code.Flags</code>，且支持拼接（枚举值经过精心设计）。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">treeMaker.Modifiers(Flags.PUBLIC + Flags.STATIC + Flags.FINAL);</span><br></pre></td></tr></table></figure>
<h2 id="Import-JCTree-qualid-boolean-importStatic"><a href="#Import-JCTree-qualid-boolean-importStatic" class="headerlink" title="Import(JCTree qualid, boolean importStatic)"></a><code>Import(JCTree qualid, boolean importStatic)</code></h2><p>用来新建一个Import语句。其中qualid是要引入的类。</p>
<h2 id="ClassDef"><a href="#ClassDef" class="headerlink" title="ClassDef"></a><code>ClassDef</code></h2><p>用来新建一个类语句，所有参数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">JCClassDecl <span class="title">ClassDef</span><span class="params">(JCModifiers mods,							// 修饰符</span></span></span><br><span class="line"><span class="function"><span class="params">                     Name name,									// 类的名字</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;JCTypeParameter&gt; typarams,			// 类型参数，如&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                     JCExpression extending,					// 继承的类，extends T</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;JCExpression&gt; implementing,			// 实现的接口</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;JCTree&gt; defs)</span></span>;						<span class="comment">// 类中的具体语句，如类型声明或者方法声明，所以是一个List</span></span><br></pre></td></tr></table></figure>
<h2 id="MethodDef"><a href="#MethodDef" class="headerlink" title="MethodDef"></a><code>MethodDef</code></h2><p>用来新建一个犯法语句，所有参数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">JCMethodDecl <span class="title">MethodDef</span><span class="params">(JCModifiers mods,						// 修饰符</span></span></span><br><span class="line"><span class="function"><span class="params">                       Name name,								// 方法的名字</span></span></span><br><span class="line"><span class="function"><span class="params">                       JCExpression restype,					// 返回类型</span></span></span><br><span class="line"><span class="function"><span class="params">                       List&lt;JCTypeParameter&gt; typarams,			// 类型参数列表，如&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                       JCVariableDecl recvparam,				// receiver type，好像实际上没啥用</span></span></span><br><span class="line"><span class="function"><span class="params">                       List&lt;JCVariableDecl&gt; params,				// 参数列表</span></span></span><br><span class="line"><span class="function"><span class="params">                       List&lt;JCExpression&gt; thrown,				// 抛出错误的列表</span></span></span><br><span class="line"><span class="function"><span class="params">                       JCBlock body,							// 方法体</span></span></span><br><span class="line"><span class="function"><span class="params">                       JCExpression defaultValue)</span></span>;				<span class="comment">// 默认方法，如interface中的默认实现</span></span><br></pre></td></tr></table></figure>
<h2 id="VarDef-JCModifiers-mods-Name-name-JCExpression-vartype-JCExpression-init"><a href="#VarDef-JCModifiers-mods-Name-name-JCExpression-vartype-JCExpression-init" class="headerlink" title="VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init)"></a><code>VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init)</code></h2><p>用来新建一个变量。</p>
<p>参数意义如下：</p>
<ul>
<li>mods：修饰符</li>
<li>name：变量名</li>
<li>vartype：变量类型</li>
<li>init：初始化</li>
</ul>
<h2 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a><code>Skip</code></h2><p>用来新建一个<code>;</code>语句块，没有参数。</p>
<h2 id="Block-long-flags-List-lt-JCStatement-gt-stats"><a href="#Block-long-flags-List-lt-JCStatement-gt-stats" class="headerlink" title="Block(long flags, List&lt;JCStatement&gt; stats)"></a><code>Block(long flags, List&lt;JCStatement&gt; stats)</code></h2><p>用来新建一个块语句。</p>
<p>参数意义如下：</p>
<ul>
<li>flags：访问标志</li>
<li>stats：语句列表</li>
</ul>
<h2 id="DoLoop-JCStatement-body-JCExpression-cond"><a href="#DoLoop-JCStatement-body-JCExpression-cond" class="headerlink" title="DoLoop(JCStatement body, JCExpression cond)"></a><code>DoLoop(JCStatement body, JCExpression cond)</code></h2><p>用来新建一个<code>do...while</code>语句。</p>
<p>参数意义如下：</p>
<ul>
<li>body：循环体的语句</li>
<li>cond：循环条件</li>
</ul>
<h2 id="JCWhileLoop-WhileLoop-JCExpression-cond-JCStatement-body"><a href="#JCWhileLoop-WhileLoop-JCExpression-cond-JCStatement-body" class="headerlink" title="JCWhileLoop WhileLoop(JCExpression cond, JCStatement body)"></a><code>JCWhileLoop WhileLoop(JCExpression cond, JCStatement body)</code></h2><p>用来新建一个<code>while</code>循环。</p>
<p>参数意义如下：</p>
<ul>
<li>cond：循环条件。</li>
<li>body：循环体语句。</li>
</ul>
<h2 id="ForLoop"><a href="#ForLoop" class="headerlink" title="ForLoop"></a>ForLoop</h2><p>用来新建一个for循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">JCForLoop <span class="title">ForLoop</span><span class="params">(List&lt;JCStatement&gt; init,					// 循环初始化</span></span></span><br><span class="line"><span class="function"><span class="params">                  JCExpression cond,						// 循环条件</span></span></span><br><span class="line"><span class="function"><span class="params">                  List&lt;JCExpressionStatement&gt; step,				// 循环的变化语句</span></span></span><br><span class="line"><span class="function"><span class="params">                  JCStatement body)</span></span>;						<span class="comment">// 循环体</span></span><br></pre></td></tr></table></figure>
<h2 id="JCEnhancedForLoop-ForeachLoop-JCVariableDecl-var-JCExpression-expr-JCStatement-body"><a href="#JCEnhancedForLoop-ForeachLoop-JCVariableDecl-var-JCExpression-expr-JCStatement-body" class="headerlink" title="JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body)"></a>JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body)</h2><p>用来新建一个增强for循环。</p>
<p>其参数意义如下：</p>
<ul>
<li>var：每次循环的单个变量</li>
<li>expr：被循环的变量</li>
<li>body：循环体</li>
</ul>
<h2 id="JCLabeledStatement-Labelled-Name-label-JCStatement-body"><a href="#JCLabeledStatement-Labelled-Name-label-JCStatement-body" class="headerlink" title="JCLabeledStatement Labelled(Name label, JCStatement body)"></a><code>JCLabeledStatement Labelled(Name label, JCStatement body)</code></h2><p>用来新建一个标记块。</p>
<p>其参数意义如下：</p>
<ul>
<li>label：标签名</li>
<li>body：块体</li>
</ul>
<h2 id="public-JCSwitch-Switch-JCExpression-selector-List-lt-JCCase-gt-cases"><a href="#public-JCSwitch-Switch-JCExpression-selector-List-lt-JCCase-gt-cases" class="headerlink" title="public JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases)"></a><code>public JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases)</code></h2><p>用来新建一个Switch语句。</p>
<p>其参数意义如下：</p>
<ul>
<li>selector： switch语句中被判断的表达式</li>
<li>cases：switch语句的cases</li>
</ul>
<h2 id="public-JCCase-Case-JCExpression-pat-List-lt-JCStatement-gt-stats"><a href="#public-JCCase-Case-JCExpression-pat-List-lt-JCStatement-gt-stats" class="headerlink" title="public JCCase Case(JCExpression pat, List&lt;JCStatement&gt; stats)"></a><code>public JCCase Case(JCExpression pat, List&lt;JCStatement&gt; stats)</code></h2><p>用来新建一个case语句。</p>
<p>其参数意义如下：</p>
<ul>
<li>pat：case语句的条件表达式</li>
<li>stats：符合条件时的语句块</li>
</ul>
<h2 id="public-JCSynchronized-Synchronized-JCExpression-lock-JCBlock-body"><a href="#public-JCSynchronized-Synchronized-JCExpression-lock-JCBlock-body" class="headerlink" title="public JCSynchronized Synchronized(JCExpression lock, JCBlock body)"></a><code>public JCSynchronized Synchronized(JCExpression lock, JCBlock body)</code></h2><p>用来新建一个synchronized语句。</p>
<p>其参数意义如下：</p>
<ul>
<li>lock：同步锁的对象</li>
<li>body：synchronized的语句块</li>
</ul>
<h2 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h2><p>用来新建一个try语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JCTry <span class="title">Try</span><span class="params">(List&lt;JCTree&gt; resources,				// <span class="keyword">try</span>-resource语句中的资源列表</span></span></span><br><span class="line"><span class="function"><span class="params">                     JCBlock body,						// <span class="keyword">try</span>的主体语句块</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;JCCatch&gt; catchers,			// <span class="keyword">try</span>对应的<span class="keyword">catch</span>语句列表</span></span></span><br><span class="line"><span class="function"><span class="params">                     JCBlock finalizer)</span> 				<span class="comment">// finally语句</span></span></span><br></pre></td></tr></table></figure>
<h2 id="public-JCCatch-Catch-JCVariableDecl-param-JCBlock-body"><a href="#public-JCCatch-Catch-JCVariableDecl-param-JCBlock-body" class="headerlink" title="public JCCatch Catch(JCVariableDecl param, JCBlock body)"></a><code>public JCCatch Catch(JCVariableDecl param, JCBlock body)</code></h2><p>用来新建一个catch语句。</p>
<p>其参数意义如下：</p>
<ul>
<li>param：catch语句的参数</li>
<li>body：catch语句的主体语句块</li>
</ul>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a>Conditional</h2><p>用来新建一个三目表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JCConditional <span class="title">Conditional</span><span class="params">(JCExpression cond,				// 条件判断</span></span></span><br><span class="line"><span class="function"><span class="params">                                 JCExpression thenpart,			// 结果为真的语句</span></span></span><br><span class="line"><span class="function"><span class="params">                                 JCExpression elsepart)</span>			<span class="comment">// 结果为假的语句</span></span></span><br></pre></td></tr></table></figure>
<h2 id="public-JCIf-If-JCExpression-cond-JCStatement-thenpart-JCStatement-elsepart"><a href="#public-JCIf-If-JCExpression-cond-JCStatement-thenpart-JCStatement-elsepart" class="headerlink" title="public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart)"></a><code>public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart)</code></h2><p>用来新建一个if语句。</p>
<p>其参数意义如下：</p>
<ul>
<li>cond：if条件语句</li>
<li>thenpart：if的语句块</li>
<li>elsepart：else的语句块</li>
</ul>
<h2 id="JCExpressionStatement-Exec-JCExpression-expr"><a href="#JCExpressionStatement-Exec-JCExpression-expr" class="headerlink" title="JCExpressionStatement Exec(JCExpression expr)"></a><code>JCExpressionStatement Exec(JCExpression expr)</code></h2><p>用来创建一个可执行语句。</p>
<p>其参数意义如下：</p>
<ul>
<li>expr：要执行的语句。</li>
</ul>
<p><strong>例如，TreeMaker.Apply以及TreeMaker.Assign就需要外面包一层TreeMaker.Exec来获得一个JCExpressionStatement</strong></p>
<h2 id="public-JCBreak-Break-Name-label"><a href="#public-JCBreak-Break-Name-label" class="headerlink" title="public JCBreak Break(?Name label)"></a><code>public JCBreak Break(?Name label)</code></h2><p>用来创建一个break语句，可以是带标签的。</p>
<h2 id="public-JCContinue-Continue-Name-label"><a href="#public-JCContinue-Continue-Name-label" class="headerlink" title="public JCContinue Continue(?Name label)"></a><code>public JCContinue Continue(?Name label)</code></h2><p>用来创建一个continue语句，可以是带标签的。</p>
<h2 id="public-JCReturn-Return-JCExpression-expr"><a href="#public-JCReturn-Return-JCExpression-expr" class="headerlink" title="public JCReturn Return(JCExpression expr)"></a><code>public JCReturn Return(JCExpression expr)</code></h2><p>用来创建一个return语句，expr是要返回的表达式。</p>
<h2 id="public-JCThrow-Throw-JCExpression-expr"><a href="#public-JCThrow-Throw-JCExpression-expr" class="headerlink" title="public JCThrow Throw(JCExpression expr)"></a><code>public JCThrow Throw(JCExpression expr)</code></h2><p>用来新建一个throw语句，expr是要抛出的错误表达式。</p>
<h2 id="NewClass"><a href="#NewClass" class="headerlink" title="NewClass"></a>NewClass</h2><p>用来新建一个新的类实例化，如<code>new A()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JCNewClass <span class="title">NewClass</span><span class="params">(JCExpression encl,					// 作用域，一般是在顶层，可以通getEnclosingExpression函数来获取</span></span></span><br><span class="line"><span class="function"><span class="params">                           List&lt;JCExpression&gt; typeargs,			// 类型参数列表</span></span></span><br><span class="line"><span class="function"><span class="params">                           JCExpression clazz,					// </span></span></span><br><span class="line"><span class="function"><span class="params">                           List&lt;JCExpression&gt; args,				// 实例化时需要的构造器参数</span></span></span><br><span class="line"><span class="function"><span class="params">                           JCClassDecl def)</span>						<span class="comment">//  要实例化的类的定义</span></span></span><br></pre></td></tr></table></figure>
<h2 id="NewArray"><a href="#NewArray" class="headerlink" title="NewArray"></a>NewArray</h2><p>用来创建一个数组。例如，<code>new int[10][10]{1,2,3}</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JCNewArray <span class="title">NewArray</span><span class="params">(JCExpression elemtype,		// 数组对的类型</span></span></span><br><span class="line"><span class="function"><span class="params">                         List&lt;JCExpression&gt; dims,		// 数组的维度列表</span></span></span><br><span class="line"><span class="function"><span class="params">                         List&lt;JCExpression&gt; elems)</span>		<span class="comment">// 数组的元素列表</span></span></span><br></pre></td></tr></table></figure>
<h2 id="public-JCLambda-Lambda-List-lt-JCVariableDecl-gt-params-JCTree-body"><a href="#public-JCLambda-Lambda-List-lt-JCVariableDecl-gt-params-JCTree-body" class="headerlink" title="public JCLambda Lambda(List&lt;JCVariableDecl&gt; params,JCTree body)"></a><code>public JCLambda Lambda(List&lt;JCVariableDecl&gt; params,JCTree body)</code></h2><p>用来创建一个lambda表达式。</p>
<p>其参数意义如下：</p>
<ul>
<li>params：参数</li>
<li>body：lambda表达式的方法体</li>
</ul>
<h2 id="public-JCAssign-Assign-JCExpression-lhs-JCExpression-rhs"><a href="#public-JCAssign-Assign-JCExpression-lhs-JCExpression-rhs" class="headerlink" title="public JCAssign Assign(JCExpression lhs, JCExpression rhs)"></a><code>public JCAssign Assign(JCExpression lhs, JCExpression rhs)</code></h2><p>用来创建一个赋值表达式，如例<code>a = b</code></p>
<p>其参数意义如下：</p>
<ul>
<li>lhs：左侧的表示</li>
<li>rhs：右侧的表示</li>
</ul>
<h2 id="public-JCAssignOp-Assignop-JCTree-Tag-opcode-JCTree-lhs-JCTree-rhs"><a href="#public-JCAssignOp-Assignop-JCTree-Tag-opcode-JCTree-lhs-JCTree-rhs" class="headerlink" title="public JCAssignOp Assignop(JCTree.Tag opcode, JCTree lhs, JCTree rhs)"></a><code>public JCAssignOp Assignop(JCTree.Tag opcode, JCTree lhs, JCTree rhs)</code></h2><p>用来创建一个复合赋值运算符。例如：<code>a += b</code>或<code>c-= d</code>等操作。</p>
<p>其参数意义如下：</p>
<ul>
<li>opcode：操作符</li>
<li>lhs：左侧表达式</li>
<li>rhs：右侧表达式</li>
</ul>
<h2 id="public-JCBinary-Binary-JCTree-Tag-opcode-JCExpression-lhs-JCExpression-rhs"><a href="#public-JCBinary-Binary-JCTree-Tag-opcode-JCExpression-lhs-JCExpression-rhs" class="headerlink" title="public JCBinary Binary(JCTree.Tag opcode, JCExpression lhs, JCExpression rhs)"></a><code>public JCBinary Binary(JCTree.Tag opcode, JCExpression lhs, JCExpression rhs)</code></h2><p>创建一个二元操作符。如<code>a - b</code>或<code>c + d</code>。</p>
<p>其参数意义如下：</p>
<ul>
<li>opcode：操作符</li>
<li>lhs：左侧表达式</li>
<li>rhs：右侧表达式</li>
</ul>
<h2 id="public-JCTypeCast-TypeCast-JCTree-clazz-JCExpression-expr"><a href="#public-JCTypeCast-TypeCast-JCTree-clazz-JCExpression-expr" class="headerlink" title="public JCTypeCast TypeCast(JCTree clazz, JCExpression expr)"></a><code>public JCTypeCast TypeCast(JCTree clazz, JCExpression expr)</code></h2><p>创建一个类型强转。如<code>(int)c</code>。</p>
<p>其参数意义如下：</p>
<ul>
<li>clazz：要转换的类型</li>
<li>expr：要转换的变量</li>
</ul>
<h2 id="public-JCArrayAccess-Indexed-JCExpression-indexed-JCExpression-index"><a href="#public-JCArrayAccess-Indexed-JCExpression-indexed-JCExpression-index" class="headerlink" title="public JCArrayAccess Indexed(JCExpression indexed, JCExpression index)"></a><code>public JCArrayAccess Indexed(JCExpression indexed, JCExpression index)</code></h2><p>创建一个根据数组下标获取语句，如<code>arr[0]</code>。</p>
<p>其参数意义如下：</p>
<ul>
<li>indexed：被获取的数组表达式</li>
<li>index：数组下标</li>
</ul>
<h2 id="public-JCFieldAccess-Select-JCExpression-selected-Name-selector"><a href="#public-JCFieldAccess-Select-JCExpression-selected-Name-selector" class="headerlink" title="public JCFieldAccess Select(JCExpression selected, Name selector)"></a><code>public JCFieldAccess Select(JCExpression selected, Name selector)</code></h2><p>创建一个对象获取语句，如<code>obj.prop</code>。</p>
<p>其参数意义如下：</p>
<ul>
<li>selected：被选择的对象</li>
<li>selector：要选择的对象属性</li>
</ul>
<h2 id="public-JCIdent-Ident-Name-name"><a href="#public-JCIdent-Ident-Name-name" class="headerlink" title="public JCIdent Ident(Name name)"></a><code>public JCIdent Ident(Name name)</code></h2><p>创建一个标识符语句。例如：<code>a = 10</code>中的a。</p>
<h2 id="public-JCLiteral-Literal-TypeTag-tag-Object-value"><a href="#public-JCLiteral-Literal-TypeTag-tag-Object-value" class="headerlink" title="public JCLiteral Literal(TypeTag tag, Object value)"></a><code>public JCLiteral Literal(TypeTag tag, Object value)</code></h2><p>创建一个字面量表达式。如<code>String a = &#39;10&#39;</code>中的<code>&#39;10&#39;</code>。</p>
<p>其参数意义如下：</p>
<ul>
<li>tag：字面量表达式的类型</li>
<li>value：字面量表达式的值</li>
</ul>
<h2 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a><code>Apply</code></h2><p>创建一个方法调用。如<code>method1(10)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JCMethodInvocation <span class="title">Apply</span><span class="params">(List&lt;JCExpression&gt; typeargs,	// 类型参数列表</span></span></span><br><span class="line"><span class="function"><span class="params">                                JCExpression fn,				// 函数</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;JCExpression&gt; args)</span>		<span class="comment">// 函数的参数</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
      <tags>
        <tag>JCTree</tag>
        <tag>TreeMaker</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的各种文件压缩、解压方法（更新中~）</title>
    <url>/2022/07/01/Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E3%80%81%E8%A7%A3%E5%8E%8B%E6%96%B9%E6%B3%95%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD~%EF%BC%89/</url>
    <content><![CDATA[<p>Note：本文的工具都开源在GitHub的<a href="https://github.com/MW530/JUtils" target="_blank" rel="noopener">JUtils</a>上。</p>
<h1 id="ZIP压缩"><a href="#ZIP压缩" class="headerlink" title="ZIP压缩"></a>ZIP压缩</h1><h2 id="zipOutputStream方式"><a href="#zipOutputStream方式" class="headerlink" title="zipOutputStream方式"></a>zipOutputStream方式</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>这个方式是最基础的方式，是Java底层给出的一种流方案。</p>
<p>其压缩方式步骤如下：</p>
<ol>
<li>新建一个<code>ZipOutputStream</code>，其参数接收一个<code>OutputStream</code>，一般是新建一个FileOutputStream。</li>
<li>循环获取要压缩的文件/文件夹，调用putEntry函数进行流的写入。</li>
<li>putEntry的过程如下：<ol>
<li>如果是文件夹，则将其设为基础目录，然后递归调用putEntry来压缩该文件夹下的文件。</li>
<li>如果是文件，则使用基础目录拼接后将该entry放入流中。</li>
</ol>
</li>
<li>设置压缩级别。</li>
<li>flush、close这个流。</li>
</ol>
<p>值得注意的有：</p>
<ul>
<li>文件夹的处理，即递归的获取子文件夹，然后进行压缩。</li>
<li>entry的名字则自带了文件夹目录层级，即<code>xxx/aaaa.jpg</code>则会在压缩包中新建一个xxx的文件夹，并把<code>aaa.jpg</code>放入其中。</li>
</ul>
<p>具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>  2022/7/4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> fileUrls中，文件只会取文件名，文件夹则只会取最内层文件夹的名字。但子文件夹和其下的子文件就会递归压缩了。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> fileInfos:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> compressionLevel:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> filePath:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFilesByZipStream</span><span class="params">(ArrayList&lt;String&gt; fileUrls, Integer compressionLevel, String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断外围文件夹是否存在，如果不存在则创建</span></span><br><span class="line">    <span class="keyword">if</span>(fileUrls == <span class="keyword">null</span> || filePath.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">"文件列表不能为空！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String filePathWithoutName = FileUtils.getOuterFolderPath(filePath);</span><br><span class="line">    File pathFile = <span class="keyword">new</span> File(filePathWithoutName);</span><br><span class="line">    <span class="keyword">if</span>(!pathFile.exists())&#123;</span><br><span class="line">        pathFile.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断源文件存在，则删除</span></span><br><span class="line">    File tempFile = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    <span class="keyword">if</span>(tempFile.exists())&#123;</span><br><span class="line">        tempFile.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZipOutputStream zipOutputStream = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(filePath), Charset.forName(<span class="string">"GBK"</span>));</span><br><span class="line">    <span class="keyword">for</span> (String url : fileUrls) &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(url);</span><br><span class="line">        putEntry(zipOutputStream, file, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    zipOutputStream.setLevel(compressionLevel);</span><br><span class="line">    zipOutputStream.flush();</span><br><span class="line">    zipOutputStream.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putEntry</span><span class="params">(ZipOutputStream zipOutputStream, File file, String basePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory())&#123;</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File subFile : files) &#123;</span><br><span class="line">            putEntry(zipOutputStream, subFile, basePath + File.separator + file.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ZipEntry entry = <span class="keyword">new</span> ZipEntry(basePath + File.separator + file.getName());</span><br><span class="line">        entry.setSize(file.length());</span><br><span class="line">        zipOutputStream.putNextEntry(entry);</span><br><span class="line">        <span class="keyword">byte</span>[] fileByte = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        fileInputStream.read(fileByte);</span><br><span class="line">        zipOutputStream.write(fileByte);</span><br><span class="line">        zipOutputStream.flush();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>解压的过程就比较简单了，因为不涉及递归获取文件。其过程如下：</p>
<ol>
<li>只需要不断调用<code>getNextEntry</code>方法，获取entry，判断其为文件夹还是文件：<ol>
<li>如果是文件夹，则结合基础目录，拼接新目录并新建该文件夹。</li>
<li>如果是文件，则结合基础目录，拼接新文件目录，然后读取流中的文件并写入该文件。</li>
</ol>
</li>
<li>关闭Entry、关闭流。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractZipByStream</span><span class="params">(String zipPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File zipFile = <span class="keyword">new</span> File(zipPath);</span><br><span class="line">    String newOuterPath = zipFile.getParent() + File.separator + zipFile.getName().split(<span class="string">"\\."</span>)[<span class="number">0</span>];</span><br><span class="line">    File newOuterFolder = <span class="keyword">new</span> File(newOuterPath);</span><br><span class="line">    <span class="keyword">if</span>(!newOuterFolder.exists())&#123;</span><br><span class="line">        newOuterFolder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(zipPath), Charset.forName(<span class="string">"GBK"</span>));</span><br><span class="line">    ZipEntry entry = zipInputStream.getNextEntry();</span><br><span class="line">    <span class="keyword">while</span>(entry != <span class="keyword">null</span>)&#123;</span><br><span class="line">        String newPath = newOuterPath + File.separator + entry.getName();</span><br><span class="line">        File file =  <span class="keyword">new</span> File(newPath);</span><br><span class="line">        <span class="keyword">if</span>(entry.isDirectory())&#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">            <span class="comment">//文件</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            String parent = file.getParent();</span><br><span class="line">            File outerFolder = <span class="keyword">new</span> File(parent);</span><br><span class="line">            <span class="keyword">if</span> (!outerFolder.exists())&#123;</span><br><span class="line">                outerFolder.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            BufferedOutputStream bufferedInputStream =  <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = zipInputStream.read(buff, <span class="number">0</span> ,<span class="number">1024</span>)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bufferedInputStream.write(buff, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            zipInputStream.read(buff);</span><br><span class="line">            bufferedInputStream.flush();</span><br><span class="line">            bufferedInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">        entry = zipInputStream.getNextEntry();</span><br><span class="line">    &#125;</span><br><span class="line">    zipInputStream.closeEntry();</span><br><span class="line">    zipInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><ol>
<li><p><code>entry.getSize()</code>：这个接口返回对应entry未压缩时的大小。<strong>但是其可能是未知的</strong>，所以不能通过该属性来新建byte数组。</p>
</li>
<li><p>文件流读取：就像上面说的，<code>entry.getSize()</code>可能是未知的。所以流读取的时候，应当采用先初始化一个固定大小的数组，然后调用read时传入该数组的大小，这里是1024。但是read会返回当次读取的字节长度，如果小于1024，则返回该次的大小，否则就是传入的大小（1024）。</p>
</li>
<li><p>还得注意中文，如果文件中含有中文，那必须在新建流的时候，传入第二个编码参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(zipPath), Charset.forName(<span class="string">"GBK"</span>));</span><br><span class="line"></span><br><span class="line">ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(zipPath), Charset.forName(<span class="string">"GBK"</span>));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ZipFile方式"><a href="#ZipFile方式" class="headerlink" title="ZipFile方式"></a>ZipFile方式</h2><p>ZipFile类可以用来读取zip文件，其实本质上还是利用<code>ZipInputStream</code>，所以其只可以用来解压缩文件。但是由于其对压缩包的每个文件都进行拆解，所以相较于直接用<code>ZipInputStream</code>，会简单一点（但也只是一点）。</p>
<p><code>ZipFile</code>有一个<code>entries()</code>方法，可以获取所有的元素。然后遍历整个所有的entries。与<code>ZipInputStream</code>不同的就是，可以通过entries对象获取单个<code>inputStream</code>，就不存在自己看分割长度的问题。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>  2022/7/6</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 通过Java自带的ZipFile类实现文件解压缩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> zipPath: 压缩文件目标地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">extractZipFileByZipFile</span><span class="params">(String zipPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File NativeZipFile = <span class="keyword">new</span> File(zipPath);</span><br><span class="line">    String newOuterPath = NativeZipFile.getParent() + File.separator + NativeZipFile.getName().split(<span class="string">"\\."</span>)[<span class="number">0</span>];</span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(zipPath);</span><br><span class="line">    Enumeration&lt;? extends ZipEntry&gt; entries = zipFile.entries();</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;? extends ZipEntry&gt; it = entries.asIterator(); it.hasNext(); ) &#123;</span><br><span class="line">        ZipEntry zipEntry = it.next();</span><br><span class="line">        String newPath = newOuterPath + File.separator + zipEntry.getName();</span><br><span class="line">        File file =  <span class="keyword">new</span> File(newPath);</span><br><span class="line">        <span class="keyword">if</span>(zipEntry.isDirectory())&#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">            <span class="comment">//文件</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            String parent = file.getParent();</span><br><span class="line">            File outerFolder = <span class="keyword">new</span> File(parent);</span><br><span class="line">            <span class="keyword">if</span> (!outerFolder.exists())&#123;</span><br><span class="line">                outerFolder.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            InputStream inputStream = zipFile.getInputStream(zipEntry);</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            fileOutputStream.write(inputStream.readAllBytes());</span><br><span class="line">            fileOutputStream.flush();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="zip4j方式"><a href="#zip4j方式" class="headerlink" title="zip4j方式"></a>zip4j方式</h2><p>Zip4j是用于zip文件或流的最全面的Java库。最重要的是：zip4j是唯一一个支持压缩文件加密的工具。像上面提到的<code>ZipOutputStream</code>并不支持加密。并且zip4j的API很简单。如果不是，一般就不需要封装了，可以直接用。</p>
<p>下面还是给出一个简单的封装，主要是将其功能封装在了多个重载函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>  2022/7/6</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 通过zip4j进行无密码的压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> zipPath: 压缩文件目标地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> fileUrls: 被压缩文件的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> compressLevel:  压缩率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compressZipFileByZip4j</span><span class="params">(String zipPath, ArrayList&lt;String&gt; fileUrls, CompressionLevel compressLevel)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">        net.lingala.zip4j.ZipFile zipFile = <span class="keyword">new</span> net.lingala.zip4j.ZipFile(zipPath);</span><br><span class="line">        _compressZipFileByZip4j(zipFile, fileUrls, compressLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>  2022/7/6</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 通过zip4j进行有密码压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> zipPath: 压缩文件目标的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> fileUrls: 要被压缩的文件列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> compressLevel: 压缩率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> password: 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compressZipFileByZip4j</span><span class="params">(String zipPath, ArrayList&lt;String&gt; fileUrls, CompressionLevel compressLevel, @NotNull String password)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">        net.lingala.zip4j.ZipFile zipFile = <span class="keyword">new</span> net.lingala.zip4j.ZipFile(zipPath, password.toCharArray());</span><br><span class="line">        _compressZipFileByZip4j(zipFile, fileUrls, compressLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>  2022/7/6</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 通过zip4j进行无密码压缩，然后重命名被压缩的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> zipPath: 压缩文件目标的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> fileUrls: 要被压缩的文件列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> compressLevel: 压缩率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> renames: 重命名map，&lt;originalName, newName&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compressZipFileByZip4j</span><span class="params">(String zipPath, ArrayList&lt;String&gt; fileUrls, CompressionLevel compressLevel, Map&lt;String, String&gt; renames)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">        net.lingala.zip4j.ZipFile zipFile = <span class="keyword">new</span> net.lingala.zip4j.ZipFile(zipPath);</span><br><span class="line">        _compressZipFileByZip4j(zipFile, fileUrls, compressLevel);</span><br><span class="line">        zipFile.renameFiles(renames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>  2022/7/6 通过zip4j进行有密码压缩，然后重命名被压缩的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> zipPath: 压缩文件目标的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> fileUrls: 要被压缩的文件列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> compressLevel: 压缩率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> password: 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> renames: 重命名map，&lt;originalName, newName&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compressZipFileByZip4j</span><span class="params">(String zipPath, ArrayList&lt;String&gt; fileUrls, CompressionLevel compressLevel, @NotNull String password, Map&lt;String, String&gt; renames)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">        net.lingala.zip4j.ZipFile zipFile = <span class="keyword">new</span> net.lingala.zip4j.ZipFile(zipPath, password.toCharArray());</span><br><span class="line">        _compressZipFileByZip4j(zipFile, fileUrls, compressLevel);</span><br><span class="line">        zipFile.renameFiles(renames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>  2022/7/6</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 通过zip4j进行无密码解压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> zipPath: 压缩文件目标的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> targetPath: 解压释放目标地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractZipFileByZip4j</span><span class="params">(String zipPath, String targetPath)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">        net.lingala.zip4j.ZipFile zipFile = <span class="keyword">new</span> net.lingala.zip4j.ZipFile(zipPath);</span><br><span class="line">        zipFile.extractAll(targetPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>  2022/7/6</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 通过zip4j进行有密码解压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> zipPath: 压缩文件目标的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> targetPath: 解压释放目标地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> password: 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractZipFileByZip4j</span><span class="params">(String zipPath, String targetPath, @NotNull String password)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">        net.lingala.zip4j.ZipFile zipFile = <span class="keyword">new</span> net.lingala.zip4j.ZipFile(zipPath, password.toCharArray());</span><br><span class="line">        zipFile.extractAll(targetPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>  2022/7/6</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 通过zip4j进行无密码解压，并且只解压给出列表的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> zipPath: 压缩文件目标的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> targetPath: 解压释放目标地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> extractFiles: 要解压的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractZipFileByZip4j</span><span class="params">(String zipPath, String targetPath, List&lt;String&gt; extractFiles)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">        net.lingala.zip4j.ZipFile zipFile = <span class="keyword">new</span> net.lingala.zip4j.ZipFile(zipPath);</span><br><span class="line">        <span class="keyword">for</span> (String extractFile : extractFiles) &#123;</span><br><span class="line">            zipFile.extractFile(extractFile, targetPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> MichaelWang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>  2022/7/6</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 通过zip4j进行有密码解压，并且只解压给出列表的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> zipPath: 压缩文件目标的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> targetPath: 解压释放目标地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> password: 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> extractFiles: 要解压的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractZipFileByZip4j</span><span class="params">(String zipPath, String targetPath, @NotNull String password, List&lt;String&gt; extractFiles)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">        net.lingala.zip4j.ZipFile zipFile = <span class="keyword">new</span> net.lingala.zip4j.ZipFile(zipPath, password.toCharArray());</span><br><span class="line">        <span class="keyword">for</span> (String extractFile : extractFiles) &#123;</span><br><span class="line">            zipFile.extractFile(extractFile, targetPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>文件压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程编程核心技术-1-多线程技术基础</title>
    <url>/2022/03/29/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h1><p>Java的JDK实现多线程编程主要有两种方式：一种是继承Thread类，另一种是实现Runnable接口。</p>
<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><p>直接继承Thread类，然后重写其run方法就可以得到一个新的线程类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">"MyThread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主方法中启动线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread mythread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mythread.start();</span><br><span class="line">        System.out.println(<span class="string">"main"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">MyThread</span><br></pre></td></tr></table></figure>
<p>由于新线程的启动需要更多时间，所以main被先打印出来。</p>
<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>由于Java不支持多继承，使用继承就会造成问题，如果本来还需要继承其他的父类，那么为了实现多线程来占用一个继承就得不尝试了，因此使用Runnable接口更加合理。实际上Thread也是实现了Runable接口的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure>
<h3 id="创建新的线程类"><a href="#创建新的线程类" class="headerlink" title="创建新的线程类"></a>创建新的线程类</h3><p>同样的，实现该接口后重写其中的run方法，即可实现一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myrunnable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyRunnable运行中!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行该线程"><a href="#运行该线程" class="headerlink" title="运行该线程"></a>运行该线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">"运行结束!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例变量共享造成的非线程安全问题与解决方案"><a href="#实例变量共享造成的非线程安全问题与解决方案" class="headerlink" title="实例变量共享造成的非线程安全问题与解决方案"></a>实例变量共享造成的非线程安全问题与解决方案</h2><p>每个线程类可以有多个实体对象。</p>
<ul>
<li>每个实体对象都可以单独调用start方法来运行，</li>
<li>或者通过Thread类来构造多个新的线程对象。</li>
</ul>
<p>此时前一种情况，每个实体对象的属性是独立的，即每个线程都拥有一份独立的属性。</p>
<p><strong>总结规律就是：只有在创建不同线程的线程对象是同一个的时候，其中的成员变量才会被共享。</strong></p>
<p>例如：</p>
<h3 id="独立变量"><a href="#独立变量" class="headerlink" title="独立变量"></a>独立变量</h3><h4 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">            count--;</span><br><span class="line">            <span class="comment">//此示例不要用while语句，会造成其他线程得不到运行的机会</span></span><br><span class="line">            <span class="comment">//因为第一个执行while语句的线程会将count值减到0</span></span><br><span class="line">            <span class="comment">//一直由一个线程进行减法运算</span></span><br><span class="line">            System.out.println(<span class="string">"由 "</span>+<span class="keyword">this</span>.currentThread().getName()+<span class="string">" 计算，count="</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行类"><a href="#执行类" class="headerlink" title="执行类"></a>执行类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread a=<span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">        MyThread b=<span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">        MyThread c=<span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由A计算，count&#x3D;4</span><br><span class="line">由B计算，count&#x3D;4</span><br><span class="line">由c计算，count&#x3D;4</span><br><span class="line">由B计算，count&#x3D;3</span><br><span class="line">由A计算，count&#x3D;3</span><br><span class="line">由A计算，count&#x3D;2</span><br><span class="line">由A计算，count&#x3D;1</span><br><span class="line">由A计算，count&#x3D;O</span><br><span class="line">由B计算，count&#x3D;2</span><br><span class="line">由c计算，count&#x3D;3</span><br><span class="line">由B计算，count&#x3D;1</span><br><span class="line">由c计算，count&#x3D;2</span><br><span class="line">由B计算，count&#x3D;O</span><br><span class="line">由c计算，count&#x3D;1</span><br><span class="line">由c计算，count&#x3D;o</span><br></pre></td></tr></table></figure>
<p>由于每个线程独立享有属性变量，在这里即为count属性，所以每个线程都会独立操作对应count，从头5减到0。</p>
<h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><h4 id="线程类-1"><a href="#线程类-1" class="headerlink" title="线程类"></a>线程类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">            count--;</span><br><span class="line">            <span class="comment">//此示例不要用while语句，会造成其他线程得不到运行的机会</span></span><br><span class="line">            <span class="comment">//因为第一个执行while语句的线程会将count值减到0</span></span><br><span class="line">            <span class="comment">//一直由一个线程进行减法运算</span></span><br><span class="line">            System.out.println(<span class="string">"由 "</span>+<span class="keyword">this</span>.currentThread().getName()+<span class="string">" 计算，count="</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行类-1"><a href="#执行类-1" class="headerlink" title="执行类"></a>执行类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    MyThread mythread=<span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        Thread a=<span class="keyword">new</span> Thread(mythread,<span class="string">"A"</span>);</span><br><span class="line">        Thread b=<span class="keyword">new</span> Thread(mythread,<span class="string">"B"</span>);</span><br><span class="line">        Thread c=<span class="keyword">new</span> Thread(mythread,<span class="string">"C"</span>);</span><br><span class="line">        Thread d=<span class="keyword">new</span> Thread(mythread,<span class="string">"D"</span>);</span><br><span class="line">        Thread e=<span class="keyword">new</span> Thread(mythread,<span class="string">"E"</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        d.start();</span><br><span class="line">        e.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由A计算，count&#x3D;3</span><br><span class="line">由B计算，count&#x3D;3</span><br><span class="line">由c计算，count&#x3D;2</span><br><span class="line">由D计算，count&#x3D;1</span><br><span class="line">由E计算，count&#x3D;0</span><br></pre></td></tr></table></figure>
<p>此时由于这5个线程是由一个实体创建而来，所以其变量是私有的，所以每个线程都是访问的同一个变量。这样大概率会出现线程安全问题，比如上面的A, B。共享变量的值都为3，说明A, B同时对count进行了处理。</p>
<p>出现这个问题的原因主要是在JVM中，count++会被分成三步：</p>
<ul>
<li>取得原有的count值，</li>
<li>计算count-1，</li>
<li>对count进行赋值。</li>
</ul>
<p>其解决方法由几种，后面文章会详细介绍，首先这里可以使用<code>synchronized</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">            count--;</span><br><span class="line">            <span class="comment">//此示例不要用while语句，会造成其他线程得不到运行的机会</span></span><br><span class="line">            <span class="comment">//因为第一个执行while语句的线程会将count值减到0</span></span><br><span class="line">            <span class="comment">//一直由一个线程进行减法运算</span></span><br><span class="line">            System.out.println(<span class="string">"由 "</span>+<span class="keyword">this</span>.currentThread().getName()+<span class="string">" 计算，count="</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说就是：被<code>synchronized</code>关键字标记的方法，不同线程会同步进入，所以不会出现线程安全问题。</p>
<p>这里要理解的应该是共享变量的概念，而不是如何解决同步问题，这里也是多线程的核心问题之一。</p>
<h2 id="start方法与run方法"><a href="#start方法与run方法" class="headerlink" title="start方法与run方法"></a>start方法与run方法</h2><h3 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h3><p>start方法并不保证其会按照启动顺序来执行，会由JVM来为其创建新的线程，因为其会启动新的线程，不是一个立即执行操作，而不同的线程启动时间可能随系统的状态不同而改变，因此后面的线程是有可能比前面的线程更先执行。</p>
<h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h3><p>run方法一般不直接调用，因为如果直接调用，就会在当前线程直接执行。而并不是创建新线程，然后执行。</p>
<h1 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h1><h2 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h2><p>currentThread()方法可返回代码段正在被哪个线程调用。</p>
<h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br></pre></td></tr></table></figure>
<p>在新建的线程中，可以使用this来替代<code>Thread</code>，因为其本身就是<code>Runnable</code>，</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountOperate</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run---begin"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Thread.currentThread().getName()="</span></span><br><span class="line">            + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"this.getName()="</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">        System.out.println(<span class="string">"run---end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h2><p>isAlive()方法的功能是判断当前的线程是否存活。</p>
<p>该方法同样是Thread类的静态方法。</p>
<p>例如：</p>
<p>非线程类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run="</span> + <span class="keyword">this</span>.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的活动状态是指处于正在运行或准备开始运行的状态。</p>
<h2 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h2><h3 id="sleep-long-millis-方法"><a href="#sleep-long-millis-方法" class="headerlink" title="sleep(long millis)方法"></a>sleep(long millis)方法</h3><p><code>sleep()</code>方法的作用是在指定的时间（毫秒）内让当前“正在执行的线程”休眠（暂停执行），这个“正在执行的线程”是指<code>this.currentThread()</code>返回的线程。</p>
<p>例如：</p>
<p>线程类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"run threadName="</span></span><br><span class="line">                   + <span class="keyword">this</span>.currentThread().getName() + <span class="string">" begin ="</span></span><br><span class="line">                   + System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"run threadName="</span></span><br><span class="line">                   + <span class="keyword">this</span>.currentThread().getName() + <span class="string">" end   ="</span></span><br><span class="line">                   + System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread2 mythread = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        System.out.println(<span class="string">"begin ="</span> + System.currentTimeMillis());</span><br><span class="line">        mythread.start();</span><br><span class="line">        System.out.println(<span class="string">"end   ="</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin &#x3D;1396255271828</span><br><span class="line">end&#x3D;1396255271828</span><br><span class="line">run threacNarne&#x3D;Thread-0 </span><br><span class="line">begin &#x3D;1396255271828</span><br><span class="line">run threadName&#x3D;Thread-O </span><br><span class="line">end &#x3D;1396255273828</span><br></pre></td></tr></table></figure>
<p>值得注意的是sleep方法并不会释放其持有的锁。</p>
<h3 id="sleep-long-millis-int-nanos-方法"><a href="#sleep-long-millis-int-nanos-方法" class="headerlink" title="sleep(long millis, int nanos)方法"></a>sleep(long millis, int nanos)方法</h3><p><code>sleep（long millis，int nanos）</code>方法的作用是在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序的精度和准确性的影响。</p>
<h2 id="StackTraceElement-getStackTrace-方法"><a href="#StackTraceElement-getStackTrace-方法" class="headerlink" title="StackTraceElement[] getStackTrace()方法"></a>StackTraceElement[] getStackTrace()方法</h2><p>StackTraceElement[]getStackTrace()方法的作用是返回一个表示该线程堆栈跟踪元素数组。</p>
<p>注意该方法是<code>Thread.currentThread()</code>的方法。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        e();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StackTraceElement[] array = Thread.currentThread().getStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (array != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                StackTraceElement eachElement = array[i];</span><br><span class="line">                System.out.println(<span class="string">"className="</span> + eachElement.getClassName() + <span class="string">" methodName="</span> + eachElement.getMethodName() + <span class="string">" fileName="</span> + eachElement.getFileName() + <span class="string">" lineNumber="</span>+ eachElement.getLineNumber());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test1 test1 = <span class="keyword">new</span> Test1();</span><br><span class="line">        test1.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">className&#x3D;java.lang.Thread methodName&#x3D;getStackTrace fileName&#x3D;Thread.java lineNumber&#x3D;1559</span><br><span class="line">className&#x3D;test1.Test1 methodName&#x3D;e fileName&#x3D;Test1.java lineNumber&#x3D;22</span><br><span class="line">className&#x3D;test1.Test1 methodName&#x3D;d fileName&#x3D;Test1.java lineNumber&#x3D;18</span><br><span class="line">className&#x3D;test1.Test1 methodName&#x3D;c fileName&#x3D;Test1.java lineNumber&#x3D;14</span><br><span class="line">className&#x3D;test1.Test1 methodName&#x3D;b fileName&#x3D;Test1.java lineNumber&#x3D;10</span><br><span class="line">className&#x3D;test1.Test1 methodName&#x3D;a fileName&#x3D;Test1.java lineNumber&#x3D;6</span><br><span class="line">className&#x3D;test1.Test1 methodName&#x3D;main fileName&#x3D;Test1.java lineNumber&#x3D;36</span><br></pre></td></tr></table></figure>
<h2 id="dumpStack-方法"><a href="#dumpStack-方法" class="headerlink" title="dumpStack()方法"></a>dumpStack()方法</h2><p>static void dumpStack()方法的作用是将当前线程的堆栈跟踪信息输出至<strong>标准错误流</strong>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        e();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">        age = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (age == <span class="number">100</span>) &#123;</span><br><span class="line">            Thread.dumpStack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test1 test1 = <span class="keyword">new</span> Test1();</span><br><span class="line">        test1.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Exception: Stack trace</span><br><span class="line">at java.lang.Thread.dumpStack(Thread.java :1336)at test6.Test1.e(Test1.java: 25)</span><br><span class="line">at test6.Test1.d(Test1.java: 18)at test6.Test1.c(Test1.java: 14)at test6.Test1.b(Test1.java:10)at test6.Test1.a(Test1.java:6)</span><br><span class="line">at test6.Test1.main(Test1.java: 31)</span><br></pre></td></tr></table></figure>
<h2 id="getId方法"><a href="#getId方法" class="headerlink" title="getId方法"></a>getId方法</h2><p>getId()方法用于取得线程的唯一标识。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread runThread = Thread.currentThread();</span><br><span class="line">        System.out.println(runThread.getName() + <span class="string">" "</span> + runThread.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main 1</span><br></pre></td></tr></table></figure>
<p>从运行结果来看，当前执行代码的线程名称为main，线程id值为1。</p>
<h1 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h1><p>停止线程是多线程开发的一个很重要的技术点，停止线程在Java语言中并不像break语句那样干脆，还需要一些技巧性的处理。</p>
<p>在Java中有3种方法可以使正在运行的线程终止运行：</p>
<ul>
<li>使用退出标志使线程正常退出。</li>
<li>使用stop()方法强行终止线程，但是这个方法不推荐使用，因为stop()和suspend()、resume()一样，都是作废过期的方法，使用它们可能发生不可预料的结果。</li>
<li>使用interrupt()方法中断线程。</li>
</ul>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p>interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt()方法仅仅是在当前线程中做了一个停止的标记，并不是真正停止线程。</p>
<h3 id="interrupt-并不会停止"><a href="#interrupt-并不会停止" class="headerlink" title="interrupt()并不会停止"></a>interrupt()并不会停止</h3><p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> exthread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"zzzzzzzz"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D;0</span><br><span class="line">i&#x3D;1</span><br><span class="line">i&#x3D;2</span><br><span class="line">i&#x3D;3</span><br><span class="line">i&#x3D;4</span><br></pre></td></tr></table></figure>
<p>可以看到线程并没有停止。</p>
<p>实际上我们需要自己判断interrupt状态，然后自己来推出线程。</p>
<h3 id="使用interrupt-，interrupted-，this-isInterrupted-来停止线程"><a href="#使用interrupt-，interrupted-，this-isInterrupted-来停止线程" class="headerlink" title="使用interrupt()，interrupted()，this.isInterrupted()来停止线程"></a>使用<code>interrupt()，interrupted()，this.isInterrupted()</code>来停止线程</h3><ul>
<li><code>interrupted()</code>：测试currentThread()是否已经中断。执行后具有清除状态标志值为false的功能。</li>
<li><code>this.isInterrupted()</code>：测试this关键字所在类的对象是否已经中断。不清除状态标志。</li>
</ul>
<p>示例</p>
<p>线程类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="keyword">this</span>.isInterrupted())&#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"结束！线程中断！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> exthread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"zzzzzzzz"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 82345</span><br><span class="line">i &#x3D; 82345</span><br><span class="line">i &#x3D; 82345</span><br><span class="line">i &#x3D; 82345</span><br><span class="line">zzzzzzzz</span><br><span class="line">结束！线程中断！</span><br></pre></td></tr></table></figure>
<p>这里我们每一次都检测interrupt状态，如果中断了就不进行循环了。</p>
<h2 id="异常法"><a href="#异常法" class="headerlink" title="异常法"></a>异常法</h2><p>上面我们是直接循环判断，出错就跳出循环。而如果使用异常，则可以直接跳出该线程。</p>
<p>例如</p>
<p>线程类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.interrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"已经是停止状态了!我要退出了!"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"我在for下面"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"进MyThread.java类run方法中的catch了！"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> exthread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main catch"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D;183973i&#x3D;183974</span><br><span class="line">i&#x3D;183975</span><br><span class="line">i&#x3D;183976</span><br><span class="line">i&#x3D;183977</span><br><span class="line">i&#x3D;183978</span><br><span class="line">己经是停止状态了!我要退出了!</span><br><span class="line">end !</span><br><span class="line">进MyThread.java类run方法中的catch了!</span><br><span class="line">java. lang . InterruptedException</span><br><span class="line">at exthread. MyThread.run ( MyThread.java:11)</span><br></pre></td></tr></table></figure>
<p>这里就是检测到外部传入中断信息就直接抛出错误。不再运行下面的程序。</p>
<h2 id="在sleep中使用interrupt"><a href="#在sleep中使用interrupt" class="headerlink" title="在sleep中使用interrupt()"></a>在sleep中使用interrupt()</h2><p>首先明确：在sleep中使用interrupt()会直接报出<code>InterruptedException</code>错误。</p>
<p>例如：</p>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"run begin"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">"run end"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"先停止，再遇到了sleep!进入catch!"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">end!</span><br><span class="line">i&#x3D;1</span><br><span class="line">i&#x3D;2</span><br><span class="line">i&#x3D;3</span><br></pre></td></tr></table></figure>
<h2 id="stop强制停止线程"><a href="#stop强制停止线程" class="headerlink" title="stop强制停止线程"></a>stop强制停止线程</h2><p>使用stop()方法可以强行停止线程，即暴力停止线程。并且会释放该线程所持有的所有锁。并且会抛出<code>java.lang.ThreadDeath</code>。</p>
<p>例如：</p>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> testpackage.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            thread.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D;1</span><br><span class="line">i&#x3D;2</span><br><span class="line">i&#x3D;3</span><br><span class="line">i&#x3D;4</span><br></pre></td></tr></table></figure>
<p>由运行结果可以看出，线程被暴力停止了</p>
<p><strong>注意：stop()方法已经是作废的方法，因为如果暴力性地强制让线程停止，则一些清理性的工作可能得不到完成，或者数据添加不完整。</strong></p>
<p>例如，由于直接杀死线程并且释放锁，但是如果被锁的变量正被操作了一半，此时释放锁，其他线程得到的就是一个不完整的脏数据。所以该方法会被废除。</p>
<h1 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h1><p>暂停线程意味着此线程还可以恢复运行，在Java多线程中，可以使用suspend()方法暂停线程，使用resume()方法来恢复线程的执行。</p>
<p>不过这两个方法实际上也是被废除了。所以一般也并不这么用。</p>
<h2 id="suspend-方法与resume-方法"><a href="#suspend-方法与resume-方法" class="headerlink" title="suspend()方法与resume()方法"></a>suspend()方法与resume()方法</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>调用suspend()方法会离级停止该线程。但不会释放所持有的锁。</p>
<p>示例</p>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mythread.MyThread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.suspend();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        thread.resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：执行后会立即执行，然后在主线程sleep的2s内，thread会一直i++。然后在2s后停止，随后主线程sleep5s，即thread暂停5s，接下来线程继续运行。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="独占"><a href="#独占" class="headerlink" title="独占"></a>独占</h4><p>如果suspend()方法与resume()方法使用不当，极易造成公共同步对象被独占，其他线程无法访问公共同步对象的结果。</p>
<p>例如：线程A持有了Lock1锁，线程B在等待Lock1，但线程A被意外永久suspend了。那么线程B就陷入了死锁。</p>
<h4 id="数据不完整"><a href="#数据不完整" class="headerlink" title="数据不完整"></a>数据不完整</h4><p>在使用suspend()方法与resume()方法时也容易出现线程暂停，进而导致数据不完整的情况。</p>
<p>这种立即停止，不考虑线程的状态，一般都会面临该问题。比如赋值操作进行到一半，一部分变量被赋值了，另一部分没有被赋值。那取出的数据就会出现不统一的情况。</p>
<h2 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h2><p>yield()方法的作用是放弃当前的CPU资源，让其他任务去占用CPU执行时间，放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。</p>
<p>yield()做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。<br>但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<p>注意：该方法应该直接通过<code>Thread</code>静态调用，而不能通过this来调用。</p>
<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p>在操作系统中，线程可以划分优先级，优先级较高的线程得到CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务，其实就是让高优先级的线程获得更多的CPU时间片。</p>
<p>在jdk中使用3个常量来预置定义优先级的值。分别是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="优先级的继承特征"><a href="#优先级的继承特征" class="headerlink" title="优先级的继承特征"></a>优先级的继承特征</h2><p>在Java中，线程的优先级具有继承性，例如，A线程启动B线程，则B线程的优先级与A线程是一样的。</p>
<h2 id="优先级的规律性"><a href="#优先级的规律性" class="headerlink" title="优先级的规律性"></a>优先级的规律性</h2><p>高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部先执行完。</p>
<h2 id="优先级的随机性"><a href="#优先级的随机性" class="headerlink" title="优先级的随机性"></a>优先级的随机性</h2><p>优先级高的线程往往优先执行完，但这个结果不是绝对的，因为线程的优先级还具有“随机性”，即优先级较高的线程不一定每一次都先执行完。</p>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>Java中有两种线程：</p>
<ul>
<li>用户线程，也称非守护线程；</li>
<li>另一种是守护线程。</li>
</ul>
<p>守护线程是一种特殊的线程，当进程中不存在非守护线程了，则守护线程自动销毁。</p>
<p>典型的守护线程是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。</p>
<p>创建一个守护线程的方法是使用<code>thread1.setDaemon()</code>，调用这个方法的线程就是thread1的守护线程。</p>
<p>例如：在main方法中执行以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">"我离开thread对象也不再打印了，也就是停止了！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则main方法主线程即为<code>thread</code>的守护线程。</p>
]]></content>
      <categories>
        <category>Java多线程编程核心技术</category>
      </categories>
      <tags>
        <tag>Java多线程编程核心技术</tag>
        <tag>多线程技术基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程编程核心技术-3-线程间通信</title>
    <url>/2022/04/02/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-3-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait/notify机制"></a>wait/notify机制</h1><h2 id="不使用wait-notify机制实现线程间通信"><a href="#不使用wait-notify机制实现线程间通信" class="headerlink" title="不使用wait/notify机制实现线程间通信"></a>不使用wait/notify机制实现线程间通信</h2><p> 之前说过volatile可以实现不同线程的变量的可见性。所以不同线程间通信可以使用volatile变量来进行信息交换。</p>
<p>示例：</p>
<p>自定义List类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mylist;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">"tom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类A：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">import</span> mylist.MyList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyList list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(MyList list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                list.add();</span><br><span class="line">                System.out.println(<span class="string">"添加了"</span> + (i + <span class="number">1</span>) + <span class="string">"个元素"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类B：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">import</span> mylist.MyList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyList list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(MyList list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"==5了，线程b要退出了！"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> mylist.MyList;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadA;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadB;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyList service = <span class="keyword">new</span> MyList();</span><br><span class="line">        ThreadA a = <span class="keyword">new</span> ThreadA(service);</span><br><span class="line">        a.setName(<span class="string">"A"</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(service);</span><br><span class="line">        b.setName(<span class="string">"B"</span>);</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加了1个元素</span><br><span class="line">添加了2个元素</span><br><span class="line">添加了3个元素</span><br><span class="line">添加了4个元素</span><br><span class="line">&#x3D;&#x3D;5了，线程b要退出了!</span><br><span class="line">添加了5个元素</span><br><span class="line">java . lang.InterruptedException</span><br><span class="line">at extthread. ThreadB . run (ThreadB.java:20)</span><br><span class="line">添加了6个元素</span><br><span class="line">添加了7个元素</span><br><span class="line">添加了8个元素</span><br><span class="line">添加了9个元素</span><br></pre></td></tr></table></figure>
<h2 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h2><p>wait()方法是Object类的方法，它的作用是使当前执行wait()方法的线程等待，<strong>在wait()所在的代码行处暂停执行，并释放锁，直到接到通知或被中断为止</strong>。</p>
<p>在调用wait()之前，线程必须获得该对象的对象级别锁，<strong>即只能在同步方法或同步块中调用wait()方法</strong>。</p>
<p>通过通知机制使某个线程继续执行wait()方法后面的代码时，对线程的选择是按照执行wait()方法的顺序确定的，并需要重新获得锁。</p>
<p>如果调用wait()时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此不需要try-catch语句捕捉异常。</p>
<h3 id="wait-long-方法"><a href="#wait-long-方法" class="headerlink" title="wait(long)方法"></a>wait(long)方法</h3><p>wait（long）方法想要自动向下运行也要持有锁，如果没有锁，则一直在等待，直到持有锁为止。</p>
<h2 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify()方法"></a>notify()方法</h2><p><strong>notify()方法要在同步方法或同步块中调用</strong>，即在调用前，线程必须获得锁，如果调用notify()时没有持有适当的锁，则会抛出IllegalMonitorStateException。</p>
<p>该方法用来通知那些可能等待该锁的其他线程，如果有多个线程等待，则按照执行wait()方法的顺序对处于wait状态的线程发出一次通知（notify），并使该线程重新获取锁。</p>
<p>需要说明的是，执行notify()方法后，当前线程不会马上释放该锁，呈wait状态的线程也并不能马上获取该对象锁，要等到执行notify()方法的线程将程序执行完，也就是退出synchronized同步区域后，当前线程才会释放锁，而呈wait状态的线程才可以获取该对象锁。</p>
<p>当第一个获得了该对象锁的wait线程运行完毕后，它会释放该对象锁，此时如果没有再次使用notify语句，那么其他呈wait状态的线程因为没有得到通知，会继续处于wait状态。</p>
<p>总结：wait()方法使线程暂停运行，而notify()方法通知暂停的线程继续运行。</p>
<h2 id="notifyAll-方法"><a href="#notifyAll-方法" class="headerlink" title="notifyAll()方法"></a>notifyAll()方法</h2><p>notifyAll()方法会按照执行wait()方法的倒序依次对其他全部线程进行唤醒。</p>
<h2 id="wait-notify机制-1"><a href="#wait-notify机制-1" class="headerlink" title="wait/notify机制"></a>wait/notify机制</h2><p>拥有相同锁的线程才可以实现wait/notify机制，所以调用这两个方法必须持有对应对象的锁，即必须在同步代码块中。</p>
<p>示例：</p>
<p>wait类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"开始      wait time="</span> + </span><br><span class="line">                      System.currentTimeMillis());</span><br><span class="line">                lock.wait();</span><br><span class="line">                System.out.println(<span class="string">"结束      wait time="</span> + </span><br><span class="line">                      System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>notify类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始notify time="</span> + System.currentTimeMillis());</span><br><span class="line">            lock.notify();</span><br><span class="line">            System.out.println(<span class="string">"结束notify time="</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> extthread.MyThread1;</span><br><span class="line"><span class="keyword">import</span> extthread.MyThread2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">            MyThread1 t1 = <span class="keyword">new</span> MyThread1(lock);</span><br><span class="line">            t1.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">            MyThread2 t2 = <span class="keyword">new</span> MyThread2(lock);</span><br><span class="line">            t2.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始 wait time&#x3D;1405413930814</span><br><span class="line">开始notify time&#x3D;1405413933816</span><br><span class="line">结束notify time&#x3D;1405413933816</span><br><span class="line">结束wait time&#x3D;1405413933816</span><br></pre></td></tr></table></figure>
<h2 id="线程状态切换"><a href="#线程状态切换" class="headerlink" title="线程状态切换"></a>线程状态切换</h2><p><img src="\images\Java多线程编程核心技术\线程状态切换.jpg" alt="线程状态切换"></p>
<p>1）创建一个新的线程对象后，调用它的start()方法，系统会为此线程分配CPU资源，此时线程处于runnable（可运行）状态，这是一个准备运行的阶段。如果线程抢占到CPU资源，则此线程就处于running（运行）状态。</p>
<p>2）runnable状态和running状态可相互切换，因为有可能线程运行一段时间后，其他高优先级的线程抢占了CPU资源，这时此线程就从running状态变成runnable状态。</p>
<p>线程进入runnable状态大体分为如下4种情况。</p>
<ul>
<li><p>调用sleep()方法后经过的时间超过了指定的休眠时间；</p>
</li>
<li><p>线程成功获得了试图同步的监视器；</p>
</li>
<li><p>线程正在等待某个通知，其他线程发出了通知；</p>
</li>
<li><p>处于挂起状态的线程调用了resume恢复方法。</p>
</li>
</ul>
<p>3）blocked是阻塞的意思，例如，如果遇到了一个I/O操作，此时当前线程由runnable运行状态转成blocked阻塞状态，等待I/O操作的结果。这时操作系统会把宝贵的CPU时间片分配给其他线程，当I/O操作结束后，线程由blocked状态结束，进入runnable状态，线程会继续运行后面的任务。</p>
<p>出现阻塞的情况大体分为如下5种。</p>
<ul>
<li><p>线程调用sleep()方法，主动放弃占用的处理器资源。</p>
</li>
<li><p>线程调用了阻塞式I/O方法，在该方法返回前，该线程被阻塞。</p>
</li>
<li><p>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。</p>
</li>
<li><p>线程等待某个通知（notify）。</p>
</li>
<li><p>程序调用了suspend()方法将该线程挂起。此方法容易导致死锁，应尽量避免使用该方法。</p>
</li>
</ul>
<p>4）run()方法运行结束后进入销毁阶段，整个线程执行完毕。</p>
<h2 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h2><p>sleep与wait的不同在于，wait会释放对应的锁。而sleep并不会释放锁。</p>
<h2 id="interrupt-方法与wait-方法"><a href="#interrupt-方法与wait-方法" class="headerlink" title="interrupt()方法与wait()方法"></a>interrupt()方法与wait()方法</h2><p>注意：当线程调用wait()方法后，再对该线程对象执行interrupt()方法会出现Interrupted-Exception异常。</p>
<p>所以有以下几点：</p>
<ul>
<li>执行完notify()方法后，按照执行wait()方法的顺序唤醒其他线程。notify()所在的同步代码块执行完才会释放对象的锁，其他线程继续执行wait()之后的代码。</li>
<li>在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放。</li>
<li>在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放对象锁，等待被唤醒。</li>
</ul>
<h2 id="通过管道实现线程间通信"><a href="#通过管道实现线程间通信" class="headerlink" title="通过管道实现线程间通信"></a>通过管道实现线程间通信</h2><p>Java语言提供了各种各样的输入/输出流，使我们能够很方便地对数据进行操作，其中管道流（pipe stream）是一种特殊的流，用于在不同线程间直接传送数据。一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同线程间的通信，而无须借助于类似临时文件之类的东西。</p>
<p>Java JDK提供了4个类来使线程间可以进行通信，即PipedInputStream和PipedOutputStream、PipedReader和PipedWriter。</p>
<h3 id="通过管道进行线程间通信——字节流"><a href="#通过管道进行线程间通信——字节流" class="headerlink" title="通过管道进行线程间通信——字节流"></a>通过管道进行线程间通信——字节流</h3><p>下面通过字节流，即<code>PipedInputStream</code>和<code>PipedOutputStream</code>来进行通信。</p>
<p>例如：</p>
<p>写数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">(PipedOutputStream out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"write :"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">                String outData = <span class="string">""</span> + (i + <span class="number">1</span>);</span><br><span class="line">                out.write(outData.getBytes());</span><br><span class="line">                System.out.print(outData);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">(PipedInputStream input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"read  :"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> readLength = input.read(byteArray);</span><br><span class="line">            <span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</span><br><span class="line">                String newData = <span class="keyword">new</span> String(byteArray, <span class="number">0</span>, readLength);</span><br><span class="line">                System.out.print(newData);</span><br><span class="line">                readLength = input.read(byteArray);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            input.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义两个线程运行这两个程序，</p>
<p>执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> service.ReadData;</span><br><span class="line"><span class="keyword">import</span> service.WriteData;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadRead;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadWrite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WriteData writeData = <span class="keyword">new</span> WriteData();</span><br><span class="line">            ReadData readData = <span class="keyword">new</span> ReadData();</span><br><span class="line"></span><br><span class="line">            PipedInputStream inputStream = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">            PipedOutputStream outputStream = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// inputStream.connect(outputStream);</span></span><br><span class="line">            outputStream.connect(inputStream);</span><br><span class="line"></span><br><span class="line">            ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            input.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">两个自定义线程类代码如图<span class="number">3</span>-<span class="number">35</span>所示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">图<span class="number">3</span>-<span class="number">35</span>　两个自定义线程类代码</span><br><span class="line"></span><br><span class="line">类Run.java代码如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> service.ReadData;</span><br><span class="line"><span class="keyword">import</span> service.WriteData;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadRead;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadWrite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WriteData writeData = <span class="keyword">new</span> WriteData();</span><br><span class="line">            ReadData readData = <span class="keyword">new</span> ReadData();</span><br><span class="line"></span><br><span class="line">            PipedInputStream inputStream = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">            PipedOutputStream outputStream = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// inputStream.connect(outputStream);</span></span><br><span class="line">            outputStream.connect(inputStream);</span><br><span class="line"></span><br><span class="line">            ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</span><br><span class="line">            threadRead.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            ThreadWrite threadWrite = <span class="keyword">new</span> ThreadWrite(writeData, outputStream);</span><br><span class="line">            threadWrite.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码<code>inputStream.connect(outputStream)</code>或<code>outputStream.connect(inputStream)</code>的作用是使两个管道之间建立通信连接，这样才可以对数据进行输出与输入。</p>
<h3 id="通过管道进行线程间通信——字符流"><a href="#通过管道进行线程间通信——字符流" class="headerlink" title="通过管道进行线程间通信——字符流"></a>通过管道进行线程间通信——字符流</h3><p>同样的，可以使用<code>PipedReader</code>和<code>PipedWriter</code>。来实现线程间通信。</p>
<h1 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h1><p>在很多情况下，主线程创建并启动子线程，如果子线程要进行大量的耗时运算，主线程往往将早于子线程结束之前结束，这时如果主线程想等待子线程执行完成之后再结束，例如，当子线程处理一个数据，主线程要取得这个数据中的值时，就要用到join()方法了。方法join()的作用是等待线程对象销毁。</p>
<h2 id="jion-方法的使用"><a href="#jion-方法的使用" class="headerlink" title="jion()方法的使用"></a>jion()方法的使用</h2><p>如上所说，如果子线程的执行时间大于主线程，则主线程结束时，子线程仍然在运行。</p>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">private</span> String str = <span class="string">"string"</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">			sleep(<span class="number">10000</span>);</span><br><span class="line">            System.out.println(<span class="string">"sub thread end!"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.str = str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread1 thread = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">"main thread end!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main thread end!</span><br><span class="line">sub thread end!</span><br></pre></td></tr></table></figure>
<p>可以看出，在子线程结束之前，主线程就已经结束了。</p>
<p>而此时在主线程加入<code>join</code>方法，就会使主线程等待子线程执行完毕后再结束。</p>
<p>改进运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread1 thread = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">"main thread end!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub thread end</span><br><span class="line">main thread end!</span><br></pre></td></tr></table></figure>
<p>可以看出，主线程在等待子线程执行完毕过后才执行的。</p>
<h2 id="join-方法与interrupt-方法"><a href="#join-方法与interrupt-方法" class="headerlink" title="join()方法与interrupt()方法"></a>join()方法与interrupt()方法</h2><p>在使用join()方法的过程中，如果当前线程对象被中断，则当前线程出现异常。</p>
<h2 id="join（long）方法的使用"><a href="#join（long）方法的使用" class="headerlink" title="join（long）方法的使用"></a>join（long）方法的使用</h2><p>x.join（long）方法中的参数用于设定等待的时间，不管x线程是否执行完毕，时间到了并且重新获得了锁，则当前线程会继续向后运行。如果没有重新获得锁，则一直在尝试，直到获得锁为止。</p>
<p>例如：</p>
<p>在线程中暂停3s，而<code>join(2000)</code>。</p>
<p>则结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main thread end!</span><br><span class="line">sub thread end</span><br></pre></td></tr></table></figure>
<p>相当于主线程暂停了2s。</p>
<p>那使用join（2000）和使用sleep（2000）有什么区别呢？上面的示例中在运行效果上并没有区别，其实区别主要来自于这两个方法在同步的处理上。</p>
<h2 id="join-方法与sleep-方法的区别"><a href="#join-方法与sleep-方法的区别" class="headerlink" title="join()方法与sleep()方法的区别"></a>join()方法与sleep()方法的区别</h2><p>join（long）方法的功能在内部是使用wait（long）方法来进行实现的，所以join（long）方法具有释放锁的特点。</p>
<p>join（long）方法源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源代码中可以了解到，当执行wait（long）方法后当前线程的<strong>锁被释放</strong>，那么其他线程就可以调用此线程中的同步方法了。</p>
<p><strong>即执行join方法的线程，在执行join这段时间内，是不持有锁的。</strong></p>
<p>而Thread.sleep（long）方法却<strong>不释放锁</strong>。</p>
<p>另外需要注意一点，join()无参方法或join（time）有参方法一旦执行，说明源代码中的wait（time）已经被执行，也就证明锁被立即释放，仅仅在指定的join（time）时间后当前线程会继续向下运行。</p>
<h1 id="类ThreadLocal"><a href="#类ThreadLocal" class="headerlink" title="类ThreadLocal"></a>类ThreadLocal</h1><p>ThreadLocal又叫做线程局部变量，全称thread local variable，它的使用场合主要是为了解决多线程中因为数据并发产生不一致的问题。ThreadLocal为每一个线程都提供了变量的副本，使得每一个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享，这样的结果无非是耗费了内存，也大大减少了线程同步所带来的性能消耗，也减少了线程并发控制的复杂度。</p>
<h2 id="类ThreadLocal的原理"><a href="#类ThreadLocal的原理" class="headerlink" title="类ThreadLocal的原理"></a>类ThreadLocal的原理</h2><p>类ThreadLocal的主要作用是将数据放入当前线程对象中的Map中，这个Map是Thread类的实例变量。类ThreadLocal自己不管理、不存储任何数据，它只是数据和Map之间的桥梁，用于将数据放入Map中，执行流程如下：数据→ThreadLocal→currentThread()→Map。</p>
<p>执行后每个线程中的Map存有自己的数据，Map中的key存储的是ThreadLocal对象，value就是存储的值。每个Thread中的Map值只对当前线程可见，其他线程不可以访问当前线程对象中Map的值。当前线程销毁，Map随之销毁，Map中的数据如果没有被引用、没有被使用，则随时GC收回。</p>
<p><img src="\images\Java多线程编程核心技术\ThreadLocal.jpg" alt="ThreadLocal"></p>
<h2 id="类ThreadLocal的使用"><a href="#类ThreadLocal的使用" class="headerlink" title="类ThreadLocal的使用"></a>类ThreadLocal的使用</h2><p>一般是在公共位置定义一个static的ThreadLocal对象，然后在线程中直接存取该变量即可。对于不同的线程，ThreadLocal内部进行处理，将其存储到map中。</p>
<p>如：</p>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tag = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread1 thread = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        MyThread1 thread2 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread.setStr(<span class="string">"thread"</span>);</span><br><span class="line">        thread2.setStr(<span class="string">"thread2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"main thread end!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">private</span> String str = <span class="string">"string"</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">			sleep(<span class="number">3000</span>);</span><br><span class="line">			System.out.println(<span class="string">"sub thread end"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		Main.tag.set(str);</span><br><span class="line">		System.out.println(Main.tag.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread</span><br><span class="line">thread2</span><br><span class="line">main thread end!</span><br><span class="line">sub thread end</span><br><span class="line">sub thread end</span><br></pre></td></tr></table></figure>
<h2 id="重写类ThreadLocal解决初始化问题"><a href="#重写类ThreadLocal解决初始化问题" class="headerlink" title="重写类ThreadLocal解决初始化问题"></a>重写类ThreadLocal解决初始化问题</h2><p>ThreadLocal如果没有放置值，则get默认返回null。要想自定义初值，可以继承ThreadLocal并重写initialValue。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocalThread</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> (T) <span class="string">"init value"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则此时，在未初始化之前get，返回的将是”init value”。</p>
<h1 id="类InheritableThreadLocal的使用"><a href="#类InheritableThreadLocal的使用" class="headerlink" title="类InheritableThreadLocal的使用"></a>类InheritableThreadLocal的使用</h1><p>使用类InheritableThreadLocal可使子线程继承父线程的值。</p>
<h2 id="类ThreadLocal的问题"><a href="#类ThreadLocal的问题" class="headerlink" title="类ThreadLocal的问题"></a>类ThreadLocal的问题</h2><p>类ThreadLocal无法实现对线程的ThreadLocal值继承。</p>
<h2 id="类InheritableThreadLocal"><a href="#类InheritableThreadLocal" class="headerlink" title="类InheritableThreadLocal"></a>类InheritableThreadLocal</h2><p>使用InheritableThreadLocal类可以让子线程从父线程继承值。</p>
<p>例如：</p>
<p>工具共享类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InheritableThreadLocal tl = <span class="keyword">new</span> </span><br><span class="line">                  InheritableThreadLocal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tools.Tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"在ThreadA线程中取值="</span> + Tools.tl.get());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> extthread.ThreadA;</span><br><span class="line"><span class="keyword">import</span> tools.Tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Tools.tl.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Tools.tl.set(<span class="string">"此值是main线程放入的！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"       在Main线程中取值="</span> + Tools.tl.get());</span><br><span class="line">                       Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            ThreadA a = <span class="keyword">new</span> ThreadA();</span><br><span class="line">            a.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">       在Main线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br><span class="line">在ThreadA线程中取值&#x3D;此值是main线程放入的！</span><br></pre></td></tr></table></figure>
<p>可以看出，子ThreadA线程获取的值是从父线程main继承的。</p>
<h2 id="InheritableThreadLocal原理"><a href="#InheritableThreadLocal原理" class="headerlink" title="InheritableThreadLocal原理"></a>InheritableThreadLocal原理</h2><p>InheritableThreadLocal原理还是使用一个map来存储数据，但具体实现时，并不再引用自身作为map的key。而是直接使用父线程作为key。所以在读取的时候，始终能够保持父子线程读取到同一个对象。</p>
<h2 id="重写childValue-方法实现对继承的值加工"><a href="#重写childValue-方法实现对继承的值加工" class="headerlink" title="重写childValue()方法实现对继承的值加工"></a>重写childValue()方法实现对继承的值加工</h2><p>InheritableThreadLocal不光可以直接覆盖原来父线程的值，还可以获取到父线程的值后，进行特定格式的加工。其具体是重写<code>childValue()</code>方法。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">childValue</span><span class="params">(Object parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue + <span class="string">" 我在子线程加的~!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在Main线程中取值&#x3D;1407987668302</span><br><span class="line">在ThreadA线程中取值&#x3D;1407987668302我在子线程加的~!</span><br><span class="line">在ThreadA线程中取值&#x3D;1407987668302我在子线程加的~!</span><br><span class="line">在ThreadA线程中取值&#x3D;1407987668302我在子线程加的~!</span><br><span class="line">在ThreadA线程中取值&#x3D;1407987668302我在子线程加的~!</span><br><span class="line">在Threada线程中取值&#x3D;1407987668302我在子线程加的~!</span><br><span class="line">在ThreadA线程中取值&#x3D;1407987668302我在子线程加的~!</span><br><span class="line">在ThreadA线程中取值&#x3D;1407987668302我在子线程加的~!</span><br><span class="line">在ThreadA线程中取值&#x3D;1407987668302我在子线程加的~!</span><br><span class="line">在ThreadA线程中取值&#x3D;1407987668302我在子线程加的~!</span><br><span class="line">在ThreadA线程中取值&#x3D;1407987668302我在子线程加的~!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java多线程编程核心技术</category>
      </categories>
      <tags>
        <tag>Java多线程编程核心技术</tag>
        <tag>线程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数组</title>
    <url>/2018/10/26/JavaScript%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="JavaScript数组"><a href="#JavaScript数组" class="headerlink" title="JavaScript数组"></a>JavaScript数组</h1><p><strong>复习一下数组，发现有些方法都忘记了</strong></p>
<h2 id="定义数组的方式"><a href="#定义数组的方式" class="headerlink" title="定义数组的方式"></a>定义数组的方式</h2><ol>
<li><p>采用直接量创建</p>
<p> var MyArray = [];//创建空数组</p>
<p> var MyArray = [1,2,3];//创建数字型数组</p>
<p> var MyArray = [“A”,”B”,”C”];//创建字符型数组</p>
<p> var MyArray = [{id:1},{id:2},{id:3}];//创建对象型数组</p>
</li>
<li><p>采用构造函数创建</p>
<p> var MyArray = new Array();<br> MyArray[0] = 0;<br> MyArray[1] = “A”;</p>
<p> var MyArray = new Array(5);</p>
<p> var MyArray = new Array(5,4,3,2,1);</p>
<a id="more"></a>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2></li>
</ol>
<ul>
<li>constructor </li>
</ul>
<p>描述：返回对创建此对象的数组函数的<strong>引用</strong>。</p>
<p>应用1：用于判断元素类型</p>
<p>exp：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test.constructor==<span class="built_in">Array</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"This is an Array"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (test.constructor==<span class="built_in">Boolean</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"This is a Boolean"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (test.constructor==<span class="built_in">Date</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"This is a Date"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (test.constructor==<span class="built_in">String</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"This is a String"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>This is an Array
</code></pre><p>应用2：用于获取构造函数的原形</p>
<p>exp:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">employee</span>(<span class="params">name,job,born</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">this</span>.born=born;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bill=<span class="keyword">new</span> employee(<span class="string">"Bill Gates"</span>,<span class="string">"Engineer"</span>,<span class="number">1985</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(bill.constructor);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">employee</span>(<span class="params">name, job, born</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.job = job; </span><br><span class="line">    <span class="keyword">this</span>.born = born;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>length</li>
</ul>
<p>描述：设置或返回数组中元素的数目</p>
<p>应用：设置或返回数组中元素的数目</p>
<p>exp：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"Andy"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Wendy"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"Original length: "</span> + arr.length)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">5</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"New length: "</span> + arr.length)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Original length: 3
New length: 5
</code></pre><ul>
<li>prototype</li>
</ul>
<p>描述：使您有能力向对象添加属性和方法</p>
<p>应用：向对象添加属性和方法</p>
<p>exp:<br>    <script type="text/javascript"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个employee对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">employee</span>(<span class="params">name,job,born</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.job=job;</span><br><span class="line"><span class="keyword">this</span>.born=born;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个employee</span></span><br><span class="line"><span class="keyword">var</span> bill=<span class="keyword">new</span> employee(<span class="string">"Bill Gates"</span>,<span class="string">"Engineer"</span>,<span class="number">1985</span>);</span><br><span class="line"></span><br><span class="line">employee.prototype.salary=<span class="literal">null</span>;</span><br><span class="line">bill.salary=<span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(bill.salary);</span><br></pre></td></tr></table></figure>
<p><strong>值得注意的是：prototyp是面向对象编程的重要属性。在W3C的解释中，可以知道函数也是一个对向（具体函数与对象的关系后续再详细讨论），每个函数对象都具有一个子对象prototype。Prototype 表示了该函数的原型，prototype表示了一个类的属性的集合。当通过new来生成一个类的对象时，prototype对象的属性就会成为实例化对象的属性。</strong></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>contact()</li>
</ul>
<p>描述：连接两个或更多的数组，并返回结果</p>
<p>应用：连接n个数组</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="string">"James"</span></span><br><span class="line">arr2[<span class="number">1</span>] = <span class="string">"Adrew"</span></span><br><span class="line">arr2[<span class="number">2</span>] = <span class="string">"Martin"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>)</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="string">"William"</span></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="string">"Franklin"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行连接操作</span></span><br><span class="line"><span class="built_in">document</span>.write(arr.concat(arr2,arr3))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas,James,Adrew,Martin,William,Franklin
</code></pre><ul>
<li>join()</li>
</ul>
<p>描述：把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔</p>
<p>应用：创建一个数组，然后把它的所有元素放入一个字符串</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr.join(<span class="string">"."</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George.John.Thomas
</code></pre><p><strong>注意：join(separator)中separator为间隔符，若为空择默认为逗号。</strong></p>
<ul>
<li>pop()</li>
</ul>
<p>描述：pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且<strong>返回它删除的元素的值</strong>。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值</p>
<p>应用：创建一个数组，然后删除数组的最后一个元素</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr.pop())</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas
Thomas
George,John
</code></pre><ul>
<li>push()</li>
</ul>
<p>描述：push() 方法可把它的参数顺序添加到 arrayObject 的尾部。</p>
<p>它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。</p>
<pre><code>arrayObject.push(newelement1,newelement2,....,newelementX)

newelement1（必选）- 要添加的第一个元素
newelement2（可选）- 要添加的第二个元素
newelementX（可选）- 要添加的第X个元素
</code></pre><p>应用：创建一个数组，并通过添加一个元素来改变其长度</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.push(<span class="string">"James"</span>) + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas
4
George,John,Thomas,James
</code></pre><ul>
<li>reverse()</li>
</ul>
<p>描述：用于颠倒数组中元素的顺序（该方法会改变原来的数组，而不会创建新的数组）</p>
<p>应用：创建一个数组，然后颠倒其元素的顺序</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.reverse())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas
Thomas,John,George
</code></pre><ul>
<li>shift()</li>
</ul>
<p>描述:用于把数组的第一个元素从其中删除，并返回第一个元素的值(如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject)</p>
<p>应用：创建一个数组，并删除数组的第一个元素。请注意，这也将改变数组的长度</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.shift() + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas
George
John,Thomas
</code></pre><ul>
<li>slice()</li>
</ul>
<p>描述：slice() 方法可从已有的数组中返回选定的元素</p>
<p><strong>arrayObject.slice(start,end)</strong></p>
<p>start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</p>
<p>end: 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p>
<p><strong>请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。</strong></p>
<p>应用：创建一个新数组，然后显示从其中选取的元素</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取数组的2-4位（注意数组下标从0开始）</span></span><br><span class="line"><span class="built_in">document</span>.write(arr.slice(<span class="number">2</span>,<span class="number">4</span>) + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas,James,Adrew,Martin
Thomas,James
George,John,Thomas,James,Adrew,Martin
</code></pre><ul>
<li>sort()</li>
</ul>
<p>描述：用于对数组的元素进行排序</p>
<p><strong>arrayObject.sort(sortby)</strong></p>
<p>sortby    可选。规定排序顺序。<strong>必须是函数</strong>。</p>
<p>返回值为对数组的引用。<strong>请注意，数组在原数组上进行排序，不生成副本</strong></p>
<p>参数说明：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>
<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p>
<p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。</p>
<p>应用：创建一个数组，并按字母顺序进行排序</p>
<p>exp1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.sort())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas,James,Adrew,Martin
Adrew,George,James,John,Martin,Thomas
</code></pre><p>exp2:实现对多位数的排序（利用排序函数作为参数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumber</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"10"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"5"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"40"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"25"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"1000"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.sort(sortNumber))</span><br></pre></td></tr></table></figure>
<p><strong>如果不写该函数作为参数，只会对多位数的第一位以ASCII码进行排序，无法实现多位数排序</strong></p>
<ul>
<li>splice()</li>
</ul>
<p>描述：splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目</p>
<p><strong>该方法会改变原始数组</strong></p>
<p>arrayObject.splice(index,howmany,item1,…..,itemX)</p>
<p>index    必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。<br>howmany    必需。要删除的项目数量。如果设置为 0，则不会删除项目。<br>item1, …, itemX    可选。向数组添加的新项目。</p>
<p><strong>请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。</strong></p>
<p>应用：</p>
<p>exp1:创建一个新数组，并向其添加/删除一个元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="comment">//从第二个位置修改，"howmany"参数为0择不删除，第三个参数为要添加的元素</span></span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"William"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas,James,Adrew,Martin
George,John,William,Thomas,James,Adrew,Martin
</code></pre><p>exp2：删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"William"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas,James,Adrew,Martin
George,John,William,James,Adrew,Martin
</code></pre><p>exp3:删除从 index 2 (“Thomas”) 开始的三个元素，并添加一个新元素 (“William”) 来替代被删除的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">3</span>,<span class="string">"William"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr)</span><br></pre></td></tr></table></figure>
<p>输出：<br>    George,John,Thomas,James,Adrew,Martin<br>    George,John,William,Martin</p>
<ul>
<li>unshift</li>
</ul>
<p>描述：可向数组的开头添加一个或更多元素，并<strong>返回新的长度</strong></p>
<p><strong>arrayObject.unshift(newelement1,newelement2,….,newelementX)</strong></p>
<p>newelement1    必需。向数组添加的第一个元素。</p>
<p>newelement2    可选。向数组添加的第二个元素。</p>
<p>newelementX    可选。可添加若干个元素。</p>
<p>说明：unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。</p>
<p><strong>请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。</strong></p>
<p><strong>请注意，unshift() 方法无法在 Internet Explorer 中正确地工作！</strong></p>
<p>应用：创建一个数组，并把一个元素添加到数组的开头，并返回数组的新长度</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.unshift(<span class="string">"William"</span>) + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>George,John,Thomas
4
William,George,John,Thomas
</code></pre><p><strong>一些不常用的方法</strong></p>
<p>toSource()    返回该对象的源代码。</p>
<p>toString()    把数组转换为字符串，并返回结果。</p>
<p>toLocaleString()   把数组转换为本地数组，并返回结果。</p>
<p>valueOf()      返回数组对象的原始值</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>以上内容均来自<a href="http://www.w3school.com.cn/jsref/jsref_obj_array.asp" target="_blank" rel="noopener">W3Cschool</a>，我是为了加深印象，巩固一下知识点。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL与Java中的日期API</title>
    <url>/2022/03/25/MySQL%E4%B8%8EJava%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9FAPI/</url>
    <content><![CDATA[<h1 id="相关问题："><a href="#相关问题：" class="headerlink" title="相关问题："></a>相关问题：</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>Java系统中采用了localDateTime类型的数据，MySQL数据库中采用了DateTime类型。但是存储之后再取出来发现数据不一致，即秒之后的毫秒部分变成了000000。</p>
<h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>MySQL的DateTime没有设置长度，则默认为不包含小数部分。即只存储’YYYY-MM-DD hh:mm:ss’，小数部分是不会被存储的，小数部分会被丢弃。但原始的localDateTime是包含小数部分的，即到微秒部分：10^-6s。所以存储后取出来的数据就损失了小于秒部分，所以小数点后都为0，与原来的不相等。</p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><ol>
<li>只对比秒之前的部分，即无视损失的部分。</li>
<li>将MySQL数据库的DateTime的长度设置为6（最长），则不会造成损失。</li>
</ol>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>MySQL有5种日期类型：</p>
<ul>
<li>DATE</li>
<li>TIME</li>
<li>DATETIME</li>
<li>TIMESTAMP</li>
<li>YEAR</li>
</ul>
<p>但是在介绍具体的类型之前，需要先看MySQL官方的几条关于日期的提醒：</p>
<ul>
<li><p>MySQL会尝试各种格式来解析传入的值，但最好是按照标准的格式来进行传递，否则可能会有不可预知的行为出现。</p>
<p>其具体格式简单介绍在后文附加。</p>
</li>
<li><p>虽然MySQL会尝试各种格式，但是date部分总是应该按照year-month-day的顺序来传递。</p>
</li>
<li><p>并不推荐用两个字表示的年份，起具有歧义，但MySQL仍然是接受的。其解析行为如下：</p>
<ul>
<li>如果是70-99则解析为1970-1999</li>
<li>如果是00-69则解析为2000-2069</li>
</ul>
</li>
<li><p>默认情况下，当MySQL遇到一个超出date或者time类型范围的值时，会默认将其转换为该类型的”0“值。</p>
</li>
<li><p>MySQL允许存储“0”值<code>0000-00-00</code>作为填充值，有时这比null更方便。可以通过开启<code>NO_ZERO_IN_DATE</code>来禁止零值。</p>
</li>
</ul>
<p>下面的表展示了各种类型的零值：</p>
<table summary="Format of the zero value for temporal data types."><colgroup><col style="width: 30%"><col style="width: 40%"></colgroup><thead><tr><br>          <th>Data Type</th><br>          <th><span class="quote">“<span class="quote">Zero</span>”</span> Value</th><br>        </tr></thead><tbody><tr><br>          <td><a class="link" href="datetime.html" title="11.2.2&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a></td><br>          <td><code class="literal">‘0000-00-00’</code></td><br>        </tr><tr><br>          <td><a class="link" href="time.html" title="11.2.3&nbsp;The TIME Type"><code class="literal">TIME</code></a></td><br>          <td><code class="literal">‘00:00:00’</code></td><br>        </tr><tr><br>          <td><a class="link" href="datetime.html" title="11.2.2&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a></td><br>          <td><code class="literal">‘0000-00-00 00:00:00’</code></td><br>        </tr><tr><br>          <td><a class="link" href="datetime.html" title="11.2.2&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a></td><br>          <td><code class="literal">‘0000-00-00 00:00:00’</code></td><br>        </tr><tr><br>          <td><a class="link" href="year.html" title="11.2.4&nbsp;The YEAR Type"><code class="literal">YEAR</code></a></td><br>          <td><code class="literal">0000</code></td><br></tr></tbody></table>

<h2 id="DATE-DATETIME-TIMESTAMP"><a href="#DATE-DATETIME-TIMESTAMP" class="headerlink" title="DATE, DATETIME,  TIMESTAMP"></a>DATE, DATETIME,  TIMESTAMP</h2><p>DATE类型用来存储不含时间的日期值。MySQL以’YYYY-MM-DD’格式检索和显示DATE值。支持的范围是’1000-01-01’到’9999-12-31’。</p>
<p>DATETIME类型用来存储包含时间的日期值。MySQL以’YYYY-MM-DD hh:mm:ss’的格式检索和显示DATETIME值。支持的范围为’1000-01-01 00:00:00”到“9999-12-31 23:59:59’。</p>
<p>TIMESTAMP也用于存储包含时间的日期值。TIMESTAMP的范围是’1970-01-01 00:00:01’ UTC到’2038-01-19 03:14:07’ UTC。</p>
<p><strong>DATETIME或TIMESTAMP值可以包含尾随的小数秒部分，精度最高可达微秒(6位)。</strong></p>
<p style="font-size: 30px; font-weight=bold">（注意默认是没有小数部分，需要将长度改为6才有所有的小数部分）</p>

<p>而DATETIME包含小数的范围为：’1000-01-01 00:00:00.000000’<code>to</code>‘9999-12-31 23:59:59.999999’</p>
<p>TIMESTAMP包含小数的范围为： <code>&#39;1970-01-01 00:00:01.000000&#39;</code> to <code>&#39;2038-01-19 03:14:07.999999&#39;</code></p>
<p>MySQL将TIMESTAMP值从当前时区转换为UTC来存储，然后从UTC转换回当前时区以进行检索。(这不会发生在其他类型，如DATETIME。)</p>
<p>默认情况下，每个连接的当前时区都是服务器的时间。</p>
<p>时区可以在每个连接的基础上设置（通过<code>time_zone=xxx</code>）。只要时区设置保持不变，就会得到存储的相同值。如果存储了一个TIMESTAMP值，然后更改时区并检索该值，则检索到的值与存储的值不同。这是因为在两个方向上的转换没有使用相同的时区。</p>
<p>无效值得处理：</p>
<ul>
<li>非严格模式下，无效的DATE、DATETIME或TIMESTAMP值将被转换为适当类型的“零”值，例如<code>10:45:15</code>会被转化为<code>0000-00-00</code>，因为’45’不是一个合法的月份。</li>
<li>严格模式下，不仅仅只限制月份在1-12之间、天在1-31之间，而是会限制大月小月的区别，如’4-32’就不合法，因为4越没有31号。</li>
</ul>
<p>（这里的严格模式是指启用<code>STRICT_TRANS_TABLES</code>或<code>STRICT_ALL_TABLES</code>中的一个或两个模式。）</p>
<h2 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h2><p>MySQL以’hh:mm:ss’的格式检索和显示时间值。其范围从’-838:59:59’ 到’838:59:59’。</p>
<p>小时的部分可能是如此之大,因为可以使用时间类型不仅代表一个时间点(必须小于24小时),也可以代表运行时间或两个事件之间的时间间隔(可能是远远大于24小时,甚至负)。</p>
<p>TIME也可以包含小数部分来表示更小的时间单位，最小可以到达小数点后6位，即微秒。此时其范围为：<code>&#39;-838:59:59.000000&#39;</code> to <code>&#39;838:59:59.000000&#39;</code>。</p>
<p>对于简写，其规则如下：</p>
<ul>
<li>如果包含冒号，如’11:12’，则按从小时开始解析，即’11:12’被解析为’11:12:00’。</li>
<li>如果不含冒号，如’1112’，则按从秒开始解析，即’1112’被解析为’00:11:12’，’12’被解析为’00:00:12’。</li>
</ul>
<p>注意：TIME的零值’00:00:00’本身也是一个合法的TIME值，所以如果数据库里存储的是’00:00:00’，则并不能识别其到底是零值还是正确的值。</p>
<h2 id="YEAR"><a href="#YEAR" class="headerlink" title="YEAR"></a>YEAR</h2><p>YEAR类型是一种1字节类型，用于表示年份值。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>从MySQL 8.0.19开始，带有显式显示宽度的YEAR(4)数据类型已经被弃用，MySQL在未来版本中将会将其移除。直接使用YEAR而不使用显示宽度，其具有相同的含义。</p>
<p>MySQL 8.0不再支持2位YEAR(2)数据类型。</p>
</blockquote>
<p>MySQL以YYYY格式显示YEAR值，取值范围为1901 ~ 2155和0000。</p>
<p>YEAR字段接受以下格式的值：</p>
<ul>
<li>四个数字的字符串，范围在’1901’到’2155’之间。</li>
<li>四个数字的数字类型，范围在1901-2155之间。</li>
<li>两个数字的字符串，与前面DATE一样，范围在’0’-‘99’之间，’0’-‘69’表示2000-1069年。’70’-‘99’表示1970到1999年。</li>
<li>两个数字的数字类型，遇上面一样，只是传递的是数字。</li>
<li>作为返回在YEAR上下文中可接受的值的函数的结果，例如NOW()。</li>
</ul>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>Java的日期API可以看另一篇专门介绍的文章。<a href="https://www.mw530.cn/2022/02/16/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-6-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/" target="_blank" rel="noopener">java核心技术-II-6-日期和时间API</a></p>
<p>只能说Java的日期API设计经过了这么多轮的迭代，比较混乱，要想完全掌握，还确实需要时间。</p>
]]></content>
      <categories>
        <category>日期API</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
        <tag>日期API</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程编程核心技术-2-对象及变量的并发访问</title>
    <url>/2022/03/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-2-%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>在上一篇文章<a href="https://www.mw530.cn/2022/03/29/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">Java多线程编程核心技术-1-多线程技术基础</a>中，提到了共享变量造成的非线程安全问题。</p>
<p>本文就是为了解决非线程安全的相关问题。</p>
<h1 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h1><p>关键字synchronized可用来保障原子性、可见性和有序性。</p>
<p>但是在学习synchronized之前，我们必须明确一点：</p>
<p><strong>synchronized锁住的是对象。即使是synchronized方法。</strong></p>
<h2 id="线程安全问题和解决方案"><a href="#线程安全问题和解决方案" class="headerlink" title="线程安全问题和解决方案"></a>线程安全问题和解决方案</h2><p>就像前一文中提到的，只有多线程共享的变量才会面临线程安全问题。</p>
<p>即定义在线程类中并且被多个实例化为多个线程。</p>
<p>而方法体中的局部变量，无论如何都不会被多线程共享，因此无论如何都不会出现线程安全问题。</p>
<h3 id="synchronized同步方法的使用"><a href="#synchronized同步方法的使用" class="headerlink" title="synchronized同步方法的使用"></a>synchronized同步方法的使用</h3><p>对于共享的变量，在对其进行操作的方法上，加上synchronized关键字，即将其成为同步方法。也就是说所有线程在访问该方法时，必须排队进行访问，而不能同时访问。</p>
<p>（注意这里的例子并不合理，一般都会实现业务和线程解耦。这里不再拘束于这一点。）</p>
<p>例如：设计一个让每个线程使共享变量i增加的程序，每个线程在增加完后将其置0，然后再递增。</p>
<p>线程类1(不加同步)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">while</span>(i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">       		i++;</span><br><span class="line">       		System.out.println(Thread.currentThread().getName() + <span class="string">"update! "</span> + <span class="string">"i="</span> + i);</span><br><span class="line">       	&#125;</span><br><span class="line">       	i = <span class="number">0</span>;</span><br><span class="line">       	System.out.println(<span class="string">"thread: "</span>+Thread.currentThread().getName()+<span class="string">"reset i= "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread1 thread = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-1update! i&#x3D;2</span><br><span class="line">Thread-3update! i&#x3D;3</span><br><span class="line">Thread-3update! i&#x3D;5</span><br><span class="line">Thread-2update! i&#x3D;2</span><br><span class="line">thread: Thread-3reset i&#x3D; 0</span><br><span class="line">Thread-1update! i&#x3D;4</span><br><span class="line">Thread-2update! i&#x3D;1</span><br><span class="line">Thread-2update! i&#x3D;3</span><br><span class="line">Thread-2update! i&#x3D;4</span><br><span class="line">Thread-2update! i&#x3D;5</span><br><span class="line">thread: Thread-2reset i&#x3D; 0</span><br><span class="line">Thread-1update! i&#x3D;2</span><br><span class="line">Thread-1update! i&#x3D;1</span><br><span class="line">Thread-1update! i&#x3D;2</span><br><span class="line">Thread-1update! i&#x3D;3</span><br><span class="line">Thread-1update! i&#x3D;4</span><br><span class="line">Thread-1update! i&#x3D;5</span><br><span class="line">thread: Thread-1reset i&#x3D; 0</span><br></pre></td></tr></table></figure>
<p>可以看到结果是混乱的，因为并没有同步，此时我们为run方法加上同步标志：</p>
<p>线程类2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">while</span>(i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">       		i++;</span><br><span class="line">       		System.out.println(Thread.currentThread().getName() + <span class="string">"update! "</span> + <span class="string">"i="</span> + i);</span><br><span class="line">       	&#125;</span><br><span class="line">       	i = <span class="number">0</span>;</span><br><span class="line">       	System.out.println(<span class="string">"thread: "</span>+Thread.currentThread().getName()+<span class="string">"reset i= "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-1update! i&#x3D;1</span><br><span class="line">Thread-1update! i&#x3D;2</span><br><span class="line">Thread-1update! i&#x3D;3</span><br><span class="line">Thread-1update! i&#x3D;4</span><br><span class="line">Thread-1update! i&#x3D;5</span><br><span class="line">thread: Thread-1reset i&#x3D; 0</span><br><span class="line">Thread-3update! i&#x3D;1</span><br><span class="line">Thread-3update! i&#x3D;2</span><br><span class="line">Thread-3update! i&#x3D;3</span><br><span class="line">Thread-3update! i&#x3D;4</span><br><span class="line">Thread-3update! i&#x3D;5</span><br><span class="line">thread: Thread-3reset i&#x3D; 0</span><br><span class="line">Thread-2update! i&#x3D;1</span><br><span class="line">Thread-2update! i&#x3D;2</span><br><span class="line">Thread-2update! i&#x3D;3</span><br><span class="line">Thread-2update! i&#x3D;4</span><br><span class="line">Thread-2update! i&#x3D;5</span><br><span class="line">thread: Thread-2reset i&#x3D; 0</span><br></pre></td></tr></table></figure>
<p>可以看到结果是按照每个线程自己的顺序来进行的，每个线程都没有中断。</p>
<h2 id="同步synchronized在字节码指令中的原理"><a href="#同步synchronized在字节码指令中的原理" class="headerlink" title="同步synchronized在字节码指令中的原理"></a>同步synchronized在字节码指令中的原理</h2><h3 id="synchronized同步方法-1"><a href="#synchronized同步方法-1" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h3><p>在方法中使用<code>synchronized</code>关键字实现同步的原因是使用了flag标记<code>ACC_SYNCHRONIZED</code>，当调用方法时，调用指令会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否设置，如果设置了，执行线程先持有同步锁，然后执行方法，最后在方法完成时释放锁。</p>
<h3 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h3><p>如果使用synchronized代码块，则使用monitorenter和monitorexit指令进行同步处理</p>
<h2 id="多个对象多个锁"><a href="#多个对象多个锁" class="headerlink" title="多个对象多个锁"></a>多个对象多个锁</h2><p>就像我们之前说的，synchronized锁住的是对象。那么如果线程对象不同，即变量不共享了，那么锁也就不一样了。</p>
<p>例如：</p>
<p>线程类：线程类2</p>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread1 thread = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        MyThread1 thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        MyThread1 thread2 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0update! i&#x3D;1</span><br><span class="line">Thread-2update! i&#x3D;1</span><br><span class="line">Thread-2update! i&#x3D;2</span><br><span class="line">Thread-1update! i&#x3D;1</span><br><span class="line">Thread-2update! i&#x3D;3</span><br><span class="line">Thread-0update! i&#x3D;2</span><br><span class="line">Thread-2update! i&#x3D;4</span><br><span class="line">Thread-1update! i&#x3D;2</span><br><span class="line">Thread-2update! i&#x3D;5</span><br><span class="line">Thread-0update! i&#x3D;3</span><br><span class="line">thread: Thread-2reset i&#x3D; 0</span><br><span class="line">Thread-1update! i&#x3D;3</span><br><span class="line">Thread-0update! i&#x3D;4</span><br><span class="line">Thread-0update! i&#x3D;5</span><br><span class="line">thread: Thread-0reset i&#x3D; 0</span><br><span class="line">Thread-1update! i&#x3D;4</span><br><span class="line">Thread-1update! i&#x3D;5</span><br><span class="line">thread: Thread-1reset i&#x3D; 0</span><br></pre></td></tr></table></figure>
<p>可以看到线程是异步运行的，但是由于变量不共享，所以并不会发生混乱，最终结果还是正确的。</p>
<p>即：</p>
<p><strong>不共享的变量具有同锁，即使是相同的类实例化的。</strong></p>
<h2 id="静态同步synchronized方法"><a href="#静态同步synchronized方法" class="headerlink" title="静态同步synchronized方法"></a>静态同步synchronized方法</h2><p>关键字synchronized还可以应用在static静态方法上，如果这样写，那是对当前的*.java文件对应的Class类对象进行持锁，Class类的对象是单例的，更具体地说，在静态static方法上使用synchronized关键字声明同步方法时，使用当前静态方法所在类对应Class类的单例对象作为锁。</p>
<p>例如：</p>
<p>服务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名称为："</span> + Thread.currentThread().getName()</span><br><span class="line">                   + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printA"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程名称为："</span> + Thread.currentThread().getName()</span><br><span class="line">                   + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printA"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名称为："</span> + Thread.currentThread().getName()</span><br><span class="line">                   + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printB"</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程名称为："</span> + Thread.currentThread().getName()</span><br><span class="line">                   + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类A：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> service.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Service.printA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类B：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> service.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Service.printB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> service.Service;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadA;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadA a = <span class="keyword">new</span> ThreadA();</span><br><span class="line">        a.setName(<span class="string">"A"</span>);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        ThreadB b = <span class="keyword">new</span> ThreadB();</span><br><span class="line">        b.setName(<span class="string">"B"</span>);</span><br><span class="line">        b.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程名称为:A在1403596294939进入printA</span><br><span class="line">线程名称为:A在1403596297939离开printA</span><br><span class="line">线程名称为:B在1403596297939进入printB</span><br><span class="line">线程名称为:B在1403596297939离开printB</span><br></pre></td></tr></table></figure>
<p>虽然该程序运行结果和将synchronized关键字加到非static方法上的效果是一样的——同步，但两者还是有本质上的不同，synchronized关键字加到static静态方法上的方式是将Class类对象作为锁，而synchronized关键字加到非static静态方法上的方式是将方法所在类的对象作为锁。</p>
<h2 id="synchronized用法的几条基本原则（重要）"><a href="#synchronized用法的几条基本原则（重要）" class="headerlink" title="synchronized用法的几条基本原则（重要）"></a>synchronized用法的几条基本原则（重要）</h2><p>这里有几个显而易见的解论：</p>
<ol>
<li>在Java中只有“将对象作为锁”这种说法，并没有“锁方法”这种说法。</li>
<li>在Java语言中，“锁”就是“对象”，“对象”可以映射成“锁”，哪个线程拿到这把锁，哪个线程就可以执行这个对象中的synchronized同步方法。</li>
<li>A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。</li>
<li>A线程先持有object对象的Lock锁，B线程如果在这时调用object对象中的synchronized类型的方法，则需要等待，也就是同步。</li>
<li>如果在X对象中使用了synchronized关键字声明非静态方法，则X对象就被当成锁。</li>
</ol>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>由于线程是可以睡眠的，所以可能线程运行到一半暂停了，此时可能共享数据正操作一半，此时的数据即被称为脏数据。如果此时读取数据，那么必然是不正确的。所以我们也应当对共享变量的读取添加限制，回想上面第4条。对一个对象不同的synchronized方法，也是同步的，会排队进行。</p>
<p>因此解决办法是将读取方法也设为同步，那么如果设置方法再sleep中，线程不会释放锁，则读取办法也会等待设置方法执行完才能运行，从而避免脏读。</p>
<p>例如：</p>
<p>服务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublicVar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String username = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">public</span> String password = <span class="string">"AA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"setValue method thread name="</span></span><br><span class="line">                   + Thread.currentThread().getName() + <span class="string">" username="</span></span><br><span class="line">                   + username + <span class="string">" password="</span> + password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getValue method thread name="</span></span><br><span class="line">                + Thread.currentThread().getName() + <span class="string">" username="</span> + username + <span class="string">" password="</span> + password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> entity.PublicVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PublicVar publicVar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(PublicVar publicVar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.publicVar = publicVar;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        publicVar.setValue(<span class="string">"B"</span>, <span class="string">"BB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> entity.PublicVar;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PublicVar publicVarRef = <span class="keyword">new</span> PublicVar();</span><br><span class="line">            ThreadA thread = <span class="keyword">new</span> ThreadA(publicVarRef);</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">200</span>);<span class="comment">// 输出结果受此值大小影响</span></span><br><span class="line"></span><br><span class="line">            publicVarRef.getValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时通过getValue获取的数字是一组脏数据，因为getValue不是同步方法，再setValue运行到一半就读取了数据。所以解决办法是将getValue也变为同步方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"getValue method thread name="</span></span><br><span class="line">           + Thread.currentThread().getName() + <span class="string">" username="</span> + username + <span class="string">" </span></span><br><span class="line"><span class="string">           password="</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized锁重入"><a href="#synchronized锁重入" class="headerlink" title="synchronized锁重入"></a>synchronized锁重入</h2><p>关键字synchronized拥有重入锁的功能，即在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以得到该对象锁的，这也证明在一个synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以得到锁的。</p>
<h2 id="锁重入支持继承的环境"><a href="#锁重入支持继承的环境" class="headerlink" title="锁重入支持继承的环境"></a>锁重入支持继承的环境</h2><p>锁重入支持继承的环境即如果类A继承了类B，且类B中有同步方法fn，A重写了fn方法，那么可以通过super.fn调用父类的方法，那么此时的锁仍然是持有的。即重入了锁。</p>
<p>例如：</p>
<p>父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateIMainMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i--;</span><br><span class="line">            System.out.println(<span class="string">"main print i="</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateISubMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                System.out.println(<span class="string">"sub print i="</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">super</span>.operateIMainMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> myservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateISubMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                System.out.println(<span class="string">"sub print i="</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">super</span>.operateIMainMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> myservice.Main;</span><br><span class="line"><span class="keyword">import</span> myservice.Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        sub.operateISubMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> extthread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub print i&#x3D;9</span><br><span class="line">main print i&#x3D;8</span><br><span class="line">sub print i&#x3D;7</span><br><span class="line">main print i&#x3D;6</span><br><span class="line">sub print i&#x3D;5</span><br><span class="line">main print i&#x3D;4</span><br><span class="line">sub print i&#x3D;3</span><br><span class="line">main print i&#x3D;2</span><br><span class="line">sub print i&#x3D;1</span><br><span class="line">main print i&#x3D;0</span><br></pre></td></tr></table></figure>
<p>可以看到由于调用了父类的方法，所以i也再依次减小。并且锁持续持有，完成了锁重入。</p>
<h2 id="出现异常，锁自动释放"><a href="#出现异常，锁自动释放" class="headerlink" title="出现异常，锁自动释放"></a>出现异常，锁自动释放</h2><p>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。</p>
<h2 id="重写方法不使用synchronized"><a href="#重写方法不使用synchronized" class="headerlink" title="重写方法不使用synchronized"></a>重写方法不使用synchronized</h2><p>重写方法如果不使用synchronized关键字，即是非同步方法，使用后变成同步方法。</p>
<h2 id="holdsLock-方法"><a href="#holdsLock-方法" class="headerlink" title="holdsLock()方法"></a>holdsLock()方法</h2><p><code>public static native boolean holdsLock(Object obj)</code>方法的作用检测当前线程是否持有指定对象的锁（这里也就印证了前面第一条）。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A "</span> + Thread.currentThread().holdsLock(Test1<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        isLocked();</span><br><span class="line">        System.out.println(<span class="string">"C "</span> + Thread.currentThread().holdsLock(Test1<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isLocked</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B "</span> + Thread.currentThread().holdsLock(Test1<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A <span class="keyword">false</span></span><br><span class="line">B <span class="keyword">true</span></span><br><span class="line">C <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h1 id="synchronized同步语句块"><a href="#synchronized同步语句块" class="headerlink" title="synchronized同步语句块"></a>synchronized同步语句块</h1><p>synchronized方法是将当前对象作为锁，而synchronized代码块是将任意对象作为锁。可以将锁看成一个标识，哪个线程持有这个标识，就可以执行同步方法。</p>
<p>其主要格式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的obj即为要锁住的对象。也就是说持有该锁后，其他要访问该对象的代码都必须同步。实际上synchronized方法于就等同于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">// 锁住当前对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized同步代码块的使用"><a href="#synchronized同步代码块的使用" class="headerlink" title="synchronized同步代码块的使用"></a>synchronized同步代码块的使用</h2><p>当两个并发线程访问同一个对象object中的synchronized（obj）同步代码块时，一段时间内只能有一个线程得到执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p>
<p>例如：</p>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    		i = <span class="number">100</span>;</span><br><span class="line">    		j = <span class="number">100</span>;</span><br><span class="line">    		System.out.println(String.valueOf(i)+<span class="string">":"</span>+String.valueOf(i)+<span class="string">" current thread: "</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">    		i = <span class="number">1</span>;</span><br><span class="line">    		j = <span class="number">1</span>;</span><br><span class="line">    		System.out.println(String.valueOf(i)+<span class="string">":"</span>+String.valueOf(i)+<span class="string">" current thread: "</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread1 thread = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100:100 current thread: Thread-0</span><br><span class="line">1:1 current thread: Thread-0</span><br><span class="line">100:100 current thread: Thread-0</span><br><span class="line">1:1 current thread: Thread-0</span><br></pre></td></tr></table></figure>
<p>可以看到两个线程是按顺序进入的然后运行的。</p>
<h2 id="锁住任意对象"><a href="#锁住任意对象" class="headerlink" title="锁住任意对象"></a>锁住任意对象</h2><p>前面的例子锁住的是this，即当前的对象。但synchronized代码块还可以锁住任意对象，只需要将其传入代码块的参数即可。</p>
<p>例如：</p>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String str = <span class="string">"string"</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">synchronized</span>(str) &#123;</span><br><span class="line">    		str = <span class="string">"new String"</span>;</span><br><span class="line">    		System.out.println(<span class="string">"update str: "</span> + str);</span><br><span class="line">    		str = <span class="string">"string"</span>;</span><br><span class="line">    		System.out.println(<span class="string">"recover str: "</span> + str);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread1 thread = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update str: new String</span><br><span class="line">recover str: string</span><br><span class="line">update str: new String</span><br><span class="line">recover str: string</span><br></pre></td></tr></table></figure>
<p>可以看到仍然是同步执行的。</p>
<h2 id="synchronized同步块的三个结论"><a href="#synchronized同步块的三个结论" class="headerlink" title="synchronized同步块的三个结论"></a>synchronized同步块的三个结论</h2><p>synchronized（非this对象x）格式的写法是将x对象本身作为“对象监视器”，这样就可以分析出3个结论：</p>
<ol>
<li>当多个线程同时执行synchronized（x）{}同步代码块时呈同步效果。</li>
<li>当其他线程执行x对象中synchronized同步方法时呈同步效果。</li>
<li>当其他线程执行x对象方法里面的synchronized（this）代码块时呈现同步效果。</li>
</ol>
<p>其实这几个结论都由一条准则获得：synchronized锁住的是对象，所以只要是需要对应obj锁的代码，都必须是同步的；而不需要的，就是异步。</p>
<p>这里的结论与前面synchronized方法原理基本一致。</p>
<h2 id="类Class的单例性"><a href="#类Class的单例性" class="headerlink" title="类Class的单例性"></a>类Class的单例性</h2><p>每一个*.java文件对应Class类的实例都是一个。</p>
<h2 id="同步syn（class）代码块可以对类的所有对象实例起作用"><a href="#同步syn（class）代码块可以对类的所有对象实例起作用" class="headerlink" title="同步syn（class）代码块可以对类的所有对象实例起作用"></a>同步syn（class）代码块可以对类的所有对象实例起作用</h2><p>同样的，可以通过synchronized代码块来改写synchronized方法。</p>
<p>例如：</p>
<p>服务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Service<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程名称为："</span> + Thread.currentThread().getName()</span><br><span class="line">                       + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printA"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程名称为："</span> + Thread.currentThread().getName()</span><br><span class="line">                       + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printA"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Service<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名称为："</span> + Thread.currentThread().getName()</span><br><span class="line">                   + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printB"</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程名称为："</span> + Thread.currentThread().getName()</span><br><span class="line">                   + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printB"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是直接锁定了<code>Service.class</code>，就像静态synchronized方法。</p>
<h2 id="String常量池特性与同步相关的问题与解决方案"><a href="#String常量池特性与同步相关的问题与解决方案" class="headerlink" title="String常量池特性与同步相关的问题与解决方案"></a>String常量池特性与同步相关的问题与解决方案</h2><p>值得注意的是，常量有一个常量池，通过字面量定义的String对象。可能会被放到常量池中，导致虽然看起来不同，但是实际上是同一个对象，所以其锁确实同一个锁，导致错误。</p>
<p>其解决办法也很简单，使用字符串常量作为锁对象时，不用字面量定义，而用构造方法来定义，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String lock = <span class="keyword">new</span> String(<span class="string">"lock"</span>);</span><br></pre></td></tr></table></figure>
<p>这样就可以保证获取到的字符串对象完全不同。</p>
<h2 id="锁对象不改变依然同步执行"><a href="#锁对象不改变依然同步执行" class="headerlink" title="锁对象不改变依然同步执行"></a>锁对象不改变依然同步执行</h2><p>只要对象不变，运行的结果即为同步。其实这也对应了一个对象一把锁的原则。</p>
<p>即对象本身不变，其属性改变，并不会影响对象的锁。</p>
<h2 id="锁对象改变则锁改变"><a href="#锁对象改变则锁改变" class="headerlink" title="锁对象改变则锁改变"></a>锁对象改变则锁改变</h2><p>同样的，如果锁对象改变，则锁也相应改变，所以不同的线程就会变成异步执行。</p>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>首先了解并发编程中的的三个重要特性：</p>
<ul>
<li>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
<p>而volatile基本保证了上述特征，但是在原子性上，其并不完整，具体如下：</p>
<p>在32位系统中，针对未使用volatile声明的long或double数据类型没有实现写原子性，如果想实现，则声明变量时添加volatile，而在64位系统中，原子性取决于具体的实现，在X86架构64位JDK版本中，写double或long是原子的。<strong>另外，针对用volatile声明的int i变量进行i++操作时是非原子的。</strong></p>
<h2 id="可见性测试"><a href="#可见性测试" class="headerlink" title="可见性测试"></a>可见性测试</h2><h3 id="简单的内存模型"><a href="#简单的内存模型" class="headerlink" title="简单的内存模型"></a>简单的内存模型</h3><p>简单来说，线程再执行的时候是在CPU中执行，而为了缓解内存速度太慢的问题。CPU中就设计了缓存，而不同的线程都有不同的缓存，一般是先将内存中的变量复制到CPU缓存中。而不同的线程就有不同的副本，因此就产生了同步问题。</p>
<p>而关键字volatile具有可见性，可见性是指A线程更改变量的值后，B线程马上就能看到更改后的变量的值。</p>
<p>其原理在于用volatile标记的变量每次读写值都是从内存中读取，而不是读写局部缓存。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>线程代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String str = <span class="string">"string"</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(str != <span class="string">""</span>) &#123;</span><br><span class="line">    		System.out.println(<span class="string">"looping!"</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">        System.out.println(<span class="string">"stop!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.str = str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread1 thread = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.setStr(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其结果就是无论如何都停不下来。</p>
<p>但是如果将str改为volatile修饰就可以将其停下来。</p>
<p>即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">private</span> String str = <span class="string">"string"</span>;</span><br></pre></td></tr></table></figure>
<p>则会在大致两秒后停下来。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>在32位系统中，针对未使用volatile声明的long或double数据类型没有实现写原子性，如果想实现，则声明变量时添加volatile。</p>
<p>在64位系统中，原子性取决于具体的实现，在X86架构64位JDK版本中，写double或long是原子的。</p>
<p>另外，volatile关键字最致命的缺点是不支持原子性，也就是多个线程对用volatile修饰的变量i执行i–操作时，i–操作还会被分解成3步，造成非线程安全问题的出现。</p>
<h3 id="解决原子性"><a href="#解决原子性" class="headerlink" title="解决原子性"></a>解决原子性</h3><h3 id="使用synchronized"><a href="#使用synchronized" class="headerlink" title="使用synchronized"></a>使用synchronized</h3><p>可以使用synchronized来同步赋值方法可以实现原子性。这个方法很容易想到。</p>
<h3 id="使用Atomic原子类进行i-操作实现原子性"><a href="#使用Atomic原子类进行i-操作实现原子性" class="headerlink" title="使用Atomic原子类进行i++操作实现原子性"></a>使用Atomic原子类进行i++操作实现原子性</h3><p>除了在i++操作时使用synchronized关键字实现同步外，还可以使用AtomicInteger原子类实现原子性。</p>
<p>原子操作是不能分割的整体，没有其他线程能够中断或检查处于原子操作中的变量。一个原子（atomic）类型就是一个原子操作可用的类型，它可以在没有锁（lock）的情况下做到线程安全（thread-safe）。</p>
<p>例如：</p>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddCountThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(count.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> extthread.AddCountThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AddCountThread countService = <span class="keyword">new</span> AddCountThread();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(countService);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(countService);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(countService);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(countService);</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(countService);</span><br><span class="line">        t5.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">49992</span><br><span class="line">49993</span><br><span class="line">49994</span><br><span class="line">49995</span><br><span class="line">49996</span><br><span class="line">49997</span><br><span class="line">49998</span><br><span class="line">49999</span><br><span class="line">50000</span><br></pre></td></tr></table></figure>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>使用关键字volatile可以禁止代码重排序。保证代码的有序性。</p>
<p>在Java程序运行时，JIT（Just-In-Time Compiler，即时编译器）可以动态地改变程序代码运行的顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A代码-重耗时</span><br><span class="line">B代码-轻耗时</span><br><span class="line">C代码-重耗时</span><br><span class="line">D代码-轻耗时</span><br></pre></td></tr></table></figure>
<p>可能会被重排为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B代码-轻耗时</span><br><span class="line">D代码-轻耗时</span><br><span class="line">A代码-重耗时</span><br><span class="line">C代码-重耗时</span><br></pre></td></tr></table></figure>
<p>这样做的主要原因是CPU流水线是同时执行这4个指令的，那么轻耗时的代码在很大程度上先执行完，以让出CPU流水线资源给其他指令，所以代码重排序是为了追求更高的程序运行效率。</p>
<p>重排序发生在没有依赖关系时。</p>
<p>但如果加入了volatile，则保证被volatile声明的语句前后无法重排。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A变量的操作</span><br><span class="line">B变量的操作</span><br><span class="line">volatile Z变量的操作</span><br><span class="line">C变量的操作</span><br><span class="line">D变量的操作</span><br></pre></td></tr></table></figure>
<p>那么会有4种情况发生：</p>
<p>1）A、B可以重排序。</p>
<p>2）C、D可以重排序。</p>
<p>3）A、B不可以重排到Z的后面。</p>
<p>4）C、D不可以重排到Z的前面。</p>
<p>换言之，变量Z是一个“屏障”，Z变量之前或之后的代码不可以跨越Z变量，这就是屏障的作用，关键字synchronized具有同样的特性。</p>
<h3 id="volatile重排的规则"><a href="#volatile重排的规则" class="headerlink" title="volatile重排的规则"></a>volatile重排的规则</h3><p>由上可以得出volatile声明的规则：</p>
<ol>
<li>关键字volatile之前的代码可以重排</li>
<li>关键字volatile之后的代码可以重排</li>
<li>关键字volatile之前的代码不可以重排到volatile之后</li>
<li>关键字volatile之后的代码不可以重排到volatile之前</li>
<li>关键字synchronized之前的代码不可以重排到synchronized之后</li>
<li>关键字synchronized之后的代码不可以重排到synchronized之前</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键字synchronized的主要作用是保证同一时刻，只有一个线程可以执行某一个方法，或是某一个代码块，synchronized可以修饰方法及代码块。随着JDK的版本升级，synchronized关键字在执行效率上得到很大提升。它包含三个特征。</p>
<ol>
<li>可见性：synchronized具有可见性。</li>
<li>原子性：使用synchronized实现了同步，同步实现了原子性，保证被同步的代码段在同一时间只有一个线程在执行。</li>
<li>禁止代码重排序：synchronized禁止代码重排序。</li>
</ol>
<p>关键字volatile的主要作用是让其他线程可以看到最新的值，volatile只能修饰变量。它包含三个特征：</p>
<ol>
<li>可见性：B线程能马上看到A线程更改的数据。</li>
<li>原子性：在32位系统中，针对未使用volatile声明的long或double数据类型没有实现写原子性，如果想实现，则声明变量时添加volatile，而在64位系统中，原子性取决于具体的实现，在X86架构64位JDK版本中，写double或long是原子的。另外，针对用volatile声明的int i变量进行i++操作时是非原子的。</li>
<li>禁止代码重排序。</li>
</ol>
<p>关键字volatile和synchronized的使用场景总结如下：</p>
<p>1）当想实现一个变量的值被更改时，让其他线程能取到最新的值时，就要对变量使用volatile。（即volatile尽量只用于解决可见性问题。）</p>
<p>2）当多个线程对同一个对象中的同一个实例变量进行操作时，为了避免出现非线程安全问题，就要使用synchronized。</p>
]]></content>
      <categories>
        <category>Java多线程编程核心技术</category>
      </categories>
      <tags>
        <tag>Java多线程编程核心技术</tag>
        <tag>对象及变量的并发访问</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程编程核心技术-5-Timer的使用</title>
    <url>/2022/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-5-Timer%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="定时器Timer的使用"><a href="#定时器Timer的使用" class="headerlink" title="定时器Timer的使用"></a>定时器Timer的使用</h1><h2 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h2><p>Timer类的主要作用是设置计划任务，即在指定时间开始执行某一个任务。</p>
<p>其构造方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Timer-"</span> + serialNumber());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(<span class="keyword">boolean</span> isDaemon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Timer-"</span> + serialNumber(), isDaemon);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即可以自定义该定时器的名称。</p>
<p>其主要有四个方法：</p>
<ul>
<li>schedule</li>
<li>scheduleAtFixedRate</li>
<li>cancel</li>
<li>purge</li>
</ul>
<p>其中第一二个都是计划执行的方法；而第三个为取消任务；第四个为移除所有被取消的任务，并返回器数量。</p>
<h2 id="TimerTask类"><a href="#TimerTask类" class="headerlink" title="TimerTask类"></a>TimerTask类</h2><p>TimerTask是实现了Runnable接口的一个抽象类，即实际上是封装了一个线程。</p>
<p>主要是在内部添加了状态属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> state = VIRGIN;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRGIN = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHEDULED   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXECUTED    = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>并且新建了一个空对象作为锁对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This object is used to control access to the TimerTask internals.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>我们需要去继承TimerTask，然后重写run方法，进而实现自己的任务。</p>
<h2 id="单次任务"><a href="#单次任务" class="headerlink" title="单次任务"></a>单次任务</h2><p>下面介绍可以单词执行任务的方法。</p>
<h3 id="指定时间执行-schedule-TimerTask-task-Date-time"><a href="#指定时间执行-schedule-TimerTask-task-Date-time" class="headerlink" title="指定时间执行-schedule(TimerTask task, Date time)"></a>指定时间执行-<code>schedule(TimerTask task, Date time)</code></h3><p>可以通过<code>schedule(TimerTask task，Date time)</code>来执行定时只执行一次的任务。</p>
<p>例如10秒后打印字符串：</p>
<p>TimerTask类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"task begin!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">		TimerTask timerTask = <span class="keyword">new</span> MyTimerTask();</span><br><span class="line">		timer.schedule(timerTask, <span class="keyword">new</span> Date(System.currentTimeMillis()+<span class="number">10000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TimerThread线程不会自动销毁"><a href="#TimerThread线程不会自动销毁" class="headerlink" title="TimerThread线程不会自动销毁"></a>TimerThread线程不会自动销毁</h4><p>执行后会发现一个问题，即使当定时器已经执行完毕，定时器线程并不会结束。这是因为任务的实际执行是在Timer类内部的<code>TimerThread</code>线程来执行。其run方法是一个死循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mainLoop();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></span><br><span class="line">        <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">            newTasksMayBeScheduled = <span class="keyword">false</span>;</span><br><span class="line">            queue.clear();  <span class="comment">// Eliminate obsolete references</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main timer loop.  (See class comment.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimerTask task;</span><br><span class="line">            <span class="keyword">boolean</span> taskFired;</span><br><span class="line">            <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">                <span class="comment">// Wait for queue to become non-empty</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                    queue.wait();</span><br><span class="line">                <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></span><br><span class="line">                <span class="keyword">long</span> currentTime, executionTime;</span><br><span class="line">                task = queue.getMin();</span><br><span class="line">                <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">                        queue.removeMin();</span><br><span class="line">                        <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    currentTime = System.currentTimeMillis();</span><br><span class="line">                    executionTime = task.nextExecutionTime;</span><br><span class="line">                    <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            task.state = TimerTask.EXECUTED;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></span><br><span class="line">                            queue.rescheduleMin(</span><br><span class="line">                                task.period&lt;<span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">                                : executionTime + task.period);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn't yet fired; wait</span></span><br><span class="line">                    queue.wait(executionTime - currentTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></span><br><span class="line">                task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以即使是定时器全部结束，也不会停止线程。</p>
<p>而我们可以使用<code>public void cancel()</code>来手动使TimerThread终止。</p>
<p>Timer类中public void cancel()方法的作用是终止此计时器，丢弃所有当前已安排的任务。这不会干扰当前正在执行的任务（如果存在）。一旦终止了计时器，那么它的执行线程也会终止，并且无法根据它安排更多的任务。注意，在此计时器调用的计时器任务的run()方法内调用此方法，可以确保正在执行的任务是此计时器所执行的最后一个任务。可以重复调用此方法，但是第二次和后续调用无效。</p>
<p>例如：</p>
<p>执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">		TimerTask timerTask = <span class="keyword">new</span> MyTimerTask();</span><br><span class="line">		timer.schedule(timerTask, <span class="keyword">new</span> Date(System.currentTimeMillis()+<span class="number">10000</span>));</span><br><span class="line">		Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">		timer.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即指定10秒钟后执行该任务，15秒后取消该定时器，定时线程也被终止。</p>
<h4 id="计划时间早于当前时间——立即运行的效果"><a href="#计划时间早于当前时间——立即运行的效果" class="headerlink" title="计划时间早于当前时间——立即运行的效果"></a>计划时间早于当前时间——立即运行的效果</h4><p>如果指定的时间在当前时间之前，则该任务会立即执行。但是注意，其仍然是在异步线程中使用，所以仍然会比主线程慢输出，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">		TimerTask timerTask = <span class="keyword">new</span> MyTimerTask();</span><br><span class="line">		timer.schedule(timerTask, <span class="keyword">new</span> Date(System.currentTimeMillis()-<span class="number">10000</span>));</span><br><span class="line">		System.out.println(<span class="string">"main thread!"</span>);</span><br><span class="line">		timer.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main thread!</span><br><span class="line">task begin!</span><br></pre></td></tr></table></figure>
<h4 id="一个Timer中执行多个TimerTask任务"><a href="#一个Timer中执行多个TimerTask任务" class="headerlink" title="一个Timer中执行多个TimerTask任务"></a>一个Timer中执行多个TimerTask任务</h4><p>一个Timer相当于一个管理器，因此其可以管理多个异步任务。只需要多次调用schedule方法即可。</p>
<p>例如：</p>
<p>任务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Task Time: "</span> + System.currentTimeMillis());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nowTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"current time: "</span> + nowTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> scheduleTime1 = (nowTime + <span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">long</span> scheduleTime2 = (nowTime + <span class="number">8000</span>);</span><br><span class="line">        System.out.println(<span class="string">"task1 time: "</span> + scheduleTime1);</span><br><span class="line">        System.out.println(<span class="string">"task2 time: "</span> + scheduleTime2);</span><br><span class="line"></span><br><span class="line">        MyTimerTask task1 = <span class="keyword">new</span> MyTimerTask();</span><br><span class="line">        MyTimerTask task2 = <span class="keyword">new</span> MyTimerTask();</span><br><span class="line"></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(task1, <span class="keyword">new</span> Date(scheduleTime1));</span><br><span class="line">        timer.schedule(task2, <span class="keyword">new</span> Date(scheduleTime2));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"main thread!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">current time: 1649239031782</span><br><span class="line">task1 time: 1649239036782</span><br><span class="line">task2 time: 1649239039782</span><br><span class="line">main thread!</span><br><span class="line">Task Time: 1649239036782</span><br><span class="line">Task Time: 1649239039796</span><br></pre></td></tr></table></figure>
<p>可以看到其都执行了。</p>
<h3 id="指定时间间隔后执行-schedule-TimerTask-task，long-delay"><a href="#指定时间间隔后执行-schedule-TimerTask-task，long-delay" class="headerlink" title="指定时间间隔后执行-schedule(TimerTask task，long delay)"></a>指定时间间隔后执行-<code>schedule(TimerTask task，long delay)</code></h3><p>该方法与上述的<code>schedule(TimerTask task, Date time)</code>都是添加一个任务。</p>
<p>不过该方法是以执行方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"运行了！时间为："</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        System.out.println(<span class="string">"当前时间："</span> + System.currentTimeMillis());</span><br><span class="line">        timer.schedule(task, <span class="number">7000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环任务"><a href="#循环任务" class="headerlink" title="循环任务"></a>循环任务</h2><p>还可以制定以一定间隔一直循环执行任务。</p>
<h3 id="追赶任务"><a href="#追赶任务" class="headerlink" title="追赶任务"></a>追赶任务</h3><h4 id="指定第一次任务-schedule-TimerTask-task，Date-firstTime，long-period"><a href="#指定第一次任务-schedule-TimerTask-task，Date-firstTime，long-period" class="headerlink" title="指定第一次任务-schedule(TimerTask task，Date firstTime，long period)"></a>指定第一次任务-<code>schedule(TimerTask task，Date firstTime，long period)</code></h4><p>该方法的作用是在<strong>指定日期之后</strong>按指定的间隔周期无限循环地执行某一任务。</p>
<p>例如，执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mytask.MyTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nowTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"当前时间为："</span> + nowTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> scheduleTime = (nowTime + <span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">"计划时间为："</span> + scheduleTime);</span><br><span class="line"></span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line"></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(task, <span class="keyword">new</span> Date(scheduleTime), <span class="number">4000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">current time: <span class="number">1649241014210</span></span><br><span class="line">plan time: <span class="number">1649241024210</span></span><br><span class="line">Task Time: <span class="number">1649241024210</span></span><br><span class="line">Task Time: <span class="number">1649241028219</span></span><br><span class="line">Task Time: <span class="number">1649241032229</span></span><br><span class="line">Task Time: <span class="number">1649241036244</span></span><br></pre></td></tr></table></figure>
<h4 id="以当前时间为第一次任务的开始时间-schedule-TimerTask-task，long-delay，long-period"><a href="#以当前时间为第一次任务的开始时间-schedule-TimerTask-task，long-delay，long-period" class="headerlink" title="以当前时间为第一次任务的开始时间-schedule(TimerTask task，long delay，long period)"></a>以当前时间为第一次任务的开始时间-<code>schedule(TimerTask task，long delay，long period)</code></h4><p>该方法的作用是以执行<code>schedule(TimerTask task，long delay，long period)</code>方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"运行了！时间为："</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        System.out.println(<span class="string">"当前时间："</span> + System.currentTimeMillis());</span><br><span class="line">        timer.schedule(task, <span class="number">7000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">current time: 1649241296832</span><br><span class="line">plan time: 1649241306832</span><br><span class="line">Task Time: 1649241299845</span><br><span class="line">Task Time: 1649241300855</span><br><span class="line">Task Time: 1649241301870</span><br></pre></td></tr></table></figure>
<h3 id="不追赶任务-scheduleAtFixedRate"><a href="#不追赶任务-scheduleAtFixedRate" class="headerlink" title="不追赶任务-scheduleAtFixedRate"></a>不追赶任务-<code>scheduleAtFixedRate</code></h3><h4 id="追赶测试"><a href="#追赶测试" class="headerlink" title="追赶测试"></a>追赶测试</h4><p>schedule()方法和scheduleAtFixedRate()方法的主要区别在于有没有追赶特性。</p>
<p>所谓追赶，即当上一次任务的结束时间已经比该次任务的计划时间晚了，那么该次任务是否还执行。</p>
<p>而schedule是不具有追赶行的，即过期的任务不会被执行。</p>
<p>scheduleAtFixedRate具有追赶性，即使任务过期，还是会执行。</p>
<p>例如：</p>
<p>追赶执行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test9</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"begin timer="</span> + System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">"  end timer="</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        <span class="keyword">long</span> nowTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"现在执行时间："</span> + nowTime);</span><br><span class="line">        <span class="keyword">long</span> runTime = nowTime - <span class="number">20000</span>;</span><br><span class="line">        System.out.println(<span class="string">"计划执行时间："</span> + runTime);</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(task, <span class="keyword">new</span> Date(runTime), <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">current time: 1649242106556</span><br><span class="line">plan time: 1649242086556</span><br><span class="line">begin timer&#x3D;1649242106557</span><br><span class="line">  end timer&#x3D;1649242106557</span><br><span class="line">begin timer&#x3D;1649242108563</span><br><span class="line">  end timer&#x3D;1649242108563</span><br><span class="line">begin timer&#x3D;1649242110575</span><br><span class="line">  end timer&#x3D;1649242110575</span><br><span class="line">begin timer&#x3D;1649242112582</span><br><span class="line">  end timer&#x3D;1649242112582</span><br><span class="line">begin timer&#x3D;1649242114596</span><br><span class="line">  end timer&#x3D;1649242114596</span><br><span class="line">begin timer&#x3D;1649242116607</span><br><span class="line">  end timer&#x3D;1649242116607</span><br><span class="line">begin timer&#x3D;1649242118610</span><br><span class="line">  end timer&#x3D;1649242118610</span><br><span class="line">begin timer&#x3D;1649242120622</span><br><span class="line">  end timer&#x3D;1649242120622</span><br><span class="line">begin timer&#x3D;1649242122633</span><br><span class="line">  end timer&#x3D;1649242122633</span><br></pre></td></tr></table></figure>
<p>可以看到，1649242086556到1649242106556之间的任务都没有被执行。</p>
<h4 id="不追赶测试"><a href="#不追赶测试" class="headerlink" title="不追赶测试"></a>不追赶测试</h4><p>同样的，我们将其换成scheduleAtFixedRate方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"begin timer="</span> + System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">"  end timer="</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        <span class="keyword">long</span> nowTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"current time: "</span> + nowTime);</span><br><span class="line">        <span class="keyword">long</span> runTime = nowTime - <span class="number">20000</span>;</span><br><span class="line">        System.out.println(<span class="string">"plan time: "</span> + runTime);</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.scheduleAtFixedRate(task, <span class="keyword">new</span> Date(runTime), <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">current time: 1649242326064</span><br><span class="line">plan time: 1649242306064</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242326066</span><br><span class="line">  end timer&#x3D;1649242326066</span><br><span class="line">begin timer&#x3D;1649242328064</span><br><span class="line">  end timer&#x3D;1649242328064</span><br><span class="line">begin timer&#x3D;1649242330070</span><br><span class="line">  end timer&#x3D;1649242330070</span><br><span class="line">begin timer&#x3D;1649242332064</span><br><span class="line">  end timer&#x3D;1649242332064</span><br><span class="line">begin timer&#x3D;1649242334077</span><br><span class="line">  end timer&#x3D;1649242334077</span><br><span class="line">begin timer&#x3D;1649242336065</span><br><span class="line">  end timer&#x3D;1649242336065</span><br><span class="line">begin timer&#x3D;1649242338065</span><br><span class="line">  end timer&#x3D;1649242338065</span><br></pre></td></tr></table></figure>
<p>可以看到，1649242326066的时间都被追赶执行。将20s之内执行任务的次数输出完，再每间隔2s执行一次任务。</p>
]]></content>
      <categories>
        <category>Java多线程编程核心技术</category>
      </categories>
      <tags>
        <tag>Java多线程编程核心技术</tag>
        <tag>Timer的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL必知必会1-12-基础知识</title>
    <url>/2022/02/20/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A1-12-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>主键每一行都应该可以唯一标识自己的一列。没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行。</p>
<p>表中的任意行都可以作为主键，只要它满足以下条件：</p>
<ul>
<li>任意两行不具有相同的主键值。</li>
<li>每个行都必须具有一个主键（主键不允许为NULL）。</li>
</ul>
<p>主键通常是定义在表的一个列中，但并不是只能一列，也可以多个列一起使用作为主键。当使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须时唯一的（但单个列的值可以不唯一）。</p>
<p>主键的好习惯：</p>
<ul>
<li>不更新主键列中的值。</li>
<li>不重用主键列中的值。</li>
<li>不再主键列中使用可能会更改的值。</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL是一种DBMS，即它是一种数据库软件。</p>
<h2 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h2><p>DBMS可分为两类：</p>
<ul>
<li>基于共享文件系统的DBMS</li>
<li>基于客户机-服务器的DBMS<ul>
<li>客户机是与用户打交道的软件。</li>
<li>服务器部分是负责所有数据访问和处理的一个软件。</li>
</ul>
</li>
</ul>
<h1 id="数据库命令"><a href="#数据库命令" class="headerlink" title="数据库命令"></a>数据库命令</h1><h2 id="USE命令"><a href="#USE命令" class="headerlink" title="USE命令"></a>USE命令</h2><p>USE可以用于选择数据库。</p>
<p>例如选择数据库<code>HRDB</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> HRDB;</span><br></pre></td></tr></table></figure>
<h2 id="SHOW命令"><a href="#SHOW命令" class="headerlink" title="SHOW命令"></a>SHOW命令</h2><p>SHOW命令可以用来展示数据，例如表、服务器状态，用户等。</p>
<p>例如：</p>
<ol>
<li><p>展示表-<code>applicant2022</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> applicant2022;</span><br></pre></td></tr></table></figure>
</li>
<li><p>展示服务器状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>展示创建的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><p><code>SELECT from</code> 语句可以用来检索数据。</p>
<p>其基本结构为</p>
<p><code>SELECT col1, col2, ..., coln from table</code></p>
<p>例如：</p>
<ol>
<li><p>从表<code>products</code>中选择一列<code>prod_name</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从表<code>products</code>中选择两列<code>prod_name, prod_price</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="从表products中检索所有的列"><a href="#从表products中检索所有的列" class="headerlink" title="从表products中检索所有的列"></a>从表<code>products</code>中检索所有的列</h2><p>可以通过通配符*来匹配所有列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products</span><br></pre></td></tr></table></figure>
<h2 id="检索不同的列"><a href="#检索不同的列" class="headerlink" title="检索不同的列"></a>检索不同的列</h2><p>上面返回数据的列是包含重复元素的。而可以使用<code>DISTINCT</code>关键词来去掉列中的重复值。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
<p>注意：<code>DISTINCT</code>关键词会应用于所有列而不仅前置它的列。例如<code>SELECT vend_id, prod_price from products</code>，除非两个列都不同，否则所有的列都将被检索出来。</p>
<h2 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h2><p><code>SEELCT</code>语句返回匹配的所有行，而<code>LIMIT</code>关键词可以指定返回的行数。</p>
<p>例如：从<code>products</code>中选择<code>products</code>的前5行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>也可以指定返回行数的位置。其格式有以下两种：</p>
<ul>
<li><code>LIMIT start, count</code>:包含start，第一列为0。</li>
<li><code>LIMIT start OFFSET count</code>:与上面代码意义一样。</li>
</ul>
<p>例如：从<code>products</code>中选择<code>products</code>的从第3列开始的前5行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">LIMIT</span> <span class="number">3</span>, <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用完全限定的表明"><a href="#使用完全限定的表明" class="headerlink" title="使用完全限定的表明"></a>使用完全限定的表明</h2><p>所谓的完全限定名，对于字段来说就是<code>表名+列名</code>，而对于表名来说就是<code>数据库+表名</code>。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> products.prod_name <span class="keyword">FROM</span> HRDB.products;</span><br></pre></td></tr></table></figure>
<h1 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h1><p>可以使用<code>ORDER BY</code>子句，来对筛选出的数据进行排序。</p>
<h2 id="单例排序"><a href="#单例排序" class="headerlink" title="单例排序"></a>单例排序</h2><p>简单按照一列排序。</p>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<h2 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h2><p>有时需要按照多列排序，即第一列相同，则按照第二列来排序。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price, prod_name;</span><br></pre></td></tr></table></figure>
<h2 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h2><p>默认排序的方向为升序（关键词为<code>ASC</code>），而可以使用<code>DESC</code>来指定为降序。</p>
<p>例如：</p>
<ol>
<li><p>升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price;</span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">ASC</span>;		//前后等价</span><br></pre></td></tr></table></figure>
</li>
<li><p>降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><p><code>WHERE</code>语句可以用来指定过滤的条件。<code>WHERE</code>后接条件相等，不等，大于或小于等。</p>
<h2 id="普通筛选"><a href="#普通筛选" class="headerlink" title="普通筛选"></a>普通筛选</h2><p>从<code>products</code>表中选出<code>prod_price</code>等于2.5的列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price = <span class="number">2.50</span>;</span><br></pre></td></tr></table></figure>
<p>注意：在同hi使用<code>ORDER BY</code>语句和<code>WHERE</code>时，应该让<code>ORDER BY</code>语句位于<code>WHERE</code>之后。</p>
<p>下面是<code>WHERE</code>子句操作符</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="\images\MySQL必知必会\WHERE子句操作符.jpg" alt="WHERE子句操作符"></h3><h3 id="检查单个值"><a href="#检查单个值" class="headerlink" title="检查单个值"></a>检查单个值</h3><p>可以使用=来检查单个值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name = <span class="string">'fuses'</span>;</span><br></pre></td></tr></table></figure>
<p>注意MySQL来执行匹配的时默认不区分大小写。</p>
<h3 id="不匹配检查"><a href="#不匹配检查" class="headerlink" title="不匹配检查"></a>不匹配检查</h3><p>可以使用&lt;&gt;来进行不等于匹配。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id &lt;&gt; <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
<h3 id="范围检查"><a href="#范围检查" class="headerlink" title="范围检查"></a>范围检查</h3><p>为了检查某个列的范围可以用<code>BETWEEN</code>关键词。</p>
<p>例如检索价格在5-10美元之间的商品：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>注意：两个值必须用AND关键词分隔。 <code>BETWEEN</code>匹配范围内的所有的值，包括开始值和结束值。</p>
<h3 id="空值判断"><a href="#空值判断" class="headerlink" title="空值判断"></a>空值判断</h3><p>对于NULL的判断，有一个特殊的子句-<code>IS NULL</code>。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h1 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h1><h2 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合<code>WHERE</code>子句</h2><p>MySQL允许给出多个<code>WHERE</code>子句。这些子句有两种组合方式：</p>
<ul>
<li>AND关键词：并，都要满足，优先级最高。</li>
<li>OR关键词：或，只满足一个即可。</li>
</ul>
<h2 id="AND子句"><a href="#AND子句" class="headerlink" title="AND子句"></a>AND子句</h2><p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id = <span class="number">1003</span> <span class="keyword">AND</span> prod_price &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>该语句表示，既要<code>vend_id</code>等于1003，又要<code>prod_price</code>小于等于10.</p>
<h2 id="OR子句"><a href="#OR子句" class="headerlink" title="OR子句"></a>OR子句</h2><p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id = <span class="number">1003</span> <span class="keyword">OR</span> prod_price &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h2><p><code>WHERE</code>可以包含任意数目的AND和OR操作符。并允许两者以任意的顺序结合来进行组合为更加复杂的过滤句子。但是注意AND有更高的优先级。如果想要改变，则需要括号<code>()</code>。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name，prod_price <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1002</span> <span class="keyword">OR</span> vend_id = <span class="number">1003</span> <span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>所实际的顺序是先计算后面的<code>AND</code>，再计算前面的<code>OR</code>。</p>
<p>如果要改变顺序，可以通过一下格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name，prod_price <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> (vend_id = <span class="number">1002</span> <span class="keyword">OR</span> vend_id = <span class="number">1003</span>) <span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h2><p>圆括号在<code>WHERE</code>子句中还有另一种用法。IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN合法值为由逗号分隔的多个值。</p>
<p>例如：取<code>vend_id</code>的值在<code>1002</code>,<code>1003</code>,<code>1004</code>中的任意一个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name，prod_price <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>使用IN操作符的优点为：</p>
<ul>
<li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</li>
<li>在使用IN时，计算的次序更容易管理。</li>
<li>IN操作符一般比OR操作符清单执行更快。</li>
<li>IN操作符的最大优点是可以包含其他SELECT语句，使得能够动态地建立<code>WHERE</code>语句。</li>
</ul>
<h2 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h2><p><code>WHERE</code>子句中地<code>NOT</code>操作符有且只有一个功能，那就是否定它之后所跟地任意条件。</p>
<p>例如<code>vend_id</code>不在<code>1002,1003,1004</code>之中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name，prod_priceFROM products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>MySQL中地NOT支持对IN、BETWEEN和EXISTS子句进行取反。</p>
<h1 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h1><h2 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h2><p>LIKE操作符用于与后面的搜索模式组合进行过滤。</p>
<h2 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h2><p>%表示任何字符出现任意次数（0-∞）。</p>
<p>例如：匹配<code>prod_name</code>为以<code>jet</code>开头地所有内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id，prod_nameFROM products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure>
<p>注意：根据MySQL地配置方式，搜索可以是区分大小写的。如果区分大小写<code>jet%</code>与<code>Jetpack 1000</code>将不匹配。</p>
<p>注意通配符可以出现在字段的任意位置，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id，prod_nameFROM products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'%anvil%'</span>;</span><br></pre></td></tr></table></figure>
<p>表示任意内容，只要包含<code>anvil</code>就可以匹配到。如<code>1anvil</code>、<code>anval1q、</code>qanval0`。</p>
<h2 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h2><p>另一个通配符（_）只匹配<strong>单个字符</strong>。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id，prod_nameFROM products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'_ ton anvi7'</span>;</span><br></pre></td></tr></table></figure>
<p>只匹配第一开头包含一个单词，后面为<code>ton anvi7</code>的单词。如<code>1 ton anvi7</code>，<code>q ton anvi7</code>等。</p>
<h2 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h2><p>使用通配符应当记住以下技巧：</p>
<ul>
<li>不要过度使用通配符。其它操作符能够达到相同效果的目的，应该使用其他操作符。</li>
<li>在确定需要使用通配符时，除非绝对必要，否则不要把它们放在搜索模式的开始处。因为这会使检索速度慢很多。</li>
</ul>
<h1 id="用正则表达式进行搜索"><a href="#用正则表达式进行搜索" class="headerlink" title="用正则表达式进行搜索"></a>用正则表达式进行搜索</h1><p>由于前面的通配符能实现的通配模式有限，所以引入了正则表达式来进行匹配。</p>
<p>其基本语句是<code>REGEXP</code>关键词。其后接的字符串即为正则表达式。</p>
<p>例如表示name为1000的列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> <span class="keyword">name</span> REGEXP <span class="string">'1000'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h2><p>可以通过<code>|</code>来间隔两个串，并且匹配这来给你个串中的一个。</p>
<p>例如：匹配<code>prod_name</code>为1000或2000：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_nameFROM products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'1000 | 2000'</span><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>可以给出两个以上的OR条件，用于匹配多个可能的情况。</p>
<h2 id="匹配多字符中的一个"><a href="#匹配多字符中的一个" class="headerlink" title="匹配多字符中的一个"></a>匹配多字符中的一个</h2><p>可以通过<code>[xyz]</code>来匹配z, y, z中的任意一个字母。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_nameFROM products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[123] Ton'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>匹配<code>1tom</code>、<code>2tom</code>或者<code>3tom</code>。</p>
<h2 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h2><p>可以结合<code>[]</code>和<code>-</code>来表示范围。如，<code>[a-z]</code>来匹配a到z的任意一个字母；[1-10]来匹配1到10的任意一个数字。</p>
<p>例如：匹配<code>1 Ton</code>到<code>5 Ton</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_nameFROM products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[1-5] Ton'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name ;</span><br></pre></td></tr></table></figure>
<p>而为了方便，MySQL定义了特定范围的串。具体如下表：</p>
<p><img src="\images\MySQL必知必会\正则表达式-字符类.jpg" alt="正则表达式-字符类"></p>
<h2 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a>匹配特殊字符</h2><p>对于MySQL定义的正则表达式特殊字符，如<code>%, _</code>等，可以通过转义来进行。</p>
<p>如：<code>\\.</code>匹配<code>.</code>，<code>\\%</code>匹配<code>%</code>。具体如下表。</p>
<p><img src="\images\MySQL必知必会\正则表达式-转义字符.jpg" alt="正则表达式-转义字符"></p>
<h2 id="匹配出现次数"><a href="#匹配出现次数" class="headerlink" title="匹配出现次数"></a>匹配出现次数</h2><p>有时候需要匹配的模式出现多次，则需要量词。两次直接跟在模式的后面。如<code>a{5}</code>匹配<code>aaaaa</code>，a出现5次。而所有的两次如下：</p>
<p><img src="\images\MySQL必知必会\正则表达式-量词.jpg" alt="正则表达式-量词"></p>
<p>例如：匹配id为一个或多个1的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> <span class="keyword">id</span> REGEX <span class="string">'1+'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>没有定位词时，正则表达式总是匹配所有的内容，而通过定位符可以匹配开头或者结尾。具体所有的定位符如下：</p>
<p><img src="\images\MySQL必知必会\正则表达式-定位符.jpg" alt="正则表达式-定位符"></p>
<p>例如匹配数字开头的<code>id</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> <span class="keyword">id</span> REGEX <span class="string">'^[0-9]'</span>;</span><br></pre></td></tr></table></figure>
<h1 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h1><p>计算字段可以重新组合、计算原有表中的数据。</p>
<h2 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h2><p>利用<code>Concat(..args)</code>函数可以用来拼接字段。这其中参数不仅可以是表中字段，也可以是自定义字符，其间用逗号<code>,</code>分割。</p>
<p>例如：其中有表的字段<code>vend_name</code>、<code>vend_country</code>，也有<code>(</code>、<code>)</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(vend_name，<span class="string">' ( '</span>, vend_country，<span class="string">')'</span>)<span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name ;</span><br></pre></td></tr></table></figure>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>刚才创建的新字段实际上是没有名字的，而需要给他给一个名字，即别名（不止新字段可以指定别名，存在于表中的字段也可以指定别名）。其采用关键字<code>AS</code>来指定。</p>
<p>如：给新字段指定了别名<code>vend_title</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name)，<span class="string">'('</span>，<span class="keyword">RTrim</span>(vend_country)，<span class="string">')'</span>) <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>
<h2 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h2><p>不仅可以用<code>Concat(...)</code>来拼接字段，还可以使用算数运算符来获得新的数字字段。</p>
<p>例如：利用乘法计算新字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id，</span><br><span class="line">quantity,item_price，</span><br><span class="line">quantity*item_price <span class="keyword">As</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<p>下面是具体所有的操作符：</p>
<p><img src="\images\MySQL必知必会\正则表达式-算术操作符.jpg" alt="正则表达式-算术操作符"></p>
<h1 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h1><p>MySQL包含了很多处理函数。</p>
<h2 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h2><p>字符处理函数包含以下：</p>
<p><img src="\images\MySQL必知必会\正则表达式-文本处理函数1.jpg" alt="正则表达式-文本处理函数1"></p>
<p><img src="\images\MySQL必知必会\正则表达式-文本处理函数2.jpg" alt="正则表达式-文本处理函数2"></p>
<p>其中<code>Soundex()</code>是读音类似的一个处理函数。这个一般是用于英语。</p>
<h2 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h2><p>对于日期和时间，MySQL也内置了一些函数。所有的函数如下：</p>
<p><img src="\images\MySQL必知必会\正则表达式-常用日期和时间处理函数.jpg" alt="正则表达式-常用日期和时间处理函数"></p>
<p><strong>值得注意的是：无论什么时候指定一个日期，不管插入或更新表值还是用<code>WHERE</code>语句进行过滤，日期必须为格式<code>yyyy-mm-dd</code>。</strong></p>
<p>因此，基本的日期比较简单：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id，order_numFROM orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date = <span class="string">'2005-09-01'</span>;</span><br></pre></td></tr></table></figure>
<p>利用<code>Datr()</code>函数可以创建一个日期时间的日期部分。如一个值<code>dt</code>在表中为一个<code>DateTime</code>类型，假设其为<code>2022-02-02 08:08:08</code>。则<code>Date(dt)</code>就为<code>2022-02-02</code></p>
<p>而日期之间可以用<code>BETWEEN AND</code>来筛选确定日期范围内的列。</p>
<p>如：筛选生日在<code>2001年2月1日</code>到<code>2002年2月4日</code>之间的列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> birthday <span class="keyword">BETWEEN</span> <span class="string">'2001-2-1'</span> <span class="keyword">AND</span> <span class="string">'2002-2-4'</span></span><br></pre></td></tr></table></figure>
<h2 id="数字处理函数"><a href="#数字处理函数" class="headerlink" title="数字处理函数"></a>数字处理函数</h2><p>下面是所有的处理函数：</p>
<p><img src="\images\MySQL必知必会\正则表达式-数值处理函数.jpg" alt="正则表达式-数值处理函数"></p>
<h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><p>又是仅仅需要获得数据的一些汇总，而并不是数据本身，如数量等。</p>
<p>MySQL也涉及相关的函数，具体如下：</p>
<p><img src="\images\MySQL必知必会\正则表达式-聚集函数.jpg" alt="正则表达式-聚集函数"></p>
<h2 id="汇聚不同值"><a href="#汇聚不同值" class="headerlink" title="汇聚不同值"></a>汇聚不同值</h2><p>对于所有的聚集函数，可以指定两个参数来表示计算的值：</p>
<ul>
<li><code>ALL</code>（默认）：所有的值都将被计算。</li>
<li><code>DISTINCT</code>：只计算不同的值。</li>
</ul>
<p>例如：表示统计不同<code>name</code>的所有列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">name</span>) <span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure>
<h2 id="多个汇集函数"><a href="#多个汇集函数" class="headerlink" title="多个汇集函数"></a>多个汇集函数</h2><p>汇集函数就可以多个同时使用。</p>
<p>如：同时使用了4个汇聚函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_items,</span><br><span class="line"><span class="keyword">MIN</span>(prod_price) <span class="keyword">As</span> price_min,<span class="keyword">MAX</span>(prod_price) <span class="keyword">AS</span> price_max,<span class="keyword">AVG</span>(prod_price) <span class="keyword">As</span> price_avg</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
<h1 id="组合汇聚函数"><a href="#组合汇聚函数" class="headerlink" title="组合汇聚函数"></a>组合汇聚函数</h1><p>还可以嵌套组合汇聚函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">COUNT</span>(car1), <span class="keyword">COUNT</span>(car2), <span class="keyword">COUNT</span>(car3), <span class="keyword">COUNT</span>(car4)) <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure>
<p>汇聚函数可以嵌套组合，如上，先统计每种车类型的数量，然后统计其平均数（虽然一般不会这些设计表，只是示例用法）。</p>
<p>使用别名可以更清晰一些。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(car1) <span class="keyword">AS</span> c1, <span class="keyword">COUNT</span>(car2) <span class="keyword">AS</span> c2, <span class="keyword">COUNT</span>(car3) <span class="keyword">AS</span> c3, <span class="keyword">COUNT</span>(car4) <span class="keyword">AS</span> c4, <span class="keyword">AVG</span>(c1, c2, c3, c4) <span class="keyword">AS</span> carAvg <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程编程核心技术-4-Lock对象的使用</title>
    <url>/2022/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-4-Lock%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>Java多线程可以使用synchronized关键字来实现线程间同步，不过JDK 1.5新增加的ReentrantLock类也能达到同样的效果，并且在扩展功能上更加强大，如具有嗅探锁定、多路分支通知等功能。</p>
<h2 id="ReentrantLock类"><a href="#ReentrantLock类" class="headerlink" title="ReentrantLock类"></a>ReentrantLock类</h2><p>可以直接new一个ReentranLock。然后再后面的方法中使用该对象的方法来进行同步处理。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>
<h2 id="lock-方法"><a href="#lock-方法" class="headerlink" title="lock()方法"></a>lock()方法</h2><p>lock方法用于锁定当前的ReentrantLock对象。在此之后，所有的方法都是同步运行的了。与synchoronized代码块一样，其他调用该lock锁的代码都会被同步，等待该锁释放。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">//后面的代码都会同步执行</span></span><br></pre></td></tr></table></figure>
<h2 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h2><p>public boolean tryLock()方法的作用是嗅探拿锁，如果当前线程发现锁被其他线程持有了，则返回false，程序继续执行后面的代码，而不是呈阻塞等待锁的状态。</p>
<p>例如：</p>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获得锁"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"没有获得锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> service.MyService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyService service = <span class="keyword">new</span> MyService();</span><br><span class="line"></span><br><span class="line">        Runnable runnableRef = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                service.waitMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(runnableRef);</span><br><span class="line">        threadA.setName(<span class="string">"A"</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(runnableRef);</span><br><span class="line">        threadB.setName(<span class="string">"B"</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A获得锁</span><br><span class="line">B没有获得锁</span><br></pre></td></tr></table></figure>
<p>注意这里为synchoronized不具有的方法，即尝试获取锁，如果没获得，就继续执行下去，而不是阻塞。</p>
<h2 id="tryLock-long-timeout-TimeUnit-unit"><a href="#tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="tryLock(long timeout, TimeUnit unit)"></a>tryLock(long timeout, TimeUnit unit)</h2><p>这里的方法与上面方法一样，但这里加了延迟时间。如果当前线程在指定的timeout内持有了锁，则返回值是true，超过时间则返回false。参数timeout代表当前线程抢锁的时间。</p>
<h2 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h2><p>public void lockInterruptibly()方法的作用是当某个线程尝试获得锁并且阻塞在lockInterrup-tibly()方法时，该线程可以被中断。</p>
<h2 id="unlock-方法"><a href="#unlock-方法" class="headerlink" title="unlock()方法"></a>unlock()方法</h2><p>unlock方法会解除该锁，也就是说，后面的代码不再受该该锁的限制，可以异步执行了。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 同步代码</span></span><br><span class="line">lock.unlock();</span><br><span class="line"><span class="comment">// 异步代码</span></span><br></pre></td></tr></table></figure>
<h2 id="整体例子"><a href="#整体例子" class="headerlink" title="整体例子"></a>整体例子</h2><p>服务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName()</span><br><span class="line">                    + (<span class="string">" "</span> + (i + <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> service.MyService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(MyService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.testMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> service.MyService;</span><br><span class="line"><span class="keyword">import</span> extthread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyService service = <span class="keyword">new</span> MyService();</span><br><span class="line"></span><br><span class="line">        MyThread a1 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line">        MyThread a2 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line">        MyThread a3 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line">        MyThread a4 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line">        MyThread a5 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line"></span><br><span class="line">        a1.start();</span><br><span class="line">        a2.start();</span><br><span class="line">        a3.start();</span><br><span class="line">        a4.start();</span><br><span class="line">        a5.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadName-Thread-01</span><br><span class="line">ThreadName-Thread-02</span><br><span class="line">ThreadName-Thread-O3</span><br><span class="line">ThreadName-Thread-04</span><br><span class="line">THreadName-Thread-05</span><br><span class="line">ThreadName-Thread-41</span><br><span class="line">ThreadName-Thread-42</span><br><span class="line">ThreadName-Thread-43</span><br><span class="line">ThreadName-Thread-44</span><br><span class="line">ThreadNane-Thread-45</span><br><span class="line">ThreadName-Thread-11</span><br><span class="line">ThreadName-Thread-12</span><br><span class="line">ThreadName-Thread-13</span><br><span class="line">ThreadName&#x3D;Thread-14</span><br><span class="line">ThreadName-Thread-15</span><br><span class="line">ThreadName&#x3D;Thread-21</span><br><span class="line">ThreaaName-Threaa-22</span><br><span class="line">ThreadName-Thread-23</span><br><span class="line">ThreadName-Thread-24</span><br><span class="line">ThreadName-Thread-25</span><br><span class="line">ThreadName-Tnread-31</span><br><span class="line">ThreadName-Thread-32</span><br><span class="line">ThreadName-Thread-33</span><br><span class="line">ThreadName-Thread-34</span><br><span class="line">ThreadName-Thread-35</span><br></pre></td></tr></table></figure>
<p>从程序运行结果来看，只有当当前线程输出完毕之后将锁释放，其他线程才可以继续抢锁并输出，每个线程内输出的数据是有序的，从1到5，因为当前线程已经持有锁，具有互斥排他性，但线程之间输出的顺序是随机的，即谁抢到锁，谁输出。</p>
<h1 id="condition对象"><a href="#condition对象" class="headerlink" title="condition对象"></a>condition对象</h1><p>关键字synchronized与wait()、notify()/notifyAll()方法相结合可以实现wait/notify模式，ReentrantLock类也可以实现同样的功能，但需要借助于Condition对象。Condition类是JDK 5的技术，具有更好的灵活性，例如，可以实现多路通知功能，也就是在一个Lock对象中可以创建多个Condition实例，线程对象注册在指定的Condition中，从而可以有选择性地进行线程通知，在调度线程上更加灵活。</p>
<h2 id="await-方法"><a href="#await-方法" class="headerlink" title="await()方法"></a>await()方法</h2><p>await方法与synchonized的wait方法类似。调用该方法可以使线程进入到wait状态。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">" await时间为"</span> + System.currentTimeMillis());</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的调用await方法机会调用对应Condition对象的await方法。使线程进入wait状态。直到该Condtition的signal/signalAll方法被调用，才会将其进行唤醒。</p>
<h2 id="signal-方法"><a href="#signal-方法" class="headerlink" title="signal()方法"></a>signal()方法</h2><p>signal()与synchonized的notify方法类似。即唤醒等待队列中的其中一个线程。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"signal时间为"</span> + System.currentTimeMillis());</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="signalAll-方法"><a href="#signalAll-方法" class="headerlink" title="signalAll()方法"></a>signalAll()方法</h2><p>同样的，signalAll()方法类似于synchonized的notifyAll()方法。即唤醒所有的等待该Condition的线程。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"signal时间为"</span> + System.currentTimeMillis());</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><p>公平锁：采用先到先得的策略，每次获取锁之前都会检查队列里面有没有排队等待的线程，没有才会尝试获取锁，如果有就将当前线程追加到队列中。</p>
<p>非公平锁：采用“有机会插队”的策略，一个线程获取锁之前要先去尝试获取锁而不是在队列中等待，如果获取锁成功，则说明线程虽然是后启动的，但先获得了锁，这就是“作弊插队”的效果。如果获取锁没有成功，那么才将自身追加到队列中进行等待。</p>
<p>而ReentrantLock默认是非公平锁，与synchoronized一致，也可以在构造函数中传入一个布尔参数来构造出公平锁。</p>
<p>即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h1 id="相关的方法"><a href="#相关的方法" class="headerlink" title="相关的方法"></a>相关的方法</h1><h2 id="Lock-public-int-getHoldCount"><a href="#Lock-public-int-getHoldCount" class="headerlink" title="Lock-public int getHoldCount()"></a>Lock-public int getHoldCount()</h2><p>public int getHoldCount()方法的作用是查询“当前线程”保持此锁定的个数，即调用lock()方法的次数。</p>
<h2 id="Lock-public-final-int-getQueueLength"><a href="#Lock-public-final-int-getQueueLength" class="headerlink" title="Lock-public final int getQueueLength()"></a>Lock-public final int getQueueLength()</h2><p>public final int getQueueLength()方法的作用是返回正等待获取此锁的线程估计数，例如，这里有5个线程，其中1个线程长时间占有锁，那么调用getQueueLength()方法后，其返回值是4，说明有4个线程同时在等待锁的释放。</p>
<h2 id="Lock-public-int-getWaitQueueLength（Condition-condition）"><a href="#Lock-public-int-getWaitQueueLength（Condition-condition）" class="headerlink" title="Lock-public int getWaitQueueLength（Condition condition）"></a>Lock-public int getWaitQueueLength（Condition condition）</h2><p>public int getWaitQueueLength（Condition condition）方法的作用是返回等待与此锁相关的给定条件Condition的线程估计数。例如，这里有5个线程，每个线程都执行了同一个Condition对象的await()方法，则调用getWaitQueueLength（Condition condition）方法时，其返回的int值是5。</p>
<h2 id="Lock-public-final-boolean-hasQueuedThread（Thread-thread）"><a href="#Lock-public-final-boolean-hasQueuedThread（Thread-thread）" class="headerlink" title="Lock-public final boolean hasQueuedThread（Thread thread）"></a>Lock-public final boolean hasQueuedThread（Thread thread）</h2><p>public final boolean hasQueuedThread（Thread thread）方法的作用是查询指定的线程是否正在等待获取此锁，也就是判断参数中的线程是否在等待队列中。</p>
<h2 id="Lock-public-final-boolean-hasQueued-Threads"><a href="#Lock-public-final-boolean-hasQueued-Threads" class="headerlink" title="Lock-public final boolean hasQueued-Threads()"></a>Lock-public final boolean hasQueued-Threads()</h2><p>public final boolean hasQueuedThreads()方法的作用是查询是否有线程正在等待获取此锁，也就是等待队列中是否有等待的线程。</p>
<h2 id="Lock-public-boolean-hasWaiters（Condition-condition）"><a href="#Lock-public-boolean-hasWaiters（Condition-condition）" class="headerlink" title="Lock-public boolean hasWaiters（Condition condition）"></a>Lock-public boolean hasWaiters（Condition condition）</h2><p>public boolean hasWaiters（Condition condition）方法的作用是查询是否有线程正在等待与此锁有关的condition条件，也就是是否有线程执行了condition对象中的await()方法而呈等待状态。而public int getWaitQueueLength（Condition condition）方法的作用是返回有多少个线程执行了condition对象中的await()方法而呈等待状态。</p>
<h2 id="Lock-public-final-boolean-isFair"><a href="#Lock-public-final-boolean-isFair" class="headerlink" title="Lock-public final boolean isFair()"></a>Lock-public final boolean isFair()</h2><p>public final boolean isFair()方法的作用是判断是不是公平锁。</p>
<h2 id="Lock-public-boolean-isHeldByCurrentThread"><a href="#Lock-public-boolean-isHeldByCurrentThread" class="headerlink" title="Lock-public boolean isHeldByCurrentThread()"></a>Lock-public boolean isHeldByCurrentThread()</h2><p>public boolean isHeldByCurrentThread()方法的作用是查询当前线程是否保持此锁。</p>
<h2 id="Lock-public-boolean-isLocked"><a href="#Lock-public-boolean-isLocked" class="headerlink" title="Lock-public boolean isLocked()"></a>Lock-public boolean isLocked()</h2><p>public boolean isLocked()方法的作用是查询此锁是否由任意线程保持，并没有释放。</p>
<h2 id="Lock-public-boolean-await（long-time，TimeUnit-unit）-重要"><a href="#Lock-public-boolean-await（long-time，TimeUnit-unit）-重要" class="headerlink" title="Lock-public boolean await（long time，TimeUnit unit）-重要"></a>Lock-public boolean await（long time，TimeUnit unit）-重要</h2><p>public boolean await（long time，TimeUnit unit）方法的作用和public final native void wait（long timeout）方法一样，都具有<strong>自动唤醒线程</strong>的功能。即在规定时间内没有线程对其进行唤醒，则自动进行唤醒。</p>
<h2 id="Lock-public-long-awaitNanos（long-nanosTimeout）"><a href="#Lock-public-long-awaitNanos（long-nanosTimeout）" class="headerlink" title="Lock-public long awaitNanos（long nanosTimeout）"></a>Lock-public long awaitNanos（long nanosTimeout）</h2><p>public long awaitNanos（long nanosTimeout）方法的作用和public final native void wait（long timeout）方法一样，都具有自动唤醒线程的功能，不过时间单位是纳秒（ns）。</p>
<h2 id="Lock-public-boolean-awaitUntil（Date-deadline）-重要"><a href="#Lock-public-boolean-awaitUntil（Date-deadline）-重要" class="headerlink" title="Lock-public boolean awaitUntil（Date deadline）-重要"></a>Lock-public boolean awaitUntil（Date deadline）-重要</h2><p>public boolean awaitUntil（Date deadline）方法的作用是在<strong>指定的Date结束等待</strong>。</p>
<h2 id="Lock-public-void-awaitUninterruptibly"><a href="#Lock-public-void-awaitUninterruptibly" class="headerlink" title="Lock-public void awaitUninterruptibly()"></a>Lock-public void awaitUninterruptibly()</h2><p>public void awaitUninterruptibly()方法的作用是<strong>实现线程在等待的过程中，不允许被中断</strong>。</p>
<h1 id="ReentrantReadWriteLock类"><a href="#ReentrantReadWriteLock类" class="headerlink" title="ReentrantReadWriteLock类"></a>ReentrantReadWriteLock类</h1><p>ReentrantLock类具有完全互斥排他的效果，同一时间只有一个线程在执行ReentrantLock.lock()方法后面的任务，这样做虽然保证了同时写实例变量的线程安全性，但效率是非常低下的，所以JDK提供了一种读写锁——ReentrantReadWriteLock类，使用它可以在进行读操作时不需要同步执行，提升运行速度，加快运行效率。</p>
<p>读写锁有两个锁：一个是读操作相关的锁，也称共享锁；另一个是写操作相关的锁，也称排他锁。</p>
<p>读锁之间不互斥，读锁和写锁互斥，写锁与写锁互斥，因此只要出现写锁，就会出现互斥同步的效果。</p>
<p>读操作是指读取实例变量的值，写操作是指向实例变量写入值。</p>
<h2 id="ReentrantLock类的缺点"><a href="#ReentrantLock类的缺点" class="headerlink" title="ReentrantLock类的缺点"></a>ReentrantLock类的缺点</h2><p>与ReentrantReadWriteLock类相比，ReentrantLock类的主要缺点是使用ReentrantLock对象时，所有的操作都同步，哪怕只对实例变量进行读取操作，这样会耗费大量的时间，降低运行效率。</p>
<h2 id="ReentrantReadWriteLock类的使用"><a href="#ReentrantReadWriteLock类的使用" class="headerlink" title="ReentrantReadWriteLock类的使用"></a>ReentrantReadWriteLock类的使用</h2><h3 id="读读共享"><a href="#读读共享" class="headerlink" title="读读共享"></a>读读共享</h3><p>由于读并不会改变数据内容，所以相当于可异步操作。因此这个锁可以共享。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> String username = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.readLock().lock();			<span class="comment">// 获取读锁</span></span><br><span class="line">            System.out.println(<span class="string">"begin "</span> + Thread.currentThread().getName() + <span class="string">" "</span> + System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">"print service "</span> + username);</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            System.out.println(<span class="string">"  end "</span> + Thread.currentThread().getName() + <span class="string">" "</span> + System.currentTimeMillis());</span><br><span class="line">            lock.readLock().unlock();		<span class="comment">// 解除读锁</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写写互斥"><a href="#写写互斥" class="headerlink" title="写写互斥"></a>写写互斥</h3><p>由于写会改变数据内容，因此需要进行同步处理，这里可以获得一个排他锁。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.writeLock().lock();</span><br><span class="line">                System.out.println(<span class="string">"获得写锁"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">" "</span> + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获得写锁A1414899878671</span><br><span class="line">获得写锁B1414899888671</span><br></pre></td></tr></table></figure>
<h3 id="读写互斥、写读互斥"><a href="#读写互斥、写读互斥" class="headerlink" title="读写互斥、写读互斥"></a>读写互斥、写读互斥</h3><p>实际上只要涉及到写操作，即修改数据，那么就必定需要排他锁。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(<span class="string">"获得读锁"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">" "</span> + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.writeLock().lock();</span><br><span class="line">                System.out.println(<span class="string">"获得写锁"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">" "</span> + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> service.Service;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadA;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Service service = <span class="keyword">new</span> Service();</span><br><span class="line"></span><br><span class="line">        ThreadA a = <span class="keyword">new</span> ThreadA(service);</span><br><span class="line">        a.setName(<span class="string">"A"</span>);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(service);</span><br><span class="line">        b.setName(<span class="string">"B"</span>);</span><br><span class="line">        b.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获得读锁1414899977328</span><br><span class="line">获得写锁1414899987328</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="ReentrantLock与synchoronized的相同点"><a href="#ReentrantLock与synchoronized的相同点" class="headerlink" title="ReentrantLock与synchoronized的相同点"></a>ReentrantLock与synchoronized的相同点</h3><ul>
<li>ReentrantLock与synchoronized都默认是非公平锁。</li>
<li>ReentrantLock与synchoronized都默认是可重入锁。</li>
<li>Object类中的wait()方法相当于Condition类中的await()方法。</li>
<li>Object类中的wait（long timeout）方法相当于Condition类中的await（long time，TimeUnit unit）方法。</li>
<li>Object类中的notify()方法相当于Condition类中的signal()方法。</li>
<li>Object类中的notifyAll()方法相当于Condition类中的signalAll()方法。</li>
</ul>
<h3 id="ReentrantLock与synchoronized的不同点"><a href="#ReentrantLock与synchoronized的不同点" class="headerlink" title="ReentrantLock与synchoronized的不同点"></a>ReentrantLock与synchoronized的不同点</h3><ul>
<li>synchronized是关键字属于JVM层面，Lock是具体类是api层面的锁。</li>
<li>synchronized是重量级锁，重量级锁需要将线程从内核态和用户态来回切换。而ReentrantLock是轻量级锁。</li>
<li><p>synchronized不需要用户去手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用。需要lock,unlock配合try finally完成。</p>
</li>
<li><p>Condition支持不响应中断，而Object不支持，也就是Object只要有中断就要响应。</p>
</li>
<li>Condition支持多个等待队列（new多个Condition对象），而Object只有一个等待队列，但两者都只要一个同步队列；即可以实现分组唤醒线程。</li>
<li>Condition支持截止时间设置，而Object是超时时间设置，支持截止时间设置，不用计算需要等多久。</li>
</ul>
<h2 id="ReentrantLock缺点"><a href="#ReentrantLock缺点" class="headerlink" title="ReentrantLock缺点"></a>ReentrantLock缺点</h2><ul>
<li><p>lock 必须在 finally 块中释放。否则，如果受保护的代码将抛出异常，锁就有可能永远得不到释放！这一点区别看起来可能没什么，但是实际上，它极为重要。忘记在 finally 块中释放锁，可能会在程序中留下一个定时炸弹，当有一天炸弹爆炸时，您要花费很大力气才有找到源头在哪。而使用同步，JVM 将确保锁会获得自动释放。</p>
</li>
<li><p>当 JVM 用 synchronized 管理锁定请求和释放时，JVM 在生成线程时能够包括锁定信息。这些对调试非常有价值，因为它们能标识死锁或者其他异常行为的来源。 Lock 类只是普通的类，JVM 不知道具体哪个线程拥有 Lock 对象，不方便调试。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java多线程编程核心技术</category>
      </categories>
      <tags>
        <tag>Java多线程编程核心技术</tag>
        <tag>Lock对象的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL必知必会13-18-高级检索知识</title>
    <url>/2022/02/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A13-18-%E9%AB%98%E7%BA%A7%E6%A3%80%E7%B4%A2%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><p>分组数据可以用于按照某一列数据作为分类标准来统计数据。所以其一般与聚集函数一起用。</p>
<h2 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h2><p>分组是使用<code>SELECT</code>子句和<code>GROUP BY</code>子句建立。</p>
<p>例如：统计每个<code>vend_id</code>的数据数量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods <span class="keyword">FROM</span> products <span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure>
<p>将语句分为两部分，</p>
<ul>
<li><code>SELECT vend_id, COUNT(*) AS num_prods FROM products</code></li>
<li><code>GROUP BY vend_id</code></li>
</ul>
<p>可以看作是先统计了总数，然后将总数按照<code>vend_id</code>分类。其结果可能如下：</p>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>num_prods</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>3</td>
</tr>
<tr>
<td>1002</td>
<td>2</td>
</tr>
<tr>
<td>1003</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>因为使用了<code>GROUP BY</code>，就不必指定要计算和估值的每个组了。系统会自动完成。<code>GROUP BY</code>子句指示<code>MySQL</code>分组数据，然后<strong>对每个组而不是整个结果集进行聚集</strong>。</p>
<p>在具体使用<code>GROUP BY</code>子句前，需要知道一些重要的规定。</p>
<ul>
<li><code>GROUP BY</code>子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更加细致的控制。</li>
<li>如果在<code>GROUP BY</code>子句中嵌套了分组，数据将在最后规定的分组上进行汇总，换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li><code>GROUP BY</code>子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。<strong>如果在<code>SELECT</code>中使用表达式，则必须在<code>GROUP BY</code>子句中指定相同的表达式。不能使用别名。</strong></li>
<li>除聚集计算语句外，<code>SELECT</code>语句中的每个列都必须在<code>GROUP BY</code>子句中给出。</li>
<li>如果分组列中具有NULL值，则NULL值将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>
<li><code>GROUP BY</code>子句必须出现在<code>WHERE</code>子句之后，<code>ORDER BY</code>子句之前。</li>
</ul>
<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>分组过滤允许<code>GROUP BY</code>得出的分组进行过滤，规定得到哪些分组，排除哪些分组。</p>
<p><code>WHERE</code>子句不能对其进行过滤，因为分组是针对行的，而不是针对分组的。事实上，<code>WHERE</code>没有分组的概念。</p>
<p>MySQL提供了<code>HAVING</code>子句，<code>HAVING</code>非常类似于<code>WHERE</code>。只不过<code>WHERE</code>过滤行，<code>HAVING</code>过滤分组。</p>
<h3 id="HAVING和WHERE"><a href="#HAVING和WHERE" class="headerlink" title="HAVING和WHERE"></a><code>HAVING</code>和<code>WHERE</code></h3><ul>
<li>实际上有关<code>WHERE</code>的所有这些技术和选项都适用于<code>HAVING</code>。它们的句法是相同的，只是关键字有差别。</li>
<li>另一种理解方式是<code>WHERE</code>在数据分组前进行过滤，<code>HAVING</code>在数据分组后进行过滤。</li>
<li><strong>基于上面一条，可以得：<code>WHERE</code>用于筛选数据表中的字段，而<code>HAVING</code>用于筛选前面确定的字段（临时表的一部分）。</strong></li>
</ul>
<h3 id="分组过滤例子"><a href="#分组过滤例子" class="headerlink" title="分组过滤例子"></a>分组过滤例子</h3><ol>
<li><p>单使用<code>HAVING</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> orders <span class="keyword">FROM</span> orders <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>该语句增加了一个<code>HAVING COUNT(*) &gt;= 2</code>子句。所以其意义是按照<code>cust_id</code>分组然后筛选分组中总数<code>COUNT(*)</code>大于等于2的分组。</p>
</li>
<li><p>同时使用<code>WHERE</code>和<code>HAVING</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &gt;= <span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这里在前面加了<code>WHERE prod_price &gt;= 10</code>子句，如上所说，<code>WHERE</code>在分组统计之前进行计算，所以后面的统计中就不再包含<code>prod_price &lt; 10</code>的数据。然后将统计出的数据按照<code>COUNT(*) &gt; 2</code>进行分组过滤。</p>
</li>
</ol>
<h3 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h3><p><code>GROUP BY</code>和<code>ORDERED BY</code>子句的区别：</p>
<table>
<thead>
<tr>
<th>OEDERED BY</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody>
<tr>
<td>排序产生的输出</td>
<td>分组行。但输出可能不是分组的顺序</td>
</tr>
<tr>
<td>任意行都可以使用（甚至非选择的列也可以使用）</td>
<td>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td>
</tr>
<tr>
<td>不一定需要</td>
<td>如果于聚集函数一起使用列（或表达式），则必须使用</td>
</tr>
</tbody>
</table>
<p><code>GROUP BY</code>和<code>ORDERED BY</code>可以一起使用，可以先将数据筛选出来，然后按某列数据（可能是聚集的那列数据）对筛选的数据进行排序。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="keyword">SUM</span>(quantity * itenm_price) <span class="keyword">AS</span> ordertotal <span class="keyword">FROM</span> orderitems <span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num <span class="keyword">HAVING</span> <span class="keyword">SUM</span>(quantity * itenm_price) &gt;= <span class="number">50</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ordertotal;</span><br></pre></td></tr></table></figure>
<h2 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h2><p>下表中从上到小是<code>SELECT</code>中子句的出现顺序。</p>
<table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody>
</table>
<h1 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h1><p>MySQL在4.1版本引入了子查询功能。</p>
<p>SELECT语句是单个SQL的查询。迄今为止我们看到的SELECT语句都是简单查询，即从单个数据表中检索数据的单条语句。</p>
<p>SQL还允许创建子查询，即嵌套在其他查询中的查询。</p>
<h2 id="使用子查询进行过滤"><a href="#使用子查询进行过滤" class="headerlink" title="使用子查询进行过滤"></a>使用子查询进行过滤</h2><p>订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。</p>
<p>现在，假如需要列出订购物品TNT2的所有客户，应该怎样检索?下面列出具体的步骤。</p>
<p>(1)检索包含物品TNT2的所有订单的编号。</p>
<p>(2)检索具有前一步骤列出的订单编号的所有客户的ID。</p>
<p>(3)检索前一步骤返回的所有客户ID的客户信息。</p>
<p>上述每个步骤都可以单独作为一个查询来执行。可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。</p>
<ol>
<li><p><code>SELECT order_num FROM orderitems WHERE prod_id = &#39;TNT2&#39;</code></p>
<p>| order_num |<br>| ——— |<br>| 20005     |<br>| 20007     |</p>
</li>
</ol>
<ol start="2">
<li><p><code>SELECT cust_id FROM orders WHERE order_num IN (20005, 20007)</code></p>
<p>| cust_id |<br>| ——- |<br>| 10001   |<br>| 10004   |</p>
</li>
<li><p><code>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001, 10004)</code></p>
<p>| cust_name      | cust_contact |<br>| ————– | ———— |<br>| Coyote Inc.    | Y Lee        |<br>| Yosemite Plcae | Y sam        |</p>
</li>
</ol>
<h3 id="合并子句"><a href="#合并子句" class="headerlink" title="合并子句"></a>合并子句</h3><ol>
<li><p>合并子句1和子句2得到子句4</p>
<p>现在考虑合并第一个第二个子句。实际上就是将第二个子句中的数据用第一个子句来替换，并且用括号使之先进行计算。如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>)</span><br></pre></td></tr></table></figure>
<p>| cust_id |<br>| ——- |<br>| 10001   |<br>| 10004   |</p>
</li>
<li><p>合并子句4和子句3</p>
<p>用同样的方法得到合并子句4和子句3：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> cust_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span></span><br><span class="line">    ));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为了执行上面的语句，MySQL实际上必须执行3条<code>SELECT</code>语句。最里面返回订单号列表，此列表用于最外面的子查询的<code>WHERE</code>子句。次外面的子查询返回客户ID列表。此客户ID列表用于最外层查询的<code>WHERE</code>子句。最外层查询才返回所需的数据。    </p>
<p>可见，在WHERE子句中使用子查询能够编写出功能强大并且很灵活的SQL语句。对于嵌套子查询的数目没有限制，不过在实际使用时由于性能的限制，最好不要嵌套太多的子查询。</p>
<p>注意：在<code>WHERE</code>子句中使用子查询，应该保证<code>SELECT</code>语句具有与<code>WHERE</code>子句中相同数目的列。通常，子查询将返回当单个列并且与单个列匹配，但如果需要也可以使用多个列。</p>
<p>虽然子查询一般与IN操作符相结合，但也可以用于测试等于（=）、不等于（&lt;&gt;）等。</p>
<h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><p>使用子查询的另一方法是创建计算字段。假设需要显示customers表中的每个客户的订单总数。订单与相应的客户ID存储在orders表中。</p>
<p>为了执行整个操作，遵循下面的步骤：</p>
<ol>
<li>从costumers表中检测客户列表。</li>
<li>对于检索出的每个客户，统计其在orders表中的订单数目。</li>
</ol>
<p>同样写出如果分开查询的步骤：</p>
<ol>
<li><p><code>SELECT COUNT(*) AS orders FROM orders WHERE cust_id = 10001</code></p>
<p>| orders |<br>| —— |<br>| 2      |</p>
</li>
<li><p><code>SELECT cust_name, cust_state FROM customers ORDER BY cust_name</code></p>
<p>| cust_name   | cust_status |<br>| ———– | ———– |<br>| Coyote Inc. | MI          |<br>| E fudd      | IL          |<br>| Mouse House | IN          |</p>
</li>
</ol>
<h3 id="合并子句-1"><a href="#合并子句-1" class="headerlink" title="合并子句"></a>合并子句</h3><p>现在将1，2合并，与上面不同，子句不作为筛选条件，而是一个计算属性。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_state, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> orders.cust_id = customers.cust_id) <span class="keyword">AS</span> orders <span class="keyword">FROM</span> customers <span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>cust_name</th>
<th>cust_status</th>
<th>oders</th>
</tr>
</thead>
<tbody>
<tr>
<td>Coyote Inc.</td>
<td>MI</td>
<td>2</td>
</tr>
<tr>
<td>E fudd</td>
<td>IL</td>
<td>1</td>
</tr>
<tr>
<td>Mouse House</td>
<td>IN</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>注意这里的第三个属性是通过一个子查询得到的一个计算属性，<strong>注意这里子查询中的<code>WHERE</code>语句的条件，其会自动判断当前外层筛选出<code>oders</code>表中的行的<code>cust_id</code>，然后和<code>customers</code>表的<code>cust_id</code>进行比较。且必须加上限定名，如果不加上限定名，MySQL就会假设是将<code>oders</code>表中的<code>cust_id</code>进行自身匹配</strong>。</p>
<p>所以注意：虽然子查询在构造<code>SELECT</code>语句时极其有用，但必须注意限制有歧义性的列名。</p>
<p>技巧：对于子查询这种技术，可以嵌套很多层进行很强大的查询。但是为了在很多嵌套时其仍然保持正确，可以按照从内向外的调试技巧，即先从内部查询开始调试，一层层的增加，可以有效减少错误率。</p>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。</p>
<h2 id="为什么要联结表"><a href="#为什么要联结表" class="headerlink" title="为什么要联结表"></a>为什么要联结表</h2><p>分解数据为多个表能够有效地存储、更方便地处理，并且具有更加强大的可伸缩性。但是分解后数据也随之分解，为检索制造了很多麻烦。</p>
<p>而使用联结可以将多个表结合在一起。可以在一条<code>SELECT</code>语句中关联表。</p>
<h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price <span class="keyword">FROM</span> vendors, products <span class="keyword">WHERE</span> venders.vend_id = products.vend_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>vend_name</th>
<th>prod_name</th>
<th>prod_price</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACME</td>
<td>Bird seed</td>
<td>10.00</td>
</tr>
<tr>
<td>ACME</td>
<td>Carrots</td>
<td>2.50</td>
</tr>
<tr>
<td>ACME</td>
<td>Detonator</td>
<td>13.00</td>
</tr>
</tbody>
</table>
<p>这条语句的关键是<code>WHERE</code>子句，其指定了联立表的条件。</p>
<p>注意要匹配的两个列以<code>venders.vend_id</code>和<code>products.vend_id</code>来指定。这里需要这种完全限定名，因为如果只给出<code>vend_id</code>，则MySQL不知道指定的是两张表中的哪一个。</p>
<p><strong>在列可能出现二义性的时候，必须使用完全限定名。</strong>如果引用一个没有用表名限定的具有二义性的列名，则MySQL经返回错误结果。</p>
<h2 id="WHERE子句的重要性"><a href="#WHERE子句的重要性" class="headerlink" title="WHERE子句的重要性"></a><code>WHERE</code>子句的重要性</h2><p>利用WHERE子句建立联结关系似乎有点奇怪，但实际上，有一个很充分的理由。请记住，在一条SELECT语句中联结几个表时，相应的关系是 在运行中构造的。在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。你必须自己做这件事情。在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管 它们逻辑上是否可以配在一起。</p>
<p><strong>笛卡尔积</strong>：由没有联结条件的表返回的结果为笛卡尔积。检索出的行数将是第一个表中的行数乘以第二个表中的行数（即将第一张表中的所有数据与第二张表中所有数据进行组合，因为没有限定条件指定两张表中的哪些数据应该被指定）。</p>
<h2 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h2><p>目前为止所用的联结称为等值联结（equal join），它基于两个表之间的相等测试。<strong>这种联结也称为内部联结</strong>。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。下面的SELECT语句返回与前面使用<code>where =</code>的例子完全相同的数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name，prod_name，prod_price <span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<p>这种语法将联结条件通过<code>ON</code>关键词来指定，并且由<code>INNER JOIN</code>给出要联立的两张表。</p>
<h2 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h2><p>SQL对一条<code>SELECT</code>语句可以联结的表的数目没有限制。创建多张表联结的规则基本相同：首先列出所有的表，然后定义表的关系，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, vend_name, prod_price, quantity <span class="keyword">FROM</span> orderitems, products, vendors <span class="keyword">WHERE</span> products.vend_id = vendors.vend_id <span class="keyword">AND</span> orderitems.prod_id = products.pord_id <span class="keyword">AND</span> order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<p>此语句联立了3张表，<code>orderitems</code>、<code>products</code>和<code>vendors</code>。并且通过<code>WHERE</code>指定了两个联立条件和一个值限定条件。</p>
<p>性能考虑：MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常消耗资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。</p>
<p>考虑子查询中的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (    <span class="keyword">SELECT</span> cust_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span>(        <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>    ));</span><br></pre></td></tr></table></figure>
<p>此时就可以用联立表来进行查询，而不需要进行子查询，子查询消耗的性能往往比联立更高：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers. orders, orderitems <span class="keyword">WHERE</span> customers.cust_id = orders.cust_id <span class="keyword">AND</span> orderitems.order_num = orders.order_num <span class="keyword">AND</span> pord_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
<p>通过两个限定条件来联立三张表，然后通过一个值限定来确定返回的是要求的产品。</p>
<h1 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h1><p>还有其他类型的表联结方式，也可以对被联结的表使用别名和聚集函数。</p>
<h2 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h2><p>SQL中不仅允许给列起别名，还允许给表取别名。这样做主要有以下两个理由：</p>
<ul>
<li>缩短SQL语句。</li>
<li>允许在单个<code>SELECT</code>语句中多次使用相同的表。</li>
</ul>
<p>比如下面的语句使用别名来替代表名来缩短SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi <span class="keyword">WHERE</span> c.cust_id = o.cust_id <span class="keyword">AND</span> oi.order_num = o.order_num <span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到这里使用别名简化了后面的全限定名的写法。</p>
<h2 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h2><p>前面只看到了内部连接（等价联结）的简单联结。实际上一共有4中联结方式：</p>
<ul>
<li>自联结</li>
<li>自然联结</li>
<li>内部连接</li>
<li>外部联结</li>
</ul>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><p>所谓子查询就是表自己和自己联立，<strong>一般是为了通过表中的某一个信息来查询该表中的其他信息</strong>。</p>
<p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。下面是通过子查询解决此问题的一种方法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pord_id, pord_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id = (<span class="keyword">SELECT</span> vend_id <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_id = <span class="string">'DTNTR'</span>);</span><br></pre></td></tr></table></figure>
<p>同样，其可以用联结来重写子查询的语句。而这时我们是通过一张表得到的信息来查询这张表中的信息，此时就该使用自联结：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name <span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2 <span class="keyword">WHERE</span> p1.vend_id = p2.vend_id <span class="keyword">AND</span> p2.prod_id = <span class="string">'DTNTR'</span>;</span><br></pre></td></tr></table></figure>
<p>此查询中需要的两个表实际上是相同的表，因此<code>products</code>表在<code>FROM</code>子句中出现了两次。虽然这是完全合法的，但对<code>products</code>的引用具有二义性，因此MySQL不知道你引用的<code>products</code>表中的哪个实例。</p>
<p>为解决此问题，使用了表别名。<code>products</code>的第一次出现为别名p1，第二次出现为别名p2。现在可以将这些别名用作表名。例如，<code>SELECT</code>语句使用p1前缀明确地给出所需列的全名。如果不这样，MySQL将返回错误，因为分别存在两个名为<code>prod_id</code>、<code>prod_name</code>的列。MySQL不知道想要的是哪一个列（即使它们事实上是同一个列)。<code>WHERE</code>（通过匹配p1中的<code>vend_id</code>和p2中的<code>vend_id</code>）首先联结两个表，然后按第二个表中的<code>prod_id</code>过滤数据，返回所需的数据。</p>
<p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。</p>
<p>自然联结是这样一种联结，其中你只能选择那些唯一的列。这一 般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子<br>集来完成的。下面举一个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.*, o.order_num，o.order_date,</span><br><span class="line">oi.prod_id，oi.quantity ，o1.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c,orders <span class="keyword">As</span> o，orderitems <span class="keyword">As</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id <span class="keyword">AND</span> oi.order_num = o.order_num <span class="keyword">AND</span> prod_id = <span class="string">'FB'</span> ;</span><br></pre></td></tr></table></figure>
<p>1、自然连接是特殊的内联结（等值联结），自然联结不能有where和on去限制筛选<br>2、等值连接要求相等的分量，不一定是公共属性（即相同的列名）；而自然连接要求相等的公共属性（列名）。　　</p>
<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。</p>
<p>下面的SELECT语句给出一个简单的内部联结。它检索所有客户及其订单：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num <span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customer.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>类似于上一章中所看到的内部联结，这条SELECT语句使用了关 键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM 子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN，如下例所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num <span class="keyword">FROM</span> customers <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> orders.cust_id = customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>外部联结的类型存在两种基本的外部联结形式：左外部联结和右外部联结。它们之间的唯一差别是所关联的表的顺序不同。换句话说，左外部联结可通过颠倒语句中表的顺序来达到互相的效果。</p>
<h2 id="使用聚集函数"><a href="#使用聚集函数" class="headerlink" title="使用聚集函数"></a>使用聚集函数</h2><p>聚集函数也可以用于联结表的聚集。</p>
<p>例如：如果要检索所有客户及每个客户所下的订单数，下面使用了<code>COUNT()</code>函数的代码可完成此工作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name, customers.cust_id, <span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord <span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> costomers.cust_id = orders.cust_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>此SELECT语句使用<code>INNER JOIN</code>将<code>customers</code>和<code>orders</code>表互相关联。 <code>GROUP BY</code>子句按客户分组数据，因此，函数调用<code>COUNT(orders.order_num)</code>对每个客户的订单计数，将它作为<code>num_ord</code>返回。</p>
<h2 id="使用联结的条件"><a href="#使用联结的条件" class="headerlink" title="使用联结的条件"></a>使用联结的条件</h2><ul>
<li>注意使用联结的类型，根据不同情况选择内还是外。</li>
<li>应该提供联结条件，否则将返回笛卡尔积。</li>
<li>在一个联结中，可以包含多个表，并且不同的表也可以使用不同的联结方式，但是应该先单个测试，防止混乱出错。</li>
</ul>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>MySQL允许执行多个查询操作（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常被称为并（<code>union</code>）或复合查询（<code>compound query</code>）。</p>
<p>有两种基本情况，其中需要使用组合查询：</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据。</li>
<li>对单个表执行多个查询，按单个查询返回数据。</li>
</ul>
<p>组合查询和多个WHERE条件：多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，任何具有多个<code>WHERE</code>子句的<code>SELECT</code>语句都可以作为一个组合查询给出，在以下段落中可以看到这一点。 这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。</p>
<h2 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h2><p>可用UNION操作符来组合数条SQL查询。</p>
<h3 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h3><p><code>UNION</code>的使用很简单。所需做的只是给出每条<code>SELECT</code>语句，在各条语句之间放上关键字<code>UNION</code>。</p>
<p>举一个例子，假如需要价格小于等于5的所有物品的一个列表，而且 还想包括供应商1001和1002生产的所有物品（不考虑价格）。当然，可以利用<code>WHERE</code>子句来完成此工作，不过这次我们将使用<code>UNION</code>。</p>
<p>语句1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>prod_id</code></th>
<th><code>prod_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1003</td>
<td>FC</td>
<td>2.50</td>
</tr>
<tr>
<td>1002</td>
<td>FUI</td>
<td>3.42</td>
</tr>
<tr>
<td>1003</td>
<td>SLING</td>
<td>4.49</td>
</tr>
</tbody>
</table>
<p>语句2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>prod_id</code></th>
<th><code>prod_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>ANV01</td>
<td>5.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV02</td>
<td>9.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV03</td>
<td>14.99</td>
</tr>
</tbody>
</table>
<h4 id="组合查询-1"><a href="#组合查询-1" class="headerlink" title="组合查询"></a>组合查询</h4><p>现在将两条语句组合起来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span>  vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>prod_id</code></th>
<th><code>prod_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1003</td>
<td>FC</td>
<td>2.50</td>
</tr>
<tr>
<td>1002</td>
<td>FUI</td>
<td>3.42</td>
</tr>
<tr>
<td>1003</td>
<td>SLING</td>
<td>4.49</td>
</tr>
<tr>
<td>1001</td>
<td>ANV01</td>
<td>5.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV02</td>
<td>9.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV03</td>
<td>14.99</td>
</tr>
</tbody>
</table>
<h4 id="WHERE方式"><a href="#WHERE方式" class="headerlink" title="WHERE方式"></a><code>WHERE</code>方式</h4><p>前面提到，一般从同一个表中进行联合查询，也可以用<code>WHERE</code>来替代：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span> <span class="keyword">AND</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>prod_id</code></th>
<th><code>prod_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1003</td>
<td>FC</td>
<td>2.50</td>
</tr>
<tr>
<td>1002</td>
<td>FUI</td>
<td>3.42</td>
</tr>
<tr>
<td>1003</td>
<td>SLING</td>
<td>4.49</td>
</tr>
<tr>
<td>1001</td>
<td>ANV01</td>
<td>5.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV02</td>
<td>9.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV03</td>
<td>14.99</td>
</tr>
</tbody>
</table>
<p>这两种方式获得的结果一致。</p>
<h3 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h3><ul>
<li><code>UNION</code>必须由两条或两条以上的<code>SELECT</code>语句组成，语句之间用关键字<code>UNION</code>分隔（因此，如果组合4条<code>SELECT</code>语句，将要使用3个<code>UNION</code>关键字）。</li>
<li><code>UNION</code>中的每个查询必须包含<strong>相同的列、表达式和聚集函数</strong>（不过各个列不需要以相同的次序列出）。</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li>
</ul>
<p>如果遵守了这些基本规则或限制，则可以将并用于任何数据检索任务。</p>
<h3 id="包含或取消重复的列"><a href="#包含或取消重复的列" class="headerlink" title="包含或取消重复的列"></a>包含或取消重复的列</h3><p><strong><code>UNION</code>会从查询结果集中自动去除了重复的行</strong>（换句话说，它的行为与 单条<code>SELECT</code>语句中使用多个<code>WHERE</code>子句条件一样）。</p>
<p>这是<code>UNION</code>的默认行为，但是如果需要，可以改变它。事实上，如果 想返回所有匹配行，可使用<code>UNION ALL</code>而不是<code>UNION</code>。</p>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<p>此时就会将重复的行保存下来，不会被移除。</p>
<h3 id="对组合查询结果进行排序"><a href="#对组合查询结果进行排序" class="headerlink" title="对组合查询结果进行排序"></a>对组合查询结果进行排序</h3><p><code>SELECT</code>语句的输出用<code>ORDER BY</code>子句排序。在用<code>UNION</code>组合查询时，只 能使用一条<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条<code>ORDER BY</code>子句。</p>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_id, prod_price;</span><br></pre></td></tr></table></figure>
<p>这条<code>UNION</code>在最后一条<code>SELECT</code>语句后使用了<code>ORDER BY</code>子句。虽 然<code>ORDER BY</code>子句似乎只是最后一条<code>SELECT</code>语句的组成部分，但实际上MySQL将用它来排序所有<code>SELECT</code>语句返回的所有结果。</p>
<h1 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h1><p>并非所有引擎都支持全文本搜索：MySQL 支持几种基本的数据库引擎。并非所有的引擎都支持本全文本搜索。两个最常使用的引擎为<code>MyISAM</code>和<code>InnoDB</code>，前者支持全文本搜索，而<strong>后者不支持</strong>。</p>
<p>前文介绍了<code>LIKE</code>关键词和正则表达式，都可以达到检索的目的。但是其有以下的问题：</p>
<ul>
<li>性能：通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。</li>
<li>明确控制：使用通配符和正则表达式匹配，很难（而且并不总 是能）明确地控制匹配什么和不匹配什么。</li>
<li>智能化的结果：虽然基于通配符和正则表达式的搜索提供了非 常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。</li>
</ul>
<p>所有这些限制以及更多的限制都可以用全文本搜索来解决。在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理 每个词。MySQL创建指定列中各词的一个<strong>索引</strong>，搜索可以针对这些词进 行。这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率，等等。</p>
<h2 id="使用全文搜索"><a href="#使用全文搜索" class="headerlink" title="使用全文搜索"></a>使用全文搜索</h2><p>使用全文搜索，包含以下两步：</p>
<ul>
<li>索引要被搜索的列，而且要随着数据的改变不断地重新索引（MySQL自动完成）。</li>
<li>使用<code>SELECT</code>子句地<code>Match()</code>和<code>Against()</code>来进行全文搜索。</li>
</ul>
<h3 id="启用全文搜索支持"><a href="#启用全文搜索支持" class="headerlink" title="启用全文搜索支持"></a>启用全文搜索支持</h3><p>启用全文搜索支持，需要在创建表地时候使用<code>FULLTEXT</code>子句来确定要被索引的列，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">	node_id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    prod_id <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    note_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    note_text <span class="built_in">text</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY KEEY(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">)<span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure>
<p>如上，<code>FULLTEXT(note_text)</code>，使用<code>FULLTEXT</code>指定了<code>note_text</code>为要被检索的列。</p>
<blockquote>
<p>不要在导入数据时使用FULLTEXT： 更新索引要花时间，虽然 不是很多，但毕竟要花时间。如果正在导入数据到一个新表， 此时不应该启用FULLTEXT索引。应该首先导入所有数据，然 后再修改表，定义FULLTEXT。这样有助于更快地导入数据（而 且使索引数据的总时间小于在导入每行时分别进行索引所需<br>的总时间）</p>
</blockquote>
<h3 id="进行全文搜索"><a href="#进行全文搜索" class="headerlink" title="进行全文搜索"></a>进行全文搜索</h3><p>在索引之后，使用两个函数<code>Match()</code>和<code>Against()</code>执行全文本搜索，其中<code>Match()</code>指定被搜索的列，<code>Against()</code>指定要使用的搜索表达式。</p>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'rabbit'</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Customer complaint: rabbit has been able to detect trap，foodapparently less effective now .<br/>Quantity varies，sold by the sack load. A11 guaranteed to bebright and orange，and suitable for use as rabbit bait.</td>
</tr>
</tbody>
</table>
<p>此<code>SELECT</code>语句检索单个列<code>note_text</code>。由于<code>WHERE</code>子句，一个全 文本搜索被执行。<code>Match(note_text)</code>指示MySQL针对指定的列进行搜索，<code>Against(&#39;rabbit&#39;)</code>指定词rabbit作为搜索文本。由于有 两行包含词rabbit，这两个行被返回。</p>
<p>实际上刚才的搜索也可以使用LIKE关键字来解决：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> produscts <span class="keyword">WHERE</span> note_text <span class="keyword">LIKE</span> <span class="string">'%rabbit%'</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Quantity varies， sold by the sack load. A11 guaranteed to bebright and orange，and suitable for use as rabbit bait.<br/>Customer complaint: rabbit has been able to detect trap，foodapparently less effective now .</td>
</tr>
</tbody>
</table>
<p>这条SELECT语句同样检索出两行，但次序不同（虽然并不总是这种情况）。</p>
<p>其原因在于全文搜索会将具有较高等级的行先返回。而<code>LIKE</code>则是按照数据库中的顺序来进行返回。</p>
<p>这里的优先级一般是目标词越靠前，目标词越多，优先级越高。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>全文搜索的优点在于：</p>
<ul>
<li>其按照优先级排序</li>
<li>检索速度更快</li>
</ul>
<h3 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h3><p>查询扩展用来设法放宽所返回的全文本搜索结果的范围。考虑下面 的情况。你想找出所有提到anvils的注释。只有一个注释包含词anvils，但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。</p>
<p>这也是查询扩展的一项任务。在使用查询扩展时，MySQL对数据和 索引进行两遍扫描来完成搜索：</p>
<ul>
<li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有 行；</li>
<li>其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简 要地解释MySQL如何断定什么有用，什么无用）。</li>
<li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件， 而且还使用所有有用的词。</li>
</ul>
<p>例如，首先进行一个简单的全文本搜索，没有查询扩展： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productsnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Aganinst(<span class="string">"anvils"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Multiple customer returns，anvils failing to drop fast enough orfa1ling backwards on purchaser. Recommend that customer considersusing heavier anvils.</td>
</tr>
</tbody>
</table>
<p>有一行包含词anvils，因此只返回一行。</p>
<p>现在使用查询扩展：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productsnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Aganinst(<span class="string">"anvils"</span> <span class="keyword">WITH</span> <span class="keyword">QUERY</span> EXPANSION);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Multiple customer returns，anvils failing to drop fast enough orfa1ling backwards on purchaser. Recommend that customer considersusing heavier anvils.<br/>Customer complaint: Sticks not individua1ly wrapped，too easy tomistakenly detonate all at once. Recommend individual wrapping.Customer complaint: Not heavy enough to generate flying starsaround headof victim. If being purchased for dropping，recommend<br />ANV02 or ANV03 instead</td>
</tr>
<tr>
<td>Please note that no returns wil1 be accepted if safe opened usingexplosives .<br/>Customer complaint: rabbit has been able to detect trap，foodapparently less effective now .<br/>Customer complaint: Circular hole in safe floor can apparently beeasily cut with handsaw.<br/>Matches not included，recommend purchase of matches or detonator(item DTNTR) .</td>
</tr>
</tbody>
</table>
<p>这次返回了7行。第一行包含词anvils，因此等级最高。第二行与anvils无关，但因为它包含第一行中的两个词（customer<br>和recommend），所以也被检索出来。第3行也包含这两个相同的词，但它 们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名）。</p>
<h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><p>MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean 170<br>mode）。以布尔方式，可以提供关于如下内容的细节：</p>
<ul>
<li>要匹配的词</li>
<li>拍排斥的词（如果某行包含这个词，则不返回改行，即使它包含其他指定的词也是如此）</li>
<li>排列提示</li>
<li>表达式分组</li>
<li>其他内容</li>
</ul>
<blockquote>
<p>即使没有FULLTEXT索引也可以使用 布尔方式不同于迄今为 止使用的全文本搜索语法的地方在于，即使没有定义 FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作<br>（其性能将随着数据量的增加而降低）。</p>
</blockquote>
<p>例1：检索包含<code>heavy</code>的句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_textFROMproductnotes</span><br><span class="line"><span class="keyword">wHERE</span> <span class="keyword">Match</span>(note_text) Against( <span class="string">'heavy'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Item is extremely heavy. Designed for dropping，not recommendedfor use with slings，ropes，pulleys， or tightropes.Customer complaint: Not heavy enough to generate flying starsaround head of victim. If being purchased for dropping，recommendANV02 or ANV03 instead.</td>
</tr>
</tbody>
</table>
<p>此全文本搜索检索包含词heavy的所有行（有两行）。其中使用 了关键字IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同。</p>
<p>例2：检索包含<code>heavy</code>但不包含任何以<code>rope</code>开头的行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productsnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'heavy -rope*'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Customer complaint: Not heavy enough to generate flying stars around head of victim. If being purchased for dropping，recommend ANVO2 or ANV03 instead.</td>
</tr>
</tbody>
</table>
<p>这次只返回一行。这一次仍然匹配词heavy，但-rope*明确地 指示MySQL排除包含rope*（任何以rope开始的词，包括<br>ropes）的行，这就是为什么上一个例子中的第一行被排除的原因。</p>
<p>下面是所有的全文布尔操作符</p>
<table>
<thead>
<tr>
<th>布尔操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>包含，词必须存在</td>
</tr>
<tr>
<td>-</td>
<td>排除，词必须不出现</td>
</tr>
<tr>
<td>&gt;</td>
<td>包含，而且增加等级值</td>
</tr>
<tr>
<td>&lt;</td>
<td>包含，且减少等级值</td>
</tr>
<tr>
<td>()</td>
<td>把词组成子表达式（允许这些表达式作为一个组被包含、排除、排列等）</td>
</tr>
<tr>
<td>~</td>
<td>取消一个词的排序值</td>
</tr>
<tr>
<td>*</td>
<td>词尾的通配符</td>
</tr>
<tr>
<td>“”</td>
<td>定义一个短语（与单个词的列表不一样，它匹配整个短语以便排除整个短语）</td>
</tr>
</tbody>
</table>
<p>例如</p>
<p>1：搜索包含词<code>rabbit</code>和<code>bait</code>的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'+rabbit +bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<p>2：搜索匹配包含<code>rabbit</code>和<code>bait</code>中的至少一 个词的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'rabbit bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<p>3：搜索匹配短语<code>rabbit bait</code>而不是匹配两个词<code>rabbit</code>和 <code>bait</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'"rabbit bait"'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<p>4：匹配<code>rabbit</code>和<code>carrot</code>，增加前者的等级，降低后者的等级。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'&gt;rabbit &lt;bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<h3 id="全文搜索的使用说明"><a href="#全文搜索的使用说明" class="headerlink" title="全文搜索的使用说明"></a>全文搜索的使用说明</h3><ul>
<li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为 那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li>
<li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参 阅MySQL文档以了解如何完成此工作）。</li>
<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。 因此，MySQL规定了一条50%规则，如果一个词出现在50%以上 的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN<br>MODE。</li>
<li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词 或者不出现，或者至少出现在50%的行中）。</li>
<li>忽略词中的单引号。例如，don’t索引为dont。</li>
<li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文 本搜索结果。</li>
<li>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>高级检索知识</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL必知必会22-30-MySQL高级特征</title>
    <url>/2022/02/24/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A22-30-MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是虚拟的表。与包含数据的表不同，视图只包含使用时动态检索数据的查询。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact </span><br><span class="line"><span class="keyword">FROM</span> custmers, orders, orderitems </span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id </span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num = orders.order_num </span><br><span class="line"><span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
<p>此查询用来检索订购了某个特定产品的客户。任何需要这个数据的 人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。 为了检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子<br>句。</p>
<p>现在，假如可以把整个查询包装成一个名为productcustomers的虚 拟表，则可以如下轻松地检索出相同的数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> productcustomers <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
<p>这就是视图的作用。productcustomers是一个视图，作为视图，它 不包含表中应该有的任何列或数据，它包含的是一个SQL查询（与上面用以正确联结表的相同的查询）。</p>
<h3 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h3><p>下面是视图的一些常见应用。</p>
<ul>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必指导它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表。</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>在视图创建之后，可以用与表基本相同的方式利用它们。可以对视 图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据。</p>
<p>重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。 视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><ul>
<li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相 同的名字）。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据 库管理人员授予。</li>
<li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造 一个视图。</li>
<li><code>ORDER BY</code>可以用在视图中，但如果从该视图检索数据<code>SELECT</code>中也 含有<code>ORDER BY</code>，那么该视图中的<code>ORDER BY</code>将被覆盖。</li>
<li>视图不能索引，也不能有关联的触发器或默认值。</li>
<li>视图可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。</li>
</ul>
<h2 id="使用视图-1"><a href="#使用视图-1" class="headerlink" title="使用视图"></a>使用视图</h2><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>使用<code>CREATE VIEW</code>关键词来创建视图。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> productscustomer <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact prod_id</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, ordertimes</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num = orders.order_num;</span><br></pre></td></tr></table></figure>
<p>这条语句创建一个名为productcustomers的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。</p>
<h3 id="使用视图-2"><a href="#使用视图-2" class="headerlink" title="使用视图"></a>使用视图</h3><p>如果执行<code>SELECT * FROM productcustomers</code>，将列出订购了任意产品的客户。</p>
<p>如果检索订购了TNT2的客户，可如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> productcustomers <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>cust_name</code></th>
<th><code>cust_contact</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Coyote Inc.</td>
<td>Y Lee</td>
</tr>
<tr>
<td>Yosemite Place</td>
<td>Y Sam</td>
</tr>
</tbody>
</table>
<p>这条语句通过<code>WHERE</code>子句从视图中检索特定数据。在MySQL处 理此查询时，它将指定的<code>WHERE</code>子句添加到视图查询中的已有<code>WHERE</code>子句中，以便正确过滤数据。</p>
<blockquote>
<p>创建可重用的视图：创建不受特定数据限制的视图是一种好办法。例如，上面创建的视图返回生产所有产品的客户而 不仅仅是生产TNT2的客户。扩展视图的范围不仅使得它能被 重用，而且甚至更有用。这样做不需要创建和维护多个类似<br>视图。</p>
</blockquote>
<h3 id="使用视图重新格式化检索出的数据"><a href="#使用视图重新格式化检索出的数据" class="headerlink" title="使用视图重新格式化检索出的数据"></a>使用视图重新格式化检索出的数据</h3><p>例如之前提到的在单个组合计算列中返回供应商名和位置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name),<span class="string">' ('</span>，<span class="keyword">RTrim</span>(vend_country)，<span class="string">')'</span>)</span><br><span class="line"><span class="keyword">As</span> vend_title</span><br><span class="line">FROMvendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>
<p>现在，假如经常需要这个格式的结果。不必在每次需要时执行联结， 创建一个视图，每次需要时使用它即可。为把此语句转换为视图，可按如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vendorlocation <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name), <span class="string">'('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">')'</span>) <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>
<p>这条语句使用与以前的SELECT语句相同的查询创建视图。为了 检索出以创建所有邮件标签的数据，可如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> vendorlocation;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>vend_title</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>ACME (USA)</td>
</tr>
<tr>
<td>Anvils R Us (USA)</td>
</tr>
<tr>
<td>Furball Inc. (USA)</td>
</tr>
</tbody>
</table>
<h3 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h3><p>视图对于应用普通的WHERE子句也很有用。例如，可以定义 customeremaillist视图，它过滤没有电子邮件地址的客户。为此目的，可使用下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customeremiallist <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>显然，在发送电子邮件到邮件列表时，需要排除没有电子邮件 地址的用户。这里的WHERE子句过滤了cust_email列中具有NULL值的那些行，使他们不被检索出来。</p>
<p>现在，可以像使用其他表一样使用视图customeremaillist。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customeremiallist；</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>cust_id</code></th>
<th><code>cust_name</code></th>
<th><code>cust_email</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>Coyote Inc.</td>
<td><a href="mailto:ylee@coyote.com">ylee@coyote.com</a></td>
</tr>
<tr>
<td>10003</td>
<td>Wascals</td>
<td><a href="mailto:rabbit@wascally.com">rabbit@wascally.com</a></td>
</tr>
<tr>
<td>10004</td>
<td>Yosemite Plca</td>
<td><a href="mailto:sam@yosemite.com">sam@yosemite.com</a></td>
</tr>
</tbody>
</table>
<h3 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h3><p>视图对于简化计算字段的使用特别有用。下面是前面提到的一 条SELECT语句。它检索某个特定订单中的物品，计算每种物品的总价格：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id，</span><br><span class="line">quantity ,item _price,</span><br><span class="line">quantity=item_price <span class="keyword">As</span> expanded_ price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">wHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>prod_id</code></th>
<th><code>quantity</code></th>
<th><code>item_price</code></th>
<th><code>expanded_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>ANV01</td>
<td>10</td>
<td>5.99</td>
<td>59.90</td>
</tr>
<tr>
<td>ANV02</td>
<td>3</td>
<td>9.99</td>
<td>29.97</td>
</tr>
<tr>
<td>TNT2</td>
<td>5</td>
<td>10.00</td>
<td>50.00</td>
</tr>
</tbody>
</table>
<p>为将其转换为一个视图，如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> orderitemsexpanded <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num, prod_id, quantity, item_price quantity * item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line">DEOM orderitems;</span><br></pre></td></tr></table></figure>
<p>为检索订单20005的详细内容（上面的输出），如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orderitemsexpanded <span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>odre_num</code></th>
<th><code>prod_id</code></th>
<th><code>quantity</code></th>
<th><code>item_price</code></th>
<th><code>expanded_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>20005</td>
<td>ANV01</td>
<td>10</td>
<td>5.99</td>
<td>59.90</td>
</tr>
<tr>
<td>20005</td>
<td>ANV02</td>
<td>3</td>
<td>9.99</td>
<td>29.97</td>
</tr>
<tr>
<td>20005</td>
<td>TNT2</td>
<td>5</td>
<td>10.00</td>
<td>50.00</td>
</tr>
</tbody>
</table>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>通常，视图是可更新的（即，可以对它们使用INSERT、UPDATE和 DELETE）。更新一个视图将更新其基表（视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p>
<p>但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不 能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p>
<ul>
<li>分组（使用GROUP BY和HAVING）；</li>
<li>联结；</li>
<li>子查询；</li>
<li>并；</li>
<li>聚集函数；</li>
<li>DISTINCT；</li>
<li>导出（计算）列。</li>
</ul>
<p>换句话说，本章许多例子中的视图都是不可更新的。这听上去好像 是一个严重的限制，但实际上不是，因为视图主要用于数据检索。</p>
<p>一般，应该将视图用于检索（SELECT语句） 而不用于更新（INSERT、UPDATE和DELETE）。</p>
<p><strong>TIP：视图从MySQL5开始支持。</strong></p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合，并且可以在调用时传入参数。传统来说，MySQL的存储过程就是MySQL中的函数，其组成函数的语句就是MySQL语句。</p>
<h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><h4 id="简单定义"><a href="#简单定义" class="headerlink" title="简单定义"></a>简单定义</h4><p>可以通过<code>CREATE PROCEDURE</code>来创建存储过程。其格式与函数定义类似。</p>
<p>例如1：计算平均价格：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">Avg</span>(pro_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line">	<span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>如上，与VBS类型，需要声明<code>BEGIN</code>和<code>END</code>。</p>
<h4 id="带参数的定义"><a href="#带参数的定义" class="headerlink" title="带参数的定义"></a>带参数的定义</h4><p>与函数类似，存储过程是可以带参数的。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing(</span><br><span class="line">	<span class="keyword">OUT</span> pl <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">OUT</span> ph <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">OUT</span> pa <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">Min</span>(prod_price) <span class="keyword">INTO</span> pl <span class="keyword">FROM</span> products;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">Max</span>(prod_price) <span class="keyword">INTO</span> ph <span class="keyword">FROM</span> products;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">INTO</span> pa <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>此存储过程接受3个参数：pl存储产品最低价格，ph存储产品 最高价格，pa存储产品平均价格。</p>
<p>每个参数必须具有指定的类型，这里使用十进制值。存储过程的参数允许的数据类型与表中使用的数据类型相同。</p>
<p>关键字OUT指出相应的参数用来从存储过程传出 一个值（返回给调用者）。MySQL支持</p>
<ul>
<li><code>IN</code>（传递给存储过程）、</li>
<li><code>OUT</code>（从存 储过程传出，如这里所用）</li>
<li><code>INOUT</code>（对存储过程传入和传出）类型的参 数。</li>
</ul>
<p>存储过程的代码位于<code>BEGIN</code>和<code>END</code>语句内，如前所见，它们是一系列 SELECT语句，用来检索值，然后保存到相应的变量（通过指定<code>INTO</code>关键字）。</p>
<p>这里的参数也是和函数不同的地方，存储过程的参数可以是传入（形参传递），也可以是传出（类似于指针实参，将数据放入内存指定位置，则函数外也可以读取到）。</p>
<h3 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h3><p>所谓的智能存储过程，就是结合业务，编写结构更明确的存储结构。</p>
<p>其中包含这些前提知识：</p>
<ul>
<li><p>存储过程的变量声明：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名 = 表达式值 [,variable_name = expression ...]；</span><br><span class="line"><span class="keyword">SET</span> @l_int = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>注意：使用set声明变量，所有MySQL变量都必须以@开始。以@开头的是自定义的，否则其被视为系统变量。</p>
</li>
<li><p>IF语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">	<span class="keyword">do</span> something;</span><br><span class="line">ELSE</span><br><span class="line">	<span class="keyword">do</span> otherthing;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CASE语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CASE var</span><br><span class="line">	WHEN condition1 THEN</span><br><span class="line">		<span class="keyword">do</span> thing1;</span><br><span class="line">    WHEN condition2 THEN</span><br><span class="line">    	<span class="keyword">do</span> thing2;</span><br><span class="line">    ELSE</span><br><span class="line">    	<span class="keyword">do</span> surplus things;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">CASE</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>循环语句1（while…do）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WHILE condition <span class="keyword">DO</span></span><br><span class="line">	<span class="keyword">do</span> things</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环语句2（repeat）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">	<span class="keyword">do</span> things;</span><br><span class="line">    UNTIL condition;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环语句3（loop）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LOOP_LABLE:LOOP</span><br><span class="line">    <span class="keyword">do</span> thinngs</span><br><span class="line">    <span class="keyword">IF</span> v &gt;=<span class="number">5</span> <span class="keyword">THEN</span></span><br><span class="line">              LEAVE LOOP_LABLE;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用“--”来表示注释，注意--后的空格</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。</p>
<p>  内置函数：</p>
<ul>
<li><p>字符类：</p>
<ul>
<li><code>CHARSET(str)</code> ：返回字串字符集</li>
<li><code>CONCAT (string2 [,... ])</code>：连接字串</li>
<li><code>INSTR (string ,substring )</code> ：返回substring首次在string中出现的位置,不存在返回0</li>
<li><code>LCASE (string2 )</code>：转换成小写</li>
<li><code>LEFT (string2 ,length )</code>：从string2中的左边起取length个字符</li>
<li><code>LENGTH (string )</code>：string长度</li>
<li><code>LOAD_FILE (file_name )</code>：从文件读取内容</li>
<li><code>LOCATE (substring , string [,start_position ] )</code>： 同INSTR,但可指定开始位置</li>
<li><code>LPAD (string2 ,length ,pad )</code>：重复用pad加在string开头,直到字串长度为length</li>
<li><code>LTRIM (string2 )</code> ：去除前端空格</li>
<li><code>REPEAT (string2 ,count )</code> ：重复count次</li>
<li><code>REPLACE (str ,search_str ,replace_str )</code> ：在str中用replace_str替换search_str</li>
<li><code>RPAD (string2 ,length ,pad)</code> ：在str后用pad补充,直到长度为length</li>
<li><code>RTRIM (string2 )</code> ：去除后端空格</li>
<li><code>STRCMP (string1 ,string2 )</code> ：逐字符比较两字串大小,</li>
<li><code>SUBSTRING (str , position [,length ])</code> ：从str的position开始,取length个字符,</li>
</ul>
</li>
<li><p>数字类：</p>
<ul>
<li><code>ABS (number2 )</code>：绝对值</li>
<li><code>BIN (decimal_number )</code> ：十进制转二进制</li>
<li><code>CEILING (number2 )</code> ：向上取整</li>
<li><code>CONV(number2,from_base,to_base)</code> ：进制转换</li>
<li><code>FLOOR (number2 )</code> ：向下取整</li>
<li><code>FORMAT (number,decimal_places )</code> ：保留小数位数</li>
<li><code>HEX (DecimalNumber )</code>：转十六进制<br>注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(‘DEF’)返回4142143<br>也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19</li>
<li><code>LEAST (number , number2 [,..])</code> ：求最小值</li>
<li><code>MOD (numerator ,denominator )</code> ：求余</li>
<li><code>POWER (number ,power )</code> ：求指数</li>
<li><code>RAND([seed])</code>：随机数</li>
<li><code>ROUND (number [,decimals ])</code> ：四舍五入,decimals为小数位数] 注：返回类型并非均为整数，如：</li>
</ul>
</li>
</ul>
<p>相当于一门新的语言，使用这门语言来编写一个存储过程（函数）来得到确定的值。</p>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>内部的变量在其作用域范围内享有更高的优先权，当执行到 end。变量时，内部变量消失，此时已经在其作用域外，变量不再可见了，应为在存储过程外再也不能找到这个申明的变量，但是你可以通过 out 参数或者将其值指派给会话变量来保存其值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc3()  </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> x1 = <span class="string">'outer'</span>;  </span><br><span class="line">    <span class="keyword">BEGIN</span> </span><br><span class="line">        <span class="keyword">SET</span> x1 = <span class="string">'inner'</span>;  </span><br><span class="line">        <span class="keyword">SELECT</span> x1;  </span><br><span class="line">    <span class="keyword">END</span>;  </span><br><span class="line">    <span class="keyword">SELECT</span> x1;  </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><p>与函数一样，存储过程也是通过<code>CALL</code>关键词来调用，参数通过括号内来传递。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @pricelow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> @pricehigh = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> @priceaverage = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">CALL</span> productpricing(@pricelow, @pricehigh, @priceaverage);</span><br></pre></td></tr></table></figure>
<h3 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h3><p>为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE PROCEDURE语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal;</span><br></pre></td></tr></table></figure>
<p>为了获得包括何时、由谁创建等详细信息的存储过程列表，使用SHOW PROCEDURE STATUS。</p>
<p>注意：MySQL从5开始支持存储过程。</p>
<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>游标即可以在检索出的数据中，选择对应的行的一个标记，可以游动游标来获得新的数据。</p>
<p>值得注意的是：MySQL的游标只能在存储过程中使用。</p>
<h2 id="使用游标步骤"><a href="#使用游标步骤" class="headerlink" title="使用游标步骤"></a>使用游标步骤</h2><ul>
<li>在能够使用游标前，必须声明（定义）它。这个过程实际上没有 检索数据，它只是定义要使用的SELECT语句。</li>
<li>一旦声明后，必须打开游标以供使用。这个过程用前面定义的 SELECT语句把数据实际检索出来。</li>
<li>对于填有数据的游标，根据需要取出（检索）各行。</li>
<li>在结束游标使用时，必须关闭游标。</li>
</ul>
<p>在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后， 可根据需要频繁地执行取操作。</p>
<h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><p>游标用DECLARE语句创建。DECLARE命名游标，并定义 相应的SELECT语句，根据需要带WHERE和其他子句。例如，下面的语句定 义了名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> ordernums <span class="keyword">CURSOR</span></span><br><span class="line">	<span class="keyword">FOR</span></span><br><span class="line">	<span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>这里仅仅是声明，并没有进行查询。在定义后才可以进行剩下的操作。</p>
<h3 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h3><h4 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h4><p>通过<code>OPEN</code>关键字来打开游标。并且在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚 动。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">OPEN ordernums;</span><br></pre></td></tr></table></figure>
<h4 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h4><p>通过<code>CLOSE</code>语句来关闭游标。CLOSE释放游标使用的所有内部内存和资源，因此在每个游标 不再需要时都应该关闭。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CLOSE ordernums;</span><br></pre></td></tr></table></figure>
<p>在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使 233 用声明过的游标不需要再次声明，用OPEN语句打开它就可以了。</p>
<p>整合过后就是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- Declare cursor</span></span><br><span class="line">	<span class="keyword">DECLARE</span> ordernums <span class="keyword">CURSOR</span></span><br><span class="line">	<span class="keyword">FOR</span></span><br><span class="line">	<span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- Open the cursor</span></span><br><span class="line">	OPEN ordernums；</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- Close the curor</span></span><br><span class="line">	CLOSE ordernums；</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h3><p>在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。</p>
<p>使下一条FETCH语句检索下一行（不 重复读取同一行）。</p>
<p>例1：从游标中检索单个行（第一行）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- Declare cursor</span></span><br><span class="line">	<span class="keyword">DECLARE</span> ordernums <span class="keyword">CURSOR</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">-- Declare local variables</span></span><br><span class="line">	<span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line">	</span><br><span class="line">	FOR</span><br><span class="line">	<span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- Open the cursor</span></span><br><span class="line">	OPEN ordernums；</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- Get order number</span></span><br><span class="line">	FETCH ordernumbers INTO o;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- Close the curor</span></span><br><span class="line">	CLOSE ordernums；</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>其中FETCH用来检索当前行的order_num列（将自动从第一行开 始）到一个名为o的局部声明的变量中。对检索出的数据不做任何处理。</p>
<p>例2：循环检索数据，从第一行到最后一行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- Declare cursor</span></span><br><span class="line">	<span class="keyword">DECLARE</span> ordernums <span class="keyword">CURSOR</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">-- Declare local variables</span></span><br><span class="line">	<span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> done <span class="built_in">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	FOR</span><br><span class="line">	<span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- Declare continue handler</span></span><br><span class="line">	<span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> SQLSSTATE <span class="string">'02000'</span> <span class="keyword">SET</span> done = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- Open the cursor</span></span><br><span class="line">	OPEN ordernums；</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- Loop through all rows</span></span><br><span class="line">	REPEAT</span><br><span class="line">	</span><br><span class="line">        <span class="comment">-- Get order number</span></span><br><span class="line">        FETCH ordernumbers INTO o;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- End of loop</span></span><br><span class="line">	UNTIL done <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- Close the curor</span></span><br><span class="line">	CLOSE ordernums；</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>与前一个例子一样，这个例子使用<code>FETCH</code>检索当前order_num 到声明的名为o的变量中。但与前一个例子不一样的是，这个例子中的<code>FETCH</code>是在<code>REPEAT</code>内，因此它反复执行直到done为真（由<code>UNTIL done END REPEAT;</code>规定）。为使它起作用，用一个<code>DEFAULT 0</code>（假，不结束）定义变量done。</p>
<p>而<code>DECLARE CONTINUE HANDLER FOR SQLSSTATE &#39;02000&#39; SET done = 1;</code>指定了<code>SQLSTATE &#39;02000&#39;</code>出现时，<code>SET done=1</code>。</p>
<p>例3：整合上面的例子</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Declare local variables</span></span><br><span class="line"><span class="keyword">DECLARE</span> done <span class="built_in">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> t <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Declare the cursor</span></span><br><span class="line"><span class="keyword">DECLARE</span> ordernumbers CURSORFOR</span><br><span class="line"><span class="keyword">SELECT</span> order_num FRON orders ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Declare continue handler</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'02000'</span> <span class="keyword">SET</span> done=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create a table to store the results</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ordertotals</span><br><span class="line">(order_num <span class="built_in">INT</span>, total <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- open the cursor</span></span><br><span class="line">OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Loop through all rows</span></span><br><span class="line">REPEAT</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Get order number</span></span><br><span class="line">    FETCH ordernumbers INTO o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Get the total for this order</span></span><br><span class="line">    <span class="keyword">CALL</span> ordertotal(o，<span class="number">1</span>，t);</span><br><span class="line">    <span class="comment">-- Insert order and total into ordertotals</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> ordertotals(order_num，tota1)</span><br><span class="line">    <span class="keyword">VALUES</span>(o，t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- End of loop</span></span><br><span class="line">    UNTIL done <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Close the cursor</span></span><br><span class="line">    CLOSE ordernumbers;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，我们增加了另一个名为t的变量（存储每个订 单的合计）。此存储过程还在运行中创建了一个新表（如果它不存在的话），名为ordertotals。这个表将保存存储过程生成的结果。FETCH 像以前一样取每个order_num，然后用CALL执行另一个存储过程（我们在 前一章中创建）来计算每个订单的带税的合计（结果存储到t）。最后，<br>用INSERT保存每个订单的订单号和合计。</p>
<p><strong>TIP：MySQL从5开始支持游标。</strong></p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>所谓触发器，就是在某个操作发生时由MySQL自发的执行其他另外的操作。</p>
<p>例如：</p>
<ul>
<li>每当增加一个顾客到某个数据库表时，都检查其电话号码格式是 否正确，州的缩写是否为大写；</li>
<li>每当订购一个产品时，都从库存数量中减去订购的数量；</li>
<li>无论何时删除一行，都在某个存档表中保留一个副本。</li>
</ul>
<p>所有这些例子的共同之处是它们都需要在某个表发生更改时自动 处理。这确切地说就是触发器。触发器是MySQL响应以下任意语句而 自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语<br>句）：</p>
<ul>
<li><code>DELETE</code></li>
<li><code>INSERT</code></li>
<li><code>UPDATE</code></li>
</ul>
<p>其他MySQL语句不支持触发器。</p>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><p>在创建触发器时，需要给出4条信息： </p>
<ul>
<li>唯一的触发器名； </li>
<li>触发器关联的表； </li>
<li>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</li>
<li>触发器何时执行（处理之前或之后）。</li>
</ul>
<blockquote>
<p>保持每个数据库的触发器名唯一：在MySQL 5中，触发器名必 须在每个表中唯一，但不是在每个数据库中唯一。这表示同一 数据库中的两个表可具有相同名字的触发器。这在其他每个数 据库触发器名必须唯一的DBMS中是不允许的，而且以后的 MySQL版本很可能会使命名规则更为严格。因此，现在最好<br>是在数据库范围内使用唯一的触发器名。</p>
</blockquote>
<p>可以使用<code>CREATE TRIGGER</code>语句创建。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> products <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> <span class="string">'Product added'</span>;</span><br></pre></td></tr></table></figure>
<p><code>CREATE TRIGGER</code>用来创建名为newproduct的新触发器。</p>
<p><code>AFTER INSERT</code>指定了触发器响应的活动。</p>
<p><code>ON products</code>指示了在哪张表格触发。</p>
<p><code>FOR EACH ROW</code>指示了每一次插入都会触发。</p>
<p><code>SELECT &#39;Product added&#39;</code>指示了触发器触发的操作。</p>
<p>为了测试这个触发器，使用INSERT语句添加一行或多行到products 中，你将看到对每个成功的插入，显示Product added消息。</p>
<blockquote>
<p>仅支持表：只有表才支持触发器，视图不支持（临时表也不 支持）。</p>
</blockquote>
<p>注意：</p>
<ul>
<li>触发器按每个表每个事件每次地定义，每个表每个事件可以允许多个触发器。比如，可以定义一张表上两个<code>BEFORE UPDATE</code>触发器，默认会按照定义的顺序触发，想要改变顺序，可以通过指定 <code>FOLLOWS | PRECEDES [trigger name]</code>来调整顺序。</li>
<li>单一触发器不能与多个事件或多个表关联，所 以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。</li>
<li>如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。</li>
<li>级联外键操作不会激活触发器。</li>
</ul>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>删除触发器只需要用<code>DROP TRIGGER</code>即可。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> newproduct;</span><br></pre></td></tr></table></figure>
<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。</p>
<h2 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h2><h3 id="INSERT触发器"><a href="#INSERT触发器" class="headerlink" title="INSERT触发器"></a>INSERT触发器</h3><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几 点：</p>
<ul>
<li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被 插入的行；</li>
<li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改 被插入的值）；</li>
<li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值。</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder <span class="keyword">ALTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.order.num;</span><br></pre></td></tr></table></figure>
<p>此代码创建一个名为neworder的触发器，它按照AFTER INSERT ON orders执行。在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW. order_num取得 这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插<br>入使用这个触发器将总是返回新的订单号。</p>
<p>测试：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(order_date, cust_id) <span class="keyword">VALUES</span> (<span class="keyword">Now</span>(), <span class="number">10001</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>order_num</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>20010</td>
</tr>
</tbody>
</table>
<p>orders包含3个列。order_date 和 cust_id必须给出， order_num由MySQL自动生成，而现在order_num还自动被返回。</p>
<h3 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h3><p>DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两 点：</p>
<ul>
<li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</li>
<li>OLD中的值全都是只读的，不能更新。</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteorder <span class="keyword">BEFORE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> archive_orders(order_num. order_date, cust_id)</span><br><span class="line">	<span class="keyword">VALUE</span>(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>在任意订单被删除前将执行此触发器。它使用一条INSERT语句 将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）。</p>
<p>使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器 来说）为，如果由于某种原因，订单不能存档，DELETE本身将被放弃。</p>
<blockquote>
<p>多语句触发器：正如所见，触发器deleteorder使用BEGIN和 END语句标记触发器体。这在此例子中并不是必需的，不过也 没有害处。使用BEGIN END块的好处是触发器能容纳多条SQL语句（在BEGIN END块中一条挨着一条）。</p>
</blockquote>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几 点：</p>
<ul>
<li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问 以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</li>
<li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）；在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）；</li>
<li>OLD中的值全都是只读的，不能更新。</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> updatevndor <span class="keyword">BEFORE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> vendors </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SET</span> NEW.vend_state = <span class="keyword">Upper</span>(NEW.vend_state);</span><br></pre></td></tr></table></figure>
<p>何数据净化都需要在<code>UPDATE</code>语句之前进行，就像这个例子中一样。每次更新一个行时，<code>NEW.vend_state</code>中的值（将用来更新表行的值）都用<code>Upper(NEW.vend_state)</code>替换。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务处理（transaction processing）可以用来维护数据库的完整性，它 保证成批的MySQL操作要么完全执行，要么完全不执行。</p>
<p>下面是一些事务的关键词：</p>
<ul>
<li>事务（transaction）：指一组SQL语句；</li>
<li>回退（rollback）：指撤销指定SQL语句的过程；</li>
<li>提交（commit）：指将未存储的SQL语句结果写入数据库表；</li>
<li>保留点（savepoint）：指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<h2 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h2><p>管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数 据何时应该回退，何时不应该回退。</p>
<h3 id="开始事务"><a href="#开始事务" class="headerlink" title="开始事务"></a>开始事务</h3><p>可以通过以下语句来标识一个事务的开始：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用回滚（ROLLBACK）"><a href="#使用回滚（ROLLBACK）" class="headerlink" title="使用回滚（ROLLBACK）"></a>使用回滚（ROLLBACK）</h3><p>MySQL的ROLLBACK命令用来回退（撤销）MySQL语句。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertaotal;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">DELETE</span> * <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure>
<p> 这个例子从显示ordertotals表（此表在第24章中填充）的内 容开始。首先执行一条<code>SELECT</code>以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条 <code>SELECT</code>语句验证ordertotals确实为空。这时用一条<code>ROLLBACK</code>语句回退 <code>START TRANSACTION</code>之后的所有语句，最后一条<code>SELECT</code>语句显示该表不为空。</p>
<p>显然，ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）。</p>
<p>事务处理用来管理INSERT、UPDATE和 DELETE语句。你不能回退SELECT语句。（这样做也没有什么意 义。）你不能回退CREATE或DROP操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。</p>
<h3 id="提交事务（COMMIT）"><a href="#提交事务（COMMIT）" class="headerlink" title="提交事务（COMMIT）"></a>提交事务（COMMIT）</h3><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。</p>
<p>对于多条语句，要想组成一个事务，可以手动开始事务和提交，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，从系统中完全删除订单20010。因为涉及更新 两个数据库表orders和orderItems，所以使用事务处理块来<br>保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如 果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。</p>
<p>隐含事务关闭：当COMMIT或ROLLBACK语句执行后，事务会自 动关闭（将来的更改会隐含提交）。</p>
<h3 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h3><p>简单的<code>ROLLBACK</code>和<code>COMMIT</code>语句就可以写入或撤销整个事务处理。但 是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。</p>
<p>在事务中，通过以下语句来标记保留点：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> pointName;</span><br></pre></td></tr></table></figure>
<p>而在使用回滚时，则不是简单的<code>ROLLBACK</code>，而是使用以下的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> pointName;</span><br></pre></td></tr></table></figure>
<p>保留点越多越好：可以在MySQL代码中设置任意多的保留 点，越多越好。保留点越多，你就越能按自己的意愿灵活地进行回退。</p>
<p>释放保留点：保留点在事务处理完成（执行一条<code>ROLLBACK</code>或 <code>COMMIT</code>）后自动释放。自MySQL 5以来，也可以用<code>RELEASE SAVEPOINT</code>明确地释放保留点。</p>
<h3 id="更改默认的提交行为"><a href="#更改默认的提交行为" class="headerlink" title="更改默认的提交行为"></a>更改默认的提交行为</h3><p>正如所述，默认的MySQL行为是自动提交所有更改。换句话说，任何 时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>autocommit</code>标志决定是否自动提交更改，不管有没有COMMIT 语句。设置<code>autocommit</code>为0（假）指示MySQL不自动提交更改（直到<code>autocommit</code>被设置为真为止）。</p>
<h1 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h1><p>数据库表被用来存储和检索数据。不同的语言和字符集需要以不同 的方式存储和检索。因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。</p>
<p>在讨论多种语言和字符集时，将会遇到以下重要术语：</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对为规定字符如何比较的指令。</li>
</ul>
<h2 id="使用字符集和校对顺序"><a href="#使用字符集和校对顺序" class="headerlink" title="使用字符集和校对顺序"></a>使用字符集和校对顺序</h2><p>MySQL支持众多的字符集。为查看所支持的字符集完整列表，使用 以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句显示所有可用的字符集以及每个字符集的描述和默认 校对。</p>
<p>为了查看所支持校对的完整列表，使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span>;</span><br></pre></td></tr></table></figure>
<p>此语句显示所有可用的校对，以及它们适用的字符集。</p>
<p>为了给表指定字符集和校对，可使用带子句的<code>CREATE TABLE</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(</span><br><span class="line">	column1 <span class="built_in">INT</span>,</span><br><span class="line">    column2 VARCAHR(<span class="number">100</span>)</span><br><span class="line">)<span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew</span><br><span class="line"> <span class="keyword">COLLATE</span> hebrew_general_cli;</span><br></pre></td></tr></table></figure>
<p>此语句创建一个包含两列的表，并且指定一个字符集和一个校对顺序。</p>
<p>一般，MySQL使用以下规则来确定表格的字符集和校对顺序。</p>
<ul>
<li>如果指定CHARACTER SET和COLLATE两者，则使用这些值。</li>
<li>如果只指定CHARACTER SET，则使用此字符集及其默认的校对（如 SHOW CHARACTER SET的结果中所示）。</li>
<li>如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库 默认。</li>
</ul>
<p>除了能指定字符集和校对的表范围外，MySQL还允许对每个列设置 它们，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">columnn1 <span class="built_in">INT</span>,</span><br><span class="line">columnn2 <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">column3VARCHAR(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_general_ci</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrewCOLLATE hebrew_general_ci ;</span><br></pre></td></tr></table></figure>
<p>这里对整个表以及一个特定的列指定了<code>CHARACTER SET</code>和 <code>COLLATE</code>。</p>
<p>如前所述，校对在对用ORDER BY子句检索出来的数据排序时起重要 的作用。如果你需要用与创建表时不同的校对顺序排序特定的SELECT语句，可以在SELECT语句自身中进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> lastname，firstname <span class="keyword">COLLATE</span> latin1_general_cs;</span><br></pre></td></tr></table></figure>
<p>此SELECT使用COLLATE指定一个备用的校对顺序（在这个例子 中，为区分大小写的校对）。这显然将会影响到结果排序的次序。</p>
<h1 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h1><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>MySQL服务器的安全基础是：用户应该对他们需要的数据具有适当 的访问权，既不能多也不能少。换句话说，用户不能对过多的数据具有过多的访问权。</p>
<p>MySQL创建一个名为root的用户账号，它对整个MySQL服务 器具有完全的控制。你可能已经在本书各章的学习中使用root进行过登 录，在对非现实的数据库试验MySQL时，这样做很好。不过在现实世界 的日常工作中，决不能使用root。应该创建一系列的账号，有的用于管理，有的供用户使用，有的供开发人员使用，等等。</p>
<h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><p>MySQL用户账号和信息存储在名为mysql的MySQL数据库中。一般不需要直接访问mysql数据库和表（你稍后会明白这一点），但有时需要 直接访问。需要直接访问它的时机之一是在需要获得所有用户账号列表时。为此，可使用以下代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>user</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>root</td>
</tr>
</tbody>
</table>
<h3 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h3><p>可以使用<code>CREATE USER</code>语句来创建账号，</p>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ben <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'p@ssw0rd'</span>;</span><br></pre></td></tr></table></figure>
<p><code>CREATE USER</code>创建一个新用户账号。在创建用户账号时不一定需 要口令，不过这个例子用<code>IDENTIFIED BY &#39;p@$$wOrd&#39;</code>给出了一个口令。</p>
<h3 id="重命名账户"><a href="#重命名账户" class="headerlink" title="重命名账户"></a>重命名账户</h3><p>可以通过<code>RENAME USER a TO b</code>来进行用户重命名。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> ben <span class="keyword">TO</span> bforta;</span><br></pre></td></tr></table></figure>
<h3 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h3><p>可以通过<code>DROP USER xxx</code>来删除账户。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> bforta;</span><br></pre></td></tr></table></figure>
<h3 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h3><p><strong>在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访 问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。</strong></p>
<h4 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h4><p>为看到赋予用户账号的权限，使用SHOW GRANTS FOR，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> bforta;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Grants for bforta@%</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRANT USAGE ON *.* TO “bforta ‘@”%*</td>
</tr>
</tbody>
</table>
<p>输出结果显示用户bforta有一个权限USAGE ON <em>.</em>。USAGE表 示根本没有权限（我知道，这不很直观），所以，此结果表示在任意数据库和任意表上对任何东西没有权限。</p>
<h4 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h4><p>为设置权限，使用GRANT语句。GRANT要求你至少给出以下信息：</p>
<ul>
<li>要授予的权限；</li>
<li>被授予访问权限的数据库或表；</li>
<li>用户名。</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcource.* <span class="keyword">TO</span> bforta;</span><br></pre></td></tr></table></figure>
<p>此<code>GRANT</code>允许用户在<code>crashcourse.*</code>（<code>crashcourse</code>数据库的所 有表）上使用<code>SELECT</code>。通过只授予<code>SELECT</code>访问权限，用户bforta对crashcourse数据库中的所有数据具有只读访问权限。</p>
<p><code>SHOW GRANTS</code>反映这个更改：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> bforta;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Grants for bforta@%</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRANT USAGE ON *.* TO “bforta‘@’%’</td>
</tr>
<tr>
<td>GRANT SELECT ON ‘crashcourse’ .* TO ‘bforta‘@’%’</td>
</tr>
</tbody>
</table>
<p>每个GRANT添加（或更新）用户的一个权限。MySQL读取所有 授权，并根据它们确定权限。</p>
<h4 id="撤销权限"><a href="#撤销权限" class="headerlink" title="撤销权限"></a>撤销权限</h4><p><code>GRANT</code>的反操作为<code>REVOKE</code>，用它来撤销特定的权限。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse。* <span class="keyword">FROM</span> bforta;</span><br></pre></td></tr></table></figure>
<p>这条<code>REVOKE</code>语句取消刚赋予用户bforta的<code>SELECT</code>访问权限。被 撤销的访问权限必须存在，否则会出错。</p>
<p>GRANT和REVOKE可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用<code>GRANT ALL</code>和<code>REVOKE ALL</code>； </li>
<li>整个数据库，使用<code>ON database.*</code>； </li>
<li>特定的表，使用<code>ON database.table</code>； </li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<p>下面时所有的权限。</p>
<p><img src="\images\MySQL必知必会\MySQL权限1.png" alt="MySQL权限1"></p>
<p><img src="\images\MySQL必知必会\MySQL权限2.png" alt="MySQL权限2"></p>
<h3 id="更改口令"><a href="#更改口令" class="headerlink" title="更改口令"></a>更改口令</h3><p>为了更改用户口令，可使用<code>SET PASSWORD</code>语句。新口令必须如下加密：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> bforta = <span class="keyword">Password</span>(<span class="string">'n3w p@$$w0rd'</span>);</span><br></pre></td></tr></table></figure>
<p><code>SET PASSWORD</code>还可以用来设置你自己的口令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">Password</span>(<span class="string">'n3w p@$$w0rd'</span>);</span><br></pre></td></tr></table></figure>
<h1 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h1><p>像所有数据一样，MySQL的数据也必须经常备份。由于MySQL数据 库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。 但是，由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。</p>
<p>下面列出这个问题的可能解决方案。</p>
<ul>
<li>使用命令行实用程序mysqldump转储所有数据库内容到某个外部 文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。</li>
<li>可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。</li>
<li>可以使用MySQL的<code>BACKUP TABLE</code>或<code>SELECT INTO OUTFILE</code>转储所 有数据到某个外部文件。这两条语句都接受将要创建的系统文件 名，此系统文件必须不存在，否则会出错。数据可以用<code>RESTORE TABLE</code>来复原。</li>
</ul>
<h2 id="查看日志文件"><a href="#查看日志文件" class="headerlink" title="查看日志文件"></a>查看日志文件</h2><p>MySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下 几种。</p>
<ul>
<li>错误日志。它包含启动和关闭问题以及任意关键错误的细节。此 日志通常名为hostname.err，位于data目录中。此日志名可用<code>--log-error</code>命令行选项更改。</li>
<li>查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此 日志文件可能会很快地变得非常大，因此不应该长期使用它。此 日志通常名为hostname.log，位于data目录中。此名字可以用<code>--log</code>命令行选项更改。</li>
<li>二进制日志。它记录更新过数据（或者可能更新过数据）的所有 语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用<code>--log-bin</code>命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前的MySQL版本中使用的是更新日志。</li>
<li>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这 个日志在确定数据库何处需要优化很有用。此日志通常名为 hostname-slow.log ，位于 data 目录中。此名字可以用<code>--log-slow-queries</code>命令行选项更改。</li>
</ul>
<p>在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。</p>
<h1 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h1><p>下面是一些简单的可能改善MySQL性能的方法：</p>
<ul>
<li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常 是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大 小等。（为查看当前设置，可使用<code>SHOW VARIABLES</code>;和<code>SHOW STATUS;</code>。）</li>
<li>MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多 个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执 行缓慢。如果你遇到显著的性能不良，可使用<code>SHOW PROCESS LIST</code>显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用<code>KILL</code>命令终结某个特定的进程（使用这个命令需要作为管理员登录）。</li>
<li>总是有不止一种方法编写同一条<code>SELECT</code>语句。应该试验联结、并、子查询等，找出最佳的方法。</li>
<li>使用<code>EXPLAIN</code>语句让MySQL解释它将如何执行一条<code>SELECT</code>语句。</li>
<li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快。</li>
<li>应该总是使用正确的数据类型。</li>
<li><strong>决不要检索比需求还要多的数据。换言之，不要用SELECT *（除 非你真正需要每个列）。</strong></li>
<li>有的操作（包括<code>INSERT</code>）支持一个可选的<code>DELAYED</code>关键字，如果 使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li>
<li>在导入数据时，应该关闭自动提交。你可能还想删除索引（包括<code>FULLTEXT</code>索引），然后在导入完成后再重建它们。</li>
<li>必须索引数据库表以改善数据检索的性能。确定索引什么不是一 件微不足道的任务，需要分析使用的SELECT语句以找出重复的 <code>WHERE</code>和<code>ORDER BY</code>子句。如果一个简单的<code>WHERE</code>子句返回结果所花 的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。</li>
<li>使用<code>UNION</code>来替代一条包含多个<code>OR</code>的<code>SELECT</code>语句可以显著改善性能。</li>
<li><code>LIKE</code>很慢。一般来说，最好是使用<code>FULLTEXT</code>而不是<code>LIKE</code>。</li>
<li>数据库是不断变化的实体。一组优化良好的表一会儿后可能就面 目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。</li>
<li>最重要的规则就是，每条规则在某些条件下都会被打破。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL高级特征</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS学习2-异步的原理和应用</title>
    <url>/2021/04/24/NodeJS%E5%AD%A6%E4%B9%A02-%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h1><h2 id="理想的非阻塞异步I-O"><a href="#理想的非阻塞异步I-O" class="headerlink" title="理想的非阻塞异步I/O"></a>理想的非阻塞异步I/O</h2><p>完美的异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需要在I/O完成后通过回调将数据传递给应用程序即可。        </p>
<p><img src="\images\Node-JS的异步原理和应用\理想中的异步.jpg" alt="理想中的异步">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p>
<p>幸运的是：Linux下的<code>AIO</code>就是通过信号或回调来传递数据。</p>
<p>不幸的是：只有Linux下有，而且它还有缺陷-<code>AIO</code>仅支持I/O内核中的<code>O_DIRECT</code>方式读取，导致无法使用系统缓存。</p>
<h2 id="现实的异步I-O"><a href="#现实的异步I-O" class="headerlink" title="现实的异步I/O"></a>现实的异步I/O</h2><p>现实更加骨感，但是要达成I/O的目标，并非难事。前面我们将场景限定在了单线程的状态下，实际上使用多线程来模拟异步，就会轻松达成效果了。通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据及性能传递，就轻松实现了异步I/O。</p>
<p><img src="\images\Node-JS的异步原理和应用\理想中的异步.jpg" alt="理想中的异步"></p>
<p>最初的Node在*nix平台下采用了<code>libeio</code>，<code>libeio</code>实质上依然采用的线程池与阻塞I/O模拟异步I/O。配合<code>libev</code>实现I/O部分，实现了异步I/O。在<code>Node v0.9.3</code>以后，自行实现了线程池来完成异步I/O。</p>
<p>而在Windows平台下，<code>IOCP</code>在某种程度上提供了较为理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调。用户无须考虑轮询。但是它的内部依然是线程池原理，不同之处在于这些线程池是由系统内核接受管理。</p>
<p>由于Windows平台和<em>in平台的差异，Node提供了<code>libuv</code>作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的Node与下层的系定义线程池<code>IOCP</code>之间各自独立。Node会在编译期间判断平台，选择性编译\</em>nix或是win目录下的源文件到目标程序中。</p>
<p><img src="\images\Node-JS的异步原理和应用\基于libuv的架构.jpg" alt="基于libuv的架构"></p>
<p><img src="\images\Node-JS的异步原理和应用\architecture.png" alt="architecture"></p>
<p>而在*nix平台，对线程池也有不同的方案：</p>
<blockquote>
<p>The event loop follows the rather usual single threaded asynchronous I/O approach: all (network) I/O is performed on non-blocking sockets which are polled using the best mechanism available on the given platform: epoll on Linux, kqueue on OSX and other BSDs, event ports on SunOS and IOCP on Windows. As part of a loop iteration the loop will block waiting for I/O activity on sockets which have been added to the poller and callbacks will be fired indicating socket conditions (readable, writable hangup) so handles can read, write or perform the desired I/O operation.</p>
</blockquote>
<p>即：</p>
<ol>
<li>Linux平台下使用epoll</li>
<li>OSX和其他BSDs使用kqueue</li>
<li>SunOS使用event ports</li>
<li>Windows使用IOCP</li>
</ol>
<p>值得注意的是：</p>
<ol>
<li>这里的I/O不仅仅只限于磁盘文件的读写。*nix将计算机抽象了一番，磁盘文件，硬件，套接字等几乎所有的计算机资源都被抽象成为了文件，因此这里描述的阻塞和非阻塞的情况同样适用于套接字等。</li>
<li>平时我们提及到Node是单线程的，这里单线程仅仅只是JavaScript执行在单线程中。在Node中，无论是*nix或者windows平台，内部完成I/O任务的另有线程池。</li>
</ol>
<h1 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h1><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>之前在<a href="https://michaelwang.top/2021/02/09/JavaScript%E5%AE%8F%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8EEvent-loop/" target="_blank" rel="noopener">JavaScript宏任务，微任务与Event-loop</a>简单介绍过事件循环的概念。</p>
<p>其在进程启动时，Node便会创建一个类似于<code>while(true)</code>的循环，每执行一次循环体的过程我们称为一个Tick，每个Tick的过程就是查看是否有事件待处理。如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行他们。然后进入下一个循环，如果不再有事件处理，就退出进程。</p>
<p><img src="\images\Node-JS的异步原理和应用\Tick流程.jpg" alt="Tick流程"></p>
<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>在每一个Tick中，都是通过观察者来判断是否有事件需要处理。</p>
<p>每个事件循环有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。</p>
<p>浏览器采用了类似的机制。事件可能来自用户的点击或者加载某个文件时产生，而这些产生的事件都有对应的观察者。在Node中，事件主要来源于网络请求，文件I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O观察者等。观察者将事件进行了分类。</p>
<p>事件循环是一个经典的生产者/消费者模型。异步I/O，网络请求等则是网络事件的请求者，源源不断的为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</p>
<p>这里用到了观察者模式，在<a href="https://michaelwang.top/2021/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">设计模式5-发布-订阅模式（观察者模式）</a>详细介绍过。</p>
<h2 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h2><p>在异步请求回调中，从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做<strong>请求对象</strong>。</p>
<p>下面以<code>fs.open()</code>作为例子，来看一下其源代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">open</span>(<span class="params">path, flags, mode, callback</span>) </span>&#123;</span><br><span class="line">  path = getValidatedPath(path);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    callback = flags;</span><br><span class="line">    flags = <span class="string">'r'</span>;</span><br><span class="line">    mode = <span class="number">0o666</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> mode === <span class="string">'function'</span>) &#123;</span><br><span class="line">    callback = mode;</span><br><span class="line">    mode = <span class="number">0o666</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mode = parseFileMode(mode, <span class="string">'mode'</span>, <span class="number">0o666</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> flagsNumber = stringToFlags(flags);</span><br><span class="line">  callback = makeCallback(callback);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> req = <span class="keyword">new</span> FSReqCallback();</span><br><span class="line">  req.oncomplete = callback;</span><br><span class="line"></span><br><span class="line">  binding.open(pathModule.toNamespacedPath(path),</span><br><span class="line">               flagsNumber,</span><br><span class="line">               mode,</span><br><span class="line">               req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fs.open()</code>是根据指定的路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初始操作。从代码可以看出，JavaScript层面的代码是通过调用C++核心模块进行下层的操作。其执行流程如下：</p>
<p><img src="\images\Node-JS的异步原理和应用\fs调用.jpg" alt="fs调用"></p>
<p>这里是JavaScript典型的调用方法：</p>
<ol>
<li>从JavaScript调用Node的核心模块</li>
<li>核心模块调用C++内建模块</li>
<li>内建模块通过libuv进行系统调用</li>
</ol>
<p>在libuv中，实质上调用了<code>uv_fs_open()</code>方法。在<code>uv_fs_open()</code>方法中，调用了<code>uv_fs_req_init</code>，将传入的参数添加到<strong><code>uv_fs_t</code>请求对象</strong>上。从JavaScript层传入的参数和当前方法都被封装在这个请求对象中，其中我们最为关注的回调函数被设置在这个对象的<code>cb</code>上属性上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">INLINE <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv_fs_req_init</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req,</span></span></span><br><span class="line"><span class="function"><span class="params">    uv_fs_type fs_type, <span class="keyword">const</span> uv_fs_cb cb)</span> </span>&#123;</span><br><span class="line">  uv_req_init(loop, (<span class="keyword">uv_req_t</span>*) req);</span><br><span class="line"></span><br><span class="line">  req-&gt;type = UV_FS;</span><br><span class="line">  req-&gt;loop = loop;</span><br><span class="line">  req-&gt;flags = <span class="number">0</span>;</span><br><span class="line">  req-&gt;fs_type = fs_type;</span><br><span class="line">  req-&gt;result = <span class="number">0</span>;</span><br><span class="line">  req-&gt;ptr = <span class="literal">NULL</span>;</span><br><span class="line">  req-&gt;path = <span class="literal">NULL</span>;</span><br><span class="line">  req-&gt;cb = cb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象封装完毕后，在Windows下，则调用<code>QUEUE_FS_TP_JOB()</code>=&gt;<code>uv__req_register()</code>=&gt;<code>QUEUE_INSERT_TAIL()</code>方法将这个<code>uv_fs_t</code>对象推入，线程池中等待执行，该方法的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QUEUE_INSERT_TAIL(&amp;(loop)-&gt;active_reqs, &amp;(req)-&gt;active_queue);</span><br></pre></td></tr></table></figure>
<p>该方法接受2个参数：</p>
<ol>
<li><code>&amp;(loop)-&gt;active_reqs</code>：要执行的方法的引用。</li>
<li><code>&amp;(req)-&gt;active_queue</code>：事件循环队列。</li>
</ol>
<p>至此，JavaScript调用立即返回，由JavaScript底层发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前的后续操作。当前的I/O操作在线程池中等待执行，不断是否阻塞I/O，都不会影响JavaScript线程的后续操作，如此就达到了异步的目的。</p>
<p>（在<code>libuv</code>0.1中，Windows使用的是<code>QueueUserWorkItem()</code>API，而在Unix使用的是默认4个的线程池，而在1.0版本中，在Windows与Unix统一了标准，都是用了线程池，更新公告如下：）</p>
<blockquote>
<p>Threadpool changes</p>
<p><strong><del>~</del><del>~</del><del>~</del>~~~</strong></p>
<p>In libuv 0.10 Unix used a threadpool which defaulted to 4 threads, while Windows used the</p>
<p><code>QueueUserWorkItem</code> API, which uses a Windows internal threadpool, which defaults to 512</p>
<p>threads per process.</p>
<p>In 1.0, we unified both implementations, so Windows now uses the same implementation Unix</p>
<p>does. The threadpool size can be set by exporting the <code>UV_THREADPOOL_SIZE</code> environment</p>
<p>variable. See :c:ref:<code>threadpool</code>.</p>
</blockquote>
<p><strong>请求对象时异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。</strong></p>
<h2 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h2><p> 组装好请求对象，送入I/O线程池等待执行，实际上完成了异步I/O第一部分，回调通知是第二部分。</p>
<p>线程池中的I/O操作调用完毕之后，会将获取的结果存储在<code>req-&gt;result</code>属性上，然后调用<code>PostQueuedCompletionStatus()</code>通知IOCP，告知当前对象操作已经完成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PostQueuedCompletionStatus(loop-&gt;iocp, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><code>PostQueuedCompletionStatus()</code>方法的作用是向IOCP提交执行状态，并将线程归还给线程池。通过<code>PostQueuedCompletionStatus()</code>方法提交的状态，可以通过<code>GetQueueCompletionStatus()</code>提取。</p>
<p>在这个过程中，其实还动用了事件循环的I/O观察者。在每次Tick的执行中，它会调用IOCP相关的<code>GetQueueCompletionStatus()</code>方法检测线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中然后将其作为事件处理。</p>
<p>I/O观察者回调函数的行为就是取出请求对象的<code>result</code>属性作为参数，取出<code>cb</code>属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。</p>
<p><img src="\images\Node-JS的异步原理和应用\整个异步IO流程.jpg" alt="整个异步IO流程"></p>
<p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p>
<h1 id="非I-O的异步API"><a href="#非I-O的异步API" class="headerlink" title="非I/O的异步API"></a>非I/O的异步API</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><code>setTimeout()</code>和<code>setInterval()</code>与浏览器中的API是一致的，分别用于单词和多次定时器执行任务。他们的实现与异步I/O相似，只是不需要I/O线程池的参与。调用<code>setTimeout()</code>或者<code>setInterval()</code>创建的定时器会被插入到定时器观察者内部的一个<strong>红黑树</strong>。每次Tick执行时，会从红黑树迭代取出定时器对象，检查是否超过定时时间，如果超过，就会形成一个事件，它的回调函数会立即执行。</p>
<p>众所周知，定时器并不是那么准确其原因也在于事件循环，虽然事件循环非常快，但是如果某个循环占用的时间比较多，那么下次循环时，它也许已经超时很久了。</p>
<p><img src="\images\Node-JS的异步原理和应用\setTimeout.jpg" alt="setTimeout"></p>
<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><code>process.nextTick()</code></h2><p><code>process.nextTick()</code> 会添加 <code>callback</code> 到下一个时间点队列。 在 JavaScript 堆栈上的当前操作运行完成之后，且允许事件循环继续之前，此队列会被完全耗尽。</p>
<p>此方法与<code>setTimeout</code>比起来，更加轻量级，因为不需要动用红黑树，创建定时器对象和迭代等操作。其代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `nextTick()` will not enqueue any callback when the process is about to</span></span><br><span class="line"><span class="comment">// exit since the callback would not have a chance to be executed.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  validateCallback(callback);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process._exiting)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> args;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: args = [<span class="built_in">arguments</span>[<span class="number">1</span>]]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: args = [<span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>]]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: args = [<span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>], <span class="built_in">arguments</span>[<span class="number">3</span>]]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++)</span><br><span class="line">        args[i - <span class="number">1</span>] = <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">    setHasTickScheduled(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> asyncId = newAsyncId();</span><br><span class="line">  <span class="keyword">const</span> triggerAsyncId = getDefaultTriggerAsyncId();</span><br><span class="line">  <span class="keyword">const</span> tickObject = &#123;</span><br><span class="line">    [async_id_symbol]: asyncId,</span><br><span class="line">    [trigger_async_id_symbol]: triggerAsyncId,</span><br><span class="line">    callback,</span><br><span class="line">    args</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (initHooksExist())</span><br><span class="line">    emitInit(asyncId, <span class="string">'TickObject'</span>, triggerAsyncId, tickObject);</span><br><span class="line">  queue.push(tickObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次调用<code>process.nextTick()</code>方法只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器采用红黑树的操作时间复杂度为O(lg(n))，<code>nextTick()</code>的时间复杂度为O(1)。</p>
<h2 id="setIMmediate"><a href="#setIMmediate" class="headerlink" title="setIMmediate()"></a><code>setIMmediate()</code></h2><p><code>setImmediate()</code>方法与<code>process.nextTick()</code>方法类似，都是将回调函数延迟执行。但是两者之间还是有一定的区别：</p>
<ol>
<li><code>process.nextTick()</code>方法优先级要高于<code>setImmediate()</code>。</li>
<li><code>process.nextTick()</code>的回调函数保存在一个数组中，<code>setImmediate()</code>的回调函数函数保存在链表中。</li>
<li><code>process.nextTick()</code>在每轮循环中执行链表中的一个回调函数，而<code>setImmediate()</code>在每轮循环中执行链表中的一个回调函数。</li>
</ol>
<p>其优先级不同的原因在于：事件循环对观察者的检查是有先后顺序的，<code>process.nextTick()</code>属于<code>idle</code>观察者，<code>setImmediate()</code>属于<code>check</code>观察者。在每轮循环中，<code>idle</code>观察者先于I/O观察者，I/O观察者先于<code>check</code>观察者。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nexiTick延迟执行1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nexiTick延迟执行2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行1'</span>)</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'强势插入'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'正常执行'</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<blockquote>
<p>正常执行<br>nexiTick延迟执行1<br>nexiTick延迟执行2<br>setImmediate延迟执行1<br>强势插入<br>setImmediate延迟执行2</p>
</blockquote>
<h1 id="异步编程的优势与难点"><a href="#异步编程的优势与难点" class="headerlink" title="异步编程的优势与难点"></a>异步编程的优势与难点</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p><strong>Node带来的最大特性莫过于事件驱动的非阻塞模型。非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。</strong></p>
<p>Node利用事件循环的方式，JavaScript线程池像一个分配任务和处理结果的管家，I/O线程池中的各个I/O线程都是小二。负责完成分配来的任务，小二与管家之间互不依赖，所以可以保持整体的高效率。但是由于JavaScript是单线程，所以，这个系统的极限就是JavaScript线程。换言之，Node为了解决编程模型中阻塞I/O的性能问题，采用了单线程模型，这导致Node更像是一个处理I/O密集问题的能手，而CPU密集型取决于管家的能耐如何。</p>
<p>而通过C++写出来的V8虽然相较于原生C++多了一个编译过程。但是性能仍然可以逼近顶尖。</p>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在传统的同步编程中，通常使用Java的<code>try/catch/final</code>语句块来进行异常捕获。但是这对于异步编程并不适用。因为在之前提到过，异步I/O主要分为两个阶段：请求提交和处理结果。这两个阶段中间有事件循环机制，两者彼此不相关联。异步方法则通常在第一个阶段请求后立即返回，因为异常不一定发生在这个阶段，<code>try...catch...</code>不会生效。</p>
<p>在Node中为了解决这个问题，一般形成了一个约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步回调没有抛出。在这个约定中，我们在编写的异步方法上。也必须取遵循这样几个原则：</p>
<p>原则一：必须执行调用者传入的回调函数。</p>
<p>原则二：正确传递回异常供调用者判断。</p>
<p>示例代码中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = something</span><br><span class="line">        <span class="keyword">if</span>(error)&#123;</span><br><span class="line">            <span class="keyword">return</span> callback(error)</span><br><span class="line">        &#125;</span><br><span class="line">        callback(<span class="literal">null</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外可能出现的错误写法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    req.body = <span class="built_in">JSON</span>.parse(buf, options.receiver)</span><br><span class="line">    callback()</span><br><span class="line">&#125;<span class="keyword">catch</span> (err)&#123;</span><br><span class="line">    err.body = buf</span><br><span class="line">    err.status = <span class="number">400</span></span><br><span class="line">    callback(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的意图是捕获是捕获<code>JSON.parse()</code>中可能出现的异常，但是却不小心包含了用户传递的回调函数。这意味着如果回调函数中有异常抛出，将会进入<code>catch()</code>代码块中执行，于是回调函数将会被执行两次。这样显然不是预期的结果，可能导致业务混乱。正确的代码应为✔：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    req.body = <span class="built_in">JSON</span>.parse(buf, options.reviver)</span><br><span class="line">&#125;<span class="keyword">catch</span> (err)&#123;</span><br><span class="line">    err.body = buf</span><br><span class="line">    err.status = <span class="number">400</span></span><br><span class="line">    <span class="keyword">return</span> callback(err)	    <span class="comment">//直接return，不再执行下面的操作</span></span><br><span class="line">&#125;</span><br><span class="line">callback()</span><br></pre></td></tr></table></figure>
<p>另外还有一种方法就是将错误时执行的回调一并传递给异步函数，在异步函数出错时直接调用错误的回调函数就行了，而且现在普遍采用这种方式，典型的比如<code>Promise.then(suc, fail)</code>，或者<code>Axios</code>等框架的设计。</p>
<p>简单的例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span>(<span class="params">success, fail</span>)</span>&#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> res = something</span><br><span class="line">            success(res)</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            fail(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要更多参数，可以把函数参数设置为一个对象，现在普遍是这么做的。</p>
<h3 id="函数嵌套过深"><a href="#函数嵌套过深" class="headerlink" title="函数嵌套过深"></a>函数嵌套过深</h3><p>这也是Node开发被人诟病最多的地方。在现代前端工程化开发中，由于采用Node作为支持，特别是在网络请求中，经常会出现嵌套过深的问题，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;req1, req2, req3&#125; <span class="keyword">from</span> <span class="string">'api.js'</span></span><br><span class="line"></span><br><span class="line">req1().then(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> param1 = res1.param</span><br><span class="line">    req2(param).then(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> param2 = res2.param</span><br><span class="line">        req3(param).then(<span class="function"><span class="params">res3</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//DO SOMETHING WITH res3</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样的问题目前仍然困扰着开发人员。</p>
<h4 id="async函数解决办法"><a href="#async函数解决办法" class="headerlink" title="async函数解决办法"></a><code>async</code>函数解决办法</h4><p>但是ES6的<code>async</code>函数为我们提供了一个解决该问题的途径，它可以使我们像编写同步代码一样编写异步代码，其本质是<code>Promise</code>的语法糖。</p>
<p><code>async</code>函数在定义的时候需要使用<code>async</code>关键词，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">req1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//REQ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>async</code>函数会返回一个<code>Promise</code>对象，可以使用<code>then</code>方法获取结果。<strong>当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</strong></p>
<p>具体的用法可以参考<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></p>
<p>用<code>async</code>可以将上面请求的代码改写为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;req1, req2, req3&#125; <span class="keyword">from</span> <span class="string">'api.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleReq</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> param1 = <span class="keyword">await</span> req1()</span><br><span class="line">    <span class="keyword">let</span> param2 = <span class="keyword">await</span> req2(param1)</span><br><span class="line">    <span class="keyword">let</span> param3 = <span class="keyword">await</span> req3(param2)</span><br><span class="line">    <span class="keyword">return</span> param3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前的问题有两个（第一个也许不算）：</p>
<ol>
<li><code>await</code>命令只能在<code>async</code>函数中使用，而<code>async</code>返回的是一个<code>promise</code>对象，也就是说，我们必须最后再调用一个<code>then()</code>方法用于获取结果。（或许这不算什么问题，至少让嵌套次数减少到一次）</li>
<li>兼容性问题：</li>
</ol>
<p><img src="\images\Node-JS的异步原理和应用\async.png" alt="async"></p>
<p>可以看出，IE完全不支持，chrome也到55版本才支持，所以兼容性是一个很大的问题。</p>
<p>但是如果在工程化的前端开发中，由于多了预编译过程，所以使用ES6的语法会被转义为ES5的可接受代码。比如<code>vue-cli</code>中，在初始化项目时就包含了<code>babel</code>。</p>
<h3 id="阻塞代码"><a href="#阻塞代码" class="headerlink" title="阻塞代码"></a>阻塞代码</h3><p>在Node中还有一个问题是，没有<code>sleep()</code>这样的线程沉睡功能，能用做延时操作的只有<code>setInterval</code>和<code>setTimeout</code>。但这两个函数并不能阻塞后面的代码执行。</p>
<p>很多人会使用<code>while</code>方式实现阻塞，但是由于Node是单线程，所以使用<code>while</code>会持续占用CPU进行判断，这与真正的线程沉睡相差甚远我，完全破环了事件循环的调度。官方推荐的是使用<code>setTimeout</code>来实现，但是问题在于，<code>setTimeout</code>无法阻塞后面的代码运行。</p>
<h4 id="setTimeout实现"><a href="#setTimeout实现" class="headerlink" title="setTimeout实现"></a><code>setTimeout</code>实现</h4><p>实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//TO DO AFTER 3 SECOND</span></span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br><span class="line">otherFunc1()</span><br><span class="line">otherFunc2()</span><br></pre></td></tr></table></figure>
<p>这里虽然定时器内的代码会被延迟执行，但是后面的otherFunc1()，otherFunc2()都会立即执行，这样不符合我们印象中的<code>sleep()</code></p>
<h4 id="setTimeout配合async实现"><a href="#setTimeout配合async实现" class="headerlink" title="setTimeout配合async实现"></a><code>setTimeout</code>配合<code>async</code>实现</h4><p>刚才我们讲过<code>async</code>会一直等待<code>await</code>后的语句执行完毕，才会执行后面的语句，所以我们可以利用这个点实现<code>sleep</code>功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, interval);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">one2FiveInAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">one2FiveInAsync();</span><br></pre></td></tr></table></figure>
<p>当然，还有一个问题就是，我们使用<code>sleep()</code>的函数必须定义为<code>async</code>函数，也就是说，外部调用该函数时，也必须定义为<code>async</code>，或者处理<code>Promise</code>。</p>
<h1 id="异步编程的解决方案"><a href="#异步编程的解决方案" class="headerlink" title="异步编程的解决方案"></a>异步编程的解决方案</h1><h2 id="事件发布订阅模式"><a href="#事件发布订阅模式" class="headerlink" title="事件发布订阅模式"></a>事件发布订阅模式</h2><p>事件监听器模式是一种广泛应用于异步编程的模式，是回调函数的事件化，又称为发布订阅模式。具体实现可以参见之前写过的<a href="https://michaelwang.top/2021/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">设计模式5-发布-订阅模式（观察者模式）</a>。</p>
<p>Node自身提供的<code>event</code>模块是发布订阅模式的一个简单实现，<code>Node</code>中的部分模块抖继承自它，这个模块比前端浏览器中的大量DOM事件简单，不存在事件冒泡，也不存在<code>preventDefault()</code>，<code>stopPropagation()</code>和<code>stopImmediatePropagatiom()</code>等控制事件传递的方法（在14.5版本中，已经写出了<code>Event</code>类，实现了<code>event.bubbles</code>,<code>event.cancelBubble()</code>等方法，但是还没有实现，等待后面官方实现吧）。它具有<code>addListener/om()</code>，<code>once()</code>，<code>removeListener()</code>，<code>removeAllListeners()</code>和<code>emit()</code>等基本的事件监听模式的方法实现。时间发布/订阅模式的操作比较简单，示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅</span></span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'触发事件'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布</span></span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br></pre></td></tr></table></figure>
<p>事件发布订阅模式一般来说有两个用处：</p>
<ul>
<li>业务逻辑解耦，事件发布者无须关注订阅的监听器如何实现业务逻辑，甚至不用关心有多少个监听器的存在，数据通过消息的方式可以很灵活地传递。</li>
<li>另一个角度来看，事件监听模式也是一种钩子（hook）机制，利用钩子导出内部数据或者状态给外部的调用者。</li>
</ul>
<p>期中<code>HTTP</code>请求时经典场景：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postData = querystring.stringify(&#123;</span><br><span class="line">  <span class="string">'msg'</span>: <span class="string">'你好世界'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  hostname: <span class="string">'nodejs.cn'</span>,</span><br><span class="line">  port: <span class="number">80</span>,</span><br><span class="line">  path: <span class="string">'/upload'</span>,</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">    <span class="string">'Content-Length'</span>: Buffer.byteLength(postData)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = http.request(options, (res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`状态码: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`响应头: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(res.headers)&#125;</span>`</span>);</span><br><span class="line">  res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">  res.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`响应主体: <span class="subst">$&#123;chunk&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'响应中已无数据'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听事件</span></span><br><span class="line">req.on(<span class="string">'error'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`请求遇到问题: <span class="subst">$&#123;e.message&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据写入请求主体。</span></span><br><span class="line">req.write(postData);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<p>在<code>HTTP</code>请求的代码种，程序员只需要将视线放在<code>error</code>，<code>data</code>，<code>end</code>这些业务事件点上即可，至于内部的流程如何，无需过多关注。</p>
<p>值得一提的是：<code>Node</code>对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性而考虑的。</p>
<ol>
<li><p>如果对一个事件添加超过了10个监听器，将会得到一条警告。这一处设计于Node自身单线程运行有关，设计设认为太多的监听器太多可能导致内存泄漏，所以会存在这样一条警告。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(node:4004) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 event listeners added to [MyEmitter]. Use emitter.setMaxListeners() to increase <span class="built_in">limit</span></span><br></pre></td></tr></table></figure>
<p>调用<code>emitter.setMaxListeners()</code>，参数设为0或者Infinity表示不限制监听器的数量。另一方面，由于时间发布会引起一系列监听器执行，如果事件相关的监听器过多，可能存在过多占用CPU的情景。</p>
</li>
<li><p>为了处理异常，<code>EventEmitter</code>对象对<code>error</code>事件进行了特殊对待。如果运行期间的错误出发了<code>error</code>事件，<code>EventEmitter</code>会检查是否有对<code>error</code>事件添加过监听器。如果添加了，这个错误会交由监听器处理，否则这个错误会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的<code>EventEmitter</code>示例应该对<code>error</code>事件进行处理。                                                        </p>
</li>
</ol>
<h2 id="Promise-Deferred模式"><a href="#Promise-Deferred模式" class="headerlink" title="Promise/Deferred模式"></a>Promise/Deferred模式</h2><p>使用时间的方式时，执行流程需要被余预先设定。即便是分支，也需要预先设定，这是由发布/订阅模式的运行机制所决定的。下面为普通的Ajax调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api', &#123;</span><br><span class="line">    success: onSuccess,</span><br><span class="line">    error: onError,</span><br><span class="line">    complete: onComplete</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的异步调用中，必须严谨的设置目标。那么是否有一种先执行异步调用，延迟传递处理的方式呢？答案就是<code>Promise/Deferred</code>模式。</p>
<p><code>Promise/Deferred</code>模式最早在JavaScript框架中出现于Dojo的代码中，被广为所知则是来自jQuery1.5版本，该版本几乎重写了Ajax部分，是的调用Ajax可以通过错如下的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('./api')</span><br><span class="line">    .success(onSuccess)</span><br><span class="line">    .error(onError)</span><br><span class="line">    .complete(onComplete)</span><br></pre></td></tr></table></figure>
<p>这使得即使不调用<code>success()</code>，<code>error()</code>等方法，Ajax也会执行。</p>
<p>在原始的API中，一个事件只能处理一个回调，而通过<code>Deffered</code>对象，可以对事件加入任意的业务处理逻辑，示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api')</span><br><span class="line">    .success(onSuccess1)</span><br><span class="line">    .success(onSuccess2)</span><br></pre></td></tr></table></figure>
<p><code>Promise/Deffered</code>模式在2009年时被Kris Zyp抽象为一个提案，发布在<code>CommonJS</code>规范中。随着使用<code>Promise/Deffered</code>模式的应用逐渐增多，<code>Promise/Deffered</code>提案已经抽象出<code>Promise/A</code>、<code>Promise/B</code>、<code>Promise/D</code>等典型的模式。随后<code>Promise/A</code>规范已经成为EcmaScript的官方规范。ES6中的<code>Promise</code>规范即为<code>Promise/A</code>规范。</p>
<p>具体的<code>Promise</code>原理和手写可以看我的这两篇文章：</p>
<ol>
<li><a href="https://michaelwang.top/2021/02/04/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Promise的实现</a></li>
<li><a href="https://michaelwang.top/2019/06/28/Promise%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">Promise理解</a></li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本文大部分参考《深入浅出nodejs》以及<a href="https://nodejs.org/" target="_blank" rel="noopener">Node</a>官网</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS学习1-模块机制</title>
    <url>/2021/04/22/NodeJS%E5%AD%A6%E4%B9%A01-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>commonJS制定了一套模块的规范，来解决当时JavaScript中没有完善的模块机制，但是现在ES Module已经比较成熟了，在前端工程化开发中大部分都是用的ES Module来进行模块的导入导出。</p>
<p>由于内容比较多，之前在<a href="https://michaelwang.top/2021/02/14/JavaScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/" target="_blank" rel="noopener">JavaScript中的模块导入导出</a>中已经介绍过基本用法。详细的内容可以看<a href="https://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="Node的模块实现"><a href="#Node的模块实现" class="headerlink" title="Node的模块实现"></a>Node的模块实现</h2><p>Node中，模块总的分为两类：</p>
<ol>
<li>核心模块：由Node提供的模块</li>
<li>文件模块：由用户编写的模块</li>
</ol>
<p>这两类模块都会经过以下三个步骤：</p>
<ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>
<p>注意：</p>
<ol>
<li>核心模块部分在Node源代码中就被编译为了二进制文件。Node在启动时即被载入到内存中，所以这部分核心模块在引入的时候，文件定位和编译执行这两个步骤可以省略掉，所以其加载速度要快于文件模块。文件模块则是在运行时动态加载的，需要完整的路径分析，文件定位和编译执行过程，所以起运行速度要慢于核心模块。</li>
<li>Node是默认缓存加载为第一优先级，无论是核心模块还是文件模块。require()方法对相同模块的二次加载一律采用缓存优先的方式。</li>
</ol>
<h3 id="路径分析"><a href="#路径分析" class="headerlink" title="路径分析"></a>路径分析</h3><p>由于<code>require()</code>函数接受多种标识符，所以不同标识符也有不同的分析方法。大致分为以下几类：</p>
<ol>
<li>核心模块，如：http, fs, path等</li>
<li>以<code>.</code>或<code>..</code>开始的相对路径文件模块</li>
<li>以<code>/</code>开始的绝对路径文件模块</li>
<li>非核心路径的文件模块，如自定义的connect模块</li>
</ol>
<h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>核心模块的优先级仅次于缓存加载，其在Node中的源代码编译过程中已经编译为了二进制代码，其加载速度最快。</p>
<p>由于其优先级高于自定义模块，所以我们定义一个标识符与核心模块相同的自定义模块是无法被成功加载的。</p>
<h4 id="路径形式的文件模块"><a href="#路径形式的文件模块" class="headerlink" title="路径形式的文件模块"></a>路径形式的文件模块</h4><p>以<code>.</code>或<code>..</code>开始的标识符，都会被当作文件模块来处理。并且在初次加载时会将其转换为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。</p>
<h4 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h4><p>自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种页数的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。这与<code>CommonJS</code>中规定的<code>node_modules</code>的模块文件夹有关，但是在Node中的自定义模块的查找是一个与JavaScript中原型链查找相似，Node首先查找当前目录下的<code>node_modules</code>文件夹下是否存在该模块（注意这里的文件名在下面讲），然后查看父级目录下的<code>node_modules</code>是否存在该模块，再查看父级目录的父级目录是否存在<code>node_modules</code>，形成了一个链。只要在更近一层中发现该模块，即不再向外查找。</p>
<p>由于这种递归式的查找，所以其速度是最慢的。</p>
<p><strong>模块路径：</strong></p>
<p>模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。其本质就是前面提到的，当前目录下的<code>mode_modules</code>文件夹，父级目录下的<code>mode_modules</code>文件夹，父级目录的父级目录下的<code>node_modules</code>。</p>
<p>所以当我们新建一个js文件（该文件可以放在任意目录下），然后输入<code>console.log(module.paths)</code>。</p>
<p>执行该文件后就会得到一个类似下面数组的输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'/home/aa/bb/node_modules'</span>,</span><br><span class="line">    <span class="string">'/home/aa/node_modules'</span>,</span><br><span class="line">    <span class="string">'/home/node_modules'</span>,</span><br><span class="line">    <span class="string">'node_modules'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h3><h4 id="文件扩展名分析"><a href="#文件扩展名分析" class="headerlink" title="文件扩展名分析"></a>文件扩展名分析</h4><p><code>require()</code>函数接受不包含扩展名的文件标识符。这种情况下，Node会按<code>.js</code>，<code>.json</code>，<code>node</code>的次序补足扩展名，依次尝试。</p>
<p>在尝试的过程中，需要调用fs模块同步阻塞式的判断文件是否存在，由于Node是单线程的，所以这里可能会引起一点性能问题。所以，在使用<code>node</code>，<code>json</code>文件时，加上扩展名，会稍微提高一点速度。另外就是可以使用缓存机制，也可以大幅度的环节Node单线程阻塞调用的缺陷。</p>
<h4 id="目录分析和包"><a href="#目录分析和包" class="headerlink" title="目录分析和包"></a>目录分析和包</h4><p>在分析标识符的过程中，<code>require()</code>通过分析文件扩展名之后，可能没有发现对应文件，但是确得到了一个目录，这在引入自定义模块和组个模块路径进行查找时经常出现。此时，Node会将该目录作为一个包来处理。</p>
<p>此时，Node会在当前目录下查找<code>package.json</code>文件（CommonJS包规范定义的包描述文件），通过<code>JSON.parse()</code>解析出包描述对象。从中取得<code>mian</code>属性指定的文件进行定位。如果文件名缺少扩展名，将会重复上面的扩展名分析过程。</p>
<p>如果<code>mian</code>属性指定的文件名错误，或者和没有<code>package.json</code>文件，Node会将index当作默认文件名，然后依次尝试查找<code>index.js</code>,<code>index.json</code>,<code>index.node</code>。</p>
<p>如果上面的过程都没有定位到任何文件，则定义模块进入下一个模块路径（上一级路径）进行查找。</p>
<p>如果所有路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。</p>
<h3 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h3><p>在Node中，每个文件模块都是一个对象，它的定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(parent &amp;&amp; parent.children)&#123;</span><br><span class="line">        parend.child.push(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.filename = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.loaded = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.children = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译和执行时引入文件模块的最后一个阶段。定位到具体文件后，Node会新建一个模块对象，然后根据路径载入并编译。具体不同的文件会有不同的处理方法：</p>
<ul>
<li>js文件：通过fs模块同步读取文件后编译执行。</li>
<li>node文件：用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生效的文件。</li>
<li>json文件：通过fs模块同步读取文件后，用<code>JSON.parse()</code>解析返回结果。</li>
<li>其余扩展名文件：它们会被当作js文件载入。</li>
</ul>
<h3 id="JavaScript模块的编译"><a href="#JavaScript模块的编译" class="headerlink" title="JavaScript模块的编译"></a>JavaScript模块的编译</h3><p>在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了<code>(function(exports, require, __filename, __dirname){\n</code>，在尾部添加了<code>\n})</code>，则一个正常的JavaScript文件会被包装成如下的样子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">exports, require, module, __filename, __dirname</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>)</span><br><span class="line">    <span class="keyword">export</span>.area = <span class="function"><span class="keyword">function</span>(<span class="params">radius</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> math.PI * radius * radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>即形成了一个闭包，这样每个模块文件之间都进行了作用域隔离。包装过后的代码会通过vm原生的<code>runInThisContext()</code>方法执行（类似于eval，只是具有明确的上下文，不污染全局），返回一个<code>function</code>对象。在这一个过程后，模块就会具有<code>exports</code>属性,<code>require</code>方法，<code>module</code>（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个<code>funciton</code>执行。</p>
<p>注意：模块中的<code>exports</code>是<code>module.export</code>的一个形参传递，所以我们必须向<code>module.export</code>添加对象，否则无法添加导出属性。</p>
<h3 id="C-C-模块的编译"><a href="#C-C-模块的编译" class="headerlink" title="C/C++模块的编译"></a>C/C++模块的编译</h3><p>Node调用<code>process.dlopen()</code>方法进行加载和执行。在Node的架构下，<code>dlopen()</code>方法在Windows和*nix平台下分别有不同的实现，通过libnv兼容层进行了封装。</p>
<p>实际上，.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译产生的，所以这里只有加载和执行过程。在执行过程中，模块的<code>exports</code>对象与.node魔窟啊产生联系，然后返回给调用者。</p>
<p>C/C++模块给Node使用者带来的优势主要是执行效率方面的，劣势则是C/C++模块的编写门槛比JavaScript高。</p>
<h3 id="JSON文件的编译"><a href="#JSON文件的编译" class="headerlink" title="JSON文件的编译"></a>JSON文件的编译</h3><p>.json文件的编译是3种编译方式中最简单的。Node利用fs模块同步读取JSON文件文件的内容之后，调用<code>JSON.parse()</code>方法得到对象，然后将它赋值给模块对象的<code>exports</code>，以供外部调用。</p>
<p>JSON文件在用做项目的配置文件时比较有用。如果你定义了一个JSON文件作为配置，那就不必调用fs模块去异步读取和解析，直接调用<code>require()</code>即可引入。</p>
<h2 id="核心模块-1"><a href="#核心模块-1" class="headerlink" title="核心模块"></a>核心模块</h2><p>Node的核心模块在编译成为可执行文件的过程中被编译进了二进制文件，核心模块也分为C/C++编写的和JavaScript编写的两部分，期中C/C++文件存放在Node项目中的src目录下，JavaScript文件存放在lib目录下。</p>
<h3 id="JavaScript核心模块的编译过程"><a href="#JavaScript核心模块的编译过程" class="headerlink" title="JavaScript核心模块的编译过程"></a>JavaScript核心模块的编译过程</h3><p>在编译所有C/C++文件之前，编译程序需要将所有的JavaScript模块文件编译为C/C++代码，但此时并不会将其编译为可以执行的C/C++代码，而是将其以字符串的形式存储在数组中。具体过程如下：</p>
<h4 id="转存为C-C-代码"><a href="#转存为C-C-代码" class="headerlink" title="转存为C/C++代码"></a>转存为C/C++代码</h4><p>Node采用了V8自带的<code>js2c.py</code>工具，将所有内置的JavaScript代码（<code>src/node.js和lib/*.js</code>）转换为C++里的数组，生成<code>node_natives.h</code>头文件中。</p>
<p>在这个过程中，JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。</p>
<h4 id="编译JavaScript核心模块"><a href="#编译JavaScript核心模块" class="headerlink" title="编译JavaScript核心模块"></a>编译JavaScript核心模块</h4><p>lib目录下的所有文件也没有定义require,module,exports这些变量。所以也需要经历文件模块的编译过程。但与文件模块不同的是：获取源代码的位置，核心模块在启动时就被载入内存，所以调用时是直接从内存中取；而文件模块还需要从磁盘中读取。这个速度差别很大。</p>
<p>在代码实现中是通过<code>process.binding(&#39;natives&#39;)</code>取出，编译成功的模块缓存到NativeModule._cache对象中，文件模块则缓存到Module._cache上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NativeModule</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fileName = id + <span class="string">'.js'</span></span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;</span><br><span class="line">   	<span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NativeModule._source = process.binding(<span class="string">'navives'</span>)</span><br><span class="line">NativeModule._cache = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-C-模块的编译过程"><a href="#C-C-模块的编译过程" class="headerlink" title="C/C++模块的编译过程"></a>C/C++模块的编译过程</h3><p>在核心模块中，大致分为两类：</p>
<ol>
<li>全部由C/C++编写，我们称为<strong>内建模块</strong>。</li>
<li><p>由C/C++完成核心部分，其他部分则由JavaScript实现包装或向外导出。</p>
<p>第二种情况下                                    一                般是以C/C++完成核心功能，由JavaScript实现包装或向外导出，这样可以平衡脚本语言与静态语言的开发速度与运行效率。</p>
</li>
</ol>
<h4 id="内建模块的组织形式"><a href="#内建模块的组织形式" class="headerlink" title="内建模块的组织形式"></a>内建模块的组织形式</h4><p>在Node中，内建模块的内部结构定义如下，其在<code>node.h</code>中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_module</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nm_version;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nm_flags;</span><br><span class="line">  <span class="keyword">void</span>* nm_dso_handle;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* nm_filename;</span><br><span class="line">  node::addon_register_func nm_register_func;</span><br><span class="line">  node::addon_context_register_func nm_context_register_func;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* nm_modname;</span><br><span class="line">  <span class="keyword">void</span>* nm_priv;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">nm_link</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个内建模块在定义之后，都通过<code>NODE_MODULE</code>宏定义到node命名空间中，模块的具体初始化方法挂在为结构的<code>register_func</code>成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODLE(modname, regfunc)&#123;</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">        NODE_MODULE_EXPORT node::node_module_struct modname ## _module=</span><br><span class="line">        &#123;</span><br><span class="line">            NODE_STANDARD_MODULE_STUFF,</span><br><span class="line">            regfunc,</span><br><span class="line">            NODE_STRINGFY(modename)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>node_extensions.h文件将这些散列的内建模块统一放进了一个叫<code>node_module_list</code>的数组中，这些模块有：</p>
<ul>
<li>node_buffer</li>
<li>node_crypto</li>
<li>node_evals</li>
<li>node_fs</li>
<li>node_http_parser</li>
<li>node_os</li>
<li>node_zlib</li>
<li>node_timer_wrap</li>
<li>node_udp_wrap</li>
<li>node_pipe_wrap</li>
<li>node_cares_wrap</li>
<li>node_tty_wrap</li>
<li>node_process_wrap</li>
<li>node_fs_event_wrap</li>
<li>node_signal_watcher</li>
</ul>
<p>这些内建模块通过Node提供的<code>get_buildin_module()</code>方法从<code>node_module_list</code>数组中取出这些模块。</p>
<p><strong>内建模块的优势：</strong></p>
<ul>
<li>由C/C++编写，所以性能上由于脚本语言。</li>
<li>直接被加载收到内存中，速度快于从磁盘中查找。</li>
</ul>
<h4 id="内建模块的导入导出"><a href="#内建模块的导入导出" class="headerlink" title="内建模块的导入导出"></a>内建模块的导入导出</h4><p>通常来说，在Node中，由JavaScript编写的核心模块依赖于C/C++编写的内建模块。而文件模块一般依赖于核心模块，而不是直接调用内建模块。</p>
<p><img src="\images\Node-JS的模块机制\依赖层次.jpg" alt="依赖层次"></p>
<p>Node在启动时候，会生成一个全局变量<code>process</code>，并会提供一个<code>Binding()</code>方法用来协助内建模块。</p>
<h2 id="C-C-扩展模块"><a href="#C-C-扩展模块" class="headerlink" title="C/C++扩展模块"></a>C/C++扩展模块</h2><p>C/C++扩展模块是属于文件模块得一类。C/C++模块通过预编译为.node文件，在调用<code>process.dlopen()</code>方法来加载执行。</p>
<p>注意：<code>.node</code>文件实际上是编译过后得二进制文件，所以在不同平台下是不同的，在Windows下，其就是一个<code>.dll</code>文件，在*nix下，其是一个<code>.so</code>文件，加一个<code>.node</code>是为了看起来更自然。</p>
<p>在<code>dlopen()</code>中，实现了分平台加载<code>.so</code>，<code>.dll</code>的方法。</p>
<p>所以一个不同的<code>.node</code>文件是无法混用的，必须重新在其平台下编译成正确的<code>.node</code>文件。</p>
<p><img src="\images\Node-JS的模块机制\原生模块加载流程.jpg" alt="原生模块加载流程"></p>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol>
<li>GYP项目生成工具：Node编译工具，可以通过<code>npm install -g node-gyp</code>命令安装。</li>
<li>V8引擎C++库：V8是Node自身动力来源之一。它自身由C++写成，可以实现JavaScript与C++互相调用。</li>
<li>libuv库：libuv也是Node自身的动力来源之一。其是一个跨平台的一层封装，通过它去调用一些底层操作，比自己在各个平台下编写实现要高效得多。libuv封装得功能包括事件循环、文件操作等。</li>
<li>Node内部库：写C++模块时，免不了要做一些面向对象得编程工作，而Node自身提供了一些C++代码，比如<code>node::ObjectWrap</code>类可以用来包装你的自定义类，它可以帮助实现对象回收等工作。</li>
<li>其他库：其他存在<code>deps</code>目录下的库在编写扩展模块时也许可以帮助你，比如<code>zlib,openssl,http_parser</code>等。</li>
</ol>
<h3 id="C-C-扩展模块的编写"><a href="#C-C-扩展模块的编写" class="headerlink" title="C/C++扩展模块的编写"></a>C/C++扩展模块的编写</h3><p>与核心模块的编写不同，普通的扩展模块不需要无须将源代码编译进Node，而是通过<code>dlopen()</code>方法动态加载。所以在编写普通模块时，无须将源代码写入node命名空间，也不需要提供头文件。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h5><p>JavaScript写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello world'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> demo &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line"><span class="keyword">using</span> v8::Isolate;</span><br><span class="line"><span class="keyword">using</span> v8::Local;</span><br><span class="line"><span class="keyword">using</span> v8::Object;</span><br><span class="line"><span class="keyword">using</span> v8::<span class="keyword">String</span>;</span><br><span class="line"><span class="keyword">using</span> v8::Value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  Isolate* isolate = args.GetIsolate();</span><br><span class="line">  args.GetReturnValue().Set(<span class="keyword">String</span>::NewFromUtf8(</span><br><span class="line">      isolate, <span class="string">"Hello world"</span>).ToLocalChecked());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">  NODE_SET_METHOD(exports, <span class="string">"sayHello"</span>, Method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// 命名空间示例</span></span><br></pre></td></tr></table></figure>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>在不同的平台都可以使用GYP工具进行编译。</p>
<p>首先需要编写<code>.gyp</code>项目文件。<code>node-gyp</code>约定<code>.gyp</code>文件为<code>bidning.gyp</code>，其内容示例如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    'target': [</span><br><span class="line">        &#123;</span><br><span class="line">            'target_name': 'hello',</span><br><span class="line">            'source': [</span><br><span class="line">                'src/hello.cc'</span><br><span class="line">            ],</span><br><span class="line">            'condition': [</span><br><span class="line">                [</span><br><span class="line">                    'OS == <span class="string">"win"</span>',</span><br><span class="line">                    &#123;</span><br><span class="line">                        'libraries': ['-lnode.lib']</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node-gyp configure</span><br></pre></td></tr></table></figure>
<p>接下来会生成一些其他文件，在*nix平台下，会生成Makefile等文件；在Windows下，则会生成vcxproj等文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node-gyp build</span><br></pre></td></tr></table></figure>
<p>此时gyp会根据平台，分别进行make或vcbuild进行编译。编译完成后，<code>hello.node</code>文件会生成了<code>build/Release</code>目录下。</p>
<p>注意：</p>
<p>Node.js 使用了静态链接库，比如 V8、libuv 和 OpenSSL。 所有的插件都需要链接到 V8，也可能链接到任何其他的依赖项。 通常情况下，只要简单地引入相应的 <code>#include &lt;...&gt;</code> 声明（如 <code>#include &lt;v8.h&gt;</code>），则 <code>node-gyp</code> 将会自动地定位到相应的头文件。 但是也有一些注意事项需要留意：</p>
<ul>
<li>当 <code>node-gyp</code> 运行时，<strong>它将会检测指定的 Node.js 发行版本，并下载完整的源代码包或只是头文件</strong>。</li>
</ul>
<p>如果下载了完整的源代码，则插件将会具有对完整的 Node.js 依赖项的完全访问权限。 如果只下载了 Node.js 的头文件，则只有 Node.js 公开的符号可用。</p>
<ul>
<li>可以使用 <code>--nodedir</code> 标志指向本地的 Node.js 源代码镜像来运行 <code>node-gyp</code>。</li>
</ul>
<p>如果使用此选项，则插件将有权访问全部依赖项。</p>
<p>注意：工具之间存在兼容性问题，最开始我在实验时的版本是:</p>
<ul>
<li>Visual Studio -2019</li>
<li>Node.js -12.14.0</li>
<li>node-gym -8.0.0</li>
<li>python -3.9</li>
</ul>
<p>结果一直报语法错误，示例如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  Hello.cc</span><br><span class="line">D:\Test\Node\native\Hello.cc(16,25): error C2039: <span class="string">"ToLocalChecked"</span>: 不是 <span class="string">"v8::Local&lt;v8::String&gt;"</span> 的成员 [D:\Test\Node\native\build\hello.vcxproj]</span><br><span class="line">C:\Users\Administrator\AppData\Local\node-gyp\Cache\12.14.0\include\node\v8.h(1311): message : 参见“v8::Local&lt;v8::String&gt;”的声明 [D:\Test\Node\native\build\hello.vcxproj]</span><br><span class="line">gyp ERR! build error </span><br><span class="line">gyp ERR! stack     at ChildProcess.onExit (C:\Users\Administrator\AppData\Roaming\nvm\v12.14.0\node_modules\node-gyp\lib\build.js:194:23)</span><br><span class="line">gyp ERR! stack     at ChildProcess.emit (events.js:210:5)</span><br><span class="line">gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12)</span><br><span class="line">gyp ERR! System Windows_NT 10.0.19042</span><br><span class="line">gyp ERR! <span class="built_in">command</span> <span class="string">"C:\\Program Files\\nodejs\\node.exe"</span> <span class="string">"C:\\Program Files\\nodejs\\node_modules\\node-gyp\\bin\\node-gyp.js"</span> <span class="string">"build"</span></span><br><span class="line">gyp ERR! cwd D:\Test\Node\native</span><br><span class="line">gyp ERR! node -v v12.14.0</span><br><span class="line">gyp ERR! node-gyp -v v8.0.0</span><br><span class="line">gyp ERR! not ok</span><br></pre></td></tr></table></figure>
<p>网上貌似错误经验不多，我折腾了很久，最后决定换以下node版本，这里使用了<code>nvm</code>版本切换工具。转为最新的<code>15.5.1</code>版本，然后就成功构建了。</p>
<h3 id="C-C-扩展模块的加载"><a href="#C-C-扩展模块的加载" class="headerlink" title="C/C++扩展模块的加载"></a>C/C++扩展模块的加载</h3><p>得到<code>hello.node</code>文件后，直接通过<code>require()</code>方法来进行标识符解析，路径解析，文件定位，然后加载执行即可。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">'./build/Release/hello.node'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(hello.sayHello())</span><br></pre></td></tr></table></figure>
<h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><p>实际上，<code>require()</code>在引入.node文件的过程中，实际上经历了4个层面上的调用。</p>
<p>加载.node文件实际上经历了两个步骤：</p>
<ul>
<li>调用<code>uv_dlopen()</code>方法去打开动态链接库。</li>
<li>调用<code>uv_dlsym</code>方法找到动态链接库中通过NODE_MODULE宏定义的方法地址。</li>
</ul>
<p>这两个步骤都是通过libuv库进行封装的：</p>
<ul>
<li>在*nix平台下实际上调用的是dlfcn.h头文件中定义的<code>dlopen()</code>和<code>dlsym()</code>两个方法；</li>
<li>在Windows平台则是通过<code>LoadLibraryExW()</code>和<code>GetProcAddress()</code>这两个方法实现的。他们分别加载.so和.dll文件（即.node文件）</li>
</ul>
<p><img src="\images\Node-JS的模块机制\node文件加载流程.jpg" alt="node文件加载流程"></p>
<p>即我们一般不直接调用<code>process.dlopen()</code>，而是通过<code>require()</code>来获取编写的Node模块。在<code>process.md</code>中写到：</p>
<blockquote>
<p> <strong><code>process.dlopen(module, filename[, flags])</code></strong></p>
<!-- YAML

added: v0.1.16

changes:

 \- version: v9.0.0

  pr-url: https://github.com/nodejs/node/pull/12794

  description: Added support for the `flags` argument.

-->
<p>* <code>module</code> {Object}</p>
<p>* <code>filename</code> {string}</p>
<p>* <code>flags</code> {os.constants.dlopen} <strong><em>\</em>Default:**</strong> <code>os.constants.dlopen.RTLD_LAZY</code></p>
<p>The <code>process.dlopen()</code> method allows dynamically loading shared objects. It is</p>
<p>primarily used by <code>require()</code> to load C++ Addons, and should not be used</p>
<p>directly, except in special cases. In other words, [<code>require()</code>][] should be</p>
<p>preferred over <code>process.dlopen()</code> unless there are specific reasons such as</p>
<p>custom dlopen flags or loading from ES modules.</p>
</blockquote>
<p>所以最后总结一下Node中各种模块之间的关系则为：</p>
<p> <img src="\images\Node-JS的模块机制\模块调用关系.jpg" alt="模块调用关系"></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本文大部分参考《深入浅出nodejs》</p>
<p>以及：</p>
<ul>
<li><a href="http://nodejs.cn/api/addons.html#addons_c_addons" target="_blank" rel="noopener">C++ 插件</a></li>
<li><a href="https://github.com/nodejs/node-gyp" target="_blank" rel="noopener">node-gyp</a></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Node学习4-Buffer</title>
    <url>/2021/04/28/Node%E5%AD%A6%E4%B9%A04-Buffer/</url>
    <content><![CDATA[<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p><code>Buffer</code> 对象用于表示固定长度的字节序列。</p>
<p>从V3.0开始，该对象就继承自<a href="http://url.nodejs.cn/ZbDkpm" target="_blank" rel="noopener">Uint8Array</a>（从V3.0版本加入的特性），且继承时带上了涵盖额外用例的方法。只要支持 <code>Buffer</code> 的地方，Node.js API 都可以接受普通的 <a href="http://url.nodejs.cn/ZbDkpm" target="_blank" rel="noopener"><code>Uint8Array</code></a></p>
<h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><p>Buffer是一个典型的JavaScript与C++结合的模块，它将性能部分用C++实现，将非性能相关的部分用JavaScript实现。</p>
<p><img src="D:\myblog\myblog\source\images\Node-JS的Buffer\buffer.png" alt="buffer"></p>
<p>之前说过，Buffer所占的内存不过是V8分配的，属于堆外内存。由于V8垃圾回收性能的影响，将通用的操作对象用更高效和专用的内存分配回收来管理是个不错的思路。</p>
<h2 id="Buffer内存分配"><a href="#Buffer内存分配" class="headerlink" title="Buffer内存分配"></a>Buffer内存分配</h2><p>在最开始的Node版本中，是采用了slab分配机制，并且使用构造函数来新建一个Buffer，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bf = <span class="keyword">new</span> Buffer(<span class="number">100</span>)</span><br><span class="line"><span class="comment">//新建一个长度为100的Buffer</span></span><br></pre></td></tr></table></figure>
<p>并且在内部判断是否大于8KB来使用<code>slab</code>算法。</p>
<p>但是自V5.10版本开始时，新增了<code>Buffer.alloc(size)</code>。在V5.12新增了<code>Buffer.allocUnsafe(size)</code>。并且在于V6.0版本废除该API。</p>
<p>在Node启动的时候，Buffer 模块会预分配一个内部的大小为 <code>Buffer.poolSize</code> （默认为8KB）的 Buffer 实例，作为快速分配的内存池，用于使用 <code>Buffer.allocUnsafe()</code> 创建新的 Buffer 实例、或 <code>Buffer.from(array)</code>、或 <code>Buffer.concat()</code>、或弃用的 <code>new Buffer(size)</code> 构造器但仅当 size 小于或等于 <code>Buffer.poolSize &gt;&gt; 1</code>（<code>Buffer.poolSize</code> 除以二再向下取整）。</p>
<h3 id="Buffer-alloc-size-fill-encoding"><a href="#Buffer-alloc-size-fill-encoding" class="headerlink" title="Buffer.alloc(size[, fill[, encoding]])"></a><code>Buffer.alloc(size[, fill[, encoding]])</code></h3><p>该API最大的特点是，永远不会使用内部的<code>Buffer</code>池，而是直接分配。我们来查看其源代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new filled Buffer instance.</span></span><br><span class="line"><span class="comment"> * alloc(size[, fill[, encoding]])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Buffer.alloc = <span class="function"><span class="keyword">function</span> <span class="title">alloc</span>(<span class="params">size, fill, encoding</span>) </span>&#123;</span><br><span class="line">  assertSize(size);</span><br><span class="line">  <span class="comment">//有初始化的Buffer，则先申请unsafeBuffer，再填充</span></span><br><span class="line">  <span class="keyword">if</span> (fill !== <span class="literal">undefined</span> &amp;&amp; fill !== <span class="number">0</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> buf = createUnsafeBuffer(size);</span><br><span class="line">    <span class="keyword">return</span> _fill(buf, fill, <span class="number">0</span>, buf.length, encoding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//无填充的话直接新建FastBuffer，FastBuffer是Uint8Array的子类</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FastBuffer(size);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里会判断是否有填充，如果没有填充或者size&lt;0，则直接返回一个<code>FastBuffer</code>。这里的<code>FastBuffer</code>是<code>Uint8Array</code>的一个子类，源代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastBuffer</span> <span class="keyword">extends</span> <span class="title">Uint8Array</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Using an explicit constructor here is necessary to avoid relying on</span></span><br><span class="line">  <span class="comment">// `Array.prototype[Symbol.iterator]`, which can be mutated by users.</span></span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-useless-constructor</span></span><br><span class="line">  <span class="keyword">constructor</span>(bufferOrLength, byteOffset, length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(bufferOrLength, byteOffset, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p id="createUnsafeBuffer">我们再看如果有填充并且长度不为0，则调用<code>createUnsafeBuffer</code>返回一个未初始化的数组，我们再来看一下其源代码：</p>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A toggle used to access the zero fill setting of the array buffer allocator</span></span><br><span class="line"><span class="comment">// in C++.</span></span><br><span class="line"><span class="comment">// |zeroFill| can be undefined when running inside an isolate where we</span></span><br><span class="line"><span class="comment">// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.</span></span><br><span class="line"><span class="keyword">let</span> zeroFill = getZeroFillToggle();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUnsafeBuffer</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  zeroFill[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FastBuffer(size);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    zeroFill[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到看到这里的定义是为了解决当运行在一个我们没有一个ArrayBuffer的分配器的独立容器时，<code>zeroFill</code>可能为<code>undefined</code>时，所以调用<code>getZeroFillToggle</code>来直接获取<code>zeroFill</code>，用来解决这个问题。</p>
<p>可以看到整个过程中，没有使用到缓冲池<code>pool</code>的代码。正因如此，这种方式，要比下面的两个API慢得多。</p>
<h3 id="Buffer-allocUnsafe-size"><a href="#Buffer-allocUnsafe-size" class="headerlink" title="Buffer.allocUnsafe(size)"></a><code>Buffer.allocUnsafe(size)</code></h3><p>以这种方式创建的 <code>Buffer</code> 实例的底层内存是未初始化的。 新创建的 <code>Buffer</code> 的内容是未知的，可能包含敏感数据。</p>
<p>该API会在<code>size</code>小于<code>Buffer.poolSize</code>的一半的时使用内部的缓冲池。让我们来看一下该API的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer</span></span><br><span class="line"><span class="comment"> * instance. If `--zero-fill-buffers` is set, will zero-fill the buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Buffer.allocUnsafe = <span class="function"><span class="keyword">function</span> <span class="title">allocUnsafe</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  assertSize(size);</span><br><span class="line">  <span class="keyword">return</span> allocate(size);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p id="allocate">可以看到内部先判断大小，然后直接返回<code>allocate</code>整个函数的返回值，我们再看<code>allocate</code>函数。</p>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocate</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FastBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果分配的大小小于4KB</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; (Buffer.poolSize &gt;&gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="comment">//剩下的缓冲池不足，则新建一个缓冲池</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (poolSize - poolOffset))</span><br><span class="line">      createPool();</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">new</span> FastBuffer(allocPool, poolOffset, size);</span><br><span class="line">    poolOffset += size;</span><br><span class="line">    alignPool();</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createUnsafeBuffer(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里就很明显有一个对于缓冲池的判断，如果小于<code>size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)</code>，即默认小于4KB，则再判断缓冲池是否够，不够就新建一个<code>pool</code>然后缓冲池偏移。这里本质上还是一个<code>slab</code>算法，我们后面再讲。</p>
<p>但是当不满足<code>size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)</code>时，会调用<code>createUnsafeBuffer</code>，这个函数即<code>Buffer.alloc()</code>有填充时处理的<a href="createUnsafeBuffer">情况</a>，即直接调用C++内存分配，不从缓冲池分配。</p>
<h3 id="Buffer-allocUnsafeSlow-size"><a href="#Buffer-allocUnsafeSlow-size" class="headerlink" title="Buffer.allocUnsafeSlow(size)"></a><code>Buffer.allocUnsafeSlow(size)</code></h3><p>以这种方式创建的 <code>Buffer</code> 实例的底层内存是未初始化的。 <code>Buffer</code> 的内容是未知的，可能包含敏感数据。 </p>
<p>刚才提到了，<code>Buffer.allocUnsafe(size)</code>在分配的内存小于4KB时，会使用内部的缓冲池。 这可以避免垃圾回收机制因创建太多独立的 <code>Buffer</code> 而过度使用。 通过消除跟踪和清理尽可能多的单个 <code>ArrayBuffer</code> 对象的需要，该方法可以提高性能和内存使用率。</p>
<p>但是当我们不想从缓冲池中分配内存，而是直接在内存中保有一小块内存时，就可以使用这个API来创建一个非内存池的<code>Buffer</code>。</p>
<p>下面我们来看一下其源代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Equivalent to SlowBuffer(num), by default creates a non-zero-filled</span></span><br><span class="line"><span class="comment"> * Buffer instance that is not allocated off the pre-initialized pool.</span></span><br><span class="line"><span class="comment"> * If `--zero-fill-buffers` is set, will zero-fill the buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Buffer.allocUnsafeSlow = <span class="function"><span class="keyword">function</span> <span class="title">allocUnsafeSlow</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  assertSize(size);</span><br><span class="line">  <span class="keyword">return</span> createUnsafeBuffer(size); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到代码很简单，先判断大小，然后直接调用<a href="createUnsafeBuffer">allocUnsafeSlow</a>，从内存直接分配。</p>
<h3 id="slab算法"><a href="#slab算法" class="headerlink" title="slab算法"></a>slab算法</h3><p>当我们使用<code>Buffer.allocUnsafe(size)</code>且内存小于4KB时，就会使用内部的缓冲池，而这个缓冲池的设计就是一个<code>slab</code>算法。所以下面简单介绍一下这个算法。</p>
<p>slab算法是一种动态内存管理机制，最早诞生于SunOS系统中，目前在一些*nix系统中有广泛的应用，如FreeBSD和Linux。</p>
<p>简而言之，slab就是一块申请好的固定大小的内存区域。slab区域具有如下的3种状态：</p>
<ol>
<li>full：完全分配状态。</li>
<li>partial：部分分配状态。</li>
<li>empty：没有被分配状态。</li>
</ol>
<p>下面我们看一下创建缓冲池的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  poolSize = Buffer.poolSize;</span><br><span class="line">  allocPool = createUnsafeBuffer(poolSize).buffer;</span><br><span class="line">  markAsUntransferable(allocPool);</span><br><span class="line">  poolOffset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">createPool();</span><br></pre></td></tr></table></figure>
<p>可以看到实际上就是在定义后立即调用，内部调用了<code>createUnsafeBuffer</code>预先申请一个<code>Buffer.poolSize</code>的缓冲池。并且将<code>poolOffset</code>设置为0，即没被占用。</p>
<p>我们回顾之前的allocate函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocate</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FastBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果分配的大小小于4KB</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; (Buffer.poolSize &gt;&gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="comment">//剩下的缓冲池不足，则新建一个缓冲池</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (poolSize - poolOffset))</span><br><span class="line">      createPool();</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">new</span> FastBuffer(allocPool, poolOffset, size);</span><br><span class="line">    poolOffset += size;</span><br><span class="line">    alignPool();</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createUnsafeBuffer(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现，其在分配完缓冲池后，会做两件事：</p>
<ol>
<li>poolOffset += size：增加偏移量。</li>
<li>alignPool()：居中缓冲池。</li>
</ol>
<p>第一个时间不用详细解释，即将刚才分配的内存添加到全局的<code>poolOffset</code>中取。</p>
<p>而第二个函数，我们看看其源代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alignPool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Ensure aligned slices</span></span><br><span class="line">  <span class="keyword">if</span> (poolOffset &amp; <span class="number">0x7</span>) &#123;</span><br><span class="line">    poolOffset |= <span class="number">0x7</span>;</span><br><span class="line">    poolOffset++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码运用了两个位运算，实际上第一个判断是判断<code>poolOffset</code>是否超过了缓冲池的一半，如果没有，则将其定位在缓冲池一半的位置（结合上面判断新建的Buffer的大小是否小于缓冲池的一半）。即实现函数的名字：居中缓冲池。</p>
<p>所以，这种slab算法会造成内存的浪费，因为如果pool的前一部分非常小，只有几个字节，但是由于会进行居中缓冲池的操作，最后这个Buffer仍然会占据<code>Buffer.poolSize &gt;&gt;&gt; 1</code>大小的内存。</p>
<p>（这里我不确定是不是slab算法，因为上面的根据源代码总结出的算法与Linux中slab算法有较大的差距，而很多文章都说Node中Buffer就是slab算法，待我后续确定）</p>
<h2 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h2><p>Buffer对象可以与字符串之间进行相互转换。</p>
<h3 id="字符串转Buffer"><a href="#字符串转Buffer" class="headerlink" title="字符串转Buffer"></a>字符串转Buffer</h3><p>字符串转Buffer主要是通过<code>Buffer.from()</code>函数实现：</p>
<p>这个函数有多个重载函数，可以实现从字符串，数组和对象的到Buffer的转换，具体参见<a href="http://nodejs.cn/api/buffer.html" target="_blank" rel="noopener">Node官网</a></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Buffer.from(<span class="string">'fhqwhgads'</span>, <span class="string">'utf8'</span>));</span><br><span class="line"><span class="comment">// 打印: &lt;Buffer 66 68 71 77 68 67 61 64 73&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(Buffer.from(<span class="string">'fhqwhgads'</span>, <span class="string">'utf16le'</span>));</span><br><span class="line"><span class="comment">// 打印: &lt;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf1 = Buffer.from(<span class="string">'buffer'</span>);</span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.from(buf1);</span><br><span class="line"></span><br><span class="line">buf1[<span class="number">0</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf1.toString());</span><br><span class="line"><span class="comment">// 打印: auffer</span></span><br><span class="line"><span class="built_in">console</span>.log(buf2.toString());</span><br><span class="line"><span class="comment">// 打印: buffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'this is a test'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf = Buffer.from(<span class="keyword">new</span> Foo(), <span class="string">'utf8'</span>);</span><br><span class="line"><span class="comment">// 打印: &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;</span></span><br></pre></td></tr></table></figure>
<p>Node.js当前支持的编码如下：</p>
<ul>
<li><code>&#39;utf8&#39;</code>: 多字节编码的 Unicode 字符。 许多网页和其他文档格式都使用 <a href="http://url.nodejs.cn/mzW5jo" target="_blank" rel="noopener">UTF-8</a>。 <strong>这是默认的字符编码</strong>。 当将 <code>Buffer</code> 解码为不专门包含有效 UTF-8 数据的字符串时，则会使用 Unicode 替换字符 <code>U+FFFD</code> � 来表示这些错误。</li>
<li><code>&#39;utf16le&#39;</code>: 多字节编码的 Unicode 字符。 与 <code>&#39;utf8&#39;</code> 不同，字符串中的每个字符都会使用 2 个或 4 个字节进行编码。 Node.js 仅支持 <a href="http://url.nodejs.cn/CJHzJq" target="_blank" rel="noopener">UTF-16</a> 的<a href="http://url.nodejs.cn/HY3tVp" target="_blank" rel="noopener">小端序</a>变体。</li>
<li><code>&#39;latin1&#39;</code>: Latin-1 代表 <a href="http://url.nodejs.cn/z8AaDs" target="_blank" rel="noopener">ISO-8859-1</a>。 此字符编码仅支持从 <code>U+0000</code> 到 <code>U+00FF</code> 的 Unicode 字符。 每个字符使用单个字节进行编码。 超出该范围的字符会被截断，并映射成该范围内的字符。</li>
</ul>
<p>使用以上方法之一将 <code>Buffer</code> 转换为字符串，称为解码；将字符串转换为 <code>Buffer</code>，称为编码。</p>
<p>Node.js 还支持以下两种二进制转文本的编码。 对于二进制转文本的编码，其命名约定是相反的：将 <code>Buffer</code> 转换为字符串通常称为编码，而将字符串转换为 <code>Buffer</code> 则称为解码。</p>
<ul>
<li><code>&#39;base64&#39;</code>: <a href="http://url.nodejs.cn/fum2xU" target="_blank" rel="noopener">Base64</a> 编码。 当从字符串创建 <code>Buffer</code> 时，此编码也会正确地接受 <a href="http://url.nodejs.cn/j8aS4R" target="_blank" rel="noopener">RFC 4648 第 5 节</a>中指定的 “URL 和文件名安全字母”。 base64 编码的字符串中包含的空格字符（例如空格、制表符和换行）会被忽略。</li>
<li><code>&#39;hex&#39;</code>: 将每个字节编码成两个十六进制的字符。 当解码仅包含有效的十六进制字符的字符串时，可能会发生数据截断。 请参见下面的示例。</li>
</ul>
<p>还支持以下传统的字符编码：</p>
<ul>
<li><code>&#39;ascii&#39;</code>: 仅适用于 7 位 <a href="http://url.nodejs.cn/pLT1D9" target="_blank" rel="noopener">ASCII</a> 数据。 当将字符串编码为 <code>Buffer</code> 时，这等效于使用 <code>&#39;latin1&#39;</code>。 当将 <code>Buffer</code> 解码为字符串时，则使用此编码会在解码为 <code>&#39;latin1&#39;</code> 之前额外取消设置每个字节的最高位。 通常，当在编码或解码纯 ASCII 文本时，应该没有理由使用这种编码，因为 <code>&#39;utf8&#39;</code>（或者，如果已知的数据始终为纯 ASCII，则为 <code>&#39;latin1&#39;</code>）会是更好的选择。 这仅为传统的兼容性而提供。</li>
<li><code>&#39;binary&#39;</code>: <code>&#39;latin1&#39;</code> 的别名。 有关此编码的更多背景，请参阅<a href="http://url.nodejs.cn/x5E3Yh" target="_blank" rel="noopener">二进制字符串</a>。 该编码的名称可能会引起误解，因为此处列出的所有编码都是在字符串和二进制数据之间转换。 对于在字符串和 <code>Buffer</code> 之间进行转换，通常 <code>&#39;utf-8&#39;</code> 是正确的选择。</li>
<li><code>&#39;ucs2&#39;</code>: <code>&#39;utf16le&#39;</code> 的别名。 UCS-2 以前是指 UTF-16 的一种变体，该变体不支持代码点大于 U+FFFF 的字符。 在 Node.js 中，始终支持这些代码点。</li>
</ul>
<h4 id="Buffer不支持的编码"><a href="#Buffer不支持的编码" class="headerlink" title="Buffer不支持的编码"></a>Buffer不支持的编码</h4><p>Node目前支持的编码格式依然比较少，包括在中国常用的GBK, GB2312, BIG-5等。为此，Buffer提供了一个<code>Buffer.isEncoding()</code>方法来判断编码是否被Node支持。</p>
<p>对于不支持的编码类型，可以借助Node生态圈中的模块完成转换，<code>iconv</code>和<code>iconv-lite</code>两个模块都可以支持更多的编码类型的转换，包括Windwos 125系列、ISO-8859系列、IBM/DOS代码页系列、Macintosh系列、KO18系列，以及Latin1、US-ASCII、也支持宽字节编码GBK和GB2312。</p>
<p><code>iconv-lite</code>使用纯JavaScript实现，<code>iconv</code>则通过C++调用libiconv库完成。前者比后者更轻量无须编译和处理环境依赖直接使用。在性能方面，由于转码都是消耗CPU，在V8的高性能下，少了C++到JavaScript的层次转换，纯JavaScript的性能比C++表现得更好。具体使用参见：</p>
<ul>
<li><a href="https://github.com/bnoordhuis/node-iconv" target="_blank" rel="noopener">node-iconv</a></li>
<li><a href="https://github.com/ashtuchkin/iconv-lite" target="_blank" rel="noopener">iconv-lite</a></li>
</ul>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>Buffer在使用中，通常是以一段一段的方式传输。例如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReaderStream(<span class="string">'test.md'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">''</span></span><br><span class="line">rs.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    data += chunk</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面这段代码常见于国外，用于流读取得师范，data事件中得获取的chunk对象即为Buffer对象。对于初学者而言，容易将Buffer当作字符串来理解，所以在接受上面示例时不会觉得有任何异常。</p>
<p>但是一旦流中出现宽字符时，问题就会暴露出来。如果你在通过Node开发的网站上看到�乱码符号，那么问题多半来自这里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data += chunk</span><br></pre></td></tr></table></figure>
<p>这段代码里隐藏了<code>toString()</code>操作，它等价于下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data = data.toString() + chunk.toString()</span><br></pre></td></tr></table></figure>
<p>值得注意的是：外国人的语境通常是英文环境，没有宽字符，在他们的场景中，这个<code>toString()</code>不会造成任何问题。但是对于宽字符的中文，却会形成问题。</p>
<p>其主要原因在于，每次<code>data</code>事件发生时，其读取的长度不一定为指定宽字符长度的整倍数，比如UTF-8中，每个字符的长度为3个字节，但是如果我们一次读取的字节为10个字节，那么前两个字符会被正常显示，但是第三个字符只录入了1/3，所以其无法正常显示，最后会被显示为�。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="setEncoding"><a href="#setEncoding" class="headerlink" title="setEncoding()"></a><code>setEncoding()</code></h5><p>可读流还有一个设置编码的方法<code>setEncoding()</code>，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">readable.setEncoding(encoding)</span><br></pre></td></tr></table></figure>
<p>该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。为此，我们改进之前的程序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123;<span class="attr">highWaterMark</span>: <span class="number">11</span>&#125;)</span><br><span class="line">rs.setEncoding(<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>
<p>再次执行，即可得到正常的结果，说明输出不再受Buffer大小的影响了。</p>
<p>这里我们可以稍微看一下这个函数的源代码（<code>src/lib/internal/streams/readable.js</code>）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Backwards compatibility.</span></span><br><span class="line">Readable.prototype.setEncoding = <span class="function"><span class="keyword">function</span>(<span class="params">enc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!StringDecoder)</span><br><span class="line">    StringDecoder = <span class="built_in">require</span>(<span class="string">'string_decoder'</span>).StringDecoder;</span><br><span class="line">  <span class="keyword">const</span> decoder = <span class="keyword">new</span> StringDecoder(enc);</span><br><span class="line">  <span class="keyword">this</span>._readableState.decoder = decoder;</span><br><span class="line">  <span class="comment">// If setEncoding(null), decoder.encoding equals utf8.</span></span><br><span class="line">  <span class="keyword">this</span>._readableState.encoding = <span class="keyword">this</span>._readableState.decoder.encoding;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> buffer = <span class="keyword">this</span>._readableState.buffer;</span><br><span class="line">  <span class="comment">// Iterate over current buffer to convert already stored Buffers:</span></span><br><span class="line">  <span class="keyword">let</span> content = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> data <span class="keyword">of</span> buffer) &#123;</span><br><span class="line">    content += decoder.write(data);</span><br><span class="line">  &#125;</span><br><span class="line">  buffer.clear();</span><br><span class="line">  <span class="keyword">if</span> (content !== <span class="string">''</span>)</span><br><span class="line">    buffer.push(content);</span><br><span class="line">  <span class="keyword">this</span>._readableState.length = content.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，内部新建了一个<code>StringDecoder</code>，每次data事件发生时，<code>decoder</code>对象会将对得到的<code>Buffer</code>到<code>String</code>的转码，然后传递给调用者。</p>
<p>其中<code>string_decoder</code>之所以能够解决这个问题，是因为其会判断当前编码的单个字符宽度w，当第一次<code>data</code>事件触发的时候，就会只截取前面k<em>w个字节的长度（k\</em>w &lt; total）多余的（total - k*w）个字符会被保存下来，与下次<code>data</code>事件传过来的字节一直再进行解析。</p>
<p>但是<code>setEncoding</code>的问题在于，其只能支持上述Buffer支持的编码，仍然不能支持GKB等编码。如果遇到这些编码，仍然会出现问题。</p>
<h5 id="数组拼接"><a href="#数组拼接" class="headerlink" title="数组拼接"></a>数组拼接</h5><p>我们可以将接收到的字节存储在数组中，然后通过<code>iconv-lite</code>等工具再来进行转码：</p>
<h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chunks = []</span><br><span class="line"><span class="keyword">let</span> size = <span class="number">0</span></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    chunks.push(chunk)</span><br><span class="line">    size += chunk.length</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.concat(chunks, size)</span><br><span class="line">    <span class="keyword">let</span> str = iconv.decode(buf, <span class="string">'GBK'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>正常的拼接方法是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度，然后调用<code>Buffer.concat</code>方法生成一个合并的Buffer对象。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p>
<h4 id="Buffer与性能"><a href="#Buffer与性能" class="headerlink" title="Buffer与性能"></a>Buffer与性能</h4><p>Buffer在文件I/O和网络I/O时运用广泛，尤其在网络传输中，它的性能举足轻重。在应用中，如果不是特别大的内容，我们都会使用字符串，但一旦在网络中传输，都需要转换为字符串，以二进制数据进行传输。在web应用中，从字符串到Buffer的转换时时刻刻都在发生，所以提高字符串到Buffer的转换效率，可以大幅度提高网络吞吐量。</p>
<p>下面是net模块的<code>makeSyncWrite</code>函数，在实际中，它是最后处理数据的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSyncWrite</span>(<span class="params">fd</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">chunk, enc, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enc !== <span class="string">'buffer'</span>)</span><br><span class="line">      chunk = Buffer.from(chunk, enc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._handle.bytesWritten += chunk.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ctx = &#123;&#125;;</span><br><span class="line">    writeBuffer(fd, chunk, <span class="number">0</span>, chunk.length, <span class="literal">null</span>, <span class="literal">undefined</span>, ctx);</span><br><span class="line">    <span class="keyword">if</span> (ctx.errno !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> ex = errors.uvException(ctx);</span><br><span class="line">      ex.errno = ctx.errno;</span><br><span class="line">      <span class="keyword">return</span> cb(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    cb();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>chunk = Buffer.from(chunk, enc);</code>，如果<code>chunk</code>不是<code>Buffer</code>，则将其转换为<code>Buffer</code>。</p>
<p>所以，Node底层仍然是使用<code>Buffer.from()</code>来进行字符串到<code>Buffer</code>的转换，所以，如果是动态的字符串，我们提前转换与Node自动转换区别不大，<strong>但是如果是静态的字符串，比如各种错误提示，此时将其提前转换为<code>Buffer</code>，在高并发时，将大幅度提高服务器CPU的利用率。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于经常写JavaScript代码的人，很容易混淆<code>String</code>与<code>Buffer</code>，实际上它们有诸多不同：</p>
<ol>
<li><code>String</code>长度不定，而<code>Buffer</code>在定义的时候就规定了长度，之后无法改变（可以使用<code>Buffer.concat()</code>变相的增加长度）。</li>
<li><code>Buffer</code>存储的是二进制数据，字符串与<code>Buffer</code>之间存在编码问题。</li>
<li>在V3版本后，<code>Buffer</code>即为<code>Uint8Array</code>的子类，所以其本质是一个数组。</li>
<li><code>String</code>的内存由V8引擎分配、回收，而<code>Buffer</code>的内存由Node自己负责，不受其内存限制。</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本文参考</p>
<ul>
<li>《深入浅出nodejs》</li>
<li><a href="https://nodejs.org/" target="_blank" rel="noopener">Node</a>官网</li>
<li><a href="https://github.com/nodejs/node" target="_blank" rel="noopener">Node源码</a></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title>Node学习5-进程机制</title>
    <url>/2021/05/03/Node%E5%AD%A6%E4%B9%A05-%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="服务端模型的变迁"><a href="#服务端模型的变迁" class="headerlink" title="服务端模型的变迁"></a><code>服务端模型的变迁</code></h1><p>Web服务器的架构已经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。</p>
<h2 id="石器时代：同步"><a href="#石器时代：同步" class="headerlink" title="石器时代：同步"></a>石器时代：同步</h2><p>最早的服务器，其执行模型是同步的，它的服务模式是一次只为一次请求服务，所有的请求都得按次序等待服务。这意味着除了当前的请求被处理外，其余请求都处于等待被处理的状态。其处理性能相当低下，假设每次响应服务耗时为N秒，则这类服务的QPS为1/N。</p>
<p>这种架构如今已基本被淘汰，只在一些无并发需要的应用中存在。</p>
<h2 id="青铜时代：复制进程"><a href="#青铜时代：复制进程" class="headerlink" title="青铜时代：复制进程"></a>青铜时代：复制进程</h2><p>为了解决同步架构的并发问题，衍生出了复制多个进程以提高并发量的模式。每个进程为一个连接服务。但这种模式的消耗非常高，因为新建进程的代价是很高的，包括内存上下文的分配。因为在复制进程的同时也会复制进程内部的状态，也就是说同样的状态会在内存中存储多份，造成来个浪费。</p>
<p>假设通过进程复制和预复制的方式搭建的服务器有资源的限制，且进程的上限为M，那么这一类服务的QPS为M/N。</p>
<h2 id="白银时代：多线程"><a href="#白银时代：多线程" class="headerlink" title="白银时代：多线程"></a>白银时代：多线程</h2><p>为了解决创建进程代价过大的问题，多线程的概念被引入，线程相当于一个简化版的进程，其没有自己的系统资源，所以在创建，废除时，其代价都比进程小的多。但是值得注意的是，不同进程的线程切换会造成上下文的切换，当过多的不同进程的线程进行切换时，消耗仍然很大。虽然其有缺点，但线程仍然是当代操作系统的重要组成部分。</p>
<p>如果忽略多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为N*L/N。</p>
<h2 id="黄金时代：事件驱动"><a href="#黄金时代：事件驱动" class="headerlink" title="黄金时代：事件驱动"></a>黄金时代：事件驱动</h2><p>多线程的服务模型服役了很长一段时间，Apache就是采用多线程/多进程模式来实现的，当并发量增长到上万时，内存耗用的问题就会暴露出来，即为著名的C10k问题。</p>
<p>为了解决高并发的问题，基于事件驱动的服务模型出现了，像Node和Nginx均是基于事件驱动的方式实现的：即一个线程为所有请求服务，请求到来时触发事件，这与每个请求由一个线程服务的模式完全不同。采用单线程避免了不必要的内存开销和上下文切换问题。</p>
<p>但是这种基于单线程的模式虽然解决了上面的问题，但是其无法高效的利用多核CPU的问题，则为这个模式的问题之所在。所以当我们解决掉这个问题时，那么性能的提升是相当可观的。</p>
<h2 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h2><p>面对单线程对多核利用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程的各自利用一个CPU，以此实现多核CPU的利用。基于Node提供的<code>child_process</code>模块可以实现多进程的调用。我们创建一个简单的服务端代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">5000</span> + <span class="built_in">Math</span>.round(<span class="number">1</span> + <span class="built_in">Math</span>.random() * <span class="number">1000</span>)</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">    res.end(<span class="string">"Hello World\n"</span>)</span><br><span class="line">&#125;).listen(port, <span class="string">'127.0.0.1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server on 127.0.0.1:'</span>+port)</span><br></pre></td></tr></table></figure>
<p>通过<code>node work.js</code>启动它，它会监听听5000到6000之间的一个随机端口。将下面的代码保存为<code>master.js</code>，并通过<code>node master.js</code>启动它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork</span><br><span class="line"><span class="keyword">let</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span>  i = <span class="number">0</span>; i &lt; cpus.length; i++)&#123;</span><br><span class="line">    fork(<span class="string">'./work.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会根据当前机器上的CPU的数量复制出当前Node进程数。</p>
<p>会得到如下的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server on 127.0.0.1:5123</span><br><span class="line">server on 127.0.0.1:5481</span><br><span class="line">server on 127.0.0.1:5065</span><br><span class="line">server on 127.0.0.1:5516</span><br></pre></td></tr></table></figure>
<p>如下图即为典型的Master-Work模式，又称为主从模式，其广泛用于并行处理业务的模式，具备较好的可伸缩性和稳定性。图中的进程分为两类：主进程和工作进程。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它趋向于稳定。工作进程负责具体的业务处理。</p>
<p>注意通过<code>fork()</code>复制的进程都是一个独立的进程，每个进程都是一个独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10MB的内存。</p>
<h1 id="child-process模块"><a href="#child-process模块" class="headerlink" title="child_process模块"></a><code>child_process</code>模块</h1><h2 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h2><h3 id="异步创建子进程"><a href="#异步创建子进程" class="headerlink" title="异步创建子进程"></a>异步创建子进程</h3><h4 id="child-process-exec-command-options-callback"><a href="#child-process-exec-command-options-callback" class="headerlink" title="child_process.exec(command[, options][, callback])"></a><code>child_process.exec(command[, options][, callback])</code></h4><p>该方法可以直接异步执行<strong>命令</strong>（不是JavaScript代码，而是shell命令），<code>options</code>参数可以控制各种条件，比如工作目录，编码等；第三个参数用于设置失败的回调。</p>
<p>该命令衍生shell，然后在shell中执行<code>command</code>，并缓冲任何产生的输出。传给<code>command</code>字符串会被shell直接处理，特殊字符串（因shell而异）需要被相应地处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exec(<span class="string">'"/目录/空 格/文件.sh" 参数1 参数2'</span>);</span><br><span class="line"><span class="comment">// 使用双引号，使路径中的空格不会被解释为多个参数的分隔符。</span></span><br><span class="line"></span><br><span class="line">exec(<span class="string">'echo "\\$HOME 变量为 $HOME"'</span>);</span><br><span class="line"><span class="comment">// $HOME 变量在第一个实例中会被转义，但是第二个则不会。</span></span><br></pre></td></tr></table></figure>
<p>所以对于用户的输入，一定要经过无害化处理才能使用这个函数，因为其可以触发任何命令，很危险!</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> process = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cmd = <span class="string">'console.log(123456)'</span></span><br><span class="line"></span><br><span class="line">process.exec(<span class="string">'echo 132'</span>,&#123;<span class="attr">encoding</span>: <span class="string">'GBK'</span>&#125;, (error, stdout, stderr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`执行的错误: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`stdout: <span class="subst">$&#123;stdout&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`stderr: <span class="subst">$&#123;stderr&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>值得注意的是：标准输出是在回调的<code>stdout</code>参数中，而不会直接打印在当前控制台中。</p>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><p>我们简单看一下其源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">command, options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> opts = normalizeExecArgs(command, options, callback);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports.execFile(opts.file,</span><br><span class="line">                                 opts.options,</span><br><span class="line">                                 opts.callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其首先是调用了<code>normalizeExecArgs()</code>这个函数，我们再看一下内部：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeExecArgs</span>(<span class="params">command, options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &#123;</span><br><span class="line">    callback = options;</span><br><span class="line">    options = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a shallow copy so we don't clobber the user's options object.</span></span><br><span class="line">  options = &#123; ...options &#125;;</span><br><span class="line">  options.shell = <span class="keyword">typeof</span> options.shell === <span class="string">'string'</span> ? options.shell : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    file: command,</span><br><span class="line">    options: options,</span><br><span class="line">    callback: callback</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部首先是做了一个判断，即忽略<code>options</code>功能的实现。</p>
<p>然后是对<code>options</code>做了浅拷贝防止修改用户的<code>options</code>对象。因为后面需要对<code>options.shell</code>进行处理，即是否使用默认的<code>shell.exe</code>。详见下面：</p>
<blockquote>
<h2 id="shell-的要求"><a href="#shell-的要求" class="headerlink" title="shell 的要求"></a>shell 的要求</h2><p>Shell 需要能理解 <code>-c</code> 开关。 如果 shell 是 <code>&#39;cmd.exe&#39;</code>，则它需要能理解 <code>/d /s /c</code> 开关，且命令行解析需要能兼容。</p>
<h2 id="默认的-Windows-shell"><a href="#默认的-Windows-shell" class="headerlink" title="默认的 Windows shell"></a>默认的 Windows shell</h2><p>尽管微软指定在根环境中 <code>%COMSPEC%</code> 必须包含 <code>&#39;cmd.exe&#39;</code> 的路径，但子进程并不总是遵循相同的要求。 因此，在可以衍生 shell 的 <code>child_process</code> 函数中，如果 <code>process.env.ComSpec</code> 不可以，则使用 <code>&#39;cmd.exe&#39;</code> 作为后备。</p>
</blockquote>
<p>然后直接返回了一个对象，并且将<code>command</code>重命名为<code>file</code>（这里我没有看到哪里将<code>command</code>转换为<code>file</code>，但是<code>exeFile</code>确实只接受File，疑惑）</p>
<p>跳出这个函数，看<code>exe()</code>函数，可以发现其仍然是调用了<code>exeFile()</code>函数，我们下面再来看这个函数的源码。</p>
<h4 id="child-process-execFile-file-args-options-callback"><a href="#child-process-execFile-file-args-options-callback" class="headerlink" title="child_process.execFile(file[, args][, options][, callback])"></a><code>child_process.execFile(file[, args][, options][, callback])</code></h4><p>该函数与<code>child_process.exe()</code>相似，都是执行命令。但仍然有些许不同。</p>
<ul>
<li>该方法第一个参数接受一个命令文件（名字或路径），而不是命令的字符串。</li>
<li><code>child_process.execFile()</code> 函数类似于 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback" target="_blank" rel="noopener"><code>child_process.exec()</code></a>，但默认情况下不会衍生 shell。 指定的可执行文件 <code>file</code> 会被直接衍生作为新的进程，使其比 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback" target="_blank" rel="noopener"><code>child_process.exec()</code></a> 稍微更高效。</li>
<li>由于没有衍生 shell，因此不支持 I/O 重定向和文件通配等行为。</li>
</ul>
<h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execFile</span>(<span class="params">file <span class="regexp">/* , args, options, callback */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = [];</span><br><span class="line">  <span class="keyword">let</span> callback;</span><br><span class="line">  <span class="keyword">let</span> options;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the optional positional parameters.解析参数</span></span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; ArrayIsArray(<span class="built_in">arguments</span>[pos])) &#123;</span><br><span class="line">    args = <span class="built_in">arguments</span>[pos++];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="built_in">arguments</span>[pos] == <span class="literal">null</span>) &#123;</span><br><span class="line">    pos++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[pos] === <span class="string">'object'</span>) &#123;</span><br><span class="line">    options = <span class="built_in">arguments</span>[pos++];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="built_in">arguments</span>[pos] == <span class="literal">null</span>) &#123;</span><br><span class="line">    pos++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[pos] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    callback = <span class="built_in">arguments</span>[pos++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!callback &amp;&amp; pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="built_in">arguments</span>[pos] != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_ARG_VALUE(<span class="string">'args'</span>, <span class="built_in">arguments</span>[pos]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  options = &#123;</span><br><span class="line">    encoding: <span class="string">'utf8'</span>,</span><br><span class="line">    timeout: <span class="number">0</span>,</span><br><span class="line">    maxBuffer: MAX_BUFFER,</span><br><span class="line">    killSignal: <span class="string">'SIGTERM'</span>,</span><br><span class="line">    cwd: <span class="literal">null</span>,</span><br><span class="line">    env: <span class="literal">null</span>,</span><br><span class="line">    shell: <span class="literal">false</span>,</span><br><span class="line">    ...options</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate the timeout, if present.验证参数</span></span><br><span class="line">  validateTimeout(options.timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate maxBuffer, if present.</span></span><br><span class="line">  validateMaxBuffer(options.maxBuffer);</span><br><span class="line"></span><br><span class="line">  options.killSignal = sanitizeKillSignal(options.killSignal);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关键-产生子进程</span></span><br><span class="line">  <span class="keyword">const</span> child = spawn(file, args, &#123;</span><br><span class="line">    cwd: options.cwd,</span><br><span class="line">    env: options.env,</span><br><span class="line">    gid: options.gid,</span><br><span class="line">    shell: options.shell,</span><br><span class="line">    signal: options.signal,</span><br><span class="line">    uid: options.uid,</span><br><span class="line">    windowsHide: !!options.windowsHide,</span><br><span class="line">    windowsVerbatimArguments: !!options.windowsVerbatimArguments</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> encoding;</span><br><span class="line">  <span class="keyword">const</span> _stdout = [];</span><br><span class="line">  <span class="keyword">const</span> _stderr = [];</span><br><span class="line">  <span class="keyword">if</span> (options.encoding !== <span class="string">'buffer'</span> &amp;&amp; Buffer.isEncoding(options.encoding)) &#123;</span><br><span class="line">    encoding = options.encoding;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    encoding = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> stdoutLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> stderrLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> killed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> exited = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ex = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cmd = file;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">exithandler</span>(<span class="params">code, signal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exited) <span class="keyword">return</span>;</span><br><span class="line">    exited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">      clearTimeout(timeoutId);</span><br><span class="line">      timeoutId = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!callback) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge chunks</span></span><br><span class="line">    <span class="keyword">let</span> stdout;</span><br><span class="line">    <span class="keyword">let</span> stderr;</span><br><span class="line">    <span class="keyword">if</span> (encoding ||</span><br><span class="line">      (</span><br><span class="line">        child.stdout &amp;&amp;</span><br><span class="line">        child.stdout.readableEncoding</span><br><span class="line">      )) &#123;</span><br><span class="line">      stdout = ArrayPrototypeJoin(_stdout, <span class="string">''</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stdout = Buffer.concat(_stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (encoding ||</span><br><span class="line">      (</span><br><span class="line">        child.stderr &amp;&amp;</span><br><span class="line">        child.stderr.readableEncoding</span><br><span class="line">      )) &#123;</span><br><span class="line">      stderr = ArrayPrototypeJoin(_stderr, <span class="string">''</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stderr = Buffer.concat(_stderr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ex &amp;&amp; code === <span class="number">0</span> &amp;&amp; signal === <span class="literal">null</span>) &#123;</span><br><span class="line">      callback(<span class="literal">null</span>, stdout, stderr);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length !== <span class="number">0</span>)</span><br><span class="line">      cmd += <span class="string">` <span class="subst">$&#123;ArrayPrototypeJoin(args, <span class="string">' '</span>)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ex) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-restricted-syntax</span></span><br><span class="line">      ex = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Command failed: '</span> + cmd + <span class="string">'\n'</span> + stderr);</span><br><span class="line">      ex.killed = child.killed || killed;</span><br><span class="line">      ex.code = code &lt; <span class="number">0</span> ? getSystemErrorName(code) : code;</span><br><span class="line">      ex.signal = signal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ex.cmd = cmd;</span><br><span class="line">    callback(ex, stdout, stderr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">errorhandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    ex = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child.stdout)</span><br><span class="line">      child.stdout.destroy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child.stderr)</span><br><span class="line">      child.stderr.destroy();</span><br><span class="line"></span><br><span class="line">    exithandler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child.stdout)</span><br><span class="line">      child.stdout.destroy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child.stderr)</span><br><span class="line">      child.stderr.destroy();</span><br><span class="line"></span><br><span class="line">    killed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      child.kill(options.killSignal);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      ex = e;</span><br><span class="line">      exithandler();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    timeoutId = setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">delayedKill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      kill();</span><br><span class="line">      timeoutId = <span class="literal">null</span>;</span><br><span class="line">    &#125;, options.timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child.stdout) &#123;</span><br><span class="line">    <span class="keyword">if</span> (encoding)</span><br><span class="line">      child.stdout.setEncoding(encoding);</span><br><span class="line"></span><br><span class="line">    child.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onChildStdout</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> encoding = child.stdout.readableEncoding;</span><br><span class="line">      <span class="keyword">const</span> length = encoding ?</span><br><span class="line">        Buffer.byteLength(chunk, encoding) :</span><br><span class="line">        chunk.length;</span><br><span class="line">      <span class="keyword">const</span> slice = encoding ? StringPrototypeSlice :</span><br><span class="line">        (buf, ...args) =&gt; buf.slice(...args);</span><br><span class="line">      stdoutLen += length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stdoutLen &gt; options.maxBuffer) &#123;</span><br><span class="line">        <span class="keyword">const</span> truncatedLen = options.maxBuffer - (stdoutLen - length);</span><br><span class="line">        ArrayPrototypePush(_stdout, slice(chunk, <span class="number">0</span>, truncatedLen));</span><br><span class="line"></span><br><span class="line">        ex = <span class="keyword">new</span> ERR_CHILD_PROCESS_STDIO_MAXBUFFER(<span class="string">'stdout'</span>);</span><br><span class="line">        kill();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ArrayPrototypePush(_stdout, chunk);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child.stderr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (encoding)</span><br><span class="line">      child.stderr.setEncoding(encoding);</span><br><span class="line"></span><br><span class="line">    child.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onChildStderr</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> encoding = child.stderr.readableEncoding;</span><br><span class="line">      <span class="keyword">const</span> length = encoding ?</span><br><span class="line">        Buffer.byteLength(chunk, encoding) :</span><br><span class="line">        chunk.length;</span><br><span class="line">      stderrLen += length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stderrLen &gt; options.maxBuffer) &#123;</span><br><span class="line">        <span class="keyword">const</span> truncatedLen = options.maxBuffer - (stderrLen - length);</span><br><span class="line">        ArrayPrototypePush(_stderr,</span><br><span class="line">                           chunk.slice(<span class="number">0</span>, truncatedLen));</span><br><span class="line"></span><br><span class="line">        ex = <span class="keyword">new</span> ERR_CHILD_PROCESS_STDIO_MAXBUFFER(<span class="string">'stderr'</span>);</span><br><span class="line">        kill();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _stderr.push(chunk);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  child.addListener(<span class="string">'close'</span>, exithandler);</span><br><span class="line">  child.addListener(<span class="string">'error'</span>, errorhandler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数相对还是比较长，有217行。但是结构相当清晰：</p>
<ul>
<li>L 2-4：定义参数变量</li>
<li>L 7-26：解析参数（由于定义了可选参数，所以需要这样解析）</li>
<li>L 28-46：定义<code>options</code>并验证参数合法性</li>
<li>L 48-57（关键）：调用<code>spawn()</code>函数产生子进程</li>
<li>Rest：剩下的代码都是为child添加<code>close</code>和<code>error</code>事件和其准备工作</li>
<li>Last：返回child。</li>
</ul>
<h4 id="在-Windows-上衍生-bat-和-cmd-文件"><a href="#在-Windows-上衍生-bat-和-cmd-文件" class="headerlink" title="在 Windows 上衍生 .bat 和 .cmd 文件"></a>在 Windows 上衍生 <code>.bat</code> 和 <code>.cmd</code> 文件</h4><p><code>child_process.exec()</code> 和 <code>child_process.execFile()</code>之间区别的重要性可能因平台而异。 在 Unix 类型的操作系统（Unix、Linux、macOS）上，<code>child_process.execFile()</code>可以更高效，因为默认情况下不会衍生 shell。 但是在 Windows 上， <code>.bat</code> 和 <code>.cmd</code> 文件在没有终端的情况下不能自行执行，因此无法使用 <code>child_process.execFile()</code>启动。 当在 Windows 上运行时，要调用 <code>.bat</code> 和 <code>.cmd</code> 文件，可以使用设置了 <code>shell</code> 选项的 <code>child_process.spawn()</code>、或 <code>child_process.exec()</code>、或衍生 <code>cmd.exe</code> 并将 <code>.bat</code> 或 <code>.cmd</code> 文件作为参数传入（也就是 <code>shell</code> 选项和 <code>child_process.exec()</code>所做的）。 在任何情况下，如果脚本的文件名包含空格，则需要加上引号。</p>
<h4 id="child-process-spawn-command-args-options"><a href="#child-process-spawn-command-args-options" class="headerlink" title="child_process.spawn(command[, args][, options])"></a><code>child_process.spawn(command[, args][, options])</code></h4><p>可以看到，最后创建进程的工作，都是由这个方法实现的，但是其与<code>exec()</code>有较大的不同，否则也不会设计两个API，一直存在这么久。</p>
<h5 id="spawn-与exec-的不同："><a href="#spawn-与exec-的不同：" class="headerlink" title="spawn()与exec()的不同："></a><code>spawn()</code>与<code>exec()</code>的不同：</h5><ul>
<li><code>exec()</code>的<code>command</code>是包含参数的，而<code>spawn</code>命令的参数是作为函数的第二个参数传入的。</li>
<li><code>exec()</code>是将处理函数作为回调传入内部，而<code>spawn</code>实现了<code>emitter</code>，可以直接在外部监听事件。还可以准确地监听<code>close</code>等事件，<code>exec()</code>则只能统一监听<code>error</code>事件。</li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> ls = spawn(<span class="string">'ls'</span>, [<span class="string">'-lh'</span>, <span class="string">'/usr'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要显式的监听</span></span><br><span class="line">ls.stdout.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.stderr.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.on(<span class="string">'close'</span>, (code) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`子进程退出，退出码 <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">file, args, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//解析参数</span></span><br><span class="line">  options = normalizeSpawnArguments(file, args, options);</span><br><span class="line">  <span class="comment">//验证timeout</span></span><br><span class="line">  validateTimeout(options.timeout);</span><br><span class="line">    <span class="comment">//验证signal</span></span><br><span class="line">  validateAbortSignal(options.signal, <span class="string">'options.signal'</span>);</span><br><span class="line">    <span class="comment">//验证并转换killSignal信号，这里嵌套太深而且不重要，就不再深究</span></span><br><span class="line">  <span class="keyword">const</span> killSignal = sanitizeKillSignal(options.killSignal);</span><br><span class="line">    <span class="comment">//新建子进程，重要</span></span><br><span class="line">  <span class="keyword">const</span> child = <span class="keyword">new</span> ChildProcess();</span><br><span class="line">    <span class="comment">//这里实际是记录log，而不是debug</span></span><br><span class="line">  debug(<span class="string">'spawn'</span>, options);</span><br><span class="line">    <span class="comment">//初始化子进程参数</span></span><br><span class="line">  child.spawn(options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子进程超时的操作</span></span><br><span class="line">  <span class="keyword">if</span> (options.timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          child.kill(killSignal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          child.emit(<span class="string">'error'</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        timeoutId = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, options.timeout);</span><br><span class="line"></span><br><span class="line">    child.once(<span class="string">'exit'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">        clearTimeout(timeoutId);</span><br><span class="line">        timeoutId = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否有killSignal参数，即终止进程的信号值，有的话添加abort事件</span></span><br><span class="line">  <span class="keyword">if</span> (options.signal) &#123;</span><br><span class="line">    <span class="keyword">const</span> signal = options.signal;</span><br><span class="line">    <span class="keyword">if</span> (signal.aborted) &#123;</span><br><span class="line">      process.nextTick(onAbortListener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      signal.addEventListener(<span class="string">'abort'</span>, onAbortListener, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      child.once(<span class="string">'exit'</span>,</span><br><span class="line">                 () =&gt; signal.removeEventListener(<span class="string">'abort'</span>, onAbortListener));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onAbortListener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      abortChildProcess(child, killSignal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//返回子进程</span></span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数中最重要的就是<code>const child = new ChildProcess();</code>这一部分，我们再看一下这个类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildProcess</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  FunctionPrototypeCall(EventEmitter, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._closesNeeded = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>._closesGot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.connected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.signalCode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.exitCode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.killed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.spawnfile = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重要，新建进程</span></span><br><span class="line">  <span class="keyword">this</span>._handle = <span class="keyword">new</span> Process();</span><br><span class="line">  <span class="keyword">this</span>._handle[owner_symbol] = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._handle.onexit = <span class="function">(<span class="params">exitCode, signalCode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signalCode) &#123;</span><br><span class="line">      <span class="keyword">this</span>.signalCode = signalCode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.exitCode = exitCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.stdin) &#123;</span><br><span class="line">      <span class="keyword">this</span>.stdin.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._handle.close();</span><br><span class="line">    <span class="keyword">this</span>._handle = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exitCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> syscall = <span class="keyword">this</span>.spawnfile ? <span class="string">'spawn '</span> + <span class="keyword">this</span>.spawnfile : <span class="string">'spawn'</span>;</span><br><span class="line">      <span class="keyword">const</span> err = errnoException(exitCode, syscall);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.spawnfile)</span><br><span class="line">        err.path = <span class="keyword">this</span>.spawnfile;</span><br><span class="line"></span><br><span class="line">      err.spawnargs = ArrayPrototypeSlice(<span class="keyword">this</span>.spawnargs, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'exit'</span>, <span class="keyword">this</span>.exitCode, <span class="keyword">this</span>.signalCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If any of the stdio streams have not been touched,</span></span><br><span class="line">    <span class="comment">// then pull all the data through so that it can get the</span></span><br><span class="line">    <span class="comment">// eof and emit a 'close' event.</span></span><br><span class="line">    <span class="comment">// Do it on nextTick so that the user has one last chance</span></span><br><span class="line">    <span class="comment">// to consume the output, if for example they only want to</span></span><br><span class="line">    <span class="comment">// start reading the data once the process exits.</span></span><br><span class="line">    process.nextTick(flushStdio, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    maybeClose(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ObjectSetPrototypeOf(ChildProcess.prototype, EventEmitter.prototype);</span><br><span class="line">ObjectSetPrototypeOf(ChildProcess, EventEmitter);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ChildProcess.prototype.spawn = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ChildProcess.prototype.kill = <span class="function"><span class="keyword">function</span>(<span class="params">sig</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ChildProcess.prototype.ref = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._handle) <span class="keyword">this</span>._handle.ref();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ChildProcess.prototype.unref = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._handle) <span class="keyword">this</span>._handle.unref();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>可以看到这实际上就是一个原生的JS类，其在构造函数中定义了很多内部变量，其中最重要的是<code>this._handle = new Process();</code>来真实的新建一个进程。而这个类则是从C++底层导出的，所以我们不再向下深入。</p>
<p>在定义完类之后，Node立即为其添加了<code>event</code>模块，用于用户对其进行操作。</p>
<p>其中<code>spawn()</code>也很重要，注意每层的对象都有<code>spawn()</code>函数，其用来得到最后的输出结果。</p>
<h4 id="child-process-fork-modulePath-args-options"><a href="#child-process-fork-modulePath-args-options" class="headerlink" title="child_process.fork(modulePath[, args][, options])"></a><code>child_process.fork(modulePath[, args][, options])</code></h4><p><code>child_process.fork()</code> 方法是 <code>child_process.spawn()</code>的特例，专门用于衍生新的 Node.js 进程。 与 <code>child_process.spawn()</code> 一样返回 <code>ChildProcess对象</code>。 返回的 <code>ChildProcess</code>会内置额外的通信通道，允许消息在父进程和子进程之间来回传递。 详见 <code>subprocess.send()</code>。</p>
<p>记住，衍生的 Node.js 子进程独立于父进程，但两者之间建立的 IPC 通信通道除外。 每个进程都有自己的内存，带有自己的 V8 实例。 由于需要额外的资源分配，因此不建议衍生大量的 Node.js 子进程。</p>
<p>默认情况下， <code>child_process.fork()</code> 会使用父进程的 <code>process.execPath</code>来衍生新的 Node.js 实例。</p>
<p>该方法应该比较常用的，因为我们在做web的负载均衡或者多核CPU利用时，一般其他的server也是Node，所以通过该API可以直接生成新的进程。</p>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前面的主从的例子</span></span><br><span class="line"><span class="keyword">let</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork</span><br><span class="line"><span class="keyword">let</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span>  i = <span class="number">0</span>; i &lt; cpus.length; i++)&#123;</span><br><span class="line">    fork(<span class="string">'./work.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步创建子进程"><a href="#同步创建子进程" class="headerlink" title="同步创建子进程"></a>同步创建子进程</h3><p>下面的函数会同步创建，执行进程，并且将会阻塞 Node.js 事件循环、暂停任何其他代码的执行，直到衍生的进程退出。阻塞这些调用对于简化通用的脚本任务和简化应用程序配置在启动时的加载或处理都非常有用。</p>
<h4 id="child-process-execFileSync-file-args-options"><a href="#child-process-execFileSync-file-args-options" class="headerlink" title="child_process.execFileSync(file[, args][, options])"></a><code>child_process.execFileSync(file[, args][, options])</code></h4><p><code>child_process.execFileSync()</code> 方法通常与 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback" target="_blank" rel="noopener"><code>child_process.execFile()</code></a> 相同，但该方法在子进程完全关闭之前不会返回。 当遇到超时并且已发送 <code>killSignal</code> 时，该方法也需等到进程完全退出后才返回。</p>
<p>如果子进程拦截并处理了 <code>SIGTERM</code> 信号但未退出，则父进程仍将等待子进程退出。</p>
<p>这个函数也是和<code>execFile()</code>的调用栈差不多。</p>
<p><code>exeFilr()</code>-&gt;<code>spawnSync</code>（lib）-&gt;<code>spawnSync()</code>(internal)-&gt;<code>spawn_sync.spawn(options)</code>(C++内建模块)</p>
<h4 id="child-process-execSync-command-options"><a href="#child-process-execSync-command-options" class="headerlink" title="child_process.execSync(command[, options])"></a><code>child_process.execSync(command[, options])</code></h4><p><code>child_process.execSync()</code> 方法通常与 <code>child_process.exec()</code> 相同，但该方法在子进程完全关闭之前不会返回。 当遇到超时并且已发送 <code>killSignal</code> 时，该方法也需等到进程完全退出后才返回。 如果子进程拦截并处理了 <code>SIGTERM</code> 信号但未退出，则父进程会等待直到子进程退出。</p>
<h5 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execSync</span>(<span class="params">command, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> opts = normalizeExecArgs(command, options, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> inheritStderr = !opts.options.stdio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ret = spawnSync(opts.file, opts.options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inheritStderr &amp;&amp; ret.stderr)</span><br><span class="line">    process.stderr.write(ret.stderr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> err = checkExecSyncError(ret, opts.args, command);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret.stdout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个函数就没有调用<code>exeFileSync()</code>，而是直接调用的<code>spawnSync()</code>函数。下面我们再看<code>spawnSync()</code></p>
<h4 id="child-process-spawnSync-command-args-options"><a href="#child-process-spawnSync-command-args-options" class="headerlink" title="child_process.spawnSync(command[, args][, options])"></a><code>child_process.spawnSync(command[, args][, options])</code></h4><p><code>child_process.spawnSync()</code> 方法通常与 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options" target="_blank" rel="noopener"><code>child_process.spawn()</code></a> 相同，但在子进程完全关闭之前该函数不会返回。 当遇到超时并且已发送 <code>killSignal</code> 时，该方法也需等到进程完全退出后才返回。 如果进程拦截并处理了 <code>SIGTERM</code> 信号但未退出，则父进程会等待直到子进程退出。</p>
<h5 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawnSync</span>(<span class="params">file, args, options</span>) </span>&#123;</span><br><span class="line">  options = &#123;</span><br><span class="line">    maxBuffer: MAX_BUFFER,</span><br><span class="line">    ...normalizeSpawnArguments(file, args, options)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  debug(<span class="string">'spawnSync'</span>, options);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate the timeout, if present.</span></span><br><span class="line">  validateTimeout(options.timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate maxBuffer, if present.</span></span><br><span class="line">  validateMaxBuffer(options.maxBuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate and translate the kill signal, if present.</span></span><br><span class="line">  options.killSignal = sanitizeKillSignal(options.killSignal);</span><br><span class="line"></span><br><span class="line">  options.stdio = getValidStdio(options.stdio || <span class="string">'pipe'</span>, <span class="literal">true</span>).stdio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.input) &#123;</span><br><span class="line">    <span class="keyword">const</span> stdin = options.stdio[<span class="number">0</span>] = &#123; ...options.stdio[<span class="number">0</span>] &#125;;</span><br><span class="line">    stdin.input = options.input;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We may want to pass data in on any given fd, ensure it is a valid buffer</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; options.stdio.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> input = options.stdio[i] &amp;&amp; options.stdio[i].input;</span><br><span class="line">    <span class="keyword">if</span> (input != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> pipe = options.stdio[i] = &#123; ...options.stdio[i] &#125;;</span><br><span class="line">      <span class="keyword">if</span> (isArrayBufferView(input)) &#123;</span><br><span class="line">        pipe.input = input;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">'string'</span>) &#123;</span><br><span class="line">        pipe.input = Buffer.from(input, options.encoding);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_ARG_TYPE(<span class="string">`options.stdio[<span class="subst">$&#123;i&#125;</span>]`</span>,</span><br><span class="line">                                       [<span class="string">'Buffer'</span>,</span><br><span class="line">                                        <span class="string">'TypedArray'</span>,</span><br><span class="line">                                        <span class="string">'DataView'</span>,</span><br><span class="line">                                        <span class="string">'string'</span>],</span><br><span class="line">                                       input);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要，调用internal的spawnSync的函数</span></span><br><span class="line">  <span class="keyword">return</span> child_process.spawnSync(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面都是对参数进行验证和处理。最后只是调用了<code>child_process.spawnSync(options)</code>函数，我们再看一下这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawnSync</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = spawn_sync.spawn(options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result.output &amp;&amp; options.encoding &amp;&amp; options.encoding !== <span class="string">'buffer'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; result.output.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!result.output[i])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      result.output[i] = result.output[i].toString(options.encoding);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result.stdout = result.output &amp;&amp; result.output[<span class="number">1</span>];</span><br><span class="line">  result.stderr = result.output &amp;&amp; result.output[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result.error) &#123;</span><br><span class="line">    result.error = errnoException(result.error, <span class="string">'spawnSync '</span> + options.file);</span><br><span class="line">    result.error.path = options.file;</span><br><span class="line">    result.error.spawnargs = ArrayPrototypeSlice(options.args, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最重要的就是第一条语句，即调用了<code>spawn_sync.spawn(options)</code>函数，这个函数也是从C++导入的内部模块。</p>
<p>所以对于Process模块，JavaScript层面只做了参数的验证，处理，以及返回数据。（因为JavaScript的能力就止于此了），其内部具体的逻辑，都是在C++平台来处理的。而这一部分，是由libuv进行处理的，因为涉及到跨平台处理不同。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>名称</th>
<th>执行类型</th>
<th>同步/异步</th>
<th>事件处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>exec</td>
<td>命令</td>
<td>异步</td>
<td>callback回调/event监听</td>
</tr>
<tr>
<td>execFile</td>
<td>命令（文件）</td>
<td>异步</td>
<td>callback回调/event监听</td>
</tr>
<tr>
<td>Fork</td>
<td>JavaScript模块</td>
<td>异步</td>
<td>event监听</td>
</tr>
<tr>
<td>execSync</td>
<td>命令</td>
<td>同步</td>
<td>/</td>
</tr>
<tr>
<td>execFileSync</td>
<td>命令（文件）</td>
<td>同步</td>
<td>/</td>
</tr>
</tbody>
</table>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>在Master-Work中模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。对于<code>child_process</code>模块，创建好了子进程，然后与父子进程间通信是十分容易的。</p>
<p>由于Node中的进程模块实现了<code>EventEmitter</code>，所以可以直接使用事件监听的方式来进行通信。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>对应的子进程有5个事件，其中包括通信的<code>message</code>事件。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时间</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td>close</td>
<td>进程关闭</td>
<td>1.  <code>code</code> 子进程自行退出时的退出码。<br />2. <code>signal</code>子进程被终止的信号。</td>
</tr>
<tr>
<td>disconnect</td>
<td>调用父进程中的 <code>subprocess.disconnect()</code>或子进程中的 <code>process.disconnect()</code> 后会触发 <code>&#39;disconnect&#39;</code> 事件。</td>
<td>/</td>
</tr>
<tr>
<td>error</td>
<td>1. 无法衍生进程；<br /> 2. 无法杀死进程；<br /> 3. 向子进程发送消息失败。</td>
<td><code>err</code> 错误</td>
</tr>
<tr>
<td>exit</td>
<td>当子进程结束后时会触发 <code>&#39;exit&#39;</code> 事件。</td>
<td>1.   <code>code</code>子进程自行退出时的退出码。<br /> 2. <code>signal</code> 子进程被终止的信号。</td>
</tr>
<tr>
<td>message</td>
<td>当子进程使用 <code>process.send()</code>发送消息时会触发 <code>&#39;message&#39;</code> 事件。</td>
<td>1.  <code>message</code>  一个已解析的 JSON 对象或原始值。<br /> 2. <code>sendHandle</code>一个 <code>net.Socket</code>或 <a href="http://nodejs.cn/api/net.html#net_class_net_server" target="_blank" rel="noopener"><code>net.Server</code></a> 对象，或 <code>undefined</code>。</td>
</tr>
</tbody>
</table>
<p>通过<code>Process.end()</code>方法，可以向子进程发送消息，而主进程可以通过<code>message</code>事件监听子进程的消息。</p>
<p>而子进程可以通过内置对象<code>process</code>的<code>send()</code>方法，和同样的事件监听来与父进程通信。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//master.js</span></span><br><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"><span class="keyword">const</span> n = cp.fork(__dirname + <span class="string">'/sub.js'</span>)</span><br><span class="line"></span><br><span class="line">n.on(<span class="string">'message'</span>, (m) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`进程消息：<span class="subst">$&#123;m&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    work.send(<span class="string">'父进程发送消息来了'</span>)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//work.js</span></span><br><span class="line">process.on(<span class="string">'message'</span>, (m) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`进程消息：<span class="subst">$&#123;m&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    process.send(<span class="string">'子进程发送消息来了'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过<code>message</code>和<code>send()</code>传递消息。</p>
<p>IPC的全程是Inter-Process-Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间的通信技术有很多，如管道通信、共享存储、消息传递、socket等。Node中实现IPC通信的是管道（pipe）技术。但这个管道与传统的管道有一些不同，在Node中管道是一个抽象层的称呼，具体实现细节由libuv提供，在Windows下由命名管道（named pipe）实现，*nix下则采用Unix Domain Socket。表现在应用层上的进程通信只有简单的<code>message</code>事件和<code>send()</code>方法，接口十分简洁。</p>
<p><img src="\images\Node-JS的进程\IPC.png" alt="IPC"></p>
<h3 id="句柄传递"><a href="#句柄传递" class="headerlink" title="句柄传递"></a>句柄传递</h3><p>一般来说，NodeJS用于后端服务器的开发，所以多进程一般用于调动多核CPU来提高并发，那么不同的进程能否监听同一个端口来实现提高并发的目的呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//work.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/pain'</span>&#125;)</span><br><span class="line">    res.end(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;).listen(<span class="number">8888</span>, <span class="string">'127.0.0.1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = requrie(<span class="string">'child_process'</span>).fork</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="string">'./work.js'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">得到的错误如下：</span><br><span class="line"></span><br><span class="line">​<span class="string">``</span><span class="string">`bash</span></span><br><span class="line"><span class="string">events.js:187</span></span><br><span class="line"><span class="string">      throw er; // Unhandled 'error' event</span></span><br><span class="line"><span class="string">      ^</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Error: listen EADDRINUSE: address already in use 127.0.0.1:8888</span></span><br></pre></td></tr></table></figure>
<p>很明显，不同的进程启动同一个端口的server，肯定会引起端口占用的问题。</p>
<p>最开始为了解决这个问题，我们的想法是代理。即主进程对外接受所有的网络请求，再将这些请求分别代理到不同端口的进程上。</p>
<p>通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。但是由于进程每接受到一个连接，将会用掉一个文件描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程地过程就会用掉两个文件描述符。操作系统的文件描述符是有限的，代理方案浪费掉一倍的文件描述符地做法影响了系统地扩展能力。</p>
<p>为了解决上述问题，Node在V0.5.9加入了进程间发送句柄的功能。<code>sned()</code>方法除了能通过IPC发送数据外，还能够发送句柄，第二个可选参数即为句柄。</p>
<p>句柄即一种用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以来把标识一个socket对象，一个UDP套接字，一个管道等。因此，我们可以通过发送句柄来达到更高的多核利用效率。下面是一个例子（传递一个HTTP句柄）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//master.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = os.cpus().length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> worker = fork(<span class="string">'./work.js'</span>);</span><br><span class="line">  workers.push(worker);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'创建新进程：'</span>+worker.pid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line">server.listen(<span class="number">9527</span>, () =&gt; &#123;</span><br><span class="line">  workers.forEach(<span class="function"><span class="params">worker</span> =&gt;</span> &#123;</span><br><span class="line">    worker.send(<span class="string">'SERVER'</span>, server);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//关闭主服务器</span></span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//work.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建每个协助进程的 http 服务器，不监听任何端口号</span></span><br><span class="line"><span class="keyword">const</span> httpServer = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">`Hello world by <span class="subst">$&#123;process.pid&#125;</span>\n`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'message'</span>, (msg, tcpServer) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果是 master 传递来的 tcp server</span></span><br><span class="line">  <span class="keyword">if</span> (msg === <span class="string">'SERVER'</span>) &#123;</span><br><span class="line">    <span class="comment">// 新连接建立的时候触发</span></span><br><span class="line">    tcpServer.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">      <span class="comment">// 把 tcp server 的连接转给 http server 处理</span></span><br><span class="line">      httpServer.emit(<span class="string">'connection'</span>, socket);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在主进程发送完句柄之后，即关闭监听，也就是说，将所有的请求处理都交给子进程，这样可以做到权责分明。结构图如下：</p>
<p><img src="\images\Node-JS的进程\分布式.png" alt="分布式"></p>
<h4 id="同端口监听的原理"><a href="#同端口监听的原理" class="headerlink" title="同端口监听的原理"></a>同端口监听的原理</h4><h5 id="句柄的发送与还原"><a href="#句柄的发送与还原" class="headerlink" title="句柄的发送与还原"></a>句柄的发送与还原</h5><p>目前子进程对象的<code>send()</code>方法可以发送的句柄类型包括如下几种：</p>
<ul>
<li><code>net.Socket</code>：TCP套接字。</li>
<li><code>net.Server</code>：TCP服务器，任意建立在TCP服务上的应用层服务都可以进行传递。</li>
<li><code>net.Native</code>：C++层面的TCP套接字或IPC管道。</li>
<li><code>dgram.Socket</code>：UDP套接字。</li>
<li><code>dgram.Native</code>：C++层面的UDP套接字。</li>
</ul>
<p><code>send()</code>方法在将消息发送到IPC管道之前，会将消息组装成为两个对象，一个参数是<code>handle</code>，另一个是<code>message</code>。</p>
<p>我们简单看一下其源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴露用于调用的API，主要用来解析参数，后面调用_send()来进行发送</span></span><br><span class="line">target.send = <span class="function"><span class="keyword">function</span>(<span class="params">message, handle, options, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle === <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = handle;</span><br><span class="line">      handle = <span class="literal">undefined</span>;</span><br><span class="line">      options = <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = options;</span><br><span class="line">      options = <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      validateObject(options, <span class="string">'options'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options = &#123; <span class="attr">swallowErrors</span>: <span class="literal">false</span>, ...options &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connected) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._send(message, handle, options, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> ex = <span class="keyword">new</span> ERR_IPC_CHANNEL_CLOSED();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">      process.nextTick(callback, ex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际调用的API</span></span><br><span class="line">  target._send = <span class="function"><span class="keyword">function</span>(<span class="params">message, handle, options, callback</span>) </span>&#123;</span><br><span class="line">    assert(<span class="keyword">this</span>.connected || <span class="keyword">this</span>.channel);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//消息为空</span></span><br><span class="line">    <span class="keyword">if</span> (message === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ERR_MISSING_ARGS(<span class="string">'message'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Non-serializable messages should not reach the remote</span></span><br><span class="line">    <span class="comment">// end point; as any failure in the stringification there</span></span><br><span class="line">    <span class="comment">// will result in error message that is weakly consumable.</span></span><br><span class="line">    <span class="comment">// So perform a final check on message prior to sending.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> message !== <span class="string">'string'</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> message !== <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> message !== <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> message !== <span class="string">'boolean'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_ARG_TYPE(</span><br><span class="line">        <span class="string">'message'</span>, [<span class="string">'string'</span>, <span class="string">'object'</span>, <span class="string">'number'</span>, <span class="string">'boolean'</span>], message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Support legacy function signature</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">      options = &#123; <span class="attr">swallowErrors</span>: options &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Package messages with a handle object</span></span><br><span class="line">      <span class="comment">//注意：这里处理含有handle参数的情况</span></span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">      <span class="comment">// This message will be handled by an internalMessage event handler</span></span><br><span class="line">       <span class="comment">//新的message将会含有一个type属性用来标识handle的类型</span></span><br><span class="line">      message = &#123;</span><br><span class="line">        cmd: <span class="string">'NODE_HANDLE'</span>,</span><br><span class="line">        type: <span class="literal">null</span>,</span><br><span class="line">        msg: message</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断handle种类</span></span><br><span class="line">      <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> net.Socket) &#123;</span><br><span class="line">        message.type = <span class="string">'net.Socket'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> net.Server) &#123;</span><br><span class="line">        message.type = <span class="string">'net.Server'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> TCP || handle <span class="keyword">instanceof</span> Pipe) &#123;</span><br><span class="line">        message.type = <span class="string">'net.Native'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> dgram.Socket) &#123;</span><br><span class="line">        message.type = <span class="string">'dgram.Socket'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> UDP) &#123;</span><br><span class="line">        message.type = <span class="string">'dgram.Native'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_HANDLE_TYPE();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Queue-up message and handle if we haven't received ACK yet.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._handleQueue) &#123;</span><br><span class="line">        ArrayPrototypePush(<span class="keyword">this</span>._handleQueue, &#123;</span><br><span class="line">          callback: callback,</span><br><span class="line">          handle: handle,</span><br><span class="line">          options: options,</span><br><span class="line">          message: message.msg,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._handleQueue.length === <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      obj = handleConversion[message.type];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// convert TCP object to native handle object</span></span><br><span class="line">      handle = ReflectApply(handleConversion[message.type].send,</span><br><span class="line">                            target, [message, handle, options]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If handle was sent twice, or it is impossible to get native handle</span></span><br><span class="line">      <span class="comment">// out of it - just send a text without the handle.</span></span><br><span class="line">      <span class="keyword">if</span> (!handle)</span><br><span class="line">        message = message.msg;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Update simultaneous accepts on Windows</span></span><br><span class="line">      <span class="keyword">if</span> (obj.simultaneousAccepts &amp;&amp; process.platform === <span class="string">'win32'</span>) &#123;</span><br><span class="line">        handle.setSimultaneousAccepts(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._handleQueue &amp;&amp;</span><br><span class="line">               !(message &amp;&amp; (message.cmd === <span class="string">'NODE_HANDLE_ACK'</span> ||</span><br><span class="line">                             message.cmd === <span class="string">'NODE_HANDLE_NACK'</span>))) &#123;</span><br><span class="line">      <span class="comment">// Queue request anyway to avoid out-of-order messages.</span></span><br><span class="line">      ArrayPrototypePush(<span class="keyword">this</span>._handleQueue, &#123;</span><br><span class="line">        callback: callback,</span><br><span class="line">        handle: <span class="literal">null</span>,</span><br><span class="line">        options: options,</span><br><span class="line">        message: message,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._handleQueue.length === <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里在接收到参数之后，会构建一个新的<code>message</code>对象，其中含有<code>handle</code>的类型。然后将其推入<code>_handleQueue</code>中，后面由Node进行发送。</p>
<p>实际上发送到IPC管道中的是该句柄的文件描述符，文件描述符实际上是一个整数值。这个<code>message</code>对象在写入到IPC管道时会通过<code>JSON.stringify()</code>进行序列化。所以最终发送到IPC管道中的信息都是字符串。<code>send()</code>能发送消息和句柄不代表它能够发送任意对象。</p>
<p>连接了IPC管道的子进程可以读取到父进程发来的消息，将字符串通过<code>JSON.parse()</code>解析还原为对象后，才出发<code>message</code>事件将消息作为消息体传递给应用层。在这个过程中，消息对象还要被过滤处理，<code>message.cmd</code>的值如果以<code>NODE_</code>为前缀，它将响应一个内部事件<code>interalMessage</code>。如果<code>message.cmd</code>值为<code>NODE_HANDLE</code>，它将取出<code>message.type</code>值和得到的为文件描述符一起还原出一个对应的对象。这个过程如图。</p>
<p><img src="\images\Node-JS的进程\句柄发送还原.png" alt="句柄发送还原"></p>
<h5 id="端口的共同监听"><a href="#端口的共同监听" class="headerlink" title="端口的共同监听"></a>端口的共同监听</h5><p>在了解句柄传递背后的原理之后，我们继续探索为何发送句柄后，多个进程可以监听到同一个端口。其原因就在于：我们启动独立的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。</p>
<p>Node底层对每个端口监听都设置了<code>SO_REUSEADDR</code>选项，这个选项的含义是不同的进程可以就相同的网卡和端口进行监听，这个服务器套接字可以被不同的进程复用。</p>
<p>但是由于独立启动的进程互相之间不知道文件描述符，所以监听相同的端口时就会失败。但对于<code>send()</code>发送的句柄还原出来的服务而言，他们的文件描述符时相同的，所以可以监听到相同的端口不会引发异常。</p>
<p>多个应用监听同一个端口时，文件描述符同一时间只能被某一个进程所用。也就是说一个连接只能由一个进程处理，这些进程服务是抢占式的。</p>
<h2 id="集群稳定之路"><a href="#集群稳定之路" class="headerlink" title="集群稳定之路"></a>集群稳定之路</h2><h3 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h3><p>在进程除了<code>message</code>事件外，Node还定义了以下事件：</p>
<ul>
<li>error：当子进程无法被创建或无法被杀死或无法发送消息时会触发该事件。</li>
<li>exit：子进程退出时触发该事件，如果是正常退出，整个事件的第一个参数为退出码，否则为null。如果是通过<code>kill()</code>方法杀死的，会得到第二个参数，它标识杀死进程时的信号。</li>
<li>close：在子进程的标准输入输出流终止时触发该事件，参数与exit相同。</li>
<li>disconnect：在父进程或子进程中调用<code>disconnect()</code>方法时触发该事件，在调用该方法时将关闭监听IPC通道。</li>
</ul>
<h3 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h3><p>有了父子进程之间的相关事件之后，就可以在这些关系之间创建出需要的机制。我们通过子进程的exit事件来获知其退出的消息。同时利用这个事件，当一个子进程退出时，可以重新启动一个进程来继续服务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork</span><br><span class="line"><span class="keyword">let</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer()</span><br><span class="line">server.listen(<span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> works = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> createWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> worker = fork(__dirname + <span class="string">'/worker.js'</span>)</span><br><span class="line">    worker.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'work'</span> + worker.pid + <span class="string">'exited.'</span>)</span><br><span class="line">        <span class="keyword">delete</span> workers[worker.pid]</span><br><span class="line">        createWork()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//句柄转发</span></span><br><span class="line">    worker.send(<span class="string">'server'</span>, server)</span><br><span class="line">    workers[worker.pid] = worker</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Create worker. pid:'</span>+worker.pid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpus.length; i++)&#123;</span><br><span class="line">        createServer()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> pid <span class="keyword">in</span> workers)&#123;</span><br><span class="line">            workers[pid].kill()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS D:\Test\Node&gt; node reStart.js</span><br><span class="line">Create worker. pid:11436</span><br><span class="line">Create worker. pid:14868</span><br><span class="line">Create worker. pid:16240</span><br><span class="line">Create worker. pid:11044</span><br><span class="line"></span><br><span class="line">//杀死11436</span><br><span class="line">C:\Users\Administrator&gt;taskkill -F /pid 11436</span><br><span class="line">成功: 已终止 PID 为 11436 的进程。</span><br><span class="line"></span><br><span class="line">//自动新增进程</span><br><span class="line">work11436exited.</span><br><span class="line">Create worker. pid:15608</span><br></pre></td></tr></table></figure>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>多个进程的同时服务一个工作时，必须要保证每个进程都得到适量的工作，这种保证多个单元工作量公平的策略叫做负载均衡。</p>
<p>Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一顿工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。</p>
<p>这种机制一般来说是公平的，但是需要明白的是，一个进程的繁忙分为CPU繁忙和I/O繁忙两个部分构成。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够能够抢到较多的进程，形成负载不均衡的情况。</p>
<p>在此Node在v0.11中提供了一种的新的策略使得负载均衡更加合理，即轮转调度算法。轮转调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) % n 个进程来发送连接。在cluster模块中启用它。</p>
<h1 id="Cluster模块"><a href="#Cluster模块" class="headerlink" title="Cluster模块"></a>Cluster模块</h1><p>前面介绍的<code>child_process</code>模块，如果完全使用该模块来完成一个集群，那么还是有一定的难度，所以Node提供了<code>cluster</code>模块用于更方便的实现集群。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>工作进程由 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options" target="_blank" rel="noopener"><code>child_process.fork()</code></a> 方法创建，因此它们可以使用 IPC 和父进程通信，从而使各进程交替处理连接服务。</p>
<p>cluster 模块支持两种分发连接的方法。</p>
<p>第一种方法（也是除 Windows 外所有平台的默认方法）是循环法，由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程，在分发中使用了一些内置技巧防止工作进程任务过载。</p>
<p>第二种方法是，主进程创建监听 socket 后发送给感兴趣的工作进程，由工作进程负责直接接收连接。</p>
<p>理论上第二种方法应该是效率最佳的。 但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。 可能会出现八个进程中有两个分担了 70% 的负载。</p>
<p>因为 <code>server.listen()</code> 将大部分工作交给主进程完成，因此导致普通 Node.js 进程与 cluster 工作进程差异的情况有三种：</p>
<ol>
<li><code>server.listen({fd: 7})</code> 因为消息会被传给主进程，所以父进程中的文件描述符 7 将会被监听并将句柄传给工作进程，而不是监听文件描述符 7 指向的工作进程。</li>
<li><code>server.listen(handle)</code> 显式地监听句柄，会导致工作进程直接使用该句柄，而不是和主进程通信。</li>
<li><code>server.listen(0)</code> 正常情况下，这种调用会导致 server 在随机端口上监听。</li>
</ol>
<p>但在 cluster 模式中，所有工作进程每次调用 <code>listen(0)</code> 时会收到相同的“随机”端口。 实质上，这种端口只在第一次分配时随机，之后就变得可预料。 如果要使用独立端口的话，应该根据工作进程的 ID 来生成端口号。</p>
<p>Node.js 不支持路由逻辑。 因此在设计应用时，不应该过分依赖内存数据对象，例如 session 和登陆等。</p>
<p>由于各工作进程是独立的进程，它们可以根据需要随时关闭或重新生成，而不影响其他进程的正常运行。 只要有存活的工作进程，服务器就可以继续处理连接。 如果没有存活的工作进程，现有连接会丢失，新的连接也会被拒绝。 Node.js 不会自动管理工作进程的数量，而应该由具体的应用根据实际需要来管理进程池。</p>
<p>虽然 <code>cluster</code> 模块主要用于网络相关的情况，但同样可以用于其他需要工作进程的情况。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将上面的代码改写为cluster的方式：</p>
<p>这里的<code>setupMaster</code>方法：</p>
<ol>
<li><p><code>setupMaster</code> 用于修改默认的 ‘fork’ 行为。 一旦调用，将会按照 <code>cluster.settings</code> 进行设置。</p>
</li>
<li><p>所有的设置只对后来的 <a href="http://nodejs.cn/api/cluster.html#cluster_cluster_fork_env" target="_blank" rel="noopener"><code>.fork()</code></a> 调用有效，对之前的工作进程无影响。</p>
</li>
<li><p>唯一无法通过 <code>.setupMaster()</code> 设置的属性是传给 <a href="http://nodejs.cn/api/cluster.html#cluster_cluster_fork_env" target="_blank" rel="noopener"><code>.fork()</code></a> 的 <code>env</code> 属性。</p>
</li>
</ol>
<p>其接受的参数为<code>cluster.settings</code>对象：</p>
<ol>
<li>execArgv &lt;string[]&gt; 传给 Node.js 可执行文件的字符串参数列表。默认值: process.execArgv。</li>
<li>exec <string> 工作进程的文件路径。默认值: process.argv[1]。</li>
<li>args &lt;string[]&gt; 传给工作进程的字符串参数。默认值: process.argv.slice(2)。</li>
<li>cwd <string> 工作进程的当前工作目录。默认值: undefined（从父进程继承）。</li>
<li>serialization <string> 指定用于在进程之间发送消息的序列化类型。可能的值为 ‘json’ 和 ‘advanced’。有关更多详细信息，请参见child_process 的高级序列化。默认值: false。</li>
<li>silent <boolean> 是否需要发送输出到父进程的 stdio。默认值: false。</li>
<li>stdio <Array> 配置衍生的进程的 stdio。 由于 cluster 模块运行依赖于 IPC，这个配置必须包含 ‘ipc’。如果提供了这个选项，则覆盖 silent。</li>
<li>uid <number> 设置进程的用户标识符。参见 setuid(2)。</li>
<li>gid <number> 设置进程的群组标识符。参见 setgid(2)。<br>inspectPort <number> | <Function> 设置工作进程的检查端口。这可以是一个数字、或不带参数并返回数字的函数。默认情况下，每个工作进程都有自己的端口，从主进程的 process.debugPort 开始递增。<br>windowsHide <boolean> 隐藏衍生的进程的控制台窗口（通常在 Windows 系统上会创建）。默认值: false。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>)</span><br><span class="line"></span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">    exec: <span class="string">'worker.js'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpus.length; i++)&#123;</span><br><span class="line">    cluster.fork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>同样，cluster模块提供了一些事件监听：</p>
<ol>
<li><code>disconnect</code>事件</li>
<li><code>exit</code>事件</li>
<li><code>fork</code>事件</li>
<li><code>listening</code>事件</li>
<li><code>message</code>事件</li>
<li><code>online</code>事件：当衍生一个新的工作进程后，工作进程应当响应一个上线消息。 </li>
<li><code>setup</code>事件：每当 <a href="http://nodejs.cn/api/cluster.html#cluster_cluster_setupmaster_settings" target="_blank" rel="noopener"><code>.setupMaster()</code></a> 被调用时触发。</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本文大部分参考《深入浅出nodejs》以及<a href="https://nodejs.org/" target="_blank" rel="noopener">Node</a>官网</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>进程机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Node节点的操作</title>
    <url>/2021/03/22/Node%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h1><p><strong><code>Node</code></strong> 是一个接口，各种类型的 DOM API 对象会从这个接口继承。它允许我们使用相似的方式对待这些不同类型的对象；比如, 继承同一组方法，或者用同样的方式测试。</p>
<p>这里我们不谈其属性，只关注<code>Node</code>节点的操作。</p>
<h2 id="Node-appendChild"><a href="#Node-appendChild" class="headerlink" title="Node.appendChild()"></a><code>Node.appendChild()</code></h2><p><strong><code>Node.appendChild(aChild)</code></strong>方法将一个节点附加到指定父节点的子节点列表的末尾处。</p>
<p>值得注意的是：</p>
<ol>
<li>该方法只接受一个参数</li>
<li>其参数必须是一个<code>Node</code>，不能接受<code>DOMString</code>对象</li>
<li>如果<code>aChild</code>已存在文档中，则该方法会先remove该节点，再在目标位置插入节点</li>
<li>其会返回插入的子节点（<code>aChild</code>）</li>
</ol>
<p>兼容性如下，可以说是最起始一部分操作方法了。</p>
<p><img src="\images\Node\appendChild.png" alt="append"></p>
<h2 id="ParentNode-append"><a href="#ParentNode-append" class="headerlink" title="ParentNode.append()"></a><code>ParentNode.append()</code></h2><p> <strong><code>ParentNode.append</code></strong> 方法在 <code>ParentNode</code>的最后一个子节点之后插入一组 <code>Node</code>对象或 <code>DOMString</code>对象。</p>
<p>被插入的 <code>DOMString</code>对象等价为 <code>Text</code>节点。</p>
<p>与<code>appendChild</code>不同的是：</p>
<ol>
<li>允许追加  DOMString 对象，而 Node.appendChild() 只接受 Node 对象。</li>
<li>没有返回值，而 Node.appendChild() 返回追加的 Node 对象。</li>
<li>可以追加多个节点和字符串，而 Node.appendChild() 只能追加一个节点。</li>
</ol>
<p>这个方法的兼容性相对差一些，但是功能全面。</p>
<p><img src="\images\Node\append.png" alt="append"></p>
<h2 id="Node-insertBefore"><a href="#Node-insertBefore" class="headerlink" title="Node.insertBefore()"></a><code>Node.insertBefore()</code></h2><p><strong><code>Node.insertBefore()</code></strong> 方法在参考节点之前插入一个拥有指定父节点的子节点。函数返回被插入过的子节点。</p>
<p>注意：</p>
<ol>
<li>如果给定的子节点是对文档中现有节点的引用，<code>insertBefore()</code> 会将其从当前位置移动到新位置</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNode = parentNode.insertBefore(newNode, referenceNode);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>insertedNode</code> 被插入节点(newNode)</li>
<li><code>parentNode</code> 新插入节点的父节点</li>
<li><code>newNode</code> 用于插入的节点</li>
<li><code>referenceNode</code> <code>newNode</code> 将要插在这个节点之前</li>
</ul>
<p>如果 <code>referenceNode</code> 为 <code>null</code> 则 <code>newNode</code> 将被插入到子节点的末尾<em>。</em></p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="\images\Node\insertBefore.png" alt="insertBefore"></p>
<h2 id="Node-removeChild"><a href="#Node-removeChild" class="headerlink" title="Node.removeChild"></a><code>Node.removeChild</code></h2><p><strong><code>Node.removeChild()</code></strong> 方法从DOM中删除一个子节点。返回删除的节点。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldChild = node.removeChild(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OR</span></span><br><span class="line"></span><br><span class="line">element.removeChild(child);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>child</code> 是要移除的那个子节点.</li>
<li><code>node</code> 是<code>child</code>的父节点.</li>
<li>oldChild保存对删除的子节点的引用. <code>oldChild</code> === <code>child</code>.</li>
</ul>
<p>注意：</p>
<blockquote>
<p>被移除的这个子节点仍然存在于内存中,只是没有添加到当前文档的DOM树中,因此,你还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量比如<code>上例中的oldChild</code>来保存这个节点的引用. 如果使用上述语法中的第二种方法, 即没有使用 oldChild 来保存对这个节点的引用, 则认为被移除的节点已经是无用的, 在短时间内将会被内存管理回收.</p>
</blockquote>
<h2 id="Node-replaceChild"><a href="#Node-replaceChild" class="headerlink" title="Node.replaceChild()"></a><code>Node.replaceChild()</code></h2><p><strong><code>Node.replaceChild()</code></strong> 方法用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = parentNode.replaceChild(newChild, oldChild);</span><br></pre></td></tr></table></figure>
<p><strong>newChild</strong></p>
<p>用来替换 <code>oldChild</code> 的新节点。如果该节点已经存在于 DOM 树中，则它首先会被从原始位置删除。</p>
<p><strong>oldChild</strong></p>
<p>被替换掉的原始节点。</p>
<h3 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="\images\Node\replaceChild.png" alt="replaceChild"></p>
<h2 id="Node-cloneNode"><a href="#Node-cloneNode" class="headerlink" title="Node.cloneNode"></a><code>Node.cloneNode</code></h2><p><strong><code>Node.cloneNode()</code></strong>方法返回调用该方法的节点的一个副本.</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dupNode = node.cloneNode(deep);</span><br></pre></td></tr></table></figure>
<p><code>node</code></p>
<p>将要被克隆的节点</p>
<p><code>dupNode</code></p>
<p>克隆生成的副本节点</p>
<p><code>deep</code> 可选</p>
<p>是否采用深度克隆<code>,如果为true,</code>则该节点的所有后代节点也都会被克隆,如果为<code>false,则只克隆该节点本身.</code></p>
<blockquote>
<p><strong>注意:</strong> 在 DOM4 规范中(实现于Gecko 13.0(Firefox 13.0 / Thunderbird 13.0 / SeaMonkey 2.10))，<code>deep</code>是一个可选参数。如果省略的话，参数的默认值为 <code>true，</code>也就是说默认是深度克隆。如果想使用浅克隆, 你需要将该参数设置为 <code>false。</code></p>
<p>在最新的规范里，该方法的行为已经改变了，其默认值变成了 false。虽然该参数仍旧是可选的，但是你必须要为该方法设置 deep 参数，无论是为了向前还是向后兼容考虑。假如开发者没设置参数的话，Gecko 28.0 (Firefox 28 / Thunderbird 28 / SeaMonkey 2.25 / Firefox OS 1.3)) 版本的控制台会发出警告。从 Gecko 29.0 (Firefox 29 / Thunderbird 29 / SeaMonkey 2.26)) 开始该方法默认为浅复制而不是深度复制。</p>
</blockquote>
<p>值得注意的是：</p>
<ol>
<li><p>克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如<code>onclick=&quot;alert(1)&quot;</code>),但不会拷贝那些使用<code>addEventListener()</code>方法或者<code>node.onclick = fn</code>这种用JavaScript动态绑定的事件。</p>
</li>
<li><p>在使用<code>Node.appendChild()</code>或其他类似的方法将拷贝的节点添加到文档中之前,那个拷贝节点并不属于当前文档树的一部分,也就是说,它没有父节点。</p>
</li>
<li><p>如果<code>deep</code>参数设为<code>false</code>,则不克隆它的任何子节点.该节点所包含的所有文本也不会被克隆,因为文本本身也是一个或多个的<code>Text</code>节点。</p>
<h3 id="兼容性-2"><a href="#兼容性-2" class="headerlink" title="兼容性"></a>兼容性</h3></li>
</ol>
<blockquote>
<p>注意:为了防止一<img src="\images\Node\cloneNode.png" alt="cloneNode">个文档中出现两个ID重复的元素,使用<code>cloneNode()方法克隆的节点在需要时应该指定另外一个与原ID值不同的ID</code></p>
</blockquote>
<h2 id="Node-contains"><a href="#Node-contains" class="headerlink" title="Node.contains"></a><code>Node.contains</code></h2><p><code>Node.contains()</code>返回的是一个布尔值，来表示传入的节点是否为该节点的后代节点。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node.contains( otherNode )</span><br></pre></td></tr></table></figure>
<ul>
<li><code>node</code> 是否包含otherNode节点.</li>
<li><code>otherNode</code> 是否是node的后代节点.</li>
</ul>
<p>如果 <code>otherNode</code> 是 <code>node 的后代节点或是</code> <code>node</code> 节点本身.则返回<code>true</code> , 否则返回 <code>false</code>.</p>
<h3 id="兼容性-3"><a href="#兼容性-3" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="\images\Node\contains.png" alt="contains"></p>
<h2 id="Node-isEqualNode"><a href="#Node-isEqualNode" class="headerlink" title="Node.isEqualNode"></a><code>Node.isEqualNode</code></h2><p> <strong><code>Node.isEqualNode()</code></strong>方法可以判断两个节点是否相等。当两个节点的类型相同，定义特征(defining characteristics)相同（对元素来说，即 id，孩子节点的数量等等），属性一致等，这两个节点就是相等的。一些具体的数据指出：多数时候的比较是根据节点的类型来的。</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isEqualNode = node.isEqualNode(otherNode);</span><br></pre></td></tr></table></figure>
<ul>
<li>otherNode: 比较是否相等的节点.</li>
</ul>
<p>注意：这里的<code>equal</code>与<code>===</code>不同，用<code>===</code>比较时，比较的是node的唯一id。而这里是鸭子比较法。</p>
<h2 id="Node-hasChildNodes"><a href="#Node-hasChildNodes" class="headerlink" title="Node.hasChildNodes"></a><code>Node.hasChildNodes</code></h2><p><code>hasChildNodes</code>方法返回一个布尔值,表明当前节点是否包含有子节点.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有三种方法可以判断当前节点是否有子节点。</p>
<ul>
<li>node.firstChild !== null</li>
<li>node.childNodes.length &gt; 0</li>
<li>node.hasChildNodes()</li>
</ul>
<h1 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h1><p>可以使用<code>element</code>标签的<code>innerHTML</code>与<code>innerText</code>属性。以及<code>insertAdjacentHTML</code>方法来修改元素内部的值。</p>
<h2 id="element-innerHTML"><a href="#element-innerHTML" class="headerlink" title="element.innerHTML"></a><code>element.innerHTML</code></h2><p><strong><code>Element.innerHTML</code></strong> 属性设置或获取HTML语法表示的元素的后代。</p>
<p>注意：如果一个 <div>, <span>, 或 <noembed> 节点有一个文本子节点，该节点包含字符 (&amp;), (&lt;),  或(&gt;), innerHTML 将这些字符分别返回为&amp;, &lt; 和 &gt; 。使用Node.textContent  可获取一个这些文本节点内容的正确副本。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> content = element.innerHTML;</span><br><span class="line">element.innerHTML = htmlString;</span><br></pre></td></tr></table></figure>
<p><code>DOMString</code>包含元素后代的HTML序列。设置元素的 <code>innerHTML</code> 将会删除所有该元素的后代并以上面给出的 htmlString 替代。</p>
<p>注意：</p>
<p><strong><code>SyntaxError</code></strong> </p>
<p>​    当 HTML 没有被正确标记时，设置 <code>innerHTML</code> 将会抛出语法错误。</p>
<p><strong><code>NoModificationAllowedError</code></strong> </p>
<p>​    当父元素是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document" target="_blank" rel="noopener"><code>Document</code></a> 时，设置 <code>innerHTML</code> 将会提示不允许修改。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>用 <code>innerHTML</code> 插入文本到网页中并不罕见。但这有可能成为网站攻击的媒介，从而产生潜在的安全风险问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">"John"</span>;</span><br><span class="line"><span class="comment">// assuming 'el' is an HTML DOM element</span></span><br><span class="line">el.innerHTML = name; <span class="comment">// harmless in this case</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">"&lt;script&gt;alert('I am John in an annoying alert!')&lt;/script&gt;"</span>;</span><br><span class="line">el.innerHTML = name; <span class="comment">// harmless in this case</span></span><br></pre></td></tr></table></figure>
<p>尽管这看上去像 <a href="https://zh.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">cross-site scripting</a> 攻击，结果并不会导致什么。<strong>HTML 5 中指定不执行由 <code>innerHTML</code> 插入的<code>script</code>标签。</strong></p>
<p>然而，有很多不依赖<code>&lt;script&gt;</code>标签去执行，<code>innerHTML</code> 去设置你无法控制的字符串时，这仍然是一个安全问题。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">"&lt;img src='x' onerror='alert(1)'&gt;"</span>;</span><br><span class="line">el.innerHTML = name; <span class="comment">// shows the alert</span></span><br></pre></td></tr></table></figure>
<p>于这个原因，当插入纯文本时，建议不要使用 <code>innerHTML</code> 。取而代之的是使用 <code>Node.textContent</code>或者<code>element.innerText</code>，它不会把给定的内容解析为 HTML，它仅仅是将原始文本插入给定的位置。</p>
<h3 id="兼容性-4"><a href="#兼容性-4" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="\images\Node\innerHTML.png" alt="innerHTML"></p>
<h2 id="HTMLElement-innerText"><a href="#HTMLElement-innerText" class="headerlink" title="HTMLElement.innerText"></a><code>HTMLElement.innerText</code></h2><p><strong><code>innerText</code></strong> 属性表示一个节点及其后代的“渲染”文本内容。与<code>innerText</code>一样，其可以作为一个getter，其作为一个getter的时候，获取的内容与用户光标选中后复制的内容差不多</p>
<blockquote>
<p><strong>Note:</strong> <code>innerText</code> 很容易与<code>Node.textContent</code>混淆, 但这两个属性间实际上有很重要的区别. 大体来说, <code>innerText</code> 可操作已被渲染的内容， 而 <code>textContent</code> 则不会.</p>
</blockquote>
<h2 id="Node-textContent"><a href="#Node-textContent" class="headerlink" title="Node.textContent"></a><code>Node.textContent</code></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node" target="_blank" rel="noopener"><code>Node</code></a> 接口的 <code>textContent</code> 属性表示一个节点及其后代的文本内容。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p><code>textContent</code> 的值取决于具体情况：</p>
<ol>
<li>如果节点是一个 <code>document</code>，或者一个 DOCTYPE ，则 <code>textContent</code> 返回 <code>null</code>。</li>
<li>如果节点是个 <code>CDATA section</code>、注释、<code>processing instruction</code>或者 <code>text node</code>，<code>textContent</code> 返回节点内部的文本内容，例如 <code>Node.nodeValue</code>。</li>
<li>对于其他节点类型，<code>textContent</code> 将所有子节点的 <code>textContent</code> 合并后返回，除了注释和processing instructions。（如果该节点没有子节点的话，返回一个空字符串。）</li>
</ol>
<p>注意：在节点上设置 <code>textContent</code> 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。</p>
<h3 id="与-innerText-的区别"><a href="#与-innerText-的区别" class="headerlink" title="与 innerText 的区别"></a>与 <strong>innerText</strong> 的区别</h3><ol>
<li><code>textContent</code> 会获取<em>所有</em>元素的内容，包括<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>元素，然而 <code>innerText</code> 只展示给人看的元素。</li>
<li><code>textContent</code> 会返回节点中的每一个元素。相反，<code>innerText</code> 受 CSS 样式的影响，并且不会返回隐藏元素的文本，<ul>
<li>此外，由于 <code>innerText</code> 受 CSS 样式的影响，它会触发回流（ <a href="https://wiki.developer.mozilla.org/en-US/docs/Glossary/Reflow" target="_blank" rel="noopener">reflow</a> ）去确保是最新的计算样式。（回流在计算上可能会非常昂贵，因此应尽可能避免。）</li>
</ul>
</li>
<li>与 <code>textContent</code> 不同的是, 在 Internet Explorer (小于和等于 11 的版本) 中对 <code>innerText</code> 进行修改， 不仅会移除当前元素的子节点，而且还会<em>永久性地破坏</em>所有后代文本节点。在之后不可能再次将节点再次插入到任何其他元素或同一元素中。</li>
</ol>
<h3 id="兼容性-5"><a href="#兼容性-5" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="\images\Node\textContent.png" alt="textContent"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.mozilla.org/zh-CN/docs" target="_blank" rel="noopener">MDN</a></p>
]]></content>
      <categories>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>DOM</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL必知必会19-21-数据和表的操作</title>
    <url>/2022/02/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A19-21-%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h1><p><code>INSET</code>可以用来插入数据，其可以用以下几种方式使用：</p>
<ul>
<li>插入完整的行；</li>
<li>插入行的一部分；</li>
<li>插入多行；</li>
<li>插入某些查询的结果。</li>
</ul>
<blockquote>
<p>插入及系统安全机制：可针对每个表或 每个用户，利用MySQL的安全机制禁止使用INSET语句。</p>
</blockquote>
<h2 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h2><p>可以直接按照表中的字段顺序来使用<code>INSERT</code>插入数据。</p>
<p>例如表<code>Customers</code>的结构为：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>location</th>
<th>birthday</th>
<th>hobby</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>则可以通过下面的方式来插入数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="string">'mw'</span>, <span class="string">'China'</span>, <span class="string">'1999-1-1'</span>, <span class="string">'hike'</span>);</span><br></pre></td></tr></table></figure>
<p>但这种方式并不安全，因为其依赖于表中字段的顺序。还可以按照给出的字段顺序来插入数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(<span class="keyword">id</span>, <span class="keyword">name</span>, location, birthday, hobby) <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="string">'mw'</span>, <span class="string">'China'</span>, <span class="string">'1999-1-1'</span>, <span class="string">'hike'</span>);</span><br></pre></td></tr></table></figure>
<p>此例子完成与前一个<code>INSERT</code>语句完全相同的工作，但在表名后的括号里明确地给出了列名。则其后<code>VALUES</code>中的数据就是与前面给出的顺序相同。</p>
<p>因为提供了列名，<code>VALUES</code>必须以其指定的次序匹配指定的列名，不 一定按各个列出现在实际表中的次序。其优点是，即使表的结构改变， 此<code>INSERT</code>语句仍然能正确工作。</p>
<blockquote>
<p><strong>总是使用列的列表</strong>，一般不要使用没有明确给出列的列表的 INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使<br>表结构发生了变化。</p>
</blockquote>
<p>省略列：如果表的定义允许，则可以在INSERT操作中省略某 些列。省略的列必须满足以下某个条件。 </p>
<ul>
<li>该列定义为允许<code>NULL</code>值（无值或空值）。 </li>
<li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li>
</ul>
<p>如果数据检索是最重要的（通常是这样），则你可以通过在 <code>INSERT</code>和<code>INTO</code>之间添加关键字<code>LOW_PRIORITY</code>，指示MySQL 降低<code>INSERT</code>语句的优先级，如下所示：<br>顺便说一下，这也适用于下一章介绍的<code>UPDATE</code>和<code>DELETE</code>语句。</p>
<h2 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h2><p><code>INSERT</code>也支持一条语句插入多条数据。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(<span class="keyword">id</span>, <span class="keyword">name</span>, location, birthday, hobby) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'mw'</span>, <span class="string">'China'</span>, <span class="string">'1999-1-1'</span>, <span class="string">'hike'</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'tom'</span>, <span class="string">'America'</span>, <span class="string">'1999-1-1'</span>, <span class="string">'basketball'</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'jimmy'</span>, <span class="string">'France'</span>, <span class="string">'1999-1-1'</span>, <span class="string">'drink'</span>);</span><br></pre></td></tr></table></figure>
<p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来， 用逗号分隔。</p>
<p><strong>提高<code>INSERT</code>的性能此技术可以提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条<code>INSERT</code>语句快。</strong></p>
<h2 id="插入检索的数据"><a href="#插入检索的数据" class="headerlink" title="插入检索的数据"></a>插入检索的数据</h2><p><code>INSERT</code>一般用来给表插入一个指定列值的行。但是，<code>INSERT</code>还存在另一种形式，可以利用它将一条<code>SELECT</code>语句的结果插入表中。这就是所 谓的<code>INSERT SELECT</code>，顾名思义，它是由一条<code>INSERT</code>语句和一条<code>SELECT</code>语句组成的。</p>
<p>假如你想从另一表中合并客户列表到你的customers表。不需要每次读取一行，然后再将它用INSERT插入，可以如下进行：</p>
<p>例如，将<code>Customers</code>中的数据插入到新的<code>CustomersNew</code>表中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> CustomersNew(<span class="keyword">id</span>, <span class="keyword">name</span>, location, birthday, hobby)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, location, birthday, hobby</span><br><span class="line"><span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure>
<p>这个例子使用<code>INSERT SELECT</code>从中将<code>customers</code>所有数据导入 <code>CustomersNew</code>。</p>
<p><strong>这条语句将插入多少行有赖于<code>customers</code>表中有多少行。</strong></p>
<p>这个例子导入了cust_id（假设你能够确保cust_id的值不重复）。你 也可以简单地省略这列（从INSERT和SELECT中），这样MySQL就会生成新值。</p>
<blockquote>
<p>INSERT SELECT中的列名：为简单起见，这个例子在INSERT和 SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。 事实上，MySQL甚至不关心SELECT返回的列名。它使用的是 列的位置，因此SELECT中的第一列（不管其列名）将用来填充 表列中指定的第一个列，第二列将用来填充表列中指定的第二 个列，如此等等。这对于从使用不同列名的表中导入数据是非<br>常有用的。</p>
</blockquote>
<p><code>INSERT SELECT</code>中<code>SELECT</code>语句可包含<code>WHERE</code>子句以过滤插入的数据。</p>
<h1 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h1><p>为了更新数据，需要使用<code>UPDATE</code>语句，可以采用两种方式使用<code>UPDATE</code>：</p>
<ul>
<li>更新表中特定行。</li>
<li>更新表中的所有的行。</li>
<li>确定要更新行的过滤条件。</li>
</ul>
<h3 id="更新单列"><a href="#更新单列" class="headerlink" title="更新单列"></a>更新单列</h3><p>例如：客户10005现在有了电子邮件地址，因此他的记录 需要更新，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers <span class="keyword">SET</span> cust_email = <span class="string">'elmer@fudd.com'</span> <span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
<p><code>UPDATE</code>语句总是以要更新的表的名字开始。在此例子中，要更新的 表的名字为customers。SET命令用来将新值赋给被更新的列。如这里所示，<code>SET</code>子句设置<code>cust_email</code>列为指定的值。</p>
<p><code>UPDATE</code>语句以<code>WHERE</code>子句结束，它告诉MySQL更新哪一行。没有 <code>WHERE</code>子句，MySQL将会用这个电子邮件地址更新customers表中所有行，这不是我们所希望的。</p>
<h3 id="更新多列"><a href="#更新多列" class="headerlink" title="更新多列"></a>更新多列</h3><p>更新多列时，需要在<code>SET</code>放置多个更新项，用逗号隔开。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers <span class="keyword">SET</span> cust_name = <span class="string">'The  Fudds'</span>, cust_email = <span class="string">'elmer@fudd.com'</span> <span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>IGNORE</code>关键字：如果用<code>UPDATE</code>语句更新多行，并且在更新这些 行中的一行或多行时出一个现错误，则整个<code>UPDATE</code>操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新可使用IGNORE关键字，如下所示：<code>UPDATE IGNORE customers…</code>。</p>
</blockquote>
<h3 id="删除某个值"><a href="#删除某个值" class="headerlink" title="删除某个值"></a>删除某个值</h3><p>为了删除某一列的的值，可以设置它为NULL（假定表设定为允许NULL）。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers <span class="keyword">SET</span> cust_email = <span class="literal">NULL</span> <span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
<p>其中NULL用来去除<code>cust_email</code>列中的值。</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>可以通过<code>DELETE</code>关键值来删除数据。其有两种方式：</p>
<ul>
<li>从表中删除特定的行。</li>
<li>从表中删除所有的行。</li>
</ul>
<p>例如：</p>
<p>1：删除特定行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id = <span class="number">10006</span>;</span><br></pre></td></tr></table></figure>
<p>DELETE FROM要求指定从中删除数据的表名。 WHERE子句过滤要删除的行。在这个例子中，只删除客户10006。</p>
<p>2：删除所有的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure>
<p>即去掉<code>WHERE</code>限制条件。就会删除表中的所有数据。</p>
<blockquote>
<p>更快的删除：如果想从表中删除所有行，不要使用DELETE。 可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</p>
</blockquote>
<h2 id="更新和删除指导"><a href="#更新和删除指导" class="headerlink" title="更新和删除指导"></a>更新和删除指导</h2><ul>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE 子句的UPDATE或DELETE语句。</li>
<li>保证每个表都有主键，尽可能 像WHERE子句那样使用它。</li>
<li>在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进 行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。</li>
<li>使用强制实施引用完整性的数据库。</li>
</ul>
<h1 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h1><p>这里仅讨论通过MySQL命令来创建和操作表，如果使用GUI工具会更加简单。</p>
<h2 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h2><p>为利用CREATE TABLE创建表，必须给出下列信息： </p>
<ul>
<li>新表的名字，在关键字<code>CREATE TABLE</code>之后给出；</li>
<li>表列的名字和定义，用逗号分隔。</li>
</ul>
<p>CREATE TABLE语句也可能会包括其他关键字或选项，但至少要包括表的名字和列的细节。</p>
<h3 id="表创建基础"><a href="#表创建基础" class="headerlink" title="表创建基础"></a>表创建基础</h3><p>例如，创建<code>customers</code>表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers</span><br><span class="line">(</span><br><span class="line">    cust_id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    cust_name <span class="built_in">char</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    cust_address <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_city <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_state <span class="built_in">char</span>(<span class="number">5</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_zip <span class="built_in">char</span>(<span class="number">10</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_country <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_contact <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_emai1 <span class="built_in">char</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (cust_id)</span><br><span class="line">) <span class="keyword">ENGINE</span>-<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以看到，表名紧跟在<code>CREATE TABLE</code>关键字后 面。实际的表定义（所有列）括在圆括号之中。各列之间用逗号分隔。这个表由9列组成。每列的定义以列名（它在表中必须是唯一的）开始，后跟列的数据类型。表的主键可以在创建表时用 <code>PRIMARY KEY</code>关键字指定。这里，列cust_id指定作为主键列。整条语句由右圆括号后的分号结束。</p>
<blockquote>
<p>处理现有的表 在创建新表时，指定的表名必须不存在，否则 将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删 除该表，然后再重建它，而不是简单地用创建表语句覆盖它。</p>
</blockquote>
<h3 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h3><p>允许NULL的字段，则允许在插入或更新的时候空缺其值或者赋予NULL值。</p>
<p>MySQL可以在指定字段时指定<code>NULL</code>或<code>NOT NULL</code>来确定允许空缺或不允许空缺。</p>
<h3 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h3><p>被<code>AUTO_INCREMENT</code>标记得的字段会在数据增加的时候自动增加（一般将其赋NULL，让其自增）。但是其有以下规范：</p>
<ul>
<li><p><code>AUTO_INCREMENT</code>是数据列的一种属性，只适用于整数类型数据列。</p>
</li>
<li><p>设置<code>AUTO_INCREMENT</code>属性的数据列应该是一个正数序列，所以应该把该数据列声明为UNSIGNED，这样序列的编号个可增加一倍。</p>
</li>
<li><p><code>AUTO_INCREMENT</code>数据列必须有唯一索引，以避免序号重复(即是主键或者主键的一部分)。</p>
</li>
<li><p><code>AUTO_INCREMENT</code>数据列必须具备<code>NOT NULL</code>属性。</p>
</li>
<li><p><code>AUTO_INCREMENT</code>数据列序号的最大值受该列的数据类型约束，如<code>TINYINT</code>数据列的最大编号是127,如加上<code>UNSIGNED</code>，则最大为255。一旦达到上限，<code>AUTO_INCREMENT</code>就会失效。</p>
</li>
<li><p>当进行全表删除时，MySQL <code>AUTO_INCREMENT</code>会从1重新开始编号。全表删除的意思是发出以下两条语句时：</p>
<p><code>delete from table_name;</code>或者<code>truncate table table_name</code>。</p>
</li>
</ul>
<h3 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h3><p>如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。</p>
<p>其通过<code>DEFAULT</code>关键字来指定。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line">(</span><br><span class="line">    order_numint <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    order_item <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">    prod_idchar(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    quantity intNOT <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">    item _price decima1(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (order_num，order_item)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>quantity列包含订单中每项物品的数量。在此例子中，给该列的描述添加文本<code>DEFAULT 1</code>指示MySQL，在未给出数量的情况下使用数量1。</p>
<h3 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h3><p>MySQL有一个具体管理和处理数据的内部引擎。 在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用<code>SELECT</code> 语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候，此引擎都隐藏在DBMS内，不需要过多关注它。</p>
<p>但MySQL与其他DBMS不一样，它具有多种引擎。它打包多个引擎， 这些引擎都隐藏在MySQL服务器内，全都能执行<code>CREATE TABLE</code>和<code>SELECT</code>等命令。</p>
<p>当然，你完全可以忽略这些数据库引擎。如果省略<code>ENGINE=</code>语句，则 使用默认引擎。多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么<code>ENGINE=</code>语句很重要的原因。</p>
<p>下面是几个引擎：</p>
<ul>
<li>InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索；</li>
<li>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘） 中，速度很快（特别适合于临时表）；</li>
<li>MyISAM是一个性能极高的引擎，它支持全文本搜索， 但不支持事务处理。</li>
</ul>
<h2 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h2><p>为更新表定义，可使用ALTER TABLE语句。<strong>但是，理想状态下，当表中存储数据以后，该表就不应该再被更新。</strong>在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。</p>
<p>为了使用ALTER TABLE更改表结构，必须给出下面的信息：</p>
<ul>
<li>在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将 出错）；</li>
<li>所做更改的列表。</li>
</ul>
<p>例如:</p>
<p>1：给表添加一个字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors <span class="keyword">ADD</span> vend_phone <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>2：删除表的一个字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span><br></pre></td></tr></table></figure>
<p>3：定义外键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (order_num) <span class="keyword">REFERENCES</span> orders (order_num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_products </span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (prod_id)<span class="keyword">REFERENCES</span> products (prod_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orders_customers </span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (cust_id)<span class="keyword">REFERENCES</span> customers (cust_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_products_vendors</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (vend_id)<span class="keyword">REFERENCES</span> vendors (vend_id);</span><br></pre></td></tr></table></figure>
<p>这里，由于要更改4个不同的表，使用了4条ALTER TABLE语句。为了对单个表进行多个更改，可以使用单条ALTER TABLE语句，每个更改用逗号分隔。</p>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>使用<code>DROP</code>关键字来删除整个表。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers;</span><br></pre></td></tr></table></figure>
<p>这条语句删除customers表（假设它存在）。<strong>删除表没有确认， 也不能撤销，执行这条语句将永久删除该表。</strong></p>
<h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><p>使用<code>RENAME TABLE</code>关键字来对表进行重命名。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> customers <span class="keyword">TO</span> customersNew;</span><br></pre></td></tr></table></figure>
<p>还可以对表进行批量重命名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> backup_customers <span class="keyword">To</span> customers,</span><br><span class="line">			backup_vendors <span class="keyword">To</span> vendors,</span><br><span class="line">			backup_products <span class="keyword">TO</span> products;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>数据和表的操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise理解</title>
    <url>/2019/06/28/Promise%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="唠唠叨叨"><a href="#唠唠叨叨" class="headerlink" title="唠唠叨叨"></a>唠唠叨叨</h1><p>最近考试比较多，终于快结束了，间隙时间，我第一遍看了《你不知道的JavaScript》的上中篇，说实话，可能是因为译本的原因，也可能是知识比较深入，我感觉比较难理解，有时感觉一小节讲完，发现他的中心观点只有一句话。但总的来说，这是套值得深入研读的书籍，暑假我将再次研读。<br><a id="more"></a></p>
<h2 id="Promise的神秘面纱"><a href="#Promise的神秘面纱" class="headerlink" title="Promise的神秘面纱"></a>Promise的神秘面纱</h2><p>ES6的知识点着实比较庞大，除了对Number，Array等的扩展。Promise这个概念也很吸引人。比如著名的<code>axios</code>就是采用Promise来封装的。</p>
<p>我在《你不知道的JavaScript》中看到一个比较形象的比喻，当你去买一个汉堡包，你先把钱给服务员，然后服务员会给你一个<strong>凭证</strong>，在这个汉堡包被完成之前，凭证即代表了你的汉堡包。一段时间过后，服务员通知你结果。但这是服务员可能会对你说：‘Sorry Sir,hamburger has sold out…’这种失败的结果即为Promise中的<strong>reject</strong>。但大多数情况下，我们期望并得到的结果是一个汉堡包 （ <strong>solved</strong>）。</p>
<p>也就是说：<strong>Promise是一个容器，里面保存着未来才会结束的事件（通常是一个一步操作）的结果。</strong></p>
<p><strong>Promise的特点</strong></p>
<ol>
<li>Promise的状态不收外界的影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p><strong>Promise的基本用法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义promise</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> res = asycFunc();</span><br><span class="line">	<span class="keyword">if</span>(res.code 满足条件)&#123;</span><br><span class="line">		resolved(res.data);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		reject(res.data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用promise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1(不推荐). </span></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;show(res)&#125;,err=&gt;(handleError(err)))</span><br><span class="line"><span class="comment">//2(推荐). </span></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;show(res)&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;handleError(err)&#125;)</span><br></pre></td></tr></table></figure>
<p>第二种的好处在于，<strong>1.采用链式的写法可以捕获前一个then抛出的错误，而一then中同时写resolve与reject无法做到。2.在语法上更人性化，类似于try…catch…语法。</strong>但实际catch = then(null,rejection).<br>都是捕获产生的错误，包括rejected，Error；对于错误，还有一点值得注意的是，<strong>reject或者resolve即代表这个promise状态的冻结。类似于函数的return，这两个语句一旦发生，其后面所有的语句都将无效。即使是抛出错误，也无法再被catch所捕获。</strong></p>
<p><strong>Promise的链式玩法</strong></p>
<p>前面的then…catch…其实已经是链式的写法了。</p>
<p>Promise有3个函数可以链式调用。分别是</p>
<ol>
<li><code>then(func(reslved,rejected){...})</code>: 为Promise实例添加状态改变时的回调函数。</li>
<li><code>catch(func(err){...})</code>: 用于指定发生错误时的回调函数。包括rejected也被他处理。</li>
<li><code>finally(func(){...})</code>: 无论状态如何，是否抛出错误。都将执行该回调。</li>
</ol>
<p>但其能够一直链式调用的原因是：这3个函数每次调用都会产生一个新的Promise对象，并且这个新的promise会将旧的promise返回值作为参数，这个对象又包含了这3个方法，所以可以一直链式调用。</p>
<p><strong>Promise的高级玩法（模式）</strong></p>
<ol>
<li>Promise.all([p1,p2,…])</li>
</ol>
<p>说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为：</p>
<p>a. 所有的Promise的值变为resolved时，该对象才返回resolved，并返回所有的结果。<br>b. 一旦有一个Promise对象返回rejected，则整个对象返回rejected，并返回错误原因。</p>
<p><em>由Promise封装的axios中，有axios.all([re1,re2,…])方法</em></p>
<ol start="2">
<li>Promise.race([p1,p2,…])</li>
</ol>
<p>说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为：</p>
<p>a. 当第一个Promise返回resolved时，整个Promise状态变为resolved，并返回第一个Promise resolved的结果，一旦有任何一个Promise决议为拒绝，他就会拒绝。</p>
<p><strong>值得注意的</strong></p>
<ol>
<li>Promise.all在传入空数组时，会立即返回resolved；但Promise.race会被一直挂起。<strong>所以不要想Promise.race中传递空数组。</strong>希望ECMA会尽快修改这一点。</li>
</ol>
<p><strong>一些骚操作</strong></p>
<p>在《你不知道JavaScript》一书中，提出来一些ES6标准之外的Promise模式之外的一些扩展模式，比如：</p>
<ol>
<li><code>Promise.none([...])</code>:与<code>Promise.all</code>的情况互换，即所有的Promise都rejected才rejected。反之则返回resolved。</li>
<li><code>Promise.any([...])</code>:与race相对，该模式忽略rejected，得到第一个resolved。</li>
<li><code>Promise.first([...]):</code>这个模式类似与any([…])的竞争，，即只要第一个Promise完成，他就会忽略有序的任何拒绝和完成。</li>
<li><code>Promise.last([...])</code>:这个类似与first([…]，但确实最后一个完成胜出。</li>
</ol>
<p>示例：<code>Promise.first([...])</code>的实现</p>
<pre><code>//polyfill安全的guard检查
if(!Promise.first){
    Promise.first = function(prs){
        //返回最终的Promise对象
        return new Promise(function(resolve,reject){
            //把所有的Promise循环一次
            prs.forEach(function(pr){
                //把值规整化，并且不管哪个先完成，就决议组Promise
                Promise.resolve(pr).then(resolve);
            })
        })
    }
}
</code></pre><p><strong>Promise的实际应用</strong></p>
<ol>
<li><p>异步加载图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>异步Ajax</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Promise着实避免了回调函数的一些缺陷，并且它的使用也越来越广泛，包括后面的async异步函数，也是利用Promise来完成的，因此，这里简单的了解一下Promise还是很有必要的。</p>
<h1 id="2021年1月18日补充"><a href="#2021年1月18日补充" class="headerlink" title="2021年1月18日补充"></a>2021年1月18日补充</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li><p>其在新建时就开始立即执行，一旦完成，其状态就会”凝固“。</p>
</li>
<li><p>“凝固”过后其状态就不会发生改变，并且与事件不同的是，其可以随之被监听，即：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;resolve(<span class="number">1</span>)&#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;res&#125;</span>--第一次获取`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;res&#125;</span>--第二次获取`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   第一个结果为：1—第一次获取</p>
<p>   第二个结果为：1—第二次获取</p>
<p>   <strong>注意</strong>：这两次执行都会在3秒过后执行，并且都会执行；这里区别于普通事件，一旦错过，就无法再监听到了。但是Promise在操作完成后会凝固状态，无论后面在什么时候进行监听（定义其then函数）都会被执行。</p>
<h2 id="以实现的接口"><a href="#以实现的接口" class="headerlink" title="以实现的接口"></a>以实现的接口</h2><ol>
<li><p><code>Promise.all([p1, p2, p3])</code>，其返回结果分为两种：</p>
<ol>
<li><p>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
</li>
<li><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p><strong>注意</strong>：注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><code>Promise.race([p1, p2, p3])</code>：上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态（无论是<code>fulfilled</code>还是<code>reject</code>），<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p>下面这个即利用这个特性完成请求超时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p><code>Promise.allSettled(p1, p2, p3)</code>：方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p>
<p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，<strong>Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: 'fulfilled', value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: 'rejected', reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p><code>Promise.any(p1, p2, p3)</code>：该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。（与all相反）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  fetch(<span class="string">'/endpoint-a'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'a'</span>),</span><br><span class="line">  fetch(<span class="string">'/endpoint-b'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'b'</span>),</span><br><span class="line">  fetch(<span class="string">'/endpoint-c'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'c'</span>),</span><br><span class="line">];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> <span class="built_in">Promise</span>.any(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(first);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>
<p>   捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any(promises).then(</span><br><span class="line">  (first) =&gt; &#123;</span><br><span class="line">    <span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    <span class="comment">// All of the promises were rejected.</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>   下面是一个例子。</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">var</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">var</span> alsoRejected = <span class="built_in">Promise</span>.reject(<span class="literal">Infinity</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any([resolved, rejected, alsoRejected]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any([rejected, alsoRejected]).catch(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results); <span class="comment">// [-1, Infinity]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p><code>Promise.resolve()</code>：有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>
<ol>
<li><p><strong>参数是一个 Promise 实例</strong></p>
<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
</li>
<li><p><strong>参数是一个<code>thenable</code>对象</strong></p>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p>
</li>
<li><p><strong>参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p>
<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p>
</li>
<li><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
</li>
</ol>
</li>
</ol>
<ol start="6">
<li><p><code>Promise.reject()</code>：会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === <span class="string">'出错了'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>
</li>
</ol>
<p>目前Chrome(87)中的以实现上述方法。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL关键字问题</title>
    <url>/2022/03/30/MySQL%E5%85%B3%E9%94%AE%E5%AD%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>因为之前排查一个sql错误，看了半天才发现是关键字占用，但是作为属性又没有提示，所以这里记录以下MySQL的所有关键字。</p>
<p>本来一般的排查方案是将sql复制到UI工具中查看，但是有些UI工具提示并不全（可能是版本问题），比如<code>groups</code>关键字，SQLyog就不会提示。导致一直没有排查出来。</p>
</blockquote>
<p>MySQL的关键分为占用或不占用。如果是占用的关键词，那么就不能直接使用。必须添加引号，注意这个引号是 <strong>`</strong> ,即英文状态下的波浪号。其他的引号是无法做到消除占用的，包括单引号和双引号。</p>
<p>如果是不占用的关键词，则可以直接使用，但不保证以后不会占用，所以最好还是避开这些关键字。</p>
<p>下文中包含（R）的，即为被占用的，使用时必须要加  <strong>`</strong>。</p>
<p>A</p>
<ul>
<li><code>ACCESSIBLE</code> (R)</li>
<li><code>ACCOUNT</code></li>
<li><code>ACTION</code></li>
<li><code>ACTIVE</code>; added in 8.0.14 (nonreserved)</li>
<li><code>ADD</code> (R)</li>
<li><code>ADMIN</code>; became nonreserved in 8.0.12</li>
<li><code>AFTER</code></li>
<li><code>AGAINST</code></li>
<li><code>AGGREGATE</code></li>
<li><code>ALGORITHM</code></li>
<li><code>ALL</code> (R)</li>
<li><code>ALTER</code> (R)</li>
<li><code>ALWAYS</code></li>
<li><code>ANALYSE</code>; removed in 8.0.1</li>
<li><code>ANALYZE</code> (R)</li>
<li><code>AND</code> (R)</li>
<li><code>ANY</code></li>
<li><code>ARRAY</code>; added in 8.0.17 (reserved); became nonreserved in 8.0.19</li>
<li><code>AS</code> (R)</li>
<li><code>ASC</code> (R)</li>
<li><code>ASCII</code></li>
<li><code>ASENSITIVE</code> (R)</li>
<li><code>AT</code></li>
<li><code>ATTRIBUTE</code>; added in 8.0.21 (nonreserved)</li>
<li><code>AUTHENTICATION</code>; added in 8.0.27 (nonreserved)</li>
<li><code>AUTOEXTEND_SIZE</code></li>
<li><code>AUTO_INCREMENT</code></li>
<li><code>AVG</code></li>
<li><code>AVG_ROW_LENGTH</code></li>
</ul>
<p>B</p>
<ul>
<li><code>BACKUP</code></li>
<li><code>BEFORE</code> (R)</li>
<li><code>BEGIN</code></li>
<li><code>BETWEEN</code> (R)</li>
<li><code>BIGINT</code> (R)</li>
<li><code>BINARY</code> (R)</li>
<li><code>BINLOG</code></li>
<li><code>BIT</code></li>
<li><code>BLOB</code> (R)</li>
<li><code>BLOCK</code></li>
<li><code>BOOL</code></li>
<li><code>BOOLEAN</code></li>
<li><code>BOTH</code> (R)</li>
<li><code>BTREE</code></li>
<li><code>BUCKETS</code>; added in 8.0.2 (nonreserved)</li>
<li><code>BY</code> (R)</li>
<li><code>BYTE</code></li>
</ul>
<p>C</p>
<ul>
<li><code>CACHE</code></li>
<li><code>CALL</code> (R)</li>
<li><code>CASCADE</code> (R)</li>
<li><code>CASCADED</code></li>
<li><code>CASE</code> (R)</li>
<li><code>CATALOG_NAME</code></li>
<li><code>CHAIN</code></li>
<li><code>CHALLENGE_RESPONSE</code>; added in 8.0.27 (nonreserved)</li>
<li><code>CHANGE</code> (R)</li>
<li><code>CHANGED</code></li>
<li><code>CHANNEL</code></li>
<li><code>CHAR</code> (R)</li>
<li><code>CHARACTER</code> (R)</li>
<li><code>CHARSET</code></li>
<li><code>CHECK</code> (R)</li>
<li><code>CHECKSUM</code></li>
<li><code>CIPHER</code></li>
<li><code>CLASS_ORIGIN</code></li>
<li><code>CLIENT</code></li>
<li><code>CLONE</code>; added in 8.0.3 (nonreserved)</li>
<li><code>CLOSE</code></li>
<li><code>COALESCE</code></li>
<li><code>CODE</code></li>
<li><code>COLLATE</code> (R)</li>
<li><code>COLLATION</code></li>
<li><code>COLUMN</code> (R)</li>
<li><code>COLUMNS</code></li>
<li><code>COLUMN_FORMAT</code></li>
<li><code>COLUMN_NAME</code></li>
<li><code>COMMENT</code></li>
<li><code>COMMIT</code></li>
<li><code>COMMITTED</code></li>
<li><code>COMPACT</code></li>
<li><code>COMPLETION</code></li>
<li><code>COMPONENT</code></li>
<li><code>COMPRESSED</code></li>
<li><code>COMPRESSION</code></li>
<li><code>CONCURRENT</code></li>
<li><code>CONDITION</code> (R)</li>
<li><code>CONNECTION</code></li>
<li><code>CONSISTENT</code></li>
<li><code>CONSTRAINT</code> (R)</li>
<li><code>CONSTRAINT_CATALOG</code></li>
<li><code>CONSTRAINT_NAME</code></li>
<li><code>CONSTRAINT_SCHEMA</code></li>
<li><code>CONTAINS</code></li>
<li><code>CONTEXT</code></li>
<li><code>CONTINUE</code> (R)</li>
<li><code>CONVERT</code> (R)</li>
<li><code>CPU</code></li>
<li><code>CREATE</code> (R)</li>
<li><code>CROSS</code> (R)</li>
<li><code>CUBE</code> (R); became reserved in 8.0.1</li>
<li><code>CUME_DIST</code> (R); added in 8.0.2 (reserved)</li>
<li><code>CURRENT</code></li>
<li><code>CURRENT_DATE</code> (R)</li>
<li><code>CURRENT_TIME</code> (R)</li>
<li><code>CURRENT_TIMESTAMP</code> (R)</li>
<li><code>CURRENT_USER</code> (R)</li>
<li><code>CURSOR</code> (R)</li>
<li><code>CURSOR_NAME</code></li>
</ul>
<p>D</p>
<ul>
<li><code>DATA</code></li>
<li><code>DATABASE</code> (R)</li>
<li><code>DATABASES</code> (R)</li>
<li><code>DATAFILE</code></li>
<li><code>DATE</code></li>
<li><code>DATETIME</code></li>
<li><code>DAY</code></li>
<li><code>DAY_HOUR</code> (R)</li>
<li><code>DAY_MICROSECOND</code> (R)</li>
<li><code>DAY_MINUTE</code> (R)</li>
<li><code>DAY_SECOND</code> (R)</li>
<li><code>DEALLOCATE</code></li>
<li><code>DEC</code> (R)</li>
<li><code>DECIMAL</code> (R)</li>
<li><code>DECLARE</code> (R)</li>
<li><code>DEFAULT</code> (R)</li>
<li><code>DEFAULT_AUTH</code></li>
<li><code>DEFINER</code></li>
<li><code>DEFINITION</code>; added in 8.0.4 (nonreserved)</li>
<li><code>DELAYED</code> (R)</li>
<li><code>DELAY_KEY_WRITE</code></li>
<li><code>DELETE</code> (R)</li>
<li><code>DENSE_RANK</code> (R); added in 8.0.2 (reserved)</li>
<li><code>DESC</code> (R)</li>
<li><code>DESCRIBE</code> (R)</li>
<li><code>DESCRIPTION</code>; added in 8.0.4 (nonreserved)</li>
<li><code>DES_KEY_FILE</code>; removed in 8.0.3</li>
<li><code>DETERMINISTIC</code> (R)</li>
<li><code>DIAGNOSTICS</code></li>
<li><code>DIRECTORY</code></li>
<li><code>DISABLE</code></li>
<li><code>DISCARD</code></li>
<li><code>DISK</code></li>
<li><code>DISTINCT</code> (R)</li>
<li><code>DISTINCTROW</code> (R)</li>
<li><code>DIV</code> (R)</li>
<li><code>DO</code></li>
<li><code>DOUBLE</code> (R)</li>
<li><code>DROP</code> (R)</li>
<li><code>DUAL</code> (R)</li>
<li><code>DUMPFILE</code></li>
<li><code>DUPLICATE</code></li>
<li><code>DYNAMIC</code></li>
</ul>
<p>E</p>
<ul>
<li><code>EACH</code> (R)</li>
<li><code>ELSE</code> (R)</li>
<li><code>ELSEIF</code> (R)</li>
<li><code>EMPTY</code> (R); added in 8.0.4 (reserved)</li>
<li><code>ENABLE</code></li>
<li><code>ENCLOSED</code> (R)</li>
<li><code>ENCRYPTION</code></li>
<li><code>END</code></li>
<li><code>ENDS</code></li>
<li><code>ENFORCED</code>; added in 8.0.16 (nonreserved)</li>
<li><code>ENGINE</code></li>
<li><code>ENGINES</code></li>
<li><code>ENGINE_ATTRIBUTE</code>; added in 8.0.21 (nonreserved)</li>
<li><code>ENUM</code></li>
<li><code>ERROR</code></li>
<li><code>ERRORS</code></li>
<li><code>ESCAPE</code></li>
<li><code>ESCAPED</code> (R)</li>
<li><code>EVENT</code></li>
<li><code>EVENTS</code></li>
<li><code>EVERY</code></li>
<li><code>EXCEPT</code> (R)</li>
<li><code>EXCHANGE</code></li>
<li><code>EXCLUDE</code>; added in 8.0.2 (nonreserved)</li>
<li><code>EXECUTE</code></li>
<li><code>EXISTS</code> (R)</li>
<li><code>EXIT</code> (R)</li>
<li><code>EXPANSION</code></li>
<li><code>EXPIRE</code></li>
<li><code>EXPLAIN</code> (R)</li>
<li><code>EXPORT</code></li>
<li><code>EXTENDED</code></li>
<li><code>EXTENT_SIZE</code></li>
</ul>
<p>F</p>
<ul>
<li><code>FACTOR</code>; added in 8.0.27 (nonreserved)</li>
<li><code>FAILED_LOGIN_ATTEMPTS</code>; added in 8.0.19 (nonreserved)</li>
<li><code>FALSE</code> (R)</li>
<li><code>FAST</code></li>
<li><code>FAULTS</code></li>
<li><code>FETCH</code> (R)</li>
<li><code>FIELDS</code></li>
<li><code>FILE</code></li>
<li><code>FILE_BLOCK_SIZE</code></li>
<li><code>FILTER</code></li>
<li><code>FINISH</code>; added in 8.0.27 (nonreserved)</li>
<li><code>FIRST</code></li>
<li><code>FIRST_VALUE</code> (R); added in 8.0.2 (reserved)</li>
<li><code>FIXED</code></li>
<li><code>FLOAT</code> (R)</li>
<li><code>FLOAT4</code> (R)</li>
<li><code>FLOAT8</code> (R)</li>
<li><code>FLUSH</code></li>
<li><code>FOLLOWING</code>; added in 8.0.2 (nonreserved)</li>
<li><code>FOLLOWS</code></li>
<li><code>FOR</code> (R)</li>
<li><code>FORCE</code> (R)</li>
<li><code>FOREIGN</code> (R)</li>
<li><code>FORMAT</code></li>
<li><code>FOUND</code></li>
<li><code>FROM</code> (R)</li>
<li><code>FULL</code></li>
<li><code>FULLTEXT</code> (R)</li>
<li><code>FUNCTION</code> (R); became reserved in 8.0.1</li>
</ul>
<p>G</p>
<ul>
<li><code>GENERAL</code></li>
<li><code>GENERATED</code> (R)</li>
<li><code>GEOMCOLLECTION</code>; added in 8.0.11 (nonreserved)</li>
<li><code>GEOMETRY</code></li>
<li><code>GEOMETRYCOLLECTION</code></li>
<li><code>GET</code> (R)</li>
<li><code>GET_FORMAT</code></li>
<li><code>GET_MASTER_PUBLIC_KEY</code>; added in 8.0.4 (reserved); became nonreserved in 8.0.11</li>
<li><code>GET_SOURCE_PUBLIC_KEY</code>; added in 8.0.23 (nonreserved)</li>
<li><code>GLOBAL</code></li>
<li><code>GRANT</code> (R)</li>
<li><code>GRANTS</code></li>
<li><code>GROUP</code> (R)</li>
<li><code>GROUPING</code> (R); added in 8.0.1 (reserved)</li>
<li><code>GROUPS</code> (R); added in 8.0.2 (reserved)</li>
<li><code>GROUP_REPLICATION</code></li>
<li><code>GTID_ONLY</code>; added in 8.0.27 (nonreserved)</li>
</ul>
<p>H</p>
<ul>
<li><code>HANDLER</code></li>
<li><code>HASH</code></li>
<li><code>HAVING</code> (R)</li>
<li><code>HELP</code></li>
<li><code>HIGH_PRIORITY</code> (R)</li>
<li><code>HISTOGRAM</code>; added in 8.0.2 (nonreserved)</li>
<li><code>HISTORY</code>; added in 8.0.3 (nonreserved)</li>
<li><code>HOST</code></li>
<li><code>HOSTS</code></li>
<li><code>HOUR</code></li>
<li><code>HOUR_MICROSECOND</code> (R)</li>
<li><code>HOUR_MINUTE</code> (R)</li>
<li><code>HOUR_SECOND</code> (R)</li>
</ul>
<p>I</p>
<ul>
<li><code>IDENTIFIED</code></li>
<li><code>IF</code> (R)</li>
<li><code>IGNORE</code> (R)</li>
<li><code>IGNORE_SERVER_IDS</code></li>
<li><code>IMPORT</code></li>
<li><code>IN</code> (R)</li>
<li><code>INACTIVE</code>; added in 8.0.14 (nonreserved)</li>
<li><code>INDEX</code> (R)</li>
<li><code>INDEXES</code></li>
<li><code>INFILE</code> (R)</li>
<li><code>INITIAL</code>; added in 8.0.27 (nonreserved)</li>
<li><code>INITIAL_SIZE</code></li>
<li><code>INITIATE</code>; added in 8.0.27 (nonreserved)</li>
<li><code>INNER</code> (R)</li>
<li><code>INOUT</code> (R)</li>
<li><code>INSENSITIVE</code> (R)</li>
<li><code>INSERT</code> (R)</li>
<li><code>INSERT_METHOD</code></li>
<li><code>INSTALL</code></li>
<li><code>INSTANCE</code></li>
<li><code>INT</code> (R)</li>
<li><code>INT1</code> (R)</li>
<li><code>INT2</code> (R)</li>
<li><code>INT3</code> (R)</li>
<li><code>INT4</code> (R)</li>
<li><code>INT8</code> (R)</li>
<li><code>INTEGER</code> (R)</li>
<li><code>INTERVAL</code> (R)</li>
<li><code>INTO</code> (R)</li>
<li><code>INVISIBLE</code></li>
<li><code>INVOKER</code></li>
<li><code>IO</code></li>
<li><code>IO_AFTER_GTIDS</code> (R)</li>
<li><code>IO_BEFORE_GTIDS</code> (R)</li>
<li><code>IO_THREAD</code></li>
<li><code>IPC</code></li>
<li><code>IS</code> (R)</li>
<li><code>ISOLATION</code></li>
<li><code>ISSUER</code></li>
<li><code>ITERATE</code> (R)</li>
</ul>
<p>J</p>
<ul>
<li><code>JOIN</code> (R)</li>
<li><code>JSON</code></li>
<li><code>JSON_TABLE</code> (R); added in 8.0.4 (reserved)</li>
<li><code>JSON_VALUE</code>; added in 8.0.21 (nonreserved)</li>
</ul>
<p>K</p>
<ul>
<li><code>KEY</code> (R)</li>
<li><code>KEYRING</code>; added in 8.0.24 (nonreserved)</li>
<li><code>KEYS</code> (R)</li>
<li><code>KEY_BLOCK_SIZE</code></li>
<li><code>KILL</code> (R)</li>
</ul>
<p>L</p>
<ul>
<li><code>LAG</code> (R); added in 8.0.2 (reserved)</li>
<li><code>LANGUAGE</code></li>
<li><code>LAST</code></li>
<li><code>LAST_VALUE</code> (R); added in 8.0.2 (reserved)</li>
<li><code>LATERAL</code> (R); added in 8.0.14 (reserved)</li>
<li><code>LEAD</code> (R); added in 8.0.2 (reserved)</li>
<li><code>LEADING</code> (R)</li>
<li><code>LEAVE</code> (R)</li>
<li><code>LEAVES</code></li>
<li><code>LEFT</code> (R)</li>
<li><code>LESS</code></li>
<li><code>LEVEL</code></li>
<li><code>LIKE</code> (R)</li>
<li><code>LIMIT</code> (R)</li>
<li><code>LINEAR</code> (R)</li>
<li><code>LINES</code> (R)</li>
<li><code>LINESTRING</code></li>
<li><code>LIST</code></li>
<li><code>LOAD</code> (R)</li>
<li><code>LOCAL</code></li>
<li><code>LOCALTIME</code> (R)</li>
<li><code>LOCALTIMESTAMP</code> (R)</li>
<li><code>LOCK</code> (R)</li>
<li><code>LOCKED</code>; added in 8.0.1 (nonreserved)</li>
<li><code>LOCKS</code></li>
<li><code>LOGFILE</code></li>
<li><code>LOGS</code></li>
<li><code>LONG</code> (R)</li>
<li><code>LONGBLOB</code> (R)</li>
<li><code>LONGTEXT</code> (R)</li>
<li><code>LOOP</code> (R)</li>
<li><code>LOW_PRIORITY</code> (R)</li>
</ul>
<p>M</p>
<ul>
<li><code>MASTER</code></li>
<li><code>MASTER_AUTO_POSITION</code></li>
<li><code>MASTER_BIND</code> (R)</li>
<li><code>MASTER_COMPRESSION_ALGORITHMS</code>; added in 8.0.18 (nonreserved)</li>
<li><code>MASTER_CONNECT_RETRY</code></li>
<li><code>MASTER_DELAY</code></li>
<li><code>MASTER_HEARTBEAT_PERIOD</code></li>
<li><code>MASTER_HOST</code></li>
<li><code>MASTER_LOG_FILE</code></li>
<li><code>MASTER_LOG_POS</code></li>
<li><code>MASTER_PASSWORD</code></li>
<li><code>MASTER_PORT</code></li>
<li><code>MASTER_PUBLIC_KEY_PATH</code>; added in 8.0.4 (nonreserved)</li>
<li><code>MASTER_RETRY_COUNT</code></li>
<li><code>MASTER_SERVER_ID</code>; removed in 8.0.23</li>
<li><code>MASTER_SSL</code></li>
<li><code>MASTER_SSL_CA</code></li>
<li><code>MASTER_SSL_CAPATH</code></li>
<li><code>MASTER_SSL_CERT</code></li>
<li><code>MASTER_SSL_CIPHER</code></li>
<li><code>MASTER_SSL_CRL</code></li>
<li><code>MASTER_SSL_CRLPATH</code></li>
<li><code>MASTER_SSL_KEY</code></li>
<li><code>MASTER_SSL_VERIFY_SERVER_CERT</code> (R)</li>
<li><code>MASTER_TLS_CIPHERSUITES</code>; added in 8.0.19 (nonreserved)</li>
<li><code>MASTER_TLS_VERSION</code></li>
<li><code>MASTER_USER</code></li>
<li><code>MASTER_ZSTD_COMPRESSION_LEVEL</code>; added in 8.0.18 (nonreserved)</li>
<li><code>MATCH</code> (R)</li>
<li><code>MAXVALUE</code> (R)</li>
<li><code>MAX_CONNECTIONS_PER_HOUR</code></li>
<li><code>MAX_QUERIES_PER_HOUR</code></li>
<li><code>MAX_ROWS</code></li>
<li><code>MAX_SIZE</code></li>
<li><code>MAX_UPDATES_PER_HOUR</code></li>
<li><code>MAX_USER_CONNECTIONS</code></li>
<li><code>MEDIUM</code></li>
<li><code>MEDIUMBLOB</code> (R)</li>
<li><code>MEDIUMINT</code> (R)</li>
<li><code>MEDIUMTEXT</code> (R)</li>
<li><code>MEMBER</code>; added in 8.0.17 (reserved); became nonreserved in 8.0.19</li>
<li><code>MEMORY</code></li>
<li><code>MERGE</code></li>
<li><code>MESSAGE_TEXT</code></li>
<li><code>MICROSECOND</code></li>
<li><code>MIDDLEINT</code> (R)</li>
<li><code>MIGRATE</code></li>
<li><code>MINUTE</code></li>
<li><code>MINUTE_MICROSECOND</code> (R)</li>
<li><code>MINUTE_SECOND</code> (R)</li>
<li><code>MIN_ROWS</code></li>
<li><code>MOD</code> (R)</li>
<li><code>MODE</code></li>
<li><code>MODIFIES</code> (R)</li>
<li><code>MODIFY</code></li>
<li><code>MONTH</code></li>
<li><code>MULTILINESTRING</code></li>
<li><code>MULTIPOINT</code></li>
<li><code>MULTIPOLYGON</code></li>
<li><code>MUTEX</code></li>
<li><code>MYSQL_ERRNO</code></li>
</ul>
<p>N</p>
<ul>
<li><code>NAME</code></li>
<li><code>NAMES</code></li>
<li><code>NATIONAL</code></li>
<li><code>NATURAL</code> (R)</li>
<li><code>NCHAR</code></li>
<li><code>NDB</code></li>
<li><code>NDBCLUSTER</code></li>
<li><code>NESTED</code>; added in 8.0.4 (nonreserved)</li>
<li><code>NETWORK_NAMESPACE</code>; added in 8.0.16 (nonreserved)</li>
<li><code>NEVER</code></li>
<li><code>NEW</code></li>
<li><code>NEXT</code></li>
<li><code>NO</code></li>
<li><code>NODEGROUP</code></li>
<li><code>NONE</code></li>
<li><code>NOT</code> (R)</li>
<li><code>NOWAIT</code>; added in 8.0.1 (nonreserved)</li>
<li><code>NO_WAIT</code></li>
<li><code>NO_WRITE_TO_BINLOG</code> (R)</li>
<li><code>NTH_VALUE</code> (R); added in 8.0.2 (reserved)</li>
<li><code>NTILE</code> (R); added in 8.0.2 (reserved)</li>
<li><code>NULL</code> (R)</li>
<li><code>NULLS</code>; added in 8.0.2 (nonreserved)</li>
<li><code>NUMBER</code></li>
<li><code>NUMERIC</code> (R)</li>
<li><code>NVARCHAR</code></li>
</ul>
<p>O</p>
<ul>
<li><code>OF</code> (R); added in 8.0.1 (reserved)</li>
<li><code>OFF</code>; added in 8.0.20 (nonreserved)</li>
<li><code>OFFSET</code></li>
<li><code>OJ</code>; added in 8.0.16 (nonreserved)</li>
<li><code>OLD</code>; added in 8.0.14 (nonreserved)</li>
<li><code>ON</code> (R)</li>
<li><code>ONE</code></li>
<li><code>ONLY</code></li>
<li><code>OPEN</code></li>
<li><code>OPTIMIZE</code> (R)</li>
<li><code>OPTIMIZER_COSTS</code> (R)</li>
<li><code>OPTION</code> (R)</li>
<li><code>OPTIONAL</code>; added in 8.0.13 (nonreserved)</li>
<li><code>OPTIONALLY</code> (R)</li>
<li><code>OPTIONS</code></li>
<li><code>OR</code> (R)</li>
<li><code>ORDER</code> (R)</li>
<li><code>ORDINALITY</code>; added in 8.0.4 (nonreserved)</li>
<li><code>ORGANIZATION</code>; added in 8.0.4 (nonreserved)</li>
<li><code>OTHERS</code>; added in 8.0.2 (nonreserved)</li>
<li><code>OUT</code> (R)</li>
<li><code>OUTER</code> (R)</li>
<li><code>OUTFILE</code> (R)</li>
<li><code>OVER</code> (R); added in 8.0.2 (reserved)</li>
<li><code>OWNER</code></li>
</ul>
<p>P</p>
<ul>
<li><code>PACK_KEYS</code></li>
<li><code>PAGE</code></li>
<li><code>PARSER</code></li>
<li><code>PARTIAL</code></li>
<li><code>PARTITION</code> (R)</li>
<li><code>PARTITIONING</code></li>
<li><code>PARTITIONS</code></li>
<li><code>PASSWORD</code></li>
<li><code>PASSWORD_LOCK_TIME</code>; added in 8.0.19 (nonreserved)</li>
<li><code>PATH</code>; added in 8.0.4 (nonreserved)</li>
<li><code>PERCENT_RANK</code> (R); added in 8.0.2 (reserved)</li>
<li><code>PERSIST</code>; became nonreserved in 8.0.16</li>
<li><code>PERSIST_ONLY</code>; added in 8.0.2 (reserved); became nonreserved in 8.0.16</li>
<li><code>PHASE</code></li>
<li><code>PLUGIN</code></li>
<li><code>PLUGINS</code></li>
<li><code>PLUGIN_DIR</code></li>
<li><code>POINT</code></li>
<li><code>POLYGON</code></li>
<li><code>PORT</code></li>
<li><code>PRECEDES</code></li>
<li><code>PRECEDING</code>; added in 8.0.2 (nonreserved)</li>
<li><code>PRECISION</code> (R)</li>
<li><code>PREPARE</code></li>
<li><code>PRESERVE</code></li>
<li><code>PREV</code></li>
<li><code>PRIMARY</code> (R)</li>
<li><code>PRIVILEGES</code></li>
<li><code>PRIVILEGE_CHECKS_USER</code>; added in 8.0.18 (nonreserved)</li>
<li><code>PROCEDURE</code> (R)</li>
<li><code>PROCESS</code>; added in 8.0.11 (nonreserved)</li>
<li><code>PROCESSLIST</code></li>
<li><code>PROFILE</code></li>
<li><code>PROFILES</code></li>
<li><code>PROXY</code></li>
<li><code>PURGE</code> (R)</li>
</ul>
<p>Q</p>
<ul>
<li><code>QUARTER</code></li>
<li><code>QUERY</code></li>
<li><code>QUICK</code></li>
</ul>
<p>R</p>
<ul>
<li><code>RANDOM</code>; added in 8.0.18 (nonreserved)</li>
<li><code>RANGE</code> (R)</li>
<li><code>RANK</code> (R); added in 8.0.2 (reserved)</li>
<li><code>READ</code> (R)</li>
<li><code>READS</code> (R)</li>
<li><code>READ_ONLY</code></li>
<li><code>READ_WRITE</code> (R)</li>
<li><code>REAL</code> (R)</li>
<li><code>REBUILD</code></li>
<li><code>RECOVER</code></li>
<li><code>RECURSIVE</code> (R); added in 8.0.1 (reserved)</li>
<li><code>REDOFILE</code>; removed in 8.0.3</li>
<li><code>REDO_BUFFER_SIZE</code></li>
<li><code>REDUNDANT</code></li>
<li><code>REFERENCE</code>; added in 8.0.4 (nonreserved)</li>
<li><code>REFERENCES</code> (R)</li>
<li><code>REGEXP</code> (R)</li>
<li><code>REGISTRATION</code>; added in 8.0.27 (nonreserved)</li>
<li><code>RELAY</code></li>
<li><code>RELAYLOG</code></li>
<li><code>RELAY_LOG_FILE</code></li>
<li><code>RELAY_LOG_POS</code></li>
<li><code>RELAY_THREAD</code></li>
<li><code>RELEASE</code> (R)</li>
<li><code>RELOAD</code></li>
<li><code>REMOTE</code>; added in 8.0.3 (nonreserved); removed in 8.0.14</li>
<li><code>REMOVE</code></li>
<li><code>RENAME</code> (R)</li>
<li><code>REORGANIZE</code></li>
<li><code>REPAIR</code></li>
<li><code>REPEAT</code> (R)</li>
<li><code>REPEATABLE</code></li>
<li><code>REPLACE</code> (R)</li>
<li><code>REPLICA</code>; added in 8.0.22 (nonreserved)</li>
<li><code>REPLICAS</code>; added in 8.0.22 (nonreserved)</li>
<li><code>REPLICATE_DO_DB</code></li>
<li><code>REPLICATE_DO_TABLE</code></li>
<li><code>REPLICATE_IGNORE_DB</code></li>
<li><code>REPLICATE_IGNORE_TABLE</code></li>
<li><code>REPLICATE_REWRITE_DB</code></li>
<li><code>REPLICATE_WILD_DO_TABLE</code></li>
<li><code>REPLICATE_WILD_IGNORE_TABLE</code></li>
<li><code>REPLICATION</code></li>
<li><code>REQUIRE</code> (R)</li>
<li><code>REQUIRE_ROW_FORMAT</code>; added in 8.0.19 (nonreserved)</li>
<li><code>RESET</code></li>
<li><code>RESIGNAL</code> (R)</li>
<li><code>RESOURCE</code>; added in 8.0.3 (nonreserved)</li>
<li><code>RESPECT</code>; added in 8.0.2 (nonreserved)</li>
<li><code>RESTART</code>; added in 8.0.4 (nonreserved)</li>
<li><code>RESTORE</code></li>
<li><code>RESTRICT</code> (R)</li>
<li><code>RESUME</code></li>
<li><code>RETAIN</code>; added in 8.0.14 (nonreserved)</li>
<li><code>RETURN</code> (R)</li>
<li><code>RETURNED_SQLSTATE</code></li>
<li><code>RETURNING</code>; added in 8.0.21 (nonreserved)</li>
<li><code>RETURNS</code></li>
<li><code>REUSE</code>; added in 8.0.3 (nonreserved)</li>
<li><code>REVERSE</code></li>
<li><code>REVOKE</code> (R)</li>
<li><code>RIGHT</code> (R)</li>
<li><code>RLIKE</code> (R)</li>
<li><code>ROLE</code>; became nonreserved in 8.0.1</li>
<li><code>ROLLBACK</code></li>
<li><code>ROLLUP</code></li>
<li><code>ROTATE</code></li>
<li><code>ROUTINE</code></li>
<li><code>ROW</code> (R); became reserved in 8.0.2</li>
<li><code>ROWS</code> (R); became reserved in 8.0.2</li>
<li><code>ROW_COUNT</code></li>
<li><code>ROW_FORMAT</code></li>
<li><code>ROW_NUMBER</code> (R); added in 8.0.2 (reserved)</li>
<li><code>RTREE</code></li>
</ul>
<p>S</p>
<ul>
<li><code>SAVEPOINT</code></li>
<li><code>SCHEDULE</code></li>
<li><code>SCHEMA</code> (R)</li>
<li><code>SCHEMAS</code> (R)</li>
<li><code>SCHEMA_NAME</code></li>
<li><code>SECOND</code></li>
<li><code>SECONDARY</code>; added in 8.0.16 (nonreserved)</li>
<li><code>SECONDARY_ENGINE</code>; added in 8.0.13 (nonreserved)</li>
<li><code>SECONDARY_ENGINE_ATTRIBUTE</code>; added in 8.0.21 (nonreserved)</li>
<li><code>SECONDARY_LOAD</code>; added in 8.0.13 (nonreserved)</li>
<li><code>SECONDARY_UNLOAD</code>; added in 8.0.13 (nonreserved)</li>
<li><code>SECOND_MICROSECOND</code> (R)</li>
<li><code>SECURITY</code></li>
<li><code>SELECT</code> (R)</li>
<li><code>SENSITIVE</code> (R)</li>
<li><code>SEPARATOR</code> (R)</li>
<li><code>SERIAL</code></li>
<li><code>SERIALIZABLE</code></li>
<li><code>SERVER</code></li>
<li><code>SESSION</code></li>
<li><code>SET</code> (R)</li>
<li><code>SHARE</code></li>
<li><code>SHOW</code> (R)</li>
<li><code>SHUTDOWN</code></li>
<li><code>SIGNAL</code> (R)</li>
<li><code>SIGNED</code></li>
<li><code>SIMPLE</code></li>
<li><code>SKIP</code>; added in 8.0.1 (nonreserved)</li>
<li><code>SLAVE</code></li>
<li><code>SLOW</code></li>
<li><code>SMALLINT</code> (R)</li>
<li><code>SNAPSHOT</code></li>
<li><code>SOCKET</code></li>
<li><code>SOME</code></li>
<li><code>SONAME</code></li>
<li><code>SOUNDS</code></li>
<li><code>SOURCE</code></li>
<li><code>SOURCE_AUTO_POSITION</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_BIND</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_COMPRESSION_ALGORITHMS</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_CONNECT_RETRY</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_DELAY</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_HEARTBEAT_PERIOD</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_HOST</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_LOG_FILE</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_LOG_POS</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_PASSWORD</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_PORT</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_PUBLIC_KEY_PATH</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_RETRY_COUNT</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_SSL</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_SSL_CA</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_SSL_CAPATH</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_SSL_CERT</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_SSL_CIPHER</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_SSL_CRL</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_SSL_CRLPATH</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_SSL_KEY</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_SSL_VERIFY_SERVER_CERT</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_TLS_CIPHERSUITES</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_TLS_VERSION</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_USER</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SOURCE_ZSTD_COMPRESSION_LEVEL</code>; added in 8.0.23 (nonreserved)</li>
<li><code>SPATIAL</code> (R)</li>
<li><code>SPECIFIC</code> (R)</li>
<li><code>SQL</code> (R)</li>
<li><code>SQLEXCEPTION</code> (R)</li>
<li><code>SQLSTATE</code> (R)</li>
<li><code>SQLWARNING</code> (R)</li>
<li><code>SQL_AFTER_GTIDS</code></li>
<li><code>SQL_AFTER_MTS_GAPS</code></li>
<li><code>SQL_BEFORE_GTIDS</code></li>
<li><code>SQL_BIG_RESULT</code> (R)</li>
<li><code>SQL_BUFFER_RESULT</code></li>
<li><code>SQL_CACHE</code>; removed in 8.0.3</li>
<li><code>SQL_CALC_FOUND_ROWS</code> (R)</li>
<li><code>SQL_NO_CACHE</code></li>
<li><code>SQL_SMALL_RESULT</code> (R)</li>
<li><code>SQL_THREAD</code></li>
<li><code>SQL_TSI_DAY</code></li>
<li><code>SQL_TSI_HOUR</code></li>
<li><code>SQL_TSI_MINUTE</code></li>
<li><code>SQL_TSI_MONTH</code></li>
<li><code>SQL_TSI_QUARTER</code></li>
<li><code>SQL_TSI_SECOND</code></li>
<li><code>SQL_TSI_WEEK</code></li>
<li><code>SQL_TSI_YEAR</code></li>
<li><code>SRID</code>; added in 8.0.3 (nonreserved)</li>
<li><code>SSL</code> (R)</li>
<li><code>STACKED</code></li>
<li><code>START</code></li>
<li><code>STARTING</code> (R)</li>
<li><code>STARTS</code></li>
<li><code>STATS_AUTO_RECALC</code></li>
<li><code>STATS_PERSISTENT</code></li>
<li><code>STATS_SAMPLE_PAGES</code></li>
<li><code>STATUS</code></li>
<li><code>STOP</code></li>
<li><code>STORAGE</code></li>
<li><code>STORED</code> (R)</li>
<li><code>STRAIGHT_JOIN</code> (R)</li>
<li><code>STREAM</code>; added in 8.0.20 (nonreserved)</li>
<li><code>STRING</code></li>
<li><code>SUBCLASS_ORIGIN</code></li>
<li><code>SUBJECT</code></li>
<li><code>SUBPARTITION</code></li>
<li><code>SUBPARTITIONS</code></li>
<li><code>SUPER</code></li>
<li><code>SUSPEND</code></li>
<li><code>SWAPS</code></li>
<li><code>SWITCHES</code></li>
<li><code>SYSTEM</code> (R); added in 8.0.3 (reserved)</li>
</ul>
<p>T</p>
<ul>
<li><code>TABLE</code> (R)</li>
<li><code>TABLES</code></li>
<li><code>TABLESPACE</code></li>
<li><code>TABLE_CHECKSUM</code></li>
<li><code>TABLE_NAME</code></li>
<li><code>TEMPORARY</code></li>
<li><code>TEMPTABLE</code></li>
<li><code>TERMINATED</code> (R)</li>
<li><code>TEXT</code></li>
<li><code>THAN</code></li>
<li><code>THEN</code> (R)</li>
<li><code>THREAD_PRIORITY</code>; added in 8.0.3 (nonreserved)</li>
<li><code>TIES</code>; added in 8.0.2 (nonreserved)</li>
<li><code>TIME</code></li>
<li><code>TIMESTAMP</code></li>
<li><code>TIMESTAMPADD</code></li>
<li><code>TIMESTAMPDIFF</code></li>
<li><code>TINYBLOB</code> (R)</li>
<li><code>TINYINT</code> (R)</li>
<li><code>TINYTEXT</code> (R)</li>
<li><code>TLS</code>; added in 8.0.21 (nonreserved)</li>
<li><code>TO</code> (R)</li>
<li><code>TRAILING</code> (R)</li>
<li><code>TRANSACTION</code></li>
<li><code>TRIGGER</code> (R)</li>
<li><code>TRIGGERS</code></li>
<li><code>TRUE</code> (R)</li>
<li><code>TRUNCATE</code></li>
<li><code>TYPE</code></li>
<li><code>TYPES</code></li>
</ul>
<p>U</p>
<ul>
<li><code>UNBOUNDED</code>; added in 8.0.2 (nonreserved)</li>
<li><code>UNCOMMITTED</code></li>
<li><code>UNDEFINED</code></li>
<li><code>UNDO</code> (R)</li>
<li><code>UNDOFILE</code></li>
<li><code>UNDO_BUFFER_SIZE</code></li>
<li><code>UNICODE</code></li>
<li><code>UNINSTALL</code></li>
<li><code>UNION</code> (R)</li>
<li><code>UNIQUE</code> (R)</li>
<li><code>UNKNOWN</code></li>
<li><code>UNLOCK</code> (R)</li>
<li><code>UNREGISTER</code>; added in 8.0.27 (nonreserved)</li>
<li><code>UNSIGNED</code> (R)</li>
<li><code>UNTIL</code></li>
<li><code>UPDATE</code> (R)</li>
<li><code>UPGRADE</code></li>
<li><code>USAGE</code> (R)</li>
<li><code>USE</code> (R)</li>
<li><code>USER</code></li>
<li><code>USER_RESOURCES</code></li>
<li><code>USE_FRM</code></li>
<li><code>USING</code> (R)</li>
<li><code>UTC_DATE</code> (R)</li>
<li><code>UTC_TIME</code> (R)</li>
<li><code>UTC_TIMESTAMP</code> (R)</li>
</ul>
<p>V</p>
<ul>
<li><code>VALIDATION</code></li>
<li><code>VALUE</code></li>
<li><code>VALUES</code> (R)</li>
<li><code>VARBINARY</code> (R)</li>
<li><code>VARCHAR</code> (R)</li>
<li><code>VARCHARACTER</code> (R)</li>
<li><code>VARIABLES</code></li>
<li><code>VARYING</code> (R)</li>
<li><code>VCPU</code>; added in 8.0.3 (nonreserved)</li>
<li><code>VIEW</code></li>
<li><code>VIRTUAL</code> (R)</li>
<li><code>VISIBLE</code></li>
</ul>
<p>W</p>
<ul>
<li><code>WAIT</code></li>
<li><code>WARNINGS</code></li>
<li><code>WEEK</code></li>
<li><code>WEIGHT_STRING</code></li>
<li><code>WHEN</code> (R)</li>
<li><code>WHERE</code> (R)</li>
<li><code>WHILE</code> (R)</li>
<li><code>WINDOW</code> (R); added in 8.0.2 (reserved)</li>
<li><code>WITH</code> (R)</li>
<li><code>WITHOUT</code></li>
<li><code>WORK</code></li>
<li><code>WRAPPER</code></li>
<li><code>WRITE</code> (R)</li>
</ul>
<p>X</p>
<ul>
<li><code>X509</code></li>
<li><code>XA</code></li>
<li><code>XID</code></li>
<li><code>XML</code></li>
<li><code>XOR</code> (R)</li>
</ul>
<p>Y</p>
<ul>
<li><code>YEAR</code></li>
<li><code>YEAR_MONTH</code> (R)</li>
</ul>
<p>Z</p>
<ul>
<li><code>ZEROFILL</code> (R)</li>
<li><code>ZONE</code>; added in 8.0.22 (nonreserved)</li>
</ul>
<h3 id="MySQL-8-0-New-Keywords-and-Reserved-Words"><a href="#MySQL-8-0-New-Keywords-and-Reserved-Words" class="headerlink" title="MySQL 8.0 New Keywords and Reserved Words"></a>MySQL 8.0 New Keywords and Reserved Words</h3><p>The following list shows the keywords and reserved words that are added in MySQL 8.0, compared to MySQL 5.7. Reserved keywords are marked with (R).</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-A" target="_blank" rel="noopener">A</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-B" target="_blank" rel="noopener">B</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-C" target="_blank" rel="noopener">C</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-D" target="_blank" rel="noopener">D</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-E" target="_blank" rel="noopener">E</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-F" target="_blank" rel="noopener">F</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-G" target="_blank" rel="noopener">G</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-H" target="_blank" rel="noopener">H</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-I" target="_blank" rel="noopener">I</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-J" target="_blank" rel="noopener">J</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-K" target="_blank" rel="noopener">K</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-L" target="_blank" rel="noopener">L</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-M" target="_blank" rel="noopener">M</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-N" target="_blank" rel="noopener">N</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-O" target="_blank" rel="noopener">O</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-P" target="_blank" rel="noopener">P</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-R" target="_blank" rel="noopener">R</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-S" target="_blank" rel="noopener">S</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-T" target="_blank" rel="noopener">T</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-U" target="_blank" rel="noopener">U</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-V" target="_blank" rel="noopener">V</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-W" target="_blank" rel="noopener">W</a> | <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-new-8-0-Z" target="_blank" rel="noopener">Z</a></p>
<p>A</p>
<ul>
<li><code>ACTIVE</code></li>
<li><code>ADMIN</code></li>
<li><code>ARRAY</code></li>
<li><code>ATTRIBUTE</code></li>
<li><code>AUTHENTICATION</code></li>
</ul>
<p>B</p>
<ul>
<li><code>BUCKETS</code></li>
</ul>
<p>C</p>
<ul>
<li><code>CHALLENGE_RESPONSE</code></li>
<li><code>CLONE</code></li>
<li><code>COMPONENT</code></li>
<li><code>CUME_DIST</code> (R)</li>
</ul>
<p>D</p>
<ul>
<li><code>DEFINITION</code></li>
<li><code>DENSE_RANK</code> (R)</li>
<li><code>DESCRIPTION</code></li>
</ul>
<p>E</p>
<ul>
<li><code>EMPTY</code> (R)</li>
<li><code>ENFORCED</code></li>
<li><code>ENGINE_ATTRIBUTE</code></li>
<li><code>EXCEPT</code> (R)</li>
<li><code>EXCLUDE</code></li>
</ul>
<p>F</p>
<ul>
<li><code>FACTOR</code></li>
<li><code>FAILED_LOGIN_ATTEMPTS</code></li>
<li><code>FINISH</code></li>
<li><code>FIRST_VALUE</code> (R)</li>
<li><code>FOLLOWING</code></li>
</ul>
<p>G</p>
<ul>
<li><code>GEOMCOLLECTION</code></li>
<li><code>GET_MASTER_PUBLIC_KEY</code></li>
<li><code>GET_SOURCE_PUBLIC_KEY</code></li>
<li><code>GROUPING</code> (R)</li>
<li><code>GROUPS</code> (R)</li>
<li><code>GTID_ONLY</code></li>
</ul>
<p>H</p>
<ul>
<li><code>HISTOGRAM</code></li>
<li><code>HISTORY</code></li>
</ul>
<p>I</p>
<ul>
<li><code>INACTIVE</code></li>
<li><code>INITIAL</code></li>
<li><code>INITIATE</code></li>
<li><code>INVISIBLE</code></li>
</ul>
<p>J</p>
<ul>
<li><code>JSON_TABLE</code> (R)</li>
<li><code>JSON_VALUE</code></li>
</ul>
<p>K</p>
<ul>
<li><code>KEYRING</code></li>
</ul>
<p>L</p>
<ul>
<li><code>LAG</code> (R)</li>
<li><code>LAST_VALUE</code> (R)</li>
<li><code>LATERAL</code> (R)</li>
<li><code>LEAD</code> (R)</li>
<li><code>LOCKED</code></li>
</ul>
<p>M</p>
<ul>
<li><code>MASTER_COMPRESSION_ALGORITHMS</code></li>
<li><code>MASTER_PUBLIC_KEY_PATH</code></li>
<li><code>MASTER_TLS_CIPHERSUITES</code></li>
<li><code>MASTER_ZSTD_COMPRESSION_LEVEL</code></li>
<li><code>MEMBER</code></li>
</ul>
<p>N</p>
<ul>
<li><code>NESTED</code></li>
<li><code>NETWORK_NAMESPACE</code></li>
<li><code>NOWAIT</code></li>
<li><code>NTH_VALUE</code> (R)</li>
<li><code>NTILE</code> (R)</li>
<li><code>NULLS</code></li>
</ul>
<p>O</p>
<ul>
<li><code>OF</code> (R)</li>
<li><code>OFF</code></li>
<li><code>OJ</code></li>
<li><code>OLD</code></li>
<li><code>OPTIONAL</code></li>
<li><code>ORDINALITY</code></li>
<li><code>ORGANIZATION</code></li>
<li><code>OTHERS</code></li>
<li><code>OVER</code> (R)</li>
</ul>
<p>P</p>
<ul>
<li><code>PASSWORD_LOCK_TIME</code></li>
<li><code>PATH</code></li>
<li><code>PERCENT_RANK</code> (R)</li>
<li><code>PERSIST</code></li>
<li><code>PERSIST_ONLY</code></li>
<li><code>PRECEDING</code></li>
<li><code>PRIVILEGE_CHECKS_USER</code></li>
<li><code>PROCESS</code></li>
</ul>
<p>R</p>
<ul>
<li><code>RANDOM</code></li>
<li><code>RANK</code> (R)</li>
<li><code>RECURSIVE</code> (R)</li>
<li><code>REFERENCE</code></li>
<li><code>REGISTRATION</code></li>
<li><code>REPLICA</code></li>
<li><code>REPLICAS</code></li>
<li><code>REQUIRE_ROW_FORMAT</code></li>
<li><code>RESOURCE</code></li>
<li><code>RESPECT</code></li>
<li><code>RESTART</code></li>
<li><code>RETAIN</code></li>
<li><code>RETURNING</code></li>
<li><code>REUSE</code></li>
<li><code>ROLE</code></li>
<li><code>ROW_NUMBER</code> (R)</li>
</ul>
<p>S</p>
<ul>
<li><code>SECONDARY</code></li>
<li><code>SECONDARY_ENGINE</code></li>
<li><code>SECONDARY_ENGINE_ATTRIBUTE</code></li>
<li><code>SECONDARY_LOAD</code></li>
<li><code>SECONDARY_UNLOAD</code></li>
<li><code>SKIP</code></li>
<li><code>SOURCE_AUTO_POSITION</code></li>
<li><code>SOURCE_BIND</code></li>
<li><code>SOURCE_COMPRESSION_ALGORITHMS</code></li>
<li><code>SOURCE_CONNECT_RETRY</code></li>
<li><code>SOURCE_DELAY</code></li>
<li><code>SOURCE_HEARTBEAT_PERIOD</code></li>
<li><code>SOURCE_HOST</code></li>
<li><code>SOURCE_LOG_FILE</code></li>
<li><code>SOURCE_LOG_POS</code></li>
<li><code>SOURCE_PASSWORD</code></li>
<li><code>SOURCE_PORT</code></li>
<li><code>SOURCE_PUBLIC_KEY_PATH</code></li>
<li><code>SOURCE_RETRY_COUNT</code></li>
<li><code>SOURCE_SSL</code></li>
<li><code>SOURCE_SSL_CA</code></li>
<li><code>SOURCE_SSL_CAPATH</code></li>
<li><code>SOURCE_SSL_CERT</code></li>
<li><code>SOURCE_SSL_CIPHER</code></li>
<li><code>SOURCE_SSL_CRL</code></li>
<li><code>SOURCE_SSL_CRLPATH</code></li>
<li><code>SOURCE_SSL_KEY</code></li>
<li><code>SOURCE_SSL_VERIFY_SERVER_CERT</code></li>
<li><code>SOURCE_TLS_CIPHERSUITES</code></li>
<li><code>SOURCE_TLS_VERSION</code></li>
<li><code>SOURCE_USER</code></li>
<li><code>SOURCE_ZSTD_COMPRESSION_LEVEL</code></li>
<li><code>SRID</code></li>
<li><code>STREAM</code></li>
<li><code>SYSTEM</code> (R)</li>
</ul>
<p>T</p>
<ul>
<li><code>THREAD_PRIORITY</code></li>
<li><code>TIES</code></li>
<li><code>TLS</code></li>
</ul>
<p>U</p>
<ul>
<li><code>UNBOUNDED</code></li>
<li><code>UNREGISTER</code></li>
</ul>
<p>V</p>
<ul>
<li><code>VCPU</code></li>
<li><code>VISIBLE</code></li>
</ul>
<p>W</p>
<ul>
<li><code>WINDOW</code> (R)</li>
</ul>
<p>Z</p>
<ul>
<li><code>ZONE</code></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3_CGI编程踩坑日记</title>
    <url>/2019/01/14/Python3-CGI%E7%BC%96%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Hard-start"><a href="#Hard-start" class="headerlink" title="Hard-start"></a>Hard-start</h1><p>这是学习Python的第六天，也是进入Python高级编程的第一天，嗯，对，然后我就遇见了Big Problem，甚至到现在都还有一个问题没有解决。</p>
<a id="more"></a>
<h1 id="Problem-I-met"><a href="#Problem-I-met" class="headerlink" title="Problem I met"></a>Problem I met</h1><ol>
<li>Apache的安装问题</li>
</ol>
<p>在得之要使用Apache之后，我直接就百度Apache，然后再官网首页</p>
<p><img src="\images\Python_CGI编程踩坑日记\1.png" alt="官网1"></p>
<p>结果下载下来直接用不了，解压了发现文件不对。然后一搜教程才发现文件下载错了。</p>
<p>应该在这里下载：</p>
<p><img src="\images\Python_CGI编程踩坑日记\1.png" alt="官网2"></p>
<p>终于完成填了第一个坑！</p>
<ol start="2">
<li>Apache配置问题</li>
</ol>
<p>要启用CGI，必需修改配置文件。而这个配置不仅仅是是一个地方，是n个地方：</p>
<ol>
<li>ServerRoot配置</li>
</ol>
<p>ServerRoot “” 主要用于指定Apache的安装路径，此选项参数值在安装Apache时系统会自动把Apache的路径写入。Windows安装时，该选项的值为Windows安装的路径，Linux安装时该选项值为编译时选择的路径</p>
<p>找到：</p>
<pre><code>Define SRVROOT &quot;${SRVROOT}&quot;
ServerRoot &quot;${SRVROOT}4&quot;
</code></pre><p>改为：</p>
<pre><code>Define SRVROOT &quot;D:\web\Apache24&quot;
ServerRoot &quot;D:\web\Apache24&quot;
</code></pre><p>其中”${SRVROOT}”应改为你你安装Apache的目录。</p>
<ol start="2">
<li>Listen 配置</li>
</ol>
<p>Listen主要侦听web服务端口状态，默认为：80，即侦听所有的地址的80端口，注意这里也可以写成IP地址的侦听形式，不写即默认的地址：0.0.0.0</p>
<p>找到：</p>
<pre><code>Listen:80
</code></pre><p>改为：<br>    Listen:8080</p>
<p>一般不为80，因为容易占用，改为其他好一点。比如我改为8080。</p>
<ol start="3">
<li>CGI配置</li>
</ol>
<p>找到：</p>
<pre><code>AddHandler cgi-script .cgi .pl 
</code></pre><p>改为：</p>
<pre><code>AddHandler cgi-script .cgi .pl .py
</code></pre><p>这里是增加对Python的支持。</p>
<p>找到：</p>
<pre><code>&lt;Directory &quot;/${SRVROOT}&quot;&gt;
    AllowOverride none
    Require all denied
&lt;/Directory&gt;
</code></pre><p>改为：</p>
<pre><code>&lt;Directory &quot;D:\web\Apache24\cgi-bin&quot;&gt;
    AllowOverride None
    Options Indexes FollowSymLinks ExecCGI
    Require all granted 
    Require host ip
&lt;/Directory&gt;
</code></pre><p>注意这里/${SRVROOT}任然还是Apache的安装地址。</p>
<ol start="3">
<li>Python解释器</li>
</ol>
<p>我就这么按照runoob上代码粘贴下来，like this：</p>
<pre><code>#!/usr/bin/python3

print (&quot;Content-type:text/html&quot;)
print ()                             # 空行，告诉服务器结束头部
print (&apos;&lt;html&gt;&apos;)
print (&apos;&lt;head&gt;&apos;)
print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;)
print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;)
print (&apos;&lt;/head&gt;&apos;)
print (&apos;&lt;body&gt;&apos;)
print (&apos;&lt;h2&gt;Hello Word! 我是来自菜鸟教程的第一CGI程序&lt;/h2&gt;&apos;)
print (&apos;&lt;/body&gt;&apos;)
print (&apos;&lt;/html&gt;&apos;)
</code></pre><p>然后就出现了500错误，下面是log里的提示：</p>
<pre><code>[Mon Jan 14 11:31:58.626473 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。  : [client ::1:52212] couldn&apos;t create child process: 720002: hello.py

[Mon Jan 14 11:31:58.660452 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。  : [client ::1:52212] AH01223: couldn&apos;t spawn child process: D:/web/Apache24/cgi-bin/hello.py
</code></pre><p>百度了半天，突然想起Apache如何载入编译器呢，然后直接百度上面代码的第一行：</p>
<pre><code>#!/usr/bin/python3
</code></pre><p>然后才知道这是Linux下Python的解释器位置，我枯了。然后我找到了自己Python3的安装位置，却发现没有exe文件，我又枯了。但是用sys自己的命令：</p>
<pre><code>import sys
sys.path
</code></pre><p>得到了就是这个位置。不管了，直接写吧！<br>于是得到了这一段代码：</p>
<pre><code>#!D:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python37\\python.exe
</code></pre><p>没错，就是这么长，不知道自己当时怎么安装的。我又枯了。</p>
<p>结果成功解析了！！！</p>
<p><strong>但是！！！</strong></p>
<p>又乱码了，检查了py文件的编码，发现py默认是utf-8啊。然后终于在网上找到了解决办法。没错，是print()函数的问题。</p>
<p>又大佬看print()源码使用<strong>Unicode</strong>，果然乱码了，然后引入了这一段代码：</p>
<pre><code>import io
sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;)
</code></pre><p>即：将print()函数改为<strong>utf-8</strong>编码输出，终于留了一张图：</p>
<p><img src="\images\Python_CGI编程踩坑日记\3.png" alt="正常输出"></p>
<p>附上正常获取text，textarea的代码，其他的都一样。</p>
<p>(text.html):</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/cgi-bin/text.py&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt;
&lt;input tyep = &apos;text&apos; name = &apos;name&apos;/&gt;
&lt;textarea name=&quot;personinform&quot;&gt;个人信息&lt;/textarea&gt;
&lt;input type=&apos;submit&apos; value=&apos;提交&apos;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>(text.py):</p>
<pre><code>#!D:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python37\\python.exe
import io
import sys
import cgi, cgitb
sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;)
form = cgi.FieldStorage()
name = form.getvalue(&apos;name&apos;)
personinform= form.getvalue(&apos;personinform&apos;)
print (&quot;Content-type:text/html&quot;)
print ()                             # 空行，告诉服务器结束头部
print (&apos;&lt;html&gt;&apos;)
print (&apos;&lt;head&gt;&apos;)
print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;)
print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;)
print (&apos;&lt;/head&gt;&apos;)
print (&apos;&lt;body&gt;&apos;)
print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;)
print(name)
print(personinform)
print (&apos;&lt;/body&gt;&apos;)
print (&apos;&lt;/html&gt;&apos;)
</code></pre><p>下面是get从url来获取键值的方法：</p>
<pre><code>#!D:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python37\\python.exe
import io
import sys
import cgi, cgitb
sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;)
form = cgi.FieldStorage()
name = form.getvalue(&apos;name&apos;)
number = form.getvalue(&apos;number&apos;)
print (&quot;Content-type:text/html&quot;)
print ()                             # 空行，告诉服务器结束头部
print (&apos;&lt;html&gt;&apos;)
print (&apos;&lt;head&gt;&apos;)
print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;)
print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;)
print (&apos;&lt;/head&gt;&apos;)
print (&apos;&lt;body&gt;&apos;)
print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;)
print(name,number)
print (&apos;&lt;/body&gt;&apos;)
print (&apos;&lt;/html&gt;&apos;)
</code></pre><p><img src="\images\Python_CGI编程踩坑日记\4.png" alt="get方法图片"></p>
<ul>
<li>last problem(unsolved)</li>
</ul>
<p>最后一个问题就是CGI的文件上传问题。由上面的代码可以知道，所有接受的数据都来自：</p>
<pre><code>cgi.FieldStorage()
</code></pre><p>网上的教程都这么获得数据：</p>
<pre><code>import cgi, os
import cgitb; cgitb.enable()

form = cgi.FieldStorage()

# 获取文件名
fileitem = form[&apos;filename&apos;]

# 检测文件是否上传
if fileitem.filename:
# 设置文件路径 
fn = os.path.basename(fileitem.filename)
open(&apos;/tmp/&apos; + fn,   &apos;wb&apos;).write(fileitem.file.read())

message = &apos;文件 &quot;&apos; + fn + &apos;&quot; 上传成功&apos;

else:
    message = &apos;文件没有上传&apos;
</code></pre><p>但是问题在于，</p>
<pre><code>fileitem.filename == none
</code></pre><p>我直接输出 fielitem</p>
<pre><code>fileitem = MiniFielStorage(&apos;filename&apos;,&apos;test.txt&apos;)
#test.txt为上传的文件名
</code></pre><p>所以fileitem.filename始终为none。所以一直解决不了，查了各种资料，不过官方文档里有类似的解释，但是还是没有解决办法。明天再看吧~~~难受啊，马飞~</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CGI</tag>
      </tags>
  </entry>
  <entry>
    <title>Run Latent Diffusion Model-1-make it work first</title>
    <url>/2024/07/30/Run-Latent-Diffusion-Model-1-make-it-work-first/</url>
    <content><![CDATA[<script src=/js/crypto-js.js></script>
<script>
function doDecrypt (pwd, onError) {
	console.log('in doDecrypt');
	const txt = document.getElementById('enc_content').innerHTML;
	let plantext;
	try {
		const bytes = CryptoJS.AES.decrypt(txt, pwd);
		var plaintext = bytes.toString(CryptoJS.enc.Utf8);
	} catch(err) {
		if(onError) {
			onError(err);
		}
		return;
	}
	document.getElementById('enc_content').innerHTML = plaintext;
	document.getElementById('enc_content').style.display = 'block';
	document.getElementById('enc_passwd').style.display = 'none';
	if(typeof MathJax !== 'undefined') {
		MathJax.Hub.Queue(
			['resetEquationNumbers', MathJax.InputJax.TeX],
			['PreProcess', MathJax.Hub],
			['Reprocess', MathJax.Hub]
		);
	}
}
</script>
<div id="enc_content" style="display:none">U2FsdGVkX1+rqeeDzTj6Yb0YWWuOyt0psRgra4sT+K0=</div>
<div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div>
<script>
var onError = function(error) {
	document.getElementById("enc_error").innerHTML = "password error!"
};
function decrypt() {
var passwd = document.getElementById("enc_pwd_input").value;
console.log(passwd);
doDecrypt(passwd, onError);
}
</script>
</div>]]></content>
  </entry>
  <entry>
    <title>SpringSecurity结构梳理</title>
    <url>/2022/06/02/SpringSecurity%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>Spring Security整体是基于Servlet的Filter机制。简单来说，其就是将一系列的Filter组合起来，然后建立一定的机制来管理这些Filter；并且为特定的Filter提供一定的配套类来达成一定的功能，比如认证的Filter，CSRF的Filter等。</p>
<p>下面是对其管理机制的一些简单介绍</p>
<h2 id="FilterChain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a><code>FilterChain</code></h2><p>Servlet的Filter的执行过程，类似于函数的调用过程。</p>
<p>即当一个请求从客户端发送到Server的时候，在到达对应的Servlet处理之前，都会调用提前的设定的对应Filter。并且这些Filter会按照调用栈执行，并且会按照调用的顺序再返回，由第一个Filter来执行response。</p>
<p>其流程图如下：</p>
<p><img src="/images/SpringSecurity结构梳理/Filter流程.jpg" alt="Filter流程"></p>
<p>值得注意的是，SpringMVC就是基于Servelt的，其基本原理为，建立一个名为<code>DispatcherServlet</code>的servlet来接受所有的请求，然后再在SpringMVC应用内为其映射对应的Controller请求函数。</p>
<p>而上面整个过程中用的Filter就构成了一个链式的结构，其又被称为Filter链（<code>FilterChain</code>）。</p>
<h2 id="DelegatingFilterProxy"><a href="#DelegatingFilterProxy" class="headerlink" title="DelegatingFilterProxy"></a><code>DelegatingFilterProxy</code></h2><p>这个类实际上是为Spring上下文和Servlet之间提供了一个桥梁。即一般来说，我们为Servlet注册上下文的时候，Spring上下文并不一定启动了，所以在Filter中无法感知到Spring应用，并且这些Filter也是用户自己new出来的，可以说是违背了Spring应用中IOC的核心，即把类的构造权交由Spring容器来做，而不是自己手动新建。</p>
<p>所以该类就是为了解决这个问题，从名字就可以看出，这是一个具有代理功能的类。即一个<code>DelegatingFilterProxy</code>代理一个真实的Filter，并且被代理的这个类是在Spring容器中的。代理类中提供了从容器中查找的对应真实Filter的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.targetBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.targetBeanName = <span class="keyword">this</span>.getFilterName();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            WebApplicationContext wac = <span class="keyword">this</span>.findWebApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (wac != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.delegate = <span class="keyword">this</span>.initDelegate(wac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和调用真实Filter的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeDelegate</span><span class="params">(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    delegate.doFilter(request, response, filterChain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以一般的用法就是，在Spring容器中定义对应的Filter，然后再向Servlet容器中注册一个自己新建的<code>DelegatingFilterProxy</code>类实例，该实例就会自动查找并调用Spring容器中的Filter。</p>
<p>如新建的<code>DelegatingFilterProxy</code>的doFilter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Lazily get Filter that was registered as a Spring Bean</span></span><br><span class="line">	<span class="comment">// For the example in DelegatingFilterProxy </span></span><br><span class="line">delegate</span><br><span class="line"> is an instance of Bean Filter0</span><br><span class="line">	Filter delegate = getFilterBean(someBeanName);</span><br><span class="line">	<span class="comment">// delegate work to the Spring Bean</span></span><br><span class="line">	delegate.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种代理机制的另一个好处就是延迟加载，实际上还是克服了无法将容器对象注册为标准Filter的缺点。因为Filter需要在应用启动的时候就注册，但此时Spring容器可能并没有初始化好，那么就是无法进行注册的。则借用代理，在需要时加载，那么在需要的时候一般就已经初始化好了（因为请求都发送过来了）。</p>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>实际上该类很简单，一共就180行代码。</p>
<p>这里其实也为我们经常遇到的一个问题提供了解决思路，即：在Filter中如果需要使用Spring容器中的对象，该怎么拿到？或者更宽泛一点：在Spring容器可能还没有初始化完成时（还比如interceptor种），我们又需要使用容器中的对象，该怎么使用？一个典型的场景就是：在Filter中需要使用redis，除非自己手写一个RedisTemplate，但Spring-Redis实际上已经新建好并且注入到Spring容器中，只需要我们取出来就好了，这种情况下，自己再去新建就显得没有必要了。</p>
<p>那么这里我们就可以使用其中的API，通过request来获取对应的Spring上下文，并以此来获取容器的对象来进行使用。值得注意的是，这里的使用也是延迟的，即获取和使用都是在请求到来时才进行，因为容器的初始化在之后才进行的。（例如，如果将上下文的获取，容器中对象中的获取放到Filter的构造器中，那就肯定得不到对应的对象，因为那时容器还没有初始化，获取的必定为null。）</p>
<p>一个简单的实例如下（从request获取存储在Spring上下文中的RedisUtils对象）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisUtils <span class="title">getInstance</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    WebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());</span><br><span class="line">    <span class="keyword">return</span> webApplicationContext.getBean(RedisUtils<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是使用<code>WebApplicationContextUtils</code>工具类。</p>
<p>再看一下其是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getWebApplicationContext</span><span class="params">(ServletContext sc, String attrName)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(sc, <span class="string">"ServletContext must not be null"</span>);</span><br><span class="line">    Object attr = sc.getAttribute(attrName);</span><br><span class="line">    <span class="keyword">if</span> (attr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attr <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException)attr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attr <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error)attr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attr <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException((Exception)attr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(attr <span class="keyword">instanceof</span> WebApplicationContext)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Context attribute is not of type WebApplicationContext: "</span> + attr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (WebApplicationContext)attr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其实逻辑很简单，就是从<code>ServletContext</code>通过名字获取<code>WebApplicationContext</code>对象。而且个对象是在应用启动的时候由Spring放进去的。</p>
<h2 id="FilterChainProxy"><a href="#FilterChainProxy" class="headerlink" title="FilterChainProxy"></a><code>FilterChainProxy</code></h2><p><code>FilterChainProxy</code>实际上相当于Spring Security的<code>DelegatingFilterProxy</code>。即它也是一个代理类，但它与<code>DelegatingFilterProxy</code>不同的点在于：</p>
<ul>
<li><code>FilterChainProxy</code>是所有经过Spring Security请求的入口位置，所以其代理的是多个Filter，而不是像<code>DelegatingFilterProxy</code>一样，仅仅代理一个Filter。</li>
<li><code>FilterChainProxy</code>作为Spring Security的核心Filter，其可以用来做一些其他任务，比如清除<code>SecurityContext</code>防止内存泄露。</li>
<li><code>FilterChainProxy</code>提供了更灵活的Filter匹配机制，即哪些Filter将在哪些路径中触发。</li>
</ul>
<p>简单来说，就是<code>DelegatingFilterProxy</code>代理了<code>FilterChainProxy</code>，而<code>FilterChainProxy</code>又代理一系列的Filter（这些代理就是普通的Spring容器内的对象了）。</p>
<p>下面是一个简单的例子：</p>
<ol>
<li>Servlet内看到的Filter，可以看到第四个就是一个<code>DelegatingFilterProxy</code>，这个类就是Spring Security注册的。</li>
</ol>
<p><img src="/images/SpringSecurity结构梳理/Servlet内看到的Filter.jpg" alt="Servlet内看到的Filter"></p>
<ol start="2">
<li>可以看到，这个<code>DelegatingFilterProxy</code>代理了一个<code>FilterChainProxy</code>对象。</li>
</ol>
<p><img src="/images/SpringSecurity结构梳理/DelegatingFilterProxy代理了FilterChainProxy.jpg" alt="DelegatingFilterProxy代理了FilterChainProxy">    </p>
<ol start="3">
<li>该<code>FilterChainProxy</code>又代理了一系列的Filter。</li>
</ol>
<p><img src="/images/SpringSecurity结构梳理/FilterChainProxy代理的Filter.jpg" alt="FilterChainProxy代理的Filter"></p>
<p>所以实际上就是一个套娃的过程。</p>
<h2 id="Spring-Security中的默认拦截器顺序"><a href="#Spring-Security中的默认拦截器顺序" class="headerlink" title="Spring Security中的默认拦截器顺序"></a>Spring Security中的默认拦截器顺序</h2><ul>
<li><code>ForceEagerSessionCreationFilter</code></li>
<li><code>ChannelProcessingFilter</code></li>
<li><code>WebAsyncManagerIntegrationFilter</code></li>
<li><code>SecurityContextPersistenceFilter</code></li>
<li><code>HeaderWriterFilter</code></li>
<li><code>CorsFilter</code></li>
<li><code>CsrfFilter</code></li>
<li><code>LogoutFilter</code></li>
<li><code>OAuth2AuthorizationRequestRedirectFilter</code></li>
<li><code>Saml2WebSsoAuthenticationRequestFilter</code></li>
<li><code>X509AuthenticationFilter</code></li>
<li><code>AbstractPreAuthenticatedProcessingFilter</code></li>
<li><code>CasAuthenticationFilter</code></li>
<li><code>OAuth2LoginAuthenticationFilter</code></li>
<li><code>Saml2WebSsoAuthenticationFilter</code></li>
<li><code>UsernamePasswordAuthenticationFilter</code></li>
<li><code>DefaultLoginPageGeneratingFilter</code></li>
<li><code>DefaultLogoutPageGeneratingFilter</code></li>
<li><code>ConcurrentSessionFilter</code></li>
<li><code>DigestAuthenticationFilter</code></li>
<li><code>BearerTokenAuthenticationFilter</code></li>
<li><code>BasicAuthenticationFilter</code></li>
<li><code>RequestCacheAwareFilter</code></li>
<li><code>SecurityContextHolderAwareRequestFilter</code></li>
<li><code>JaasApiIntegrationFilter</code></li>
<li><code>RememberMeAuthenticationFilter</code></li>
<li><code>AnonymousAuthenticationFilter</code></li>
<li><code>OAuth2AuthorizationCodeGrantFilter</code></li>
<li><code>SessionManagementFilter</code></li>
<li><code>ExceptionTranslationFilter</code></li>
<li><code>FilterSecurityInterceptor</code></li>
<li><code>SwitchUserFilter</code></li>
</ul>
<h1 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h1><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a><code>SecurityContextHolder</code></h2><p><code>SecurityContextHolder</code>是Spring认证的核心。它存储了当前被认证的用户信息，其存储的是一个<code>SecurityContext</code>对象。</p>
<p> Spring Security并不关心如何存储该信息，但是它包含一个值，它被用作当前通过身份验证的用户。</p>
<p>其结构如下：</p>
<p><img src="/images/SpringSecurity结构梳理/securitycontextholder.png" alt="securitycontextholder"></p>
<p>表示用户通过身份验证的最简单方法是直接设置SecurityContextHolder:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecurityContext context = SecurityContextHolder.createEmptyContext(); </span><br><span class="line">Authentication authentication = <span class="keyword">new</span> TestingAuthenticationToken(<span class="string">"username"</span>, <span class="string">"password"</span>, <span class="string">"ROLE_USER"</span>); </span><br><span class="line">context.setAuthentication(authentication);</span><br><span class="line">SecurityContextHolder.setContext(context);</span><br></pre></td></tr></table></figure>
<p>获取存储的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecurityContext context = SecurityContextHolder.getContext();</span><br><span class="line">Authentication authentication = context.getAuthentication();</span><br><span class="line">String username = authentication.getName();</span><br><span class="line">Object principal = authentication.getPrincipal();</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>SecurityContextHolder</code>使用<code>ThreadLocal</code>来存储这些细节，这意味着<code>SecurityContext</code>总是对同一个线程中的方法可用，即使<code>SecurityContext</code>没有显式地作为参数传递给那些方法。如果在处理当前主体的请求后清除线程，那么以这种方式使用<code>ThreadLocal</code>是非常安全的。Spring Security的<code>FilterChainProxy</code>确保<code>SecurityContext</code>可以被清除掉。</p>
<p>在其他的场景中，可能并不适合使用<code>ThreadLocal</code>，比如Swing客户端中，可能希望Java虚拟机中的所有线程使用相同的<code>SecurityContextHolder</code>。</p>
<p>那么就可以设定<code>SecurityContextHolder</code>的策略，即设置<code>SecurityContextHolder.strategyName</code>。其有4种模式：</p>
<ul>
<li>public static final String MODE_THREADLOCAL = “MODE_THREADLOCAL”：默认，即ThreadLocal方式。</li>
<li>public static final String MODE_INHERITABLETHREADLOCAL = “MODE_INHERITABLETHREADLOCAL”：其所有派生线程共享。</li>
<li>public static final String MODE_GLOBAL = “MODE_GLOBAL”：所有线程共享上下文。</li>
</ul>
<h2 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a><code>SecurityContext</code></h2><p>其是一个接口，只定义了基本的设置<code>Authentication</code>的方法。但其有一个实现类<code>SecurityContextImpl</code>，但是实现也很简单，只是定义了最基本的<code>Authentication</code>成员变量的get和set方法。该类是实际存储用户数据的类，其将会被存储到<code>SecurityContextHolder</code>中。</p>
<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a><code>Authentication</code></h2><p>这是一个接口，其含义是真正存储用户认证信息的类，其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.security.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.security.Principal;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到很简单，其中的<code>getCredentials</code>是定义的获取用户的的密钥，<code>getPrincipal</code>用来获取用户的名字，而<code>getDetails</code>用于获取其他附加的信息（可由自己定义）。</p>
<p>由于其是一个接口，必须要有其实现类才能工作，所以在Spring Security内部先定义了一个<code>AbstractAuthenticationToken</code>抽象类实现了一定的功能。</p>
<p>然后又为不同场景中定义了很多不同的<code>Authentication</code>，这些<code>Authentication</code>都被命名为xxxToken。</p>
<p>最常见的就是<code>UsernamePasswordAuthenticationToken</code>和<code>AnonymousAuthenticationToken</code>。</p>
<p>其中<code>AnonymousAuthenticationToken</code>是用来存储账户密码的对象。</p>
<p>其实现很简单，即四十多行代码，其中principal就是用户名，credentials就是密码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.security.authentication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationToken</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationToken</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">560L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line">    <span class="keyword">private</span> Object credentials;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Collection)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.principal = principal;</span><br><span class="line">        <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">        <span class="keyword">this</span>.setAuthenticated(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(authorities);</span><br><span class="line">        <span class="keyword">this</span>.principal = principal;</span><br><span class="line">        <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">        <span class="keyword">super</span>.setAuthenticated(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCredentials</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.credentials;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPrincipal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        Assert.isTrue(!isAuthenticated, <span class="string">"Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setAuthenticated(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eraseCredentials</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eraseCredentials();</span><br><span class="line">        <span class="keyword">this</span>.credentials = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>该对象会交给对应类型的<code>ProviderManager</code>来进行认证，并且是更具这个类的类型来选择<code>ProviderManager</code>的类型。</strong></p>
<h2 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a><code>GrantedAuthority</code></h2><p>这个类是用来存储用户的权限实例。比如角色和权限。</p>
<p>一般是从<code>Authentication.getAuthorities()</code>获取。这个对象是对应于特定角色的权限。一般来说是在<code>UserDetailService</code>中装配User对象时一起装配的（比如是从数据库中的RBAC模型获取的）。</p>
<h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a><code>AuthenticationManager</code></h2><p><code>AuthenticationManager</code>是一个接口，它规定了Spring Security如何进行验证用户。但实际上其只定义了一个<code>authenticate</code>方法，这个方法也是整个认证过程的关键。</p>
<p>我们可以自己实现<code>AuthenticationManager</code>，但一般都是使用Spring Security自己实现的<code>ProviderManager</code>。</p>
<h2 id="ProviderManager"><a href="#ProviderManager" class="headerlink" title="ProviderManager"></a><code>ProviderManager</code></h2><p><code>ProviderManager</code>是Spring Security认证的核心类。它是<code>AuthenticationManager</code>的最常见实现类。</p>
<p>它代理一系列的<code>AuthenticationProvider</code>，<code>AuthenticationProvider</code>是实际进行用户认证的类。每个<code>AuthenticationProvider</code>都有机会表明身份验证应该成功、失败，或者表明它不能做出决定并允许下游的<code>AuthenticationProvider</code>做出决定。如果没有配置<code>AuthenticationProvider</code>实例可以验证,与<code>ProviderNotFoundException</code>认证失败,这是一个特殊<code>AuthenticationException</code>表明<code>ProviderManager</code>没有配置为支持传递给它的身份验证类型（<code>Authentication</code>类型）。</p>
<p>简单来说就是由<code>ProviderManager</code>代理一系列的<code>AuthenticationProvider</code>，然后当认证请求到来的时候（通常是在Filter中），来调用对应类型的<code>AuthenticationProvider</code>来进行用户的验证。</p>
<p>其结构如下：</p>
<p><img src="/images/SpringSecurity结构梳理/providermanager.png" alt="providermanager"></p>
<p>另外，<code>ProviderManager</code>还允许配置一个可选的父类<code>AuthenticationManager</code>（当然一般也是<code>ProviderManager</code>）。在当前<code>ProviderManager</code>找不到对应<code>AuthenticationProvider</code>的情况下就会调用父类进行验证。</p>
<h2 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a><code>AuthenticationProvider</code></h2><p>这个类也是一个十分重要的类，它提供了对不同类型<code>Authentication</code>的具体验证方案。Spring Security也提供了很多具体的验证方案，在Spring Security中，用户密码验证的默认<code>AuthenticationProvider</code>是<code>DaoAuthenticationProvider</code>，它实现了<code>AbstractUserDetailsAuthenticationProvider</code>类。</p>
<p>其中主要规定了密码加密方式<code>setPasswordEncoder</code>，<code>UserDetailService</code>的获取等方法。</p>
<p>而我们要自定义自己的验证方式时，也可以自定义<code>AuthenticationProvider</code>。主要就是要实现<code>authenticate</code>方法。</p>
<p>例如，下面是一个实现邮箱登录的<code>AuthenticationProvider</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailCodeAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> XPanUserEmailDetailsService UuerEmailDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DefaultPreAuthenticationChecks preAuthenticationChecks = <span class="keyword">new</span> DefaultPreAuthenticationChecks();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailCodeAuthenticationProvider</span><span class="params">(XPanUserEmailDetailsService userDetailsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.UuerEmailDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        supports(authentication.getClass());</span><br><span class="line">        EmailCodeAuthenticationToken token = (EmailCodeAuthenticationToken) authentication;</span><br><span class="line">        UserDetails user = UuerEmailDetailsService.loadUserByUserEmail((String) token.getPrincipal());</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)token.getDetails();</span><br><span class="line">        RedisUtils instance = RedisUtils.getInstance(request);</span><br><span class="line">        String realCode = instance.get((String)authentication.getPrincipal());</span><br><span class="line">        <span class="keyword">if</span>(realCode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"验证码已过期！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证码是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(!realCode.equals((String) authentication.getCredentials()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"验证码错误！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(<span class="string">"无法获取用户信息"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        preAuthenticationChecks.check(user);</span><br><span class="line">        EmailCodeAuthenticationToken res = <span class="keyword">new</span> EmailCodeAuthenticationToken(user, user.getAuthorities());</span><br><span class="line">        res.setDetails(token.getDetails());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EmailCodeAuthenticationToken<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">authentication</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultPreAuthenticationChecks</span> <span class="keyword">implements</span> <span class="title">UserDetailsChecker</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">DefaultPreAuthenticationChecks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(UserDetails user)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!user.isAccountNonLocked()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> LockedException(<span class="string">"User account is locked"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!user.isEnabled()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DisabledException(<span class="string">"User is disabled"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!user.isAccountNonExpired()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AccountExpiredException(<span class="string">" User account has expired"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><p>该接口一般用在<code>AuthenticationProvider</code>类中用来获取用户的完整信息，该接口定义了<code>loadUserByUsername</code>方法用来获取用户的信息。但是如果在自定义的<code>AuthenticationProvider</code>中，就不一定要用实现<code>UserDetailsService</code>的方式来获取用户信息了，也可以直接定义自己的类。（基本的问题就是比如邮箱登录的时候，我们应当是通过邮箱来获取用户，而不是用户名）。</p>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
        <tag>认证</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务使用以及要点</title>
    <url>/2022/06/22/Spring%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1 id="5种隔离级别"><a href="#5种隔离级别" class="headerlink" title="5种隔离级别"></a>5种隔离级别</h1><p>MySQL有4种隔离级别：</p>
<ul>
<li><p><strong>读未提交内容（read-uncommitted）</strong>：</p>
<p>在该隔离级别中，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。</p>
<p>该隔离级别会出现的问题是：脏读(Dirty Read)，即读取到了未提交的数据。</p>
</li>
<li><p><strong>读取提交内容（read-committed）</strong></p>
<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p>
<p>该隔离级别会出现的问题是：不可重复读(Nonrepeatable Read)，即不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。</p>
<p>导致这种情况的原因可能有：</p>
<p>1)、有一个交叉的事务有新的commit，导致了数据的改变;</p>
<p>2)、一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit</p>
</li>
<li><p><strong>可重复读（repeatable-read）</strong></p>
<p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p>
<p>不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p>
<p>简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。</p>
<p>InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
</li>
<li><p><strong>可串行化（serializable）</strong></p>
<p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<p>在这个级别，可能导致大量的超时现象和锁竞争。</p>
</li>
</ul>
<p>但由于Spring只提供事务的接口，在具体提交事务的时候必须根据不同的数据库系统进行决定。因此Spring提供了一种默认机制，即根据不同的数据库来选择不同的默认隔离机制。这也是Spring默认的隔离级别。</p>
<h1 id="7种传播机制"><a href="#7种传播机制" class="headerlink" title="7种传播机制"></a>7种传播机制</h1><p>所谓的传播机制，就是在面对事务嵌套的时候，Spring采取的处理措施。其有以下7种机制：</p>
<ul>
<li><p><strong>REQUIRED</strong> 这是默认的。表示当前方法必须在一个具有事务的上下文中运行，如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。（如果被调用端发生异常，那么调用端和被调用端事务都将回滚）</p>
<p><em>例如，functionA-&gt;functionB，如果functionA是一个事务，functionB也是一个事务并且传播机制为PROPAGATION_REQUIRED，则functionB直接在functionA的事务中运行；那如果functionA不是一个事务，则functionB会新开一个事务。</em></p>
</li>
<li><p><strong>REQUIRE_NEW</strong> 表示当前方法必须运行在它自己的事务中。如果存在当前事务，在该方法执行期间，当前事务会被挂起。</p>
<p>例如，functionA-&gt;functionB，如果functionA是一个事务，functionB也是一个事务并且传播机制为REQUIRE_NEW，则functionB会挂起functionA的事务并且开一个新的事物，直到functionB事物执行完毕；如果functionA不是一个事务，则如果functionB开一个新事务执行。</p>
</li>
<li><p><strong>NESTED</strong>  如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在，并且外层事务抛出异常回滚，那么内层事务必须回滚，反之，内层事务并不影响外层事务。如果封装事务不存在，则同<code>required</code>的一样。</p>
</li>
<li><p><strong>SUPPORTS</strong> 表示当前方法不必需要具有一个事务上下文，但是如果有一个事务的话，它也可以在这个事务中运行。</p>
</li>
<li><p><strong>NOT_SUPPORTED</strong> 表示该方法不应该在一个事务中运行。如果有一个事务正在运行，他将在运行期被挂起，直到这个事务提交或者回滚才恢复执行。</p>
</li>
<li><p><strong>MANDATORY</strong> 表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常。</p>
</li>
<li><p><strong>NEVER</strong> 表示当方法务不应该在一个事务中运行，如果存在一个事务，则抛出异常。</p>
</li>
</ul>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h2><p>xml方式下，需要使用<code>&lt;tx:advice/&gt;</code>标签进行配置。其具体是在<code>&lt;tx:advice/&gt;</code>-&gt;<code>&lt;tx:attributes/&gt;</code>-&gt;<code>&lt;tx:method/&gt;</code>中进行属性配置。</p>
<p>其属性有以下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>必须</th>
<th>默认</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>Yes</td>
<td></td>
<td>被该事务关联的方法，可以使用通配符（<em>），如`get</em>`等。</td>
</tr>
<tr>
<td>propagation</td>
<td>No</td>
<td>REQUIRED</td>
<td>事务的传播行为（见上列表）。</td>
</tr>
<tr>
<td>isolation</td>
<td>No</td>
<td>DEFAULT</td>
<td>事务的隔离级别（见上列表）。</td>
</tr>
<tr>
<td>timeout</td>
<td>No</td>
<td>-1</td>
<td>事务的超时时间（秒），只有传播行为在REQURED和REQUIRES_NEW时有效。</td>
</tr>
<tr>
<td>read-only</td>
<td>No</td>
<td>falsse</td>
<td>读写事务与只读事务。仅在REQUIRED或REQUIRES_NEW时有效。</td>
</tr>
<tr>
<td>rollback-for</td>
<td>No</td>
<td></td>
<td>触发回滚的错误列表，例如<code>com.foo.MyBusinessException,ServletException</code>。</td>
</tr>
<tr>
<td>no-rollback-for</td>
<td>No</td>
<td></td>
<td>不触发回滚的错误列表，例如<code>com.foo.MyBusinessException,ServletException</code>。</td>
</tr>
</tbody>
</table>
<p>最后两个属性值得注意的是：Spring事务默认只会对<code>RuntimeException</code>或者<code>Error</code>及其子类进行回滚，其他的异常都不会回滚，只会抛出异常。因此最后两个属性是为了改变这一默认行为的。如遇到IO错误时，Spring事务是不会回滚的，如果需要，则必须配置<code>IOExcetpion</code>。</p>
<h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><p>注解方式下，使用<code>@Transactional</code>来进行注解的配置。其主要配置都与XML方式属性一致（都含有以上的配置项，不过是以注解属性的形式，横杠写法变为小驼峰写法），主要有以下几个不同的属性，</p>
<ul>
<li><code>value</code>：也就是默认值，这个属性可以用来确定使用不同的事务管理器(transaction manager)，即可以在一个应用中使用不同的事物管理器。</li>
<li><code>transactionManager</code>：与value一致。</li>
</ul>
<p>值得注意的是：</p>
<ul>
<li><p>该注解可以用在类上，则整个类的方法都会使用该事物管理器进行事物操作。</p>
</li>
<li><p>该注解必须是被spring代理的类，否则事务配置无效。</p>
</li>
<li><p>非public方法默认是无法进行事物管理的，加上不会报错，只是会无效。如果想要在非public的方法上使用事务，可以使用在配置类（<code>@Configuration</code>）加上<code>@EnableTransactionManagement</code>注解，并且配置一个<code>transactionAttributeSource</code>示例。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Register a custom AnnotationTransactionAttributeSource with the</span><br><span class="line"> * publicMethodsOnly flag set to false to enable support for</span><br><span class="line"> * protected and package-private @Transactional methods in</span><br><span class="line"> * class-based proxies.</span><br><span class="line"> *</span><br><span class="line"> * @see ProxyTransactionManagementConfiguration#transactionAttributeSource()</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Bean</span><br><span class="line">TransactionAttributeSource transactionAttributeSource() &#123;</span><br><span class="line">    return new AnnotationTransactionAttributeSource(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是请注意，基于接口的代理中的事务方法必须始终是公共的，并在代理接口中定义。（也就是说，如果spring容器中存储的类型是接口，那么实现类中的事务方法还是必须为公开，并且在接口中进行定义）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>-Sprin</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise的实现</title>
    <url>/2021/02/04/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>前面已经写过一篇文章来理解<code>Promise</code>及其使用方法，这里尝试来模拟<code>Promise</code>。</p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>根据<a href="https://promisesaplus.com/#point-1" target="_blank" rel="noopener">Promise/A+</a>原理，有以下几个点需要遵守：</p>
<ol>
<li><p><code>Promise</code>有一个<code>Promise States</code>，其有三种状态：</p>
<ol>
<li><code>pending</code>：初始状态，可以转化为<code>fulfilled</code>，<code>rejected</code>。</li>
<li><code>fulfilled</code>：<ol>
<li>需要一个<code>value</code>作为结果。</li>
<li>不能转化为其他状态。</li>
</ol>
</li>
<li><code>rejected</code>：<ol>
<li>需要一个<code>reason</code>作为一个原因。</li>
<li>不能转化为其他状态。</li>
</ol>
</li>
</ol>
</li>
<li><p>必须要一个<code>then</code>方法，接受两个参数</p>
<ol>
<li><code>onFulfilled</code>：当操作成功时发生的回调。</li>
<li><code>onRejected</code>：当操作失败时发生的回调。</li>
</ol>
<p>一旦<code>promise</code>完成，每一次调用<code>then</code>方法，得到的结果必须是相同的。</p>
</li>
<li><p><code>Promise</code>返回的必须也是一个<code>promise</code>。</p>
</li>
</ol>
<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><h2 id="实现1，2功能"><a href="#实现1，2功能" class="headerlink" title="实现1，2功能"></a>实现1，2功能</h2><p>首先我们实现第一个和第二个特点：</p>
<p>基本思路如下：</p>
<ul>
<li><p>一个<code>Promise</code>首先要有一个<code>status</code>，表示当前的状态，其有三种状态：</p>
<ol>
<li><code>PENDING</code>：表示当前<code>Promise</code>未完成，此时的回调函数会加入相应的队列</li>
<li><code>RESOLVED</code>：表示当前<code>Promise</code>已经完成，且时<code>resolve</code>状态，直接调用成功的函数。</li>
<li><code>REJECTED</code>：表示当前<code>Promise</code>已经完成，且时<code>rejected</code>状态，直接调用失败的函数。</li>
</ol>
</li>
<li><p>然后我们要定义两个值：</p>
<ol>
<li><code>value</code>：用于<code>resolve</code>时的返回值。</li>
<li><code>reason</code>：用于<code>rejected</code>时的返回值。</li>
</ol>
</li>
<li><p>上面说到当<code>Promise</code>状态为<code>PENDING</code>时，我们会把回调函数放到相应的队列，所以我们还会定义两个队列</p>
<ol>
<li><code>resolvedCallQueue</code>：存放成功的回调函数</li>
<li><code>rejectedCallQueue</code>：存放失败的回调函数</li>
</ol>
</li>
<li><p>然后我们定义<code>Promise</code>的<code>resolve</code>和<code>rejected</code>函数，在这两个函数中，我们会改变<code>Promise</code>的状态并且给<code>value</code>或者<code>reason</code>赋值，最后执行相应的函数队列。</p>
</li>
<li>最后我们会定义<code>Promise</code>的<code>then</code>方法。如同上面对于状态的定义，我们会根据当前<code>Promise</code>的状态来处理<code>then</code>方法传来的回调函数。</li>
</ul>
<p>下面用<code>ES6</code>的<code>class</code>来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executer) &#123;</span><br><span class="line">    <span class="comment">//定义Promise状态枚举数据</span></span><br><span class="line">    <span class="keyword">this</span>.status_enum = &#123;</span><br><span class="line">      PENDING: <span class="string">'PENDING'</span>,</span><br><span class="line">      RESOLVED: <span class="string">'RESOLVED'</span>,</span><br><span class="line">      REJECTED: <span class="string">'REJECTED'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//成功的返回值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">//失败的返回值</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">//成功的回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>.resolvedCallQueue = [];</span><br><span class="line">    <span class="comment">//失败的回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>.rejectedCallQueue = [];</span><br><span class="line">    <span class="comment">//当前Promise状态</span></span><br><span class="line">    <span class="keyword">this</span>.status = <span class="keyword">this</span>.status_enum.PENDING;</span><br><span class="line">    <span class="comment">//Promise完成</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="keyword">this</span>.status_enum.RESOLVED;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.resolvedCallQueue.length; i++) &#123;</span><br><span class="line">          <span class="keyword">this</span>.resolvedCallQueue[i](<span class="keyword">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//Promise失败</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="keyword">this</span>.status_enum.REJECTED;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rejectedCallQueue.length; i++) &#123;</span><br><span class="line">          <span class="keyword">this</span>.rejectedCallQueue[i](<span class="keyword">this</span>.reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//执行Promise函数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executer(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'错误'</span>, e);</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义then函数</span></span><br><span class="line">  then(onfulfilled, onrejected) &#123;</span><br><span class="line">    <span class="comment">//检测参数必须为函数</span></span><br><span class="line">    <span class="keyword">if</span>(!onfulfilled <span class="keyword">instanceof</span> <span class="built_in">Function</span> || !onrejected <span class="keyword">instanceof</span> <span class="built_in">Function</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Uncaught TypeError: Promise resolver is not a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当Promise状态为RESOLVED时，进行成功回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.RESOLVED) &#123;</span><br><span class="line">      onfulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当Promise状态为REJECTED时，进行失败回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.REJECTED) &#123;</span><br><span class="line">      onrejected(<span class="keyword">this</span>.reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当Promise状态为PENDING时，将其回调函数加入相应队列，在完成时会执行相应的函数队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resolvedCallQueue.push(onfulfilled);</span><br><span class="line">      <span class="keyword">this</span>.rejectedCallQueue.push(onrejected);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面用原型实现(基本原理一样，因为<code>class</code>本质也是原型链的语法糖)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.status_enum = &#123;</span><br><span class="line">    PENDING: <span class="string">'PENDING'</span>,</span><br><span class="line">    RESOLVED: <span class="string">'RESOLVED'</span>,</span><br><span class="line">    REJECTED: <span class="string">'REJECTED'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">this</span>.resolvedCallQueue = [];</span><br><span class="line">  <span class="keyword">this</span>.rejectedCallQueue = [];</span><br><span class="line">  <span class="keyword">this</span>.status = <span class="keyword">this</span>.status_enum.PENDING;</span><br><span class="line">  <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="keyword">this</span>.status_enum.RESOLVED;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.resolvedCallQueue.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resolvedCallQueue[i](<span class="keyword">this</span>.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="keyword">this</span>.status_enum.REJECTED;</span><br><span class="line">      <span class="keyword">this</span>.reason = reason;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rejectedCallQueue.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.rejectedCallQueue[i](<span class="keyword">this</span>.reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executer(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'错误'</span>, e);</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Promise2.prototype.then = <span class="function"><span class="keyword">function</span> <span class="title">then</span>(<span class="params">onfulfilled, onrejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.RESOLVED) &#123;</span><br><span class="line">    onfulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.REJECTED) &#123;</span><br><span class="line">    onrejected(<span class="keyword">this</span>.reason);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resolvedCallQueue.push(onfulfilled);</span><br><span class="line">    <span class="keyword">this</span>.rejectedCallQueue.push(onrejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，Promise的基本功能就已经实现，简单测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2秒！！！'</span>);</span><br><span class="line">        resolve(<span class="number">111</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2秒！！！</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line"></span><br><span class="line">111</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line"></span><br><span class="line">111</span><br></pre></td></tr></table></figure>
<h2 id="实现1，2，3功能"><a href="#实现1，2，3功能" class="headerlink" title="实现1，2，3功能"></a>实现1，2，3功能</h2><p>前面我们基本实现了<code>Promise</code>的基本功能，但是还是一个问题是：<code>Promise</code>必须返回一个<code>Promise</code>，上面的代码并不满足这一点。</p>
<p>所谓我们为了实现返回的都是<code>Promise</code>，我们需要重写<code>then</code>方法，使之返回的是一个Promise，这时，我们还是要根据当前<code>Promise</code>的状态来分开来处理。</p>
<p>但是其中心点是，必须持续执行<code>Promise</code>，直到其返回值不是一个<code>thenable</code>对象或方法，所以这是一个递归的过程。所以我们定义了一个函数<code>cycleResolve</code>，其接受四个参数：</p>
<ol>
<li><code>newPromise</code>：新建的被用于返回的<code>Promise</code></li>
<li><code>target</code>：回调函数执行的获得结果（可能仍然是一个<code>Promise</code>）</li>
<li><code>resolve</code>：新<code>Promise</code>的<code>resolve</code>函数</li>
<li><code>reject</code>：新<code>Promise</code>的<code>reject</code>函数</li>
</ol>
<p>该函数的功能是：判定返回值<code>target</code>是不是一个<code>thenable</code>对象（包括<code>Promise</code>），如果是，继续执行其<code>then</code>方法。经过这个过程，知道返回值不是<code>thenable</code>对象，然后将其值<code>resolve</code>出去。</p>
<p>注意：</p>
<ol>
<li>只有<code>target</code>是一个<code>thenable</code>对象并且其<code>then</code>属性是一个函数时，才会调用其<code>then</code>方法，否则会直接将<code>target</code>resolve出去。</li>
<li>一旦遇到错误，都会直接<code>reject(e)</code></li>
<li><code>then</code>方法中必须使用<code>setTimeout</code>来使内部的操作成为宏任务，在下一个tick执行。这样才能拿到<code>newPromise</code>，否则会出现未初始化错误。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status_enum = &#123;</span><br><span class="line">            PENDING: <span class="string">'PENDING'</span>,</span><br><span class="line">            RESOLVED: <span class="string">'RESOLVED'</span>,</span><br><span class="line">            REJECTED: <span class="string">'REJECTED'</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.resolvedCallQueue = [];</span><br><span class="line">        <span class="keyword">this</span>.rejectedCallQueue = [];</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="keyword">this</span>.status_enum.PENDING;</span><br><span class="line">        <span class="comment">//定义resolve方法，任务完成时调度</span></span><br><span class="line">        <span class="keyword">this</span>.resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = <span class="keyword">this</span>.status_enum.RESOLVED;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.resolvedCallQueue.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.resolvedCallQueue[i](<span class="keyword">this</span>.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//定义reject方法，任务失败时调度</span></span><br><span class="line">        <span class="keyword">this</span>.reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = <span class="keyword">this</span>.status_enum.REJECTED;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rejectedCallQueue.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.rejectedCallQueue[i](<span class="keyword">this</span>.reason);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//执行定义Promise时传入的任务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executer(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'错误'</span>, e);</span><br><span class="line">            <span class="keyword">this</span>.reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义then方法</span></span><br><span class="line">    then(onfulfilled, onrejected) &#123;</span><br><span class="line">        <span class="comment">//新建一个Promise用于返回</span></span><br><span class="line">        <span class="keyword">let</span> newPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.RESOLVED) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> target = onfulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                        cycleResolve(newPromise, target, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(e);</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.REJECTED) &#123;</span><br><span class="line">                <span class="comment">//建立宏任务，方便拿到newPromise，否则会出现未初始化错误</span></span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> target = onrejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                        cycleResolve(newPromise, target, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(e);</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.resolvedCallQueue.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> target = onfulfilled(<span class="keyword">this</span>.value); <span class="comment">//将resolve函数保留的成功值传递作为参数</span></span><br><span class="line">                            cycleResolve(newPromise, target, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(e);</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">this</span>.rejectedCallQueue.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> target = onrejected(<span class="keyword">this</span>.reason); <span class="comment">//将resolve函数保留的成功值传递作为参数</span></span><br><span class="line">                            cycleResolve(newPromise, target, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(e);</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> newPromise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cycleResolve</span>(<span class="params">newPromise, target, resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//禁止循环调用</span></span><br><span class="line">        <span class="keyword">if</span> (newPromise === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环调用'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            target !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (<span class="keyword">typeof</span> target === <span class="string">'object'</span> ||</span><br><span class="line">             <span class="keyword">typeof</span> target === <span class="string">'function'</span>) <span class="comment">/*确定其是一个对象*/</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> then = target.then; <span class="comment">/*确定是否是一个thenable对象*/</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                    then.call(</span><br><span class="line">                        target,</span><br><span class="line">                        (newTarget) =&gt; &#123;</span><br><span class="line">                            resolvePromise(newPromise, newTarget, resolve, reject);</span><br><span class="line">                        &#125;,</span><br><span class="line">                        (e) =&gt; &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolve(target);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，<code>Promise</code>的基本功能都已经完成，接下来我们完成剩下的一些细枝末节的东西，包括：</p>
<ol>
<li>实现<code>resolve</code>方法</li>
<li>实现<code>reject</code>方法</li>
<li>实现<code>catch</code>方法。</li>
<li>实现<code>finally</code>方法。</li>
<li>实现<code>Promise</code>的其他方法：<ol>
<li><code>Promise.all([p1, p2, p3])</code></li>
<li><code>Promise.race([p1, p2, p3])</code></li>
<li><code>Promise.allSettled(p1, p2, p3)</code></li>
<li><code>Promise.any(p1, p2, p3)</code></li>
</ol>
</li>
</ol>
<p>注意：</p>
<ol>
<li>各个函数的功能不再赘述，具体查看<a href="https://michaelwang.top/2019/06/28/Promise%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">Promise理解</a></li>
<li>下面的代码就只写对应部分，多余部分不再进行赘述。</li>
</ol>
<h2 id="实现catch方法"><a href="#实现catch方法" class="headerlink" title="实现catch方法"></a>实现catch方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(onrejected) &#123; <span class="comment">/*在class中定义catch方法*/</span></span><br><span class="line">    <span class="keyword">const</span> newPromise = <span class="keyword">new</span> Promise3(<span class="function">(<span class="params"><span class="literal">undefined</span>, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.REJECTED) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> target = onrejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                    cycleReject(newPromise, target, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(e)</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="keyword">this</span>.status_enum.PENDING) &#123;</span><br><span class="line">            <span class="keyword">this</span>.rejectedCallQueue.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> target = onrejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                        cycleReject(newPromise, target, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环reject</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cycleReject</span>(<span class="params">newPromise, target, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//禁止循环调用</span></span><br><span class="line">    <span class="keyword">if</span> (newPromise === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环调用'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        target !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (<span class="keyword">typeof</span> target === <span class="string">'object'</span> ||</span><br><span class="line">         <span class="keyword">typeof</span> target === <span class="string">'function'</span>) <span class="comment">/*确定其是一个对象*/</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> then = target.then; <span class="comment">/*确定是否是一个thenable对象*/</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                then.call(</span><br><span class="line">                    target,</span><br><span class="line">                    (newTarget) =&gt; &#123;</span><br><span class="line">                        resolvePromise(newPromise, newTarget, reject);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    (e) =&gt; &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里的操作与<code>then</code>方法逻辑基本一致，唯一不同的是，我们只需要捕捉<code>reject</code>，不捕捉<code>resolve</code>。</p>
<h2 id="实现finally"><a href="#实现finally" class="headerlink" title="实现finally"></a>实现finally</h2><p><code>Promise</code>的<code>finally</code>的方法无论<code>promise</code>的结果是成功还是失败，都会执行，并且返回该<code>promise</code>。所以实现很简单。执行其<code>promise</code>的<code>then</code>方法来获取该<code>promise</code>的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise-resolve方法-下面的方法是直接作为class的静态函数成员的"><a href="#实现Promise-resolve方法-下面的方法是直接作为class的静态函数成员的" class="headerlink" title="实现Promise.resolve方法(下面的方法是直接作为class的静态函数成员的)"></a>实现<code>Promise.resolve</code>方法(下面的方法是直接作为class的静态函数成员的)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">    <span class="comment">//如果是一个Promise</span></span><br><span class="line">    <span class="keyword">if</span>(val <span class="keyword">instanceof</span> Promise3)&#123;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    <span class="comment">//如果没有参数，或者为null,undefined</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise3(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve()&#125;)</span><br><span class="line">    <span class="comment">//参数存在但不存在then方法</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &amp;&amp; !val.then <span class="keyword">instanceof</span> <span class="built_in">Function</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise3(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//参数存在且存在then方法</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &amp;&amp; val.then <span class="keyword">instanceof</span> <span class="built_in">Function</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise3(val.then)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise-reject方法"><a href="#实现Promise-reject方法" class="headerlink" title="实现Promise.reject方法"></a>实现<code>Promise.reject</code>方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> reject(val)&#123;</span><br><span class="line">    <span class="comment">//直接将val作为理由返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(val);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>## </p>
<h2 id="实现Promise-all-p1-p2-p3"><a href="#实现Promise-all-p1-p2-p3" class="headerlink" title="实现Promise.all([p1, p2, p3])"></a>实现<code>Promise.all([p1, p2, p3])</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> all(arr) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">            arr[i].then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                res.push(v)</span><br><span class="line">                <span class="comment">//是否所有的promise都是resolve</span></span><br><span class="line">                <span class="keyword">if</span>(res.length === arr.length)&#123;</span><br><span class="line">                    <span class="keyword">return</span> resolve(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, (e) =&gt; &#123;</span><br><span class="line">                <span class="comment">//只要一个reject，直接reject</span></span><br><span class="line">                <span class="keyword">return</span> reject(e)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise-race-p1-p2-p3"><a href="#实现Promise-race-p1-p2-p3" class="headerlink" title="实现Promise.race([p1, p2, p3])"></a>实现<code>Promise.race([p1, p2, p3])</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">race</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (let i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            arr[i].then(</span><br><span class="line">                (v) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> resolve(v)</span><br><span class="line">                &#125;,</span><br><span class="line">                (e) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise-allSettled-p1-p2-p3"><a href="#实现Promise-allSettled-p1-p2-p3" class="headerlink" title="实现Promise.allSettled([p1, p2, p3])"></a>实现<code>Promise.allSettled([p1, p2, p3])</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> allSettled(arr) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            arr[i].then(</span><br><span class="line">                (v) =&gt; &#123;</span><br><span class="line">                    res.push(&#123;</span><br><span class="line">                        status: <span class="string">'fulfilled'</span>,</span><br><span class="line">                        value: v,</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;,</span><br><span class="line">                (e) =&gt; &#123;</span><br><span class="line">                    res.push(&#123;</span><br><span class="line">                        status: <span class="string">'rejected'</span>,</span><br><span class="line">                        reason: e,</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            ).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//计数器必须在这里统计，因为异步操作，若放在then中，在finally中无法读取预期的值</span></span><br><span class="line">                ++count === arr.length &amp;&amp; resolve(res)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise-any-p1-p2-p3"><a href="#实现Promise-any-p1-p2-p3" class="headerlink" title="实现Promise.any(p1, p2, p3)"></a>实现<code>Promise.any(p1, p2, p3)</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> any(arr) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            arr[i].then(</span><br><span class="line">                (v) =&gt; &#123;</span><br><span class="line">                    <span class="comment">//只要有一个resolve，则直接resolve</span></span><br><span class="line">                    <span class="keyword">return</span> resolve(v);</span><br><span class="line">                &#125;,</span><br><span class="line">                (e) =&gt; &#123;</span><br><span class="line">                    res.push(e);</span><br><span class="line">                    res.length === arr.length &amp;&amp; reject(res);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本人能力有限，可能会出现错误，谅解。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow2.0-data模块的使用</title>
    <url>/2021/09/04/Tensorflow2-0-data%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Tensorflow-data"><a href="#Tensorflow-data" class="headerlink" title="Tensorflow-data"></a>Tensorflow-data</h1><p>Tesorflow官方提供了一些数据集来供我们使用。其地址为<a href="https://tensorflow.google.cn/datasets?hl=zh_cn" target="_blank" rel="noopener">Tensorflow-data</a>，我们可以在这里查看数据集的详细细节<a href="https://tensorflow.google.cn/datasets/catalog/overview?hl=zh_cn" target="_blank" rel="noopener">Tensorflow-data-catalog</a>。</p>
<p>其API地址为<a href="https://tensorflow.google.cn/datasets/api_docs/python/tfds/all_symbols?hl=zh_cn" target="_blank" rel="noopener">API</a>。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>Tensorflow-data有137个API，一般不会全部使用。我们需要了解的第一个API是：</p>
<p><code>tfds.load</code>：从本地或网络载入数据集，并生成<code>tf.data.Dataset</code>对象。</p>
<p>其基本形式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tfds.load(</span><br><span class="line">    name: str,</span><br><span class="line">    *,</span><br><span class="line">    split: Optional[Tree[splits_lib.Split]] = <span class="literal">None</span>,</span><br><span class="line">    data_dir: Optional[str] = <span class="literal">None</span>,</span><br><span class="line">    batch_size: tfds.typing.Dim = <span class="literal">None</span>,</span><br><span class="line">    shuffle_files: bool = <span class="literal">False</span>,</span><br><span class="line">    download: bool = <span class="literal">True</span>,</span><br><span class="line">    as_supervised: bool = <span class="literal">False</span>,</span><br><span class="line">    decoders: Optional[TreeDict[decode.Decoder]] = <span class="literal">None</span>,</span><br><span class="line">    read_config: Optional[tfds.ReadConfig] = <span class="literal">None</span>,</span><br><span class="line">    with_info: bool = <span class="literal">False</span>,</span><br><span class="line">    builder_kwargs: Optional[Dict[str, Any]] = <span class="literal">None</span>,</span><br><span class="line">    download_and_prepare_kwargs: Optional[Dict[str, Any]] = <span class="literal">None</span>,</span><br><span class="line">    as_dataset_kwargs: Optional[Dict[str, Any]] = <span class="literal">None</span>,</span><br><span class="line">    try_gcs: bool = <span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>tfds.load</code>实际上是一个对内建三个方法的语法糖：</p>
<ol>
<li><p>新建一个<code>DatasetBuilder</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">builder = tfds.builder(name, data_dir=data_dir, **builder_kwargs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>为这个build下载或准备（本地则不需要下载）数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">builder.download_and_prepare(**download_and_prepare_kwargs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>载入<code>tf.data.Dataset</code>对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ds = builder.as_dataset(</span><br><span class="line">    split=split,</span><br><span class="line">    as_supervised=as_supervised,</span><br><span class="line">    shuffle_files=shuffle_files,</span><br><span class="line">    read_config=read_config,</span><br><span class="line">    decoders=decoders,</span><br><span class="line">    **as_dataset_kwargs,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>说完我们再来看每个参数解析：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>类型</th>
<th>说明</th>
<th>必须</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>String</td>
<td>数据集的名称，我们可以在<a href="https://tensorflow.google.cn/datasets/catalog/overview?hl=zh_cn" target="_blank" rel="noopener">Tensorflow-data-catalog</a>查看数据集的名字。注意这里的名字是蛇形命名法，即：a_b_c的下划线分割的形式。</td>
<td>是</td>
<td>/</td>
</tr>
<tr>
<td>split</td>
<td>String/tuple</td>
<td>如何分割数据集，主要有’train’, ‘test’两个是符串以及其tuple构成。如：<br />1: ‘train’, ‘test’，分别表示只载入训练数据，或只载入测试数据。<br />2: [‘train’, ‘test’]，表示载入训练集和测试集，此时第一个参数会返回一个list，我们可以用(train_data, test_data)来解构list。<br />3: ‘train[:120]’, ‘train[:75%]’, ‘test[25%:100%]’, ‘train[:4shard]’：如同python的list截取一样的格式，只不过这里可以是绝对值、者百分比值或者分片。片是tensorflow中的一个概念，数据集在下载时即定义好了一共多少个片，我们可以用<code>info.splits[&#39;train&#39;].num_shards</code>来查看总片数。<br />4: ‘train+test’, ‘train[:25%]+test’: 这种格式会把训练集和测试集合并在一起返回，其中每一部分都可以用列表截断。<br /><strong>值得注意的是：每个数据集支持的split的格式不同，需要我们具体来使用。</strong></td>
<td>否</td>
<td>数据集定义的划分模式</td>
</tr>
<tr>
<td>data_dir</td>
<td>String</td>
<td>写入/读取数据集的地址，我们可以更改这个地址。</td>
<td>否</td>
<td>win下：<code>C:\Users\[user]\tensorflow_datasets</code></td>
</tr>
<tr>
<td>batch_size</td>
<td>Int</td>
<td>设置一个batch的大小，这里的batch主要是针对较大的数据集，不可能将所有的数据全部读进内存，我们会一次读取一个batch进内存运算。</td>
<td>否</td>
<td>不划分batch</td>
</tr>
<tr>
<td>shuffle_files</td>
<td>Boolean</td>
<td>是否需要打乱输入数据</td>
<td>否</td>
<td>False</td>
</tr>
<tr>
<td>download</td>
<td>Boolean</td>
<td>是否是从远程下载</td>
<td>否</td>
<td>True</td>
</tr>
<tr>
<td>as_supervised</td>
<td>Boolean</td>
<td>是否是监督模式，如果是True的话， <code>tf.data.Dataset</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>decoders</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>read_config</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>with_info</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>builder_kwargs</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>download_and_prepare_kwargs</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>as_dataset_kwargs</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>try_gcs</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
        <tag>Tensorflow-data</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript特点1</title>
    <url>/2021/01/09/TypeScript%E7%89%B9%E7%82%B91/</url>
    <content><![CDATA[<h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><p>TS中增加了<code>void</code>类型，<strong>用于表示没有任何类型</strong>，一般也是<strong>用于一个函数没有返回值</strong>，但是与其他语言不同的是，TS允许一个变量直接声明为Void型（虽然这没什么用）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<p><code>void</code>型变量只能被赋值<code>undefined</code>,<code>null</code></p>
<h1 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h1><p>这里的<code>null</code>与<code>undefined</code>与JS中基本一致，其是所有类型的子类，即所有的变量都可被赋值为<code>null</code>与<code>undifined</code>。</p>
<h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p><code>never</code>表示那些永远不存在的的值的类型。从应用的角度来看，与<code>void</code>对比，<code>never</code>一般用于无法返回的函数的返回值类型。比如<strong>抛出错误的函数</strong>，<strong>死循环的函数</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>never</code>与<code>null</code>、<code>undefined</code>一致，也是所有类型子类（比<code>null</code>,<code>undefined</code>级别更低）。</p>
<p>除了上述最常用的方法，never有其他用处。比如尤雨溪谈到的收窄类型</p>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>简单说，就是在对<code>any</code>型变量操作时跳过TS在编译时的检测，对于一个<code>any</code>的变量，我们在某些特定情况下知道其必定为某种特定类型，此时调用其特定的方法。我们可以跳过编译时的检测，但是其对运行没有影响。</p>
<p>具体，形式一：“尖括号”语法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>
<p>形式二：<code>as</code>语法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure>
<p>注意，无论是否通过类型断言，没有指定属性的变量始终返回<code>undefined</code>，如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a : <span class="built_in">any</span> = <span class="number">145</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = (a <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.length);         <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);					<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><p>解构这一部分ES6也支持 ，并且我觉得这是一个非常好的特征，可以更加灵活地进行变量的交换，拆分，合并。</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>下面的形式是最简单的数组解构形式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [first, second] = input;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// outputs 2</span></span><br></pre></td></tr></table></figure>
<p>解构用于以申明的变量(交换变量是一个很好的应用)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap variables</span></span><br><span class="line">[first, second] = [second, first];</span><br></pre></td></tr></table></figure>
<p>用于函数参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first);</span><br><span class="line">    <span class="built_in">console</span>.log(second);</span><br><span class="line">&#125;</span><br><span class="line">f(input);</span><br></pre></td></tr></table></figure>
<p><strong>…语法获取剩余变量</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, ...second]: [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first);    <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(second);  <span class="comment">//[2,3,4]</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>只要位置对应，可以解构数组任何位置元素</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [first] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(fourth); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>与数组解构原理一致，只要键名一致，就可以就行解构。如，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    a: <span class="string">"foo"</span>,</span><br><span class="line">    b: <span class="number">12</span>,</span><br><span class="line">    c: <span class="string">"bar"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</span><br><span class="line"><span class="built_in">console</span>.log(a)		<span class="comment">//foo</span></span><br><span class="line"><span class="built_in">console</span>.log(b)		<span class="comment">//12</span></span><br></pre></td></tr></table></figure>
<p>也可以用没有申明的赋值：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(&#123; a, b &#125; = &#123; a: <span class="string">"baz"</span>, b: <span class="number">101</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 <code>{</code> 起始的语句解析为一个块。</p>
<p>同样，我们可以使用<code>...</code>语法进行剩余元素提取。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    a: <span class="string">"foo"</span>,</span><br><span class="line">    b: <span class="number">12</span>,</span><br><span class="line">    c: <span class="string">"bar"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;a, ...others&#125; = o;</span><br><span class="line"><span class="built_in">console</span>.log(a);				<span class="comment">//foo</span></span><br><span class="line"><span class="built_in">console</span>.log(others);		<span class="comment">//&#123; b: 12, c: 'bar' &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><p>我们也可以对提取的元素进行重命名，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a: newName1, b: newName2 &#125; = o;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是<code>:</code>不是表示类型，而是旧名字与新名字的间隔。</p>
<p>但是如果需要限制提取元素的类型，则不能进行属性重命名。</p>
<h3 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h3><p>我们可以使用<code>...</code>语法来进行数组（对象的展开），如</p>
<p>数组展开</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>]; 		<span class="comment">//bothPlus = [0,1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>对象展开</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; food: <span class="string">"spicy"</span>, price: <span class="string">"$$"</span>, ambiance: <span class="string">"noisy"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> search = &#123; name: <span class="string">"me"</span>, ...defaults &#125;;			<span class="comment">//search  = &#123;name:"me",food:"spicy", price: "$$", ambiance: "noisy" &#125;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，在对象展开中，相同的键值对会被合并！</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>这里的接口与传统面向对象语言中的接口有一定的差距，</p>
<p>在面向对象的语言中（如Java），<strong>接口是一个抽象类型，是抽象方法的集合。</strong></p>
<p>而在TS中，接口更多的是对数据及其解构进行检查。</p>
<p>下面是一个典型的用法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelledValue &#123;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">  size: int;					<span class="comment">//顺序无关</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span>&#125;;</span><br><span class="line">printLabel(myObj);										<span class="comment">//Size 10 Object</span></span><br></pre></td></tr></table></figure>
<p>与函数参数一致，接口中允许<strong>可选属性</strong>，<strong>只读属性</strong>的存在，例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;			<span class="comment">//加?可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    readonly x: <span class="built_in">number</span>;</span><br><span class="line">    readonly y: <span class="built_in">number</span>;		<span class="comment">//readonly-只读属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readonly</code> vs <code>const</code></p>
<p>readonly用于属性；</p>
<p>const用于变量；</p>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><p>这里有一点需要注意的是，如果是采用<strong>字面量形式参数</strong>时，会触发额外属性检查。如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>这里会报错：</p>
<p><em>s</em>cript.ts(6,46): error TS2355: A function whose declared type is neither ‘void’ nor ‘any’ must return a value.<em>
</em>script.ts(10,31): error TS2345: Argument of type ‘{ colour: string; width: number; }’ is not assignable to parameter of type ‘SquareConfig’.<em><br>  Object literal may only specify known properties, but ‘colour’ does not exist in type ‘SquareConfig’. Did you mean to write ‘color’?</em></p>
<p>但是我们在传参时不采用字面量对象传参，而是采用变量直接穿，则不会触发额外属性检查。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arg  = &#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(arg);</span><br></pre></td></tr></table></figure>
<p>运行正常！</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>当然TS中的接口也有传统面向对象语言中的抽象方法集合的功能。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与java不同，TS中的接口是可以直接被<strong>使用</strong>的，如，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即直接定义变量的类为接口，在Java中这是不允许的，只有实现接口后的类才能被实例化。</p>
<h4 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h4><p>这一点与java一致，接口是可以被实现的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>And，TS中接口可以多继承！</strong></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>TS中函数部分比较简单，主要仍然是格式问题</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v1: int, v2: <span class="built_in">string</span></span>) <span class="title">boolean</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的细节都是JS中的内容，此处不谈。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCODE-插件开发1</title>
    <url>/2021/04/28/VSCODE-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911/</url>
    <content><![CDATA[<p>createTextEditorDecorationType(options: DecorationRenderOptions]): TextEditorDecorationType：创建一个新的装饰器。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">options: DecorationRenderOptions</td>
<td style="text-align:left">装饰类型渲染的选项</td>
</tr>
<tr>
<td style="text-align:left"><strong>Returns</strong></td>
<td style="text-align:left"><strong>Description</strong></td>
</tr>
<tr>
<td style="text-align:left">TextEditorDecorationType</td>
<td style="text-align:left">一个新的装饰器实体</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>VS CODE插件</category>
      </categories>
      <tags>
        <tag>VS CODE插件</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript特点2</title>
    <url>/2021/01/10/TypeScript%E7%89%B9%E7%82%B92/</url>
    <content><![CDATA[<h1 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h1><p>TS中的类型兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。 与Java不同，Java的强制转换是基于继承的，只有有继承关系的对象才可以进行转换。</p>
<p>即只要对象中的成员有包含关系，则可以进行类型转换。如，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Named;</span><br><span class="line"><span class="comment">// OK, because of structural typing</span></span><br><span class="line">p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>这一点也是根据JS的灵活性设计的，JS中变量类型是自动检测的，程序员不需要专门进行规定。</p>
<h2 id="对象的兼容"><a href="#对象的兼容" class="headerlink" title="对象的兼容"></a>对象的兼容</h2><p>TS结构化类型系统的基本规则是，如果<code>x</code>要兼容<code>y</code>，（所谓<code>x</code>兼容<code>y</code>，就是<code>x</code>可以被赋值为<code>y</code>），如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Named;</span><br><span class="line"><span class="comment">// y's inferred type is &#123; name: string; location: string; &#125;</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; name: <span class="string">'Alice'</span>, location: <span class="string">'Seattle'</span> &#125;;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>
<p>称为<code>x</code>兼容<code>y</code>。</p>
<blockquote>
<p>这里要检查<code>y</code>是否能赋值给<code>x</code>，编译器检查<code>x</code>中的每个属性，看是否能在<code>y</code>中也找到对应属性。 在这个例子中，<code>y</code>必须包含名字是<code>name</code>的<code>string</code>类型成员。<code>y</code>满足条件，因此赋值正确。</p>
</blockquote>
<h2 id="函数的兼容"><a href="#函数的兼容" class="headerlink" title="函数的兼容"></a>函数的兼容</h2><h3 id="函数参数兼容"><a href="#函数参数兼容" class="headerlink" title="函数参数兼容"></a>函数参数兼容</h3><p>函数的兼容与对象的兼容相反，函数<code>x</code>的参数包含函数<code>y</code>的参数，则<code>x</code>兼容<code>y</code>。如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line">x = y; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要查看<code>x</code>是否能赋值给<code>y</code>，首先看它们的参数列表。 <code>x</code>的每个参数必须能在<code>y</code>里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，<code>x</code>的每个参数在<code>y</code>中都能找到对应的参数，所以允许赋值。</p>
<p>第二个赋值错误，因为<code>y</code>有个必需的第二个参数，但是<code>x</code>并没有，所以不允许赋值。</p>
</blockquote>
<p>这里可以理解为，在函数赋值时，函数的参数可以被忽略的，（<strong>注意：函数调用的时候仍然必须赋值相等的参数，否则采用可选参数</strong>）但是限制了不能多余参数。即<code>y</code>中的参数<code>s</code>，在被赋值给<code>x</code>的时候直接被忽略，即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JS中函数调用的灵活性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>);			<span class="comment">//参数b被忽略</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)			<span class="comment">//多加参数c</span></span><br></pre></td></tr></table></figure>
<h3 id="函数返回值兼容"><a href="#函数返回值兼容" class="headerlink" title="函数返回值兼容"></a>函数返回值兼容</h3><p>返回参数少的函数可以被赋值为参数多的函数（这里TS称参数多的为参数少的函数的子类），即源函数可以被赋值为子类，即向下转换，如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">'Alice'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> y = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">'Alice'</span>, location: <span class="string">'Seattle'</span>&#125;);</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// OK</span></span><br><span class="line">y = x; <span class="comment">// Error, because x() lacks a location property</span></span><br></pre></td></tr></table></figure>
<h3 id="类的兼容"><a href="#类的兼容" class="headerlink" title="类的兼容"></a>类的兼容</h3><p>类的兼容只比较实例成员。静态部分不会被比较。（仍然是基于成员的比较，而不是Java中的继承），如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    feet: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Size &#123;</span><br><span class="line">    feet: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">numFeet: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal;</span><br><span class="line"><span class="keyword">let</span> s: Size;</span><br><span class="line"></span><br><span class="line">a = s;  <span class="comment">// OK</span></span><br><span class="line">s = a;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="交叉类型（Intersection-Types）"><a href="#交叉类型（Intersection-Types）" class="headerlink" title="交叉类型（Intersection Types）"></a>交叉类型（Intersection Types）</h2><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， <code>Person &amp; Serializable &amp; Loggable</code>同时是 <code>Person</code> <em>和</em> <code>Serializable</code> <em>和</em> <code>Loggable</code>。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>
<p>通俗的讲，就是包含所有成员类型的成员属性。如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;				<span class="comment">//将T与U成员变量混合成为新的变量，并返回该变量，返回时采用交叉类型而不是any</span></span><br><span class="line">    <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">        (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">    log(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">    log() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">"Jim"</span>), <span class="keyword">new</span> ConsoleLogger());</span><br><span class="line"><span class="keyword">var</span> n = jim.name;</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure>
<h2 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h2><p>形式：A|B|C</p>
<p>含义：</p>
<p>作为参数时，仅支持A类或B类或C类，其他类型数据均不被接接受。如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">value: <span class="built_in">number</span>|<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>);			<span class="comment">//正常</span></span><br><span class="line">f(<span class="string">"1"</span>);			<span class="comment">//正常</span></span><br><span class="line">f(<span class="literal">true</span>);		<span class="comment">//失败</span></span><br></pre></td></tr></table></figure>
<p>作为返回值时：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">    fly();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    swim();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// okay</span></span><br><span class="line">pet.swim();    <span class="comment">// errors</span></span><br></pre></td></tr></table></figure>
<p>由于返回的是A|B,所以我们只能访问A与B的交叉成员。</p>
<h3 id="类型保护与区分类型（Type-Guards-and-Differentiating-Types）"><a href="#类型保护与区分类型（Type-Guards-and-Differentiating-Types）" class="headerlink" title="类型保护与区分类型（Type Guards and Differentiating Types）"></a>类型保护与区分类型（Type Guards and Differentiating Types）</h3><p>联合类型可以使我们接受多种特定类型的参数，但是我们要在函数内部更具参数类型执行特定的操作时又该如何判断呢。下面的写法是错误的，因为联合类型在访问任何独有参数时，都会发生错误。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.swim) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pet.fly) &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使代码工作，必须使用<strong>类型断言</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class="line">    (&lt;Fish&gt;pet).swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h4><p>注意到，这种写法，我们在任何时候调用参数属性时，都必须加上类型断言。我们可以采用另外一种写法使之后的参数调用不再加上类型断言。</p>
<p>TS中的<em>类型保护</em>机制使之成为现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 <em>类型谓词</em>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子里， <code>pet is Fish</code>就是类型谓词。 谓词为 <code>parameterName is Type</code>这种形式， <code>parameterName</code>必须是来自于当前函数签名里的一个参数名。</p>
<p>每当使用一些变量调用 <code>isFish</code>时，TypeScript会将变量<strong>缩减</strong>为那个具体的类型（<strong>在以后对应分支中的参数的每次调用都会被识别为该类型</strong>），只要这个类型与变量的原始类型是兼容的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 'swim' 和 'fly' 调用都没有问题了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="typeof类型保护"><a href="#typeof类型保护" class="headerlink" title="typeof类型保护"></a>typeof类型保护</h5><p>实际上我们可以发现，在上面的断言函数中执行的内容就是判断参数是否为对应类型，是返回<code>true</code>，否返回<code>false</code>，所以我们在断言函数内部可以使用<code>typeof</code>来进行判断。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"number"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"string"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNumber(padding)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isString(padding)) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，对于原始类型（<code>number, string, boolean, symbol</code>），TS直接将<code>typeof</code>识别为断言函数，而不必我们每次都为原始类型类型编写一个断言。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"string"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些<em> <code>typeof</code>类型保护</em>只有两种形式能被识别： <code>typeof v === &quot;typename&quot;</code>和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code>或 <code>&quot;symbol&quot;</code>。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p>
<h4 id="instanceof类型保护"><a href="#instanceof类型保护" class="headerlink" title="instanceof类型保护"></a>instanceof类型保护</h4><p>对于非原始类型，如何做到类型判断并收紧呢？TS提供了<code>instanceof</code>类型保护，也可以避免我们重写断言函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">    getPaddingString(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SpaceRepeatingPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> StringPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">        <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>) :</span><br><span class="line">        <span class="keyword">new</span> StringPadder(<span class="string">"  "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为SpaceRepeatingPadder | StringPadder</span></span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为'SpaceRepeatingPadder'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为'StringPadder'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>instanceof</code>的右侧要求是一个构造函数，TypeScript将细化为：</p>
<ol>
<li>此构造函数的 <code>prototype</code>属性的类型，如果它的类型不为 <code>any</code>的话</li>
<li>构造签名所返回的类型的联合</li>
</ol>
<h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4><p>TS将null，undefined视为两种不同的类型，他们不能被赋值给任何其他类型的参数。如官方文档所说：</p>
<p>注意，按照JavaScript的语义，TypeScript会把 <code>null</code>和 <code>undefined</code>区别对待。 <code>string | null</code>， <code>string | undefined</code>和 <code>string | undefined | null</code>是不同的类型。</p>
<h4 id="可选参数与可选属性"><a href="#可选参数与可选属性" class="headerlink" title="可选参数与可选属性"></a>可选参数与可选属性</h4><p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + (y || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>);</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">null</span>); <span class="comment">// error, 'null' is not assignable to 'number | undefined'</span></span><br></pre></td></tr></table></figure>
<p>也就是说，可选属性可以被赋值为undefined作为占位参数，但是不能被赋值为null。</p>
<p>同样的，可选属性也可被赋值为undefined作为占位参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">    b?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.a = <span class="number">12</span>;</span><br><span class="line">c.a = <span class="literal">undefined</span>; <span class="comment">// error, 'undefined' is not assignable to 'number'</span></span><br><span class="line">c.b = <span class="number">13</span>;</span><br><span class="line">c.b = <span class="literal">undefined</span>; <span class="comment">// ok</span></span><br><span class="line">c.b = <span class="literal">null</span>; <span class="comment">// error, 'null' is not assignable to 'number | undefined'</span></span><br></pre></td></tr></table></figure>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>形如C中的<code>typedef</code>语法，TS提供了类型别名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>起别名不会新建一个类型 - 它创建了一个新 <em>名字</em>来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p>
<p>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Container&lt;T&gt; = &#123; value: T &#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用类型别名来在属性里引用自己：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</span><br><span class="line">    value: T;</span><br><span class="line">    left: Tree&lt;T&gt;;</span><br><span class="line">    right: Tree&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型别名只能出现在申明的左侧。</p>
<h4 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h4><p>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">"ease-in"</span> | <span class="string">"ease-out"</span> | <span class="string">"ease-in-out"</span>;</span><br><span class="line"><span class="keyword">class</span> UIElement &#123;</span><br><span class="line">    animate(dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (easing === <span class="string">"ease-in"</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-out"</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-in-out"</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// error! should not pass null or undefined.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement();</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"ease-in"</span>);</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"uneasy"</span>); <span class="comment">// error: "uneasy" is not allowed here</span></span><br></pre></td></tr></table></figure>
<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Argument of type &#39;&quot;uneasy&quot;&#39; is not assignable to parameter of type &#39;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#39;</span><br></pre></td></tr></table></figure>
<h4 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h4><p>TypeScript还具有数字字面量类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rollDie</span>(<span class="params"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="number">1</span> || x !== <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//         ~~~~~~~</span></span><br><span class="line">        <span class="comment">// Operator '!==' cannot be applied to types '1' and '2'.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换句话说，当 <code>x</code>与 <code>2</code>进行比较的时候，它的值必须为 <code>1</code>，这就意味着上面的比较检查是非法的。</p>
<h4 id="可辨识联合（Discriminated-Unions）"><a href="#可辨识联合（Discriminated-Unions）" class="headerlink" title="可辨识联合（Discriminated Unions）"></a>可辨识联合（Discriminated Unions）</h4><p>你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 <em>可辨识联合</em>的高级模式，它也称做 <em>标签联合</em>或 <em>代数数据类型</em>。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：</p>
<ol>
<li>具有普通的单例类型属性— <em>可辨识的特征</em>。</li>
<li>一个类型别名包含了那些类型的联合— <em>联合</em>。</li>
<li>此属性上的类型保护。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: <span class="string">"square"</span>;</span><br><span class="line">    size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">    kind: <span class="string">"rectangle"</span>;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: <span class="string">"circle"</span>;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们声明了将要联合的接口。 每个接口都有 <code>kind</code>属性但有不同的字符串字面量类型。 <code>kind</code>属性称做 <em>可辨识的特征</em>或 <em>标签</em>。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle;</span><br></pre></td></tr></table></figure>
<p>现在我们使用可辨识联合:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h1><p>这个部分也是ES6的引入一种新的原生类型，如<code>number</code>，<code>string</code>。</p>
<p>其特点是<strong>唯一</strong>，一个symbols是唯一独特的，无法改变的。即使两个<code>symbol</code>输入的<code>key</code>一样，这两个值仍然是完全不同的。</p>
<p><code>symbol</code>类型的值是通过<code>Symbol</code>构造函数创建的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym2 = Symbol(<span class="string">"key"</span>); <span class="comment">// 可选的字符串key</span></span><br></pre></td></tr></table></figure>
<p>Symbols是不可改变且唯一的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym2 = Symbol(<span class="string">"key"</span>);</span><br><span class="line"><span class="keyword">let</span> sym3 = Symbol(<span class="string">"key"</span>);</span><br><span class="line"></span><br><span class="line">sym2 === sym3; <span class="comment">// false, symbols是唯一的</span></span><br></pre></td></tr></table></figure>
<p>像字符串一样，symbols也可以被用做对象属性的键。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [sym]: <span class="string">"value"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]); <span class="comment">// "value"</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-review-router</title>
    <url>/2019/03/20/Vue-review-router/</url>
    <content><![CDATA[<h1 id="最基本的一个路由展示域"><a href="#最基本的一个路由展示域" class="headerlink" title="最基本的一个路由展示域"></a>最基本的一个路由展示域</h1><ol>
<li><p>在Vue控制域中写入router规定的标签</p>
<ol>
<li><router-link to="/login">Go to Login</router-link>  //该项为路由的链接，默认为a标签</li>
<li><router-link to="/register">Go to Register</router-link>//该项为路由的链接，默认为a标签</li>
<li><p><router-view></router-view>   //该项为渲染路由组件的位置</p>
<p><strong>以下步骤一般不能交换，因为存在相互依赖关系</strong></p>
</li>
</ol>
</li>
</ol>
<a id="more"></a>
<ol start="2">
<li>创建组件模板</li>
</ol>
<pre><code>const login = {template:&apos;&lt;h1\&gt;这是一个登录框&lt;/h1\&gt;&apos;};

const register = {template:&apos;&lt;h1\&gt;这是一个注册框&lt;/h1\&gt;&apos;};
</code></pre><ol start="3">
<li><p>创建一个routes对象作为VueRouter的参数</p>
<pre><code>const routes = [
{path:&apos;/login&apos;,component:login},
{path:&apos;/register&apos;,component:register}
]
</code></pre></li>
<li><p>创建一个VueRouter实例，并将上面的routes作为参数，<strong>值得注意的是，这里的参数名字是<code>routes</code>，下面是使用ES6的写法简写对象名</strong></p>
<p> const router = new VueRouter({</p>
<pre><code>    routes
})
</code></pre></li>
<li><p>创建Vue实例，<strong>值得注意的是，这之中的路由参数为<code>router</code>，下面是使用ES6的写法简写对象名</strong></p>
<pre><code>const vm = new Vue({
    el:&apos;#app&apos;,
    router
})
</code></pre></li>
</ol>
<h1 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h1><p>需要添加的是,在创建routes对象时</p>
<pre><code>    //创建一个routes对象
const routes = [
    //这里是重要点，给需要添加默认路由的加路由加上redirect属性，其值为要转向的路由地址
    {path:&apos;/&apos;,redirect:&quot;/login&quot;},
    {path:&apos;/login&apos;,component:login},
    {path:&apos;/register&apos;,component:register}
]
</code></pre><h1 id="子路由的使用"><a href="#子路由的使用" class="headerlink" title="子路由的使用"></a>子路由的使用</h1><p><strong>JavaScript：</strong></p>
<pre><code>&lt;script&gt;
//创建模板
const teacher = {template:&quot;#teacher&quot;};
const student = {template:&quot;#student&quot;}

const teacherName = {template:&quot;&lt;h1&gt;这是老师的名字&lt;/h1&gt;&quot;}
const studentName = {template:&quot;&lt;h1&gt;这是学生的名字&lt;/h1&gt;&quot;}
const teacherId = {template:&quot;&lt;h1&gt;这是老师的序号&lt;/h1&gt;&quot;}
const studentId = {template:&quot;&lt;h1&gt;这是学生的序号&lt;/h1&gt;&quot;}
//创建父级routes对象
routes = [
    {
        path:&apos;/student&apos;,
        component:student,
        //注意这里子路由的申明的方式
        children:[
            {path:&apos;name&apos;,component:studentName},
            {path:&apos;id&apos;,component:studentId}
        ]
    },
    {
        path:&apos;/teacher&apos;,
        component:teacher,
        children:[
            {path:&apos;name&apos;,component:teacherName},
            {path:&apos;id&apos;,component:teacherId}
        ]
        }
]

//创建VueRouter实例
const router = new VueRouter({
    routes
})

//创建Vue实例
const vm = new Vue({
    el:&quot;#app&quot;,
    router
})
&lt;/script&gt;
</code></pre><p><strong>body</strong></p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
        &lt;router-link to=&quot;/student&quot;&gt;student&lt;/router-link&gt;
        &lt;router-link to=&quot;/teacher&quot;&gt;teacher&lt;/router-link&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;

    //注意这里在模板中申明子路由的link和view
    &lt;template id=&quot;teacher&quot;&gt;
        &lt;div&gt;
            &lt;router-link to=&quot;/teacher/name&quot;&gt;这是老师的名字 &lt;/router-link&gt;
            &lt;router-link to=&quot;/teacher/id&quot;&gt;这是老师的id&lt;/router-link&gt;
            &lt;router-view&gt;&lt;/router-view&gt;
        &lt;/div&gt;
    &lt;/template&gt;


    //注意这里在模板中申明子路由的link和view
    &lt;template id=&quot;student&quot;&gt;
        &lt;div&gt;
            &lt;router-link to=&quot;/student/name&quot;&gt;这是学生的名字 &lt;/router-link&gt;
            &lt;router-link to=&quot;/student/id&quot;&gt;这是学生的id&lt;/router-link&gt;
            &lt;router-view&gt;&lt;/router-view&gt;
        &lt;/div&gt;
    &lt;/template&gt;
</code></pre><h1 id="带名视图"><a href="#带名视图" class="headerlink" title="带名视图"></a>带名视图</h1><p><strong>body</strong></p>
<pre><code>&lt;div id=&quot;app&quot;&gt;

        //注意下面的router-view中都是带有name属性的

        &lt;h1&gt;这里是默认视图&lt;/h1&gt;
        &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt;

        &lt;h1&gt;这里只显示学生的视图&lt;/h1&gt;
        &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt;

        &lt;h1&gt;这里只显示老师的视图&lt;/h1&gt;
        &lt;router-view name=&quot;tea&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt;
    &lt;/div&gt;

&lt;template id=&quot;default&quot;&gt;
    &lt;div&gt;
        &lt;h1&gt;这是默认的展示页面&lt;/h1&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;template id=&quot;stu&quot;&gt;
    &lt;div&gt;
        &lt;h1&gt;这是学生的展示页面&lt;/h1&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;template id=&quot;tea&quot;&gt;
    &lt;div&gt;
        &lt;h1&gt;这是老师的展示页面&lt;/h1&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><p><strong>js部分</strong></p>
<pre><code>//创建模板
   const defaultView = {template:&quot;#default&quot;};
   const stuView = {template:&quot;#stu&quot;};
   const teaView = {template:&quot;#tea&quot;};

   //创建路由参数,这里是关键，component的value可以是一个对象，该对象的键值就是视图的名字和模板对应的名字
   const routes = [
       {
           path:&quot;/&quot;,
           components:{
               default:defaultView,
               stu:stuView,
               tea:teaView
           }
       }
   ]

   //创建路由实例
   const router = new VueRouter({
       routes
   })

   //创建Vue实例
   const vm = new Vue({
       el:&quot;#app&quot;,
       router
   })
</code></pre>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>VueRouter</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中动态添加路由的问题</title>
    <url>/2020/01/06/Vue%E4%B8%AD%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="起始"><a href="#起始" class="headerlink" title="起始"></a>起始</h1><p>前端的权限控制一直是一个可繁可简的问题，要想简单，直接写入所有路由，然后将每个路由的权限写入路由原信息中，然后在<code>router.beforeEach</code>中判断这个路由是否该用户的权限，进行<code>reject()</code>或者<code>next()</code>。这样做很简单，但是Vue提供了一个<code>addRouter</code>的api，用于动态注册路由，由此可以用这个api来根据用户角色进行动态路由注入。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="动态注入路由后404问题"><a href="#动态注入路由后404问题" class="headerlink" title="动态注入路由后404问题"></a>动态注入路由后404问题</h2><p>一般我们将公共路由放置到路的初始化中，这其中就包括<strong>404页面</strong>，他的path一般是<strong>*</strong>,也就是匹配所有路由，因此Vue官方文档中提到：</p>
<blockquote>
<p>当使用<em>通配符</em>路由时，请确保路由的顺序是正确的，也就是说含有<em>通配符</em>的路由应该放在最后。路由 <code>{ path: &#39;*&#39; }</code> 通常用于客户端 404 错误。</p>
</blockquote>
<p>所以我们一般将404放到静态路由的最后一个，但是当我们动态注入路由后，理论上来说，<code>404</code>的优先级应该比我动态注入的路由高，所以我第一使用动态注入时，所有页面跳转至<code>404</code>页面。开始以为是注入失败，后来将404页面删除就能够正常跳转了。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol>
<li><p>所以我参照了<code>element-ui-admin</code>中的思路，没有使用<code>*</code>来匹配404页面，而是在<code>router.beforeEach</code>中，判断路由是否存在，手动跳转路由。</p>
</li>
<li><p>我在今天(2020-1-6)再次测试，发现<code>Vue-router</code>似乎对<code>*</code>进行了优化，即使将<code>*</code>的路由放到任意位置，包括首位，也会正确匹配路由，即当前所有路由中不存在时，才回去主动匹配<code>*</code>里有。当前使用的版本是：<code>Vue(2.6.10)</code>，<code>Vue-router(3.1.3)</code>，但是仅仅对<code>*</code>做了优化，其他通配符，比如<code>/*</code>并没有优化。</p>
</li>
</ol>
<p>综合就是如果Vue-router版本够高，则可以使用<code>*</code>的方式来进行通配页面。</p>
<h2 id="刷新路由消失的问题"><a href="#刷新路由消失的问题" class="headerlink" title="刷新路由消失的问题"></a>刷新路由消失的问题</h2><p>还有一个问题就是如果用户主动刷新浏览器，那么动态注入的路由就会生效，但是浏览器url并不会变，这个时候又会跳转至404。我这里采用的比较简答的方法就是在Vue实例初始化的时候进行重新注入。</p>
<ul>
<li>在用户登录时将其用户标识信息存储至SessionStorage。</li>
<li>在Vue实例初始化时（第一次或刷新），首先应该是判断token，如果token失效，直接跳转至登录页。</li>
<li>如果token有效，再通过sessionStorage获取用户标识符，请求后端用户权限等级。再进行路由注入，并跳转至权限对应的页面。</li>
</ul>
<p>因为刷新过程中整个页面的数据都会重新载入，所以我们必须使用一个持久化的容器，<code>sessionStorage</code>,<code>localStorage</code>,<code>cookie</code>都可以，但是我们不能将权限信息直接明文放到这些容器中，要么加密，要么只存储标识符，通过标识符再请求用户信息。</p>
<h1 id="用户退出的问题"><a href="#用户退出的问题" class="headerlink" title="用户退出的问题"></a>用户退出的问题</h1><p>使用<code>router.addRouter</code>的问题在于官方只提供了增加路由的api，并没有提供一个清除路由的api，这就导致如果同一个页面两个用户先后登录，那么就会出现路由重复注入，或者越级路由暴露的问题。经过查找资料，目前有两个主流的办法：</p>
<ol>
<li><p>直接<code>location.reload()</code>刷新页面，重置整个Vue实例，路由当然也被重置。</p>
<ol>
<li>优点<ul>
<li>方便，一行代码解决问题。</li>
</ul>
</li>
<li>缺点<ul>
<li>如果页面应用过大，那么重新载入可能会花费一定的时间，会给用户不好的体验。</li>
</ul>
</li>
</ol>
</li>
<li><p>使用hack的方法，直接创建一个新的<code>VueRouter</code>，并将静态路由添加到新的路由中去，然后用新<code>Router</code>的<code>matcher</code>去替换就<code>Router</code>的<code>matcher</code>，这样相当于变相的清除了动态注入的路由。</p>
<ol>
<li><p>优点</p>
<ul>
<li>解决了上面刷新页面的问题。</li>
</ul>
<ol start="2">
<li>缺点</li>
</ol>
<ul>
<li>官方没有提过使用该方法，所以可能会存在一定的问题，但是我发现<code>element-ui-admin</code>中也是使用的这个方法来实现路由清除，所以目前应该是不会有太大的问题。版本更新后就不一定了，也许后续官方就会推出清除路由的api。</li>
</ul>
<p>附代码：</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    静态路由</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resetRouter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = createRouter();</span><br><span class="line">  router &amp;&amp; (router.matcher = newRouter.matcher);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;resetRouter&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>动态路由</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中局部修改组件样式</title>
    <url>/2019/11/17/Vue%E4%B8%AD%E5%B1%80%E9%83%A8%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Vue如何修改子组件样式"><a href="#Vue如何修改子组件样式" class="headerlink" title="Vue如何修改子组件样式"></a>Vue如何修改子组件样式</h1><p>在使用element-ui或者i-view这些第三方样式库时，我们有时会想只在某一个组件中局部修改库中的样式而部影响全局样式。</p>
<p><strong>首先我们需要打开控制器找到对应组件的CSS样式的类名或者id</strong></p>
<p>有以下几种方式</p>
<h2 id="不在style样式上添加scope属性"><a href="#不在style样式上添加scope属性" class="headerlink" title="不在style样式上添加scope属性"></a>不在style样式上添加scope属性</h2><pre><code>&lt;template&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;el-input&gt;&lt;/el-input&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
    .father el-input{
        color:red;
    }
&lt;/style&gt;
</code></pre><p>这样相当于只修改father类下的el-input的属性。</p>
<h2 id="使用-gt-gt-gt-穿透"><a href="#使用-gt-gt-gt-穿透" class="headerlink" title="使用 &gt;&gt;&gt; 穿透"></a>使用 &gt;&gt;&gt; 穿透</h2><h3 id="scope的用处"><a href="#scope的用处" class="headerlink" title="scope的用处"></a>scope的用处</h3><p><em>scoped是Vue里面style标签的一个特殊属性，当一个style标签拥有scoped属性的时候，就相当于说明它里面的样式只作用于当前这个Vue页面，不会污染到全局的样式，从而实现了组件样式的模块化，那么它是怎么实现的呢？其实如果我们给style标签加上了scoped属性，在编译的时候，他会给我们组件里面的每一个样式加一个自定义的属性data-v-5558821a,从而通过给含有这个自定义属性的标签加上样式，从而实现了部分样式的穿透。</em></p>
<pre><code>&lt;template&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;el-input&gt;&lt;/el-input&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
    .father &gt;&gt;&gt; el-input{
        color:red;
    }
&lt;/style&gt;
</code></pre><h2 id="如果使用的是less或者sass"><a href="#如果使用的是less或者sass" class="headerlink" title="如果使用的是less或者sass"></a>如果使用的是less或者sass</h2><p>可以将 <strong>&gt;&gt;&gt;</strong> 换为 <strong>/deep/</strong></p>
<pre><code>&lt;style scoped&gt;
    .father /deep/ el-input{
        color:red;
    }
&lt;/style&gt;
</code></pre>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中异步请求更新data导致数据变为非响应式的问题</title>
    <url>/2020/01/05/Vue%E4%B8%AD%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9B%B4%E6%96%B0data%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E5%8F%98%E4%B8%BA%E9%9D%9E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近在项目遇到一个棘手的问题，看了1天才发现是异步与Vue的数据更新机制导致了结果与预期不一致。</p>
<h2 id="最开始的代码流程是这样："><a href="#最开始的代码流程是这样：" class="headerlink" title="最开始的代码流程是这样："></a>最开始的代码流程是这样：</h2><ol>
<li>通过一个请求拿到一组数据data1，包括下一个请求的关键字</li>
<li>在第一个请求的回掉函数中使用for循环利用上一个数组的关键字发送多个子请求得到对应的datan，并在每个子请求的回调中对data1和datan进行对比，然后给data1添加一个字段key</li>
<li>在第一个请求的回调中把修改后的data1赋给Vue实例的data中</li>
</ol>
<h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h2><p>在Vue实例中的data1对象中，原来的数据都是响应式的，但是我后来添加的数据并不是响应式的，导致DOM不更新。</p>
<h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>产生问题后我先后大概经过了3次修改来解决这个问题：</p>
<h2 id="思路一：data转换为响应式的时间"><a href="#思路一：data转换为响应式的时间" class="headerlink" title="思路一：data转换为响应式的时间"></a>思路一：data转换为响应式的时间</h2><p>首先我从响应式这个角度去分析，Vue是在哪个生命周期函数内将data挂载到Vue实例中的(因该是在beforeCreate与created之间)，而我做这些操作是在mounted，所以此时data因该已经被挂载到了Vue实例中，后来我又在思考JS中存在变量提升，是不是Vue中也存在，即是否在mounted中存在譬如<code>this.xxx = yyy</code>这样的语句会被提升到其他语句之前执行，yyy的内存地址提前就会被写入到this.xxx的位置，然后在这个内存地址被赋值时就将其变为响应式，所以第一次data1被赋值为一个数组时他是响应式的，但是后面对这个内存地址的变量进行的操作是为数组内的对象进行赋值<code>this.data1[i].key = val</code>，这样的赋值是无法被Vue探测到的，所以其后添加的属性无法变为响应式。这样子似乎一切都说的通，但是关键是这种<strong>变量提升</strong>这个东西我之前从未在Vue中遇到过，我查阅资料也发现根本不存在这种机制。于是这个说法被PASS。</p>
<p>不过这个过程中我也复习了一下生命周期函数和Vue中数组对象的处理：</p>
<h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p>引用官方的一张图：</p>
<p><img src="\images\Vue中异步请求更新data导致数据变为非响应式的问题\lifecycle.png" style="zoom:50%;" /></p>
<p>值得注意的是：data，methods等都是在beforeCreated与created之间进行的。经常使用的mounted已经是在模板已经编译完成之后了。</p>
<h3 id="Vue中对数组和对象的处理"><a href="#Vue中对数组和对象的处理" class="headerlink" title="Vue中对数组和对象的处理"></a>Vue中对数组和对象的处理</h3><p>对于动态更新DOM最基本的原理是定义一个变量的getter和setter，在其中触发更新DOM操作，对于数组，我们整个赋值，我们可以使用getter和setter监听，但是如果我们操作数组内部的元素，比如arr[1] = 0，这样的操作我们是无法监听到的，因此在Vue中，如果这样给data赋值，这个值并不会变为响应式，而是一个普通的值。具体有</p>
<ol>
<li>数组<ol>
<li>通过索引去修改数组中的值，arr[i] = val</li>
<li>直接修改数组的长度，arr.length = n</li>
</ol>
</li>
<li>对象<ol>
<li>给对象添加属性（包括data根节点，比如没有在data中初始化某个值，在后续直接使用this.data1 = {}，这样data1无法变为响应式，dev模式下console会报错）</li>
<li>删除对象属性，（包括data根节点）</li>
</ol>
</li>
</ol>
<p>对于以上的问题，Vue提供了<code>vm.$set</code>这个api来解决。</p>
<p>对于数组的第一个问题，可以使用以下方式来解决：</p>
<p><code>vm.$set(vm.data1,index,val)</code></p>
<p>对于数组的第二个问题，可以使用数组的方法来解决：</p>
<p><code>vm.data1.splice(3)</code> //data1会被切割为0-3项</p>
<p>原因是Vue在内部也修改了Array原型链上的方法，使其能够被Vue监听到，包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<h2 id="思路二：请求异步的问题"><a href="#思路二：请求异步的问题" class="headerlink" title="思路二：请求异步的问题"></a>思路二：请求异步的问题</h2><p>这一次我似乎意识到了可能是异步的问题，因为之前玩canvas时，也是一直结果达不到预期，结果是img标签的onload事件是一个异步事件，导致结果不对。再仔细看这次的代码，可以发现，<strong>在第一次请求回调内部，由于接下来的子请求又是异步事件，所以直接执行了最后的this.data1 = data1。在子请求回掉函数执行时，data1已经被挂载到vm.data中，此时再对其进行添加属性处理，相当于是上面的对象添加属性的问题。所以必然是非响应式的。</strong>于是我this.data1 = data1放到子请求的回调中，每接受一次回调执行一次，虽然感觉这样很消耗性能。</p>
<p>但是结果是，data1数组中只有一个值的属性变为了响应式，其他的数组值仍然是非响应的。。。至少结果逼近真相了。</p>
<h2 id="思路三：Vue对于data赋值的性能优化"><a href="#思路三：Vue对于data赋值的性能优化" class="headerlink" title="思路三：Vue对于data赋值的性能优化"></a>思路三：Vue对于data赋值的性能优化</h2><p>在Vue中，有一个<strong>异步更新队列</strong>，在Vue检测到data的值改变时，会将其写入异步更新队列中，在下一个事件循环中去进行DOM跟新等等。并且在这个队列中，会对数据写入进行优化，比如this.data1原来等于1,接下来执行了两句赋值，<code>this.data1 = 3;this.data1 =  1;</code>并且这两句在同一个tick（事件循环队列）中，那么Vue就不会对data1进行操作了。</p>
<p>那么这里极可能是在极短的时间内对data1进行了两次赋值，Vue将这两次操作优化，第一次是整个赋值，第二个则只对修改的部分进行了变更，但是前面又说道，Vue没办法探测数据内容或对象属性的添加操作。所以第一个是响应式的，而第二个则不是响应式的。</p>
<p>所以唯一的解决办法就是只进行一次data1的根赋值，所以我想到了 <code>axios.all</code>这个api，它是在所有请求完成之后返回并进行回调函数。在该回调函数中进行数据处理，再直接将data1赋给vm实例上。</p>
<p><strong>成功解决</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是不太够仔细，异步这样的问题不能立即看出来，导致前面走了很大的弯，还好后面分析过程比较正确，找到了问题所在。不过也好，重温了一下，生命周期，Vue对数组和对象的处理等等。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>axios</tag>
        <tag>响应式数据</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC参数解析全解与JSON属性分解</title>
    <url>/2022/06/21/SpringMVC%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%85%A8%E8%A7%A3%E4%B8%8EJSON%E5%B1%9E%E6%80%A7%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="PRE-HTTP请求"><a href="#PRE-HTTP请求" class="headerlink" title="PRE-HTTP请求"></a>PRE-HTTP请求</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/images/SpringMVC参数解析全解与JSON属性分解/HTTP请求结构.jpeg" alt="HTTP请求结构"></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="/images/SpringMVC参数解析全解与JSON属性分解/HTTP请求实例.png" alt="HTTP请求实例"></p>
<h1 id="处理函数"><a href="#处理函数" class="headerlink" title="处理函数"></a>处理函数</h1><p>处理函数可以通过多种方式定义，其最主要还是通过注解方式，即<code>@RequestMapping</code>方式。Spring为不同的HTTP方法提供了简化的注解，分别如下：</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>另外还可以在<code>WebConfig</code>中手动配置，但这种方法用得不多，这里就不再赘述。</p>
<h2 id="处理函数接受的参数"><a href="#处理函数接受的参数" class="headerlink" title="处理函数接受的参数"></a>处理函数接受的参数</h2><p>处理函数由于本质上还是由SpringMVC来调用，因此SpringMVC是可以通过反射获取到特定处理函数的参数列表的。所以SpringMVC提供了灵活的参数选择，可以填写多种参数，具体如下表：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerWebExchange</code></td>
<td>获取一个<code>ServerWebExchange</code>对象，这个对象是由Spring定义的一个类，其相当于是整个HTTP过程的容器，可以从中获取request，response或者attributes等。</td>
</tr>
<tr>
<td><code>ServerHttpRequest</code><br /><code>ServerHttpResponse</code></td>
<td>获取一个原始的HTTP request或者response对象</td>
</tr>
<tr>
<td><code>WebSession</code></td>
<td>获取一个session对象。（如果不增加session值，不会新创建session）</td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td>获取一个Spring Security的Principal对象，实际上就是当前用户认证信息。（但用的不多，需要时再研究）</td>
</tr>
<tr>
<td><code>org.springframework.http.HttpM ethod</code></td>
<td>获取当前请求的HTTP方法。（既然定义了，肯定是知道方法的，所以用得也不多）</td>
</tr>
<tr>
<td><code>java.util.Locale</code></td>
<td>获取当前请求的Locale对象，可以通过配置<code>LocaleResolver/LocaleContextResolver</code>来决定。</td>
</tr>
<tr>
<td><code>java.util.TimeZone</code><br /><code>java.time.ZoneId</code></td>
<td>获取当前request的时区对象，也是由<code>LocaleContextResolver</code>来决定。</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>获取URL模板变量。详细见下</td>
</tr>
<tr>
<td><code>@MatrixVariable</code></td>
<td>获取在URL中定义的通过分号间隔的键值对变量。详细见下</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>获取Servlet request的请求参数。参数值会转换到指定的类型。详细见下<br />（<code>@RequestParam是可选的，简单类型如果不加，则相当于加上了该注解。</code>）</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>获取请求头部。头部值会被转换为指定的类型。详细见下</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>获取指定cookie值。cookie值会被转换为指定类型。详细见下</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>获取HTTP请求的body部分。body部分会通过<code>HttpMessageConverter</code>实例来转换为方法中给出的目标参数类型。详细见下</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code></td>
<td>获取请求的header和body。body部分会通过<code>HttpMessageConverter</code>实例来转换为方法中给出的目标参数类型。</td>
</tr>
<tr>
<td><code>@RequestPart</code></td>
<td>获取<code>multipart/form-data</code>请求中的一个部分。</td>
</tr>
<tr>
<td><code>java.util.Map</code><br /><code>org.springframework.ui.Model</code><br /><code>org.springframework.ui.ModelMa p</code></td>
<td>用在模板系统中的注入的变量。（待确定）</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>通过应用数据绑定和验证访问模型中的现有属性(如果不存在，则实例化)。（待确定）</td>
</tr>
<tr>
<td><code>Errors</code><br /><code>BindingResult</code></td>
<td>获取验证和绑定对象时的错误。(必须在验证过的方法参数之后立即声明Errors或BindingResult参数。)</td>
</tr>
<tr>
<td><code>SessionStatus</code><br />class-level<code>@SessionAttributes</code></td>
<td></td>
</tr>
<tr>
<td><code>UriComponentsBuilder</code></td>
<td>用于获取相对于当前请求的主机、端口、方案和上下文路径的URL。</td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td>用于获取会话属性-与存储在会话中的作为类级别结果的模型属性相反<code>@SessionAttributes</code>声明。</td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td>获取请求的参数。即request的attribute。</td>
</tr>
<tr>
<td>其他类型参数</td>
<td>如果这个参数不匹配以上任意的参数。则如果是简单类型，就默认添加<code>@RequestParam</code>，否则就默认添加<code>@ModelAttribute</code>。</td>
</tr>
</tbody>
</table>
<h2 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>从HTTP协议种得到的数据归根到底都是字符串，而有时候我们的处理函数中的参数不仅仅是字符串。这个时候就需要转换器将字符串转换到对应的类型，比如数字类型等。</p>
<p>可以在<code>Webconfig</code>中添加转换器，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        WebMvcConfigurer.<span class="keyword">super</span>.configureMessageConverters(converters);</span><br><span class="line">        converters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line">        converters.add(<span class="keyword">new</span> StringHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><code>@RequestParam</code></h3><p>这个注解是用来将URL上的query部分转换为处理函数的参数。例如URL=<code>http://baidu.com/addUser?user=123&amp;group=1</code>中的query就是<code>user=123</code>和<code>group=1</code>。</p>
<p>那么可以这样获取参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/addUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(@RequestParam String user, @RequestParam Integer group)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    System.out.println(group);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，这个注解是默认添加的，即时不加，也可以获取query的参数。所以下面的代码又是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/addUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String user, Integer group)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    System.out.println(group);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，该注解还可以接受其他参数为集合类型，比如Map，List。</p>
<p>例如：</p>
<h4 id="Map接收"><a href="#Map接收" class="headerlink" title="Map接收"></a>Map接收</h4><p>URL：<code>http://localhost:8080/xpan/file/file/compressFile?d=123&amp;dd=ddd</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@RequestParam Map&lt;String, String&gt; res)</span></span>&#123;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;d&#x3D;123, dd&#x3D;ddd&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>用Map接收的时候，不需要在乎参数的名字，因为其名字会作为Map的键。</p>
<h4 id="List接收"><a href="#List接收" class="headerlink" title="List接收"></a>List接收</h4><p>URL：<code>http://localhost:8080/xpan/file/file/compressFile?res=123&amp;res=ddd</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@RequestParam List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[123, ddd]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>使用List的时候就需要注意，提交的参数名字必须和接收的参数名字一样，或者使用<code>@RequestParam(&quot;xxx&quot;)</code>的形式来获取xxx的值。</p>
<h4 id="数组接收"><a href="#数组接收" class="headerlink" title="数组接收"></a>数组接收</h4><p>URL：<code>http://localhost:8080/xpan/file/file/compressFile?res=123&amp;res=ddd</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@RequestParam String[] res)</span></span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[123, ddd]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>使用数组和List基本一致，就是名字也需要保持一致，或者在注解中自定义。</p>
<p>源码位置在<code>RequestParamMethodArgumentResolver</code>。待解析。</p>
<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><code>@RequestBody</code></h3><p>这个注解是用来获取HTTP请求的body部分参数（见前面的HTTP结构图）。</p>
<p>并且可以通过converter将其转换为确定的类型。</p>
<p>这个注解也是需要converter来支持特定的request类型，即header中的<code>content-type</code>属性。即实际上body部分就是一串字符串，我们需要约定特定的格式来进行交互，而这个格式得有一个名字，这个名字就存储在<code>content-type</code>中。然后就按照这种格式来编码body得内容。</p>
<p>而我们一般使用的是JSON格式进行交互，所以此时的<code>content-type</code>就为<code>application/json</code>。</p>
<p>那么就需要一个JSON的转换器，这个转换器spring官方是没有内置的，需要我们自己添加，比如Jackson，可以在<code>Webconfig</code>中进行配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">    WebMvcConfigurer.<span class="keyword">super</span>.configureMessageConverters(converters);</span><br><span class="line">    converters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line">    converters.add(<span class="keyword">new</span> StringHttpMessageConverter());	<span class="comment">//添加这一个是为了解决StringHttpMessageConverter在前面导致String在统一返回对象时出现错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接收JSON字符串"><a href="#接收JSON字符串" class="headerlink" title="接收JSON字符串"></a>接收JSON字符串</h4><p>URL：<code>http://localhost:8080/xpan/file/folder/createFolder</code></p>
<p>body：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"folder_name"</span>: <span class="string">"myfolder"</span>,</span><br><span class="line">    <span class="attr">"depth"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"pid"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"sub_folder_count"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"sub_file_count"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/createFolder"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createFolder</span><span class="params">(@RequestBody Folder folder)</span></span>&#123;</span><br><span class="line">    System.out.println(folder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Folder(id&#x3D;null, user_id&#x3D;null, folder_name&#x3D;myfolder, depth&#x3D;1, icon&#x3D;null, pid&#x3D;0, size&#x3D;0, sub_folder_count&#x3D;0, sub_file_count&#x3D;0, gmt_statistics&#x3D;null, gmt_create&#x3D;null, gmt_update&#x3D;null)</span><br></pre></td></tr></table></figure>
<p>值得注意的是：这里还有一些Jackson的配置，比如默认是可以忽略参数的，即如果一些参数不带也是可以解析的。同样可以设置为全参数，否则报错的模式。</p>
<h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a><code>@PathVariable</code></h3><p>这个注解可以用于获取URI中的变量，与<code>requestParam</code>，这里是可以通过自定义的格式获取URI中的某一部分作为路径变量，然后注入到处理方法的参数中。</p>
<p>其中URI的匹配规则如下：</p>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?</code></td>
<td>匹配一个字符</td>
<td><code>/pages/t?st.html</code> 匹配 <code>/pages/test.html</code> 和<code>/pages/t3st.html</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配0个或多个<strong>字符</strong>（在一个路径段中）</td>
<td><code>/resources/*.png</code> 匹配<code>/resources/file.png</code><br/><code>/projects/*/versions</code> 匹配 <code>/projects/spring/versions</code> <br/>但是不匹配<code>/projects/spring/boot/versions</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>匹配直到路径尾部的一个或多个<strong>路径段</strong></td>
<td><code>/resources/**</code> 匹配 <code>/resources/file.png</code> 和 <code>/resources/images/file.png</code><br/><code>/resources/**/file.png</code> 是不合法的，因为**只允许在路径尾部。</td>
</tr>
<tr>
<td><code>{name}</code></td>
<td>匹配一个路径段并且将其捕捉为一个名为name的变量</td>
<td><code>/projects/{project}/versions</code> 匹配 <code>/projects/spring/versions</code> 并且捕捉为<br/>project=spring</td>
</tr>
<tr>
<td><code>{name:[a-z]+}</code></td>
<td>匹配<code>[a-z]+</code>为一个名为name的变量</td>
<td><code>/projects/{project:[a-z]+}/versions</code> 匹配<code>/projects/spring/versions</code> 但不匹配<br/><code>/projects/spring1/versions</code></td>
</tr>
<tr>
<td><code>{*path}</code></td>
<td>匹配直到路径尾部的一个或多个路径段并作为一个名为path的变量</td>
</tr>
</tbody>
</table>
<p>注：</p>
<ul>
<li>路径段（path segment）：指两个反斜杠内的部分。如<code>https://www.baidu.com/xxx/yyy</code>其中xxx就是一个路径段。</li>
</ul>
<p>接下来可以在处理方法中的参数中使用<code>@PathVariable</code>来获取路径变量。</p>
<p>如：</p>
<p>URL：<code>http://localhost:8080/xpan/file/file/compressFile/12345</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> Integer userId)</span>&#123;</span><br><span class="line">    System.out.println(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>当然也可以用其他更复杂，比如正则表达式来接收路径变量。</p>
<h3 id="MatrixVariable"><a href="#MatrixVariable" class="headerlink" title="@MatrixVariable"></a><code>@MatrixVariable</code></h3><p>矩阵变量（Matrix Variable）其实很简单，就是在路径段中的键值对。</p>
<p>与路径query的作用一致，只是形式不同。矩阵变量是以<code>;</code>分号作为URL结尾与矩阵变量开始的分隔符（query中是是<code>?</code>）和不同的矩阵变量之间的分隔符（query中是是<code>&amp;</code>）。而同一个name的不同值用,分割。同样的，键值之间仍然是以<code>=</code>作为连接符的。</p>
<p>例如<code>/cars;color=red,green;year=2012</code>中的矩阵变量为：<code>color=red,green;year=2012</code>。</p>
<p>与<code>@RequestParam</code>一致，也支持List和数组接收。</p>
<h4 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h4><p>URL：<code>http://localhost:8080/xpan/file/file/compressFile/12345;groupId=111;username=hhhhh</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> Integer userId, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"groupId"</span>)</span> String groupId, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"username"</span>)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(userId);</span><br><span class="line">    System.out.println(groupId);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">111</span><br><span class="line">hhhhh</span><br></pre></td></tr></table></figure>
<h4 id="List接收-1"><a href="#List接收-1" class="headerlink" title="List接收"></a>List接收</h4><p>URL：<code>http://localhost:8080/xpan/file/file/compressFile/12345;groupId=111;username=hhhhh;color=red,blue</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> Integer userId, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"groupId"</span>)</span> String groupId, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"username"</span>)</span> String username, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"color"</span>)</span> List color)</span>&#123;</span><br><span class="line">    System.out.println(userId);</span><br><span class="line">    System.out.println(groupId);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">111</span><br><span class="line">hhhhh</span><br><span class="line">[red, blue]</span><br></pre></td></tr></table></figure>
<h4 id="数组接收-1"><a href="#数组接收-1" class="headerlink" title="数组接收"></a>数组接收</h4><p>URL：<code>http://localhost:8080/xpan/file/file/compressFile/12345;groupId=111;username=hhhhh;color=red,blue</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> Integer userId, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"groupId"</span>)</span> String groupId, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"username"</span>)</span> String username, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"color"</span>)</span> String[] color)</span>&#123;</span><br><span class="line">    System.out.println(userId);</span><br><span class="line">    System.out.println(groupId);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(Arrays.toString(color));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">111</span><br><span class="line">hhhhh</span><br><span class="line">[red, blue]</span><br></pre></td></tr></table></figure>
<h4 id="Map接收-1"><a href="#Map接收-1" class="headerlink" title="Map接收"></a>Map接收</h4><p>使用map接收的时候，<code>@MatrixVariable</code>中就不需要填写参数了。例如：</p>
<p>URL：<code>http://localhost:8080/xpan/file/file/compressFile/12345;groupId=111;username=hhhhh;color=red,blue</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> Integer userId, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"groupId"</span>)</span> String groupId, @MatrixVariable Map matrixVars)</span>&#123;</span><br><span class="line">    System.out.println(userId);</span><br><span class="line">    System.out.println(groupId);</span><br><span class="line">    System.out.println(matrixVars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">111</span><br><span class="line">&#123;groupId&#x3D;111, username&#x3D;hhhhh, color&#x3D;red&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个点值得注意：</p>
<ul>
<li>矩阵变量可以单独读取和Map读取同时进行，即一个矩阵变量在多个处理方法的参数中。</li>
<li>当使用Map接收的时候，如果不指定泛型类型，则默认为<code>&lt;String, String&gt;</code>，所以后面color只解析出一个值。</li>
</ul>
<p>如果要克服也很简单，就是将泛型类型指定为List，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> Integer userId, @<span class="title">MatrixVariable</span><span class="params">(<span class="string">"groupId"</span>)</span> String groupId, @MatrixVariable Map&lt;String, List&gt; matrixVars)</span>&#123;</span><br><span class="line">    System.out.println(userId);</span><br><span class="line">    System.out.println(groupId);</span><br><span class="line">    System.out.println(matrixVars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么就能正常读取结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">111</span><br><span class="line">&#123;groupId&#x3D;[111], username&#x3D;[hhhhh], color&#x3D;[red, blue]&#125;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵变量与路径参数的匹配"><a href="#矩阵变量与路径参数的匹配" class="headerlink" title="矩阵变量与路径参数的匹配"></a>矩阵变量与路径参数的匹配</h4><p>矩阵变量与路径参数是可以匹配的，即如果矩阵变量名字相同，可以通过前置的路径变量进行定位。例如：</p>
<p>URL：<code>http://localhost:8080/xpan/file/file/compressFile/12345;order=111/123;order=222</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile/&#123;userId&#125;/&#123;groupId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> Integer userId, @<span class="title">MatrixVariable</span><span class="params">(name = <span class="string">"order"</span>, pathVar = <span class="string">"userId"</span>)</span> Integer userOrder, @<span class="title">PathVariable</span><span class="params">(<span class="string">"groupId"</span>)</span> Integer groupId, @<span class="title">MatrixVariable</span><span class="params">(name = <span class="string">"order"</span>, pathVar = <span class="string">"groupId"</span>)</span> String groupOrder)</span>&#123;</span><br><span class="line">System.out.println(userId);</span><br><span class="line">System.out.println(userOrder);</span><br><span class="line">System.out.println(groupId);</span><br><span class="line">System.out.println(groupOrder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">111</span><br><span class="line">123</span><br><span class="line">222</span><br></pre></td></tr></table></figure>
<h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a><code>@RequestHeader</code></h3><p>这个注解很简单，就是将header中的属性注入到处理函数的参数中。例如：</p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@RequestHeader(<span class="string">"Host"</span>)</span> String host, @<span class="title">RequestHeader</span><span class="params">(<span class="string">"Accept"</span>)</span> String accept)</span>&#123;</span><br><span class="line">    System.out.println(host);</span><br><span class="line">    System.out.println(accept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost:8080</span><br><span class="line">*&#x2F;*</span><br></pre></td></tr></table></figure>
<h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a><code>@CookieValue</code></h3><p>这个注解是用来获取cookie的值并注入到处理函数的参数中，例如：</p>
<p>cookie(附在HTTP header中)：</p>
<p><code>Cookie: userId=123</code></p>
<p>处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/compressFile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(@CookieValue(<span class="string">"userId"</span>)</span> Integer userId)</span>&#123;</span><br><span class="line">    System.out.println(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
<h1 id="JSON属性分解"><a href="#JSON属性分解" class="headerlink" title="JSON属性分解"></a>JSON属性分解</h1><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>Java中注解的定义也很简单，但是需要注意的是需要加上另外两个注解：</p>
<ul>
<li><code>Target</code>：当前注解被用的位置（参数、方法、类等），参数是<code>java.lang.annotation.ElementType</code>。</li>
<li><code>Retention</code>：注解存留的时间（源代码、类、运行时），参数是<code>java.lang.annotation.RetentionPolicy</code>。</li>
</ul>
<h2 id="HandlerMethodArgumentResolver"><a href="#HandlerMethodArgumentResolver" class="headerlink" title="HandlerMethodArgumentResolver"></a>HandlerMethodArgumentResolver</h2><p>HandlerMethodArgumentResolver接口可以用来解析HTTP请求，并且给处理函数的参数进行赋值。相当于自己实现一个参数解析的过程，本来springMVC中是有这一部分的实现，比如<code>@RequestParam</code>的<code>RequestParamMethodArgumentResolver</code>。</p>
<p>这个接口也很简单，只含有两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.web.method.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>supportsParameter</code>：该参数解析器是否支持当前参数。</li>
<li><code>resolveArgument</code>：返回解析后的对象，这个对象会直接赋值给当前参数。</li>
</ul>
<h2 id="自定义解析JSON"><a href="#自定义解析JSON" class="headerlink" title="自定义解析JSON"></a>自定义解析JSON</h2><p>利用上述两个知识和Jackson，就可以实现自定义的JSON解析方式。理论上可以分为2步：</p>
<ul>
<li>定义一个注解，并且<code>Target</code>为<code>ElementType.PARAMETER</code>；<code>Retention</code>为<code>RetentionPolicy.RUNTIME</code>，即确保整个注解是加在参数上，保留到运行时。</li>
<li>定义一个<code>HandlerMethodArgumentResolver</code>，support方法查看这个参数是否有上面定义的注解，resolveArgument方法利用Jackson来解析字符串。</li>
</ul>
<p>一个简单的例子如下，其功能是解析JSON中包含的<code>user_id</code>并返回：</p>
<p>注解类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UserId &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UserIdHandlerMethodArgumentResolver</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: MichaelWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/6/12 19:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: UserIdHandlerMethodArgumentResolver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserIdHandlerMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] userMethodIdExpList = &#123;<span class="string">"uid"</span>, <span class="string">"id"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parameter.hasParameterAnnotation(UserId<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String token = webRequest.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">        Integer id = JWTUtils.getIdFromToken(token.substring(<span class="number">7</span>));</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"身份认证失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; parameterType = parameter.getParameterType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单类型参数</span></span><br><span class="line">        <span class="keyword">if</span> (parameterType == Integer<span class="class">.<span class="keyword">class</span> || <span class="title">parameterType</span> </span>== <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            String requestJsonString = HttpUtils.getRequestJsonString(webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            Object o = JSONUtils.JSON2Object(requestJsonString, parameterType);</span><br><span class="line">            <span class="keyword">for</span> (String s : userMethodIdExpList) &#123;</span><br><span class="line">                PropertyDescriptor pd = <span class="keyword">new</span> PropertyDescriptor(s,parameterType);</span><br><span class="line">                Method writeMethod = pd.getWriteMethod();</span><br><span class="line">                writeMethod.invoke(o, id);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerException(<span class="string">"UserId注解obj模式下，参数对象必须含有uid/id字段"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：这里面还加入了身份认证和参数类型验证等。</p>
<h2 id="JSON属性分解注入"><a href="#JSON属性分解注入" class="headerlink" title="JSON属性分解注入"></a>JSON属性分解注入</h2><p>在面对前端传入的JSON数据，有时候可能并不是系统内定义的实体类，可能只是分开的几个参数，此时一般采用Map来接收，但是这样并不好做验证。所以我就想实现一个JSON属性分解，然后分别注入到处理函数的参数。所以一个简单的实现如下：</p>
<p>注解类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SingleRequestBody &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "-1"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UserIdHandlerMethodArgumentResolver</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.mw.xpan.resolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class="line"><span class="keyword">import</span> priv.mw.xpan.annotation.SingleRequestBody;</span><br><span class="line"><span class="keyword">import</span> priv.mw.xpan.utils.HttpUtils;</span><br><span class="line"><span class="keyword">import</span> priv.mw.xpan.utils.JSONUtils;</span><br><span class="line"><span class="keyword">import</span> priv.mw.xpan.utils.XPanRequestWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: MichaelWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/6/20 18:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: SingalMethodParamResolver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleMethodParamResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parameter.hasParameterAnnotation(SingleRequestBody<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String requestJsonString = HttpUtils.getRequestJsonString(webRequest.getNativeRequest(XPanRequestWrapper<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        HashMap&lt;String, String&gt; jsonObject = JSONUtils.JSON2Object(requestJsonString, HashMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        SingleRequestBody singleRequestBody = parameter.getParameterAnnotation(SingleRequestBody<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String value = singleRequestBody.value();</span><br><span class="line">        <span class="keyword">if</span>(!value.equals(<span class="string">"-1"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> jsonObject.get(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            String parameterName = parameter.getParameterName();</span><br><span class="line">            <span class="keyword">return</span> jsonObject.get(parameterName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/renameFile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renameFile</span><span class="params">(@SingleRequestBody String oldName)</span></span>&#123;</span><br><span class="line">    System.out.println(oldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全没问题。</p>
<p>但是在测试如下代码时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/renameFile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renameFile</span><span class="params">(@SingleRequestBody String oldName,@SingleRequestBody  String newName,@SingleRequestBody   Integer pId, @UserId Integer userId)</span></span>&#123;</span><br><span class="line">    System.out.println(oldName);</span><br><span class="line">    System.out.println(newName);</span><br><span class="line">    System.out.println(pId);</span><br><span class="line">    System.out.println(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就出现问题了，解析第一个参数时没问题，但是在解析第二个参数时就没办法从request中读取body部分了。</p>
<p>经过搜索才发现request的body是一个流，读取一次过后body指针就到最后的位置了，第二次就没办法读取了。</p>
<h2 id="解决request-body只能读取一次"><a href="#解决request-body只能读取一次" class="headerlink" title="解决request body只能读取一次"></a>解决request body只能读取一次</h2><p>这个问题网上也提供了一种比较好的把那份，即使用自定义的<code>HttpServletRequestWrapper</code>来包装一次request，这个<code>HttpServletRequestWrapper</code>需要重新定义一下body的读取方式。这里的思路也很简单，就是定义一个私有的body变量。读取的时候，如果已经有了就直接读取了。</p>
<p>下面给出一个示例（来自网上）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: MichaelWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/6/20 19:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: XPanRequestWrapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPanRequestWrapper</span>  <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a wrapper for the specified request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request The request to be wrapped</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XPanRequestWrapper</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">        body = IOUtils.toByteArray(<span class="keyword">super</span>.getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestBodyCachingInputStream(body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBodyCachingInputStream</span> <span class="keyword">extends</span> <span class="title">ServletInputStream</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lastIndexRetrieved = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> ReadListener listener;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RequestBodyCachingInputStream</span><span class="params">(<span class="keyword">byte</span>[] body)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.body = body;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isFinished()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = body[lastIndexRetrieved + <span class="number">1</span>];</span><br><span class="line">            lastIndexRetrieved++;</span><br><span class="line">            <span class="keyword">if</span> (isFinished() &amp;&amp; listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onAllDataRead();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    listener.onError(e);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lastIndexRetrieved == body.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This implementation will never block</span></span><br><span class="line">            <span class="comment">// We also never need to call the readListener from this method, as this method will never return false</span></span><br><span class="line">            <span class="keyword">return</span> isFinished();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadListener</span><span class="params">(ReadListener listener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"listener cann not be null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"listener has been set"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.listener = listener;</span><br><span class="line">            <span class="keyword">if</span> (!isFinished()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onAllDataRead();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    listener.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onAllDataRead();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    listener.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> body.length - lastIndexRetrieved - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            lastIndexRetrieved = body.length - <span class="number">1</span>;</span><br><span class="line">            body = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过以上的步骤，还需要定义一个Filter，用来每次替换request：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: MichaelWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/6/20 19:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: RequestWrapperFilter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPanRequestWrapperFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(request <span class="keyword">instanceof</span> XPanRequestWrapper))&#123;</span><br><span class="line">            request = <span class="keyword">new</span> XPanRequestWrapper(request);</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HttpServletRequestWrapper无法处理muilti-part文件"><a href="#HttpServletRequestWrapper无法处理muilti-part文件" class="headerlink" title="HttpServletRequestWrapper无法处理muilti-part文件"></a>HttpServletRequestWrapper无法处理muilti-part文件</h2><p>解决了上面的问题，又发现上传文件时就无法读取到文件了，这里有一个曲线救国的方法：</p>
<p>就是检测<code>content-type</code>是<code>multipart/form-data</code>的时候，就不进行包装。</p>
<p>所以Filter定义需要重新加一段逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: MichaelWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/6/20 19:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: RequestWrapperFilter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPanRequestWrapperFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> 完善文件上传时，request的封装</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String contentType = request.getContentType();</span><br><span class="line">        String method = <span class="string">"multipart/form-data"</span>;</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span> &amp;&amp; contentType.contains(method)) &#123;</span><br><span class="line">            <span class="comment">// 将转化后的 request 放入过滤链中</span></span><br><span class="line">            request = <span class="keyword">new</span> StandardServletMultipartResolver().resolveMultipart(request);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(request <span class="keyword">instanceof</span> XPanRequestWrapper))&#123;</span><br><span class="line">                request = <span class="keyword">new</span> XPanRequestWrapper(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等后期研究一下，我觉得还有更好的解决方案，即完善这个<code>HttpServletRequestWrapper</code>，让它也支持<code>multi-part</code>文件。</p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>参数接收</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的组件传值</title>
    <url>/2020/01/05/Vue%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h1 id="父-gt-子"><a href="#父-gt-子" class="headerlink" title="父 =&gt; 子"></a>父 =&gt; 子</h1><p>父组件向子组件传值比较简单，直接使用<code>v-bind:key = val</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;child :name &#x3D; &quot;&#39;tom&#39;&quot; :age&#x3D;&quot;&#39;12&#39;&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    	&#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;sctipt&gt;</span><br><span class="line">	props:[&quot;name&quot;,&quot;age&quot;]</span><br><span class="line">&lt;&#x2F;sctipt&gt;</span><br></pre></td></tr></table></figure>
<p>这样在子组件中可以显示父组件给子组件传的值。</p>
<p>值得注意的是：在子组件中可以对父组件穿的值进行检验。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    	&#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125;----&#123;&#123;id&#125;&#125;----&#123;&#123;address&#125;&#125;---&#123;&#123;email&#125;&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;sctipt&gt;</span><br><span class="line">	props:&#123;</span><br><span class="line">    &#x2F;&#x2F;验证为字符串</span><br><span class="line">    &quot;name&quot;:String,</span><br><span class="line">    &#x2F;&#x2F;验证为数字</span><br><span class="line">    &quot;age&quot;:Number,</span><br><span class="line">    &#x2F;&#x2F;验证为字符串或者数组</span><br><span class="line">    &quot;id&quot;:[String,Number],</span><br><span class="line">    &#x2F;&#x2F;验证为必须传递的字段，并且默认值为北京</span><br><span class="line">    &quot;address&quot;:&#123;</span><br><span class="line">    	required:true,</span><br><span class="line">    	default:function()&#123;</span><br><span class="line">    		return &quot;北京&quot;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;进行高级验证</span><br><span class="line">    &quot;email&quot;:&#123;</span><br><span class="line">    	validator: function(val)&#123;</span><br><span class="line">    		return &#x2F;^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+\.([a-zA-Z]&#123;2,4&#125;)$&#x2F;.test(val)</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;sctipt&gt;</span><br></pre></td></tr></table></figure>
<h1 id="子-gt-父"><a href="#子-gt-父" class="headerlink" title="子 =&gt; 父"></a>子 =&gt; 父</h1><p>一般不推荐子组件向父组件传值，即父 =&gt; 子的单向数据流会使整个项目更加容易维护。否则无法维护项目的整体性，组件内的状态可能会发生不在预期之内的改变。</p>
<p>但有时又必须通过子组件来改变父组件的值，则Vue官方提供了子组件与父组件通信的方法。借用这个通信的方法可以顺势进行传值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;!-- 通过组件事件进行传值 --&gt;</span><br><span class="line">	&lt;child @getData &#x3D; getData&#x2F;&gt;</span><br><span class="line">	&#123;&#123;val&#125;&#125;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      val:&quot;父组件的值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        getData(val)&#123;</span><br><span class="line">            this.val &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        &#x2F;&#x2F;或者直接挂载在vue实例上</span><br><span class="line">        this.$on(&#39;getData&#39;, this.)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;button @click&#x3D;&quot;sendData&quot;&gt;</span><br><span class="line">        向父组件传值</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      val:&quot;子组件的值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        sendData(val)&#123;</span><br><span class="line">            this.$emit(&quot;getData&quot;,this.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>即利用v-on为子组件 添加一个自定义时间，并将父组件的特定方法传入这个监听事件。</p>
<p>在子组件中调用<code>this.$emit(&#39;funcName&#39;,args...)</code>来调用父组件的方法，并利用参数将值传入至父组件。</p>
<h1 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h1><p>兄弟组件或者跨多级组件则可以使用<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex</a>来进行数组的传输。具体就不在这里讨论vuex的用法。</p>
<h1 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h1><ol>
<li><code>Vuex</code></li>
<li><code>$attrs、$listeners</code></li>
<li><code>Provide、inject</code></li>
</ol>
<h2 id="attrs、-listeners"><a href="#attrs、-listeners" class="headerlink" title="$attrs、$listeners"></a><code>$attrs、$listeners</code></h2><h3 id="vm-attrs"><a href="#vm-attrs" class="headerlink" title="vm.$attrs"></a><a href="https://cn.vuejs.org/v2/api/#vm-attrs" target="_blank" rel="noopener">vm.$attrs</a></h3><blockquote>
<p>2.4.0 新增</p>
</blockquote>
<ul>
<li><p><strong>类型</strong>：<code>{ [key: string]: string }</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</p>
</li>
</ul>
<h3 id="vm-listeners"><a href="#vm-listeners" class="headerlink" title="vm.$listeners"></a><a href="https://cn.vuejs.org/v2/api/#vm-listeners" target="_blank" rel="noopener">vm.$listeners</a></h3><blockquote>
<p>2.4.0 新增</p>
</blockquote>
<ul>
<li><p><strong>类型</strong>：<code>{ [key: string]: Function | Array&lt;Function&gt; }</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</p>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;test&quot;&gt;</span><br><span class="line">        &lt;child  v-bind&#x3D;&quot;&#123;name, sex, age&#125;&quot; v-on&#x3D;&quot;&#123;changeName,changeAge&#125;&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &#39;.&#x2F;child&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          name: &#39;张三&#39;,</span><br><span class="line">          sex: &#39;男&#39;,</span><br><span class="line">          age: 11,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeName(name) &#123;</span><br><span class="line">            this.name &#x3D; name</span><br><span class="line">        &#125;,</span><br><span class="line">        changeAge(age) &#123;</span><br><span class="line">            this.age &#x3D; age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>子组件child.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child&quot;&gt;</span><br><span class="line">        child组件的$attrs &#123;&#123;$attrs&#125;&#125;</span><br><span class="line">        &lt;child-child v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot; @showAttrs&#x3D;&quot;showAttrs&quot;&gt;&lt;&#x2F;child-child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import childChild from  &#39;.&#x2F;child-child&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;child&quot;,</span><br><span class="line">    props: [&#39;name&#39;],</span><br><span class="line">    inheritAttrs: false,</span><br><span class="line">    created() &#123;</span><br><span class="line">        console.log(&#39;child&#39;, this.$listeners) </span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        childChild</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        showAttrs() &#123;</span><br><span class="line">            console.log(this.$attrs)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>孙子组件：child-child.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child-child&quot;&gt;</span><br><span class="line">        child-child组件的$attrs &#123;&#123;$attrs&#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;child-child&quot;,</span><br><span class="line">    inheritAttrs: false,</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(&#39;child-child&#39;,this.$listeners)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>利用<code>$attrs、$listeners</code>可以实现层级传递，将跨级组件的值传递下去。</p>
<h2 id="Provide、inject"><a href="#Provide、inject" class="headerlink" title="Provide、inject"></a><code>Provide、inject</code></h2><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a><a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">provide / inject</a></h3><blockquote>
<p>2.2.0 新增</p>
</blockquote>
<ul>
<li><p><strong>类型</strong>：</p>
<ul>
<li><strong>provide</strong>：<code>Object | () =&gt; Object</code></li>
<li><strong>inject</strong>：<code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object }</code></li>
</ul>
</li>
<li><p><strong>详细</strong>：</p>
<p><code>provide</code> 和 <code>inject</code> 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p>
<p>这对选项需要一起使用，<strong>以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。</strong>如果你熟悉 React，这与 React 的上下文特性很相似。</p>
<p><code>provide</code> 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 <code>Symbol</code> 和 <code>Reflect.ownKeys</code> 的环境下可工作。</p>
<p><code>inject</code> 选项应该是：</p>
<ul>
<li>一个字符串数组，或</li>
<li>一个对象，对象的 key 是本地的绑定名，value 是：<ul>
<li>在可用的注入内容中搜索用的 key (字符串或 Symbol)，或</li>
<li>一个对象，该对象的：<ul>
<li><code>from</code> property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)</li>
<li><code>default</code> property 是降级情况下使用的 value</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：<code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p>
</blockquote>
</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父级组件提供 'foo'</span></span><br><span class="line"><span class="keyword">var</span> Provider = &#123;</span><br><span class="line">    provide: &#123;</span><br><span class="line">        foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件注入 'foo'</span></span><br><span class="line"><span class="keyword">var</span> Child = &#123;</span><br><span class="line">    inject: [<span class="string">'foo'</span>],</span><br><span class="line">    created () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) <span class="comment">// =&gt; "bar"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//孙组件注入</span></span><br><span class="line"><span class="keyword">var</span> grandson = &#123;</span><br><span class="line">    inject: [<span class="string">'foo'</span>],</span><br><span class="line">    created () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) <span class="comment">// =&gt; "bar"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>组件传值</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue插件开发1-插件原理以及应用</title>
    <url>/2021/01/12/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911-%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>插件通常用来为 Vue 添加全局功能。-Vue官网</p>
</blockquote>
<p>我觉得广义上的插件，实际上就是一些可以复用的功能或组件的封装。</p>
<p>首先分析Vue源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src-&gt;core-&gt;instance-&gt;index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>
<p>我们可以法Vue实例最初是一个函数，然后在其上挂载各种属性。作为函数，我们就可以为其直接添加属性，或者向其<code>prototype</code>上添加参数。</p>
<p>Vue的插件通常包括以下几种：</p>
<ol>
<li><p>添加全局方法或者 property。如：<a href="https://github.com/karol-f/vue-custom-element" target="_blank" rel="noopener">vue-custom-element</a></p>
<p>注册代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.customElement = <span class="function"><span class="keyword">function</span> <span class="title">vueCustomElement</span>(<span class="params">tag, componentDefinition, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里是直接向<code>Vue</code>实例上添加属性方法。</p>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.customElement()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   另外，这个插件使用了<code>Web Component</code>这一新的属性，还得找个时间学习一下。它可以在<code>HTML</code>文件中直接使用自定义标签。</p>
<ol start="2">
<li><p>添加全局资源：指令/组件/过滤器/过渡等。如 <a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-touch</a></p>
<p>注册代码（<code>vue-touch</code>）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vueTouch.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">    Vue.directive(<span class="string">'touch'</span>, &#123;</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是使用了<code>Vue</code>的<code>directive</code>定义了一个全局的<code>v-touch</code>指令。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-touch:tap</span>=<span class="string">"onTap"</span>&gt;</span>Tap me!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-touch:swipeleft</span>=<span class="string">"onSwipeLeft"</span>&gt;</span>Swipe me!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外，还可以通过<code>Vue.filter</code>注册全局的<code>filter</code>来进行使用，比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> plugin = &#123;&#125;</span><br><span class="line">plugin.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue, options</span>)</span>&#123;</span><br><span class="line">    Vue.filter(<span class="string">'capitalize'</span>, </span><br><span class="line">   		<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    		<span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    		value = value.toString()</span><br><span class="line">    		<span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则可以直接在<code>Vue</code>的<code>tempelate</code>中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <strong>值得注意的是全局组件的注册</strong>，因为很多时候我们开发组件是需要组件样式支撑的。这个时候就需要全局注册组件。比如<code>element-UI</code>(可惜无了)，<code>iview</code>这种组件库就需要注册大量的全局样式。</p>
<p>   注册代码（部分）（<code>element-UI</code>）：</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components.forEach(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  Vue.component(component.name, component);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>   这里使用<code>Vue.component</code>注册全局组件，这样注册的组件可以直接在任何组件中引用而不需在<code>script</code>中申明。</p>
<p>   <em>值得注意的是，这样引入的组件即使未被引用，依然会被打包，因此，在大型组件库中尽量少使用全局注册，否则会增加打包后的js大小。</em></p>
<ol start="3">
<li><p>通过全局混入来添加一些组件选项。如 <a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">vue-router</a></p>
<p>注册代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">	  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(<span class="keyword">this</span>.$options.router)) &#123;</span><br><span class="line">        <span class="keyword">this</span>._routerRoot = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router</span><br><span class="line">        <span class="keyword">this</span>._router.init(<span class="keyword">this</span>)</span><br><span class="line">        Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'_route'</span>, <span class="keyword">this</span>._router.history.current)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._routerRoot = (<span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent._routerRoot) || <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">      registerInstance(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed () &#123;</span><br><span class="line">      registerInstance(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里<code>vue-router</code>使用了<code>Vue.minin</code>对<code>beforeCreate</code>进行了混入，使该混入钩子在<code>Vue</code>自身的钩子之前调用。</p>
</li>
<li><p>添加 Vue 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。比如element-UI等组件库。</p>
<p>注册代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue, opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  locale.use(opts.locale);</span><br><span class="line">  locale.i18n(opts.i18n);</span><br><span class="line"></span><br><span class="line">  components.forEach(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.component(component.name, component);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Vue.use(InfiniteScroll);</span><br><span class="line">  Vue.use(Loading.directive);</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$ELEMENT = &#123;</span><br><span class="line">    size: opts.size || <span class="string">''</span>,</span><br><span class="line">    zIndex: opts.zIndex || <span class="number">2000</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$loading = Loading.service;</span><br><span class="line">  Vue.prototype.$msgbox = MessageBox;</span><br><span class="line">  Vue.prototype.$alert = MessageBox.alert;</span><br><span class="line">  Vue.prototype.$confirm = MessageBox.confirm;</span><br><span class="line">  Vue.prototype.$prompt = MessageBox.prompt;</span><br><span class="line">  Vue.prototype.$notify = Notification;</span><br><span class="line">  Vue.prototype.$message = Message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Vue</code>的<code>prototype</code>上添加很多参数方法。</p>
</li>
<li><p>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 <a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">vue-router</a></p>
<p><code>vue-router</code>中有一个<code>index.js</code>与<code>install.js</code>，在<code>install.js</code>中，只提供了与<code>Vue</code>相关的注册函数。在index中，定义了很多自己的API。</p>
</li>
</ol>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>通过全局方法 <code>Vue.use()</code> 使用插件。它需要在你调用 <code>new Vue()</code> 启动应用之前完成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 `MyPlugin.install(Vue)`</span></span><br><span class="line">Vue.use(MyPlugin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...组件选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以传入一个可选的选项对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.use(MyPlugin, &#123; <span class="attr">someOption</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><code>Vue.use</code> 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。</p>
<p>Vue.js 官方提供的一些插件 (例如 <code>vue-router</code>) 在检测到 <code>Vue</code> 是可访问的全局变量时会自动调用 <code>Vue.use()</code>。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 <code>Vue.use()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时</span></span><br><span class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">var</span> VueRouter = <span class="built_in">require</span>(<span class="string">'vue-router'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要忘了调用此方法</span></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>
<p><em>另外，全局样式表的引入需要直接在<code>main.js</code>中<code>import</code>，这样的css样式也会被全局注册，会影响所有的组件。</em></p>
<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><p><code>Vue</code>插件开发其实很简单，最关键的就是其必须要暴露一个<code>install</code>方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">'my-directive'</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.component(<span class="string">'my-component'</span>, Mcomponent)   <span class="comment">//常用</span></span><br><span class="line">  Vue.filter(<span class="string">'my-filter'</span>, Mfilter)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> MyPlugin</span><br></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>根据上面的原理，我们只需要遵循插件定义和使用的规则即可，其目录解构并不重要，但是为了规范，可以新建一个<code>plugin</code>用来存储插件文件，插件的目录解构可以自定义。另外，项目直接使用<code>vue-cli</code>生成一个普通的项目即可。</p>
<p><img src="\images\vue插件\vue插件1-1.png" alt="目录结构"></p>
<p>可以看到，在<code>index.js</code>文件中，我们定义了<code>install</code>函数，并在<code>Vue</code>的<code>prototype</code>上挂载了一个函数和一个方法，同时，也注册了一个全局的组件<code>dwin</code>。最后将该对象导出。</p>
<p><img src="\images\vue插件\vue插件1-2.png" alt="main.js"></p>
<p>然后在<code>main.js</code>中，我们从<code>index.js</code>中引入<code>dw</code>，然后使用<code>Vue.use(dw)</code>将该组件导入。</p>
<p><img src="\images\vue插件\vue插件1-3.png" alt="app.vue"></p>
<p>然后我们就可以在任何组件中使用<code>dwin</code>组件了。</p>
<p>这样一个简单的组件开发就完成了，具体的打包和上传到npm仓库见<a href="">这里</a></p>
]]></content>
      <categories>
        <category>Vue插件</category>
      </categories>
      <tags>
        <tag>Vue插件开发</tag>
        <tag>dragWindow</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的插槽与keep-alive</title>
    <url>/2020/01/05/Vue%E4%B8%AD%E7%9A%84%E6%8F%92%E6%A7%BD%E4%B8%8Ekeep-alive/</url>
    <content><![CDATA[<h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>初次真正接触插槽是在Elementui中的表格中在自定义列的内容时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column</span><br><span class="line">                 label&#x3D;&quot;姓名&quot;</span><br><span class="line">                 width&#x3D;&quot;180&quot;&gt;</span><br><span class="line">    &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">&lt;el-popover trigger&#x3D;&quot;hover&quot; placement&#x3D;&quot;top&quot;&gt;</span><br><span class="line">    &lt;p&gt;姓名: &#123;&#123; scope.row.name &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;住址: &#123;&#123; scope.row.address &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div slot&#x3D;&quot;reference&quot; class&#x3D;&quot;name-wrapper&quot;&gt;</span><br><span class="line">        &lt;el-tag size&#x3D;&quot;medium&quot;&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;&#x2F;el-tag&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;el-popover&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure>
<p>在列中插入一个template用来放置我们自定义的内容，并且可以通过<code>slot-scope=&quot;scope&quot;</code>中的scope来获取这一列的row信息。</p>
<p>仔细看了官方文档才明白，插槽<code>slot</code>是用来接收父组件在调用子组件时，在子组件标签内添加添加的内容，这个内容可以时文字，标签，或是其他组件。并且可以在slot上通过v-bind绑定值传递到父组件（说起来也算是子组件向父组件传值哦~）。可以预见，在<code>el-table-column</code>组件中，肯定存在一个slot来接受父组件的template:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column&gt;</span><br><span class="line">    &lt;slot v-bind:rowRata&#x3D;&quot;rowData&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure>
<p>值得注意的是：<code>scope-slot</code>,<code>slot</code>这两个语法在2.6.0之后都被官方废除，但是并未移除。在3.0中会被移除，取而代之的是新的<code>v-slot</code>指令。具体用法如下：</p>
<h2 id="插槽的作用域"><a href="#插槽的作用域" class="headerlink" title="插槽的作用域"></a>插槽的作用域</h2><p>值得重视的是，插槽总是在父组件中渲染的，引用官方的一句话：</p>
<blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
</blockquote>
<p>这句话中的“在”字，即我们能看到的。即使是插槽这样传递到子组件中元素。</p>
<p>所以，<strong>插槽总是能访问父组件的数据，而不能访问子组件的数组。</strong>但是有时我们又必须访问子组件的数据怎么办呢？这就用到了v-slot（slot-scope）属性。</p>
<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>对于默认插槽（即default），可以通过开始的代码形式，来获取子组件的值，前提是在子组件中使用 v-bind将其绑定到slot上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;child&gt;</span><br><span class="line">    &lt;template v-slot&#x3D;&quot;defaultPorps&quot;&gt;</span><br><span class="line">        &#123;&#123;defaultPorps.user.name&#125;&#125;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;child&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">&lt;slot v-bind:user &#x3D; &#123;&quot;name&quot;:&quot;tom&quot;&#125;&gt;</span><br><span class="line">&lt;&#x2F;slot&gt;</span><br></pre></td></tr></table></figure>
<p><strong>还有一点值得注意的是，Vue将整个slot的所有bind值封装为一个对象，所以我们使用v-bind绑定的值仅仅是该对象的一个属性（但是我们可以通过ES6的解构方法来直接拿到属性值）</strong></p>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>这个就很简单的了，一个子组件可能具有多个插槽，我们可以必须为止加上名字来区分，（如果不加，比如上面的例子中，v-slot = “xxx”全称应该是 v-slot:default=”xxx”，默认名字就是default），使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件中</span><br><span class="line">&lt;child&gt;</span><br><span class="line">	&lt;template v-slot&#x3D;&quot;slot1&quot;&gt;对应插槽1&lt;&#x2F;template&gt;</span><br><span class="line">    &lt;template v-slot&#x3D;&quot;slot1&quot;&gt;对应插槽2&lt;&#x2F;template&gt;</span><br><span class="line">    &lt;template v-slot&#x3D;&quot;slot1&quot;&gt;对应插槽3&lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;child&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;slot name&#x3D;&quot;slot1&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;slot1&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;slot1&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<p><strong>另外v-slot也可以缩写为#，就像v-on缩写为@，v-bind缩写为:</strong></p>
<h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><p>这个属性之前没有尝试过，但是最近遇到有个组件想要在来回切换时保持状态，既保持用户观看的内容，开始是想手动记录用户的状态，后来发现Vue官方提供了这个抽象组件，正好解决了问题，</p>
<p><code>keep-alive</code>基本用法是缓存某些组件的状态，我们从Vue的生命周期函数中可以发现，在组件失活时，都会触发<code>beforeDestroy</code>生命周期函数，但是如果我们将其包裹在<code>keep-alive</code>标签下，那么这些组件在失活时，并不会调用<code>beforeDestroy</code>方法，而是调用activated<code>和</code>deactivated` 这两个生命周期钩子函数将会被对应执行。将其缓存起来。</p>
<p>keep-alive组件有3个porp.</p>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;缓存所有的组件</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">	&lt;component1&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">    &lt;component2&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">    &lt;component3&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;缓存特定组件</span><br><span class="line">&lt;keep-alive inlude&#x3D;&quot;component1&quot;&gt;</span><br><span class="line">	&lt;component1&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">    &lt;component2&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">    &lt;component3&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不缓存特定组件</span><br><span class="line">&lt;keep-alive exclude&#x3D;&quot;component2&quot;&gt;</span><br><span class="line">	&lt;component1&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">    &lt;component2&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">    &lt;component3&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;规定最多缓存2个组件</span><br><span class="line">&lt;keep-alive max&#x3D;&quot;2&quot;&gt;</span><br><span class="line">	&lt;component1&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">    &lt;component2&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">    &lt;component3&gt;&lt;&#x2F;component1&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>当然，也可以配合Vue-router。来进行使用：</p>
<h2 id="配合路由"><a href="#配合路由" class="headerlink" title="配合路由"></a>配合路由</h2><p>在使用Vue-router进行组件选择性渲染的时候，我们同样也可以使用<code>keep-alive</code>，因为<code>&lt;router-view&gt;&lt;/router-view&gt;</code>组件是一个抽象路由，并不会真正创建一个组件结构在整个文档结构中，所以<code>keep-alive</code>对其仍然有效。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./views/Home.vue'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./views/Login.vue'</span></span><br><span class="line"><span class="keyword">import</span> Register <span class="keyword">from</span> <span class="string">"./views/regisetr.vue"</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/about'</span>,</span><br><span class="line">      name: <span class="string">'about'</span>,</span><br><span class="line">      componet: About</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/login'</span>,</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/register'</span>,</span><br><span class="line">      name: <span class="string">'register'</span>,</span><br><span class="line">      component: Register</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;transition</span><br><span class="line">            :duration&#x3D;&quot;500&quot;</span><br><span class="line">            mode&#x3D;&quot;out-in&quot;</span><br><span class="line">            enter-active-class&#x3D;&quot;animated bounceIn&quot;</span><br><span class="line">            leave-active-class&#x3D;&quot;animated bounceOutDown&quot;</span><br><span class="line">          &gt;</span><br><span class="line">     &lt;keep-alive exclude&#x3D;&quot;Login,Register&quot; max&#x3D;2&gt;</span><br><span class="line">         &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">     &lt;&#x2F;keep-alive&gt;</span><br><span class="line">&lt;&#x2F;transition&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码即表示，不缓存<code>Login</code>,<code>Register</code>组件，并且最多缓存2和组件。</p>
<p><strong>值得注意的是，当同时使用<code>transiton</code>组件与<code>keep-alive</code>组件时，<code>transiton</code>组件必须位于外层，很容易想明白，<code>keep-alive</code>组件对其内部的组件进行管控，如果将<code>transiton</code>组件放置到其内部，即使它是抽象组件，也会被被<code>keep-alive</code>组件管控，导致不正常</strong></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>插槽</tag>
        <tag>keep-alive</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue插件开发3-简单拖动窗口的优化</title>
    <url>/2021/01/13/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%913-%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>中心思想：首先算出首次拖动窗口距视窗的上面和左面的距离，然后计算出每次鼠标的偏移量（可正可负）。然后将其相加，就可得到新的偏移量。</p>
<p>代码思路：</p>
<ol>
<li>设置一个变量，用于标记鼠标是否按下。</li>
<li><code>mousedown</code>钩子函数中记录下此时的<code>clientX1</code>,<code>clientY1</code>,<code>offsetX</code>,<code>offsetY</code>。</li>
<li><code>mousemove</code>钩子函数中记录下次此时的<code>clientX2</code>,<code>clientY2</code>，然后计算两组量：<ol>
<li>拖动之前拖动框距文档边框的距离<code>left1 = clientX1 - offsetX</code>，<code>top1 = clientY1 - offsetY</code></li>
<li>拖动的距离<code>disX = clientX2 - clientX1</code>，<code>disY = clientY2 - clientY1</code></li>
</ol>
</li>
<li>此时新的<code>left2 = left + disX</code>，<code>top2 = top + disY</code></li>
</ol>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">banMouseDown(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"鼠标按下"</span>);</span><br><span class="line">    <span class="keyword">this</span>.isDown = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> dw = <span class="keyword">this</span>.$refs[<span class="keyword">this</span>.wid];</span><br><span class="line">    <span class="keyword">let</span> banner = <span class="keyword">this</span>.$refs[<span class="string">"banner"</span>];</span><br><span class="line">    banner.style.cursor = <span class="string">"move"</span>;</span><br><span class="line">    <span class="keyword">let</span> RectData = dw.getBoundingClientRect();</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"x"</span>, e.clientX);</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"y"</span>, e.clientY);</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"offX"</span>, e.offsetX);</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"offY"</span>, e.offsetY);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">banMouseUp() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isDown = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> banner = <span class="keyword">this</span>.$refs[<span class="string">"banner"</span>];</span><br><span class="line">    banner.style.cursor = <span class="string">"default"</span>;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">banMouseMove(e) &#123;</span><br><span class="line">    debounce(<span class="keyword">this</span>, <span class="keyword">this</span>.handle, <span class="number">20</span>)(e);			<span class="comment">//节流函数</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handle(e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isDown) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">        <span class="keyword">let</span> dw = <span class="keyword">this</span>.$refs[<span class="keyword">this</span>.wid];</span><br><span class="line">        <span class="keyword">let</span> banner = <span class="keyword">this</span>.$refs[<span class="string">"banner"</span>];</span><br><span class="line">        banner.style.cursor = <span class="string">"move"</span>;</span><br><span class="line">        <span class="keyword">let</span> RectData = dw.getBoundingClientRect();</span><br><span class="line">        <span class="keyword">let</span> cx = e.clientX;</span><br><span class="line">        <span class="keyword">let</span> cy = e.clientY;</span><br><span class="line">        <span class="keyword">let</span> moveX =</span><br><span class="line">            (<span class="keyword">this</span>.currenctPositon.x -</span><br><span class="line">            <span class="keyword">this</span>.currenctPositon.offX) +</span><br><span class="line">            (cx - <span class="keyword">this</span>.currenctPositon.x);</span><br><span class="line">        <span class="keyword">let</span> moveY =</span><br><span class="line">            (<span class="keyword">this</span>.currenctPositon.y -</span><br><span class="line">            <span class="keyword">this</span>.currenctPositon.offY) +</span><br><span class="line">            (cy - <span class="keyword">this</span>.currenctPositon.y);</span><br><span class="line">        Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"x"</span>, cx);</span><br><span class="line">        Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"y"</span>, cy);</span><br><span class="line">        dw.style.left = moveX + <span class="string">"px"</span>;</span><br><span class="line">        dw.style.top = moveY + <span class="string">"px"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>然后又发现另一个思路（似乎更简单）：</p>
<p>中心思想：要想达到拖动效果，即要保持鼠标的位置相对于拖动框是相对静止的。而鼠标的位置相对于拖动框就是<code>offset</code>的值，是不会变化的。所以当鼠标发生移动时，拖动框的位置也要发生变化，才能保证<code>offset</code>的值是不变的。所以我们在新的一次鼠标移动(<code>mousemove</code>)后，新的偏移量应当赋予拖动框的<code>left</code>,<code>right</code>值。即<code>left = clientX2 - offsetX</code>，<code>top = clientY2 - offsetY</code></p>
<p>代码思路：</p>
<ol>
<li>设置一个变量，用于标志鼠标是否按下。</li>
<li><code>mousedown</code>钩子函数中记录下此时的<code>clientX1</code>,<code>clientY1</code>,<code>offsetX</code>,<code>offsetY</code>。</li>
<li><code>mousemove</code>钩子函数中记录下次此时的<code>clientX2</code>,<code>clientY2</code>，然后计算拖动出偏移量<code>dOffsetX</code>，<code>dOffsetY</code>，具体<ol>
<li><code>left = clientX2 - offsetX</code></li>
<li><code>top = clientY2 - offsetY</code></li>
</ol>
</li>
<li>将拖动窗口的样式:<ol>
<li><code>style.left</code>设置为<code>left</code></li>
<li><code>style.top</code>设置为<code>top</code></li>
</ol>
</li>
</ol>
<p>实测是可以使用的。</p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">banMouseDown(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"鼠标按下"</span>);</span><br><span class="line">    <span class="keyword">this</span>.isDown = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> dw = <span class="keyword">this</span>.$refs[<span class="keyword">this</span>.wid];</span><br><span class="line">    <span class="keyword">let</span> banner = <span class="keyword">this</span>.$refs[<span class="string">"banner"</span>];</span><br><span class="line">    banner.style.cursor = <span class="string">"move"</span>;</span><br><span class="line">    <span class="keyword">let</span> RectData = dw.getBoundingClientRect();</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"x"</span>, e.clientX);</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"y"</span>, e.clientY);</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"offX"</span>, e.offsetX);</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"offY"</span>, e.offsetY);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">    banMouseUp() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isDown = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> banner = <span class="keyword">this</span>.$refs[<span class="string">"banner"</span>];</span><br><span class="line">        banner.style.cursor = <span class="string">"default"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">        banMouseMove(e) &#123;</span><br><span class="line">            debounce(<span class="keyword">this</span>, <span class="keyword">this</span>.handle, <span class="number">20</span>)(e);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">            handle(e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isDown) &#123;</span><br><span class="line">                    <span class="keyword">let</span> dw = <span class="keyword">this</span>.$refs[<span class="keyword">this</span>.wid];</span><br><span class="line">                    <span class="keyword">let</span> banner = <span class="keyword">this</span>.$refs[<span class="string">"banner"</span>];</span><br><span class="line">                    banner.style.cursor = <span class="string">"move"</span>;</span><br><span class="line">                    <span class="keyword">let</span> RectData = dw.getBoundingClientRect();</span><br><span class="line">                    <span class="keyword">let</span> cx = e.clientX;</span><br><span class="line">                    <span class="keyword">let</span> cy = e.clientY;</span><br><span class="line">                    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"x"</span>, cx);</span><br><span class="line">                    Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"y"</span>, cy);</span><br><span class="line">                    <span class="keyword">let</span> moveX = <span class="keyword">this</span>.currenctPositon.x - <span class="keyword">this</span>.currenctPositon.offX;</span><br><span class="line">                    <span class="keyword">let</span> moveY = <span class="keyword">this</span>.currenctPositon.y - <span class="keyword">this</span>.currenctPositon.offY;</span><br><span class="line">                    dw.style.left = moveX + <span class="string">"px"</span>;</span><br><span class="line">                    dw.style.top = moveY + <span class="string">"px"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h2><p>接下来我发现了另外一个<code>api</code>：<code>movementX</code>，<code>movementY</code>，这个<code>api</code>会在<code>mousemove</code>时记录与上一次移动的距离，所以就在思路一的基础上可以省略求<code>disX</code>,<code>disY</code>的过程，所以有了以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">handle(e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isDown) &#123;</span><br><span class="line">        <span class="keyword">let</span> dw = <span class="keyword">this</span>.$refs[<span class="keyword">this</span>.wid];</span><br><span class="line">        <span class="keyword">let</span> banner = <span class="keyword">this</span>.$refs[<span class="string">"banner"</span>];</span><br><span class="line">        banner.style.cursor = <span class="string">"move"</span>;</span><br><span class="line">        <span class="keyword">let</span> RectData = dw.getBoundingClientRect();</span><br><span class="line">        <span class="keyword">let</span> cx = e.clientX;</span><br><span class="line">        <span class="keyword">let</span> cy = e.clientY;</span><br><span class="line">        Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"x"</span>, cx);</span><br><span class="line">        Vue.set(<span class="keyword">this</span>.currenctPositon, <span class="string">"y"</span>, cy);</span><br><span class="line">        <span class="keyword">let</span> moveX = <span class="keyword">this</span>.currenctPositon.x -<span class="keyword">this</span>.currenctPositon.offX + e.movementX;</span><br><span class="line">        <span class="keyword">let</span> moveY = <span class="keyword">this</span>.currenctPositon.y -<span class="keyword">this</span>.currenctPositon.offY + e.movementY;</span><br><span class="line">        dw.style.left = moveX + <span class="string">"px"</span>;</span><br><span class="line">        dw.style.top = moveY + <span class="string">"px"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>但是由于<code>movementX</code>,<code>movementY</code>返回的是<code>int</code>，精度不够，所以会出现不跟手的情况；而且IE均不支持该属性，所以不是最优方案。</p>
<h2 id="思路四"><a href="#思路四" class="headerlink" title="思路四"></a>思路四</h2><p>最后我去参考了<code>layui</code>的方案。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> moveElem.on(<span class="string">'mousedown'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">if</span>(config.move)&#123;</span><br><span class="line">      dict.moveStart = <span class="literal">true</span>;</span><br><span class="line">      dict.offset = [</span><br><span class="line">        e.clientX - <span class="built_in">parseFloat</span>(layero.css(<span class="string">'left'</span>))</span><br><span class="line">        ,e.clientY - <span class="built_in">parseFloat</span>(layero.css(<span class="string">'top'</span>))</span><br><span class="line">      ];</span><br><span class="line">      ready.moveElem.css(<span class="string">'cursor'</span>, <span class="string">'move'</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">_DOC.on(<span class="string">'mousemove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拖拽移动</span></span><br><span class="line">    <span class="keyword">if</span>(dict.moveStart)&#123;</span><br><span class="line">      <span class="keyword">var</span> X = e.clientX - dict.offset[<span class="number">0</span>]</span><br><span class="line">      ,Y = e.clientY - dict.offset[<span class="number">1</span>]</span><br><span class="line">      ,fixed = layero.css(<span class="string">'position'</span>) === <span class="string">'fixed'</span>;</span><br><span class="line">      </span><br><span class="line">      e.preventDefault();</span><br><span class="line">      </span><br><span class="line">      dict.stX = fixed ? <span class="number">0</span> : win.scrollLeft();</span><br><span class="line">      dict.stY = fixed ? <span class="number">0</span> : win.scrollTop();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//控制元素不被拖出窗口外</span></span><br><span class="line">      <span class="keyword">if</span>(!config.moveOut)&#123;</span><br><span class="line">        <span class="keyword">var</span> setRig = win.width() - layero.outerWidth() + dict.stX</span><br><span class="line">        ,setBot = win.height() - layero.outerHeight() + dict.stY;  </span><br><span class="line">        X &lt; dict.stX &amp;&amp; (X = dict.stX);</span><br><span class="line">        X &gt; setRig &amp;&amp; (X = setRig); </span><br><span class="line">        Y &lt; dict.stY &amp;&amp; (Y = dict.stY);</span><br><span class="line">        Y &gt; setBot &amp;&amp; (Y = setBot);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      layero.css(&#123;</span><br><span class="line">        left: X</span><br><span class="line">        ,<span class="attr">top</span>: Y</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>layui</code>采用的是一种更为常见的方式。</p>
<p>其关键在于其并没有直接拿<code>offsetX</code>，而是通过<code>clientX - left</code>，<code>clientY - top</code>来计算<code>offset</code>。其原因在于可能是<code>offset</code>属性的兼容性问题。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Feature</th>
<th style="text-align:left">Chrome</th>
<th style="text-align:left">Edge</th>
<th style="text-align:left">Firefox (Gecko)</th>
<th style="text-align:left">Internet Explorer</th>
<th style="text-align:left">Opera</th>
<th style="text-align:left">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Basic support</td>
<td style="text-align:left">(Yes)</td>
<td style="text-align:left">(Yes)</td>
<td style="text-align:left"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/39" target="_blank" rel="noopener">39.0</a> (39.0)</td>
<td style="text-align:left">6</td>
<td style="text-align:left">(Yes)</td>
<td style="text-align:left">(Yes)</td>
</tr>
<tr>
<td style="text-align:left">Redefined from <code>long</code> to <code>double</code></td>
<td style="text-align:left">56</td>
<td style="text-align:left">?</td>
<td style="text-align:left">?</td>
<td style="text-align:left">?</td>
<td style="text-align:left">?</td>
<td style="text-align:left">?</td>
</tr>
</tbody>
</table>
<p><code>offsetX</code>在早期返回一个<code>int</code>，这对于拖动窗口有很大的影响，比如上面的<code>movement</code>属性，所以<code>layui</code>选择了更加稳定的直接获取其<code>style.left</code>属性。</p>
<h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p>这一部分，我觉得可加可不加，因为虽然DOM消耗很大，但是目前计算机的性能是完全足够承担一秒几十次到上百次的DOM重绘的。额可以在后期加入检测机制，如果机器性能较差，则可以节流<code>mousemove</code>函数。具体细节可以查看<a href="https://michaelwang.top/2019/11/17/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/" target="_blank" rel="noopener">函数的节流与防抖</a></p>
]]></content>
      <categories>
        <category>Vue插件</category>
      </categories>
      <tags>
        <tag>Vue插件开发</tag>
        <tag>拖动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue插件开发2-事件对象e与视窗api详解</title>
    <url>/2021/01/13/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%912-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1e%E4%B8%8E%E8%A7%86%E7%AA%97api%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h1><p><img src="\images\vue插件\vue插件2-1.png" alt="事件参数"></p>
<p>首先<code>Vue</code>没有对事件对象做修改，所以在<code>Vue</code>中的事件对象仍然与原生一样。</p>
<p>其对象属性具体又分为4类：</p>
<h2 id="鼠标-键盘属性"><a href="#鼠标-键盘属性" class="headerlink" title="鼠标 / 键盘属性"></a>鼠标 / 键盘属性</h2><table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">altKey</td>
<td style="text-align:left">返回当事件被触发时，”ALT” 是否被按下。</td>
</tr>
<tr>
<td style="text-align:left">button</td>
<td style="text-align:left">返回当事件被触发时，哪个鼠标按钮被点击。<br /><br />一个数字，表示鼠标事件发生时按下的鼠标按钮。可能的值：<br/>0：鼠标左键<br/>1：车轮按钮或中间按钮（如果有）<br/>2：鼠标右键<br/>注意： Internet Explorer 8和更早版本具有不同的返回值：<br/>1：鼠标左键<br/>2：鼠标右键<br/>4：车轮按钮或中间按钮（如果有）<br/>注意：对于左侧配置的鼠标，返回值会反转</td>
</tr>
<tr>
<td style="text-align:left"><strong>buttons</strong></td>
<td style="text-align:left"><strong>buttons</strong>属性返回一个数字，指示触发鼠标事件时按下了哪些鼠标按钮或鼠标按钮。<br /><br />一个数字，表示鼠标事件发生时按下的一个或多个鼠标按钮。如果按下多个按钮，则组合这些值以产生新数字（例如，如果按下左按钮（1）和右按钮（2），则返回值为1 + 2，即3） 。可能的值：1：鼠标左键2：鼠标右键4：滚轮按钮或中间按钮8：第四个鼠标按钮（通常是“浏览器返回”按钮）16：第五个鼠标按钮（通常是“浏览器转发”按钮）注意：对于左侧配置的鼠标，返回值会反转</td>
</tr>
<tr>
<td style="text-align:left">clientX</td>
<td style="text-align:left">返回当事件被触发时，鼠标指针的水平坐标。</td>
</tr>
<tr>
<td style="text-align:left">clientY</td>
<td style="text-align:left">返回当事件被触发时，鼠标指针的垂直坐标。</td>
</tr>
<tr>
<td style="text-align:left">ctrlKey</td>
<td style="text-align:left">返回当事件被触发时，”CTRL” 键是否被按下。</td>
</tr>
<tr>
<td style="text-align:left">metaKey</td>
<td style="text-align:left">返回当事件被触发时，”meta” 键是否被按下。</td>
</tr>
<tr>
<td style="text-align:left">relatedTarget</td>
<td style="text-align:left">返回与事件的目标节点相关的节点。</td>
</tr>
<tr>
<td style="text-align:left">screenX</td>
<td style="text-align:left">返回当某个事件被触发时，鼠标指针的水平坐标。</td>
</tr>
<tr>
<td style="text-align:left">screenY</td>
<td style="text-align:left">返回当某个事件被触发时，鼠标指针的垂直坐标。</td>
</tr>
<tr>
<td style="text-align:left">shiftKey</td>
<td style="text-align:left">返回当事件被触发时，”SHIFT” 键是否被按下。</td>
</tr>
</tbody>
</table>
<h2 id="IE-属性"><a href="#IE-属性" class="headerlink" title="IE 属性"></a>IE 属性</h2><p>除了上面的鼠标/事件属性，IE 浏览器还支持下面的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cancelBubble</td>
<td style="text-align:left">如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。</td>
</tr>
<tr>
<td style="text-align:left">fromElement</td>
<td style="text-align:left">对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。</td>
</tr>
<tr>
<td style="text-align:left">keyCode</td>
<td style="text-align:left">对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup 事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。</td>
</tr>
<tr>
<td style="text-align:left">offsetX,offsetY</td>
<td style="text-align:left">发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。</td>
</tr>
<tr>
<td style="text-align:left">returnValue</td>
<td style="text-align:left">如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 fasle，可以取消发生事件的源元素的默认动作。<strong>比如在a标签的事件中如果将该值设为false，则不会跳转；在submit按钮中就不会提交事件。</strong></td>
</tr>
<tr>
<td style="text-align:left">srcElement</td>
<td style="text-align:left">对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。</td>
</tr>
<tr>
<td style="text-align:left">toElement</td>
<td style="text-align:left">对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。</td>
</tr>
<tr>
<td style="text-align:left">x,y</td>
<td style="text-align:left">事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。</td>
</tr>
</tbody>
</table>
<p>但是当前大部分浏览器的事件对象都已经趋近于统一，比如上图是<code>chrome</code>的事件对象，其中也涵盖了大部分上述所谓IE属性。</p>
<h2 id="标准-Event-属性"><a href="#标准-Event-属性" class="headerlink" title="标准 Event 属性"></a>标准 Event 属性</h2><p>下面列出了 2 级 DOM 事件标准定义的属性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bubbles</td>
<td style="text-align:left">返回布尔值，指示事件是否是起泡事件类型。</td>
</tr>
<tr>
<td style="text-align:left">cancelable</td>
<td style="text-align:left">返回布尔值，指示事件是否拥有可取消的默认动作。</td>
</tr>
<tr>
<td style="text-align:left">currentTarget</td>
<td style="text-align:left">返回其事件监听器触发该事件的元素。</td>
</tr>
<tr>
<td style="text-align:left">eventPhase</td>
<td style="text-align:left">返回事件传播的当前阶段。</td>
</tr>
<tr>
<td style="text-align:left">target</td>
<td style="text-align:left">返回触发此事件的元素（事件的目标节点）。</td>
</tr>
<tr>
<td style="text-align:left">timeStamp</td>
<td style="text-align:left">返回事件生成的日期和时间。</td>
</tr>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">返回当前 Event 对象表示的事件的名称。</td>
</tr>
</tbody>
</table>
<p>这部分参数中使用较多的可能是前面几个属性，比如<code>bubbles</code>，<code>cancelables</code></p>
<h2 id="标准-Event-方法"><a href="#标准-Event-方法" class="headerlink" title="标准 Event 方法"></a>标准 Event 方法</h2><p>下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">initEvent()</td>
<td style="text-align:left">初始化新创建的 Event 对象的属性。</td>
</tr>
<tr>
<td style="text-align:left">preventDefault()</td>
<td style="text-align:left">通知浏览器不要执行与事件关联的默认动作。</td>
</tr>
<tr>
<td style="text-align:left">stopPropagation()</td>
<td style="text-align:left">不再派发事件。</td>
</tr>
</tbody>
</table>
<p>这些方法是挂载在原型链的<code>Event</code>对象上的，所以直接的点击或其他事件是看不到的。</p>
<h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><ol>
<li><p><code>currentTarget</code>、<code>srcElement</code>与<code>target</code></p>
<ol>
<li><p><code>currentTarget</code>事件属性返回其事件侦听器触发事件的元素。</p>
<p><code>target</code>始终返回触发事件的真实元素。（在事件冒泡中与<code>currentTarget</code>不同）</p>
</li>
<li><p><code>currentTarget</code>在直接捕捉e得到的结果为<code>null</code>，必须在函数中通过一个变量存储下来。</p>
<p><code>target</code>的值会始终存储在e中，可以直接通过e查看。</p>
</li>
<li><p><code>srcElement</code>与<code>target</code>一致，指向事件触发的元素，旧版本firefox不支持。</p>
</li>
</ol>
</li>
<li><p><code>detail</code>：<strong>detail</strong>属性返回一个包含事件详细信息的数字。在onclick和ondblclick上使用时，该数字表示当前的点击次数。在onmousedown和onmouseup上使用时，该数字表示当前点击次数加1。</p>
</li>
<li><p><code>isTrusted</code>：isTrusted事件属性返回一个布尔值，指示事件是否可信。<br>注意：在Chrome，Firefox和Opera中，如果事件由用户调用，则该事件是受信任的，如果由脚本调用，则不受信任。在IE中，除了使用<code>createEvent()</code>方法创建的事件之外，所有事件都是可信任的。</p>
</li>
<li><p><code>relatedTarget</code>：<strong>relatedTarget</strong>属性返回与触发鼠标事件的元素相关的元素。<strong>relatedTarget</strong>属性可以与<strong>mouseover</strong>事件一起使用，以指示光标刚刚退出的元素，或者使用<strong>mouseout</strong>事件来指示光标刚刚输入的元素。</p>
</li>
<li><p><code>which</code>：<strong>which</strong>属性返回一个数字，表示触发鼠标事件时按下了哪个鼠标按钮。（注意与<code>button</code>不一致）</p>
<p>| 项目     | 描述                                                         |<br>| :——- | :———————————————————– |<br>| 返回值： | 一个数字，表示鼠标事件发生时按下的鼠标按钮。可能的值：<br />0：没有按钮<br />1：鼠标左键<br />2：滚轮按钮或中间按钮（如果有）<br />3：鼠标右键<br /><strong>注意</strong>：对于左侧配置的鼠标，返回值会反转。 |</p>
</li>
</ol>
<h2 id="视窗相关参数"><a href="#视窗相关参数" class="headerlink" title="视窗相关参数"></a>视窗相关参数</h2><p>这里具体详解视窗相关参数：</p>
<ol>
<li><p><code>clientX</code>,<code>clientY</code>：在<strong>页面</strong>（不包括浏览器bar部分）可视范围，与最左面，最上面的距离。</p>
</li>
<li><p><code>pageX</code>、<code>pageY</code>：在整个页面范围内（包括不可视的部分），与最左面，最上面的距离。</p>
</li>
<li><p><code>screenX</code>、<code>screenY</code>：距离显示器最左面，最上面的距离。（当窗口全屏时，即<code>client</code>加浏览器bar）</p>
</li>
<li><p><code>layerX</code>、<code>layerY</code>：鼠标相比较于当前坐标系的位置,即如果触发元素没有设置绝对定位或相对定位,以页面为参考点,如果有,将改变参考坐标系,从触发元素盒子模型的border区域的左上角为参考点。值得注意的是：该属性是以<code>border</code>边界为0，而<code>offset</code>是以<code>content</code>边界为0。</p>
<p><strong>但是<code>MDN</code>上标注该属性为非规范属性，各个浏览器结果预期不一致，最好不要使用。</strong></p>
</li>
<li><p><code>offsetX</code>、<code>offsetY</code>：距离事件触发元素的左面，上面的距离。</p>
<ol>
<li>注意：<code>offset</code>中，<code>padding</code>会被算在内。<code>border</code>会被算作负值。即<code>offset</code>是以<code>padding</code>作为边界的，超过这个边界即被判为负值。</li>
</ol>
</li>
<li><p><code>DOM</code>元素还含有一个属性用于计算该元素相对于<strong>视窗</strong>的距离：<code>getBoundingClientRect()</code>，该方法有4个属性：</p>
<ol>
<li><p>top：元素上边到视窗上边的距离;</p>
</li>
<li><p>right：元素右边到视窗左边的距离;</p>
</li>
<li><p>bottom：元素下边到视窗上边的距离;</p>
</li>
<li><p>left：元素左边到视窗左边的距离;</p>
<p>注意：这些属性一旦超出视窗范围即为负数</p>
</li>
</ol>
</li>
<li><p>DOM元素还带有以下一组（4个）属性：</p>
<ol>
<li><code>offsetLeft</code>：返回元素相对于父级元素的左侧偏移量</li>
<li><code>offsetTop</code>：返回元素相对于父级元素的左侧偏移量</li>
<li><code>offsetHeight</code>：返回元素的高度（包括<code>padding</code>，<code>border</code>）</li>
<li><code>offsetWidth</code>：返回元素的宽度（包括<code>padding</code>，<code>border</code>）</li>
<li><code>offsetParent</code>：返回元素的父级元素</li>
<li><code>clientLeft</code>：返回元素到父级元素左侧的距离（包括<code>padding</code>，不包括<code>border</code>）</li>
<li><code>clientTop</code>：返回元素到父级元素上侧的距离（包括<code>padding</code>，不包括<code>border</code>）</li>
<li><code>clientHeigt</code>：返回元素的高度（包括<code>padding</code>，不包括<code>border</code>）</li>
<li><code>clientWidth</code>：返回元素的宽度（包括<code>padding</code>，不包括<code>border</code>）</li>
<li><code>scrollHeight</code>：返回元素的滚动总高度（即总页面，包括因滚动而不在视野内的）（包括<code>padding</code>，不包括<code>border</code>）</li>
<li><code>scrollWidth</code>：返回元素的滚动宽度（即总页面，包括因滚动而不在视野内的）（包括<code>padding</code>，不包括<code>border</code>）</li>
</ol>
</li>
</ol>
<p>具体需要注意的是：</p>
<ol>
<li>即<code>offsetxxx</code>包括<code>border</code>，其他的<code>clientxxx</code>，<code>scrollxxx</code>不包括<code>border</code></li>
<li>这个距离与<code>dom.style.left</code>一样，指的是相对于外层具有定位标志（具有<code>positon</code>样式的元素）的祖先元素的距离。（若外层元素没有<code>positon</code>属性，则以<code>ducoment</code>为其定位元素）</li>
<li>通过<code>element.style.left</code>只能用来赋值（是字符串，需加后缀<code>px</code>），无法直接获取其值，必须通过上面的<code>offsetLeft</code>来获取其具体值。</li>
</ol>
<p><img src="\images\vue插件\vue插件2-2.png" alt="事件参数"></p>
]]></content>
      <categories>
        <category>Vue插件</category>
      </categories>
      <tags>
        <tag>Vue插件</tag>
        <tag>事件参数</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码1-从初始化到响应式原理</title>
    <url>/2020/01/08/Vue%E6%BA%90%E7%A0%811-%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>首先介绍后面要用到的几个类：</p>
<ul>
<li>Observer类：用于将一个数据变为响应式（可被观测）</li>
<li>Watcher类：一个依赖（一个指令对应一个依赖），一旦有一个指令用到了某个对象属性，那么就会新建一个Watcher作为订阅者。</li>
<li>Dep类：依赖管理器，一个对象属性对应一个Dep，其有一个内部属性<code>subs</code>用于存放依赖。</li>
</ul>
<h2 id="Vue初始化"><a href="#Vue初始化" class="headerlink" title="Vue初始化"></a>Vue初始化</h2><p>Vue原型是在<code>src/instance/idnex.js</code>中定义的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/instance/idnex.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>
<p>可以看到Vue原型是一个function。在这个函数只判断了是否是new出来的，否则报警告。然后直接调用了_init()方法，这个方法是在下面的<code>initMixin(Vue)</code>中混入的初始化方法。下面看一下这个方法中的重要部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//init.js 52-72 liens </span></span><br><span class="line"></span><br><span class="line">	initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//state包括data，props，methods</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里按顺序进行了一下操作(最简化，不考虑分支)：</p>
<ol>
<li><p>首先初始化了生命周期  <code>initLifecycle(vm)</code></p>
</li>
<li><p>初始化了事件($on,$emit,$once…)  <code>initEvents(vm)</code></p>
</li>
<li><p>初始化了render <code>initRender(vm)</code></p>
</li>
<li><p>调用了<code>beforeCreate</code>生命周期 <code>callHook(vm, &#39;beforeCreate&#39;)</code></p>
</li>
<li><p>是初始化inject  <code>initInjections(vm)</code></p>
</li>
<li><p>接下来的initState中，初始化了data,props,methods。 <code>initState(vm)</code></p>
</li>
<li><p>初始化provide <code>initProvide(vm)</code></p>
</li>
<li><p>调用生命周期created，<code>callHook(vm, &#39;created&#39;)</code>,如同官网所说：</p>
<blockquote>
<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前尚不可用。</p>
</blockquote>
</li>
<li><p>最后一步将el挂载到页面。<code>vm.$mount(vm.$options.el)</code></p>
</li>
</ol>
<h2 id="响应式原理（以对象为例）"><a href="#响应式原理（以对象为例）" class="headerlink" title="响应式原理（以对象为例）"></a>响应式原理（以对象为例）</h2><p>响应式的所有文件都放在observer文件夹下：</p>
<ul>
<li>observer<ul>
<li>array.js:数组的处理相关处理</li>
<li>dep.js:依赖管理器类的定义及其处理</li>
<li>index.js:整个observer的出口</li>
<li>scheduler.js:调度者相关文件</li>
<li>traverse.js:递归遍历一个对象，以唤醒所有转换getter，使每个嵌套的属性内的对象作为“深度”依赖项收集。</li>
<li>watcher.js:观测者，依赖的类定义与相关处理。</li>
</ul>
</li>
</ul>
<p>还是接着上面的第6步:<code>initState</code></p>
<p>initState方法定义在state.js中，下面节选这一部分中内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//state.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//代理处理</span></span><br><span class="line">    <span class="comment">//比如当我们调用this.xxx 的时候实际上它是挂载在vm._data.xxx的，这里的代理同样使用了Object.defineProperty()来进行了代理。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到intiState中，Vue进行了下面主要操作：</p>
<ul>
<li><code>initProps(vm, opts.props)</code></li>
<li><code>initMethods(vm, opts.methods)</code></li>
<li><code>initData(vm)</code></li>
<li><code>initWatch(vm, opts.watch)</code></li>
</ul>
<p>然后以<code>data</code>为例，分析对data的处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//state.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数里</p>
<ol>
<li>首先看data是一个对象还是一个函数，对其进行对应的处理</li>
<li>然后判断他不能与<code>props</code>,<code>methods</code>中的属性同名，因为最终这三部分都会被挂载到vm实例上。</li>
<li>最后调用<code>observe()</code>方法来使data变为可被观测的</li>
</ol>
<p>然后我们看<code>observe()</code>方法，这个方法就位于observer下的index.js中了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//observer/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为整个将数据变为响应式的入口函数，它进行了一下操作：</p>
<ol>
<li><p>判断传入的val如果不是一个对象或者是一个Vnode，就直接返回，不做处理</p>
</li>
<li><p>判断整个val是否有<code>__ob__</code>整个属性或者是不是Observer的子类，如果是的话，直接将<code>val.__ob__</code>返回</p>
</li>
<li><p>进行了一系列的其他的判断，比如是否应该被观测（<code>shouldObserve</code>这个对象定义在全局中，判</p>
<p>标识此时是否应该处理数据）、是否处于服务端渲染模式、是一个数组或是一个对象、是不是可扩展的、是不是Vue本身。</p>
</li>
<li><p>新建一个Observer对象，并将value传入。</p>
</li>
</ol>
<p>继续向下看，新建Observer对象过程，Observer对象也在index中定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//observer/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Observer对象包含了三个私有属性：</p>
<ul>
<li>value：当前观测对象</li>
<li>dep：依赖管理器</li>
<li>vmCount：将这个对象作为$data的数量</li>
</ul>
<p>再看他的构造方法中，执行流程如下：</p>
<ol>
<li>初始化了value，dep，vmCount</li>
<li>并给value的加上一个(不可枚举的)<code>__ob__</code>属性，可以联系上面判断<code>__ob__</code>的操作</li>
<li>判断value是否是一个数组，然后执行对数组的observer操作。现不看数组。</li>
<li>如果不是，则代表value是一个对象，则执行<code>walk()</code>方法对其进行处理。</li>
<li>在<code>walk()</code>中，可以看到Vue遍历了对象的所有属性并对其调用了<code>defineReactive</code>方法</li>
</ol>
<p>我们再跟进<code>defineReactive</code>方法中（这个方法就差不多是核心了）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//为每一个属性建立一个依赖收集器</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify() </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是分析一下他的执行流程：</p>
<ol>
<li>首先建立了一个Dep对象，即每一个属性都有一个依赖管理器用来收集用到这个属性的依赖，这一部分后面在讲。</li>
<li>判断这个对象属性能否被修改，及判断其<code>configurable</code>属性。</li>
<li>判断这个对下给你属性是否自带了<code>getter</code>与<code>setter</code>，如果有的话就将其缓存下来。</li>
<li>判断是否在函数调用时为这个对下给你属性传入了<code>customSetter</code>，如果有的话，则先调用getter将其值存储下来。</li>
<li>判断有无子对象或者是否在函数调用时确定只观测表层属性（不循环处理），如果都不满足则递归进行子属性的响应式处理。</li>
<li>这里就使整个响应式的核心：<code>Object.defineProperty</code>，在这里Vue为其定义了<code>enumerable</code>,<code>configurable</code>,<code>get</code>,<code>set</code><ol>
<li>get()：<ol>
<li>获取原始的属性值（通过原始getting或者直接获取）</li>
<li>判断Dep.target的值是否存在（这个值后面介绍Dep对象时介绍，代表的是当前的依赖），如果存在的话，就<strong>调用dep对象的<code>depend()</code>方法进行依赖收集。</strong></li>
<li>接下来判断是否有子ob对下给你，如果有的话，也调用子的dep的depend方法进行依赖收集。同时判断对象属性原来的值是否是个数组，如果是的话，调用<code>dependArray</code>方法进行数组的依赖收集。</li>
</ol>
</li>
<li>set()<ol>
<li>获取对象属性原本的值，调用原来的getter，如果没有，就接受传入的值。</li>
<li>判断有没有必要更新。</li>
<li>判断是否有<code>customSetter</code>，如果有的话，就调用</li>
<li>如果只有getter，没有setter，则直接返回。这里是为了修复#7981的BUG，问题大概是如果一个对象属性如果被其他插件修改后只有getter，但没有setter，也就是说整个插件的原意是将其变为一个不可写入的属性，但是如果不加这一句进行判断，那么Vue会直接调用<code>val = newVal</code>，对其进行赋值。这不符合预期，所以加了这一句判断，直接返回不进行处理。</li>
<li>判断如果原来有setter的话，就调用其setter。否则就直接赋值给val。</li>
<li>然后同样是对子属性的处理。</li>
<li><strong>这一步进行依赖派发。</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>至此，<code>defineReactive</code>方法流程介绍完毕。但是我们还留下了两个坑</p>
<ul>
<li>依赖收集<code>dep.depend()</code>具体如何完成的</li>
<li>依赖通知<code>dep.notify()</code>具体如何完成的</li>
</ul>
<p>接下来我们在进入这两个函数进行分析。</p>
<p>首先我们看一下Dep对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//observer/dep.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> type Watcher <span class="keyword">from</span> <span class="string">'./watcher'</span></span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> * 一个dep可以有多个指令（包括"&#123;&#123;&#125;&#125;","v-text","v-html"...）订阅它。</span></span><br><span class="line"><span class="comment"> * target属性用于表示正在处理的依赖，当确定为这个值的指令时，则将其添加到subs中（addSub函数）。</span></span><br><span class="line"><span class="comment"> * subs属性用于存放所有的依赖，他的依赖是Watcher类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span><span class="comment">/* 这个依赖管理器Dep实例 */</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// This is globally unique because only one watcher</span></span><br><span class="line"><span class="comment">// can be evaluated at a time.</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Dep对象有三个属性，</p>
<ul>
<li>target：一个静态属性，类型是<code>Watcher</code>，即当前执行的依赖</li>
<li>id：Dep的标识符</li>
<li>subs：整个dep中所有的依赖，是一个Watcherd数组</li>
</ul>
<p>然后我们直接看<code>depend()</code>方法：</p>
<p>这个函数判断dep的target是否存在，如果存在的话，则调用当前依赖的addDep方法，我们知道这个target是一个Watcher。所以我们看一下Watcher：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化了很多属性</span></span><br><span class="line">    vm: Component;</span><br><span class="line">      expression: string;</span><br><span class="line">      cb: <span class="built_in">Function</span>;</span><br><span class="line">      id: number;</span><br><span class="line">      deep: boolean;</span><br><span class="line">      user: boolean;</span><br><span class="line">      lazy: boolean;</span><br><span class="line">      sync: boolean;</span><br><span class="line">      dirty: boolean;</span><br><span class="line">      active: boolean;</span><br><span class="line">      deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">      newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">      depIds: SimpleSet;</span><br><span class="line">      newDepIds: SimpleSet;</span><br><span class="line">      before: ?<span class="built_in">Function</span>;</span><br><span class="line">      getter: <span class="built_in">Function</span>;</span><br><span class="line">      value: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        <span class="comment">//调用depaddSub方法把这个指令（this）添加到这个dep中</span></span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在addDep中，判断这个<code>Watcher</code>对应的新dep中是否含有这个传进来的Dep，如果没有就其push到新dep与新depIds中，然后判断原来的dep中是否含有这个watcher，如果没有，就push进来。</p>
<p>这里的newDep与dep是为了灵活的动态更新视图，思考以下场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;span v-if&#x3D;&quot;nameShow&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;span&gt; </span><br><span class="line">        &lt;span v-if&#x3D;&quot;ageShow&quot;&gt;&#123;&#123;age&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input :value&#x3D;&quot;name&quot;&#x2F;&gt;</span><br><span class="line">        &lt;input :value&#x3D;&quot;age&quot;&#x2F;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;button @click&#x3D;&quot;nameShow &#x3D; !nameShow&quot;&gt;切换name状态&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;ageShow &#x3D; !ageShow&quot;&gt;age&lt;&#x2F;button&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;Register&quot;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      nameShow: true,</span><br><span class="line">      ageShow: true,</span><br><span class="line">      name:&quot;123&quot;,</span><br><span class="line">      age:&quot;111&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>当nameShow与ageShow都是true时，我们对表单机进行修改以修改name与age的值时，肯定会涉及到到依赖的分发。</p>
<p>但是当我们点击button将nameShow或ageShow的值切换为false时，视图上已经不显示对应信息，则讲道理应该不会在对这个依赖进行通知。这个newDep的存在就是为了这里。</p>
<p>至此，依赖收集的过程基本完成。下面看看如何进行依赖派发的：</p>
<p>当一个对象属性被改变时，其set方法就会被调用，由此调用<code>dep.notify()</code>，进行依赖派发。我们看一下<code>dep.notify()</code>这个函数内部：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//observer/dep.js</span></span><br><span class="line"></span><br><span class="line">notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到首先是对<code>subs</code>所有的依赖进行了排序，根据官方的注释是应为：如果subs不是异步运行的话，那么他们没有在调度者中进行排序，所以我们需要对其进行排序以保证其正确按序派发。</p>
<p>然后这里调用每一个watcher的update方法，进行DOM的更新。看一下<code>update()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到首先判断了这个watcher是不是懒加载的，如果是的话，将其dirty属性变为true，Vue会在调用到它时进行加载，否则看他是不是同步的，如果是的话，立即调用<code>run()</code>进行DOM更新操作，否则就将其推入到<code>queueWatcher</code>队列中，等待调度者，进行调度。（这里就不再讲调度算法，后续再讲）</p>
<p>再进入<code>run()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//observer/watcher.js  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由官方的注释也可以看出来，这个<code>run()</code>是由调度者进行执行的（除非他是一个同步的watcher）</p>
<p><code>run()</code>函数的运行流程如下：</p>
<ol>
<li>判断这个wacher是否的活动的，如果是才操作。</li>
<li>通过<code>get()</code>获取这个watcher对应的值，判断获取到的值与watcher中保存的值是否相同</li>
<li>如果不等，则把当前watcher中保存的值作为oldValue保存下来，将当前watcher中的value设为获取到的value，然后判断这个watcher是不是用户定义的（this.user）（根据调度者中注释，watcher分为user watcher与render watcher），如果使用定义的watcher则用<code>try--catch</code>预防错误，否则直接调用这个watcher的回调函数。这个回调函数就会进行真正操作，比如调用rrnder更新DOM。</li>
</ol>
<h2 id="数组的响应式如何实现"><a href="#数组的响应式如何实现" class="headerlink" title="数组的响应式如何实现"></a>数组的响应式如何实现</h2><p>在上面我们介绍<code>Dep</code>对象时，在其构造方法中，我们只看了<code>this.walk()</code>对对象的操作，现在我们看一下对数组的操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果value是一个对象，那么会判断value有没有<code>__ptoto__</code>对象，因为部分浏览器不支持这个属性，如果有的话，则调用<code>protoAugment(value, arrayMethods)</code>把<code>arrayMethods</code>挂载到value的<code>__proto__</code>上，我们再看一下<code>arrayMethods</code>，它放在</p>
<p>observer/array.js中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * not type checking this file because flow doesn't play well with</span></span><br><span class="line"><span class="comment"> * dynamically accessing methods on Array prototype</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<ol>
<li>首先是以原生Array的prototype作为原型创建了一个新的对象<code>arrayMethods</code>。</li>
<li>列举出需要被修改的数组方法<code>methodsToPatch</code></li>
<li>对<code>methodsToPatch</code>进行forEach循环，并给arrayMethods定义每一个列举出的方法（不可枚举），如果这些方法中要为这个数组插值，我们必须也要探测这个值是否是一个引用类型（Araay或者Object），并也要将其变为响应式，所以后面判断了如果是<code>push</code>,<code>unshift</code>,<code>splice</code>则拿到要插入的值<code>inserted</code></li>
<li>判断<code>inserted</code>是否存在，如果存在，也使用<code>observeArray</code>将其变为响应式。</li>
<li>进行依赖收集<code>ob.dep.notify()</code></li>
<li>返回原始方法调用后返回的结果。</li>
</ol>
<p>然后我们再看<code>protoAugment</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span></span><br><span class="line">  target.__proto__ = src</span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到很简单，就只是把第一个参数的<code>__proto__</code>修改为第二个参数，结合我们刚刚传入的参数，即：将这个数组的<code>_proto_</code>修改为<code>arrayMethods</code>，即上面我们分析的这个对象。</p>
<p>再看<code>copyAugment</code>方法，这个方法也很简单，是针对不支持<code>__proto__</code>属性的浏览器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Augment a target Object or Array by defining</span></span><br><span class="line"><span class="comment"> * hidden properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* istanbul ignore next */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即遍历所有的方法名字，并将其设置为到目标数组上的不可枚举属性。</p>
<p>最后我们看一下<code>observeArray</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实际上就是将数组的每一个值变为响应式。</p>
<p>但是还有一点是：<strong>我们还可以通过下标的方式为数组赋值，但是JS中找不到方法检测整个操作，所以Vue也无法检测到，所以Vue提供了Vue.set和Vue.del这两个api，用来弥补这一点。</strong></p>
<p>至此，响应式的整个流程就差不多完成了。</p>
<p>最后梳理以下整个流程(对象)：</p>
<p><img src="\images\Vue源码1-从初始化到响应式原理\image-20200108185122998.png" alt="image-20200108185122998"></p>
<p>这个流程主要是我通过分析源码，借助一定的网上资料整理出来的，可能其中会有错误。希望大家指出来，谢谢。</p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>Vue源码</tag>
        <tag>响应式原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue首屏优化全解析</title>
    <url>/2021/10/16/Vue%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Vue首屏优化全解析"><a href="#Vue首屏优化全解析" class="headerlink" title="Vue首屏优化全解析"></a>Vue首屏优化全解析</h1><h2 id="打开GZIP"><a href="#打开GZIP" class="headerlink" title="打开GZIP"></a>打开GZIP</h2><h3 id="直接打包称为xxx-gz文件"><a href="#直接打包称为xxx-gz文件" class="headerlink" title="直接打包称为xxx.gz文件"></a>直接打包称为xxx.gz文件</h3><p>在前端打包过程中即生成gz文件可以减少部署服务器的打包过程，可以减少服务器的性能压力，提高响应时间。</p>
<p>使用webpack插件<a href="https://webpack.docschina.org/plugins/compression-webpack-plugin/" target="_blank" rel="noopener">CompressionWebpackPlugin</a>来实现gzip打包。</p>
<p>在vue项目根目录新建<code>webpack.config.js</code>来增加webpack配置。</p>
<p>下面是一个基本配置，具体详细见其文档。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">"compression-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">    plugins: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(env.mode === <span class="string">'production'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> comress = <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">        <span class="comment">//检测并压缩js和css文件</span></span><br><span class="line">        test: <span class="regexp">/\.(js|css|svg)$/</span>,</span><br><span class="line">        <span class="comment">//默认即为gzip，可以不写</span></span><br><span class="line">        algorithm: <span class="string">'gzip'</span>,</span><br><span class="line">        <span class="comment">//压缩选项，可以在node文档中找到所有选项</span></span><br><span class="line">        compressionOptions: &#123;</span><br><span class="line">            level: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//最小压缩体积，单位bytes，默认0</span></span><br><span class="line">        threshold: <span class="number">1600</span>,</span><br><span class="line">        <span class="comment">//最小压缩效率，ration = 压缩后体积/压缩前体积，只有效率小于这个值的时候才进行压缩，否则不压缩。默认0.8。传1则全部压缩。</span></span><br><span class="line">        minRatio: <span class="number">0.5</span>,</span><br><span class="line">        <span class="comment">//输出的文件名字，默认即为'[path][base].gz'，其他参数见文档</span></span><br><span class="line">        filename: <span class="string">'[path][base].gz'</span>,</span><br><span class="line">        <span class="comment">//是否删除源文件,默认false</span></span><br><span class="line">        deleteOriginalAssets: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">       config.plugins.push(compress)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中压缩选项[compressionOptions]可以在<a href="https://nodejs.org/api/zlib.html#zlib_class_options" target="_blank" rel="noopener">这里</a>查看。</p>
<p>注意这里有一个生产和开发两个环境来确定是否注入插件。</p>
<p>我们可以通过<code>Vue.config.productionTip = false /true</code>来改变当前环境。</p>
<h3 id="打开部署服务器gzip"><a href="#打开部署服务器gzip" class="headerlink" title="打开部署服务器gzip"></a>打开部署服务器gzip</h3><p>一般我们使用nginx来部署前端项目。所以我们这里仅仅介绍nginx的配置。</p>
<p>由于我们之前已经配置了直接打包为gz，此时服务器就不需要再进行压缩，直接传递给浏览器即可。此时我们再nginx的config配置文件中加入对应的配置项即可。</p>
<p>再<a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener">nginx官方文档</a>中，关于gzip多个API：</p>
<p>常用的有以下几个：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Syntax:</th>
<th>`<strong>gzip</strong> on</th>
<th>off;`</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">默认</td>
<td><code>gzip off;</code></td>
</tr>
<tr>
<td style="text-align:left">父级节点</td>
<td><code>http</code>, <code>server</code>, <code>location</code>, <code>if in location</code></td>
</tr>
<tr>
<td style="text-align:left">介绍</td>
<td>是否打开gzip</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Syntax:</th>
<th><code>**gzip_comp_level** *level*;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">默认</td>
<td><code>gzip_comp_level 1;</code></td>
</tr>
<tr>
<td style="text-align:left">父级节点</td>
<td><code>http</code>, <code>server</code>, <code>location</code></td>
</tr>
<tr>
<td style="text-align:left">介绍</td>
<td>压缩等级</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Syntax:</th>
<th><code>**gzip_min_length** *length*;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">默认</td>
<td><code>gzip_min_length 20;</code></td>
</tr>
<tr>
<td style="text-align:left">父级节点</td>
<td><code>http</code>, <code>server</code>, <code>location</code></td>
</tr>
<tr>
<td style="text-align:left">介绍</td>
<td>文件被压缩的临界大小</td>
</tr>
</tbody>
</table>
<p>这些API若直接属于http节点内，则所有的sever都会生效，而置于对应的server节点的话就只有对应的server会生效，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	gzip            on;</span><br><span class="line">    gzip_min_length 1000;</span><br><span class="line">    #gzip_proxied    expired no-cache no-store private auth;</span><br><span class="line">    #gzip_types      text&#x2F;plain application&#x2F;xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上我们再服务器放置的文件都是经过压缩的gz文件，所以我们只需要打开<code>gzip on</code>就行了。</p>
<h2 id="通过SplitChunks实现手动分包，公共包共享"><a href="#通过SplitChunks实现手动分包，公共包共享" class="headerlink" title="通过SplitChunks实现手动分包，公共包共享"></a>通过SplitChunks实现手动分包，公共包共享</h2><p>在<code>webpack</code>中，官方增加了<code>optimization.splitChunks</code>来手动进行分包。<br>其默认有一定的规则（只影响异步<code>chunks</code>）：</p>
<ul>
<li>新的 chunk 可以被共享，或者模块来自于 <code>node_modules</code> 文件夹</li>
<li>新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）</li>
<li>当按需加载 chunks 时，并行请求的最大数量小于或等于 30</li>
<li>当加载初始化页面时，并发请求的最大数量小于或等于 30</li>
</ul>
<p>对应的默认配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      minSize: <span class="number">20000</span>,</span><br><span class="line">      minRemainingSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">30</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">30</span>,</span><br><span class="line">      enforceSizeThreshold: <span class="number">50000</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        defaultVendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要了解几个重要的API，其他的参见<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">webpack官方文档</a>。</p>
<ol>
<li><code>splitChunks.chunks</code>：哪些chunks被执行拆分规则。默认：<code>async</code>。<ol>
<li><code>all</code>：所有的chunks都会被执行拆分。</li>
<li><code>async</code>：只有异步chunks才会被执行拆分。</li>
<li><code>initial</code>：只有入口chunks才会被执行拆分。</li>
</ol>
</li>
<li><code>splitChunks.maxAsyncRequests</code>：按需加载时的最大并行请求数。默认：<code>30</code>。</li>
<li><code>splitChunks.maxInitialRequests</code>：入口点的最大并行请求数。默认：<code>30</code>。</li>
<li><code>splitChunks.minChunks</code>：拆分前必须共享模块的最小 chunks 数，即一个被共享的模块想要被拆分，那么他被引用的次数至少为<code>minChunks</code>。默认：<code>1</code>。</li>
<li><code>splitChunks.minSize</code>：生成 chunk 的最小体积（以 bytes 为单位）。默认：20000即2.5KB。</li>
<li><code>splitChunks.maxSize</code>：告诉 webpack <strong>尝试</strong>将大于 <code>maxSize</code> 个字节的 chunk 分割成较小的部分。</li>
<li><code>splitChunks.maxAsyncSize</code>：<code>maxAsyncSize</code> 和 <code>maxSize</code> 的区别在于 <code>maxAsyncSize</code> 仅会影响按需加载 chunk。</li>
<li><code>splitChunks.maxInitialSize</code>：<code>maxInitialSize</code> 和 <code>maxSize</code> 的区别在于 <code>maxInitialSize</code> 仅会影响初始加载 chunks。</li>
<li><code>splitChunks.name</code>：拆分 chunk 的名称。设为 <code>false</code> 将保持 chunk 的相同名称，因此不会不必要地更改名称。这是生产环境下构建的建议值。</li>
<li><code>splitChunks.minRemainingSize</code>：确保拆分后剩余的最小 chunk 体积超过限制来避免大小为零的模块。其仅在剩余单个 chunk 时生效。</li>
</ol>
<p><code>maxSize</code> 只是一个提示，当模块大于 <code>maxSize</code> 或者拆分不符合 <code>minSize</code> 时可能会被违反。</p>
<h3 id="splitChunks-cacheGroups"><a href="#splitChunks-cacheGroups" class="headerlink" title="splitChunks.cacheGroups"></a>splitChunks.cacheGroups</h3><p>缓存组可以手动设置chunks的匹配规则。缓存组可以继承和/或覆盖来自 <code>splitChunks.*</code> 的任何选项。但是 <code>test</code>、<code>priority</code> 和 <code>reuseExistingChunk</code> 只能在缓存组级别上进行配置。</p>
<ol>
<li><p><code>splitChunks.cacheGroups.{cacheGroup}.priority</code>：一个模块可以属于多个缓存组。优化将优先考虑具有更高 <code>priority</code>（优先级）的缓存组。默认组的优先级为负，以允许自定义组获得更高的优先级（自定义组的默认值为 <code>0</code>）。默认：-20。</p>
</li>
<li><p><code>splitChunks.cacheGroups.{cacheGroup}.reuseExistingChunk</code>：如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块。这可能会影响 chunk 的结果文件名。默认：true。</p>
</li>
<li><p><code>splitChunks.cacheGroups.{cacheGroup}.test</code>：这个API可以接受一个函数，字符串以及正则表达式。一般可以使用正则表达式来确定规定文件夹或文件。也可以传入一个函数。<code>function (module, { chunkGraph, moduleGraph }) =&gt; boolean RegExp string</code>。省略它会选择所有模块。它可以匹配绝对模块资源路径或 chunk 名称。匹配 chunk 名称时，将选择 chunk 中的所有模块。</p>
</li>
<li><p><code>splitChunks.cacheGroups.{cacheGroup}.filename</code>：输出的文件名字。可以使用以下的占位符。</p>
<p>| 模板       | 描述                                                         |<br>| :——— | :———————————————————– |<br>| [file]     | filename 和路径，不含 query 或 fragment                      |<br>| [query]    | 带前缀 <code>?</code> 的 query                                          |<br>| [fragment] | 带前缀 <code>#</code> 的 fragment                                       |<br>| [base]     | 只有 filename（包含扩展名），不含 path                       |<br>| [filebase] | 同上，但已弃用                                               |<br>| [path]     | 只有 path，不含 filename                                     |<br>| [name]     | 只有 filename，不含扩展名或 path                             |<br>| [ext]      | 带前缀 <code>.</code> 的扩展名（对 <a href="https://webpack.docschina.org/configuration/output/#outputfilename" target="_blank" rel="noopener">output.filename</a> 不可用） |</p>
</li>
</ol>
<p>也可以传入函数<code>string function (pathData, assetInfo) =&gt; string</code></p>
<ol start="5">
<li><code>splitChunks.cacheGroups.{cacheGroup}.enforce</code>：告诉 webpack 忽略 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#splitchunksminsize" target="_blank" rel="noopener"><code>splitChunks.minSize</code></a>、<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#splitchunksminchunks" target="_blank" rel="noopener"><code>splitChunks.minChunks</code></a>、<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#splitchunksmaxasyncrequests" target="_blank" rel="noopener"><code>splitChunks.maxAsyncRequests</code></a> 和 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#splitchunksmaxinitialrequests" target="_blank" rel="noopener"><code>splitChunks.maxInitialRequests</code></a> 选项，并始终为此缓存组创建 chunk。（注意，这里说的是外部的<code>minSize</code>等，而缓存组内部的<code>minSize</code>是不会被忽略的，还是会被拆分。）</li>
</ol>
<p>下面贴一个拆分<code>element-plus</code>的拆分示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是elementplus的推荐的按需引用</span></span><br><span class="line"><span class="keyword">const</span> Components = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; ElementPlusResolver &#125; = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      Components(&#123;</span><br><span class="line">        resolvers: [ElementPlusResolver()],</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">    optimization: &#123;</span><br><span class="line">      splitChunks:&#123;</span><br><span class="line">        chunks: <span class="string">"all"</span>,</span><br><span class="line">        maxSize: <span class="number">30000</span>,</span><br><span class="line">        minSize: <span class="number">20000</span>,</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">          <span class="comment">// vendors: &#123;</span></span><br><span class="line">          <span class="comment">//   name: "chunk-vendors",</span></span><br><span class="line">          <span class="comment">//   test: /[\\/]node_modules[\\/]/,</span></span><br><span class="line">          <span class="comment">//   chunks: "initial",</span></span><br><span class="line">          <span class="comment">//   priority: 2,</span></span><br><span class="line">          <span class="comment">//   reuseExistingChunk: true,</span></span><br><span class="line">          <span class="comment">//   enforce: true</span></span><br><span class="line">          <span class="comment">// &#125;,</span></span><br><span class="line">          elementUI: &#123;</span><br><span class="line">            name: <span class="string">"chunk-elementplus"</span>,</span><br><span class="line">             <span class="comment">//最大12KB</span></span><br><span class="line">            maxSize: <span class="number">10000</span>,</span><br><span class="line">            minSize: <span class="number">1000</span>,</span><br><span class="line">             <span class="comment">//正则表达式来获取node_modules/element-plus/ 下的模块</span></span><br><span class="line">            test: <span class="regexp">/[\\/]node_modules[\\/]element-plus[\\/]/</span>,</span><br><span class="line">             <span class="comment">//所有的chunks都被拆分，异步或同步</span></span><br><span class="line">            chunks: <span class="string">"all"</span>,</span><br><span class="line">            priority: <span class="number">3</span>,</span><br><span class="line">            reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">             <span class="comment">//这里会忽略外部的minSize等，但内部的minSize仍然会被遵守</span></span><br><span class="line">            enforce: <span class="literal">true</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>cacheGroups</code>在组件是按需加载时，也是可以进行chunks拆分的。这是极好的，可以的按需加载的组件分包对优化十分友好。</p>
<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>当某一个组件十分大且不是常用组件的时候，使用路由按需加载就是一个不错的方法。</p>
<p>并且vue-router提供很友好的API来让我们进行路由懒加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Foo.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Bar.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Baz.vue'</span>)</span><br></pre></td></tr></table></figure>
<p>通过上述方式，被动态引入(使用<code>import()</code>函数动态导入)的组件将会被单独打包为一个chunk。</p>
<p>且我们可以通过注释自定义chunk的名称。</p>
<p>另外也可以使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    <span class="comment">/* 组件定义对象 */</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>来定义路由懒加载。</p>
<p>值得注意的是：<code>import()</code>动态引入也可以用在平时的组件导入。并且这个动态引入的组件也会被分包。按需加载。</p>
<h2 id="组件按需引入"><a href="#组件按需引入" class="headerlink" title="组件按需引入"></a>组件按需引入</h2><p>实际上我们平时的应用中，自己的代码不会很大，占体积大的一般都是一些第三方组件，比如UI组件，图表组件等。但是这些组件中并不是所有的组件我们都会用到。特别是图表类组件。这个时候使用按需引入十分关键。</p>
<p>一般来说按需引入即为我们手动在使用对用组件的父组件中引入和声明组件。比如<code>Element-ui</code>中。但是在一些新的UI组件，特别是Vue3出来之后，很多组件有了更加智能化的按需导入，我们不用全局导入，只需要使用和配置webpack插件，插件即可自动完成组件的引入，十分方便，比如下列的<code>element-plus</code>的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//安装插件</span><br><span class="line">npm install unplugin-vue-components</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> Components = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; ElementPlusResolver &#125; = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    Components(&#123;</span><br><span class="line">      resolvers: [ElementPlusResolver()],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上述是<code>webpack.config.js</code>，使用vue时，需要配置到<code>vue.config.js</code>中。具体见<a href="https://cli.vuejs.org/zh/guide/webpack.html" target="_blank" rel="noopener">webpack 相关</a>。</p>
<h2 id="静态资源手动压缩，使用CDN"><a href="#静态资源手动压缩，使用CDN" class="headerlink" title="静态资源手动压缩，使用CDN"></a>静态资源手动压缩，使用CDN</h2><p>CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/内容分发网络/4034265" target="_blank" rel="noopener">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
<p>我们可以将自己的静态资源上传到CDN中，在用户进行请求的时候，CDN会根据其位置选择合适的服务器进行资源传送。以获得更好网络性能。</p>
<p>值得注意的是，某些比较大库也可以用CDN引入，不仅可以减少服务器网络压力。还可以保证其稳定性。比如一些公共的CDN站点，比如<a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">bootCDN</a>。</p>
<ol>
<li><p>在HTML文件中引入<code>script</code>标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= BASE_URL %&gt;favicon.ico"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关键，引入对应的标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue@next"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We're sorry but <span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span> doesn't work properly without JavaScript enabled. Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置<code>webpack</code>的<code>externals</code>，下面是<code>vue.config.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//其他参数</span></span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    externals: &#123;</span><br><span class="line">      <span class="string">'vue'</span>: <span class="string">'Vue'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//其他参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>值得注意有两点：</p>
<ol>
<li>库的引入要直接从库中引入，而不是从路径中引入（一般安装进node_modules都是从库中引入，所以只是注意一下）。即：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>packge.json</code><strong>中的版本应该与html中引入的一致，否则会发生错误。</strong></li>
</ol>
</li>
</ol>
<p>经测试，Vue使用外部CDN，vender体积在gzip下的62.79 KiB下降到37.84KiB。优化明显！</p>
<p>国内各大云平台都有CDN服务，比如阿里云，腾讯云等。下面简单演示将vue.js替换为CDN。</p>
<h2 id="使用ES6模块替代Node模块，帮助webpack进行tree-shake"><a href="#使用ES6模块替代Node模块，帮助webpack进行tree-shake" class="headerlink" title="使用ES6模块替代Node模块，帮助webpack进行tree-shake"></a>使用ES6模块替代Node模块，帮助webpack进行tree-shake</h2><p>因为webpack的Tree-shake是基于ES6的静态结构。所谓静态结构。即不能动态的根据代码条件来导入。</p>
<p>即只能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'mw'</span></span><br></pre></td></tr></table></figure>
<p>而不能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Error syntax</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'mw'</span></span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">    <span class="keyword">import</span>(xxx)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">import</span>(yyy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能动态引入即可以在词法分析阶段就可以确定模块之间的引入关系。进而就可以通过直接去掉没被引用的模块。</p>
<p>所以我们可以尽量使用ES6的模块，并且我们可以在<code>ackage.json</code>中配置<code>sideEffects</code>属性来帮助webpack确定哪些模块是纯的ES6模块，可以直接进行<code>Tree-shake</code>。</p>
<h2 id="关闭source-map"><a href="#关闭source-map" class="headerlink" title="关闭source-map"></a>关闭source-map</h2><p>由于打包生成打代码都是经过压缩的，但是在产生错误的时候就会不好调试，此时就诞生了<code>source-map</code>。在源代码产生错误或者信息的时候，我们通过source-map查找到未压缩的源代码的位置。</p>
<p>但是在生产环境中，我们不想把源代码暴露给用户，并且source-map由于没有压缩，体积一般偏大。所以我们一般可以在生产环境中将其关闭。</p>
<p>vue可以这样关闭：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    productionSourceMap: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除冗余代码"><a href="#删除冗余代码" class="headerlink" title="删除冗余代码"></a>删除冗余代码</h2><p>webpack原生的压缩工具minimizer功能有限，我们想要极致的压缩合并配置可以使用<code>UglifyJS</code>，而<code>UglifyJS</code>内核是 <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="noopener">uglify-js</a>。</p>
<p>其包含很多配置，详细地址<a href="https://github.com/mishoo/UglifyJS#compress-options" target="_blank" rel="noopener">Compress options</a>，下面简单给出一些用的比较多的：</p>
<ul>
<li><code>drop_console</code> (default: <code>false</code>) — Pass <code>true</code> to discard calls to <code>console.*</code> functions. If you wish to drop a specific function call such as <code>console.info</code> and/or retain side effects from function arguments after dropping the function call then use <code>pure_funcs</code> instead.</li>
<li><code>drop_debugger</code> (default: <code>true</code>) — remove <code>debugger;</code> statements</li>
<li><code>booleans</code> (default: <code>true</code>) — various optimizations for boolean context, for example <code>!!a ? b : c → a ? b : c</code></li>
</ul>
<p>前两个默认是关闭的，打开之后就可以在代码中去掉<code>console</code>和<code>debugger</code>。</p>
<p>下面是一个简单的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    configureWebpack : &#123;</span><br><span class="line">        optimization: &#123;</span><br><span class="line">          minimizer: [</span><br><span class="line">              <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                test: <span class="regexp">/\.js(\?.*)?$/i</span>,</span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">                uglifyOptions: &#123;</span><br><span class="line">                    compress: &#123;</span><br><span class="line">                        drop_console: <span class="literal">true</span>,</span><br><span class="line">                        drop_debugger: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;),</span><br><span class="line">        ],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ssr或者Prerendering"><a href="#ssr或者Prerendering" class="headerlink" title="ssr或者Prerendering"></a>ssr或者Prerendering</h2><p>如果仅仅是首页优化，那么使用<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerendering</a>更好。因为相较于ssr，不需要服务器承担html文件的编译。prerendering即是把对应的路由先生成<code>html</code>。</p>
<p>prerendering一个简单的示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PrerenderSPAPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">      <span class="comment">// Required - The path to the webpack-outputted app to prerender.</span></span><br><span class="line">      staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">      <span class="comment">// Required - Routes to render.</span></span><br><span class="line">      routes: [ <span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/some/deep/nested/route'</span> ],</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>优化</tag>
        <tag>首屏优化</tag>
      </tags>
  </entry>
  <entry>
    <title>about跨域</title>
    <url>/2021/02/09/about%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="域的概念"><a href="#域的概念" class="headerlink" title="域的概念"></a>域的概念</h1><p><strong>域（Domain）</strong>作为计算机网络中一个重要的概念，其阐述的是：网络中一组计算机的逻辑集合，是活动目录中的核心单元、是活动目录的分区。其有以下特点：</p>
<ol>
<li><p>域定义了安全边界，每个域均有各自的安全策略以及与其它域的信任关系，在没有授权的情况下，不允许其他域中的用户访问本域中的资源。</p>
</li>
<li><p>中可以存储上百万个对象，不同的域之间具有层次关系，可以建立域树或域林，以便于域的扩展。域树通常由一个或多个共享连续的名称空间的域组合而成，其中第一个域称作根域，其他域称为子域，如图。</p>
<p><img src="\images\跨域\子域.png" alt="子域"></p>
</li>
<li><p>域林通常由一个或多个域树组成，如图10-15所示。其中，各个域树并不共享相同的名称空间，但域林内所有域树的域都具有相同的架构、配置信息、全局目录（Global Catalog）等。</p>
<p><img src="\images\跨域\域林.png" alt="域林"></p>
</li>
</ol>
<p>所以浏览器根据域的概念，规定了<strong>同源策略（Sameoriginpolicy）</strong>，其是浏览器最重要的安全策略之一。其保证了每个网页的安全性。确保非同源站点无法相互访问资源，JavaScript交互等。具体到浏览器中，同源是指具有相同的：</p>
<ul>
<li>协议</li>
<li>域名</li>
<li>子域</li>
<li>端口</li>
</ul>
<p>这其中任何一项不同，皆被视为非同源。会受到同源策略的限制。具体的<code>url</code>的格式：</p>
<p><img src="\images\跨域\域名结构.png" alt="域名结构"></p>
<p>注意：上面写的仅仅是url中影响影响跨域的4部分，url还有一下的部分：</p>
<ul>
<li>虚拟目录部分</li>
<li>文件名部分</li>
<li>锚点部分</li>
<li>参数部分</li>
</ul>
<p>完整的目录结构如下：</p>
<p><img src="\images\跨域\完整域名结构.png" alt="完整域名结构"></p>
<p>在浏览器中，同源策略限制的对象有：</p>
<ol>
<li>Cookie、sessionStorage、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求</li>
</ol>
<p>但是下面的4个请求是允许跨域请求资源的：</p>
<ul>
<li><code>&lt;img src=XXX&gt;</code></li>
<li><code>&lt;video src=XXX&gt;</code></li>
<li><code>&lt;link href=XXX&gt;</code></li>
<li><code>&lt;script src=XXX&gt;</code>                       </li>
</ul>
<h1 id="客户端和服务端通信"><a href="#客户端和服务端通信" class="headerlink" title="客户端和服务端通信"></a>客户端和服务端通信</h1><h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a><code>jsonp</code></h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>jsonp（JSON with Padding）</code>本身是一种<code>hack</code>的方法来实现跨域，其利用的原理有两个：</p>
<ol>
<li><code>script</code>没有同源策略的限制。</li>
<li><code>script</code>标签请求的数据会直接执行。这一点就排除了<code>img</code>和<code>link</code>两个标签。</li>
</ol>
<p>具体原理是：利用<code>script</code>的<code>src</code>属性，发送带有<code>callback</code>回调函数的GET请求，服务端在接受数据后，将要发送的数据作为函数的参数传回<code>client</code>，由于<code>script</code>会立即执行，则可以直接拿到数据。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>兼容性强，支持IE10以下浏览器跨域问题（<code>CORS</code>不支持）</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>仅支持GET方法（由<code>script</code>标签的请求性质决定）</p>
</li>
<li><p>安全性不高，易遭受攻击</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><h5 id="原生JavaScript实现"><a href="#原生JavaScript实现" class="headerlink" title="原生JavaScript实现"></a>原生JavaScript实现</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//拿到服务端结果</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//发送JSONP请求</span></span><br><span class="line">    <span class="keyword">let</span> jp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">	script.type= <span class="string">'text/javascript'</span></span><br><span class="line">	jp.src = <span class="string">'http://www.jsonp.com:8080/login?user = admin &amp; callback = login'</span></span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>jsonp</code>中的<code>src</code>其实并不是一个脚本地址，而是一个请求地址。</p>
<h5 id="JQuery实现"><a href="#JQuery实现" class="headerlink" title="JQuery实现"></a><code>JQuery</code>实现</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ajax(&#123;</span><br><span class="line">    url: <span class="string">'http://www.jsonp.com:8080/login'</span>,</span><br><span class="line">    type: <span class="keyword">get</span>,</span><br><span class="line">    dataType: 'jsonp',</span><br><span class="line">    jsonCallback: 'login',</span><br><span class="line">    data: &#123;</span><br><span class="line">        user: <span class="string">'admin'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//拿到结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="axios实现"><a href="#axios实现" class="headerlink" title="axios实现"></a>axios实现</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.getJSON(<span class="string">"https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//data    </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><p>返回数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">login(&#123;<span class="string">'status'</span>: <span class="literal">true</span>, <span class="string">'user'</span>: <span class="string">'admin'</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="CORS方案"><a href="#CORS方案" class="headerlink" title="CORS方案"></a><code>CORS</code>方案</h2><p><code>CORS（Cross-origin resource sharing）</code>，即跨域资源共享。它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源安全策略</a> 默认阻止“跨域”获取资源，即网页发送的跨域请求根本不会达到服务器即被浏览器拦截，服务器没有决定的权限。但是 <code>CORS</code> 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。</p>
<p><code>CORS</code>将不同的请求分为简单请求与复杂请求，根据请求的不同，<code>CORS</code>会进行不同的操作。</p>
<p>对于复杂请求，<code>CORS</code>会先发送一个<code>OPTIONS</code>预请求。具体再后面复杂请求时进行。</p>
<p>首先我们区分一下简单请求与复杂请求：</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>简单请求必须满足几个条件：</p>
<ul>
<li><p>使用的方法以下类型：</p>
<ul>
<li><code>GET</code></li>
<li><code>HEAD</code></li>
<li><code>POST</code></li>
</ul>
</li>
<li><p>除了被用户代理自动设置的首部字段（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener"><code>Connection</code></a> ，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent" target="_blank" rel="noopener"><code>User-Agent</code></a>）和在 Fetch 规范中定义为 <a href="https://fetch.spec.whatwg.org/#forbidden-header-name" target="_blank" rel="noopener">禁用首部名称</a> 的其他首部，允许人为设置的字段为 Fetch 规范定义的 <a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header" target="_blank" rel="noopener">对 CORS 安全的首部字段集合</a>。该集合为：</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-language</code></li>
<li><code>Content-Type</code>（下面有额外限制）</li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul>
</li>
<li><p><code>Content-Type</code>的值仅限于以下三种：</p>
<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code>-默认表单提交模式，实际上再body部分还是<code>xxx=xxx&amp;yyy=yyy</code>得形式进行传递。</li>
<li><code>application/x-www-form-urlencoded</code>-当表单需要文件上传的时候的类型。</li>
</ul>
</li>
<li><p>请求中的任意<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload" target="_blank" rel="noopener"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器；<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload" target="_blank" rel="noopener"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload" target="_blank" rel="noopener"><code>XMLHttpRequest.upload</code></a> 属性访问。</p>
</li>
<li><p>请求中没有使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" target="_blank" rel="noopener"><code>ReadableStream</code></a> 对象。</p>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="\images\跨域\simple-req-updated.png" alt="simple-req-updated"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/resources/public-data/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: bar.other</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip,deflate</span><br><span class="line"><span class="attribute">Accept-Charset</span>: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Referer</span>: http://foo.example/examples/access-control/simpleXSInvocation.html</span><br><span class="line"><span class="attribute">Origin</span>: http://foo.example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.61</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: *</span><br><span class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Content-Type</span>: application/xml</span><br><span class="line"></span><br><span class="line">[XML Data]</span><br></pre></td></tr></table></figure>
<p>请求中关键的是：</p>
<p><code>Origin: http://foo.example</code></p>
<p>它表明请求来源是<code>http://foo.example</code></p>
<p>响应中关键的是：</p>
<p><code>Access-Control-Allow-Origin: *</code></p>
<p>其表明该资源允许被任意外域访问。但一般最好是值开放给规定的域，以保证安全：</p>
<p><code>Access-Control-Allow-Origin:http://foo.example</code></p>
<h3 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h3><p>所有非简单请求皆为复杂请求，对于复杂请求，浏览器会首先发起一个<strong>预检请求（OPTIONS）</strong>，以获取服务器是否允许该请求。</p>
<p>下面是一次复杂请求的过程：</p>
<p><img src="\images\跨域\preflight_correct.png" alt="preflight_correct"></p>
<p>第一次预请求头部：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/resources/post-here/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: bar.other</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip,deflate</span><br><span class="line"><span class="attribute">Accept-Charset</span>: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Origin</span>: http://foo.example</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: POST</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: X-PINGOTHER, Content-Type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://foo.example</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: POST, GET, OPTIONS</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-PINGOTHER, Content-Type</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span>: 86400</span><br><span class="line"><span class="attribute">Vary</span>: Accept-Encoding, Origin</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br></pre></td></tr></table></figure>
<p>在请求头部中：最重要的几个字段为：</p>
<ul>
<li><code>Origin: http://foo.example</code>：表示请求的来源为<code>http://foo.example</code>，使服务端进行鉴别是否够允许该请求来源。</li>
<li><code>Access-Control-Request-Method: POST</code>：表示正式请求的方法为<code>POST</code></li>
<li><code>Access-Control-Request-Headers: X-PINGOTHER, Content-Type</code>：表示正式请求将携带两个自定义请求头部字段：<code>X-PINGOTHER</code>，<code>Content-Type</code>，服务器据此决定，该实际请求是否被允许。</li>
</ul>
<p>在响应头部中：最为重要的几个字段为：</p>
<ul>
<li><p><code>Access-Control-Allow-Origin: http://foo.example</code>：表示服务端允许来自<code>http://foo.example</code>的请求。</p>
</li>
<li><p><code>Access-Control-Allow-Methods: POST, GET, OPTIONS</code>：表示服务端允许的方法为<code>POST</code>,<code>GET</code>,<code>OPTIONS</code></p>
</li>
<li><p><code>Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</code>：表示服务端允许携带自定义请求头部字段为：<code>X-PINGOTHER, Content-Type</code></p>
</li>
<li><p><code>Access-Control-Max-Age: 86400</code>：表示响应的有效时间为86400秒，也就是24小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。</p>
<p><strong>请注意：</strong>浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。</p>
</li>
</ul>
<h4 id="附带身份凭证的请求"><a href="#附带身份凭证的请求" class="headerlink" title="附带身份凭证的请求"></a>附带身份凭证的请求</h4><p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a> 或 Fetch的<code>CORS</code>中，可以基于<code>HTTP cookies</code>和<code>HTTP</code>认证信息发送身份凭证。</p>
<p>但在默认情况下，浏览器不会携带身份信息。如果要使浏览器携带信息，需手动设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://bar.other/resources/credentialed-content/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(invocation) &#123;</span><br><span class="line">    invocation.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">    invocation.withCredentials = <span class="literal">true</span>; <span class="comment">//关键</span></span><br><span class="line">    invocation.onreadystatechange = handler;</span><br><span class="line">    invocation.send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：不光<code>client</code>要设置<code>withCredentials</code>。</p>
<p><code>server</code>还需要设置一个头部属性：</p>
<p><code>Access-Control-Allow-Credentials: true</code></p>
<p>如果响应中缺失 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials" target="_blank" rel="noopener"><code>Access-Control-Allow-Credentials</code></a><code>: true</code>（第 17 行），则响应内容不会返回给请求的发起者。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果要使请求携带身份凭证，服务端不得设置<code>Access-Control-Allow-Origin</code>为<code>*</code>。</li>
<li>响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。</li>
</ul>
<p>下面简单列举一下<code>CORS</code>中常用的HTTP头部字段</p>
<p><img src="\images\跨域\HTTP头部字段.png" alt="HTTP头部字段"></p>
<p>总结来说这两种方法，简单请求由于规范了一些属性，所以只需要验证<code>origin</code>。</p>
<p>而复杂请求给了开发者更多可自定义项，则需要服务端进行更多的验证，包括来源，请求方式，请求头字段等。</p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>fetch是一个可以用域访问和操作HTTP管道的API。这个方法是为了替代之前的<code>XMLHttpRequest</code>。该API不需要像<code>XMLHttpRequest</code>进行复杂的配置。且不基于回调方案，而是结合了ES6的<code>Promise</code>来进行数据的处理。就像使用<code>axios</code>一样简单。唯一的问题是该方法不能被<code>pollyfill</code>，且兼容性不是特别好，IE所有版本均不兼容。</p>
<p><img src="\images\跨域\fetch兼容性.png" alt="fetch兼容性"></p>
<p>但是我们必须了解，因为其是未来的网络连接方案。</p>
<p><code>fetch</code>全局方法可以接受两个参数，第一个是url，第二个是配置数据（部分如下），并返回一个<code>Promise</code>。</p>
<ul>
<li><p><code>url</code>: url地址（可以为blob）。</p>
</li>
<li><p><code>options</code>:</p>
<ul>
<li><code>method</code>: 请求使用的方法，如 <code>GET、POST。</code> </li>
<li><code>headers</code>: 请求的头信息，形式为 <code>Headers</code>值的对象字面量。</li>
<li><code>body</code>: 请求的 body 信息：可能是一个 <code>Blob</code>、<code>BufferSource</code>、<code>FormData</code>、<code>URLSearchParams</code>或者 <code>USVString</code>对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。</li>
<li><code>mode</code>: 请求的模式，如 <code>cors</code> <code>no-cors 或者</code> <code>same-origin</code>。</li>
<li><code>credentials</code>: 请求的 credentials，如 <code>omit、same-origin 或者include</code>。为了在当前域名内自动发送 cookie ， 必须提供这个选项。</li>
</ul>
<p>其中的<code>mode</code>参数即可以直接设置是否跨域。如果填写<code>no-cors</code>，则该请求会被限制为仅同源可请求。只要这个字段传入一个任意的字符串或者不填，都是默认<code>cors</code>。</p>
</li>
</ul>
<p>当然，原理还是<code>CORS</code>，所以服务器还是需要设置字段进行相应的配置。</p>
<p>其实<code>fetch</code>有很多可说，具体可以参考我写的另外一篇文章<a href="https://michaelwang.top/2021/02/13/Fetch%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Fetch方法的使用</a></p>
<h2 id="中间件代理"><a href="#中间件代理" class="headerlink" title="中间件代理"></a>中间件代理</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>中间件代理服务器即利用一个中间服务器转发实际服务器的请求，由于中间件服务器与实际服务器之间不需要遵循同源策略，即可以从实际服务器请求数据。实际上代理的主要作用并不是应对跨域。而是如其名，代理后端真实服务器，比如在分布式设计中，一个代理服务器可以代理后端多台真实服务器，做到具体业务和底层逻辑解耦。</p>
<p>实际上这种方式下，代理服务器仍然需要进行跨域配置，但是免去了后端真实服务器的跨域配置。具体流程如下：</p>
<p><img src="\images\跨域\中间件流程.png" alt="中间件流程"></p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>在node中，一般使用<code>express</code>做为<code>server</code>容器，其中的<code>express-http-proxy</code>可以直接用来转发请求，作为一个中间件代理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//middleware.js</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="built_in">require</span>(<span class="string">'express-http-proxy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置跨域</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type,Content-Length,Authorization,Accept,X-Requested-With'</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>,<span class="string">'PUT,POST,GET,DELETE,OPTIONS'</span>);</span><br><span class="line">  res.header(<span class="string">'X-Powered-By'</span>, <span class="string">'3.2.1'</span>)</span><br><span class="line">  <span class="keyword">if</span>(req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">    res.send(<span class="number">200</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置代理服务器，代理/api接口</span></span><br><span class="line">app.use(<span class="string">'/api'</span>, proxy(<span class="string">'http://realServer.com'</span>, &#123;</span><br><span class="line">    <span class="comment">//过滤器</span></span><br><span class="line">    filter: <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.method === <span class="string">'GET'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//请求路径解析</span></span><br><span class="line">    proxyReqPathResolver: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> req.url+<span class="string">'token=123456'</span>		<span class="comment">//请求转发路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">	    <span class="comment">//返回数据处理,如果过程有异步操作应返回Promise（可选）</span></span><br><span class="line">    userResDecorator: <span class="function"><span class="keyword">function</span>(<span class="params">proxyRes, proxyResData, userReq, userRes</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//同步</span></span><br><span class="line">        data = <span class="built_in">JSON</span>.parse(proxyResData.toString(<span class="string">'utf8'</span>));</span><br><span class="line">        data.newProperty = <span class="string">'exciting data'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">        <span class="comment">//异步</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">            proxyResData.funkyMessage = <span class="string">'oi io oo ii'</span>;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                resolve(proxyResData);</span><br><span class="line">            &#125;, <span class="number">200</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>真实服务器不需要配置跨域，仅一个简单的<code>server</code>即可（这里也采用<code>express</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'REAL SERVER MESSAGE!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>业务中，使用代理服务器多用于业务解耦，或者负载均衡，跨域只是其中一个特点。</p>
<h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a><code>nginx</code>反向代理</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>使用<code>nginx</code>反向代理其本质与node中间件代理一样，都是使用一个中间服务器，来转发请求到实际的后端服务器中，但同样，<code>nginx</code>的反向代理多用来做负载均衡或业务解耦，跨域问题的解决只是其中一个特点。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>下面那是一个简单的<code>nginx</code>的配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">// proxy服务器</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.middleware.com;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://www.realServer.com:8080;  <span class="comment">#关键，反向代理</span></span><br><span class="line">        <span class="attribute">proxy_cookie_domain</span> www.realServer.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin http://www.middleware.com;  <span class="comment">#当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="跨页面通信"><a href="#跨页面通信" class="headerlink" title="跨页面通信"></a>跨页面通信</h1><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a><code>postMessage</code></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><strong><code>window.postMessage()</code></strong>方法可以安全地实现跨源通信。此方法可以不考虑两个页面是否同源。只要能拿到对应窗口的引用对象，就可以使用该<code>api</code>进行通信。</p>
<h3 id="窗口引用"><a href="#窗口引用" class="headerlink" title="窗口引用"></a>窗口引用</h3><p>我们可以通过：</p>
<ul>
<li><p>子窗口<code>window.open(URL,name,features,replace)</code></p>
<p>| 参数     | 描述                                                         |<br>| :——- | :———————————————————– |<br>| URL      | 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 |<br>| name     | 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 <a> 和 <form> 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 |<br>| features | 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 |<br>| replace  | 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。 |</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newwin = <span class="built_in">window</span>.open(<span class="string">'http://www.child.com'</span>, <span class="string">'child'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>iframe</code></p>
<p><code>let newWin = document.getElemetnById(&#39;iframe&#39;).contentWindow</code></p>
</li>
</ul>
<p>拿到窗口引用。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>otherWindow.postMessage(message, targetOrigin, [transfer]);</code></p>
<ul>
<li><strong><code>otherWindow</code></strong>：其他窗口的一个引用，比如iframe的contentWindow属性、执行<a href="https://developer.mozilla.org/en-US/docs/DOM/window.open" target="_blank" rel="noopener">window.open</a>返回的窗口对象、或者是命名过或数值索引的<a href="https://developer.mozilla.org/en-US/docs/DOM/window.frames" target="_blank" rel="noopener">window.frames</a>。</li>
<li><strong><code>message</code></strong>：将要发送到其他 window的数据。它将会被<a href="https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">结构化克隆算法</a>序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。[<a href="https://developer.mozilla.org/en-US/docs/" target="_blank" rel="noopener">1</a>]</li>
<li><strong><code>targetOrigin</code></strong>`：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”<em>“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。**如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是\</em>。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。**</li>
<li><strong><code>transfer</code></strong>可选：是一串和message 同时传递的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable" target="_blank" rel="noopener"><code>Transferable</code></a> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parent window</span></span><br><span class="line"><span class="keyword">let</span> newWin = <span class="built_in">window</span>.open(<span class="string">'http://www.child.com'</span>, <span class="string">'child'</span>)</span><br><span class="line">newWin.postMessage(<span class="string">'hello'</span>, <span class="string">'https://www.orgin.com'</span>)</span><br></pre></td></tr></table></figure>
<p>在子窗口中我们可以添加<code>message</code>事件监听。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data) <span class="comment">//hello</span></span><br><span class="line">  <span class="comment">//返回消息</span></span><br><span class="line">  e.source.postMessage(<span class="string">'world'</span>, e.origin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="websocket通信"><a href="#websocket通信" class="headerlink" title="websocket通信"></a><code>websocket</code>通信</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p> <strong><code>Websocket</code>是<code>HTML5</code>的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案</strong>。</p>
<ul>
<li><code>websocket</code>本身支持跨域，不会存在<code>CORS</code>的限制。</li>
<li><code>WebSocket</code>和HTTP都是应用层协议，都基于 TCP 协议。</li>
<li><code>WebSocket</code> 是一种双向通信协议，在建立连接之后，<code>WebSocket</code> 的 server 与 client 都能主动向对方发送或接收数据。</li>
<li><code>WebSocket</code>在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</li>
</ul>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>在前端我们使用<code>Websocket</code>构造器来新建一个<code>Websocket</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> Websocket(<span class="string">'ws://websocketServer.com'</span>)</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//向服务器发送数据</span></span><br><span class="line">    socket.send(<span class="string">'client-connect...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//接受服务器返回的数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.data)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在后端我们采用<code>node.js</code>，其他语言差别不大。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"><span class="keyword">let</span> Websocket = <span class="built_in">require</span>(<span class="string">'ws'</span>)</span><br><span class="line"><span class="keyword">let</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;<span class="attr">port</span>:<span class="number">3000</span>&#125;);</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ws</span>)</span>&#123;</span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)				<span class="comment">//client-connect...</span></span><br><span class="line">        ws.send(<span class="string">'server-connect...'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain + iframe"></a><code>document.domain + iframe</code></h2><p><strong>该方法仅适用于主域相同，子域不同的场景。</strong></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>两个页面都通过js强制设置document.domain为基础主域，就实现了同域。<br> 比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://source.com:3000/b.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">onload</span>=<span class="string">"load()"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.domain = <span class="string">'source.com'</span></span></span><br><span class="line"><span class="actionscript">    	<span class="function"><span class="keyword">function</span> <span class="title">onload</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//读取b.html中的变量</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(frame.contentWindow.a);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   hellob</span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="built_in">document</span>.domain = <span class="string">'source.com'</span></span></span><br><span class="line"><span class="javascript">     <span class="keyword">let</span> a = <span class="number">100</span>;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="两个hack方法"><a href="#两个hack方法" class="headerlink" title="两个hack方法"></a>两个<code>hack</code>方法</h2><p>下面的两个方法是利用一些<code>hack</code>的方法进行通信，往往更加麻烦，所以参考一下即可。</p>
<h3 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name + iframe"></a><code>window.name + iframe</code></h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p><code>window.name</code>属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在（<strong>这一点很重要</strong>），并且可以支持非常长的 name 值（2MB）。</p>
<h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4><p>其中<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000</code>，但<code>b.html</code>为<code>a.html</code>的<code>iframe</code>，则<code>a.html</code>与<code>b.html</code>可以使用<code>window.name</code>进行通信;而c.html是<code>http://localhost:4000</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html(http://localhost:3000/b.html) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">onload</span>=<span class="string">"load()"</span> <span class="attr">id</span>=<span class="string">"iframe"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> first = <span class="literal">true</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      if(first)&#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="actionscript">        iframe.src = <span class="string">'http://localhost:3000/b.html'</span>;</span></span><br><span class="line"><span class="actionscript">        first = <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">      &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(iframe.contentWindow.name);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>b.html</code>为中间代理页，与<code>a.html</code>同域，内容为空。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c.html(http://localhost:4000/c.html) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">'hello'</span>  </span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>本方法利用了<code>window.name</code>属性在切换源后不变的性质，将数据传送到外域。但是比较复杂，需要用第三个页面进行中转，所以一般不用。</p>
<h3 id="location-hash-iframe"><a href="#location-hash-iframe" class="headerlink" title="location.hash + iframe"></a><code>location.hash + iframe</code></h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>与<code>window.name</code>上一种方法相似， a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用<code>iframe</code>的<code>location.hash</code>传值，相同域之间直接JavaScript访问来通信。</p>
<h4 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h4><p>其中<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000</code>，但<code>b.html</code>为<code>a.html</code>的<code>iframe</code>;而<code>c.html</code>是<code>http://localhost:4000</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.localhost:3000/a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.localhost:4000/b.html"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 向b.html传hash值</span></span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        iframe.src = iframe.src + <span class="string">'#user=admin'</span>;</span></span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="comment">// 开放给同域c.html的回调方法</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">onCallback</span><span class="params">(res)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'data from c.html ---&gt; '</span> + res);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.localhost:4000/b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.localhost:3000/c.html"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 监听a.html传来的hash值，再传给c.html</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.localhost:3000/c.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 监听b.html传来的hash值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 再通过操作同域a.html的js回调，将结果传回</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.parent.parent.onCallback(<span class="string">'hello: '</span> + location.hash.replace(<span class="string">'#user='</span>, <span class="string">''</span>));</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面总结了很多方法，</p>
<ul>
<li>但是<code>CORS</code>和<code>jsonp</code>是使用最多的跨域方法，<code>CORS</code>在现代开发中使用最多，但是<code>jsonp</code>兼容性更强，对于低版本的浏览器（比如IE10以下），可以实现跨域。</li>
<li>代理方法的用处不仅限于解决跨域，它有更大的作用，后期再探讨。</li>
<li>后面页面通信中，<code>postMessage</code>使用的更多，其他的<code>hack</code>方法仅在特定的环境下才有较好的效果。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.cn/post/6879365957563727880" target="_blank" rel="noopener">前端跨域系列（3）- 跨域方法总结</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API" target="_blank" rel="noopener">WebSockets</a></li>
<li><a href="https://blog.csdn.net/fjb2080/article/details/80552213" target="_blank" rel="noopener">URL组成详解</a></li>
<li><a href="https://github.com/villadora/express-http-proxy" target="_blank" rel="noopener">express-http-proxy</a></li>
<li><a href="https://github.com/villadora/express-http-proxy" target="_blank" rel="noopener">express-http-proxy</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank" rel="noopener">Cross-Origin Resource Sharing (CORS)</a></li>
</ul>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>bind,call,apply的用法及实现</title>
    <url>/2021/01/27/bind-call-apply%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p><strong><code>bind()</code></strong> 方法<strong>创建一个新的函数</strong>，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><code>thisArg</code></p>
<p>调用绑定函数时作为 <code>this</code> 参数传递给目标函数的值。 </p>
<ol>
<li>如果使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code></a>运算符构造绑定函数，则忽略该值。</li>
<li>当使用 <code>bind</code> 在 <code>setTimeout</code> 中创建一个函数（作为回调提供）时，作为 <code>thisArg</code> 传递的任何原始值都将转换为 <code>object</code>。</li>
<li>如果 <code>bind</code> 函数的参数列表为空，或者<code>thisArg</code>是<code>null</code>或<code>undefined</code>，执行作用域的 <code>this</code> 将被视为新函数的 <code>thisArg</code>。</li>
</ol>
<p><code>arg1, arg2, ...</code></p>
<p>当目标函数被调用时，被预置入绑定函数的参数列表中的参数。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回一个原函数的拷贝，并拥有指定的 <strong><code>this</code></strong> 值和初始参数。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>bind()</strong> 函数会创建一个新的<strong>绑定函数</strong>（<strong>bound function</strong>，BF）。绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语），它包装了原函数对象。调用<strong>绑定函数</strong>通常会导致执行<strong>包装函数</strong>。<br><strong>绑定函数</strong>具有以下内部属性：</p>
<ul>
<li><strong>[[BoundTargetFunction]]</strong> - 包装的函数对象（即新生成的函数）。</li>
<li><strong>[[BoundThis]]</strong> - 在调用包装函数时始终作为 <strong>this</strong> 值传递的值。</li>
<li><strong>[[BoundArguments]]</strong> - 列表，在对包装函数做任何调用都会优先用列表元素填充参数列表。</li>
<li><strong>[[Call]]</strong> - 执行与此对象关联的代码。通过函数调用表达式调用。内部方法的参数是一个<strong>this</strong>值和一个包含通过调用表达式传递给函数的参数的列表。</li>
</ul>
<p>当调用绑定函数<strong>[[BoundTargetFunction]]</strong>时，它调用 <strong>[[BoundTargetFunction]]</strong> 上的内部方法 <strong>[[Call]]</strong>，就像这样 <strong>Call(*boundThis*, *args*)</strong>。其中，<strong>boundThis</strong> 是 <strong>[[BoundThis]]</strong>，<strong>args</strong> 是 <strong>[[BoundArguments]]</strong> 加上通过函数调用传入的参数列表。</p>
<p>绑定函数也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code></a> 运算符构造，它会表现为目标函数已经被构建完毕了似的。提供的 <code>this</code> 值会被忽略，但前置参数仍会提供给模拟函数。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h4 id="改变this指向（创建绑定this指向的函数）"><a href="#改变this指向（创建绑定this指向的函数）" class="headerlink" title="改变this指向（创建绑定this指向的函数）"></a>改变this指向（创建绑定this指向的函数）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'outterA'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'innerA'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printA()	<span class="comment">//'outterA'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> innerPrintA = printA.bind(obj)</span><br><span class="line">innerPrintA()		<span class="comment">//innerA</span></span><br></pre></td></tr></table></figure>
<h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><p>通俗的讲，偏函数就是指通过一个初始函数<code>A</code>，创建出另外的函数<code>A1</code>,<code>A2</code>，这两个函数含有了初始参数1，2。这里使用<code>bind</code>是利用了他的两个特点。</p>
<ol>
<li><code>bind</code>返回的是绑定函数，区别与<code>Function.prototype.call()</code>，<code>Function.prototype.apply()</code>的立即执行</li>
<li>其接受的是参数列表，并且会与绑定函数调用时的参数合并作用<code>[[call]]</code>原函数，区别于<code>Function.prototype.apply()</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addThirtynine = add.bind(<span class="literal">null</span>, <span class="number">39</span>)</span><br><span class="line"><span class="keyword">let</span> addEleven = add.bind(<span class="literal">null</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">addThirtynine(<span class="number">3</span>)	<span class="comment">//42</span></span><br><span class="line">addEleven(<span class="number">3</span>)		<span class="comment">//14</span></span><br></pre></td></tr></table></figure>
<h4 id="改变setTimeout，setInterval的this指向"><a href="#改变setTimeout，setInterval的this指向" class="headerlink" title="改变setTimeout，setInterval的this指向"></a>改变setTimeout，setInterval的this指向</h4><p>由于<code>setTimeout</code>，<code>setInterval</code>的函调函数中<code>this</code>的指向总是<code>window</code>（即使在严格模式下）。所以可以使用<code>bind</code>改变回调函数中的<code>this</code>指向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    message: <span class="string">'内部消息'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message = <span class="string">'外部消息'</span>		<span class="comment">//这种方法是吧message变量挂载在window上</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.message)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">//一秒后打印出：'外部消息'</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.message)</span><br><span class="line">&#125;.bind(obj), <span class="number">1000</span>)							<span class="comment">//将this的指向改变为obj</span></span><br><span class="line"><span class="comment">//一秒后打印出：'内部消息'</span></span><br></pre></td></tr></table></figure>
<h3 id="作为构造函数使用的绑定函数"><a href="#作为构造函数使用的绑定函数" class="headerlink" title="作为构造函数使用的绑定函数"></a>作为构造函数使用的绑定函数</h3><p>与偏函数用法类似，相当于为构造器提供默认参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p.toString() 				<span class="comment">//'1,2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emptyObj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> YAxisPoint = Point.bind(<span class="literal">null</span>, <span class="number">0</span><span class="comment">/*x*/</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> axisPoint5 = <span class="keyword">new</span> YAxisPoint(<span class="number">5</span>)</span><br><span class="line">axisPoint5.toString()				<span class="comment">//'0,5'</span></span><br><span class="line"></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> Point; <span class="comment">// true</span></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> YAxisPoint; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> YAxisPoint(<span class="number">17</span>, <span class="number">42</span>) <span class="keyword">instanceof</span> Point; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="快捷调用"><a href="#快捷调用" class="headerlink" title="快捷调用"></a>快捷调用</h4><p>一些特定的函数被绑定在特定数据类型种，最典型的例子就是<code>Array.prototype.slice</code>，其只能由数组调用。实际上这个函数也接受类数组的对象(array-like object)，这个时候实际上是要改变this的调用。</p>
<p>一般的用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> slice = <span class="built_in">Array</span>.prototype.slice</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> slice.apply(<span class="built_in">arguments</span>)				<span class="comment">//arguments是一个类数组对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convert(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)								<span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>在使用<code>bind</code>后，由于其可以生成绑定函数，所以将要使用的函数作为<code>this</code>就可以不用每次都使用<code>apply</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unboundSlice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">let</span> slice = <span class="built_in">Function</span>.prototype.apply.bind(unboundSlice);		<span class="comment">//这个slice就是上面的slice.apply()的一个绑定函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> slice(<span class="built_in">arguments</span>)				<span class="comment">//arguments是一个类数组对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convert(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)								<span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="\images\bind-call-apply\bind.png" alt="bind"></p>
<h2 id="Pollyfill"><a href="#Pollyfill" class="headerlink" title="Pollyfill"></a>Pollyfill</h2><p>法一：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Does not work with `new (funcA.bind(thisArg, args))`</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> thatFunc = <span class="keyword">this</span>, thatArg = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> thatFunc !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - '</span> +</span><br><span class="line">             <span class="string">'what is trying to be bound is not callable'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> funcArgs = args.concat(slice.call(<span class="built_in">arguments</span>))			<span class="comment">//合并参数</span></span><br><span class="line">      <span class="keyword">return</span> thatFunc.apply(thatArg, funcArgs);					<span class="comment">//绑定this指向</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这里利用了<code>Function.prototype.apply</code>构造一个函数，运行及执行<code>apply</code>方法，达到<code>bind</code>的特点。</p>
<p>法二：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Yes, it does work with `new (funcA.bind(thisArg, args))`</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ArrayPrototypeSlice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">otherThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> baseArgs= ArrayPrototypeSlice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        baseArgsLength = baseArgs.length,</span><br><span class="line">        fToBind = <span class="keyword">this</span>,</span><br><span class="line">        fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          baseArgs.length = baseArgsLength; <span class="comment">// reset to default base arguments</span></span><br><span class="line">          baseArgs.push.apply(baseArgs, <span class="built_in">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(</span><br><span class="line">                 fNOP.prototype.isPrototypeOf(<span class="keyword">this</span>) ? <span class="keyword">this</span> : otherThis, baseArgs</span><br><span class="line">          );</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      <span class="comment">// Function.prototype doesn't have a prototype property</span></span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p><strong><code>call()</code></strong> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<p><strong>注意：</strong>该方法的语法和作用与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener"><code>apply()</code></a> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p>
<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><p><code>thisArg</code></p>
<p>可选的。在 <em><code>function</code></em> 函数运行时使用的 <code>this</code> 值。请注意，<code>this</code>可能不是该方法看到的实际值：如果这个函数处于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">非严格模式</a>下，则指定为 <code>null</code> 或 <code>undefined</code> 时会自动替换为指向全局对象，原始值会被包装。</p>
<p><code>arg1, arg2, ...</code></p>
<p>指定的参数列表。（与<code>bind</code>一样）</p>
<h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p><code>call</code>方法相较于<code>bind</code>，他会生成一个绑定函数并立即调用。</p>
<h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><h3 id="基本方法：改变this指向"><a href="#基本方法：改变this指向" class="headerlink" title="基本方法：改变this指向"></a>基本方法：改变<code>this</code>指向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    message: <span class="string">'inner-message'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message = <span class="string">'outter-message'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log()					<span class="comment">//'outter-message'</span></span><br><span class="line">log.call(obj)			<span class="comment">//'inner-message'</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-call-方法调用父构造函数"><a href="#使用-call-方法调用父构造函数" class="headerlink" title="使用 call 方法调用父构造函数"></a>使用 <code>call</code> 方法调用父构造函数</h3><p>使用<code>call</code>方法绑定<code>this</code>对象为自己子类中，则可以完成对父构造器的调用。达到简单的继承效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>)</span>&#123;</span><br><span class="line">    Product.call(<span class="keyword">this</span>, name, price)				<span class="comment">//调用父构造器，并将this绑定为Food的示例</span></span><br><span class="line">    <span class="keyword">this</span>.category = <span class="string">'food'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toy</span>(<span class="params">name, price</span>)</span>&#123;</span><br><span class="line">    Product.call(<span class="keyword">this</span>, name, price)				<span class="comment">//调用父构造器，并将this绑定为Toy的示例</span></span><br><span class="line">    <span class="keyword">this</span>.category = <span class="string">'toy'</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cheese = <span class="keyword">new</span> Food(<span class="string">'feta'</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> fun = <span class="keyword">new</span> Toy(<span class="string">'robot'</span>, <span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<h3 id="为匿名函数指定this对象"><a href="#为匿名函数指定this对象" class="headerlink" title="为匿名函数指定this对象"></a>为匿名函数指定<code>this</code>对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    message: <span class="string">'obj-message'</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.message)</span><br><span class="line">&#125;).call(obj)</span><br><span class="line"><span class="comment">//'obj-message'</span></span><br></pre></td></tr></table></figure>
<h2 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="\images\bind-call-apply\call.png" alt="call"></p>
<h2 id="Pollyfill-1"><a href="#Pollyfill-1" class="headerlink" title="Pollyfill"></a>Pollyfill</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.call) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">        <span class="string">'Function.prototype.call - what is trying to be bound is not callable'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> func = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> args = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">    that.func = func</span><br><span class="line">    that.func(...args)</span><br><span class="line">    <span class="keyword">delete</span> that.func</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects" target="_blank" rel="noopener">类数组对象</a>）的形式提供的参数。</p>
<h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><ul>
<li><p><code>thisArg</code></p>
<p>必选的。在 <em><code>func</code></em> 函数运行时使用的 <code>this</code> 值。请注意，<code>this</code>可能不是该方法看到的实际值：如果这个函数处于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">非严格模式</a>下，则指定为 <code>null</code> 或 <code>undefined</code> 时会自动替换为指向全局对象，原始值会被包装。</p>
</li>
<li><p><code>argsArray</code></p>
<p>可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 <code>func</code> 函数。如果该参数的值为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener"><code>null</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</p>
</li>
</ul>
<h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>调用有指定<strong><code>this</code></strong>值和参数的函数的结果。</p>
<h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><ol>
<li><p><code>apply</code> 与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener"><code>call()</code></a> 非常相似，不同之处在于提供参数的方式。<code>apply</code> 使用参数数组而不是一组参数列表。<code>apply</code> 可以使用数组字面量（array literal），如 <code>fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])</code>，或数组对象， 如 <code>fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))</code>。</p>
</li>
<li><p>你也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener"><code>arguments</code></a>对象作为 <code>argsArray</code> 参数。 <code>arguments</code> 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。</p>
</li>
<li><p>从 ECMAScript 第5版开始，可以使用任何种类的类数组对象，就是说只要有一个 <code>length</code> 属性和<code>(0..length-1)</code>范围的整数属性。例如现在可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList" target="_blank" rel="noopener"><code>NodeList</code></a> 或一个自己定义的类似 <code>{&#39;length&#39;: 2, &#39;0&#39;: &#39;eat&#39;, &#39;1&#39;: &#39;bananas&#39;}</code> 形式的对象。</p>
<p><strong>需要注意</strong>：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。</p>
</li>
</ol>
<h2 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h2><h3 id="基本方法：改变this指向-1"><a href="#基本方法：改变this指向-1" class="headerlink" title="基本方法：改变this指向"></a>基本方法：改变<code>this</code>指向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    message: <span class="string">'inner-message'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message = <span class="string">'outter-message'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log()					<span class="comment">//'outter-message'</span></span><br><span class="line">log.apply(obj)			<span class="comment">//'inner-message'</span></span><br></pre></td></tr></table></figure>
<h3 id="函数数组参数变为列表参数-使用内置函数"><a href="#函数数组参数变为列表参数-使用内置函数" class="headerlink" title="函数数组参数变为列表参数+使用内置函数"></a>函数数组参数变为列表参数+使用内置函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<p>在ES6中扩展运算符（spread）<code>···</code>来实现函数数组参数变为列表参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...arr)</span><br><span class="line"><span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<h3 id="兼容性-2"><a href="#兼容性-2" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="\images\bind-call-apply\apply.png" alt="apply"></p>
<h3 id="Pollyfill-2"><a href="#Pollyfill-2" class="headerlink" title="Pollyfill"></a>Pollyfill</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.apply) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">        <span class="comment">// internal IsCallable function</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">          <span class="string">'Function.prototype.apply - what is trying to be bound is not callable'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> func = <span class="keyword">this</span></span><br><span class="line">      <span class="keyword">let</span> that = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">let</span> args = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">      &#125;</span><br><span class="line">      that.func = func</span><br><span class="line">      that.func(args)</span><br><span class="line">      <span class="keyword">delete</span> that.func</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>bind</tag>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客啊</title>
    <url>/2018/07/20/blog/</url>
    <content><![CDATA[<h1 id="这是我的第一篇博客啊！"><a href="#这是我的第一篇博客啊！" class="headerlink" title="这是我的第一篇博客啊！"></a>这是我的第一篇博客啊！</h1><p>折腾了3天了，不过算起来也只是几个小时，还没弄好，心态有点爆炸啊，js也几天没有学了。<br><a href="www.baidu.com">这是百度的链接</a><br>emmmm,暂时就这样！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;fuck you&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Photoshop批量处理工具</title>
    <url>/2022/05/24/Photoshop%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Photoshop批量处理步骤"><a href="#Photoshop批量处理步骤" class="headerlink" title="Photoshop批量处理步骤"></a>Photoshop批量处理步骤</h1><ol>
<li><p>选择动作</p>
<p><img src="/images/Photoshop批量处理工具/1. 选择动作.png" alt="1. 选择动作"></p>
</li>
<li><p>新建动作</p>
<p><img src="/images/Photoshop批量处理工具/2. 新建动作.png" alt="2. 新建动作"></p>
</li>
<li><p>停止录制</p>
<p><img src="/images/Photoshop批量处理工具/3. 停止录制.png" alt="3. 停止录制"></p>
</li>
<li><p>选择批处理菜单</p>
<p><img src="/images/Photoshop批量处理工具/4. 选择批处理菜单.png" alt="4. 选择批处理菜单"></p>
</li>
<li><p>选择目标开始执行</p>
<p><img src="/images/Photoshop批量处理工具/5. 选择目标开始执行.png" alt="5. 选择目标开始执行"></p>
</li>
</ol>
<p>在对同类图片做一样处理时，十分好用~</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>在ESC服务器上搭建静态网站</title>
    <url>/2018/07/22/ecsAndWebsite/</url>
    <content><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>前面在连接上服务器后，紧接着我想测试一下服务器的网站搭建，下面就把简单的教程贴出来。</p>
<p>1.首先要要在服务器管理页面对服务器进行配置（我最开始就是忘了配置服务器的端口，结果怎么都不对!!!）由于我们<br>HTTP的对应端口是80，所以我们在安全组规则中添加对80端口的开放。</p>
<p><a href="https://imgchr.com/i/Ptydk4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/07/25/Ptydk4.md.png" alt="Ptydk4.md.png"></a><br><a id="more"></a><br>添加好之后:</p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtsJde.png" alt="PtsJde.png"></p>
<p>2.我的windows服务器中是没有自带IIS的，所以先从IIS的安装开始，点击左下角的服务器管理图标进入服务器管理页面。<br><img src="https://s1.ax1x.com/2018/07/25/PtsNid.png" alt="PtsNid.png"></p>
<p>3.在服务器管理中点击角色并点击右面的添加角色。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtyV6P.png" alt="PtyV6P.png"><br>4.进入添加角色向导。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtsMxx.png" alt="PtsMxx.png"></p>
<p>5.钩选Web服务器(IIS),点击安装。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtseIJ.png" alt="PtseIJ.png"></p>
<p>6.点击安装后会弹出是否添加，点击“添加必需的功能”。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtsZa4.png" alt="PtsZa4.png"></p>
<p>7.然后会弹出角色服务，由于我们搭建的静态网页，所以勾选常见的HTTTP功能，如果需要构建动态网站，可够相爱U呢引用程序开发下的相应功能。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtsuGR.png" alt="PtsuGR.png"></p>
<p>8.然后等待角色安装完成。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtsKR1.png" alt="PtsKR1.png"><br>9.然后就可以输入服务器的<span style="color:red;font-size:20px">公网</span>IP查看是否成功安装IIS服务。<br>看到上面这张图就代表安装成功了。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtslM6.png" alt="PtslM6.png"></p>
<p>10.添加应用池。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/Pts1sK.png" alt="Pts1sK.png"></p>
<p>11.添加站点，注意，IP地址要选择<span style="color:red;font-size:20px">全部未分配</span></p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtsYIH.png" alt="PtsYIH.png"><br>*12.最后是默认文档的修改，服务器中默认的主页是default.htm,你可以把它改成你的主页名。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/PtsYIH.png" alt="PtsYIH.png"><br><img src="https://s1.ax1x.com/2018/07/25/PtsGZD.png" alt="PtsGZD.png"></p>
<p>13.在浏览器输入你的ip地址。查看你的网页。</p>
<p><img src="https://s1.ax1x.com/2018/07/25/Ptsdzt.jpg" alt="Ptsdzt.jpg"></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>至此，一个静态网站就搭建好了。其中容易发生错误的点主要有：</p>
<ol>
<li>安全规则没有配置或者没有配置正确。</li>
<li>创建新站点的IP地址要选择全部未分配。</li>
</ol>
<p>借鉴资料：</p>
<p>部分图片取自csdn博主bestself_iot的文章<a href="https://blog.csdn.net/bestself_iot/article/details/78724286" target="_blank" rel="noopener">IIS 静态页面网站搭建</a></p>
<!--
![PtsNid.png](https://s1.ax1x.com/2018/07/25/PtsNid.png)
![Ptsni9.png](https://s1.ax1x.com/2018/07/25/Ptsni9.png)
![PtsMxx.png](https://s1.ax1x.com/2018/07/25/PtsMxx.png)
![PtseIJ.png](https://s1.ax1x.com/2018/07/25/PtseIJ.png)
![PtsZa4.png](https://s1.ax1x.com/2018/07/25/PtsZa4.png)
![PtsuGR.png](https://s1.ax1x.com/2018/07/25/PtsuGR.png)
![PtsKR1.png](https://s1.ax1x.com/2018/07/25/PtsKR1.png)
![PtslM6.png](https://s1.ax1x.com/2018/07/25/PtslM6.png)
![Pts3qO.png](https://s1.ax1x.com/2018/07/25/Pts3qO.png)
![Pts1sK.png](https://s1.ax1x.com/2018/07/25/Pts1sK.png)
![PtsYIH.png](https://s1.ax1x.com/2018/07/25/PtsYIH.png)
![PtsGZD.png](https://s1.ax1x.com/2018/07/25/PtsGZD.png)
![PtsJde.png](https://s1.ax1x.com/2018/07/25/PtsJde.png)
![PtsaRI.png](https://s1.ax1x.com/2018/07/25/PtsaRI.png)
![PtsUJA.png](https://s1.ax1x.com/2018/07/25/PtsUJA.png)
![Ptsdzt.jpg](https://s1.ax1x.com/2018/07/25/Ptsdzt.jpg)
-->]]></content>
      <categories>
        <category>website</category>
      </categories>
      <tags>
        <tag>esc</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title>float最全最根本解析</title>
    <url>/2021/10/16/float%E6%9C%80%E5%85%A8%E6%9C%80%E6%A0%B9%E6%9C%AC%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>要想真正得用好浮动，以及清除浮动。必须首先要理解几个概念作为前置知识。</p>
<h2 id="Normal-flow-（正常流）"><a href="#Normal-flow-（正常流）" class="headerlink" title="Normal flow （正常流）"></a>Normal flow （正常流）</h2><p>这个名词在国内一般被翻译为文档流，这个被很多人吐槽，就不再说了。</p>
<p>这个正常流就是我们HTML初始的流模型。也就是整个文档内，如果你不添加其他属性（浮动和绝对定位）那么整个文档就属于正常流。</p>
<h2 id="格式化上下文（formatting-context）"><a href="#格式化上下文（formatting-context）" class="headerlink" title="格式化上下文（formatting context）"></a>格式化上下文（formatting context）</h2><p>一个格式化上下文（下文称FC）就是一系列相关的元素排布的环境。不同的FC有不同的排布规则。</p>
<p>正常流中的一个盒子模型，都必然<strong>属于</strong>一个格式化上下文（formatting context）（并不是每个元素都会建立一个FC，注意属于二字）。而格式化上下文又分为以下5种：</p>
<ul>
<li>BFC(block formatting context)</li>
<li>IFC(inline formatting context)</li>
<li>RFC(ruby formatting context) - 未被实现</li>
<li>FFC(flex formatting context)</li>
<li>GFC(grid formatting context)</li>
</ul>
<p>值得注意的是：</p>
<ol>
<li><p>但是一些FC之间可以产生互动或共存，比如一个IFC可能位于一个BFC元素的内部。</p>
</li>
<li><p>FC建立的类型取决于<code>inner-display</code>。</p>
<p>这里又需要介绍一下<code>inner-display</code>的概念。</p>
<h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><p>实际上我们常使用的<code>display</code>属性，包括两个概念，<code>inner display type</code>和<code>outer display type</code></p>
<h5 id="inner-display-type"><a href="#inner-display-type" class="headerlink" title="inner display type"></a><code>inner display type</code></h5><p>内部展示类型即会决定这个元素产生的FC的类型，由此会决定其后代元素如何进行排布。</p>
<h5 id="outer-display-type"><a href="#outer-display-type" class="headerlink" title="outer display type"></a><code>outer display type</code></h5><p>外部展示类型决定了他自己如何在流布局中进行排布。</p>
<p>注意：文字没有display 属性。</p>
</li>
</ol>
<p>下面是W3C规定的所有display属性，但是一些并没有实现：</p>
<table class="data" id="display-value-summary"><br>    <thead><br>     <tr><br>      <th>Short <a class="property" data-link-type="propdesc" href="#propdef-display" id="ref-for-propdef-display①⑥">display</a><br>      </th><th>Full <a class="property" data-link-type="propdesc" href="#propdef-display" id="ref-for-propdef-display①⑦">display</a><br>      </th><th>Generated box<br>    </th></tr></thead><tbody title="Box Suppression Display Types"><br>     <tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-none" id="ref-for-valdef-display-none③">none</a><br>      </td><td>—<br>      </td><td>subtree omitted from <a data-link-type="dfn" href="#box-tree" id="ref-for-box-tree⑦">box tree</a><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-contents" id="ref-for-valdef-display-contents①">contents</a><br>      </td><td>—<br>      </td><td>element replaced by contents in <a data-link-type="dfn" href="#box-tree" id="ref-for-box-tree⑧">box tree</a><br>    </td></tr></tbody><tbody title="Flow Layout Display Types"><br>     <tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-block" id="ref-for-valdef-display-block">block</a><br>      </td><td><span class="css">block flow</span><br>      </td><td><a data-link-type="dfn" href="#block-level" id="ref-for-block-level">block-level</a> <a data-link-type="dfn" href="#block-container" id="ref-for-block-container">block container</a> <abbr title="also known as">aka</abbr> <a data-link-type="dfn" href="#block-box" id="ref-for-block-box①">block box</a><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-flow-root" id="ref-for-valdef-display-flow-root">flow-root</a><br>      </td><td><span class="css">block flow-root</span><br>      </td><td><a data-link-type="dfn" href="#block-level" id="ref-for-block-level①">block-level</a> <a data-link-type="dfn" href="#block-container" id="ref-for-block-container①">block container</a> that establishes a new <a data-link-type="dfn" href="#block-formatting-context" id="ref-for-block-formatting-context">block formatting context</a> (<a data-link-type="dfn" href="#bfc" id="ref-for-bfc">BFC</a>)<br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-inline" id="ref-for-valdef-display-inline">inline</a><br>      </td><td><span class="css">inline flow</span><br>      </td><td><a data-link-type="dfn" href="#inline-box" id="ref-for-inline-box①">inline box</a><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-inline-block" id="ref-for-valdef-display-inline-block">inline-block</a><br>      </td><td><span class="css">inline flow-root</span><br>      </td><td><a data-link-type="dfn" href="#inline-level" id="ref-for-inline-level">inline-level</a> <a data-link-type="dfn" href="#block-container" id="ref-for-block-container②">block container</a> <abbr title="also known as">aka</abbr> <dfn class="dfn-paneled" data-dfn-type="dfn" data-export="" data-lt="inline block | inline block box" id="inline-block">inline block</dfn><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-run-in" id="ref-for-valdef-display-run-in①">run-in</a><br>      </td><td><span class="css">run-in flow</span><br>      </td><td><a data-link-type="dfn" href="#run-in" id="ref-for-run-in">run-in box</a> (<a data-link-type="dfn" href="#inline-box" id="ref-for-inline-box②">inline box</a> with special box-tree-munging rules)<br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-list-item" id="ref-for-valdef-display-list-item②">list-item</a><br>      </td><td><span class="css">block flow list-item</span><br>      </td><td><a data-link-type="dfn" href="#block-box" id="ref-for-block-box②">block box</a> with additional <a href="https://www.w3.org/TR/CSS2/generate.html#lists" target="_blank" rel="noopener">marker box</a><br>     </td></tr><tr><br>      <td><span class="css">inline list-item</span><br>      </td><td><span class="css">inline flow list-item</span><br>      </td><td><a data-link-type="dfn" href="#inline-box" id="ref-for-inline-box③">inline box</a> with additional <a href="https://www.w3.org/TR/CSS2/generate.html#lists" target="_blank" rel="noopener">marker box</a><br>    </td></tr></tbody><tbody title="Formatting Context Root Display Types"><br>     <tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-flex" id="ref-for-valdef-display-flex">flex</a><br>      </td><td><span class="css">block flex</span><br>      </td><td><a data-link-type="dfn" href="#block-level" id="ref-for-block-level②">block-level</a> <a data-link-type="dfn" href="https://www.w3.org/TR/css-flexbox-1/#flex-container" target="_blank" rel="noopener" id="ref-for-flex-container">flex container</a><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-inline-flex" id="ref-for-valdef-display-inline-flex">inline-flex</a><br>      </td><td><span class="css">inline flex</span><br>      </td><td><a data-link-type="dfn" href="#inline-level" id="ref-for-inline-level①">inline-level</a> <a data-link-type="dfn" href="https://www.w3.org/TR/css-flexbox-1/#flex-container" target="_blank" rel="noopener" id="ref-for-flex-container①">flex container</a><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-grid" id="ref-for-valdef-display-grid">grid</a><br>      </td><td><span class="css">block grid</span><br>      </td><td><a data-link-type="dfn" href="#block-level" id="ref-for-block-level③">block-level</a> <a data-link-type="dfn" href="https://www.w3.org/TR/css-grid-2/#grid-container" target="_blank" rel="noopener" id="ref-for-grid-container">grid container</a><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-inline-grid" id="ref-for-valdef-display-inline-grid">inline-grid</a><br>      </td><td><span class="css">inline grid</span><br>      </td><td><a data-link-type="dfn" href="#inline-level" id="ref-for-inline-level②">inline-level</a> <a data-link-type="dfn" href="https://www.w3.org/TR/css-grid-2/#grid-container" target="_blank" rel="noopener" id="ref-for-grid-container①">grid container</a><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-ruby" id="ref-for-valdef-display-ruby">ruby</a><br>      </td><td><span class="css">inline ruby</span><br>      </td><td><a data-link-type="dfn" href="#inline-level" id="ref-for-inline-level③">inline-level</a> <a data-link-type="dfn" href="https://www.w3.org/TR/css-ruby-1/#ruby-container" target="_blank" rel="noopener" id="ref-for-ruby-container">ruby container</a><br>     </td></tr><tr><br>      <td><span class="css">block ruby</span><br>      </td><td><span class="css">block ruby</span><br>      </td><td><a data-link-type="dfn" href="#block-box" id="ref-for-block-box③">block box</a> containing <a data-link-type="dfn" href="https://www.w3.org/TR/css-ruby-1/#ruby-container" target="_blank" rel="noopener" id="ref-for-ruby-container①">ruby container</a><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-table" id="ref-for-valdef-display-table">table</a><br>      </td><td><span class="css">block table</span><br>      </td><td><a data-link-type="dfn" href="#block-level" id="ref-for-block-level④">block-level</a> <a data-link-type="dfn" href="https://www.w3.org/TR/css-tables-3/#table-wrapper-box" target="_blank" rel="noopener" id="ref-for-table-wrapper-box①">table wrapper box</a> containing <a data-link-type="dfn" href="https://www.w3.org/TR/css-tables-3/#table-grid-box" target="_blank" rel="noopener" id="ref-for-table-grid-box①">table grid box</a><br>     </td></tr><tr><br>      <td><a class="css" data-link-type="maybe" href="#valdef-display-inline-table" id="ref-for-valdef-display-inline-table">inline-table</a><br>      </td><td><span class="css">inline table</span><br>      </td><td><a data-link-type="dfn" href="#inline-level" id="ref-for-inline-level④">inline-level</a> <a data-link-type="dfn" href="https://www.w3.org/TR/css-tables-3/#table-wrapper-box" target="_blank" rel="noopener" id="ref-for-table-wrapper-box②">table wrapper box</a> containing <a data-link-type="dfn" href="https://www.w3.org/TR/css-tables-3/#table-grid-box" target="_blank" rel="noopener" id="ref-for-table-grid-box②">table grid box</a><br>    </td></tr></tbody><tbody title="Layout-internal display types"><br>     <tr><br>      <td><a class="production css" data-link-type="type" href="#typedef-display-internal" id="ref-for-typedef-display-internal②" title="Expands to: ruby-base | ruby-base-container | ruby-text | ruby-text-container | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group">&lt;display-internal&gt;</a> types<br>      </td><td>—<br>      </td><td><a href="#layout-specific-display">layout-specific internal box</a><br>   </td></tr></tbody></table>

<p>并且其分类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;display-outside&gt;  = block | inline | run-in</span><br><span class="line">&lt;display-inside&gt;   = flow | flow-root | table | flex | grid | ruby</span><br><span class="line">&lt;display-listitem&gt; = &lt;display-outside&gt;? &amp;&amp; [ flow | flow-root ]? &amp;&amp; list-item</span><br><span class="line">&lt;display-internal&gt; = table-row-group | table-header-group |</span><br><span class="line">                     table-footer-group | table-row | table-cell |</span><br><span class="line">                     table-column-group | table-column | table-caption |</span><br><span class="line">                     ruby-base | ruby-text | ruby-base-container |</span><br><span class="line">                     ruby-text-container</span><br><span class="line">&lt;display-box&gt;      = contents | none</span><br><span class="line">&lt;display-legacy&gt;   = inline-block | inline-table | inline-flex | inline-grid</span><br></pre></td></tr></table></figure>
<p>根据<code>inner display type</code>再回影响FC的产生原则，\&lt;display-outside>与 \&lt;display-box>  肯定不能影响规则。则剩下的几种，其内部的实现又各不相同。</p>
<p>首先\&lt;display-inside>必定可以产生FC。</p>
<p>而其他的几种，比如 <code>table-row</code>等由于内部的实现不同，不一定能够产生FC。</p>
<p>根据文档，可以归纳为：</p>
<ul>
<li>产生BFC<ol>
<li>flow-chrome未实现</li>
<li>flow-root</li>
<li>table</li>
<li>table-caption</li>
<li>table-row-group</li>
<li>table-header-group</li>
<li>table-footer-group</li>
<li>table-row</li>
<li>table-cell</li>
</ol>
</li>
<li>产生RFC<ol>
<li>ruby</li>
</ol>
</li>
<li>产生FFC<ol>
<li>flex</li>
</ol>
</li>
<li>产生GFC<ol>
<li>grid</li>
</ol>
</li>
<li>产生RFC<ol>
<li>ruby（原ruby标签是用来注释的）</li>
</ol>
</li>
</ul>
<h3 id="BFC-block-formatting-context"><a href="#BFC-block-formatting-context" class="headerlink" title="BFC(block formatting context)"></a>BFC(block formatting context)</h3>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>float</tag>
        <tag>浮动</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局与grid布局简介</title>
    <url>/2021/01/24/flex%E5%B8%83%E5%B1%80%E4%B8%8Egrid%E5%B8%83%E5%B1%80%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><p><code>flex</code>布局可以更加简洁的实现之前使用浮动和绝对布局实现的一些布局。特别是item的展示界面等。</p>
<p>首先应该明确一个概念，这个概念在<code>grid</code>布局中也存在，就是<code>container</code>与<code>item</code>，即被布局的元素被称为<code>item</code>，包围这些<code>item</code>的元素即为<code>container</code>。在<code>flex</code>布局中，<code>item</code>的大小要自己设置。</p>
<p><code>flex</code>布局相对于<code>grid</code>布局，简单许多，它是按照轴线的方式进行布局，按照<code>item</code>其规定一个主轴线<code>main axis</code>（默认为水平），然后对应的即为交叉轴<code>cross axis</code>（默认为垂直）。</p>
<p>所以其属性也分为容器属性和元素属性。</p>
<h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><p><strong>首先</strong>要使用<code>flex</code>布局，就要将容器的<code>display</code>属性设为<code>flex</code>。</p>
<p>注意：一旦将容器的<code>display</code>属性设为<code>flex</code>，则其<code>item</code>的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
<h3 id="1-flex-direction属性"><a href="#1-flex-direction属性" class="headerlink" title="1. flex-direction属性"></a>1. flex-direction属性</h3><p><code>flex-direction</code>属性规定了主轴的方向。由于主轴可能有水平、垂直方向，又每个轴又可以从左到右，从上到下或相反。</p>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
<h3 id="2-flex-wrap属性"><a href="#2-flex-wrap属性" class="headerlink" title="2. flex-wrap属性"></a>2. flex-wrap属性</h3><p><code>flex-wrap</code>属性规定了主轴是否进行换行。默认是不进行换行，又由于<code>flex</code>布局中，<code>item</code>的大小是自己规定的，所以在一行中，若<code>item</code>的总宽度大于父容器的宽度，则会对元素的宽度进行压缩。其有3个属性：</p>
<ul>
<li><code>nowrap</code>（默认）：不换行。</li>
<li><code>wrap</code>：换行，第一行在上方。</li>
<li><code>wrap-reverse</code>：换行，从最后一行的左边开始换行，向上换行。</li>
</ul>
<h3 id="3-flex-flow属性"><a href="#3-flex-flow属性" class="headerlink" title="3. flex-flow属性"></a>3. flex-flow属性</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>
<h3 id="4-justify-content属性"><a href="#4-justify-content属性" class="headerlink" title="4. justify-content属性"></a>4. justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。其有5个值。</p>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等，两侧无间隔。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。</li>
<li><code>space-evently</code>：每个项目两侧的间隔相等。间隔等于两侧的间隔。</li>
</ul>
<h3 id="5-align-items属性"><a href="#5-align-items属性" class="headerlink" title="5. align-items属性"></a>5. align-items属性</h3><p><code>align-items</code>属性将所有直接子节点上的align-self值设置为一个组。 align-self属性设置项目在其包含块中在交叉轴方向上的对齐方式。其有5个属性（需要注意的是这里是对每个交叉轴而言，即规定每个交叉轴上元素的对其方式，每个交叉轴上的行宽不会变，这里区别于<code>align-content</code>属性）：</p>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<p><img src="D:\myblog\myblog\source\images\flex-grid\flex-align-items.png" alt=""></p>
<h3 id="6-align-content属性"><a href="#6-align-content属性" class="headerlink" title="6. align-content属性"></a>6. align-content属性</h3><p><code>align-content</code>属性设置了浏览器如何沿着<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout" target="_blank" rel="noopener">弹性盒子布局</a>的纵轴和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout" target="_blank" rel="noopener">网格布局</a>的主轴在内容项之间和周围分配空间。如果项目只有一根轴线，该属性不起作用。（即每个交叉轴的宽度不是固定的，区别于上面的<code>align-items</code>属性）其有6个值：</p>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
<p><img src="\images\flex-grid\flex-align-content.png" alt=""></p>
<h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><p>这些属性用于<code>item</code>中。</p>
<h3 id="1-order属性"><a href="#1-order属性" class="headerlink" title="1. order属性"></a>1. order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<h3 id="2-flex-grow属性"><a href="#2-flex-grow属性" class="headerlink" title="2. flex-grow属性"></a>2. flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（<strong>如果有的话</strong>）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h3 id="3-flex-shrink属性"><a href="#3-flex-shrink属性" class="headerlink" title="3. flex-shrink属性"></a>3. flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，<strong>当空间不足时</strong>，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<h3 id="4-flex-basis属性"><a href="#4-flex-basis属性" class="headerlink" title="4. flex-basis属性"></a>4. flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。（这个属性与<code>width</code>相斥，只有一个属性生效。）</p>
<h3 id="5-flex属性"><a href="#5-flex属性" class="headerlink" title="5. flex属性"></a>5. flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h3 id="3-align-self属性"><a href="#3-align-self属性" class="headerlink" title="3. align-self属性"></a>3. align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目<strong>在交叉行</strong>不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<p><strong>注意：MDN中每个属性还有另外的一些值，比如<code>align-items</code>还有<code>self-atart</code>，<code>start</code>等属性，但是实测在chrome中虽然不会提示错误，但是也不会生效，只有上面的属性会生效，而且<code>VSCODE</code>中也只会提示上面的值，所以，目前只需掌握上面的值即可</strong></p>
<h1 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h1><p><code>grid</code>布局应该是目前原生最先进的布局方案，也正是因为其原生先进，所以其兼容性并不是很好。</p>
<p><img src="\images\flex-grid\grid-compatibility.png" alt="grid-compatibility"></p>
<p>可以看出Chrome在57版本以上才支持，而IE直接不支持。所以不是很友好。但这grid布局是以后的主流。所以可以提前了解其特点。</p>
<p>相同，<code>grid</code>布局中也分为：<code>container</code>容器和<code>item</code>项目。</p>
<h2 id="容器属性-1"><a href="#容器属性-1" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="1-display-属性"><a href="#1-display-属性" class="headerlink" title="1. display 属性"></a>1. display 属性</h3><p><code>display: grid</code>指定一个容器采用网格布局。</p>
<blockquote>
<p>注意，设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p>
</blockquote>
<h3 id="2-grid-template-columns-属性，-grid-template-rows-属性"><a href="#2-grid-template-columns-属性，-grid-template-rows-属性" class="headerlink" title="2. grid-template-columns 属性， grid-template-rows 属性"></a>2. grid-template-columns 属性， grid-template-rows 属性</h3><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/qiginur/edit?css,output" target="_blank" rel="noopener">上面代码</a>指定了一个三行三列的网格，列宽和行高都是<code>100px</code>。</p>
<p>除了使用绝对单位，也可以使用百分比。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p><strong>repeat()</strong>：<code>repeat()</code>接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。如：<code>repeat(3, 20px)</code>，也可以定义为<code>repeat(3, 10px 20px 30px)</code></p>
</li>
<li><p><strong>auto-fill 关键字</strong>：有时，项目的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://jsbin.com/himoku/edit?css,output" target="_blank" rel="noopener">上面代码</a>表示每列宽度<code>100px</code>，然后自动填充，直到容器不能放置更多的列。</p>
</li>
<li><p><strong>fr 关键字</strong>：为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/hadexek/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>表示两个相同宽度的列。</p>
<p><code>fr</code>可以与绝对长度的单位结合使用，这时会非常方便。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p><a href="https://jsbin.com/remowec/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。</p>
<ol start="4">
<li><strong>minmax()</strong></li>
</ol>
<p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span> <span class="selector-tag">minmax</span>(100<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p>
<ol start="5">
<li><strong>auto 关键字</strong></li>
</ol>
<p><code>auto</code>关键字表示由浏览器自己决定长度。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> <span class="selector-tag">auto</span> 100<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p>
<ol start="4">
<li><strong>网格线的名称</strong></li>
</ol>
<p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。<a id="net"></a></p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p>
<p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p>
<h3 id="3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性"><a href="#3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性" class="headerlink" title="3. grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性"></a>3. grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性</h3><p><code>grid-row-gap</code>属性设置行与行的间隔（行间距），<code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</p>
<p>最新标准中，<code>grid-row-gap</code>缩写为<code>row-gap</code>；<code>grid-column-gap</code>缩写为<code>colimn-gap</code>。</p>
<p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式，语法如下。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-gap</span>: &lt;<span class="selector-tag">grid-row-gap</span>&gt; &lt;<span class="selector-tag">grid-column-gap</span>&gt;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-grid-template-areas-属性"><a href="#4-grid-template-areas-属性" class="headerlink" title="4. grid-template-areas 属性"></a>4. grid-template-areas 属性</h3><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">'a b c'</span></span><br><span class="line">                       <span class="string">'d e f'</span></span><br><span class="line">                       <span class="string">'g h i'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码先划分出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p>
<p>多个单元格合并成一个区域的写法如下。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-template-areas: 'a a a'</span><br><span class="line">                     'b b b'</span><br><span class="line">                     'c c c';</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码将9个单元格分成上下<code>a</code>、<code>b</code>、<code>c</code>三个区域。</p>
<p>下面是一个布局实例。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-areas</span>: "<span class="selector-tag">header</span> <span class="selector-tag">header</span> <span class="selector-tag">header</span>"</span><br><span class="line">                     "<span class="selector-tag">main</span> <span class="selector-tag">main</span> <span class="selector-tag">sidebar</span>"</span><br><span class="line">                     "<span class="selector-tag">footer</span> <span class="selector-tag">footer</span> <span class="selector-tag">footer</span>";</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p>
<p>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-template-areas: 'a . c'</span><br><span class="line">                     'd . f'</span><br><span class="line">                     'g . i';</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p>
<blockquote>
<p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p>
<p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p>
</blockquote>
<p>下面是一个经典布局（其中<code>item</code>的属性<code>grid-area</code>下面介绍）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &lt;!<span class="selector-tag">--css</span>代码<span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: grid;</span><br><span class="line">        <span class="attribute">grid-template-areas</span>: <span class="string">"header header header"</span></span><br><span class="line">                     <span class="string">"main main sidebar"</span></span><br><span class="line">                     <span class="string">"footer footer footer"</span>;</span><br><span class="line">        <span class="comment">/* background-color: rgb(247, 80, 177); */</span></span><br><span class="line">        <span class="attribute">grid-template-rows</span>: <span class="number">30px</span> <span class="number">300px</span> <span class="number">30px</span>;</span><br><span class="line">        <span class="attribute">grid-template-columns</span>: <span class="number">400px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-id">#header</span>&#123;</span><br><span class="line">        <span class="attribute">grid-area</span>: header;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">206</span>, <span class="number">206</span>, <span class="number">206</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-id">#main</span>&#123;</span><br><span class="line">        <span class="attribute">grid-area</span>: main;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">235</span>, <span class="number">224</span>, <span class="number">74</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-id">#sidebar</span>&#123;</span><br><span class="line">        <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">250</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-id">#footer</span>&#123;</span><br><span class="line">        <span class="attribute">grid-area</span>: footer;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">112</span>, <span class="number">72</span>, <span class="number">255</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html代码--&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grid"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grid-inner"</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grid-inner"</span> <span class="attr">id</span>=<span class="string">"sidebar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grid-inner"</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grid-inner"</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="\images\flex-grid\grid-classical.png" alt="grid-classical"></p>
<h3 id="3-grid-auto-flow-属性"><a href="#3-grid-auto-flow-属性" class="headerlink" title="3. grid-auto-flow 属性"></a>3. grid-auto-flow 属性</h3><p>grid-auto-flow 属性决定子元素的排列方式。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p>
<p>即grid-auto-flow 属性默认值为：<code>row</code></p>
<p>其取值可以有：</p>
<ol>
<li><p>单值</p>
<ol>
<li><p><code>row</code>（默认值）：按行进行排列</p>
</li>
<li><p><code>column</code>：按列进行排列</p>
</li>
<li><p><code>dense</code>：该关键字指定自动布局算法使用一种“稠密”堆积算法，如果后面出现了稍小的元素，则会试图去填充网格中前面留下的空白。这样做会填上稍大元素留下的空白，但同时也可能导致原来出现的次序被打乱。</p>
<p>如果省略它，使用一种「稀疏」算法，在网格中布局元素时，布局算法只会「向前」移动，永远不会倒回去填补空白。这保证了所有自动布局元素「按照次序」出现，即使可能会留下被后面元素填充的空白。</p>
</li>
</ol>
</li>
<li><p>双值</p>
<ol>
<li><code>row dense</code>：按行排列，并按稠密算法进行填补。</li>
<li><code>column dense</code>：按列排行，并按稠密算法进行填补。</li>
</ol>
</li>
</ol>
<h4 id="正式语法"><a href="#正式语法" class="headerlink" title="正式语法"></a>正式语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ row | column ] || dense</span><br></pre></td></tr></table></figure>
<h3 id="4-justify-items-属性，-align-items-属性，-place-items-属性"><a href="#4-justify-items-属性，-align-items-属性，-place-items-属性" class="headerlink" title="4. justify-items 属性， align-items 属性， place-items 属性"></a>4. justify-items 属性， align-items 属性， place-items 属性</h3><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-items</span>: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性的写法完全相同，都可以取下面这些值。</p>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
<p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-items</span>: &lt;<span class="selector-tag">align-items</span>&gt; &lt;<span class="selector-tag">justify-items</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-items</span>: <span class="selector-tag">start</span> <span class="selector-tag">end</span>;</span><br></pre></td></tr></table></figure>
<p>如果省略第二个值，则浏览器认为与第一个值相等。</p>
<p>另外这个属性还有其他的值，但是支持度并不好：</p>
<p><img src="\images\flex-grid\-items-unsup.png" alt="-items-unsup"></p>
<p>支持较好的属性：</p>
<p><img src="\images\flex-grid\-items-sup.png" alt="-items-sup"></p>
<h3 id="5-justify-content-属性，-align-content-属性，-place-content-属性"><a href="#5-justify-content-属性，-align-content-属性，-place-content-属性" class="headerlink" title="5. justify-content 属性， align-content 属性， place-content 属性"></a>5. justify-content 属性， align-content 属性， place-content 属性</h3><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p>
<ul>
<li>start - 对齐容器的起始边框。</li>
<li>end - 对齐容器的结束边框。</li>
<li>center - 容器内部居中。</li>
<li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li>
<li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li>
<li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li>
<li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li>
</ul>
<p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-content</span>: &lt;<span class="selector-tag">align-content</span>&gt; &lt;<span class="selector-tag">justify-content</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p>
<h3 id="6-grid-auto-columns-属性，-grid-auto-rows-属性"><a href="#6-grid-auto-columns-属性，-grid-auto-rows-属性" class="headerlink" title="6. grid-auto-columns 属性， grid-auto-rows 属性"></a>6. grid-auto-columns 属性， grid-auto-rows 属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，<strong>但是某一个项目指定在第5行</strong>（使用<code>grid-column-start</code>等属性）。这时，浏览器会自动生成多余的网格，以便放置项目。</p>
<p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  	<span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item8</span>&#123;</span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">4</span>;</span><br><span class="line">	<span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\flex-grid\grid-auto.png" alt="grid-auto"></p>
<p>可以看到原本<code>container</code>只有3行3列，但是第8个item被设定在第四行，则浏览器会自动生成第4行，这个第四行就会受<code>grid-auto-rows</code>属性控制。</p>
<h3 id="7-grid-template-属性，-grid-属性"><a href="#7-grid-template-属性，-grid-属性" class="headerlink" title="7. grid-template 属性， grid 属性"></a>7. grid-template 属性， grid 属性</h3><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p>
<p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p>
<h2 id="项目属性-1"><a href="#项目属性-1" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性"><a href="#1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性" class="headerlink" title="1. grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性"></a>1. grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</h3><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p>
<blockquote>
<ul>
<li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li>
<li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li>
<li><code>grid-row-start</code>属性：上边框所在的水平网格线</li>
<li><code>grid-row-end</code>属性：下边框所在的水平网格线</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/yukobuf/edit?css,output" target="_blank" rel="noopener">上面代码</a>指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p>
<p><img src="\images\flex-grid\grid-column-start.png" alt="img"></p>
<p>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p>
<p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p>
<p><a href="https://jsbin.com/nagobey/edit?html,css,output" target="_blank" rel="noopener">下面的例子</a>是指定四个边框位置的效果。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\flex-grid\grid-column-start2.png" alt="grid-column-start2"></p>
<ol>
<li>另外，这4个属性的值还可以取网格线名字，和上面的<a href="#net">网格线名字</a></li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: header-start;			//这里是网格线名字</span><br><span class="line">  grid-column-end: header-end;				//这里是网格线名字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>这四个属性的值还可以使用<code>span</code>关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。    </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://jsbin.com/hehumay/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>表示，1号项目的左边框距离右边框跨越2个网格。</p>
<p><img src="\images\flex-grid\grid-column-start_span.png" alt="grid-column-start_span"></p>
<p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p>
<h3 id="2-grid-column-属性，-grid-row-属性"><a href="#2-grid-column-属性，-grid-row-属性" class="headerlink" title="2. grid-column 属性， grid-row 属性"></a>2. grid-column 属性， grid-row 属性</h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">  <span class="attribute">grid-row</span>: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-grid-area-属性"><a href="#3-grid-area-属性" class="headerlink" title="3. grid-area 属性"></a>3. grid-area 属性</h3><p><code>grid-area</code>属性指定项目放在哪一个区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://jsbin.com/qokexob/edit?css,output" target="_blank" rel="noopener">上面代码</a>中，1号项目位于<code>e</code>区域，效果如下图。</p>
<p><img src="\images\flex-grid\grid-area1.png" alt="grid-area1"></p>
<p>注意：需要在<code>container</code>中使用：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-template-areas: 'a b c'</span><br><span class="line">                    'd e f'</span><br><span class="line">                    'g h i';</span><br></pre></td></tr></table></figure>
<p>来指定区域的位置</p>
<p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output" target="_blank" rel="noopener">例子</a>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-justify-self-属性，-align-self-属性，-place-self-属性"><a href="#4-justify-self-属性，-align-self-属性，-place-self-属性" class="headerlink" title="4. justify-self 属性， align-self 属性， place-self 属性"></a>4. justify-self 属性， align-self 属性， place-self 属性</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p>
<p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">justify-self</span>: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性都可以取下面四个值。</p>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
<p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-self</span>: &lt;<span class="selector-tag">align-self</span>&gt; &lt;<span class="selector-tag">justify-self</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-self</span>: <span class="selector-tag">center</span> <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure>
<p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看出：</p>
<ol>
<li><code>flex</code>布局与<code>grid</code>布局相较于原始的浮动布局，简单快捷很多。所以目前<code>flex</code>布局使用的较多，但是由于<code>grid</code>布局的兼容性并不好，所以使用的并不多。</li>
<li>两种布局的属性中存在很多其他<code>W3C</code>以规定的属性，但是浏览器很多都没有实现，<code>Chrome</code>虽然有对应的值，但是并没有生效。</li>
</ol>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>使用<code>flex</code>布局进行多行布局，并使用<code>justify-content:center/space-around-space-between</code>时，如果最后一行的<code>item</code>数目少于屏幕能容纳的最大数，最后一行会出现问题，即最后一行不能左对齐，会按照其属性进行居中。</p>
<p>目前还没找到很好的解决办法，特别是在每行的数目不能确定的情况下，目前最普遍的方法时使用空白标签占位法，即使用每行添加最大能容纳的<code>item</code>数目的空白标签。这样空白标签不会显示，显性标签就会展示为左对其。但是任然还有一个问题，就是如果每行的数目减小，或者刚好能够容纳，则会出现一行(甚至两行)空白区域。虽然不影响，但是感觉仍然不是最优解。<code>grid</code>布局虽然能够在格式上完美解决，但是由于其兼容性，也不是很好的解决办法。目前仍在想能有什么解决办法。</p>
]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
        <tag>flex布局</tag>
        <tag>grid</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis动态SQL和resultMap</title>
    <url>/2022/04/15/MyBatis%E5%8A%A8%E6%80%81SQL%E5%92%8CresultMap/</url>
    <content><![CDATA[<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>mybatis动态SQL可以根据<strong>Java变量</strong>的不同动态拼接SQL，其本质就是按照我们每次向接口中传入的变量和我们指定的规则来帮助我们拼接SQL语句，简化了SQL语句的编写。</p>
<p>其主要有以下几组标签，其语义与在Java中相同：</p>
<ul>
<li><code>if</code></li>
<li><code>choose (when, otherwise)</code></li>
<li><code>trim (where, set)</code></li>
<li><code>foreach</code></li>
</ul>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if即条件判断，一般多用于where后的判断。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findActiveBlogWithTitleLike" resultType="Blog"&gt;</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line">  <span class="keyword">WHERE</span> state = <span class="string">'ACTIVE'</span></span><br><span class="line">  &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"title != null"</span>&gt;</span><br><span class="line">    <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="comment">#&#123;title&#125;</span></span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里只有当<code>title != null</code>成立的时候，其内部的语句<code>AND title like #{title}</code>才会添加到SQL语句中。</p>
<h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><p>这一组标签类似于Java中的switch语句或者<code>if...else if...else</code>语句。</p>
<p>即当会依次检验<code>when</code>是否满足，如果一个满足就按该语句拼接；如果都不满足，就按照<code>otherwise</code>来拼接。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findActiveBlogLike"</span><br><span class="line">     resultType="Blog"&gt;</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG <span class="keyword">WHERE</span> state = ‘ACTIVE’</span><br><span class="line">  &lt;<span class="keyword">choose</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">when</span> <span class="keyword">test</span>=<span class="string">"title != null"</span>&gt;</span><br><span class="line">      <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="comment">#&#123;title&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">when</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">when</span> <span class="keyword">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span><br><span class="line">      <span class="keyword">AND</span> author_name <span class="keyword">like</span> <span class="comment">#&#123;author.name&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">when</span>&gt;</span><br><span class="line">    &lt;otherwise&gt;</span><br><span class="line">      <span class="keyword">AND</span> featured = <span class="number">1</span></span><br><span class="line">    &lt;/otherwise&gt;</span><br><span class="line">  &lt;/<span class="keyword">choose</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里当<code>title != null</code>满足的时候，就按第一个when拼接，后面的都不再执行；否则检验<code>author != null and author.name != null</code>，如果满足，则按该<code>when</code>拼接，否则就直接按<code>otherwise</code>来拼接。</p>
<h2 id="where、trim、set"><a href="#where、trim、set" class="headerlink" title="where、trim、set"></a>where、trim、set</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>这一组标签是为了解决前面标签存在的问题。</p>
<p>有下面的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findActiveBlogLike"</span><br><span class="line">     resultType="Blog"&gt;</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">  &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"state != null"</span>&gt;</span><br><span class="line">    state = <span class="comment">#&#123;state&#125;</span></span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"title != null"</span>&gt;</span><br><span class="line">    <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="comment">#&#123;title&#125;</span></span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span><br><span class="line">    <span class="keyword">AND</span> author_name <span class="keyword">like</span> <span class="comment">#&#123;author.name&#125;</span></span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>现在思考，</p>
<ol>
<li><p>假设<code>state != null</code>、<code>title != null</code>、<code>author != null and author.name != null</code>都验证失败，则SQL语句拼接为如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br></pre></td></tr></table></figure>
<p>很明显这是一个错误的SQL。</p>
</li>
<li><p>假设<code>state != null</code>验证失败，但<code>title != null</code>和<code>author != null and author.name != null</code>验证成功，则SQL语句拼接如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">AND</span> title <span class="keyword">like</span> <span class="comment">#&#123;title&#125;</span></span><br><span class="line"><span class="keyword">AND</span> author_name <span class="keyword">like</span> <span class="comment">#&#123;author.name&#125;</span></span><br></pre></td></tr></table></figure>
<p>很明显，这也是一个错误的SQL。</p>
</li>
</ol>
<p>而<code>where</code>标签就是为了解决这两种情况，其特点如下：</p>
<ul>
<li>如果条件都不满足，则自动去掉<code>WHERE</code>关键字。</li>
<li>如果第一个条件不满足，则自动去掉<code>AND</code>、<code>OR</code>关键字。</li>
</ul>
<p>将上面的改写如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findActiveBlogLike"</span><br><span class="line">     resultType="Blog"&gt;</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line">  &lt;<span class="keyword">where</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"state != null"</span>&gt;</span><br><span class="line">        state = <span class="comment">#&#123;state&#125;</span></span><br><span class="line">      &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"title != null"</span>&gt;</span><br><span class="line">        <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="comment">#&#123;title&#125;</span></span><br><span class="line">      &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span><br><span class="line">        <span class="keyword">AND</span> author_name <span class="keyword">like</span> <span class="comment">#&#123;author.name&#125;</span></span><br><span class="line">      &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;/<span class="keyword">where</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如此上面两种情况分别生成的SQL如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span> title <span class="keyword">like</span> <span class="comment">#&#123;title&#125;</span></span><br><span class="line"><span class="keyword">AND</span> author_name <span class="keyword">like</span> <span class="comment">#&#123;author.name&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>与where一样，set关键字如果直接拼接也会面临问题。</p>
<p>有下面的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;update&gt;</span><br><span class="line"><span class="keyword">UPDATE</span> Author <span class="keyword">SET</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"username != null"</span>&gt;username=<span class="comment">#&#123;username&#125;,&lt;/if&gt;</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"password != null"</span>&gt;<span class="keyword">password</span>=<span class="comment">#&#123;password&#125;,&lt;/if&gt;</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"email != null"</span>&gt;email=<span class="comment">#&#123;email&#125;,&lt;/if&gt;</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"bio != null"</span>&gt;bio=<span class="comment">#&#123;bio&#125;&lt;/if&gt;</span></span><br><span class="line">         <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/<span class="keyword">update</span>&gt;</span><br></pre></td></tr></table></figure>
<p>现在思考，假如只有<code>bio != null</code>验证失败，其他都成功，则拼接的SQL如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Author <span class="keyword">SET</span> username = <span class="comment">#&#123;username&#125;, password=#&#123;password&#125;, email=#&#123;email&#125;, WHERE id=#&#123;id&#125;</span></span><br></pre></td></tr></table></figure>
<p>很明显，这也是一个错误的SQL，因为多了一个逗号<code>,</code>。</p>
<p>而set标签就是为了解决该问题而生的。</p>
<p>其操作为：会自动去掉后缀的都好<code>,</code>。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;update&gt;</span><br><span class="line"><span class="keyword">UPDATE</span> Author</span><br><span class="line">	&lt;<span class="keyword">set</span>&gt;</span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"username != null"</span>&gt;username=<span class="comment">#&#123;username&#125;,&lt;/if&gt;</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"password != null"</span>&gt;<span class="keyword">password</span>=<span class="comment">#&#123;password&#125;,&lt;/if&gt;</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"email != null"</span>&gt;email=<span class="comment">#&#123;email&#125;,&lt;/if&gt;</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"bio != null"</span>&gt;bio=<span class="comment">#&#123;bio&#125;&lt;/if&gt;</span></span><br><span class="line">         <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125;</span></span><br><span class="line">      &lt;/<span class="keyword">set</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">update</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>该标签与Java中意思一致，即去前缀或后缀，不同的是，Java中只能去除空格，而这里可以自定义要去除的对象以及哪个关键字的前后缀。</p>
<blockquote>
<p>实际上上面的where标签和set标签都是trim标签的特殊情况，因为上面的本质就是前后缀的问题。</p>
</blockquote>
<p>例如要实现上面where标签的功能。</p>
<p>其代码就如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="findActiveBlogLike"</span><br><span class="line">     resultType="Blog"&gt;</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line">  &lt;<span class="keyword">trim</span> prefix=<span class="string">"where"</span> prefixOverrides=<span class="string">"AND |OR"</span>&gt;		</span><br><span class="line">      &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"state != null"</span>&gt;</span><br><span class="line">        state = <span class="comment">#&#123;state&#125;</span></span><br><span class="line">      &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"title != null"</span>&gt;</span><br><span class="line">        <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="comment">#&#123;title&#125;</span></span><br><span class="line">      &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span><br><span class="line">        <span class="keyword">AND</span> author_name <span class="keyword">like</span> <span class="comment">#&#123;author.name&#125;</span></span><br><span class="line">      &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;/<span class="keyword">trim</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>其属性有以下四个：</p>
<ul>
<li>prefix：前缀</li>
<li>prefixOverrides：要去除的前缀</li>
<li>suffix：后缀</li>
<li>prefixOverrides：要去除的后缀</li>
</ul>
<p>即prefix和suffix分别会被加到语句中，而prefixOverrides和prefixOverrides会被去掉。</p>
<p>再例如update语句中去除拼接时的<code>,</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;update&gt;</span><br><span class="line">	<span class="keyword">UPDATE</span> Author</span><br><span class="line">	&lt;<span class="keyword">trim</span> prefix=<span class="string">"SET"</span> prefixOverrides=<span class="string">","</span>&gt;</span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"username != null"</span>&gt;username=<span class="comment">#&#123;username&#125;,&lt;/if&gt;</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"password != null"</span>&gt;<span class="keyword">password</span>=<span class="comment">#&#123;password&#125;,&lt;/if&gt;</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"email != null"</span>&gt;email=<span class="comment">#&#123;email&#125;,&lt;/if&gt;</span></span><br><span class="line">          &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">"bio != null"</span>&gt;bio=<span class="comment">#&#123;bio&#125;&lt;/if&gt;</span></span><br><span class="line">	&lt;/<span class="keyword">trim</span>&gt;</span><br><span class="line">	<span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/<span class="keyword">update</span>&gt;</span><br></pre></td></tr></table></figure>
<p>本例中，则会自动加上SET，并且会去掉后缀<code>,</code>。</p>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>与Java一致，该标签用于遍历接口传入的<strong>集合</strong>（<code>List, Array, Map</code>）。</p>
<p>其包含以下属性：</p>
<ul>
<li>collection： 表示迭代集合的名称</li>
<li>item： 表示本次迭代获取的元素，若collection为List、Set或者数组，则表示其中的元素；若collection为map，则代表key-value的value，该参数为必选</li>
<li>open：表示该语句以什么开始，最常用的是左括弧<code>(</code>，注意:mybatis会将该字符拼接到整体的sql语句之前，并且只拼接一次，该参数为可选项</li>
<li>close：表示该语句以什么结束，最常用的是右括弧<code>)</code>，注意:mybatis会将该字符拼接到整体的sql语句之后，该参数为可选项</li>
<li>separator：mybatis会在每次迭代后给sql语句append上separator属性指定的字符，一般为逗号<code>,</code>，该参数为可选项</li>
<li>index： 在list、Set和数组中,index表示当前迭代的位置，在map中，index代指是元素的key，该参数是可选项。</li>
</ul>
<p>由于包含多个元素，所以其一般和IN一起用，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="queryUserByIdsList"  resultType="user"&gt;</span><br><span class="line">		<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">		&lt;<span class="keyword">where</span>&gt; <span class="keyword">id</span> <span class="keyword">in</span> </span><br><span class="line">			&lt;foreach collection=<span class="string">"list"</span> item=<span class="string">"item"</span> <span class="keyword">open</span>=<span class="string">"("</span> <span class="keyword">close</span>=<span class="string">")"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">				<span class="comment">#&#123;item&#125;</span></span><br><span class="line">			&lt;/foreach&gt;</span><br><span class="line">		&lt;/<span class="keyword">where</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>补充：该标签也可以配合mybaits的函数<code>split</code>，将一个字段分割，然后每个部分依次再拼接。</p>
<p>如tags是按<code>id1;id2;id3</code>这样拼接的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="queryUserByIdsList"  resultType="user"&gt;</span><br><span class="line">		<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">		&lt;<span class="keyword">where</span>&gt; <span class="keyword">id</span> <span class="keyword">in</span> </span><br><span class="line">			&lt;foreach collection=<span class="string">"tags.split(';')"</span> item=<span class="string">"item"</span> <span class="keyword">open</span>=<span class="string">"("</span> <span class="keyword">close</span>=<span class="string">")"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">				<span class="comment">#&#123;item&#125;</span></span><br><span class="line">			&lt;/foreach&gt;</span><br><span class="line">		&lt;/<span class="keyword">where</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>bind标签允许我们创建一个变量，并将其绑定到当前的上下文。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="selectBlogsLike" resultType="Blog"&gt;</span><br><span class="line">  &lt;bind name="pattern" value="'%' + _parameter.getTitle() + '%'" /&gt;</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line">  <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="comment">#&#123;pattern&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h3 id="多参数的接口"><a href="#多参数的接口" class="headerlink" title="多参数的接口"></a>多参数的接口</h3><p>一般我们再定义接口的时候只有一个参数，但是当有多个参数的时候，mybatis的行为就与我们直觉的不太相同。</p>
<p>因为只有一个参数<code>var</code>的时候，我们使用<code>#{name}</code>取值时，实际上是取<code>var.name</code>属性。但是当具有多个参数时，这种方法就明显有歧义的。</p>
<p>因此其默认行为改为：</p>
<ul>
<li>将参数自动命名为<code>paramX</code>（X为参数的序号-从1开始）。</li>
<li>也可以直接通过<code>#{X}</code>来获取第X个参数-从0开始。</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="selectUser" resultMap="UserResultMap"&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    <span class="keyword">where</span> user_name = <span class="comment">#&#123;param1&#125; and dept_id = #&#123;param2&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> <span class="keyword">id</span>=<span class="string">"selectUser"</span> resultMap=<span class="string">"UserResultMap"</span>&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    <span class="keyword">where</span> user_name = <span class="comment">#&#123;0&#125; and dept_id = #&#123;1&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这两种都不直观，更好的解决办法是，通过注解<code>@Param</code>来为其命名。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUser</span><span class="params">(@Param(<span class="string">"userName"</span>)</span> String name, <span class="keyword">int</span> @<span class="title">Param</span><span class="params">(<span class="string">"deptId"</span>)</span> deptId)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="selectUser" resultMap="UserResultMap"&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">    <span class="keyword">where</span> user_name = <span class="comment">#&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>或者将其封装到map或Java bean中。</p>
<h3 id="mybatis内置参数"><a href="#mybatis内置参数" class="headerlink" title="mybatis内置参数"></a><span id="_parameter">mybatis内置参数</span></h3><p>mybatis内置了几个参数：</p>
<ul>
<li><p><code>_parameter</code>：所有参数，如果为单参数，则其就为该参数；如果是多参数，就会将其封装为一个map。</p>
<ul>
<li>第二种情况可以直接通过<code>.</code>来获取属性值，如<code>_parameter.uId</code></li>
</ul>
</li>
<li><p><code>_databaseId</code>：用户所指定的对应的数据库厂商标识。需要再mybaits配置文件中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">"DB_VENDOR"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"MySQL"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--//多个数据库提供商配置...--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（一般用的不多）</p>
</li>
<li><p><code>#{value}</code>：当参数只有一个的时候，该参数可以直接使用<code>#{value}</code>来引用，（也可以使用参数名字来引入）。这个一般配合<code>resultMap</code>的嵌套查询，因为其参数的名字没法指定。</p>
</li>
</ul>
<h1 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h1><p>resultMap可以让我们将数据库中的字段与Java对象中的属性按照指定的方法匹配起来，mybatis将会自动按照该匹配进行封装。</p>
<p>例如：</p>
<p>1、Java对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> myId;</span><br><span class="line">    <span class="keyword">private</span> String myName;</span><br><span class="line">    <span class="keyword">private</span> String myHobby;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、表字段：</p>
<ul>
<li>id</li>
<li>name</li>
<li>hobby</li>
</ul>
<p>此时要将其对应起来，自动就无能为力了，需要我们编写resultMap来手动匹配：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;resultMap  id="userResultMap" type="user"&gt;</span><br><span class="line">  &lt;id property="myId" column="id" /&gt;</span><br><span class="line">  &lt;result property="myName" column="name"/&gt;</span><br><span class="line">  &lt;result property="myHobby" column="hobby"/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<p>然后再sql中使用该resultMap：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="selectUsers" resultMap="userResultMap"&gt;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, hobby</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">users</span></span><br><span class="line">  <span class="keyword">where</span> <span class="keyword">id</span> = <span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如此就能完成对应工作。</p>
<h3 id="半自动匹配"><a href="#半自动匹配" class="headerlink" title="半自动匹配"></a>半自动匹配</h3><p>如果我们表中和对象中只有部分不匹配，则可以只手动编写不匹配的，然后将<code>autoMapping</code>设置为<code>true</code>。</p>
<h3 id="高级匹配"><a href="#高级匹配" class="headerlink" title="高级匹配"></a>高级匹配</h3><p>resultMap不光可以完成简单字段的匹配，也可以完成对象和集合的匹配。</p>
<p>例如：</p>
<p>1、User对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">    <span class="keyword">private</span> Person mentor;</span><br><span class="line">    <span class="keyword">private</span> Person[] friends;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    Person对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、表</p>
<ul>
<li>users：<ul>
<li>id</li>
<li>name</li>
<li>mentor</li>
<li>friends</li>
</ul>
</li>
<li>persons:<ul>
<li>id</li>
<li>fId</li>
<li>name</li>
</ul>
</li>
</ul>
<p>3、resultMap</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span>  <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"user"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"mentor"</span> <span class="attr">javaType</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"MId"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"MName"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"friends"</span>  <span class="attr">javaType</span>=<span class="string">"Person"</span> &gt;</span></span><br><span class="line">    	 <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"FId"</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"FName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4、SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUser"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">	SELECT userT.id as id, userT.name as name, userT.hobby as hobby, </span><br><span class="line">    mentorT.id = MId, mentorT.name = MName, </span><br><span class="line">    friendsT.id = FId, friendsT.name = FName</span><br><span class="line">    FROM users userT left outer join persons personsT ON userT.mentor = mentorT.id</span><br><span class="line">    left outer join firends friendsT ON userT.id = friendsT.fId</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就能自动装配好其对象和集合属性。</p>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>有时候Java实体中的属性不能简单的通过表的连接来查询，需要更加复杂的查询。例如将一张表中的某个字段分割过后，使用分割后的元素进行查询，此时除了使用较为复杂的存储过程外，还可以使用<code>resultMap</code>中的<code>sql</code>属性来配置子查询。</p>
<p>如：</p>
<p>1、User对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">    <span class="keyword">private</span> Person[] friends;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    Person对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、表（与上一致）</p>
<p>注意此时数据库中users表的friends是按照<code>frinedId1;frinedId2;frinedId3</code>这样存储的。</p>
<p>3、resultMap</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span>  <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"user"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"friends"</span>  <span class="attr">javaType</span>=<span class="string">"Person"</span> <span class="attr">sql</span>=<span class="string">"_findPerson"</span>  <span class="attr">autoMapping</span>=<span class="string">"true"</span>/&gt;</span>  <span class="comment">&lt;!--由于获取的字段名字相同了，所以可以直接自动匹配了--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4、SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUser"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    SELECT id, name, friends FROM users</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"_findPerson"</span> <span class="attr">resultType</span>=<span class="string">"person"</span>&gt;</span></span><br><span class="line">    SELECT id, name FROM friends WHERE id IN </span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"_parameter.split(';')"</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"itemId"</span>&gt;</span></span><br><span class="line">        #&#123;itemId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是这里的<code>_parameter</code>，就如<a href="#_parameter">上面</a>说的，此时相当于也是一个接口，但是我们并不是直接传参，所以并不知道具体的参数名字，则<code>_parameter</code>就可以直接使用了。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>动态SQL</tag>
        <tag>resultMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue插件开发4-插件的打包与引用</title>
    <url>/2021/01/13/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%914-%E6%8F%92%E4%BB%B6%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Vue插件的打包"><a href="#Vue插件的打包" class="headerlink" title="Vue插件的打包"></a>Vue插件的打包</h1><p>还是犯了一个最基础的错误，本来插件打包Vue-CLI官网给出了<a href="https://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%93" target="_blank" rel="noopener">说明</a>，而我还在苦苦百度。百度上的教程都是几年前的，全是照搬一套。</p>
<p>具体过程就是：</p>
<ol>
<li><p>按照<a href="https://michaelwang.top/2021/01/12/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911-%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%8D%B3%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">Vue插件开发1-插件原理即应用</a>编写一个插件。</p>
</li>
<li><p>使用命令<code>vue-cli-service build --target lib --name myLib [entry]</code></p>
<ol>
<li><code>myLib</code>就是你的插件名字，主要是JS文件的命名。</li>
<li>[entry]是你的文件入口文件，即导出<code>install函数</code>文件</li>
</ol>
</li>
<li><p>执行该命令就会生成打包完成的js文件。</p>
<p><img src="D:\myblog\myblog\source\images\vue插件\vue插件3-1.png" alt=""></p>
</li>
</ol>
<ul>
<li><code>dist/drag-window.common.js</code>：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包)</li>
<li><code>dist/drag-window.umd.js</code>：一个直接给浏览器或 AMD loader 使用的 UMD 包</li>
<li><code>dist/drag-window.umd.min.js</code>：压缩后的 UMD 构建版本</li>
<li><code>dist/drag-window.css</code>：提取出来的 CSS 文件 (可以通过在 <code>vue.config.js</code> 中设置 <code>css: { extract: false }</code> 强制内联)</li>
<li><code>js.map</code>：source map文件是js文件压缩后，文件的变量名替换对应、变量所在位置等元信息数据文件，一般这种文件和min.js主文件放在同一个目录下。 比如压缩后原变量是map，压缩后通过变量替换规则可能会被替换成a，这时source map文件会记录下这个mapping的信息，这样的好处就是说，在调试的时候，如果有一些JS报错，那么浏览器会通过解析这个map文件来重新merge压缩后的js,使开发者可以用未压缩前的代码来调试，这样会给我们带来很大的方便！</li>
</ul>
<h1 id="npm插件的上传"><a href="#npm插件的上传" class="headerlink" title="npm插件的上传"></a>npm插件的上传</h1><p>npm其实就是一个仓库。与git一样，我们使用<code>npm install xxx</code>的时候实际上是把其仓库中的<code>xxx</code>文件夹下载到本地。并再到<code>node_modules</code>中，我就可以直接使用<code>import xxx from xxx</code>的语法引入插件，实际上与我们在<code>src</code>下新建一个文件夹<code>lib</code>，然后使用<code>import xxx from ./lib/xxx.js</code>效果一样。</p>
<p>所以我们只需要</p>
<ol>
<li><p>在<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>注册一个npm账号。</p>
</li>
<li><p>然后新建一个文件夹使用<code>npm init</code> 初始化一个<code>package.js</code>文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"drag-window"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.21"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"A plugin  creating a drag window"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"keywords"</span>: [</span><br><span class="line">    <span class="string">"darg"</span>,</span><br><span class="line">    <span class="string">"window\u001b[D\u001b[D\u001b[D\u001b[D\u001b[D\u001b[D"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"mw530"</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   这是一个最基本的样板，关键是<code>private: true</code>，然后把<code>main.js</code>设为生成的那个js文件。</p>
<ol start="3">
<li><p>在命令行使用<code>npm adduser</code>将自己的用户添加上去。</p>
</li>
<li><p>使用<code>npm publish</code>上传自己的文件。</p>
</li>
</ol>
<p>注意：其中一个点是仓库必须切换为官方仓库，不能为淘宝仓库。</p>
<ul>
<li><p>官方仓库：npm config set registry=<a href="http://registry.npmjs.org" target="_blank" rel="noopener">http://registry.npmjs.org</a></p>
</li>
<li><p>淘宝仓库：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>;</p>
</li>
</ul>
<h1 id="插件的引用"><a href="#插件的引用" class="headerlink" title="插件的引用"></a>插件的引用</h1><p>与<a href="https://michaelwang.top/2021/01/12/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911-%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%8D%B3%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">Vue插件开发1-插件原理即应用</a>的使用一样，只是引入的地址直接写插件命即可，如<code>import xxx from &#39;xxx&#39;</code>。然后使用<code>Vue.use(xxx)</code>。</p>
<p>注意样式表文件需全局直接<code>import xxx/aaa.css</code>，如果在<code>&lt;style&gt;</code>使用了使用了<code>scope</code>属性，则其样式表只在对应组件起效，如果不加，则会全局影响。</p>
]]></content>
      <categories>
        <category>Vue插件</category>
      </categories>
      <tags>
        <tag>Vue插件</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习2-基本快照</title>
    <url>/2022/02/27/git%E5%AD%A6%E4%B9%A02-%E5%9F%BA%E6%9C%AC%E5%BF%AB%E7%85%A7/</url>
    <content><![CDATA[<h1 id="基本快照"><a href="#基本快照" class="headerlink" title="基本快照"></a>基本快照</h1><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>add命令用于使用在工作树中找到的当前内容来更新索引，其为下一次提交（<code>commit</code>）准备阶段性的内容。通常将现有路径的当前内容作为一个整体添加，但通过一些选项，它也可以用于添加只应用了部分工作树文件更改的内容，或者删除工作树中不再存在的路径。</p>
<p><code>git status</code>命令可用于获取一个摘要，其中哪些文件有更改，将在下次提交时暂存。</p>
<p>默认情况下，<code>git add</code>命令不会添加被忽略的文件。如果在命令行中显式地指定了任何被忽略的文件，<code>git add</code>将失败，并显示一列被忽略的文件。<code>git add</code>命令可以使用<code>-f (force)</code>选项添加被忽略的文件。</p>
<h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><ul>
<li><code>&lt;pathspec&gt;…</code>：要添加的文件。其规则很简单，主要是通配符<code>*</code>和<code>?</code>可以匹配目录分隔符。例如：<code>Documentation/*.jpg</code>将匹配<code>Documentation</code>子树中的所有<code>.jpg</code>文件，包括<code>Documentation/chapter_1/figure_1.jpg</code>。</li>
<li><code>-f</code>：允许添加被忽略的文件。</li>
</ul>
<h3 id="通常用法："><a href="#通常用法：" class="headerlink" title="通常用法："></a>通常用法：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>用来将所有以改变的文件都更新索引。</p>
<h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>该命令展示当前索引文件和当前HEAD提交的不同，工作树与索引文件存在差异的路径，以及工作树中未被Git跟踪的路径。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>-s</code>：以短格式化来给出输出。</li>
<li><code>-l</code>：以长格式来给出输出。</li>
<li><code>-b; --branch</code>：给出分支和追踪信息（可以以短格式）。</li>
<li><code>-v</code>：除了已更改的文件的名称外，还显示要提交的暂存文本的更改。</li>
<li><code>--ignored [=&lt;mode&gt;]</code>：也显示被忽略的文件。<code>mode</code>参数用于指定对被忽略文件的处理。它是可选的:默认<code>traditional</code>。</li>
</ul>
<h3 id="通常用法"><a href="#通常用法" class="headerlink" title="通常用法"></a>通常用法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>查看当前的文件状态。</p>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>该命令用于显示工作树和索引树之间的更改、索引和树之间的更改、两棵树之间的更改、合并导致的更改、两个blob对象之间的更改或磁盘上两个文件之间的更改。</p>
<h3 id="git-diff-lt-options-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] [--] [&lt;path&gt;…]</code></h3><p>用于查看相对于索引(下一次提交的暂存区域)所做的更改。您可以通过使用<code>git-add</code>来逐步执行这些更改。</p>
<h3 id="git-diff-lt-options-gt-no-index-lt-path-gt-lt-path-gt"><a href="#git-diff-lt-options-gt-no-index-lt-path-gt-lt-path-gt" class="headerlink" title="git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;"></a><code>git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;</code></h3><p>用于比较给定的文件系统上的两条路径。当运行命令在一个Git控制的工作树并且至少其中一个路径指向Git工作目录时，可以省略<code>--no-index</code>。</p>
<h3 id="git-diff-lt-options-gt-cached-merge-base-lt-commit-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-cached-merge-base-lt-commit-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…]</code></h3><p>用于查看下一个提交相对于其他一次\&lt;commit>的更改。如果不给出\&lt;commit>，则默认是HEAD位置。如果没有HEAD并且\&lt;commit>也没有给出，则显示了所有的<code>staged</code>变化。<code>--staged</code>与<code>--cached</code>一样。</p>
<p>如果使用<code>--merge-base</code>来替换<code>&lt;commit&gt;</code>，则使用使用<code>&lt;commit&gt;</code>和HEAD得合并基点（merge base）来和<code>path</code>进行比较。而不是直接用<code>&lt;commmit&gt;</code>比较。</p>
<h3 id="git-diff-lt-options-gt-merge-base-lt-commit-gt-lt-commit-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-merge-base-lt-commit-gt-lt-commit-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…]</code></h3><p>用来查看任意两个<code>commit</code>之间的改变。</p>
<p>如果给出了<code>--merge-base</code>选项，就是用两个<code>commit</code>的合并基点（merge base）作为前测，与后面的<code>commit</code>进行对比。</p>
<h3 id="git-diff-lt-options-gt-lt-commit-gt-lt-commit-gt-…-lt-commit-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-lt-commit-gt-lt-commit-gt-…-lt-commit-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] &lt;commit&gt; &lt;commit&gt;… &lt;commit&gt; [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] &lt;commit&gt; &lt;commit&gt;… &lt;commit&gt; [--] [&lt;path&gt;…]</code></h3><p>用于查看合并提交的结果。列出的第一个<code>&lt;commit&gt;</code>必须是merge本身;剩下的两个或更多的提交应该是它的父节点。生成所需修订集的一种方便的方法是使用<code>^@</code>后缀。</p>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>创建一个新的提交（commit），包含索引的当前内容和描述更改的给定日志消息。新的提交是HEAD的直接子节点，通常是当前分支的顶端，并且该分支被更新为指向它(除非没有分支与工作树相关联，在这种情况下，如<code>git-checkout</code>中所述，HEAD被“分离”)。</p>
<p>要提交的内容可以通过以下几种方式指定:</p>
<ul>
<li>通过使用<code>git-add</code>，在使用commit命令之前，递增地“添加”对索引的更改。</li>
<li>在使用commit命令之前，使用<code>git-rm</code>从工作树和索引中删除文件。</li>
<li>通过列出文件作为提交命令的参数(没有<code>--interactive</code>或<code>--patch switch</code>)，在这种情况下，提交将忽略索引中的更改，而是记录列出文件的当前内容(这必须是Git已经知道的);</li>
<li><strong>通过使用<code>-a</code>参数和commit命令自动“添加”所有已知文件(即所有已经在索引中列出的文件)的更改，并自动“rm”索引中已经从工作树中删除的文件，然后执行实际的提交;</strong>-可以省略add步骤（如果全部提交）。</li>
<li>通过使用<code>--interactive</code>或<code>--patch</code>开关和<code>commit</code>命令来逐个决定除了索引中的内容之外，哪些文件或块应该作为提交的一部分，然后再完成操作。</li>
</ul>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><strong><code>-a;--all</code></strong>：告诉命令自动处理已经被修改和删除的文件（<strong>也相当于自动add</strong>），<strong>但是没有告诉Git的新文件不受影响。</strong></li>
<li><code>-p;--patch</code>：使用交互式补丁选择接口来选择要提交的更改。</li>
<li><code>-C &lt;commit&gt;; --reuse-message=&lt;commit&gt;</code>：获取一个现有的提交对象，并在创建提交时重用日志消息和作者信息(包括时间戳)。</li>
<li><code>-c &lt;commit&gt;; --reedit-message=&lt;commit&gt;</code>：与<code>-C</code>类似，但使用<code>-C</code>会调用编辑器，以便用户可以进一步编辑提交消息。</li>
<li><code>--reset-author</code>：当与<code>-C/ -c/--amend</code>选项一起使用时，或者在发生冲突的选择之后提交时，声明结果提交的作者现在属于提交者。这也会更新作者的时间戳。</li>
<li><code>--short</code>：使用短格式来输出。</li>
<li><code>--long</code>：使用长格式来输出。</li>
<li><code>--branch</code>：显示分支和跟踪信息。</li>
<li><code>-F &lt;file&gt;; --file=&lt;file&gt;</code>：从给定的文件中获取提交消息。</li>
<li><code>--author=&lt;author&gt;</code>：覆盖全局得提交作者。</li>
<li><code>--date=&lt;date&gt;</code>：覆盖提交中使用的作者日期。</li>
<li><code>-m &lt;msg&gt;; --message &lt;msg&gt;</code>：使用给定的<code>&lt;msg&gt;</code>作为提交消息。如果给出了多个-m选项，它们的值将连接成单独的段落。注意：<code>-m</code>与<code>-c</code>、<code>-c</code>、<code>-F</code>互斥。</li>
<li><code>-s; --signoff; --no-signoff</code>：在提交日志消息的末尾添加一个由提交者签名的拖尾。终止的意义取决于你所提交的项目。例如，它可以证明提交者有权在项目许可下提交作品，或者同意一些贡献者的代表，例如开发者原产地证书。参考您正在参与的项目的文档或领导，以理解在该项目中如何使用结束。</li>
<li><strong><code>--allow-empty</code></strong>：允许提交与上一次<code>commit</code>完全相同的文件内容，其他信息都可以修改，如<code>&lt;msg&gt;</code>。</li>
<li><strong><code>--allow-empty-message</code></strong>：允许提交一次不包含<code>&lt;msg&gt;</code>的<code>commit</code>。</li>
<li><code>-e; --edit</code>：打开编辑器（系统设定的默认文本编辑器）来修改来自<code>-F</code>或者<code>-m</code>的消息。</li>
<li><code>--no-edit</code>：默认，直接提交来自<code>-F</code>或者<code>-m</code>的消息。</li>
<li><code>--amend</code>：直接替换上一次<code>commit</code>记录（慎重），上一次的<code>commit</code>信息都没了。</li>
</ul>
<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><p>添加、删除或读取附加到对象的注释，而不接触对象本身。默认情况下，注释被保存到<code>refs/notes/commits</code>中并从<code>refs/notes/commits</code>中读取，但是这个默认值可以被覆盖。请参阅下面的选项、配置和环境部分。如果这个ref不存在，它将在第一次需要存储笔记时被静默创建。</p>
<p>注释的典型用法是补充提交消息，而不更改提交本身。可以通过<code>git log</code>显示注释和原始的提交消息。为了区分这些注释和存储在提交对象中的消息，注释像消息一样被缩进，在一个未缩进的行<code>notes (&lt;refname&gt;):</code>(或<code>notes:</code>对于<code>refs/notes/commits</code>)之后。</p>
<p><code>Notes</code>也可以通过使用<code>--Notes</code>选项添加到使用<code>git format-patch</code>准备的补丁中。这样的注释作为补丁注释添加在三个破折号分隔线之后。</p>
<h3 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h3><ul>
<li><code>list</code>：列出给定对象的notes对象。如果没有给出对象，则显示所有注释对象及其注释对象的列表(格式为<code>&lt;注释对象&gt; &lt;注释对象&gt;</code>)。<strong>如果没有给出子命令，这是默认的子命令</strong>。</li>
<li><code>add</code>：为给定对象添加<code>notes</code>(默认为HEAD)。如果对象已经有注释则中止(使用<code>-f</code>覆盖现有的注释)。但是，如果您是交互式地使用add(使用编辑器提供注释内容)，那么现有的注释将在编辑器中打开而不是终止(就像编辑子命令)。</li>
<li><code>copy</code>：复制第一个对象的<code>notes</code>到第二个对象（默认是HEAD）。如果第二个对象已经有note或者第一个对象没有note，则终止。</li>
<li><code>append</code>：向一个已经存在note的对象追加note（默认HEAD）。如果不存在就创建一个note。</li>
<li><code>edit</code>：编辑给定对象的<code>notes</code>（默认HEAD）。</li>
<li><code>show</code>：展示给定对象的notes（默认HEAD）。</li>
<li><code>merge</code>：合并给定的note引用到当前的note引用。这将尝试将给定<code>notes ref</code>(称为<code>remote</code>)所做的更改合并到当前<code>notes ref</code>(称为<code>local</code>)，因为<code>merge-base</code>(如果有的话)。</li>
<li><code>remove</code>：移除给定对象的notes（默认HEAD）。当从命令行给出零个或一个对象时，这相当于向编辑子命令指定一个空的注释消息。</li>
<li><code>get-ref</code>：打印当前的notes引用。这提供了一个简单的方法来检索当前的notes引用(可用于merger子命令)。</li>
</ul>
<h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>-f; --force</code>：当向已经有notes的对象添加注释时，覆盖现有的notes(而不是中止)。</li>
<li><code>-m &lt;msg&gt;; --message=&lt;msg&gt;</code>：使用给定的注释消息(而不是<code>prompting</code>)。如果给出了多个<code>-m</code>选项，它们的值将连接成单独的段落。以#开头的行和段落之间除了一行以外的空行将被删除。</li>
<li><code>-F &lt;file&gt;; --file=&lt;file&gt;</code>：从给定的文件中获取笔记消息。以#开头的行和段落之间除了一行以外的空行将被删除。</li>
<li><code>-C &lt;object&gt;; --reedit-message=&lt;object&gt;</code>：将给定的<code>blob</code>对象(例如，另一个注释)作为注释消息。(使用<code>git notes copy &lt;object&gt;</code>代替在对象之间复制notes。)</li>
<li><code>-c &lt;object&gt;; --reedit-message=&lt;object&gt;</code>：与<code>-C</code>类似，但使用<code>-C</code>会调用编辑器，以便用户可以进一步编辑注释消息。</li>
<li><code>--allow-empty</code>：允许存储一个空的笔记对象。默认的行为是自动删除空注释。</li>
<li><code>--commit</code>：完成正在进行的git注释合并。被合并后会自动更新并提交。</li>
</ul>
<h2 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h2><p>这里现列举出以下三个命令的区别：</p>
<ul>
<li><code>reset</code></li>
<li><code>restore</code></li>
<li><code>revert</code></li>
</ul>
<p>主要区别有</p>
<ul>
<li><code>git-revert</code>：进行一个<strong>新</strong>提交（commit）来恢复其他提交所做的更改。</li>
<li><code>git-restore</code>：从索引或其他提交中<strong>恢复工作树中的文件</strong>。这个命令不会更新你的分支。该命令还可以用于从另一个提交恢复索引中的文件。</li>
<li><code>git-reset</code>：更新你的分支，移动分支的顶端，以便添加或删除分支提交。该操作将更改提交历史记录。</li>
</ul>
<p>该命令可以从一个还原源中来还原指定工作树中的特定目录或文件。如果一个路径被跟踪，但是在恢复源中不存在，那么它将被删除以匹配源。</p>
<p>该命令还可以用于：</p>
<ul>
<li><p><code>--staged</code>恢复索引中的内容，（即撤销上一次add操作）。</p>
</li>
<li><p><code>--staged --worktree</code>恢复工作树和索引（即撤销add操作并恢复文件内容）。</p>
</li>
</ul>
<p>默认情况下，如果给出<code>--staged</code>，则从HEAD恢复内容，否则从索引恢复内容。使用<code>--source</code>从不同的提交恢复。</p>
<h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>-s &lt;tree&gt;; --source=&lt;tree&gt;</code>：使用给定树中的内容恢复工作树文件。通常通过命名提交、分支或与之关联的标记来指定源树。如果没有指定，则从HEAD中恢复，否则从从给出的索引恢复。</li>
<li><code>-p; --patch</code>：交互式地根据恢复源和恢复位置之间的差异选择块。</li>
<li><code>-W; --worktree;; -S; --staged</code>：指定恢复位置。如果没有指定任何选项，默认情况下将恢复工作树。指定<code>--staging</code>只会恢复索引。两个都指定则索引和文件都会被恢复。</li>
<li><code>-q: --quiet</code>：静默，压制反馈信息。</li>
<li><code>--progress</code>：默认信息，将会报告所有信息。</li>
<li><code>-m; --merge</code>：当从索引中恢复工作树中的文件时，在未合并的路径中重新创建冲突的合并。</li>
<li><code>--overlay; --no-overlay</code>：在<code>overlay</code>模式下，该命令在恢复时永远不会删除文件。在<code>no-overlay</code>模式下，不出现在<code>--source</code>树中的跟踪文件将被删除，以使它们完全匹配<code>&lt;tree&gt;</code>。默认为无覆盖模式。</li>
</ul>
<h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a><code>reset</code></h2><p>该命令用于重置当前的HEAD到指定的状态。</p>
<p>其有以下使用格式：</p>
<h3 id="git-reset-q-lt-tree-ish-gt-lt-pathspec-gt-…；git-reset-q-pathspec-from-file-lt-file-gt-pathspec-file-nul-lt-tree-ish-gt"><a href="#git-reset-q-lt-tree-ish-gt-lt-pathspec-gt-…；git-reset-q-pathspec-from-file-lt-file-gt-pathspec-file-nul-lt-tree-ish-gt" class="headerlink" title="git reset [-q] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…；git reset [-q] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]] [&lt;tree-ish&gt;]"></a><code>git reset [-q] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…</code>；<code>git reset [-q] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]] [&lt;tree-ish&gt;]</code></h3><p>这两种格式将重置所有匹配<code>&lt;pathspec&gt;</code>的目录索引到他们在<code>&lt;tree-ish&gt;</code>的状态。(它不影响工作树或当前分支。)</p>
<p>这就意味着<code>git reset &lt;pathspec&gt;</code>与<code>git add &lt;pathspec&gt;</code>是完全相反的操作。并且这条命令也是和<code>git restore [--source=&lt;tree-ish&gt;] --staged &lt;pathspec&gt;...</code>是相等的。</p>
<p>运行<code>git reset &lt;pathspec&gt;</code>命令更新索引项后，可以使用<code>git-restore</code>命令查看工作树索引的内容。或者，使用<code>git-restore</code>并使用<code>--source</code>指定提交，您可以将提交中的路径内容一次性复制到索引和工作树中。</p>
<h3 id="git-reset-patch-p-lt-tree-ish-gt-lt-pathspec-gt-…"><a href="#git-reset-patch-p-lt-tree-ish-gt-lt-pathspec-gt-…" class="headerlink" title="git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;…]"></a><code>git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;…]</code></h3><p>交互式地选择索引和&lt;树状&gt;之间的差异的块(默认为HEAD)。所选的块以相反的方式应用于索引。</p>
<p>这意味着，<code>git reset -p</code>是与<code>git add -p</code>相反的，也就是说，你可以使用它来选择性地重置大块数据。</p>
<h3 id="git-reset-lt-mode-gt-lt-commit-gt"><a href="#git-reset-lt-mode-gt-lt-commit-gt" class="headerlink" title="git reset [&lt;mode&gt;] [&lt;commit&gt;]"></a><code>git reset [&lt;mode&gt;] [&lt;commit&gt;]</code></h3><p>这种格式将当前分支的HEAD重置为<code>&lt;head&gt;</code>并且可能更新索引（将其重置为<code>&lt;commit&gt;</code>的状态）和工作树。其工作模式依赖于<code>&lt;mode&gt;</code>参数。默认为<code>--mixed</code>。所有模式如下：</p>
<ul>
<li><code>--soft</code>：完全不碰索引文件或工作树(但将头部重置为<code>&lt;commit&gt;</code>，就像所有模式那样)。这使得所有你更改的文件都是<code>Changes to be committed</code>，就像git状态显示的那样。</li>
<li><code>--mixed</code>：重置索引，但不重置工作树(即，更改的文件保留，但不标记为提交（<code>commit</code>）)，并报告未更新的内容。这是默认操作。如果指定了<code>-N</code>，删除的路径将被标记为意图添加。</li>
<li><code>--hard</code>：重置索引和工作树。自<code>&lt;commit&gt;</code>以来对工作树中跟踪文件的任何更改都将被丢弃。任何在恢复阶段没有被追踪，而当前阶段跟踪的文件或目录被简单地删除（<strong>慎用</strong>）。</li>
<li><code>--merge</code>：重置索引并更新工作树中与<code>&lt;commit&gt;</code>和HEAD<strong>不同的文件</strong>，<strong>但保留索引和工作树中与之不同的文件(即有更改但未添加（add）的文件)。如果一个文件在<code>&lt;commit&gt;</code>和索引之间不一致，则会中止重置。</strong>换句话说，<code>--merge</code>的作用类似于<code>git read-tree -u -m &lt;commit&gt;</code>，但它会将未合并的索引项带向前。</li>
<li><code>keep</code>：重置工作树中<code>&lt;commit&gt;</code>和HEAD之间不一致的索引项，并更新文件。如果一个文件在<code>&lt;commit&gt;</code>和HEAD之间有不同的本地更改，reset将被中止。</li>
<li><code>--[no-]recurse-submodules</code>：当工作树被更新时，使用<code>--recursive -submodules</code>也会根据父项目中记录的提交，递归地重置所有活动子模块的工作树，并在提交时将子模块的HEAD设置为分离。</li>
</ul>
<h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>-q; --quiet;; --no-quiet</code>：静默/不静默（默认）。</li>
</ul>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h2><p>从索引中删除匹配<code>pathspec</code>的文件，或者从工作树和索引中删除。<code>git rm</code>不会从你的工作目录中删除文件。被删除的文件必须与分支的顶端相同，并且不能在索引中显示对其内容的更新，尽管可以使用<code>-f</code>选项重写默认行为。当给出<code>--cached</code>时，暂存的内容必须匹配分支的尖端或磁盘上的文件，从而允许仅从索引中删除文件。当使用 <code>sparse-checkouts</code> 模式时，<code>git rm</code>将只删除稀疏签出模式中的路径。</p>
<p>选项：</p>
<ul>
<li><code>&lt;pathspec&gt;…</code>：要被移除的文件。可以指定前置目录名(例如，<code>dir</code>用于删除<code>dir/file1</code>和<code>dir/file2</code>)来删除目录中的所有文件，并递归地删除所有子目录，但这需要显式地指定-r选项。该命令只删除<code>git</code>已知的路径。（也可以使用通配符*来移除）</li>
<li><code>-f; --force</code>：强制性的移除（当被删除的文件不与分支的顶端相同时也可以被移除）（慎用）。</li>
<li><code>-n; --dry-run</code>：不要实际删除任何文件。相反，只需显示它们是否存在于索引中，否则将被命令删除。</li>
<li><code>-r</code>：当给出前导目录名时，允许递归删除。</li>
<li><code>--cached</code>：此选项把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除</li>
<li><code>--ignore-unmatch</code>：即使没有匹配的文件，也将以零状态退出。</li>
</ul>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a><code>mv</code></h2><p>移动或重命名一个文件、目录或符号链接。</p>
<p>格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git mv [-v] [-f] [-n] [-k] &lt;<span class="built_in">source</span>&gt; &lt;destination&gt;</span><br><span class="line">git mv [-v] [-f] [-n] [-k] &lt;<span class="built_in">source</span>&gt; ... &lt;destination directory&gt;</span><br></pre></td></tr></table></figure>
<p>在第一种形式中，它将<code>&lt;source&gt;</code>重命名为<code>&lt;destination&gt;</code>，它必须存在并且是一个文件、符号链接或目录。</p>
<p>在第二种形式中，最后一个参数必须是一个已存在的目录;给定的源代码将被移动到这个目录中。</p>
<p>索引在成功完成后更新，但更改仍然必须提交。</p>
<h3 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>f; --force</code>：强制重命名或移动文件，即使目标存在。</li>
<li><code>-k</code>：跳过移动或重命名操作，这将可能导致错误情况。当源文件既不存在也不受git控制时，或者除非指定<code>-f</code>，否则它将覆盖现有文件时，就会发生错误。</li>
<li><code>-v; --verbose</code>：在移动文件时报告文件的名称。</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>基本快照</tag>
      </tags>
  </entry>
  <entry>
    <title>git常见场景与冲突处理</title>
    <url>/2022/03/27/git%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><h2 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h2><h3 id="确认暂存区"><a href="#确认暂存区" class="headerlink" title="确认暂存区"></a>确认暂存区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 增加所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line">// 增加指定文件到暂存区</span><br><span class="line">$ git add [filename]</span><br></pre></td></tr></table></figure>
<h3 id="撤销暂存区"><a href="#撤销暂存区" class="headerlink" title="撤销暂存区"></a>撤销暂存区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 取消所有最新的暂存区文件</span><br><span class="line">$ git reset HEAD .</span><br><span class="line"></span><br><span class="line">// 取消缓存区最新的指定文件</span><br><span class="line">$ git reset HEAD REAMDME.md</span><br></pre></td></tr></table></figure>
<p>注意该命令的参数HEAD是要被恢复的版本, 一般选择HEAD, 即恢复到最新的HEAD。</p>
<p>下面撤销commit也使用该命令。</p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="确认提交"><a href="#确认提交" class="headerlink" title="确认提交"></a>确认提交</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进行一次提交并附加消息<span class="string">'message'</span></span><br><span class="line">$ git commit -m <span class="string">'message'</span></span><br></pre></td></tr></table></figure>
<h3 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h3><h4 id="git-revet"><a href="#git-revet" class="headerlink" title="git revet"></a><code>git revet</code></h4><p><code>git revert</code>进行一个<strong>新</strong>提交（commit）来恢复其他提交所做的更改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git revert HEAD                  撤销前一次 commit</span><br><span class="line">$ git revert HEAD^               撤销前前一次 commit</span><br><span class="line">$ git revert commit （比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。</span><br></pre></td></tr></table></figure>
<h4 id="git-reset-version"><a href="#git-reset-version" class="headerlink" title="git reset [version]"></a>git reset [version]</h4><p>该命令会将头部指到指定的版本位置。</p>
<p>例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD^            <span class="comment"># 回退所有内容到上一个版本  </span></span><br><span class="line">$ git reset HEAD^ hello.php  <span class="comment"># 回退 hello.php 文件的版本到上一个版本  </span></span><br><span class="line">$ git  reset  052e           <span class="comment"># 回退到指定版本</span></span><br></pre></td></tr></table></figure>
<p>–hard会强制删除之前所有的信息提交. 慎用.</p>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset –hard HEAD~3  <span class="comment"># 回退上上上一个版本  </span></span><br><span class="line">$ git reset –hard bae128  <span class="comment"># 回退到某个版本回退点之前的所有信息。 </span></span><br><span class="line">$ git reset --hard origin/master    <span class="comment"># 将本地的状态回退到和远程的一样</span></span><br></pre></td></tr></table></figure>
<p>但是仍然可以恢复.</p>
<blockquote>
<p>git log -g 全局找到我们 commit 1 ID<br>git branch recover_bracch commit 1, 创建一个新的分支，<br>git merge recover_bracch 然后合并回来，</p>
</blockquote>
<h4 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a><code>git restore</code></h4><p><code>git restore</code><strong>是用来将工作区的文件恢复到上一次暂存区的数据。</strong></p>
<h3 id="修改错误的提交"><a href="#修改错误的提交" class="headerlink" title="修改错误的提交"></a>修改错误的提交</h3><p>这种情况可能是提交的文件错误或者message写错了.</p>
<p>此时可以使用<code>git commit --amend</code>来修改.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p>接下来会弹出文本编辑器来修改对应信息, 不同系统不同,可以设置.</p>
<p>其信息大致如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new repaired message</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Mon Mar 28 21:37:11 2022 +0800</span><br><span class="line">#</span><br><span class="line"># On branch main</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#	new file:   a.txt</span><br><span class="line">#	deleted:    &quot;\346\226\260\345\273\272\346\226\207\346\234\254\346\226\207\346\241\243 (2).txt&quot;</span><br><span class="line">#</span><br><span class="line"># Untracked files:</span><br><span class="line">#	a</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>第一行就是message, 后面还包含新增或删除的文件</p>
<h3 id="切换到制定提交位置"><a href="#切换到制定提交位置" class="headerlink" title="切换到制定提交位置"></a>切换到制定提交位置</h3><p>移动HEAD, 一般使用<code>checkout</code>命令.</p>
<p>格式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout &lt;SHA-1&gt;</span><br><span class="line">$ git checkout HEAD[^/~&lt;num&gt;/^&lt;num&gt;]</span><br><span class="line">$ git checkout 分支[^/~&lt;num&gt;/^&lt;num&gt;]</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout ea321		// 切换到ea321版本</span><br><span class="line">$ git checkout HEAD^		// 切换到上一个HEAD位置</span><br><span class="line">$ git checkout develop~3	// 切换到develop分支的前三个分支上</span><br></pre></td></tr></table></figure>
<h3 id="提交合并"><a href="#提交合并" class="headerlink" title="提交合并"></a>提交合并</h3><p>使用<code>git rebase</code>命令可以合并commit.</p>
<p>格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase -i  [startpoint]  [endpoint]</span><br></pre></td></tr></table></figure>
<p><code>[startpoint]</code> <code>[endpoint]</code>则指定了一个编辑区间，如果不指定<code>[endpoint]</code>，则该区间的终点默认是当前分支<code>HEAD</code>所指向的<code>commit</code>(注：该区间指定的是一个前开后闭的区间)。</p>
<p>比如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 效果一致</span><br><span class="line">$ git rebase -i HEAD HEAD~3</span><br><span class="line">$ git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>
<p>然后会弹出编辑器.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick b4d576b add b.phppick 90bc004 add c.php</span><br><span class="line">pick 45edfda add d.php</span><br><span class="line">#Rebase 36224db..45edfda onto 36224db (3 command(s))#</span><br><span class="line"># Commands:</span><br><span class="line">#p, pick &#x3D; use commit</span><br><span class="line">#r, reword &#x3D; use commit, but edit the commit message#e, edit &#x3D; use commit,but stop for amending</span><br><span class="line">#s, squash &#x3D; use commit, but meld into previous commit</span><br><span class="line"># f，fixup&#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message#x,exec &#x3D; run command (the rest of the line)using shell</span><br><span class="line"># d,drop &#x3D; remove commit</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line"># However, if you remove everything,the rebase will be aborted.#</span><br><span class="line">#Note that empty commits are commented out</span><br></pre></td></tr></table></figure>
<p>然后根据命令修改.</p>
<p>接下来还需要reset一下,才能完rebase.</p>
<h4 id="不同分支合并"><a href="#不同分支合并" class="headerlink" title="不同分支合并"></a>不同分支合并</h4><p>还可以将不同的分支合并到到一起,比如将develop分支的前3个提交合并到master上.</p>
<p>使用以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  git rebase  [startpoint]   [endpoint]  --onto  [branchName]</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  git rebase  ab123   ab124  --onto  master</span><br><span class="line">$  git rebase  HEAD~3  --onto  master</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库同步"><a href="#远程仓库同步" class="headerlink" title="远程仓库同步"></a>远程仓库同步</h2><h3 id="设置远程仓库"><a href="#设置远程仓库" class="headerlink" title="设置远程仓库"></a>设置远程仓库</h3><p>可以通过<code>git remote</code>或者通过<code>git branch</code>命令来配置远程仓库。</p>
<p>格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add [name] [url]</span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to = &lt;upstream&gt;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 新增远程仓库</span><br><span class="line">$ git remote add dev https://github.com/vuejs/core.git</span><br><span class="line"></span><br><span class="line">// 为当前分支增加上游</span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to = https://github.com/vuejs/core.git</span><br></pre></td></tr></table></figure>
<h3 id="确认推送"><a href="#确认推送" class="headerlink" title="确认推送"></a>确认推送</h3><p>使用<code>git push</code>命令可以使用本地引用更新远程引用，同时发送完成给定引用所必需的对象。</p>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 如果配置了远程仓库，则直接git push</span><br><span class="line">$ git push</span><br><span class="line"></span><br><span class="line">// 将匹配得分支推送到远程的origin仓库</span><br><span class="line">$ git push origin</span><br><span class="line"></span><br><span class="line">// 将匹配得分支推送到远程的origin仓库master分支</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="撤销推送"><a href="#撤销推送" class="headerlink" title="撤销推送"></a>撤销推送</h3><ol>
<li>本地回退版本</li>
</ol>
<p>先使用<code>git reset</code>回退版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --soft  aa909cff2239536df14820fe086d96305b24e9f1</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过强制push，将旧版本推送到远程仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master --force</span><br></pre></td></tr></table></figure>
<p>注意必须添加<code>--force</code>，因为版本是落后的。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="新增分支"><a href="#新增分支" class="headerlink" title="新增分支"></a>新增分支</h3><p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 切换到newBranch分支，如果不存在则创建后再求切换</span><br><span class="line">$ git branch newBranch</span><br><span class="line"></span><br><span class="line">// 切换到newBranch分支，如果不存在则创建后再求切换</span><br><span class="line">$ git checkout newBranch</span><br></pre></td></tr></table></figure>
<p><code>branch</code>，<code>switch</code>命令本就是为了减轻<code>checkout</code>命令而生，所以方法基本一致。</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>同样的可以使用<code>git branch</code>来删除分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 删除本地分支</span><br><span class="line">$ git branch -d dev1</span><br><span class="line"></span><br><span class="line">// 删除一个正打开的分支</span><br><span class="line">$ git branch -D dev1</span><br></pre></td></tr></table></figure>
<h3 id="恢复分支"><a href="#恢复分支" class="headerlink" title="恢复分支"></a>恢复分支</h3><p>格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch &lt;branch_name&gt; &lt;hash_val&gt;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch dev1 123d</span><br></pre></td></tr></table></figure>
<p>Git会自行负责分支的管理，所以当我们删除一个分支时，Git只是删除了指向相关提交的指针，但该提交对象依然会留在版本库中。</p>
<p>因此，如果我们知道删除分支时的散列值，就可以将某个删除的分支恢复过来。在已知提交的散列值的情况下恢复某个分支。</p>
<p>可以通过查看本地文件的log文件或者<code>reflog</code>命令来查找。</p>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>通过<code>git merge</code>命令，可以将分支合并到一起。</p>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 假设当前在matser，且落后dev1一个版本</span><br><span class="line">$ git merger dev</span><br></pre></td></tr></table></figure>
<p>注意这里还有<code>fast-forward</code>和<code>--no-ff</code>的区别，</p>
<ul>
<li><code>fast-forward</code>即直接移动当前分支的头指针到对应的合并位置。条件是两个分支不存在冲突。</li>
<li><code>--no-ff</code>是新建一个提交，然后将merger两个位置的下一次都指向这个新的提交。</li>
</ul>
<blockquote>
<p>如果条件满足时，merge 默认采用的 <code>fast-forward</code> 方式进行合并，除非你显示的加上 <code>--no-ff</code> 选项；而条件不满足时，merge 也是无法使用 <code>fast-forward</code> 合并成功的！</p>
</blockquote>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><p>正如前面介绍的, <code>git rebase</code>实际上也可以做类似的工作。<code>git rebase</code>可以将对应分支的基（即出发位置）合并到当前分支。（或者自己指定两个分支）。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 假设当前在matser，且落后dev两个版本</span><br><span class="line">$ git rebase dev</span><br><span class="line">// 或者 git rebase master dev</span><br></pre></td></tr></table></figure>
<p>则dev的指针指向了master的分支上，如下图：</p>
<p><img src="D:\myblog\source\images\git\rebase.png" alt="rebase"></p>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p>暂存一个不需要立即操作的文件树版本，将版本恢复到上一个commit。</p>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 缓存一个版本</span><br><span class="line">$ git stash push -m <span class="string">'第一个版本'</span></span><br><span class="line"></span><br><span class="line">// 从stash列表中移除单个stash状态，并将其应用到当前工作树状态的顶部。当发生冲突的时候，该命令会失败，但该stash不会从stash列表中移除。此时可以手动解决冲突，然后使用git stash drop来移除。</span><br><span class="line">$ git stash pop</span><br><span class="line"></span><br><span class="line">// 使用一个stash状态，但不会将其从stash列表中移除</span><br><span class="line">$ git stash appy</span><br><span class="line"></span><br><span class="line">// 显示所有的stash记录</span><br><span class="line">$ git stash list</span><br><span class="line"></span><br><span class="line">// 展示在stash中的记录和当前文件内容的不同</span><br><span class="line">$ git stash show</span><br></pre></td></tr></table></figure>
<h1 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h1><h2 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h2><p>首先应当是避免冲突，每个人应该负责不同的模块，然后只修改对应的文件。过多的冲突应当是分工存在问题。</p>
<h2 id="经常commit"><a href="#经常commit" class="headerlink" title="经常commit"></a>经常commit</h2><p>减少冲突的另一个方面是经常push，将自己的代码提交到仓库，尽量避免一次提交过多的文件。其次应当保证commit的原子性，即一个commit只做一件事情。</p>
<h2 id="写代码之前同步"><a href="#写代码之前同步" class="headerlink" title="写代码之前同步"></a>写代码之前同步</h2><p>在写代码之前，先pull一下，保证自己本地的代码已经同步了远程仓库，以减少可能发生的冲突。</p>
<h2 id="手动处理"><a href="#手动处理" class="headerlink" title="手动处理"></a>手动处理</h2><p>当前git已经很智能，只要存在冲突，就无法提交，或者merge。并且git会提示那些文件存在冲突，然后在文件中通过一定格式来标记，来让我们手动处理冲突。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">士大夫第卅方4时5撒发射点发生</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">发士大夫的-这是另外的冲突</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">发士大夫的-deawdaewea冲突</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;&lt;&lt;</code> 到 <code>|||</code> 显示的是当前 master 分支上修改后的内容</li>
<li><code>|||</code> 到 <code>----</code> 向您显示 master 分支与 dev 分支修改前共同的内容是什么</li>
<li><code>---</code> 到 <code>&gt;&gt;&gt;</code> 显示的是 dev 分支上修改后的内容，也就是要合并分支的内容</li>
<li><code>=======</code>用于分割不同的冲突点。</li>
</ul>
<p>此时我们只需要删除不需要的代码（包括git的提示信息），然后<strong>将修改添加到暂存区，并进行提交更改。</strong></p>
<p>最后再次进行提交或合并即可。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>冲突处理</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习3-分支与合并</title>
    <url>/2022/02/27/git%E5%AD%A6%E4%B9%A03-%E5%88%86%E6%94%AF%E4%B8%8E%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h1><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a><code>branch</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch [--color[=&lt;when&gt;] | --no-color] [--show-current]</span><br><span class="line">	[-v [--abbrev=&lt;n&gt; | --no-abbrev]]</span><br><span class="line">	[--column[=&lt;options&gt;] | --no-column] [--sort=&lt;key&gt;]</span><br><span class="line">	[--merged [&lt;commit&gt;]] [--no-merged [&lt;commit&gt;]]</span><br><span class="line">	[--contains [&lt;commit&gt;]] [--no-contains [&lt;commit&gt;]]</span><br><span class="line">	[--points-at &lt;object&gt;] [--format=&lt;format&gt;]</span><br><span class="line">	[(-r | --remotes) | (-a | --all)]</span><br><span class="line">	[--list] [&lt;pattern&gt;…]</span><br><span class="line">git branch [--track[=(direct|inherit)] | --no-track] [-f] &lt;branchname&gt; [&lt;start-point&gt;]</span><br><span class="line">git branch (--<span class="built_in">set</span>-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]</span><br><span class="line">git branch --<span class="built_in">unset</span>-upstream [&lt;branchname&gt;]</span><br><span class="line">git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br><span class="line">git branch (-c | -C) [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br><span class="line">git branch (-d | -D) [-r] &lt;branchname&gt;…</span><br><span class="line">git branch --edit-description [&lt;branchname&gt;]</span><br></pre></td></tr></table></figure>
<p><code>branch</code>用于列出、创建或者删除分支。</p>
<p>如果只给出了<code>--list</code>，则列出所有的分支。当前的分支将以绿色高亮显示，并用星号标记。在链接的工作树中签出的任何分支都将以青色突出显示，并用加号标记。</p>
<p>选项<code>-r</code>将列出远程跟踪分支，选项<code>-a</code>将同时显示本地和远程分支。</p>
<p>可以用通过添加<code>&lt;pattern&gt;</code>来筛选符合该模式的分支。（要使用<code>&lt;patterin&gt;</code>，则必须使用<code>--list</code>）。</p>
<p>使用<code>--contains</code>则表示仅显示那些包含<code>&lt;commit&gt;</code>的分支（<code>&lt;commit&gt;</code>的后代）。<code>--no-contains</code> 与其相反，即不包含。</p>
<p>使用<code>--mergerd</code>则表示仅显示那些合并到<code>&lt;commit&gt;</code>的分支。<code>--no-merged</code>相反，即没有合并到<code>&lt;commit&gt;</code>的分支。</p>
<p>第二种形式将创建一个新的名叫<code>&lt;branchname&gt;</code>的分支，其指向当前的HEAD，如果给出<code>&lt;start-point&gt;</code>，则指向给定的位置。一种特殊情况是，可以使用<code>A...B</code>来表示<code>A</code>和<code>B</code>合并的基点的快捷写法（A和B存在一个合并基点）。</p>
<p>注意这种形式会创建一个新的分支，但不会切换到它，可以使用<code>git switch &lt;newBranch&gt;</code>来切换到对应的分支。</p>
<p>一旦一个本地分支是从一个远程追踪分支启动的，那么Git就会自动配置该分支（主要是<code>branch.&lt;name&gt;.remote</code>和<code>branch.&lt;name&gt;.merge</code>配置对），以便后面<code>git pull</code>可以从<code>remote-tracking</code>分支适当地合并。</p>
<p>这个设置可以通过使用<code>--track</code>和<code>--no-track</code>选项来覆盖，或者使用<code>git branch --set-upstream-to</code>来更改。</p>
<p>使用<code>-m</code>或<code>-M</code>（<code>move</code>）选项，<code>&lt;oldbranch&gt;</code>将被重命名为<code>&lt;newbranch&gt;</code>。如果<code>&lt;oldbranch&gt;</code>有一个相应的<code>reflog</code>，它将被重命名以匹配<code>&lt;newbranch&gt;</code>，并且创建一个<code>reflog</code>条目来记住分支的重命名。如果存在<code>&lt;newbranch&gt;</code>，则必须使用<code>-M</code>来强制执行重命名。 </p>
<p><code>-c</code>和<code>-C</code>（<code>copy</code>）选项具有与<code>-m</code>和<code>-M</code>完全相同的语义，只是分支不会被重命名，而是会被复制到一个新名称，连同它的<code>config</code>和<code>reflog</code>。</p>
<p>使用<code>-d</code>或<code>-D</code>选项，<code>&lt;branchname&gt;</code>将被删除。您可以指定多个用于删除的分支。如果分支当前有一个<code>reflog</code>，那么这个<code>reflog</code>也将被删除。</p>
<p>使用<code>-r</code>和<code>-d</code>来删除远程跟踪分支（注意不是删除远程仓库本身，而是删除跟踪）。注意，只有当远程跟踪分支不再存在于远程存储库中时，或者当<code>git fetch</code>被配置为不再获取它们时，才有意义删除它们。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>-d; --delete</code>：删除一个分支。该分支必须在其上游分支中完全合并，或者在<code>HEAD</code>中(如果没有使用<code>--track</code>或<code>--set-upstream-to</code>设置upstream)。</li>
<li><code>-D</code>：<code>--delete --force</code>的简写。</li>
<li><code>--create-reflog</code>：创建分支的<code>reflog</code>。这激活了对分支<code>ref</code>所做的所有更改的记录，允许使用基于日期的<code>sha1</code>表达式，如<code>&lt;branchname&gt;@{yesterday}</code>。</li>
<li><code>-f; --force</code>：将<code>&lt;branchname&gt;</code>重置为<code>&lt;startpoint&gt;</code>，即使<code>&lt;branchname&gt;</code>已经存在。如果没有<code>-f</code>, <code>git branch</code>拒绝改变一个已经存在的分支。与<code>-d</code>(或<code>--delete</code>)组合，允许删除分支，而不管它的合并状态，或者它是否指向一个有效的提交。与<code>-m</code>(或<code>--move</code>)组合，允许重命名分支，即使新的分支名称已经存在，同样适用于<code>-c</code>(或<code>--copy</code>)。</li>
<li><code>-m; --move</code>：移动/重命名一个分支，以及它的配置和<code>reflog</code>。</li>
<li><code>-M</code>：<code>--move --force</code>的简写。</li>
<li><code>-c; --copy</code>：复制一个分支，连同它的配置和<code>reflog</code>。</li>
<li><code>-C</code>：<code>--copy --force</code>的简写。</li>
<li><code>--color[=&lt;when&gt;]</code>：为分支设置颜色，以突出显示当前、本地和远程跟踪分支。该值必须为always(默认值)、never或auto。</li>
<li><code>--no-color</code>：关闭分支颜色，即使配置文件给出了默认的颜色输出。<code>--color=never</code>。</li>
<li><code>-i; --ignore-case</code>：排序和过滤分支不区分大小写。</li>
<li><code>--column[=&lt;options&gt;]; --no-column</code>：以列（不以列）显示分支列表。</li>
<li><code>r; --remotes</code>：列出或删除(如果与<code>-d</code>一起使用)远程跟踪分支。结合<code>--list</code>来匹配可选的模式。</li>
<li><code>-a; --all</code>：同时列出远程跟踪分支和本地分支。结合<code>--list</code>来匹配可选的模式。</li>
<li><code>-l; --list</code>：列出分支。带有可选<code>&lt;pattern&gt;</code>，例如，<code>git branch --list &#39;maint-*</code>，只列出匹配模式的分支。</li>
<li><code>--show-current</code>：打印当前分支的名称。在分离的HEAD状态下，不打印任何东西。</li>
<li><code>-t; --track</code>：当创建一个新的分支时，设置<code>branch.&lt;name&gt;.remote</code>和<code>branch.&lt;name&gt;.merge</code>以设置新分支的”upstream”跟踪配置。配置会告诉git以<code>git status</code>和<code>git branch -v</code>显示两个分支之间的关系。此外，当新分支被指出时，它可以不带参数地执行<code>git pull</code>操作。</li>
<li><code>--no-track</code>：不设置”upstream”配置，即使分支。设置<code>auto.SetupMerge</code>配置变量。</li>
<li><code>-u &lt;upstream&gt;; --set-upstream-to=&lt;upstream&gt;</code>：设置<code>&lt;branchname&gt;</code>的跟踪信息，使<code>&lt;upstream&gt;</code>被认为是<code>&lt;branchname&gt;</code>的上游分支。如果没有指定<code>&lt;branchname&gt;</code>，则默认为当前分支。</li>
<li><code>--edit-description</code>：打开一个编辑器并编辑文本，以解释分支的用途，以及各种其他命令所使用的功能。可以使用多行解释。</li>
<li><code>contains [commit]</code>：仅列出包含指定提交的分支(如未指定则为HEAD)。</li>
<li><code>--no-contains [&lt;commit&gt;]</code>：只列出不包含指定提交的分支(如果没有指定，则为HEAD)。</li>
<li><code>--merged [&lt;commit&gt;]</code>：仅列出从指定的提交(如果没有指定为HEAD)中可获得提示的分支。</li>
<li><code>--no-merged [&lt;commit&gt;]</code>：仅列出从指定的提交(如果没有指定为HEAD)中无法获得提示的分支。</li>
<li><code>&lt;branchname&gt;</code>：要创建或删除的分支的名称。</li>
<li><code>&lt;start-point&gt;</code>：新的分支头将指向这个提交。它可以是一个分支名、一个<code>commit-id</code>或者一个标签。如果这个选项被省略，则将使用当前的HEAD。</li>
<li><code>&lt;oldbranch&gt;</code>：要重命名的现有分支的名称。</li>
<li><code>&lt;newbranch&gt;</code>：现有分支的新名称。应用与<code>&lt;branchname&gt;</code>相同的限制。</li>
<li><code>--sort=&lt;key&gt;</code>：根据给定的键进行排序。前缀-按值的降序排序。您可以多次使用<code>--sort=&lt;key&gt;</code>选项，在这种情况下，最后一个键成为主键。</li>
<li><code>--points-at &lt;object&gt;</code>：只列出给定对象的分支。</li>
</ul>
<p>值得注意的是：如果关联的远程分支与本地分支名字不一样，那么<code>git push</code>时git会提醒<code>fatal: The upstream branch of yourcurrent branch does not matchthe name of your current branch.</code>然后回给出其他更复杂的提交方式，最好还是把名字统一为一样。</p>
<h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><blockquote>
<p>git checkout 这个命令承担了太多职责，既被用来切换分支，又被用来恢复工作区文件，对用户造成了很大的认知负担。</p>
<p>Git社区发布了Git的新版本2.23。在该版本中，有一个特性非常引人瞩目，就是新版本的Git引入了两个新命令 git switch 和 git restore，用以替代现在的 git checkout。换言之，git checkout 将逐渐退出历史舞台。</p>
<p>Git社区决定这样做，是因为目前 git checkout 命令承载了太多的功能，这让新手们感到困惑。git checkout 的核心功能包括两个方面，一个是分支的管理，一个是文件的恢复。这两个核心功能，未来将由 git switch 和 git restore 分别负责。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout [-q] [-f] [-m] [&lt;branch&gt;]</span><br><span class="line">git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;]</span><br><span class="line">git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt;</span><br><span class="line">git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new-branch&gt;] [&lt;start-point&gt;]</span><br><span class="line">git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…</span><br><span class="line">git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] --pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]</span><br><span class="line">git checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;…]</span><br></pre></td></tr></table></figure>
<p>更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出<code>pathspec</code>, <code>git checkout</code>也会更新HEAD，将指定的分支设置为当前分支。</p>
<h3 id="git-checkout-lt-branch-gt"><a href="#git-checkout-lt-branch-gt" class="headerlink" title="git checkout  [&lt;branch&gt;]"></a><code>git checkout  [&lt;branch&gt;]</code></h3><p>切换分支到到<code>&lt;branch&gt;</code>。</p>
<h3 id="git-checkout-b-B-lt-new-branch-gt-lt-start-point-gt"><a href="#git-checkout-b-B-lt-new-branch-gt-lt-start-point-gt" class="headerlink" title="git checkout -b|-B &lt;new-branch&gt; [&lt;start-point&gt;]"></a><code>git checkout -b|-B &lt;new-branch&gt; [&lt;start-point&gt;]</code></h3><p>指定<code>-b</code>会导致创建一个新分支，就好像调用了<code>git-branch</code>，然后切换到它。并且可以指出新分支的起始点<code>&lt;start-point&gt;</code></p>
<p>如果指定<code>-B</code>，那么如果<code>&lt;new-branch&gt;</code>不存在则创建，<strong>否则就重置该分支</strong>。这相当于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -f &lt;branch&gt; [&lt;start-point&gt;]</span><br><span class="line">$ git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="git-checkout-detach-lt-branch-gt-；git-checkout-detach-lt-commit-gt"><a href="#git-checkout-detach-lt-branch-gt-；git-checkout-detach-lt-commit-gt" class="headerlink" title="git checkout  --detach [&lt;branch&gt;]；git checkout [--detach] &lt;commit&gt;"></a><code>git checkout  --detach [&lt;branch&gt;]；git checkout [--detach] &lt;commit&gt;</code></h3><p>将HEAD指向<code>&lt;commit&gt;</code>，如果提供的是<code>&lt;branch&gt;</code>，则将HEAD切换到<code>&lt;branch&gt;</code>的最新<code>commit</code>。同时更新工作树中的索引和文件。工作树中文件的本地修改将被保留，因此最终的工作树将是提交中记录的状态加上本地修改。</p>
<p>省略<code>&lt;branch&gt;</code>将会将HEAD切换到当前分支的顶端。</p>
<h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p><code>-f; --force</code>：当切换分支时，即使索引或工作树与HEAD不同，即使在切换过程中存在未跟踪的文件，也要继续进行。这用于丢弃本地更改和任何未跟踪的文件或目录。</p>
</li>
<li><p><code>--ours; --theirs</code>：当发生冲突的时候，决定是从<code>#2 (ours) or #3 (theirs)</code>中的哪一个。注意在使用<code>git rebase</code>和<code>git pull --rebase</code>时，ours和theirs可能会交换。<code>--ours</code>是选择保留本地代码。<code>--theirs</code>是选择保留合并分支代码。</p>
</li>
<li><p><code>-b &lt;new-branch&gt;</code>：创建一个名为<code>&lt;new-branch&gt;</code>的新分支，并在<code>&lt;start-point&gt;</code>处启动它。</p>
</li>
<li><p><code>-B &lt;new-branch&gt;</code>：创建分支<code>&lt;new-branch&gt;</code>，并在<code>&lt;start-point&gt;</code>处启动它;如果它已经存在，则将其重置为<code>&lt;start-point&gt;</code>。这相当于运行<code>git branch</code> with <code>-f</code>。</p>
</li>
<li><p><code>-t; --track</code>：当创建一个新的分支时，设置<code>upstream</code>配置。</p>
</li>
<li><p><code>--bo-track</code>：不要设置“upstream”配置，即使分支。<code>autoSetupMerge</code>配置变量为true。</p>
</li>
<li><p><code>--guess; --no-guess</code>：如果没有找到<code>&lt;branch&gt;</code>，但是在一个远程(调用它<code>&lt;remote&gt;</code>)中确实存在一个跟踪分支，并具有匹配的名称。其与下面语句一样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>如果分支存在于多个远程中，并且其中一个分支由<code>checkout.defaultRemote</code>配置变量命名，我们将使用该分支来消除歧异，即使<code>&lt;branch&gt;</code>在所有远程中不是唯一的。</p>
<p><code>--guess</code>是默认行为。用<code>--no-guess</code>来禁用它。</p>
</li>
<li><p><code>-l</code>：创建新分支的<code>reflog</code>;</p>
</li>
<li><p><code>-d; --detach</code>：切换到一个commit用来检查或者可放弃的实验（而不是切换到一个分支），当<code>&lt;commit&gt;</code>不是分支名时，<code>git checkout &lt;commit&gt;</code>的默认行为。</p>
</li>
<li><p><code>--orphan &lt;new-branch&gt; [&lt;start-point&gt;]</code>：创建一个新的孤立分支，命名为<code>&lt;new-branch&gt;</code>，从<code>&lt;start-point&gt;</code>开始，并切换到它。<strong>在这个新分支上进行的第一次提交将没有父节点，它将是一个新历史的根节点，与所有其他分支完全断开连接并进行提交。</strong></p>
<p>索引和工作树将被调整，就像以前运行过<code>git checkout &lt;start-point&gt;</code>一样。这允许开始一个新的历史记录，记录一组类似于<code>&lt;start-point&gt;</code>的路径，通过简单地运行git commit -a来进行根提交。</p>
</li>
<li><p><code>-m; --merge</code>：在切换分支时，如果您对当前分支和要切换的分支之间的一个或多个文件进行了本地修改，则该命令将拒绝切换分支，以便在上下文中保留您的修改。但是，使用这个选项，当前分支、工作树内容和新分支之间的三方合并就完成了，您将位于新分支上。当合并冲突发生时，冲突路径的索引条目将保持未合并状态，您需要解决冲突并使用<code>git add</code>标记已解决的路径。</p>
</li>
<li><p><code>--overwrite-ignore; --no-overwrite-ignore</code>：切换分支时，静默地覆盖被忽略的文件，这是默认行为。当新分支包含被忽略的文件时，使用<code>--no-overwrite-ignore</code>中止操作。</p>
</li>
<li><p><code>&lt;branch&gt;</code>：要切换得到分支。</p>
</li>
<li><p><code>&lt;new-branch&gt;</code>：新建分支的名字。</p>
</li>
<li><p><code>&lt;start-point&gt;</code>：用于启动新分支的提交的名称，默认是<code>HEAD</code>。</p>
</li>
<li><p><code>&lt;tree-ish&gt;</code>：被切换的树。如果没有指定，默认指定索引。</p>
</li>
</ul>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch [&lt;options&gt;] [--no-guess] &lt;branch&gt;</span><br><span class="line">git switch [&lt;options&gt;] --detach [&lt;start-point&gt;]</span><br><span class="line">git switch [&lt;options&gt;] (-c|-C) &lt;new-branch&gt; [&lt;start-point&gt;]</span><br><span class="line">git switch [&lt;options&gt;] --orphan &lt;new-branch&gt;</span><br></pre></td></tr></table></figure>
<p>切换到特定分支。工作树和索引也会更新。</p>
<p>注意，当使用<code>git switch branchName</code>时，如果<code>branchName</code>不存在，则自动创建一个新的分支然后切换到该分支（行为与<code>checkout</code>一致）。</p>
<p>可以通过添加<code>-c</code>，<code>-C</code>，自动的从一个远程仓库的同名分支创建一个新的分支。或者使用<code>--detach</code>来从一个分支分离出工作树，然后切换到该分支。</p>
<p>交换分支不需要干净的索引和工作树，也就是说允许存在未索引和未提交的文件。但是如果操作将导致本地变更的丢失，则会打断操作。（使用<code>--discard-changes</code>或者<code>--merge</code>可以用来在这种情况下抛弃改变或者合并）</p>
<h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p><code>&lt;branch&gt;</code>：要切换到的分支。</p>
</li>
<li><p><code>&lt;new-branch&gt;</code>：新分支的名字。</p>
</li>
<li><p><code>&lt;start-point&gt;</code>：新分支的起始点。指定<code>&lt;start-point&gt;</code>允许根据历史上的其他点(而不是HEAD当前点)创建一个分支。</p>
</li>
<li><p><code>-c &lt;new-branch&gt;; --create &lt;new-branch&gt;</code>：在切换到分支之前，从<code>&lt;start-point&gt;</code>开始创建一个名为<code>&lt;new-branch&gt;</code>的新分支。下面两种写法是相同的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch &lt;new-branch&gt;</span><br><span class="line">$ git switch &lt;new-branch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-C &lt;new-branch&gt;; --force-create &lt;new-branch&gt;</code>：类似于<code>--create</code>，只是如果<code>&lt;new-branch&gt;</code>已经存在，它将被重置为<code>&lt;start-point&gt;</code>。下面两种写法是相同的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -f &lt;new-branch&gt;</span><br><span class="line">$ git switch &lt;new-branch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-d; -detach</code>：切换到一个commit点，以进行检查或者可放弃的实验。</p>
</li>
<li><p><code>--guess; --no-guess</code>：如果没有找到<code>&lt;branch&gt;</code>，但在一个具有匹配名称的远程(称为<code>&lt;remote&gt;</code>)中确实存在一个跟踪分支，则将其视为等效的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch -c &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>即如果本地不存在<code>&lt;branch&gt;</code>，但在远程分支中存在同名的分支，则直接将其<code>clone</code>到本地，并且将其<code>upstream</code>设置为远程分支。</p>
<p>如果分支存在于多个远程仓库中，并且其中一个分支由<code>checkout.defaultRemote</code>配置变量命名，我们将使用该分支来消除歧异，即使<code>&lt;branch&gt;</code>在所有远程中不是唯一的。</p>
</li>
<li><p><code>-f; --force</code>：–discard-changes`的别名。</p>
</li>
<li><code>--discard-changes</code>：即使索引或工作树与HEAD不同，也要继续执行命令。索引和工作树都被恢复以匹配交换目标。如果指定了<code>--recursed -submodules</code>，子模块内容也会被恢复以匹配切换目标。这个操作用于丢弃本地的变更。</li>
<li><code>-m; --merge</code>：如果有一个或多个文件在当前分支和要切换到的分支不同。<code>switch</code>命令将会终止，但是加上了<code>--merge</code>后，被当前分支将会合到将要被切换的分支，您将位于新分支上。</li>
<li><code>-t; --track [direct | inheret]</code>：当创建一个新的分支时，设置“upstream”配置。</li>
<li><code>--orphan &lt;new-branch&gt;</code>：创建一个新的孤立分支，名为<code>&lt;new-branch&gt;</code>。所有跟踪文件都将被被删除。</li>
<li><code>--ignore-other-worktrees</code>：当需要的ref已经被另一个工作树检出时，<code>git switch</code>将会拒绝执行。这个选项可以强行使其签出到该ref上。换句话说，ref可以被多个工作树持有。</li>
<li><code>--recurse-submodules; --no-recurse-submodules</code>：使用<code>--recurse-submodules</code>将根据<code>superproject</code>中记录的提交更新所有活动子模块的内容。如果什么都没有使用(或者<code>--no- recursive -submodules</code>)，子模块工作树将不会被更新。就像git-submodule[1]一样，这将分离子模块的HEAD。</li>
</ul>
<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>用于展示commit日志。</p>
<p>该命令从给出的提交通过<code>parent</code>链列出所有可达的commit，并且不包含那些以<code>^</code>开头的可达的commits。在默认情况下,输出以反向时间顺序给出。</p>
<p>比如，以下的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> foo bar ^baz</span><br></pre></td></tr></table></figure>
<p>意味着-列出所有从foo或bar可到达，但从baz不能到达的提交。</p>
<h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>--follow</code>：继续列出重命名以外的文件历史记录(仅适用于单个文件)。</li>
<li><code>--no-decorate; --decorate[=short|full|auto|no]</code>：打印显示的任何提交的ref名称。如果指定了short，则不会打印<code>refs/heads/</code>、<code>refs/tags/</code>和<code>refs/remotes/</code>的前缀。如果指定了full，则打印完整的引用名称(包括前缀)。如果指定了auto，那么如果输出到终端，则ref名称将显示为short，否则不显示任何ref名称。选项<code>--decorate</code>是<code>--decorate=shor</code>t的简写。如果配置了，默认为<code>log. decorator</code>的配置值，否则为auto。</li>
<li><code>--source</code>：打印出在命令行中给出的每个提交的引用名称。</li>
</ul>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash list [&lt;<span class="built_in">log</span>-options&gt;]</span><br><span class="line">git stash show [-u|--include-untracked|--only-untracked] [&lt;diff-options&gt;] [&lt;stash&gt;]</span><br><span class="line">git stash drop [-q|--quiet] [&lt;stash&gt;]</span><br><span class="line">git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]</span><br><span class="line">git stash branch &lt;branchname&gt; [&lt;stash&gt;]</span><br><span class="line">git stash [push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class="line">	     [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]</span><br><span class="line">	     [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]]</span><br><span class="line">	     [--] [&lt;pathspec&gt;…]]</span><br><span class="line">git stash clear</span><br><span class="line">git stash create [&lt;message&gt;]</span><br><span class="line">git stash store [-m|--message &lt;message&gt;] [-q|--quiet] &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>回想之前介绍的<code>switch</code>和<code>checkout</code>，当工作树或者索引有修改的时候，是无法切换分支的。而<code>stash</code>就是为了解决这个问题出现的。其可以将工作树或索引的文件保存在本地。之后便可以切换分支。</p>
</blockquote>
<p>当你想要记录工作目录和索引的当前状态，但又想要回到一个干净的工作目录时，使用<code>git stash</code>。该命令保存本地修改，然后可以切换到其他分支，在其他分支操作完切换回来之后，再恢复文件。</p>
<p>通过这个命令隐藏的修改可以进行以下操作：</p>
<ul>
<li><code>git stash list</code>：列举修改。</li>
<li><code>git stash show</code>：检查修改。</li>
<li><code>git stash apply</code>：恢复修改。</li>
<li><code>git stash; git stash push</code>：隐藏当前状态。一个隐藏在默认情况下被命名为<code>WIP on branchname …</code>，但是当创建一个隐藏时，也可以在命令行上给出一个更描述性的消息。</li>
</ul>
<p>创建的最新隐藏内容存储在<code>refs/stash</code>中;旧的堆栈可以在此引用的<code>reflog</code>中找到，可以使用通常的<code>reflog</code>语法命名。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="push"><a href="#push" class="headerlink" title="push"></a><code>push</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [-m|--message &lt;message&gt;] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]] [--] [&lt;pathspec&gt;…]</span><br></pre></td></tr></table></figure>
<p>存储当前本地修改为一个<code>stash</code>。</p>
<p><code>&lt;message&gt;</code>是可选的，其给出了描述和隐藏状态。</p>
<p>其中<code>push</code>关键可以省略，在此模式下，不允许使用非选项参数，以防止拼写错误的子命令生成不需要的隐藏条目。这其中的两个例外是<code>stash -p</code>，它作为<code>stash push -p</code>的别名和pathspec元素，它允许在双连字符之后<code>--</code>以消除歧义。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a><code>list</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list [&lt;<span class="built_in">log</span>-options&gt;]</span><br></pre></td></tr></table></figure>
<p>列出你现在的储藏条目。每个储藏条目都列有它的名字、当条目被创建时当前的分支的名称以及条目所基于的提交的简短描述。</p>
<p>该命令采用适用于git log命令的选项来控制显示的内容以及如何显示。</p>
<h4 id="show"><a href="#show" class="headerlink" title="show"></a><code>show</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show [-u|--include-untracked|--only-untracked] [&lt;diff-options&gt;] [&lt;stash&gt;]</span><br></pre></td></tr></table></figure>
<p>展示在<code>stash</code>中的记录和当前文件内容的不同。</p>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a><code>pop</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pop [--index] [-q|--quiet] [&lt;stash&gt;]</span><br></pre></td></tr></table></figure>
<p>从<code>stash</code>列表中移除单个<code>stash</code>状态，并将其应用到当前工作树状态的顶部。工作目录必须与索引匹配。</p>
<p>当发生冲突的时候，该命令会失败，但该<code>stash</code>不会从<code>stash</code>列表中移除。此时可以手动解决冲突，然后使用<code>git stash drop</code>来移除。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a><code>apply</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apply [--index] [-q|--quiet] [&lt;stash&gt;]</span><br></pre></td></tr></table></figure>
<p>与<code>pop</code>类似，但其不会将当前<code>stash</code>从<code>stash</code>列表中移除。</p>
<h4 id="branch-1"><a href="#branch-1" class="headerlink" title="branch"></a>branch</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">branch &lt;branchname&gt; [&lt;stash&gt;]</span><br></pre></td></tr></table></figure>
<p>从最初创建<code>&lt;stash&gt;</code>的提交开始，创建并切换到一个名为<code>&lt;branchname&gt;</code>的新分支，将<code>&lt;stash&gt;</code>中记录的更改应用到新的工作树和索引。如果成功，并且<code>&lt;stash&gt;</code>是形式<code>stash@{&lt;revision&gt;}</code>的引用，那么它将删除<code>&lt;stash&gt;</code>。</p>
<p>如果你运行<code>git stash push</code>的分支发生了足够大的变化，以至于<code>git stash apply</code>由于冲突而失败，那么这是非常有用的。因为这个隐藏条目应用于在git隐藏运行时是HEAD的提交上，所以它会恢复原来的隐藏状态而不产生冲突。</p>
<h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><p>删除所有的<code>stash</code>条目。请注意，这些条目随后将被删除，并且可能无法恢复（<strong>谨慎</strong>）。</p>
<h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a><code>drop</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drop [-q|--quiet] [&lt;stash&gt;]</span><br></pre></td></tr></table></figure>
<p>从<code>stash</code>条目列表中删除单个<code>stash</code>条目。（不加参数则删除最近的一条）</p>
<h4 id="create"><a href="#create" class="headerlink" title="create"></a><code>create</code></h4><p>创建一个<code>stash</code>条目(这是一个常规提交对象)并返回它的对象名称，而不将其存储在<code>ref</code>名称空间的任何地方。这对脚本很有用。</p>
<p><code>store</code></p>
<p>将通过<code>git stash create</code>(一个悬空的合并提交)创建的<code>stash</code>存储在<code>stash ref</code>中，更新<code>stash reflog</code>。这对脚本很有用。这可能不是你想要使用的命令。</p>
<h3 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>-a; --all</code>：此选项仅对push和save命令有效。所有被忽略和未跟踪的文件也被隐藏，然后用<code>git clean</code>清理。</li>
<li><code>-u; --include-untracked; --no-include-untracked</code>：当使用<code>push</code>和<code>save</code>命令时，所有未跟踪的文件也会被隐藏，然后用git clean清理。当与<code>show</code>命令一起使用时，将隐藏条目中的未跟踪文件显示为diff的一部分。</li>
<li><code>--only-untracked</code>：（该选项仅对show命令有效）只显示隐藏条目中未跟踪的文件作为差异的一部分。</li>
<li><code>--index</code>：（此选项仅对pop和apply命令有效）尝试不仅恢复工作树的更改，而且恢复索引的更改。然而，当有冲突时，可能会失败。</li>
<li><code>-k; --keep-index; --no-keep-index</code>：（此选项仅对push和save命令有效）已经添加到索引中的所有更改都保持不变。</li>
<li><code>-S; --staged</code>：（此选项仅对push和save命令有效）只隐藏当前进行的更改。这类似于基本的git提交，除了状态被提交到stash而不是当前的分支。(<code>patch</code>选项比该命令优先级高)</li>
<li><code>--pathspec-from-file=&lt;file&gt;</code>：（此选项仅对push命令有效）从文件中读取<code>pathspec</code>。</li>
<li><code>&lt;pathspec&gt;…</code>：（此选项仅对push命令有效）新的存放条目只记录匹配路径规范的文件的修改状态。在随后的恢复时，索引项和工作树文件也会被回滚到这些文件在HEAD中的状态，而不匹配路径规范的文件则会保持不变。</li>
</ul>
<h2 id="workwtree"><a href="#workwtree" class="headerlink" title="workwtree"></a><code>workwtree</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git worktree add [-f] [--detach] [--checkout] [--lock [--reason &lt;string&gt;]] [-b &lt;new-branch&gt;] &lt;path&gt; [&lt;commit-ish&gt;]</span><br><span class="line">git worktree list [-v | --porcelain]</span><br><span class="line">git worktree lock [--reason &lt;string&gt;] &lt;worktree&gt;</span><br><span class="line">git worktree move &lt;worktree&gt; &lt;new-path&gt;</span><br><span class="line">git worktree prune [-n] [-v] [--expire &lt;expire&gt;]</span><br><span class="line">git worktree remove [-f] &lt;worktree&gt;</span><br><span class="line">git worktree repair [&lt;path&gt;…]</span><br><span class="line">git worktree unlock &lt;worktree&gt;</span><br></pre></td></tr></table></figure>
<p>工作树可以允许将一个仓库的不同分支分别存储到不同的文件目录。而免去了反复切换分支的麻烦（特别是对于很大的项目）。</p>
<p>可以通过<code>git worktree add</code>创建一个新的与该仓库联系的工作树。这个新的工作树被称为为“链接工作树”，而原本的工作树被称为“主工作树”。一个仓库可以有一个主工作树和多个链接工作树。可以使用<code>git worktree remove</code>来移除已存在的工作树。</p>
<p>通过<code>git worktree add &lt;path&gt;</code>，Git会自动创建一个新的分支（其名字是该路径的最后一个文件夹名字），然后将该目录作为该分支的工作树。</p>
<p>也可以通过<code>git worktree add &lt;path&gt; &lt;branch&gt;</code>来将现有的分支和目录链接起来。另一方面，如果您只是计划进行一些实验性的更改或进行测试，而不影响现有的开发，那么创建一个与任何分支都不相关的一次性工作树通常是很方便的。例如，<code>git worktree add -d &lt;path&gt;</code>将在当前分支的同一个提交中创建一个新的工作树，该树带有一个分离的HEAD。</p>
<p>如果一个工作树在没有使用<code>git worktree remove</code>的情况下被删除（即手动删除），那么它所关联的管理文件(驻留在存储库中)最终将被自动删除，或者你可以在主目录或者任何链接的工作树中运行<code>git worktree prune</code>命令来清理任何过期的管理文件。</p>
<p>如果一个链接的工作树存储在一个不总是挂载的便携设备或网络共享中，你可以通过发出<code>git worktree lock</code>命令来防止它的管理文件被删除，还可以指定<code>--reason</code>来解释为什么工作树被锁定。</p>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><h4 id="add-lt-path-gt-lt-commit-ish-gt"><a href="#add-lt-path-gt-lt-commit-ish-gt" class="headerlink" title="add &lt;path&gt; [&lt;commit-ish&gt;]"></a><code>add &lt;path&gt; [&lt;commit-ish&gt;]</code></h4><p>创建<code>&lt;path&gt;</code>并切换<code>&lt;commit-ish&gt;</code>到其中。新的工作目录链接到当前的存储库，共享除工作目录特定文件(如HEAD、index等)外的所有内容。</p>
<p>如果<code>&lt;commit-ish&gt;</code>是一个分支名称(叫它<code>&lt;branch&gt;</code>)，并且没有找到它，而且<code>-B</code>、<code>-b</code>和<code>--detach</code>都没有使用，但是在一个远程(叫它<code>&lt;remote&gt;</code>)中确实存在一个跟踪分支，具有匹配的名称，则将其视为等价的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git worktree add --track -b &lt;branch&gt; &lt;path&gt; &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>如果分支存在于多个远程中，并且其中一个分支由<code>checkout.defaultRemote</code>配置变量命名，我们将使用该分支来消除歧异，即使<code>&lt;branch&gt;</code>在所有远程中不是唯一的。</p>
<p>如果省略了<code>&lt;commit-ish</code>&gt;并且没有使用<code>-B</code>、<code>-b</code>和<code>--detach</code>，那么，为了方便起见，新的工作树与一个以<code>$(basename &lt;path&gt;</code>)命名的分支(称为<code>&lt;branch&gt;</code>)相关联。如果<code>&lt;branch&gt;</code>不存在，将自动创建一个基于HEAD的新分支，就像给出了<code>-b &lt;branch&gt;</code>一样。如果<code>&lt;branch&gt;</code>确实存在，它将在新的工作树中检出，如果没有在其他地方检出，否则命令将拒绝创建工作树。</p>
<h4 id="list-1"><a href="#list-1" class="headerlink" title="list"></a><code>list</code></h4><p>列出每个工作树的详细信息。首先列出主工作树，然后是每个链接的工作树。输出细节包括工作树是否空白，当前签出的修订，当前签出的分支(如果没有，则为“detached HEAD”)。如果工作树被锁定，则显示“locked”，如果工作树可以通过prune命令进行修剪，则显示“prunable”。</p>
<h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a><code>lock</code></h4><p>如果工作树位于不总是挂载的便携设备或网络共享上，锁定它，以防止其管理文件被自动删除。这也可以防止它被移动或删除。可以使用<code>--reason</code>指定锁的原因。</p>
<h4 id="move"><a href="#move" class="headerlink" title="move"></a><code>move</code></h4><p>将一棵工作树移动到一个新的位置。请注意，不能使用此命令移动包含子模块的主工作树或链接工作树。</p>
<h4 id="prune"><a href="#prune" class="headerlink" title="prune"></a><code>prune</code></h4><p>删除<code>$GIT_DIR/worktrees</code>中的工作树信息。</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a><code>remove</code></h4><p>移除一个工作树。只有无污染的工作树(没有未被跟踪的文件和在被跟踪的文件中没有修改)可以被删除。不干净的工作树或有子模块的工作树可以用<code>--force</code>移除。主工作树不能被移除。</p>
<h4 id="repair-lt-path-gt-…"><a href="#repair-lt-path-gt-…" class="headerlink" title="repair [&lt;path&gt;…]"></a><code>repair [&lt;path&gt;…]</code></h4><p>如果可能，修复工作树管理文件，如果它们由于外部因素而损坏或过时。</p>
<p>例如，如果主工作树(或裸存储库)被移动，链接的工作树将无法找到它。在主工作树中运行修复将重新建立连接的工作树到主工作树的连接。</p>
<p>类似地，如果一个链接的工作树在没有使用<code>git worktree move</code>的情况下被移动，那么主工作树(或者裸存储库)将无法找到它。在最近移动的工作树中运行修复将重新建立连接。如果移动了多个链接的工作树，则使用每个工作树的新<code>&lt;path&gt;</code>作为参数从任何工作树运行修复，将重新建立到所有指定路径的连接。</p>
<p>如果手动移动了主工作树和链接工作树，则在主工作树中运行修复并指定每个链接工作树的新<path>将重新建立两个方向上的所有连接。</p>
<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a><code>unlock</code></h4><p>解锁工作树，允许对其进行修剪、移动或删除。</p>
<h3 id="选项-5"><a href="#选项-5" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p><code>-f; --force</code>：默认情况下，如果<code>&lt;commit-ish</code>&gt;是一个分支名并且已经被另一个工作树检出，或者<code>&lt;path&gt;</code>已经被分配到某个工作树但现在丢失了(例如，如果手动删除了<code>&lt;path&gt;</code>)， add拒绝创建新的工作树。这个选项覆盖了这些保护措施。要添加一个缺失但锁定的工作树路径，请指定两次<code>--force</code>。</p>
<p><code>move</code>拒绝移动锁定的工作树，除非指定两次<code>-force</code>。如果目的地已经被分配给其他工作树，但是现在丢失了(例如，如果手动删除了<code>&lt;new-path&gt;</code>)，那么<code>--force</code>允许移动继续;如果目的地被锁定，使用——force两次。</p>
<p><code>remove</code>拒绝移除不干净的工作树，除非使用<code>--force</code>。要移除锁定的工作树，指定两次<code>--force</code>。</p>
</li>
<li><p><code>-b &lt;new-branch&gt;; -B &lt;new-branch&gt;</code>：使用<code>add</code>命令时，从<code>&lt;commit-ish&gt;</code>开始创建一个名为<code>&lt;new-branch&gt;</code>的新分支，并将<code>&lt;new-branch&gt;</code>检出到新的工作树中。如果省略<code>&lt;commit-ish&gt;</code>，则默认为HEAD。默认情况下，<code>-b</code>拒绝创建一个已经存在的新分支。<code>-B</code>覆盖这个安全措施，将<code>&lt;new-branch&gt;</code>重置为<code>&lt;commit-ish&gt;</code>。</p>
</li>
<li><p><code>-d; --detach</code>：使用<code>add</code>命令时，在新的工作树中分离HEAD。</p>
</li>
<li><p><code>--[no-]checkout</code>：默认情况下，添加检出<code>&lt;commit-ish&gt;</code>，但是<code>--no-checkout</code>可以用来禁止检出。</p>
</li>
<li><p><code>--[no-]guess-remote</code>：使用<code>worktree add &lt;path&gt;</code>，并没有<code>&lt;commit-ish&gt;</code>时，并不从头创建一个新的分支,如果存在一个远程仓库的分支匹配<code>&lt;path&gt;</code>的基地址名，则基于该远程分支来新建分支，并将其<code>upstram</code>为该远程分支。</p>
</li>
<li><p><code>--[no-]track</code>：当创建一个新分支时，如果<code>&lt;commit-ish&gt;</code>是一个分支，则将其标记为来自新分支的“upstream”。如果<code>&lt;commit-ish&gt;</code>是一个远程跟踪分支，这是默认值。</p>
</li>
<li><p><code>--reason &lt;string&gt;</code>：使用<code>lock</code>或<code>add --lock</code>，解释为什么工作树被锁定。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>分支与合并</tag>
      </tags>
  </entry>
  <entry>
    <title>hibernate validator基本使用</title>
    <url>/2022/03/28/hibernate-validator%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="Spring-boot"><a href="#Spring-boot" class="headerlink" title="Spring-boot"></a>Spring-boot</h2><p>spring-boot-starter-web就包含了hibernate validator。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="spring-MVC"><a href="#spring-MVC" class="headerlink" title="spring MVC"></a>spring MVC</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.17.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="验证bean"><a href="#验证bean" class="headerlink" title="验证bean"></a>验证bean</h1><p>validator的基本用法和lombok一样。添加到实体类的属性上。如果不符合属性的要求就会抛出错误。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="meta">@Size</span>(max = <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Pattern</span>(regexp = <span class="string">"[A-Z][a-z][0-9]"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Max</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="meta">@Min</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>如果不通过spring，validator是无法直接劫持实例化的过程。只能通过对应的validator对象的方法来验证对应的对象。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="keyword">null</span>, <span class="string">""</span>, <span class="string">"123"</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line"> ValidatorFactory factory = Validation.buildDefaultValidatorFactory();</span><br><span class="line">validator = factory.getValidator();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 验证所有bean的所有约束</span></span><br><span class="line">        Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations = validator.validate(user);</span><br><span class="line">        <span class="comment">// 验证单个属性</span></span><br><span class="line">        Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations2 = validator.validateProperty(user, <span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// 检查给定类的单个属性是否可以成功验证</span></span><br><span class="line">        Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations3 = validator.validateValue(User.class, "password", "sa!");</span><br><span class="line"></span><br><span class="line">        constraintViolations.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));</span><br><span class="line">        constraintViolations2.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));</span><br><span class="line">        constraintViolations3.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不能为Null</span><br><span class="line">不能为空</span><br><span class="line">需要匹配正则表达式<span class="string">"[A-Z][a-z][0-9]"</span></span><br><span class="line">最小为1</span><br></pre></td></tr></table></figure>
<h1 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h1><p>验证方法可以通过将注解加到对应的位置来验证参数或者返回值。</p>
<h2 id="验证参数"><a href="#验证参数" class="headerlink" title="验证参数"></a>验证参数</h2><p>可以通过将注解加到参数前面，然后通过验证器来验证某个方法是是否合法。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter03.parameter; </span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RentalStation</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RentalStation</span><span class="params">(@NotNull String name)</span> </span>&#123; <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rentCar</span><span class="params">( @NotNull Customer customer, @NotNull @Future Date startDate, @Min(<span class="number">1</span>)</span> <span class="keyword">int</span> durationInDays) </span>&#123;</span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>验证构造方法的参数不能为空，</li>
<li>rentCar方法的第一个参数不为空，</li>
<li>第二个参数必须为当前时间的位来，</li>
<li>第三个参数最小只能为1。</li>
</ul>
<h2 id="验证返回值"><a href="#验证返回值" class="headerlink" title="验证返回值"></a>验证返回值</h2><p>同样的，将注解加到对应的方法上可以验证返回值是否合法。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.validator.referenceguide.chapter03.returnvalue; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RentalStation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ValidRentalStation</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RentalStation</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NotNull</span> <span class="meta">@Size</span>(min = <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="meta">@NotNull</span> Customer&gt; getCustomers() &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里确保了：</p>
<ul>
<li>任何新创建的RentalStation对象都必须满足@ValidRentalStation约束  </li>
<li>getCustomers()返回的客户列表不能为空，并且必须至少包含1个元素</li>
<li>getCustomers()返回的客户列表不能包含空对象。</li>
</ul>
<h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><p>方法约束的验证是使用ExecutableValidator接口完成的。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car object = new Car( "Morris" ); Method method = Car.class.getMethod( "drive", int.class );// 1. 获取executableValidator对象</span><br><span class="line">ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); </span><br><span class="line">ExecutableValidator executableValidator = factory.getValidator().forExecutables();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 验证方法参数</span></span><br><span class="line">Car object = <span class="keyword">new</span> Car( <span class="string">"Morris"</span> ); </span><br><span class="line">Method method = Car.class.getMethod( "drive", int.class );</span><br><span class="line">Object[] parameterValues = &#123; <span class="number">80</span> &#125;; </span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateParameters( object, method, parameterValues);</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Annotation&gt; constraintType = violations.iterator() .next() .getConstraintDescriptor() .getAnnotation()</span><br><span class="line">.annotationType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 验证返回值</span></span><br><span class="line">Constructor&lt;Car&gt; constructor = Car<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>( <span class="title">String</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span> )</span>; </span><br><span class="line">Car createdObject = <span class="keyword">new</span> Car( <span class="string">"Morris"</span>, <span class="keyword">null</span> ); </span><br><span class="line">Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator .validateConstructorReturnValue( constructor, createdObject);</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Annotation&gt; constraintType = violations.iterator() .next() .getConstraintDescriptor() .getAnnotation().annotationType();</span><br></pre></td></tr></table></figure>
<p>注意：ExecutableValidator接口总共提供了四个方法:</p>
<ul>
<li><code>validateParameters()</code>：用来验证方法参数。</li>
<li><code>validateReturnValue()</code>：用来验证方法返回值。</li>
<li><code>validateConstructorParameters()</code>：用来验证构造器参数。</li>
<li><code>validateConstructorReturnValue()</code>：用来验证构造器返回值。</li>
</ul>
<h1 id="spring结合"><a href="#spring结合" class="headerlink" title="spring结合"></a>spring结合</h1><p>可以看到，上面的验证非常复杂，但是有了spring的aop帮助，我们只需要配置以下，就可以让spring自动为我们进行验证。我们只需要在方法或者参数上添加约束注解即可。</p>
<h2 id="class方式"><a href="#class方式" class="headerlink" title="class方式"></a>class方式</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>如果只需要验证实体类的约束，则只需要配置一个validator即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置验证器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> validator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Validator <span class="title">validator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">configure</span>()</span></span><br><span class="line"><span class="class">                // 快速失败模式</span></span><br><span class="line"><span class="class">                .<span class="title">failFast</span>(<span class="title">true</span>)</span></span><br><span class="line">                // .addProperty( "hibernate.validator.fail_fast", "true" )</span><br><span class="line">                .buildValidatorFactory();</span><br><span class="line">        <span class="keyword">return</span> validatorFactory.getValidator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过方法 <code>failFast(true)</code>或 <code>addProperty(&quot;hibernate.validator.fail_fast&quot;, &quot;true&quot;)</code>设置为<strong>快速失败模式</strong>，快速失败模式在校验过程中，当遇到第一个不满足条件的参数时就立即返回，不再继续后面参数的校验。否则会一次性校验所有参数，并返回所有不符合要求的错误信息</p>
<h3 id="方法验证配置"><a href="#方法验证配置" class="headerlink" title="方法验证配置"></a>方法验证配置</h3><p>如果需要验证方法参数和返回值，则还需要配置另一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置方法参数验证器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodValidationPostProcessor <span class="title">methodValidationPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MethodValidationPostProcessor postProcessor = <span class="keyword">new</span> MethodValidationPostProcessor();</span><br><span class="line">    <span class="comment">// 设置validator模式为快速失败返回</span></span><br><span class="line">    postProcessor.setValidator(validator());</span><br><span class="line">    <span class="keyword">return</span> postProcessor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h2><p>同样的，在XML中也只需要配置这两个对象即可完成配置。</p>
<h3 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- validator基本配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"validator"</span> <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"providerClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.validator.HibernateValidator"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射资源文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationMessageSource"</span> <span class="attr">ref</span>=<span class="string">"messageSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">validator</span>=<span class="string">"validator"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="方法验证配置-1"><a href="#方法验证配置-1" class="headerlink" title="方法验证配置"></a>方法验证配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置方法参数验证器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"methodValidationPostProcessor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.MethodValidationPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validator"</span> <span class="attr">ref</span>=<span class="string">"validator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在配置好之后，只要是在spring容器中的对象，都可以让spring自动完成验证。</p>
<h3 id="请求接口验证对象"><a href="#请求接口验证对象" class="headerlink" title="请求接口验证对象"></a>请求接口验证对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"> 	<span class="meta">@PostMapping</span>(<span class="string">"/login1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login1</span><span class="params">(@Valid @RequestBody User user)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果有错误会直接抛出。</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login1</span><span class="params">(@Valid @RequestBody User user,  BindingResult result)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 在控制器内本地处理验证错误</span></span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            result.getAllErrors().forEach(s -&gt; System.out.println(s.getDefaultMessage()));</span><br><span class="line">             <span class="keyword">return</span> R.fail(result.getAllErrors().get(<span class="number">0</span>).getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般都是使用第一种方式，然后通过springMVC全局处理异常。</p>
<h3 id="请求验证简单类型"><a href="#请求验证简单类型" class="headerlink" title="请求验证简单类型"></a>请求验证简单类型</h3><p>这里必须有两步：</p>
<ol>
<li><strong>必须要配置methodValidationPostProcessor</strong>。</li>
<li><strong>必须在类上加<code>@Validated</code>注解。</strong></li>
</ol>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEmail</span><span class="params">(@Email String email)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h1><p>validator-api-2.0的约束注解有22个，具体我们看下面表格</p>
<h3 id="空与非空检查"><a href="#空与非空检查" class="headerlink" title="空与非空检查"></a>空与非空检查</h3><table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Null</td>
<td>Object</td>
<td>为null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>Object</td>
<td>不为null</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>CharSequence</td>
<td>不为null，且必须有一个非空格字符</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>CharSequence、Collection、Map、Array</td>
<td>不为null，且不为空（length/size&gt;0）</td>
</tr>
</tbody>
</table>
<h3 id="Boolean值检查"><a href="#Boolean值检查" class="headerlink" title="Boolean值检查"></a>Boolean值检查</h3><table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>@AssertTrue</td>
<td>boolean、Boolean</td>
<td>为true</td>
<td>为null有效</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>boolean、Boolean</td>
<td>为false</td>
<td>为null有效</td>
</tr>
</tbody>
</table>
<h3 id="日期检查"><a href="#日期检查" class="headerlink" title="日期检查"></a>日期检查</h3><table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Future</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间之后</td>
<td>为null有效</td>
</tr>
<tr>
<td>@FutureOrPresent</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间或之后</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Past</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间之前</td>
<td>为null有效</td>
</tr>
<tr>
<td>@PastOrPresent</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间或之前</td>
<td>为null有效</td>
</tr>
</tbody>
</table>
<h3 id="数值检查"><a href="#数值检查" class="headerlink" title="数值检查"></a>数值检查</h3><table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Max</td>
<td>BigDecimal、BigInteger，byte、short、int、long以及包装类</td>
<td>小于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Min</td>
<td>BigDecimal、BigInteger，byte、short、int、long以及包装类</td>
<td>大于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类</td>
<td>小于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类</td>
<td>大于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Negative</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>负数</td>
<td>为null有效，0无效</td>
</tr>
<tr>
<td>@NegativeOrZero</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>负数或零</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Positive</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>正数</td>
<td>为null有效，0无效</td>
</tr>
<tr>
<td>@PositiveOrZero</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>正数或零</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Digits(integer = 3, fraction = 2)</td>
<td>BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类</td>
<td>整数位数和小数位数上限</td>
<td>为null有效</td>
</tr>
</tbody>
</table>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Pattern</td>
<td>CharSequence</td>
<td>匹配指定的正则表达式</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Email</td>
<td>CharSequence</td>
<td>邮箱地址</td>
<td>为null有效，默认正则 <code>&#39;.*&#39;</code></td>
</tr>
<tr>
<td>@Size</td>
<td>CharSequence、Collection、Map、Array</td>
<td>大小范围（length/size&gt;0）</td>
<td>为null有效</td>
</tr>
</tbody>
</table>
<h3 id="hibernate-validator扩展约束（部分）"><a href="#hibernate-validator扩展约束（部分）" class="headerlink" title="hibernate-validator扩展约束（部分）"></a>hibernate-validator扩展约束（部分）</h3><table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Length</td>
<td>String</td>
<td>字符串长度范围</td>
</tr>
<tr>
<td>@Range</td>
<td>数值类型和String</td>
<td>指定范围</td>
</tr>
<tr>
<td>@URL</td>
<td></td>
<td>URL地址验证</td>
</tr>
</tbody>
</table>
<p>另外还可以自定义约束注解，此处为简单介绍，就不再赘述。</p>
]]></content>
      <categories>
        <category>hibernate validator</category>
      </categories>
      <tags>
        <tag>hibernate validator</tag>
        <tag>validator</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习1-创建和获得项目</title>
    <url>/2022/02/27/git%E5%AD%A6%E4%B9%A01-%E5%88%9B%E5%BB%BA%E5%92%8C%E8%8E%B7%E5%BE%97%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="获得和创建项目"><a href="#获得和创建项目" class="headerlink" title="获得和创建项目"></a>获得和创建项目</h1><blockquote>
<p>pre：</p>
<ul>
<li>索引（index）就是指添加（add）后的文件记录。</li>
<li>工作树（working tree）指当前的目录树及其文件。</li>
</ul>
</blockquote>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a><code>init</code></h2><p>该命令用于创建一个空的仓库或者初始化一个已经存在的仓库。</p>
<p>其会创建一个<code>.git</code>文件夹，其内部会创建以下子文件：</p>
<ul>
<li><code>objects</code></li>
<li><code>refs/heads</code></li>
<li><code>refs/tags</code></li>
</ul>
<h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><ul>
<li><code>-q；--quite</code>：只打印错误和警告信息；其他的输出都不会被输出。</li>
<li><code>--bare</code>：创建一个空仓库，如果<code>GIT_DIR</code>环境变量没有设置，就其将当前工作目录设置。</li>
<li><code>--template=&lt;template-directory&gt;</code>：指定模板被使用的目录。</li>
<li><code>-b &lt;branch-name&gt;;--initial-branch=&lt;branch-name&gt;</code>：为新创建的仓库的初始化分支指定指定的名字。（如果没有指定，目前即为<code>master</code>，后期可能会改变。</li>
</ul>
<h3 id="通常用法："><a href="#通常用法：" class="headerlink" title="通常用法："></a>通常用法：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>克隆一个仓库到一个新的目录。</p>
<p>将一个存储库克隆到一个新创建的目录中，为克隆存储库中的每个分支创建远程跟踪分支(使用git branch——remotes可见)，并创建并签出一个从克隆存储库的当前活动分支分离出来的初始分支。</p>
<p>在克隆之后，没有参数的<code>git fetch</code>命令将会更新所有的远程分支。没有参数的<code>git pull</code>将会额外将远程仓库的<code>master</code>分支合并到当前本地的<code>master</code>分支。</p>
<p>这个默认配置是通过创建对下面的远程分支头的引用来实现的，<code>refs/remotes/origin</code>和初始化<code>remote.origin.url</code>和<code>remote.origin.fetch</code>。</p>
<h3 id="选项：-1"><a href="#选项：-1" class="headerlink" title="选项："></a>选项：</h3><ul>
<li><code>-l; --local</code>：当要被克隆的仓库是一个本地机器，这个标志绕过了正常的“Git感知”传输机制，通过复制objects和refs目录下的HEAD和所有东西来克隆存储库。将创建<code>.git/objects/</code>目录下的文件硬链接，以尽可能节省空间。</li>
<li><code>--no-hardlinks</code>：强制克隆过程从本地文件系统的存储库中复制<code>.git/objects</code>目录下的文件，而不是使用硬链接。</li>
<li><code>-q;--quiet</code>：静默地运作。进度不会报告给标准错误流。</li>
<li><code>--progress</code>：默认状态，除非使用了<code>-q</code>。即所有的状态报告都会被打印出来。</li>
<li><code>-o &lt;name&gt;; --origin &lt;name&gt;</code>：使用自定义的\&lt;name>名字作为远程仓库名字，而不是<code>origin</code>。本质是重写了配置文件中的<code>clone.defaultRemoteName</code>项。</li>
<li><code>-b &lt;name&gt;; --branch &lt;name&gt;</code>：并不是从远程克隆仓库的<code>HEAD</code>所指向的分支来创建新的本地分支的<code>HEAD</code>，而是从\&lt;name>分支的<code>HEAD</code>来创建。</li>
<li><code>--depth &lt;depth&gt;</code>：创建一个浅克隆，其历史截断为指定的提交数量。<code>--single-branch</code>和<code>--no-single-branch</code>可以用来获取是否是仓库的所有分支。</li>
<li><code>--shallow-since=&lt;date&gt;</code>：在指定的时间之后创建具有历史记录的浅拷贝。</li>
<li><code>--shallow-exclude=&lt;revision&gt;</code>：创建一个具有历史记录的浅克隆，排除从指定的远程分支或标记可到达的提交。此选项可指定多次。</li>
<li><code>&lt;repository&gt;</code>：要克隆的仓库地址，如：<code>git://git.host.xz/</code></li>
<li><code>&lt;directory&gt;</code>：要克隆到的新目录的位置。</li>
</ul>
<h3 id="通常用法：-1"><a href="#通常用法：-1" class="headerlink" title="通常用法："></a>通常用法：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.host.xz/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>创建和获得项目</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas基础</title>
    <url>/2019/03/10/canvas%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="创建canvas画布"><a href="#创建canvas画布" class="headerlink" title="创建canvas画布"></a>创建canvas画布</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css:</span><br><span class="line">canvas&#123;</span><br><span class="line">            border:3px solid blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">html:</span><br><span class="line">&lt;canvas width&#x3D;&quot;700&quot; height&#x3D;&quot;700&quot; id&#x3D;&quot;myCanvas&quot;&gt;</span><br><span class="line">        您的浏览器不支持canvas，请更换浏览器访问！</span><br><span class="line">    &lt;&#x2F;canvas&gt;</span><br><span class="line"></span><br><span class="line">Javascript:</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        let canvas &#x3D; document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">        let ctx &#x3D; canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Point:</p>
<ol>
<li>canvas标签是一个双标签，其内部写的是当浏览器不支持canvas时显示的内容，可以插入其他元素，比如文字，图片等。</li>
<li>canvas画布的宽高应该在其标签内定义，不能在其CSS内定义，否则其绘制的图像会按照300*150发生缩放。</li>
<li><p>所有绘图行为都在script标签中进行。</p>
<p> let ctx = canvas.getContext(“2d”);</p>
</li>
</ol>
<p>所有canvas的API都是定义在该对象上的，其中参数可以是2D，或者3D.</p>
<h1 id="Canvas绘制图像"><a href="#Canvas绘制图像" class="headerlink" title="Canvas绘制图像"></a>Canvas绘制图像</h1><p>canvas的绘制图形有两种方式：</p>
<ul>
<li>context.fill()</li>
</ul>
<p>fill()指的是填充，其默认颜色是黑色，可以在使用fill()之前使用fillStyle()方法改变填充颜色，如果是闭合图像，那么就直接填充。如果是非闭合的路径，则fill()先帮其闭合，然后填充。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">"red"</span>;<span class="comment">//设置填充色</span></span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//绘制一个填充矩形</span></span><br></pre></td></tr></table></figure>
<ul>
<li>context.stroke()</li>
</ul>
<p>stroke()方法会实际的绘制出moveTo()和lineTo()方法的路径。默认颜色是黑色，在绘制之前，可以使用strokeStyle()进行设置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.strokeStyle = <span class="string">"red"</span>;<span class="comment">//设置边框填充色</span></span><br><span class="line">ctx.strokeRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//绘制空心矩形</span></span><br></pre></td></tr></table></figure>
<h1 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h1><h2 id="绘制基本矩形"><a href="#绘制基本矩形" class="headerlink" title="绘制基本矩形"></a>绘制基本矩形</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.fillRect(x,y,height,width)<span class="comment">//实心矩形</span></span><br><span class="line">ctx.strokeRect(x,y,height,width)<span class="comment">//空心边框</span></span><br></pre></td></tr></table></figure>
<ul>
<li>x:起点的x坐标(即左上角的x坐标)</li>
<li>y:起点的y坐标(即左上角的y坐标)</li>
<li>height:矩形的高</li>
<li>width:矩形的宽</li>
</ul>
<h2 id="改变颜色"><a href="#改变颜色" class="headerlink" title="改变颜色"></a>改变颜色</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">"red"</span>;<span class="comment">//设置填充颜色</span></span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">"red"</span>;<span class="comment">//设置边框颜色</span></span><br><span class="line">ctx.strokeRect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Point:</strong></p>
<ul>
<li>ctx.fillStyle = “red”用来设置填充颜色</li>
<li>ctx.strokeStyle = “red”用来设置边框颜色</li>
<li>这些描述都要放在绘制图形之前声明</li>
</ul>
<h2 id="擦除矩形区域"><a href="#擦除矩形区域" class="headerlink" title="擦除矩形区域"></a>擦除矩形区域</h2><ul>
<li><p>ctx.clearRect(x,y,height,width)</p>
<p>  ctx.clearRect(50,50,200,200)//绘制一个矩形区域并擦除该区域之前的内容</p>
</li>
</ul>
<h1 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h1><h2 id="绘制基本圆"><a href="#绘制基本圆" class="headerlink" title="绘制基本圆"></a>绘制基本圆</h2><h3 id="实心圆"><a href="#实心圆" class="headerlink" title="实心圆"></a>实心圆</h3><ul>
<li><p>ctx.arc(x,y,radius,starAngle,endAngle,anticlockwise)</p>
<ul>
<li>x:圆心的x坐标</li>
<li>y:圆心的y坐标</li>
<li>radius:半径</li>
<li>startAngle:开始角度</li>
<li>endAngle:结束角度</li>
<li><p>anticlockwise:旋转方向，</p>
<ul>
<li>true:逆时针(可选参数，默认为false)</li>
<li>false:顺时针</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">"red"</span>; <span class="comment">//设置填充色</span></span><br><span class="line">ctx.arc(<span class="number">200</span>,<span class="number">200</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>);<span class="comment">//绘制圆形</span></span><br><span class="line">ctx.fill();<span class="comment">//填充</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="空心圆"><a href="#空心圆" class="headerlink" title="空心圆"></a>空心圆</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(<span class="number">200</span>,<span class="number">200</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">"red"</span>; </span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<p><strong>Point</strong></p>
<p>上面用到了路径，实际ctx.arc()相当于是一个lineTo()的一个集合。利用其绘制出一个圆形，最后要关闭(ctx.cloePath())，以及要(stroke())才能完全绘制出该图形。</p>
<h3 id="非完整圆"><a href="#非完整圆" class="headerlink" title="非完整圆"></a>非完整圆</h3><p>如果要绘制一个非完整的圆，比如一个实心半圆，该如何绘制呢？</p>
<p>答案是使用arc方法中的startAngle和endAngle来改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">"red"</span>;</span><br><span class="line">ctx.arc(<span class="number">200</span>,<span class="number">200</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p><strong>空心圆形</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.strokeStyle = <span class="string">"red"</span>;</span><br><span class="line">ctx.arc(<span class="number">400</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI);</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<h2 id="绘制线段"><a href="#绘制线段" class="headerlink" title="绘制线段"></a>绘制线段</h2><ul>
<li>moveTo(x,y):把画笔移动至画布的制定位置，不创建线条</li>
<li>lineTo(x,y):添加一个点(x,y)</li>
<li><p>stroke():按照之前添加的点绘制路径</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.strokeStyle = <span class="string">"red"</span>;<span class="comment">//设置填充色</span></span><br><span class="line">ctx.moveTo(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//将画笔移动至(0,0)</span></span><br><span class="line">ctx.lineTo(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//添加一个点(100,100)</span></span><br><span class="line">ctx.stroke();<span class="comment">//按点绘制路径</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Point</strong></p>
<ul>
<li>如果没有在第一次指定moveTo(x,y)，则第一个lineTo(x,y) == moveTo(x,y)</li>
<li><p>如果在lineTo()后没有使用moveTo()方法，则依次连接，eg：</p>
<p>  ctx.moveTo(0,0);<br>  ctx.lineTo(10,10);<br>  ctx.lineTo(20,20);<br>  ctx.lineTo(30,30);<br>  ctx.stroke();</p>
</li>
</ul>
<p>则画出后是一段从点(0,0)=&gt;(10,10)=&gt;(20,20)=&gt;(30,30)的一段折线。</p>
<ul>
<li>ctx.beginPath():开始一段路径</li>
<li>ctx.closePath()：闭合路径，即canvas会自动将未闭合的线段的首尾连接起来。</li>
</ul>
<p>eg(一个三角形):</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">ctx.lineTo(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">ctx.lineTo(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<p>案例(六边形)：</p>
<p><img src="\images\Canvas基础\六边形.png" alt="六边形"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">var</span> dx = <span class="number">150</span>;<span class="comment">//路径开始x坐标</span></span><br><span class="line">   <span class="keyword">var</span> dy = <span class="number">150</span>;<span class="comment">//路径开始y坐标</span></span><br><span class="line">   <span class="keyword">var</span> s = <span class="number">100</span>;<span class="comment">//边长</span></span><br><span class="line">   ctx.beginPath();<span class="comment">//路径开始</span></span><br><span class="line">   ctx.fillStyle = <span class="string">'pink'</span>;<span class="comment">//设置填充色</span></span><br><span class="line">   ctx.strokeStyle = <span class="string">'rgb(0,0,100)'</span>;<span class="comment">//设置边框颜色</span></span><br><span class="line">   <span class="keyword">var</span> dig = <span class="built_in">Math</span>.PI / <span class="number">3</span>;<span class="comment">//计算偏移角度</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">var</span> x = <span class="built_in">Math</span>.sin(i * dig);<span class="comment">//计算以下个点的x坐标的增量</span></span><br><span class="line">   <span class="keyword">var</span> y = <span class="built_in">Math</span>.cos(i * dig);<span class="comment">//计算下一个点的y坐标的增量</span></span><br><span class="line">   ctx.lineTo(dx + x * s, dy + y * s);<span class="comment">//绘制下一个点</span></span><br><span class="line">   <span class="comment">//console.log( x ,y )</span></span><br><span class="line">   &#125;</span><br><span class="line">   ctx.closePath();<span class="comment">//闭合整个路径</span></span><br><span class="line">   ctx.fill();<span class="comment">//设置填充</span></span><br><span class="line">   ctx.stroke();<span class="comment">//绘制路径</span></span><br></pre></td></tr></table></figure>
<p><strong>Point</strong></p>
<p>这个例子用了一点数学知识，主要是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">Math</span>.sin(i * dig);<span class="comment">//计算以下个点的x坐标的增量</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="built_in">Math</span>.cos(i * dig);<span class="comment">//计算下一个点的y坐标的增量</span></span><br><span class="line">    ctx.lineTo(dx + x * s, dy + y * s);<span class="comment">//绘制下一个点</span></span><br><span class="line">    <span class="comment">//console.log( x ,y )</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其原理是利用了简单的沟股定理，计算下一个点的坐标</p>
<h1 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h1><ul>
<li>let lg = ctx.createLinearGradient(xStart,yStart,xEnd,yEnd)</li>
<li>lg.addColorStop(offset,color)</li>
<li>xSart:渐变开始点的x坐标</li>
<li>yStart：渐变开始点的y坐标</li>
<li>xEnd：渐变结束点的x坐标</li>
<li>yEnd：渐变结束点的y坐标</li>
<li>offset:设定的颜色离渐变结束点的偏移量</li>
<li>color:绘制的颜色</li>
</ul>
<p>eg:<br>        let lg = ctx.createLinearGradient(0,0,100,200);<br>        lg.addColorStop(0,”#E55D87”);<br>        lg.addColorStop(1,”#5FC3E4”);<br>        ctx.fillStyle = lg;<br>        ctx.fillRect(0,0,200,200);</p>
<p><strong>Point</strong></p>
<ul>
<li>线性渐变仅仅是相当于设置填充色，在定义完填充色之后，我们还需要将填充设置为该线性渐变<code>(ctx.fillStyle = gl)</code></li>
<li>由于线性渐变仅仅是设置填充色，所以具体的背景容器还需要我们自己设置，比如设置一个矩形作为容器<code>ctx.fillRect(0,0,200,200)</code></li>
<li>由于渐变背景的坐标是相对于画布，而图形的坐标也是相对于画布，所以在定义背景时，需要注意与图形的坐标搭配以达到需要的效果</li>
</ul>
<h1 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h1><p><img src="\images\Canvas基础\径向渐变.png" alt="径向渐变"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rg = ctx.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)</span><br><span class="line">rg.addCOlorStop(offset,color);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>xSart:发散开始的圆心x坐标</p>
</li>
<li><p>yStart：发散开始的圆心y坐标</p>
</li>
<li><p>radiusStart：发散开始圆的半径</p>
</li>
<li><p>xEnd：发散结束圆心的x坐标</p>
</li>
<li><p>yEnd：发散结束圆心的y坐标</p>
</li>
<li><p>radiusEnd：发散结束圆的半径</p>
</li>
<li><p>offset：设定的颜色结束点的偏移量(0-1)</p>
</li>
<li><p>color:绘制颜色</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g1 = ctx.createRadialGradient(<span class="number">200</span>, <span class="number">150</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">150</span>, <span class="number">200</span>);</span><br><span class="line"> g1.addColorStop(<span class="number">0.1</span>, <span class="string">'#F09819'</span>);</span><br><span class="line"> g1.addColorStop(<span class="number">1</span>, <span class="string">'#EDDE5D'</span>);</span><br><span class="line"> ctx.fillStyle = g1;</span><br><span class="line"> ctx.beginPath();</span><br><span class="line"> ctx.arc(<span class="number">200</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line"> ctx.closePath();</span><br><span class="line"> ctx.fill();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="图形变形"><a href="#图形变形" class="headerlink" title="图形变形"></a>图形变形</h1><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><ul>
<li><p>scale(x,y)</p>
</li>
<li><p>x:x坐标轴按x比例缩放</p>
</li>
<li>y:y坐标轴按y比例缩放</li>
<li>前面参数的是按倍数来衡量的(0.5=&gt;50%,1=&gt;100%,2=&gt;200%)</li>
</ul>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.strokeStyle = <span class="string">"red"</span>;</span><br><span class="line">   ctx.scale(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">   ctx.strokeRect(<span class="number">5</span>,<span class="number">5</span>,<span class="number">25</span>,<span class="number">15</span>);</span><br><span class="line">   ctx.scale(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">   ctx.strokeRect(<span class="number">5</span>,<span class="number">5</span>,<span class="number">25</span>,<span class="number">15</span>);</span><br><span class="line">   ctx.scale(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">   ctx.strokeRect(<span class="number">5</span>,<span class="number">5</span>,<span class="number">25</span>,<span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Point</strong></p>
<ul>
<li>缩放一个图形，先使用<code>ctx.scale(x,y)</code>对画布进行缩放处理，后面再创建要缩放的工具<code>ctx.strokeRect(5,5,25,15);</code>。</li>
<li><p>缩放的原点都是在(0,0)位置。</p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2></li>
<li><p>ratate(angle)</p>
</li>
<li><p>angle:旋转的<strong>角度，以弧度计。</strong></p>
</li>
</ul>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.strokeStyle = <span class="string">"red"</span>;</span><br><span class="line"><span class="comment">// ctx.strokeRect(5,5,200,200);</span></span><br><span class="line">ctx.rotate(<span class="number">20</span>*<span class="built_in">Math</span>.PI/<span class="number">180</span>);<span class="comment">//旋转5°</span></span><br><span class="line">ctx.strokeRect(<span class="number">5</span>,<span class="number">5</span>,<span class="number">200</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Point:</strong></p>
<p>默认的旋转中心是在(0,0)位置。下面介绍如何改变旋转中心。</p>
<h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><ul>
<li><p>translate(x,y)</p>
</li>
<li><p>x:坐标原点向x轴平移x</p>
</li>
<li>y:坐标原点想y轴平移y</li>
</ul>
<p>eg1(以矩形中心为原点旋转)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.strokeStyle = <span class="string">"red"</span>;</span><br><span class="line">    <span class="comment">//以(0,0)为原点绘制一个起点为(200,200)，边长为200的正方形</span></span><br><span class="line">    ctx.strokeRect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="comment">//移动原点至(300,300)，即上面矩形的中心位置</span></span><br><span class="line">    ctx.translate(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">    <span class="comment">//将画布进行一个45°的旋转，得到一个旋转后的图形</span></span><br><span class="line">    ctx.rotate(<span class="number">45</span>*<span class="built_in">Math</span>.PI/<span class="number">180</span>);</span><br><span class="line">    <span class="comment">//将原点坐标改为(0,0)</span></span><br><span class="line">    ctx.translate(<span class="number">-300</span>,<span class="number">-300</span>);</span><br><span class="line">    <span class="comment">//绘制出旋转后的矩形</span></span><br><span class="line">    ctx.strokeRect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>eg2(以矩形中心为原点缩放图形):</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.strokeStyle = <span class="string">"red"</span>;</span><br><span class="line">ctx.strokeRect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.translate(<span class="number">250</span>,<span class="number">250</span>);</span><br><span class="line">ctx.scale(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">ctx.translate(<span class="number">-250</span>,<span class="number">-250</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Point</strong></p>
<p>上面提到的，scale,rotate方法的操作都是对画布而言的，貌似整的canvas的思维都是这样，需要我们有反向思考的能力。</p>
<h1 id="组合图形"><a href="#组合图形" class="headerlink" title="组合图形"></a>组合图形</h1><p><img src="\images\Canvas基础\图像组合.png" alt="径向渐变"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalCompositeOperation = type</span><br></pre></td></tr></table></figure>
<p>后绘制的图形如何与之前的图像叠加渲染，取决于type。下面是type的种类：</p>
<ul>
<li>source-over(默认):在原图形之上绘制(覆盖)。</li>
<li>destination-over:在原图形之下绘制。</li>
<li>source-in:显示原有图形和新图形的交集，新图形在上，所以颜色为新图形颜色</li>
<li>destination-in:显示原图形和新图形的交集，原图形在上，所以颜色为原图形的颜色</li>
<li>source-out:只显示新图形的非交集部分</li>
<li>destination-out:只显示旧图形的非交集部分</li>
<li>source-atop:显示原图形和交集部分，新图形在上，所以交集部分为新图形颜色</li>
<li>destination-atop：显示新图形和交集部分，新图形在上，所以交集部分为新图形颜色</li>
<li>lighter：显示原有图形和新图形，交集部分做颜色叠加</li>
<li>copy:只显示新图形</li>
</ul>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.globalCompositeOperation = <span class="string">"lighter"</span>;  </span><br><span class="line">ctx.fillStyle = <span class="string">"red"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">200</span>);   </span><br><span class="line">ctx.fillStyle = <span class="string">"blue"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Point</strong></p>
<p>该属性与上面的<code>ctx.translate(x,y)</code>一样，一旦作用，就对下面的元素都起作用，如果要还原，请在此使用该属性还原。</p>
<h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><ul>
<li>shadowOffsetX:设置或返回阴影距形状的水平距离(默认值为0)<br>-shadowOffsetY:设置或返回阴影形状的垂直距离(默认值为0)</li>
<li>shadowColor:设置或返回阴影的颜色</li>
<li>shadowBlur:设置或返回阴影的模糊级别(值越大越模糊)</li>
</ul>
<p>eg:<br>    ctx.shadowOffsetX=20;<br>    ctx.shadowColor=”blue”;<br>    ctx.shadowBlur = 50;<br>    ctx.fillStyle = “red”;<br>    ctx.fillRect(100,100,200,200);</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.shadowBlur = <span class="number">0</span>;</span><br><span class="line">ctx.shadowOffsetX = <span class="number">0</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">"yellow"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">400</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Point</strong></p>
<p>相同的是，阴影属性也是对一下的所有图形都生效。要取消阴影效果，必须重置:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.shadowBlur = <span class="number">0</span>;</span><br><span class="line">ctx.shadowOffsetX = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h1 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h1><ul>
<li>drawImage(img,x,y):在画布上定位图像</li>
<li>drawImage(img,x,y,width,height):在画布上定位图像，并规定图像的宽度和高度</li>
<li>drawImage(img,sx,sy,swidth,sheight,x,y,width,height)<ul>
<li>img:规定要使用的图像，画布或视频</li>
<li>sx(可选):开始剪切的x坐标位置</li>
<li>sy(可选):开始剪切的y坐标位置</li>
<li>swidth(可选):被剪切的图像的宽度</li>
<li>sheight(可选):被剪切的图像的高度</li>
<li>x:在画布上放置img的x坐标位置</li>
<li>y:在画布上放置img的y坐标位置</li>
<li>width(可选):要使用的图像的宽度。(拉伸或压缩)</li>
<li>height(可选)：要使用的图像的高度。(拉伸或压缩)</li>
</ul>
</li>
</ul>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">"expi.jpg"</span>;</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ctx.drawImage(img,<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Point</strong></p>
<ol>
<li>img应该是一个img对象，<code>img = new Image()</code>或者是一个Image的DOM标签<code>document.getElementById(&quot;img&quot;)</code>(实际也是一个Image对象，因为在HTML中，每创建一个img标签，就会自动创建一个Image对象。)</li>
<li><p>在使用该标签时，应当使用，Image对象的回调函数onload,否则不能渲染成功，其原因是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"> img.src = <span class="string">"expi.jpg"</span>;</span><br></pre></td></tr></table></figure>
<p>这个过程中，对img.src赋值的时候，可能还没有赋值完成，就进行了<code>ctx.drawImage</code>语句，由于还没赋值完成，此使img.src还是空，所以无法渲染出来。</p>
</li>
</ol>
<h2 id="图像平铺"><a href="#图像平铺" class="headerlink" title="图像平铺"></a>图像平铺</h2><ul>
<li>createPattern(image,type)</li>
</ul>
<p>type:</p>
<ul>
<li>no-repeat:不平铺</li>
<li>repeawt-x:按x轴方向平铺</li>
<li>repeat-y:按y轴方向平铺</li>
<li>repeat：全方向平铺</li>
</ul>
<p>eg:<br>        let img = new Image;<br>        img.src = “beauty.png”;<br>        img.onload = function(){<br>        let pattern = ctx.createPattern(img,”repeat-x”);<br>        ctx.fillStyle = pattern;<br>        ctx.fillRect(10,10,500,500);<br>        }</p>
<p><strong>Point</strong></p>
<ul>
<li>相同的是，必须要配合Image的oload回调函数来使用，道理同上。</li>
</ul>
<h2 id="图像剪切"><a href="#图像剪切" class="headerlink" title="图像剪切"></a>图像剪切</h2><ul>
<li>clip()</li>
</ul>
<p>该函数的使用方法：</p>
<ol>
<li>创建剪切区域:ctx.rect(x,y,width,heigth)</li>
<li>设置剪切部分的填充色:ctx.fillStyle = “pink”</li>
<li>进行填充:ctx.fill();</li>
<li>进行剪切:ctx.clip();</li>
</ol>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">"yellow"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">ctx.rect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">"pink"</span>;</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.clip();</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">"blue"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Point</strong></p>
<p>-一旦剪切了某个区域，则之后的所有绘图都会被限制在被剪切区域内进行（不能访问画布上的其他区域）。我们也可以在使用clip()方法之前通过使用save()方法将之前的画布保存下来,并在任意时间使用restored()方法。</p>
<h1 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h1><ul>
<li>fillText(text,x,y):绘制实心文字<ul>
<li>x:文字的中心点x坐标</li>
<li>y：文字的中心点y坐标</li>
</ul>
</li>
<li>strokeText():绘制文字描边(空心文字)</li>
<li>textAlign：设置或返回文字内容的当前对齐方式(注意：其都是相对于该文字对象的中心)，其值有：<ul>
<li>start:默认。文本在指定的位置开始。</li>
<li>end:文本在指定的位置结束。</li>
<li>left:文本左对齐。</li>
<li>center:文本的中心被放置在指定的位置。</li>
<li>right:文本右对齐。</li>
</ul>
</li>
<li>textBaseline：设置会返回在绘制文本时使用的当前文字基线,其值有：<ul>
<li>Bottom：文本基线是 em 方框的底端。</li>
<li>Top：文本基线是 em 方框的顶端。</li>
<li>Middle：文本基线是 em 方框的正中。</li>
<li>Alphabetic：默认。文本基线是普通的字母基线。</li>
<li>hanging：文本基线是悬挂基线。</li>
</ul>
</li>
<li>font:设置或返回文本内容的当前文字属性</li>
</ul>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.font = <span class="string">"40px Arial"</span>;</span><br><span class="line">ctx.textAlign = <span class="string">"center"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World"</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">ctx.strokeText(<span class="string">"Hello World"</span>,<span class="number">200</span>,<span class="number">300</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ctx.textBaseline);</span><br></pre></td></tr></table></figure>
<p><img src="\images\Canvas基础\textAlign.png" alt="textAlign"><br><img src="\images\Canvas基础\textBaseline.gif" alt="textBaseline"></p>
]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript深入解析2-原型及原型链</title>
    <url>/2019/07/18/javaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%902-%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h1 id="关于原型-prototype"><a href="#关于原型-prototype" class="headerlink" title="关于原型(prototype)"></a>关于原型(prototype)</h1><p>原型可以说是JavaScript设计中最特殊，也可以说是最精髓的设计，他遍布整个JavaScript对象。几乎也是整个JavaScript技术的核心，只有熟悉了原型，才能充分理解JavaScript中的类与委托机制了。<br><a id="more"></a></p>
<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>Q：什么是原型呢？</p>
<p>A：在所有对象中都有一个特殊的<strong>[[Prototype]]属性</strong>，其实就是对其他对象的引用。几乎所有的对象在创建时[[Prototype]]都会被赋予一个非空的值。(注意，部分浏览器将该属性暴露出来，并命名为 __proto__)</p>
<p>Q：什么是原型链呢？</p>
<p>A：如上所说，每一个对象都会有一个[[Prototype]]属性，然而[[Prototype]]属性引用的也是一个对象，这个对象同样也会含有[[Prototype]]属性，这样每一个对象就如同一个链节，一起就组成了一个链，我们称之为<strong>原型链</strong>。</p>
<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>Q：为什么要设计这样一个独特的机制呢？</p>
<p>A：或许不应该对<strong>存在</strong>这个问题如此深究，因为这可能是第一代开发人员的灵光一现，就有了这个特征。但实际上大都认为这是一门<strong>动态编译语言</strong>，或者说是<strong>脚本语言</strong>，所以没有设计类的概念，但为了填补这个概念，就有了原型。但谁也不知道JavaScript会在接下来的几十年中发展的如此蓬勃，程序员们多么希望JavaScript有OOP的概念，于是想方设法的使用原型链来模拟类的行为，<strong>但无论如何，就现在为止，JavaScript底层是没有类的概念的，包括ES6的类，任然是原型的语法糖</strong>。</p>
<h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p>我们了解了什么是原型，为什么会存在原型之后，就要知道我们该如何使用它了。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>我们来看一下创建对象的几种方法。</p>
<ol>
<li><code>let obj = {num : 0}</code></li>
<li><code>let obj = new Object({num : 0}) 或者var obj = Object({num : 0})</code></li>
<li><code>let construt = function(){this.num = 0} =&gt; let obj = new construct()</code></li>
<li><code>let obj0 = {num : 0} =&gt; let obj1 = Object.create(obj0)</code></li>
</ol>
<p>这几种方法创建的对象有所不同，我们还是来解析一下：</p>
<p>1,2：字面量方法，创建的是一个普通对象，其[[Prototype]]指向<code>Object.prototype</code>（大部分对象的原型链最后都指向它）。</p>
<p>3：new操作符：</p>
<p>当我们看到new操作符，一定会想到类，但是JavaScript中的new操作符与传统OOP语言中的new完全不同，JavaScript中的new只是将函数当成一个构造函数来调用。如同上一篇中所说，JavaScript中所有的函数都一样，不存在本质的构造函数，只有被new调用的函数就是构造函数。我们在回顾一下new操作符的执行过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> C(<span class="string">'mw'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">//C &#123;name:'mw'&#125;</span></span><br><span class="line"><span class="comment">//此时obj的__proto__指向的是C.prototype</span></span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个新的对象</li>
<li>将新对象的[[prototype]]设为C.prototype</li>
<li>将新对象设为函数调用的this</li>
<li>如果函数没有返回其他对象，则new操作符调用的函数会自动返回这个新对象，否则则会直接返回函数内的对象</li>
</ol>
<p>4: 使用Object.creat()函数来创建对象，实际上是创建了一个新对象，然后将其[[Prototype]]设置为对应对象，如果不加参数，则[[Prototype]]为Object对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">num</span> : <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__);</span><br><span class="line"><span class="comment">//&#123;num:0,__proto__:Object&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="属性获取，设置与屏蔽"><a href="#属性获取，设置与屏蔽" class="headerlink" title="属性获取，设置与屏蔽"></a>属性获取，设置与屏蔽</h2><p>当我们有了一个对象，我们可能会对他们做一些操作，比如，[[get]],[[set]],或者seal,freeze等等操作。那么这个过程又是什么样的呢？</p>
<p>我们提前需要了解的是：每一个对象的每一个属性都是具有<strong>属性描述</strong>：</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><ul>
<li>configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。</li>
<li>enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。</li>
<li>writable：表示能否修改属性值。默认为true。</li>
<li>value： 包含这个属性的数据值，读属性时，从这个位置读；写属性的时候，把新值保存在这个位置。默认为undefined。</li>
</ul>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><ul>
<li>configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。</li>
<li>enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。</li>
<li>get：读取属性时调用的函数。默认为undefined。</li>
<li>set：写入属性时调用的函数。默认为undefined。</li>
</ul>
<p>值得注意的是：</p>
<ol>
<li>官方来说，只能通过Reflect.defineProperty(obj,proName,proValue)，但是Firefox在最开始指定了__defineGetter__，__defineSetter__，后期Chrome，Opera，Safari也实现了该方法。</li>
<li>在defineProperty()中get,set不能与writable，value，同时设置。</li>
<li>在ES6中，将Object中的很多方法(包括defineProperty…)都放到了Reflect对象中，虽然Object任然包含该方法，但建议使用Reflect对象。</li>
</ol>
<h3 id="属性获取与屏蔽"><a href="#属性获取与屏蔽" class="headerlink" title="属性获取与屏蔽"></a>属性获取与屏蔽</h3><p>思考一下下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">num</span> : <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> str = obj.toString();</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">//"[object Object]"</span></span><br></pre></td></tr></table></figure>
<p>首先我们需要思考的是，我们并没有在obj上定义toString方法，为什么我们能够调用，并且得到一个结果(虽然并不那么漂亮)，我想你肯定猜到了，那是因为obj的原型对象Object拥有这个方法。<strong>所以，我们在或得一个对象的值时，是从链的底端开始查找，顺着原型链，一直查到顶端，如果不存在，返回undefined或者error。如果存在，则返回这个值。</strong>也就是说，我们能够在一个对象中查找到值，并不代表该对象含有该值，很有可能是该对象的原型链上的某个原型对象含有该值。</p>
<p>思考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">getString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="string">'from a'</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line">b.getString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="string">'from b'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.getString());</span><br></pre></td></tr></table></figure>
<p>结果是什么呢？hava a try!</p>
<p>没错，结果是’from b’</p>
<p>这就是我们所说的<strong>属性屏蔽</strong>，<strong>这一切的根源在于：我们是从链底查到链顶的，所以下层的同名属性会优先被获取，一旦引擎获取到该属性，则遍历结束，不会再向下查找。</strong></p>
<h3 id="属性设置与屏蔽"><a href="#属性设置与屏蔽" class="headerlink" title="属性设置与屏蔽"></a>属性设置与屏蔽</h3><p>当我们为一个对象的键赋值时，会发生三种情况：</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.name = <span class="string">'value'</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果在[[Prototype]]链上存在名为name的普通数据访问值，并且被标记为可写(<strong>writale:true</strong>)(默认即为true)，那就会直接在<strong>obj</strong>上添加一个名为name的新属性，它就是<strong>屏蔽属性</strong>。</li>
<li>如果在[[Prototype]]链上存在名为name的普通数据访问值，但是该属性被标记为只读，(<strong>writable:false</strong>)，那么<strong>无法修改已有属性或者在obj上创建屏蔽属性</strong>。如果在严格模式下，会抛出一个错误；否则会忽略该语句。<strong>总之，不会发生屏蔽</strong>。</li>
<li>如果在[[Prototype]]链上存在name并且它是一个setter。那就一定会调用这个setter。name不会被添加到obj上，也不会重新定义setter。</li>
</ol>
<p>屏蔽的发生也许不像我们通常认为，还要联系对象属性的描述符来确定！我们需要记住。</p>
<h4 id="隐式屏蔽"><a href="#隐式屏蔽" class="headerlink" title="隐式屏蔽"></a>隐式屏蔽</h4><p>正如类型转换一样，同样存在<strong>隐式屏蔽</strong>，只要操作对象的属性，都有可能发生隐式屏蔽。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj0 = &#123;<span class="attr">num</span>:<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="built_in">Object</span>.create(obj0);</span><br><span class="line">obj1.num++ <span class="comment">//这里发生了隐式屏蔽！！！</span></span><br></pre></td></tr></table></figure>
<p><strong>只要是[[set]]，都有可能发生隐式屏蔽</strong></p>
<h2 id="修改-Prototype"><a href="#修改-Prototype" class="headerlink" title="修改[[Prototype]]"></a>修改[[Prototype]]</h2><ol>
<li><p>Object.create()，该方法是最适用的方法。即在创建时就设置其prototype。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj0 = &#123;<span class="attr">num</span>:<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="built_in">Object</span>.create(obj0);</span><br><span class="line"><span class="comment">//将obj0设置为obj1的prototype</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>Object.setPrototypeOf()，该方法是ES6新增的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj0 = &#123;<span class="attr">num</span>:<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="built_in">Object</span>.create(obj0);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj0,obj1);</span><br><span class="line"><span class="comment">//把obj1设置为obj0的protoype</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>构造函数方法</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.a = <span class="number">123</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.prototype = <span class="keyword">new</span> F();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>回顾一下上面new操作符，就能想明白。</p>
<h2 id="检测原型链"><a href="#检测原型链" class="headerlink" title="检测原型链"></a>检测原型链</h2><p>我们又该如何检测对象的原型连上存在哪些原型对象呢？</p>
<ol>
<li><p>instance操作符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj instance <span class="built_in">Object</span>);</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><code>__proto__</code>属性，如上所说，大多数浏览器实现了<code>__proto__</code>(在ES6中加入了标准)，在兜底情况时，可以使用这种方法检测。</li>
</ol>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>理解清楚原型链，我们才能清楚理解后面的委托，“类”等等。所以这一部分是基础。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习4-共享和更新项目</title>
    <url>/2022/02/27/git%E5%AD%A6%E4%B9%A04-%E5%85%B1%E4%BA%AB%E5%92%8C%E6%9B%B4%E6%96%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="共享和更新项目"><a href="#共享和更新项目" class="headerlink" title="共享和更新项目"></a>共享和更新项目</h1><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a><code>fetch</code></h2><p>从一个或多个存储库中获取分支和/或标记(统称为“refs”)，以及完成其历史记录所需的对象。关联远程仓库的分支将会被更新。（即将远程仓库的文件同步到本地）</p>
<p>默认情况下，任何指向历史记录的标签也会被获取;其效果是获取指向您感兴趣的分支的标记。此默认行为可以通过使用<code>--tags</code>或<code>--no-tags</code>选项或配置<code>remote.&lt;name&gt;. tagopt</code>。通过使用显式获取标记的refspec，也可以获取不指向您感兴趣的分支的标记。</p>
<p><code>git fetch</code>可以从单个指定的存储库或URL获取数据，也可以从多个存储库同时获取数据(如果给定<code>&lt;group&gt;</code>并且有远程服务)。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>--all</code>：获取所有的远程仓库。</li>
<li><code>-a; --append</code>：在<code>.git/FETCH_HEAD</code>的现有内容中添加引用的ref名称和对象名称。如果没有这个选项，<code>.git/FETCH_HEAD</code>中的旧数据将被覆盖。</li>
<li><code>--atomic</code>：使用原子事务更新本地引用。要么更新所有引用，要么在错误时，不更新引用。</li>
<li><code>--depth=&lt;depth&gt;</code>：限制从每个远程分支历史记录尖端获取指定数量的提交（commit）。</li>
<li><code>--shallow-since=&lt;date&gt;</code>：深化或缩短浅层存储库的历史，以包括<code>&lt;date&gt;</code>之后的所有可达提交。</li>
<li><code>--shallow-exclude=&lt;revision&gt;</code>：深化或缩短浅层存储库的历史，以排除从指定的远程分支或标记可到达的提交。此选项可指定多次。</li>
<li><code>--unshallow</code>：如果原仓库是完整的，则将一个缩短的仓库转变为一个完整的仓库，并且会移除所有加在该仓库上的缩短限制。</li>
<li><code>-p; --prune</code>：在获取之前，删除在远程上已经不再存在的任何远程跟踪引用。如果只是因为默认的标签自动跟踪或<code>--tags</code>选项而获取标签，那么标签就不会被删除。然而，如果获取标签是由于一个显式的refspec。</li>
<li><code>-n; --no-tags</code>：默认情况下，指向从远程存储库下载的对象的标记将被获取并存储在本地。此选项禁用自动下载标记。</li>
<li><code>repository&gt;</code>：“远程”存储库，它是获取或拉取操作的源。这个参数可以是一个URL，也可以是远程服务器的名称。</li>
</ul>
<h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a><code>pull</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…]]</span><br></pre></td></tr></table></figure>
<p>将远程存储库中的更改合并到当前分支中。如果当前分支位于远程的版本之后，那么默认情况下，它将快进当前分支以匹配远程分支。如果当前分支和远程分支已经偏离，用户需要指定如何使用<code>--rebase</code>或<code>--no-rebase</code>协调偏离的分支。</p>
<p><strong>更准确地说，<code>git pull</code>运行带有给定参数的<code>git fetch</code>，然后根据配置选项或命令行标志调用<code>git rebase</code>或<code>git merge</code>来协调分支。</strong></p>
<p><code>&lt;repository&gt;</code>应该是传递给<code>git-fetch</code>的远程存储库的名称。<code>&lt;refspec&gt;</code>可以命名任意的远程引用(例如，标记的名称)，甚至可以命名具有相应远程跟踪分支的引用集合(例如，<code>refs/heads/*:refs/remotes/origin/*</code>)，但通常它是远程存储库中的一个分支的名称。</p>
<p><code>&lt;repository&gt;</code>和<code>&lt;branch&gt;</code>的默认值从当前分支的“remote”和“merge”配置中读取，由<code>git-branch --track</code>设置。</p>
<p>与<code>merge</code>相关的选项</p>
<ul>
<li><p><code>--commit; --no-commit</code>：执行合并并提交结果。这个选项可以用来覆盖<code>--no-commit</code>。只有在合并时才有用。</p>
<p>使用<code>--no-commit</code>，执行合并并在创建合并提交之前停止，给用户一个机会在提交之前检查和进一步调整合并结果。</p>
</li>
<li><p><code>--edit; -e; --no-edit</code>：在提交成功机械性合并前，打开编辑器来编辑自动生成的合并信息。</p>
</li>
<li><p><code>--squash; --no-squash</code>：生成工作树和索引状态，就像发生了一个真正的合并(除了合并信息)，但不实际做一个提交，移动HEAD，或记录<code>$GIT_DIR/MERGE_HEAD</code>(导致下一个git commit命令创建一个合并提交)。这允许你在当前的分支上创建一个单独的提交，它的效果与合并另一个分支相同。</p>
</li>
<li><p><code>--autostash; --no-autostash</code>：在操作开始之前自动创建一个临时<code>stash</code>条目，将其记录在特殊的<code>ref MERGE_AUTOSTASH</code>中，并在操作结束后应用它。这意味着您可以在脏工作树上运行操作。但是，使用时要小心:成功合并后的最终隐藏应用程序可能会导致重要的冲突。</p>
</li>
<li><p><code>-r; --rebase[=false|true|merges|interactive]</code>：当为true时，在获取后将当前分支重设为上游分支的顶部。如果有一个与上游分支对应的远程跟踪分支，并且上游分支在上次获取后被重置基点，则rebase将使用该信息来避免重基非本地更改。</p>
<p>当设置为<code>merge</code>时，使用<code>git rebase --rebase-merge</code>进行rebase，这样本地合并提交就包含在rebase中。</p>
<p><code>false</code>时，将上游分支合并到当前分支。</p>
<p><code>interactive</code>时，启用rebase的交互模式。</p>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a><code>push</code></h2></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;]</span><br><span class="line">	   [--repo=&lt;repository&gt;] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]</span><br><span class="line">	   [-u | --<span class="built_in">set</span>-upstream] [-o &lt;string&gt; | --push-option=&lt;string&gt;]</span><br><span class="line">	   [--[no-]signed|--signed=(<span class="literal">true</span>|<span class="literal">false</span>|<span class="keyword">if</span>-asked)]</span><br><span class="line">	   [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]] [--force-if-includes]]</span><br><span class="line">	   [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…]]</span><br></pre></td></tr></table></figure>
<p>使用本地引用更新远程引用，同时发送完成给定引用所必需的对象。</p>
<p>当命令行没有指定使用<code>&lt;repository&gt;</code>参数推送的位置时，使用<code>branch.*</code>。参考当前分支的远程配置，以确定在何处推送。如果缺少配置，则默认为origin。</p>
<p>当命令行没有指定使用<code>&lt;refspec&gt;…</code>参数或<code>--all</code>，<code>--mirror</code>，<code>--tags</code>选项，命令通过查找<code>remote.*</code>找到默认的<code>&lt;refspec&gt;</code>push配置，如果没有找到，则使用<code>push .default</code>配置来决定推送什么</p>
<p>当命令行和配置文件中都没有指出推送到哪里，默认行为就会被执行，其流程为：当前分支被推送到对应上游分支，但是作为安全保障，如果上游分支不存在与本地同名的分支，则推送会被打断。</p>
<h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p><code>&lt;repository&gt;</code>：<em>：</em>“远程”仓库，它是push操作的目的地。这个参数可以是一个URL，也可以是远程服务器的名称。</p>
</li>
<li><p><code>&lt;refspec&gt;…</code>：指定要用什么源对象更新什么目标引用。<code>&lt;refspec&gt;</code>参数的格式是一个可选的加号+，后面跟着源对象<code>&lt;src&gt;</code>，后面跟着一个冒号:，后面跟着目标ref <code>&lt;dst&gt;</code>。</p>
<p><code>&lt;src&gt;</code>通常是你想推送的分支的名称，但它可以是任意的“SHA-1表达式”，例如master~4或HEAD。</p>
</li>
<li><p><code>--all</code>：推送所有分支(即<code>refs/heads/</code>下的refs);不能与其他<code>&lt;refspec&gt;</code>一起使用。</p>
</li>
<li><p><code>--prune</code>：删除没有本地对应的远程分支。例如，如果本地分支tmp不再存在，则远程分支tmp将被删除。</p>
</li>
<li><p><code>--mirror</code>：为当前仓库添加一个镜像仓库，即本地仓库所作的任何行为都会被同步到镜像仓库，如创建、更新、删除等。也可以在<code>remote.&lt;remote&gt;.mirror</code>中配置。</p>
</li>
<li><p><code>-d; --delete</code>：从远程存储库中删除所有列出的参考文献。这与在所有引用前面加上冒号是一样的。</p>
</li>
<li><p><code>--[no-]atomic</code>：如果可用，在远程端使用原子事务。要么更新所有引用，要么在错误时，不更新引用。如果服务器不支持原子推送，推送将失败。</p>
</li>
<li><p><code>--[no-]force-with-lease; --force-with-lease=&lt;refname&gt;; --force-with-lease=&lt;refname&gt;:&lt;expect&gt;</code>：通常，如果远程仓库不是本地仓库的祖先，则<code>git push</code>会拒绝执行。</p>
<p>如果远程ref的当前值与配置值匹配，则此选项将覆盖此限制。即可以向非祖先仓库推送。</p>
</li>
<li><p><code>-f; --force</code>：通常，该命令拒绝更新不是用于覆盖它的本地ref的祖先的远程ref。此外，当使用<code>--force with-lease</code>选项时，该命令拒绝更新当前值不符合预期值的远程ref。</p>
<p>此标志禁用这些检查，并可能导致远程存储库丢失提交;小心使用。</p>
<p>请注意<code>--force</code>适用于所有被推送的引用，因此将它与<code>push.default</code>设置为匹配或多个推送目的地配置为<code>remote.*</code>一起使用。push可以覆盖当前分支以外的引用。</p>
</li>
<li><p><code>--[no-]force-if-includes</code>：只有当远程跟踪ref的尖端已在本地集成时，才强制更新。</p>
</li>
<li><code>--repo=&lt;repository&gt;</code>：这个选项相当于<code>&lt;repository&gt;</code>参数。如果这两个参数都指定了，命令行参数优先。</li>
<li><code>-u; --set-upstream</code>：对于每个最新或成功推送的分支，添加<code>upstream (tracking)</code>引用，该引用由无参数的<code>git-pull</code>和其他命令使用。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li><code>git push</code>：类似于<code>git push &lt;remote&gt;</code>，其中<code>&lt;remote&gt;</code>是当前分支的远端(或当如果没有为当前分支配置远端，即指<code>origin</code>)。</li>
<li><code>git push origin</code>：在不进行其他配置的情况下，将当前分支推送到已配置的上游(<code>branch.&lt;name&gt;</code>)。合并配置变量)，如果它与当前分支有相同的名称，并且错误输出而不推其他。</li>
<li><code>git push origin :</code>：将匹配的分支推到<code>origin</code>。</li>
<li><code>git push origin master</code>：在源库中找到一个与<code>master</code>匹配的ref(最有可能的是，它会找到<code>ref /heads/master</code>)，然后用它更新源库中相同的ref(例如<code>ref /heads/master</code>)。如果master远程不存在，则会创建它。</li>
<li><code>git push origin HEAD</code>：将当前分支推到远程上相同名称的方便方法。</li>
<li><code>git push origin HEAD:master</code>：将当前分支推到origin仓库中匹配master的远程ref。这种形式可以方便地推送当前的分支，而无需考虑它的本地名称。</li>
<li><code>git push origin :experimental</code>：在origin仓库中找到一个匹配<code>experimental</code>的引用(例如<code>refs/heads/experimental</code>)，并<strong>删除</strong>它。</li>
<li><code>git push origin +dev:master</code>：使用dev分支更新origin仓库的master分支，允许非快进更新。这可能会在origin仓库中留下未引用的提交。</li>
</ul>
<h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a><code>remote</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote [-v | --verbose]</span><br><span class="line">git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=(fetch|push)] &lt;name&gt; &lt;URL&gt;</span><br><span class="line">git remote rename &lt;old&gt; &lt;new&gt;</span><br><span class="line">git remote remove &lt;name&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)</span><br><span class="line">git remote <span class="built_in">set</span>-branches [--add] &lt;name&gt; &lt;branch&gt;…</span><br><span class="line">git remote get-url [--push] [--all] &lt;name&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</span><br><span class="line">git remote <span class="built_in">set</span>-url --add [--push] &lt;name&gt; &lt;newurl&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-url --delete [--push] &lt;name&gt; &lt;URL&gt;</span><br><span class="line">git remote [-v | --verbose] show [-n] &lt;name&gt;…</span><br><span class="line">git remote prune [-n | --dry-run] &lt;name&gt;…</span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…]</span><br></pre></td></tr></table></figure>
<p>管理当前分支追踪的远程仓库。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>add</code>：为<code>&lt;URL&gt;</code>的存储库添加一个名为<code>&lt;name&gt;</code>的远程服务器。然后，命令<code>git fetch &lt;name&gt;</code>可以用来创建和更新远程跟踪分支<code>&lt;name&gt;/&lt;branch&gt;</code>。<ul>
<li>使用-f选项，<code>git fetch &lt;name&gt;</code>将在远程信息建立之后立即运行。</li>
<li>使用<code>--tags</code>选项，<code>git fetch &lt;name&gt;</code>从远程仓库导入每个标签。</li>
<li>使用<code>--no-tags</code>选项，<code>git fetch &lt;name&gt;</code>不从远程仓库导入标签。</li>
</ul>
</li>
<li><code>rename</code>：将远程仓库的名字从<code>&lt;old&gt;</code>更改到<code>&lt;new&gt;</code>。所有远程跟踪分支和远程的配置设置都会被更新。</li>
<li><code>remove; rm</code>：移除名为<code>&lt;name&gt;</code>的远程仓库。移除所有远程跟踪分支和远程配置设置。</li>
<li><code>set-head</code>：设置或删除指定远程的默认分支(即<code>-ref refs/remotes/&lt;name&gt;/HEAD</code>的目标)。不需要为远程设置默认分支，但允许指定远程的名称来代替特定的分支。例如，如果origin的默认分支设置为master，那么origin可以在你通常指定<code>origin/master</code>的任何地方指定。</li>
<li><code>set-branches</code>：更改指定远程跟踪的分支列表。这可用于在远程的初始设置之后跟踪可用远程分支的子集。命名分支将被解释为git remote add命令行上指定的-t选项。</li>
<li><code>get-url</code>：检索远程服务器的url。<code>insteadOf</code>和<code>pushInsteadOf</code>的配置在这里展开。默认情况下，只列出第一个URL。</li>
<li><code>set-url</code>：更改远程的url。为匹配<code>regex &lt;oldurl&gt;</code>的remote <code>&lt;name&gt;</code>设置第一个URL(如果没有给出<code>&lt;oldurl&gt;</code>的第一个URL)为<code>&lt;newurl</code>&gt;。如果<code>&lt;oldurl&gt;</code>不匹配任何URL，则会发生错误，不做任何更改。</li>
<li><code>show</code>：提供有关远程仓库<code>&lt;name&gt;</code>的一些信息。</li>
<li><code>prune</code>：删除与<code>&lt;name&gt;</code>关联的过时引用。默认情况下，删除<code>&lt;name&gt;</code>下陈旧的远程跟踪分支，但根据全局配置和远程的配置，我们甚至可能删除尚未推送到那里的本地标记。等价于<code>git fetch --prune &lt;name&gt;</code>，除非不会获取新的引用。</li>
<li><code>update</code>：在存储库中获取由remotes定义的远程或远程组的更新。<code>&lt;group&gt;</code>。如果在命令行上既没有指定group，也没有指定remote，则使用配置参数<code>remots .default</code>;如果没有定义<code>remotes.default</code>，则所有没有配置参数<code>remote.&lt;name&gt;</code>。<code>skipDefaultUpdate设</code>置为true将被更新。</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>共享和更新项目</tag>
      </tags>
  </entry>
  <entry>
    <title>javaee之hibernate框架总结</title>
    <url>/2019/08/08/javaee%E4%B9%8Bhibernate%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hibernate目前使用的还是比较多，虽然不及mybatis。</p>
<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Hibernate工作在javaEE三层结构中的dao层，对数据库进行crud操作，其核心思想是orm（object relational mapping，对象关系映射），并且Hibernate支持多种查询方式，包括HQL，QBC,SQL三种方式。</p>
<ul>
<li>orm<ul>
<li>让实体类和数据库表进行一一对应关系</li>
<li>让实体类首先和数据库表对应</li>
<li>让实体类属性 和 表里面字段对应</li>
<li>不需要直接操作数据库表，而操作表对应实体类对象</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Hibernate的核心配置文件有如下要求：</p>
<ul>
<li>必须在src下</li>
<li>必须为hibernate.cfg.xml</li>
</ul>
<h3 id="配置核心文件"><a href="#配置核心文件" class="headerlink" title="配置核心文件"></a>配置核心文件</h3><ol>
<li><p>引入约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC&quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>配置信息</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line">	&lt;session-factory&gt;</span><br><span class="line">		&lt;!-- 第一部分： 配置数据库信息 必须的 --&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;&#x2F;hibernate_day01&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 第二部分： 配置hibernate信息  可选的--&gt;</span><br><span class="line">	&lt;!-- 输出底层sql语句 --&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;!-- 输出底层sql语句格式 --&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;!-- hibernate帮创建表，需要配置之后 </span><br><span class="line">		update: 如果已经有表，更新，如果没有，创建</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;!-- 配置数据库方言</span><br><span class="line">		在mysql里面实现分页 关键字 limit，只能使用mysql里面</span><br><span class="line">		在oracle数据库，实现分页rownum</span><br><span class="line">		让hibernate框架识别不同数据库的自己特有的语句</span><br><span class="line">	 --&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 第三部分： 把映射文件放到核心配置文件中 必须的--&gt;</span><br><span class="line">	&lt;mapping resource&#x3D;&quot;cn&#x2F;itcast&#x2F;entity&#x2F;User.hbm.xml&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;session-factory&gt;</span><br><span class="line">&lt;&#x2F;hibernate-configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>值得注意的是：</p>
<ol>
<li>配置数据库信息部分与jdbc部分的配置信息一致</li>
<li><code>hibernate.show_sql</code>： 在编译时控制台输出生成的SQL语句</li>
<li><code>hibernate.format_sql</code> : 在上面的属性开启的前提之下输出格式化之后的SQL语句</li>
<li><code>hibernate.hbm2ddl.auto</code> : 配置数据库方言<br>在mysql里面实现分页 关键字 limit，只能使用mysql里面<br>在oracle数据库，实现分页rownum<br>让hibernate框架识别不同数据库的自己特有的语句</li>
</ol>
<h3 id="配置映射文件"><a href="#配置映射文件" class="headerlink" title="配置映射文件"></a>配置映射文件</h3><p>映射文件是一个表与实体的配置映射</p>
<ul>
<li>命名没有确定规则</li>
<li>位置也没有确定位置</li>
</ul>
<ol>
<li><p>引入约束</p>
<p> &lt;!DOCTYPE hibernate-configuration PUBLIC<br> “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br> “<a href="http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</a></p>
</li>
<li><p>配置映射关系</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hibernate-mapping&gt;</span><br><span class="line">	&lt;class name&#x3D;&quot;priv.mw.dao&quot; table&#x3D;&quot;t_user&quot;&gt;</span><br><span class="line">		&lt;id name&#x3D;&quot;uid&quot; column&#x3D;&quot;uid&quot;&gt;</span><br><span class="line">			&lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">		&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;password&quot; column&#x3D;&quot;username&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;class&gt;	</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>值得注意的是：</p>
<ol>
<li><code>hibernate-mapping</code><ol>
<li>package:填写包名，如果此处填写了完整的包名，则后面class的name属性只需要填写class名字。否则class的name属性则需要填写完整的名字，及包含包名的类名。</li>
</ol>
</li>
<li><p><code>class</code></p>
<ol>
<li>name：填写类名（全路径或名字）</li>
<li>table：数据库中表名。（orm中表与类一一对应）</li>
</ol>
</li>
<li><p><code>id</code>：每一张表必须要有一个唯一的属性。</p>
<ol>
<li>name：类中属性的名字</li>
<li>column：为表中列的名字</li>
</ol>
</li>
<li><code>property</code>:表中的属性<ol>
<li>name:类中的属性名</li>
<li>column：表中的列名</li>
</ol>
</li>
</ol>
<p>值得注意的是：</p>
<ul>
<li>id或property中的column是可选的，如果不填，则默认与name属性相同。</li>
</ul>
<h2 id="实体类的编写规则"><a href="#实体类的编写规则" class="headerlink" title="实体类的编写规则"></a>实体类的编写规则</h2><ol>
<li>实体类中的属性是私有的</li>
<li>私有属性使用公开的set和get方法</li>
<li>要求实体类有属性作为唯一值(一般使用id值)</li>
<li>实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类，其目的是Integer score = null。可以表示不存在这个值，而基本类不能为null。</li>
</ol>
<h3 id="主键的生成策略"><a href="#主键的生成策略" class="headerlink" title="主键的生成策略"></a>主键的生成策略</h3><ul>
<li>native：自动增长</li>
<li>uuid：uuid算法</li>
</ul>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="session方式"><a href="#session方式" class="headerlink" title="session方式"></a>session方式</h3><ol>
<li>加载核心配置文件</li>
<li>加载SessionFactory对象</li>
<li>使用SessionFactory对象创建session对象</li>
<li>开启事务</li>
<li>开始写具体逻辑，crud操作</li>
<li>提交事务</li>
<li>关闭资源</li>
</ol>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 加载hibernate核心配置文件</span></span><br><span class="line">    <span class="comment">//这一步从src中查找hibernate.cfg.xml</span></span><br><span class="line">   Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">    cfg.configure();</span><br><span class="line">    <span class="comment">//2. 创建SessionFactory对象</span></span><br><span class="line">    <span class="comment">//同时读取映射文件，创建表格</span></span><br><span class="line">   SessionFactory sessionFactory = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 创建Session对象</span></span><br><span class="line">   Session session = session.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 开启事物</span></span><br><span class="line">   Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 写入具体的crud操作</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"李雷"</span>);</span><br><span class="line">    user.setPassword(<span class="string">'123'</span>);</span><br><span class="line">    user.setAddress(<span class="string">"日本"</span>);</span><br><span class="line">    session.save(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 提交事务</span></span><br><span class="line">   tx.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 关闭资源</span></span><br><span class="line">    session.close();</span><br><span class="line">    sessionFactory.close();</span><br></pre></td></tr></table></figure>
}
</code></pre><h4 id="session对象导航查询"><a href="#session对象导航查询" class="headerlink" title="session对象导航查询"></a>session对象导航查询</h4><p>常用的方法：</p>
<ol>
<li>get():通过OID 从数据库中抓取数据，并把数据加载到一个新实例对象上。</li>
<li>save():执行insert语句，当数据库存在这条记录时，会抛出异常。</li>
<li>saveOrUpdate():如果数据库中不存在该数据，则执行insert语句，如果存在则执行更新操作。</li>
<li>update():当数据库中存在这条记录时，Hibernate 总会执行一条SQLUPDATE 语句；当数据库中不存这条记录时，就会抛出异常。</li>
<li>delete():当数据库中存在这条记录时，Hibernate 总会执行一条SQLDELETE 语句；当数据库中不存这条记录时，就会抛出异常。</li>
<li>load():该方法与get相同，但是不会立即去查询数据库，而是等待需要使用该数据时才去查询。比如用ID查询ID，get方法任然回去查询数据库，而load则直接返回使用的ID，不去查询数据库。</li>
</ol>
<h4 id="实体对象三种状态"><a href="#实体对象三种状态" class="headerlink" title="实体对象三种状态"></a>实体对象三种状态</h4><ol>
<li>瞬时状态(Transident):如果对象从未与Session对象关联过，称该对象处于瞬时状态（或临时状态）。</li>
<li>持久状态(Persisdent):如果对象与Session对象关联起来，且该对象对应到数据库记录，则称该对象处于持久化状态。比如通过get获取的对象。</li>
<li>游离状态(Detached)：当持久化对象的Session关闭后，这个对象就会从持久化状态改变成游离状态。</li>
</ol>
<h3 id="HQL方式"><a href="#HQL方式" class="headerlink" title="HQL方式"></a>HQL方式</h3><p>example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from Customer where name=?"</span>);</span><br><span class="line">query.setParameter(<span class="string">"mw"</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>条件查询：</p>
<p> from Customer c where c.cid=? and c.custName=?</p>
</li>
<li><p>模糊查询</p>
<p> from Customer c where s.custName like ?</p>
</li>
<li><p>排序查询</p>
<p> from Customer order by cid desc</p>
</li>
<li><p>分页查询</p>
<p> Query query = session.createQuery(“from Customer”);</p>
<p> query.setFirstResult(0);<br> query.setMaxReaults(3);</p>
<p> List<Customer> list = query.list();</p>
</li>
<li><p>投影查询:查询不是所有字段值，而是部分字段的值</p>
<p> Query query = session.createQuery(“select cusName from Customer”);</p>
<p> List<Object> list = query.list();</p>
<p> for(Object object : list){</p>
<pre><code>Systom.out.println(Object);
</code></pre><p> }</p>
</li>
<li><p>聚集函数使用</p>
</li>
</ol>
<pre><code>Query query = session.createQuery(&quot;select count(*) from Customer&quot;);

object obj = query.uniqueResult();

Long lobj = (Long)obj;
int count = lobj.intValue();
</code></pre><ol start="7">
<li><p>内连接查询（返回list）：选取两张表的外键相同的数据返回。</p>
<p> Query query = session.createQuery(“from Customer c inner join c.setLinkMan”)</p>
</li>
<li><p>迫切内连接（返回对象）</p>
<pre><code>Query query = session.createQuery(&quot;from Customer c inner join fetch  c.setLinkMan&quot;)
</code></pre></li>
<li><p>左外连接（返回list）：返回左侧表中的所有数据以及右侧与之外键相同的的数据。</p>
<p> Query query = session.createQuery(“from  Customer  c  left  outer  join  c.setLinkMan”);</p>
</li>
<li><p>迫切左外连接（返回对象）</p>
<pre><code>Query query = session.createQuery(&quot;from  Customer  c  left  outer  join fetch c.setLinkMan&quot;);
</code></pre></li>
<li><p>右外连接：返回左右侧表中的所有数据以及左侧与之外键相同的的数据。</p>
<p>Query query = session.createQuery(“from Customer c right outer join s.setLinkMan”); </p>
</li>
</ol>
<h3 id="QBC方式"><a href="#QBC方式" class="headerlink" title="QBC方式"></a>QBC方式</h3><p>调用Criteria的方法实现查询</p>
<ol>
<li><p>查询所有</p>
<p> Criteria criteria = session.createCriteria(Customer.class);</p>
<p> List<Customer> list = criteria.list();</p>
</li>
<li><p>条件查询</p>
<p> Criteria criteria = session.createCriteria(Customer.class);</p>
<p> cretera.add(Restrictions.eq(“cid”,1));<br> critera.add(Restrictions.eq(“custName”,”someone”));</p>
<p> List<Customer> list = criteria.list();</p>
<p> cretiria.add(Restrictions.like(“custName”,”%s%”));</p>
</li>
<li><p>排序查询</p>
<p> Criteria criteria = session.createCriteria(Customer.class);</p>
<p> cretiria.addOrder(Order.desc(“cid”));</p>
</li>
<li><p>分页查询</p>
<p> Criteria criteria = session.createCriteria(Customer.class);</p>
<p> criteria.setFirstResult(0);<br> criteria.setMaxResult(3);</p>
</li>
<li><p>统计查询</p>
<p> Criteria criteria = session.createCriteria(Customer.class);</p>
<p> criteria.setProjection(Projections.rowCount());</p>
<p> Object obj = criteria.uniqueResult();</p>
<p> Long lobj = (Long) obj;</p>
<p> int count = lobj.intValue;</p>
</li>
<li><p>离线查询：不通过session对象来创建查询对象，即可以在dao层session对象关闭后也能执行查询。一般用在多条件查询直接在service层进行离线查询。</p>
<p> DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class);</p>
<p> Criteria criteria = detachedCriteria.getExecutableCriteria(session);</p>
<p> List<Customer> list = criteria.list();</p>
</li>
</ol>
<h2 id="hibernate一对多操作"><a href="#hibernate一对多操作" class="headerlink" title="hibernate一对多操作"></a>hibernate一对多操作</h2><p>这里的一对多其实就是SQL中一对多的概念，不过我们在学习如何在hibernate中来使用这个概念。</p>
<p>以客户，联系人为例：</p>
<ol>
<li><p>创建两个实体类，客户、联系人</p>
</li>
<li><p>让连个实体之间相互表示，即将对方对象作为一个自己的一个私有属性，并设置set,get方法。</p>
<ol>
<li><p>在客户实体类里面表示多个联系人</p>
<p>private Set<LinkMan> setLinkMan = new HashSet<LinkMan>();</p>
<p>public Set<LinkMan> getSetLinkMan(){<br> return setLinkMan;<br>}</p>
<p>public void getSetLinkMan(Set<LinkMan> setLinkMan){<br> this.setLinkMan = setLinkMan;<br>}</p>
</li>
<li><p>在联系人实体类里面表示所属客户</p>
<p>private Customer customer;</p>
<p>public Customer getCustomer(){<br> return customer;<br>}</p>
<p>public void setCustomer(Customer customer){<br> this.customer = customer;<br>}</p>
</li>
</ol>
</li>
<li><p>配置客户映射关系<br> //在客户映射文件中，表示联系人<br> //使用set标签表示所有联系人<br> //set中name为联系人中的set集合名称<br> //column为外键名称</p>
 <set name="setLinkMan"><br>     //class中写联系人的实体全路径<br>     <key column="clid"></key><br>     <one-to-many class="cn.itcast.entity.LinkMan"><br> </set>
</li>
<li><p>配置联系人映射文件</p>
<p> //name：在联系人实体中的客户属性的名字<br> //class：联系人class的全路径<br> //column：外键名称<br> <many-to-one name="customer" class="cn.itcast.entity.Customer" column="clid"><br> <many-to-one></p>
</li>
<li><p>配置核心配置文件</p>
</li>
</ol>
<p>resource：映射文件的路径名称</p>
<pre><code>&lt;mapping resource=&quot;cn/itcast/entuty/Customer.hbm.xml&quot;&gt;
&lt;mapping resource=&quot;cn/itcast/entuty/LinkMan.hbm.xml&quot;&gt;
</code></pre><h3 id="一对多级联保存"><a href="#一对多级联保存" class="headerlink" title="一对多级联保存"></a>一对多级联保存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">customer.setCustName(<span class="string">"百度"</span>);</span><br><span class="line">customer.setCustLevel(<span class="string">"普通客户"</span>);</span><br><span class="line">customer.setCustSource(<span class="string">"网络"</span>);</span><br><span class="line">customer.setCustPhone(<span class="string">"110"</span>);</span><br><span class="line">customer.setCustMobile(<span class="string">"999"</span>);</span><br><span class="line"></span><br><span class="line">LinkMan linkman = <span class="keyword">new</span> LinkMan();</span><br><span class="line">linkman.setLkm_name(<span class="string">"小宏"</span>);</span><br><span class="line">linkman.setLkm_gender(<span class="string">"男"</span>);</span><br><span class="line">linkman.setLkm_phone(<span class="string">"911"</span>);</span><br><span class="line"><span class="comment">//2 把联系人放到客户里面</span></span><br><span class="line">customer.getSetLinkMan().add(linkman);</span><br><span class="line"><span class="comment">//3 保存客户</span></span><br><span class="line">session.save(customer);</span><br></pre></td></tr></table></figure>
<h3 id="一对多级联删除"><a href="#一对多级联删除" class="headerlink" title="一对多级联删除"></a>一对多级联删除</h3><p>删除某个客户，把客户里面所有的联系人删除</p>
<p>需在set中配置cascade属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;set name=<span class="string">"setLinkMan"</span> cascade=<span class="string">"save-update,delete"</span>&gt;</span><br><span class="line"></span><br><span class="line">Customer customer = session.get(CUstomer<span class="class">.<span class="keyword">class</span>,3)</span>;</span><br><span class="line"></span><br><span class="line">session.delete(customer);</span><br></pre></td></tr></table></figure>
<h3 id="一对多级联更新"><a href="#一对多级联更新" class="headerlink" title="一对多级联更新"></a>一对多级联更新</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id查询Lucy联系人，客户百度</span></span><br><span class="line">Customer baidu = session.get(Customer<span class="class">.<span class="keyword">class</span>,1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置持久态对象</span></span><br><span class="line"></span><br><span class="line">Customer lucy = session.get(LinkMan<span class="class">.<span class="keyword">class</span>,2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把联系人放入客户对象中</span></span><br><span class="line">baidu.getSetLinkMan().add(lucy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把客户放到联系人中</span></span><br><span class="line">lucy.setCustomer(baidu);</span><br></pre></td></tr></table></figure>
<p>值得注意的是：</p>
<p>在默认转态下，两个对象都会维护这个关系。所以会执行两次SQL语句。为了解决这个问题，可以在set中配置inverse属性，让某一方放弃维护。</p>
<ul>
<li>inverse:<ul>
<li>false不放弃维护</li>
<li>true放弃维护</li>
</ul>
</li>
</ul>
<h2 id="hibernate多对多"><a href="#hibernate多对多" class="headerlink" title="hibernate多对多"></a>hibernate多对多</h2><p>实际上我们在比较少用多对多关系，会将其转化为两个一对多关系。</p>
<p>以用户和角色为例：</p>
<ol>
<li><p>创建实体类，用户和角色</p>
</li>
<li><p>让两个实体类相互表示</p>
<ol>
<li><p>一个用户有多个角色，使用set集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Private Set&lt;Role&gt; setRole = <span class="keyword">new</span> HashSet&lt;Role&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Set&lt;Role&gt; <span class="title">getSetRole</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> setRole;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSetRole</span><span class="params">(Set&lt;Role&gt; setRole)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setRole = setRole;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>. 一个角色有多个用户，使用set集合</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span> Set&lt;User&gt; setUser = <span class="keyword">new</span> HashSet&lt;User&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Set&lt;User&gt; <span class="title">getSetUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> setUser;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSetUser</span><span class="params">(Set&lt;User&gt; setUser)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setUser =setUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>配置映射关系</p>
<ol>
<li><p>在用户里面表示所有角色，使用set标签</p>
<p><set name="setRole" table="user_role"><br> <key column="userid"></key><br> <many-to-many class="cn.itcast.manytomany.Role" column="roleid"></many-to-many></p>
<set>
</li>
<li><p>在角色中表示所有用户，使用set标签</p>
<set name="setUser" table="user_role"><br> <key column="userid"></key><br> <many-to-many class="cn.idcast.manytomany.User" column="userid"></many-to-many><br></set>
</li>
</ol>
</li>
<li><p>在核心配置文件中引入映射文件</p>
<p> <mapping resource="cn/itcast/manytomany/User.hbm.xml"></p>
 <mapping resource="cn/itcast/manytomany/Role.hbm.xml">

</li>
</ol>
<h3 id="多对多级联保存"><a href="#多对多级联保存" class="headerlink" title="多对多级联保存"></a>多对多级联保存</h3><p>任然需要在set中配置cascade</p>
<pre><code>&lt;set name=&quot;setRole&quot; table=&quot;user_role&quot; cascade=&quot;save-update,delete&quot;&gt;
</code></pre><p>实体类中代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user1 = <span class="keyword">new</span> User();</span><br><span class="line">user1.setUser_name(<span class="string">"lucy"</span>);</span><br><span class="line">user1.setUser_password(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">User user2 = <span class="keyword">new</span> User();</span><br><span class="line">user2.setUser_name(<span class="string">"mary"</span>);</span><br><span class="line">user2.setUser_password(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">Role r1 = <span class="keyword">new</span> Role();</span><br><span class="line">r1.setRole_name(<span class="string">"总经理"</span>);</span><br><span class="line">r1.setRole_memo(<span class="string">"总经理"</span>);</span><br><span class="line"></span><br><span class="line">Role r2 = <span class="keyword">new</span> Role();</span><br><span class="line">r2.setRole_name(<span class="string">"秘书"</span>);</span><br><span class="line">r2.setRole_memo(<span class="string">"秘书"</span>);</span><br><span class="line"></span><br><span class="line">Role r3 = <span class="keyword">new</span> Role();</span><br><span class="line">r3.setRole_name(<span class="string">"保安"</span>);</span><br><span class="line">r3.setRole_memo(<span class="string">"保安"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 建立关系，把角色放到用户里面</span></span><br><span class="line"><span class="comment">// user1 -- r1/r2</span></span><br><span class="line">user1.getSetRole().add(r1);</span><br><span class="line">user1.getSetRole().add(r2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// user2 -- r2/r3</span></span><br><span class="line">user2.getSetRole().add(r2);</span><br><span class="line">user2.getSetRole().add(r3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 保存用户</span></span><br><span class="line">session.save(user1);</span><br><span class="line">session.save(user2);</span><br></pre></td></tr></table></figure>
<h3 id="多对多级联删除"><a href="#多对多级联删除" class="headerlink" title="多对多级联删除"></a>多对多级联删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;set name=<span class="string">"setRole"</span> table=<span class="string">"user_role"</span> cascade=<span class="string">"save-update,delete"</span>&gt;</span><br><span class="line"></span><br><span class="line">User user = session.get(User<span class="class">.<span class="keyword">class</span>,1)</span>;</span><br><span class="line">session.delete(user);</span><br></pre></td></tr></table></figure>
<h3 id="多对多级联更新"><a href="#多对多级联更新" class="headerlink" title="多对多级联更新"></a>多对多级联更新</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User lucy = session.get(User<span class="class">.<span class="keyword">class</span>,1)</span>;</span><br><span class="line">Role role = session.get(Role<span class="class">.<span class="keyword">class</span>,1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为用户添加角色</span></span><br><span class="line">lucy.getSetRole().add(role);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把用户角色删除</span></span><br><span class="line">lucy.getSetRole().remove(role);</span><br></pre></td></tr></table></figure>
<h2 id="hibernate缓存"><a href="#hibernate缓存" class="headerlink" title="hibernate缓存"></a>hibernate缓存</h2><p>hibernate为了增加查询效率，建立了缓存机制。即在查询到某个数据后，则将其存储到内存中，下一次查询时直接获取内存中的数据，不用向数据库查询，直接获取，加快查询速度。</p>
<ol>
<li>hibernate的一级缓存默认打开的</li>
<li><p>hibernate的一级缓存使用范围，是session范围，3. hibernate的一级缓存中，存储数据必须 持久态数据</p>
<h2 id="hibernate事务"><a href="#hibernate事务" class="headerlink" title="hibernate事务"></a>hibernate事务</h2><p>与SQL的事务一致，保证一系列工作的全部执行。具有以下特性：</p>
</li>
<li><p>原子性： 确保工作单元中的所有操作都成功完成; 否则，该事务被中止的故障点，操作回滚到操作之前的状态。</p>
</li>
<li>一致性：确保数据库正确后成功提交事务更改状态。</li>
<li>隔离性：事务操作彼此独立和透明。</li>
<li>持久性：可确保提交的事务的结果或仍然存在系统故障的情况下的作用。</li>
</ol>
<p>try {<br>  开启事务<br>  提交事务<br>}catch() {<br>  回滚事务<br>}finally {<br>  关闭<br>}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line">	Session session = <span class="keyword">null</span>;</span><br><span class="line">	Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		sessionFactory = HibernateUtils.getSessionFactory();</span><br><span class="line">		session = sessionFactory.openSession();</span><br><span class="line">		<span class="comment">//开启事务</span></span><br><span class="line">		tx = session.beginTransaction();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//添加</span></span><br><span class="line">		User user = <span class="keyword">new</span> User();</span><br><span class="line">		user.setUsername(<span class="string">"小马"</span>);</span><br><span class="line">		user.setPassword(<span class="string">"250"</span>);</span><br><span class="line">		user.setAddress(<span class="string">"美国"</span>);</span><br><span class="line">		</span><br><span class="line">		session.save(user);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//提交事务</span></span><br><span class="line">		tx.commit();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="comment">//回滚事务</span></span><br><span class="line">		tx.rollback();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">//关闭操作</span></span><br><span class="line">		session.close();</span><br><span class="line">		sessionFactory.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>session.beginTransaction()</code>获取<code>Transaction</code>对象。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这个说明只是一个简单的概述，根据黑马程序员2016年版的笔记总结而来，肯定不是全部的，但是这个足够进行简单的操作。</p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JavaEE</tag>
        <tag>SSH</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>javaee之spring框架总结</title>
    <url>/2019/08/09/javaee%E4%B9%8Bspring%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>spring作为目前最流行，应用最广泛的后端框架，它有着许多优点与特色，比如应用它IOC（控制翻转）的功能以及spring内部的封装，可以与hibernate，struts进行整合，这里只是简单的介绍其主要功能。</p>
<a id="more"></a>
<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="IOC内部原理"><a href="#IOC内部原理" class="headerlink" title="IOC内部原理"></a>IOC内部原理</h3><p>IOC内部使用了映射的原理：</p>
<pre><code>&lt;bean id = &quot;userService&quot; class=&quot;cn.itcast.UserService&quot;/&gt;
</code></pre><p>内部原理如下：</p>
<pre><code>//解析dom4j解析xml文件得到class属性值
String classValue = &quot;class属性值&quot;;
//使用反射创建类对象
Class clazz = Class.forName(classValue);
//创建类对象
UserService service = clazz.newInstance();
return service;
</code></pre><h3 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h3><h4 id="类的无参构造方式"><a href="#类的无参构造方式" class="headerlink" title="类的无参构造方式"></a>类的无参构造方式</h4><pre><code>&lt;bean id=&quot;user&quot; calss=&quot;cn.itcast.ioc.User&quot;&gt;&lt;/bean&gt;
</code></pre><h4 id="类的静态工厂方法"><a href="#类的静态工厂方法" class="headerlink" title="类的静态工厂方法"></a>类的静态工厂方法</h4><p>类方法：</p>
<pre><code>public class Bean2Factory{
    public static Bean2 getBean2(){
        return new Bean2();
    }
}
</code></pre><p>配置文件：</p>
<pre><code>&lt;bean id=&quot;bean2&quot; class=&quot;cn.itcast.bean.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt;
</code></pre><h4 id="类的实例工厂方法"><a href="#类的实例工厂方法" class="headerlink" title="类的实例工厂方法"></a>类的实例工厂方法</h4><p>类方法：</p>
<pre><code>public class Bean3Factory{
    public Bean3 getBean3(){
        return new Bean3();
    }
}
</code></pre><p>配置文件：</p>
<pre><code>&lt;bean id=&quot;bean3Factory&quot; class=&quot;cn.itcast.bean.Bean3Factory&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;&gt;
</code></pre><h4 id="获取实例化对象"><a href="#获取实例化对象" class="headerlink" title="获取实例化对象"></a>获取实例化对象</h4><pre><code>//加载配置文件
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);

//获取实例
User user = (User) context.getBean(&quot;user&quot;);
</code></pre><h3 id="Bean标签的常用属性"><a href="#Bean标签的常用属性" class="headerlink" title="Bean标签的常用属性"></a>Bean标签的常用属性</h3><ol>
<li>id属性：对这个bean的属性名，获取该bean的实例时所需的名字。</li>
<li>class属性：创建对象所在类的全路径。</li>
<li>name属性：功能与id属性一样，id属性不能包含特殊字符，但是在name属性值里面可以包含特殊字符。</li>
<li>scope属性：单实例与否。<ol>
<li>singleton：默认值，单实例</li>
<li>prototype：多实例</li>
</ol>
</li>
</ol>
<h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><h4 id="使用构造函数注入"><a href="#使用构造函数注入" class="headerlink" title="使用构造函数注入"></a>使用构造函数注入</h4><p>bean：</p>
<pre><code>public class PropertyDemo1{
    pubcli PropertyDemo1(String username){
        this.username= username;    
    }
}
</code></pre><p>配置文件：</p>
<pre><code>&lt;bean id=&quot;demo&quot; class=&quot;cn.itcast.property.PropertyDemo1&quot;&gt;
    &lt;construct-arg name=&quot;username&quot; value=&quot;谁谁谁&quot;&gt;&lt;/construct-arg&gt;
&lt;/bean&gt;
</code></pre><p>调用：</p>
<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);

PropertyDemo1 demo = (demo) context.getBean(&quot;demo&quot;);

System.out.println(demo.username);
</code></pre><h4 id="使用set方法注入"><a href="#使用set方法注入" class="headerlink" title="使用set方法注入"></a>使用set方法注入</h4><p>bean：</p>
<pre><code>class setBookname{
    private String bookname;
    public void setBookname(String bookname){
        this.bookname = bookname;
    }
}
</code></pre><p>配置文件：</p>
<pre><code>&lt;bean id=&quot;book&quot; class=&quot;cn.itcast.property.Book&quot;&gt;
    &lt;property name=&quot;bookname&quot; value=&quot;嘿嘿嘿&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>调用：</p>
<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);

setBookname book = (book) context.getBean(&quot;book&quot;);

System.out.println(book.bookname);
</code></pre><h4 id="注入对象类型属性"><a href="#注入对象类型属性" class="headerlink" title="注入对象类型属性"></a>注入对象类型属性</h4><p>UserDao：</p>
<pre><code>public class UserDao{
    public test(){
        System.out.print(&quot;test...&quot;);
    }
}
</code></pre><p>UserService：</p>
<pre><code>public class UserService{
    private UserDao userDao;
    public void setUserDao(User userDao){
        this.userDao = userDao;
    }
}
</code></pre><p>配置文件：</p>
<pre><code>&lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt;

//id为类中的属性名
//ref值与生成的bean的id值相同
&lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>调用：</p>
<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);

UserService userService = (UserService) context.getBean(&quot;userService&quot;);

userService.userDao.test();
</code></pre><h4 id="注入数组，list集合，map集合，properties类型属性"><a href="#注入数组，list集合，map集合，properties类型属性" class="headerlink" title="注入数组，list集合，map集合，properties类型属性"></a>注入数组，list集合，map集合，properties类型属性</h4><pre><code>&lt;bean id=&quot;person&quot; class=&quot;cn.itcast.property.Person&quot;&gt;
    &lt;!-- 数组 --&gt;
    &lt;property name=&quot;arrs&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;小王&lt;/value&gt;
            &lt;value&gt;小马&lt;/value&gt;
            &lt;value&gt;小宋&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;

    &lt;!-- list --&gt;
    &lt;property name=&quot;list&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;小奥&lt;/value&gt;
            &lt;value&gt;小金&lt;/value&gt;
            &lt;value&gt;小普&lt;/value&gt;
        &lt;/list&gt;            
    &lt;/property&gt;

    &lt;!-- map --&gt;
    &lt;property name=&quot;map&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;aa&quot; value=&quot;lucy&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;bb&quot; value=&quot;mary&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;cc&quot; value=&quot;tom&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;

    &lt;!-- properties --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;driverclass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;
            &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h3 id="IOC注解方式"><a href="#IOC注解方式" class="headerlink" title="IOC注解方式"></a>IOC注解方式</h3><ol>
<li><p>在spring配置文件中引入约束：</p>
<p> xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;</a> xsi:schemaLocation=”</p>
<pre><code>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;
</code></pre></li>
<li><p>在配置文件中开启注解扫描</p>
<p> //base-package：需要扫描注解的包<br> &lt;context:component-scan base-package=”cn.itcast”&gt;&lt;/context:component-scan&gt;</p>
</li>
<li><p>创建注解对象<br>在bean中类的上方加上注解：<code>@Component(value=&quot;...&quot;)</code></p>
</li>
</ol>
<p>bean：</p>
<pre><code>@Component(value=&quot;user&quot;) //等价于&lt;bean id=&quot;user&quot; class=&quot;...&quot;&gt;
public class User{
    public test(){
        System.out.println(&quot;got it!&quot;);    
    }
}
</code></pre><p>调用：</p>
<pre><code>public class test(
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);

    User user = (User) context.getBean(&quot;user&quot;);
    user.test();
    //got it!
}
</code></pre><p>可以了解的是，spring提供了4个注解关键字来实例化bean，其中后3个是Componnet的衍生：</p>
<ul>
<li>@Component:都可以使用</li>
<li>@Controller: web层</li>
<li>@Service: 业务层</li>
<li>@Repository: 持久层</li>
</ul>
<h4 id="注解确定单、多实例"><a href="#注解确定单、多实例" class="headerlink" title="注解确定单、多实例"></a>注解确定单、多实例</h4><pre><code>@Scope(value=&quot;prototype&quot;) //多实例
@Scope(value=&quot;singleton&quot;) //单实例
</code></pre><h4 id="注解注入属性"><a href="#注解注入属性" class="headerlink" title="注解注入属性"></a>注解注入属性</h4><h4 id="注入基本类型"><a href="#注入基本类型" class="headerlink" title="注入基本类型"></a>注入基本类型</h4><p>@Value(value)</p>
<p>bean:</p>
<pre><code>public class test{
    @Value(&quot;谁谁谁&quot;)
    private    String username;
    @Value(123)
    private int userid;
}
</code></pre><p><em>不过我们想向本类中注入值的情况比较少，掌握即可</em></p>
<h4 id="注入属性对象类型"><a href="#注入属性对象类型" class="headerlink" title="注入属性对象类型"></a>注入属性对象类型</h4><ul>
<li>@Autowired:自动检测属性并注入，前提是这个属性对象已经通过spring创建了对象实例，配置文件方式或注释方法都可以。</li>
<li>Resource(name=”对象名”)，对象名是通过spring创建的实例id值或name值</li>
</ul>
<ol>
<li><p>创建属性实例</p>
<p> @Component(value=”userDao”)<br> class userDao{</p>
<p> }</p>
</li>
<li><p>注入属性的两种方式</p>
<p> @Autowired<br> private UserDao userDao;</p>
</li>
</ol>
<pre><code>@Resource(name=&quot;userDao&quot;)
Private UserDao userDao;
</code></pre><h3 id="配置文件与注解混合使用"><a href="#配置文件与注解混合使用" class="headerlink" title="配置文件与注解混合使用"></a>配置文件与注解混合使用</h3><p>可以在配置文件中声明对象的属性类，然后在对象中通过注解注入属性。</p>
<p>配置文件：</p>
<pre><code>&lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt;
&lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt;
&lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt;
</code></pre><p>类：</p>
<pre><code>@Resource(name=&quot;bean0&quot;);
private Bean0 bean0;

@Resource(name=&quot;bean1&quot;);
private Bean0 bean1;
</code></pre><h2 id="spring中的AOP"><a href="#spring中的AOP" class="headerlink" title="spring中的AOP"></a>spring中的AOP</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li>Joinpoint(连接点)：类里面可以被增强的方法，这些方法被称为连接点。</li>
<li>Ponitcut(切入点)：所谓切入点是指我们要对哪些Joinpoint进行拦截。</li>
<li>Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)</li>
<li>Aspect(切面): 是切入点和通知（引介）的结合</li>
<li>增强：增强的逻辑，成为增强，包含以下类型：<ul>
<li>前置通知：在方法之前执行</li>
<li>后置通知：在方法之后执行</li>
<li>异常通知：在方法出现异常时执行</li>
<li>最终通知：在后置通知之后执行</li>
<li>环绕通知：在方法之前和之后执行<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3></li>
</ul>
</li>
</ul>
<ol>
<li><p>引入xml命名空间</p>
<p>  <a href="http://www.springframework.org/schema/aop" target="_blank" rel="noopener">http://www.springframework.org/schema/aop</a> <a href="http://www.springframework.org/schema/aop/spring-aop.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/aop/spring-aop.xsd</a></p>
</li>
<li><p>使用表达式配置切入点(实际增强的方法)</p>
</li>
</ol>
<p>表达式：</p>
<pre><code>execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)
</code></pre><ul>
<li>execution(* cn.itcast.aop.Book.add(…))</li>
<li>execution(<em> cn.itcast.aop.Book.</em>(..))</li>
<li>execution(<em> </em>.*(..))</li>
<li>匹配..开头的方法 execution(<em> save</em>(..))</li>
</ul>
<h3 id="AspectJ的aop操作"><a href="#AspectJ的aop操作" class="headerlink" title="AspectJ的aop操作"></a>AspectJ的aop操作</h3><ul>
<li>AspectJ不是spring的一部分，和spring一起使用aop操作。</li>
<li>spring2.0以后新增了对AspectJ的支持。</li>
<li>AspectJ可以用配置文件或注释文件。</li>
</ul>
<ol>
<li><p>配置对象</p>
<p> <bean id="book" class="cn.itcast.aop.Book"></bean></p>
 <bean id="myBook" class="cn.itcast.aop.MyBook">
</li>
<li><p>配置aop操作</p>
<p> <a href="aop:config">aop:config</a></p>
<pre><code>//配置切入点
&lt;aop:pointcut expression=&quot;execution(* cn.itcast.aop.Book.*(..))&quot; id=&quot;pointcut1&quot;&gt;

//配置切面，将增强用到切入点上
&lt;aop:aspect ref=&quot;myBook&quot;&gt;
    &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
&lt;aop:aspect&gt;
</code></pre><p> &lt;/aop:config&gt;</p>
</li>
</ol>
<p>值得注意的是：</p>
<ol>
<li><code>aop:point</code>标签是在配置切入点，即哪些方法需要被增强，其中expression为表达式，id为自定义名称。</li>
<li><code>aop:aspect</code>标签是在配置切面，即用哪些增强(方法)来增强切入点。</li>
<li>在<code>aop:aspect</code>内部标签表示的是增强的方式。包含以下标签：<ol>
<li>aop:before    前置通知</li>
<li>aop:after-returning      后置通知</li>
<li>aop:around         环绕通知</li>
<li>aop:after-throwing      异常通知</li>
<li>aop:after          最终通知</li>
</ol>
</li>
</ol>
<h3 id="AspectJ的注解AOP操作"><a href="#AspectJ的注解AOP操作" class="headerlink" title="AspectJ的注解AOP操作"></a>AspectJ的注解AOP操作</h3><ol>
<li><p>创建对象</p>
<pre><code>&lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt;
</code></pre> <bean id="myBook" class="cn.itcast.aop.MyBook">
</li>
<li><p>在spring核心配置文件中，开启aop操作</p>
<p> <a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a><a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a></p>
</li>
<li><p>在增强类上使用注解完成aop操作</p>
<p> @Aspect<br> public class MyBook{</p>
<pre><code>@Before(value=&quot;execution(* cn.itcast.aop.Book.*(..))&quot;)
public void before1(){
    System.out.print(&quot;before........&quot;);
}
</code></pre><p> }</p>
</li>
</ol>
<h2 id="sping的jdbcTemplate操作"><a href="#sping的jdbcTemplate操作" class="headerlink" title="sping的jdbcTemplate操作"></a>sping的jdbcTemplate操作</h2><ol>
<li><p>设置数据库信息</p>
<p> DriverManagerDataSource dataSource = new DriverManagerDataSource();<br> dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);<br> dataSource.setUrl(“jdbc.mysql:///database0”);<br> dataSource.setUsername(“root”);<br> dataSource.setPassword(“root”);</p>
</li>
<li><p>创建jdbcTemplate对象，设置数据源</p>
<p> JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</p>
</li>
<li><p>创建sql语句，并执行jdbcTemplate中的方法</p>
<ol>
<li><p><strong>增加</strong></p>
<p>String sql = “insert into user value(?,?)”;<br>int rows = jdbcTemplate.update(sql,”lucy”,”250”);</p>
</li>
<li><p><strong>修改</strong></p>
<p>String sql = “update user set password =? where username=?”;<br>int rows = jdbcTemplate.update(sql,”1234”,”lucy”);</p>
</li>
<li><p><strong>删除</strong></p>
<p>String sql = “delete from user where username=?”;<br>int rows = jdbcTemplate.update(sql,”lucy”);</p>
</li>
<li><p><strong>查询</strong></p>
<p>//返回对象<br>String sql = “select * from user where username=?”;<br>User user jdbcTemplate.queryForObject(sql,new MyRowMapper(),”mary”);<br>System.out.println(user);</p>
<p>//实现RowMapper<br>class MyRowMapper implements RowMapper<User>{<br> @Override<br> public User mapRow(Result re, int num) throws SQLException{</p>
<pre><code>String username= rs.getString(&quot;username&quot;);
String password = rs.getString(&quot;password&quot;);

User user = new User();
user.setUsername(username);
user.setPassword(password);
</code></pre><p> }<br>}</p>
</li>
</ol>
</li>
</ol>
<pre><code>//返回list
String sql = &quot;select * from user&quot;;
List&lt;User&gt; list = jdbcTemplate.query(sql,new MyRowMapper());

System.out.println(list);
</code></pre><h3 id="Spring配置c3p0连接池和dao使用jdbcTemplate"><a href="#Spring配置c3p0连接池和dao使用jdbcTemplate" class="headerlink" title="Spring配置c3p0连接池和dao使用jdbcTemplate"></a>Spring配置c3p0连接池和dao使用jdbcTemplate</h3><p>因为配置jdbcTemplate数据库的数据库信息实际上还是创建对象，注入属性。所以同样可以用Spring的AOP进行对象的创建。</p>
<ol>
<li>导入c3p0以及配合的jarbao </li>
<li><p>配置c3p0连接池</p>
 <bean id="dataSource" class="com.mchange.v2.c3p0.ComPoolDataSource"><br>     <property name="driverClass" value="com.mysql.jdbc.Driver"></property><br>     <property name="jdbcUrl" value="jdbc:mysql:///database"></property><br>     <property name="user" value="root"></property><br>     <property name="password" value="root"></property><br> </bean>
</li>
<li><p>dao使用jdbcTemplate</p>
<ol>
<li>创建service和dao，配置service和dao对象，并把service注入dao对象</li>
</ol>
</li>
</ol>
<pre><code>&lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c3p0.UserService&quot;&gt;
    &lt;proerpty name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c3p0.UserDao&quot;&gt;

2. 创建jdbcTemplate对象

private JdbcTemplate jdbcTemplate;
public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
    this.jdbcTemplate = jdbcTemplate;
}

3. 把模板对象注入dao中

&lt;bean id=&quot;userDao&quot; class=&quot;class.itcast.c3p0.UserDao&quot;&gt;
    &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;

4. 在jdbcTemplate对象里注入dataSource

private DataSource dataSource;
privateSQLExceptionTranslator exceptionTranslator;
private boolean lazyInit = true;

public void setDataSource(DataSource dataSource){
    this.dataSource = dataSource;
}

&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;bean&gt;
</code></pre><h2 id="spring的事务管理"><a href="#spring的事务管理" class="headerlink" title="spring的事务管理"></a>spring的事务管理</h2><h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><ol>
<li><p>在核心配置文件中配置事务管理器</p>
 <bean id="transactionManager" class="org.springframework.jdbc.dataSource.dataSourceTransactionManager"><br>     <property name="dataSource" ref="dataSource"></property><br> </bean>
</li>
<li><p>配置事务增强</p>
<p> &lt;tx:advice id=”txadvice” transaction-manager=”transactionManager”&gt;</p>
<pre><code>&lt;tx:attributes&gt;
    &lt;tx:method name=&quot;account*&quot; propagation=&quot;REQUIRED&quot;/&gt;
&lt;/tx:attributes&gt;
</code></pre><p> <a href="tx:advice">tx:advice</a></p>
</li>
<li><p>配置切面</p>
<p> <a href="aop:config">aop:config</a></p>
<pre><code>&lt;aop:pointcut expression=&quot;execution(* cn.itcast.service.OrderService.*(..))&quot; id=&quot;pointcut1&quot;&gt;

&lt;aop:adviser advice-ref=&quot;txadvice&quot; point=ref=&quot;pointcut1&quot;/&gt;
</code></pre><p> &lt;/aop:config&gt;</p>
</li>
</ol>
<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ol>
<li><p>配置事务管理器</p>
 <bean id="transactionManager" class="org.springframework.jdbc.dataSource.dataSourceTransactionManager"><br>     <property name="dataSource" ref="dataSource"></property><br> </bean>
</li>
<li><p>开启事务注解</p>
<p> &lt;tx:annotation-driven transaction-manager=”transactionManager”/&gt;</p>
</li>
<li><p>在需要使用事务的方法所在类上面添加注解</p>
<p> @Transactional<br> public class ordersService{</p>
<p> }</p>
</li>
</ol>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>这里的内容多是视频教学笔记中的内容加上我自己的理解，只是不是很深，只是一个最基本的用法，并且省去了配置环境的问题，比如导入jar包等等，这里面可能有很多错误或不足，因为我也是才开始接触。加油加油！</p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JavaEE</tag>
        <tag>SSH</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript深入解析1-this关键字</title>
    <url>/2019/07/17/javaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%901-this%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>花了三天时间粗略看完了《你不知道的JavaScript》下部，这一部分介绍了ES6的部分内容（本书出版时ES7,8）的部分特性还未推出，因为之前已经学过ES6，所以这一遍只是温习和关注细节，感觉除了新增的特征，<strong>迭代器</strong>应该是最重要的部分，因为ES6的很多特性都用到了迭代器，包括 <strong>扩展运算符(spread)‘[…]’</strong>，泛数组的迭代(for..of循环，keys(),values(),entries()等等),其次就是Promise，这个特性用的也很多，特别是在异步操作上，配合生成器(function */)，迭代器(iterator),就是<strong>async异步函数</strong>的底层实现。</p>
<h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><p>this关键字作为JavaScript开发者必须理解的概念之一，其实并没有那么高深。</p>
<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>Q：什么是this？<br>A：this代表的是函数运行的上下文环境。<br>Detail：</p>
<p>在所有语言中，都有一个<strong>调用栈</strong>的概念，即函数被哪个对象所调用（注意JavaScript中对象的概念，几乎所有的方法，参数都有一个宿主对象，其中顶层对象在浏览器中window，在node中则为global）。所以我们再执行一个函数或调用一个变量时，默认是带有一个顶层对象前缀的，不过由于我们所有的代码都在该对象中，则可以省略，不信可以试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.num);</span><br></pre></td></tr></table></figure>
<p>没错，它们的结果都是0。</p>
<p>回归正题，所以粗略的来说，函数被调用的对象即为他的this指向(先不谈硬绑定)，最简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    num : <span class="number">0</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.func();</span><br></pre></td></tr></table></figure>
<p>执行结果是什么呢？<br>没错，是0；<br>因为这里的func函数由obj调用，所以this指向obj。<br>OK,那么再看一下下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    num : <span class="number">1</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outterFunc = obj.func;</span><br><span class="line">outterFunc();</span><br></pre></td></tr></table></figure>
<p>执行结果又是什么呢？have a try!<br>可能出乎你的意料，结果是<strong>0</strong>.<br>So,why?思考一下我们上面的解释。</p>
<p>没错，也许你想通了，因为这时候的func函数并不是通过obj来调用的，所以this默认指向window，但window中num变量为0，所以结果是<strong>0</strong>.</p>
<p>在这之中，我们需要了解的是：<strong>在JavaScript中，函数，对象，数组，或者说所有对象即对象的子类（因为包括函数，数组皆为对象的子类）都是通过地址的形式存储，类似与C语言中的指针形式存储</strong></p>
<p>思考下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">123</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>在JavaScript引擎中时如何运行完这条语句的呢？<br>（你需要了解的是JavaScript不是一门预编译语言，而是一门<strong>解释执行</strong>的语言（即执行一句，编译一句，当然这是不完全正确的，从<strong>变量提升</strong>即可以看出来））</p>
<ol>
<li>查询是否存在func这个变量—否</li>
<li>声明这个变量</li>
<li>定义函数<code>function(){console.log(123)}</code></li>
<li>将该函数存储于内存中，并取得其地址</li>
<li>将该地址赋值给func变量</li>
</ol>
<p>所以func变量实际存储的是该函数的地址。<br><strong>所以函数实际上是没有存储作用域链中的任何信息，它总是一个独立存在的个体。</strong><br>这也就解释了为什么func虽然定义在obj中，但是通过某种方式提取出来后直接调用其this就指向了window。</p>
<p>所以你大概已经明白了了吧，思考一下下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">	inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outter();</span><br></pre></td></tr></table></figure>
<p>所以，结果是什么呢？</p>
<p>我猜你肯定答对了，是0；</p>
<p>同样的道理，inner函数虽然在outter函数中被调用，但任然是直接调用，没有任何前缀对象，所以其this指向任然是window。</p>
<p>最后一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"clever coder"</span>;  </span><br><span class="line"><span class="keyword">var</span> person = &#123;  </span><br><span class="line">    name : <span class="string">"foocoder"</span>,  </span><br><span class="line">    hello : <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">var</span> sayhello = <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>) </span>&#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(that.name + <span class="string">" says "</span> + sth);  </span><br><span class="line">        &#125;;  </span><br><span class="line">        sayhello(sth);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">person.hello(<span class="string">"hello world"</span>);<span class="comment">//foocoder says hello world</span></span><br></pre></td></tr></table></figure>
<p>这里内层函数this指向的任然是window，有人认为是JavaScript的设计错误，但是从上面内存的角度去分析，会发现这是正确的。</p>
<h1 id="why-amp-where"><a href="#why-amp-where" class="headerlink" title="why &amp; where"></a>why &amp; where</h1><p>说了这么多this，那么为什么要用this呢？又在哪里用呢？</p>
<p>Q：why？</p>
<p>A：this的使用使调用上下文对象变得更加简洁，否则，每次调用函数必须传递上下文对象，编码将及其复杂。</p>
<p>Q：where？</p>
<p>A：相信接触过OOP（面向对象编程）的同学应该熟悉这个结构(伪代码)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Class Example&#123;</span><br><span class="line">	 <span class="keyword">constructor</span>(name,age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age; 	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare instan = <span class="keyword">new</span> Example(<span class="string">'tom'</span>,<span class="number">23</span>);</span><br></pre></td></tr></table></figure>
<p>没错，这是一个基本类的构造，只包括了一个constructor构造器方法，其中的this指向的即是这个被实例化的对象(instan),则instan的name属性为’tom’，age属性为23。试想没有this的话，构造器该如何为实例属性赋值呢？只有显式的将instan传递给constructor函数，这将变得无比繁杂。</p>
<p>在js中，不仅是在类，即使是用<strong>行为委托</strong>方式编码，任然离不开this，因为总是存在对上下文对象的应用。</p>
<p><strong>值得注意的是：JavaScript语言基础中并没有class的概念，即使ES6推出了class关键字，但它任然是使用原型链对类的模拟，任然是ES5部分框架class实现的语法糖</strong></p>
<h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p>说了那么多，还是要详细讲一下this的绑定问题：</p>
<ol>
<li>默认绑定</li>
</ol>
<p><strong>独立函数调用执行默认绑定</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a:'</span><span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line"><span class="comment">//a:0</span></span><br></pre></td></tr></table></figure>
<p>如上面我们所说，这里的func是直接的函数调用，所以执行默认绑定，this指向了window对象。</p>
<p><strong>值得注意的是：在strict模式下，默认绑定this为undefined</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">	"use strict"</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'a:'</span>+<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Uncaught TypeError: Cannot read property 'a' of undefined</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>隐式绑定</li>
</ol>
<p>这就是我们之前熟悉的用对象来调用函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    num : <span class="number">0</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'num:'</span>+<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.func();</span><br><span class="line"></span><br><span class="line"><span class="comment">//num:0</span></span><br></pre></td></tr></table></figure>
<p><strong>当含有多层对象引用的时候，只有距函数最近的一个对象为上下文对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj0 = &#123;</span><br><span class="line">    num : <span class="number">0</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'num:'</span>+<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    num:<span class="number">1</span>,</span><br><span class="line">    obj0:obj0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.obj0.func()</span><br><span class="line"></span><br><span class="line"><span class="comment">//num:0</span></span><br></pre></td></tr></table></figure>
<p>正如我们之前所说的，函数的存储与上下文对象毫无关系，所以，当我们将对象中的函数通过某种方法提取出来时，它就与原来的对象毫无关系了，其this指向则为window了（<strong>这种现象一般被称为隐式丢失</strong>）。具体可以看上面那个例子。</p>
<ol start="3">
<li>显示绑定</li>
</ol>
<p>所谓显示绑定，即通过call(),apply(),以及ES6的bind()函数直接指定this的指向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是：call(),apply()函数的绑定是<strong>软绑定</strong>，即只在绑定这一次起作用，下一次调用时this任然执行原有绑定规则。</p>
<p>所以就衍生出了<strong>硬绑定</strong>，ES6之前需要手动封装硬绑定方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn,obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fn.apply(obj,<span class="built_in">arguments</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行此方法后，函数的this指向将被永久绑定在指定对象上，无法修改。</span></span><br></pre></td></tr></table></figure>
<p>由于这个方法需求太广泛了，所以ES6推出了官方的bind()方法，直接调用即可。</p>
<ol start="4">
<li>new绑定</li>
</ol>
<p>与其他语言中构造函数的特殊性不同，在JavaScript中，构造函数是一个普通的函数，唯一的特殊点是它在执行new操作符后自动调用，并且开始执行一系列操作：</p>
<ol>
<li>创建一个新的对象</li>
<li>这个新对象会被执行[[prototype]]连接(即将<code>__proto__</code>指定为函数的<code>prototype</code>)。</li>
<li>这个对象将会被绑定到对应的函数的this。</li>
<li>如果函数没有返回其他对象，那么new表达式中函数调用会自动返回这个新对象。</li>
</ol>
<p>第四步解释：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">				b:<span class="number">2</span></span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instan = <span class="keyword">new</span> Fun()</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;b:2&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ol>
<li>如果是new绑定，则this按上面的规则绑定对象。</li>
<li>如果是显示绑定，则this指向显示绑定的对象。</li>
<li>如果有隐式绑定，则this绑定在调用对象上。</li>
<li>否则执行默认绑定，非严格模式下为window，严格模式下位undefined。</li>
</ol>
<h2 id="箭头函数-gt"><a href="#箭头函数-gt" class="headerlink" title="箭头函数 =&gt;"></a>箭头函数 =&gt;</h2><p>在ES6中，新加了一种声明函数的方式，箭头函数(=&gt;)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">()=&gt;&#123;&#125; 等价于 <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>关于箭头函数的特性就不具体细讲，他与this相关的就是：<br>箭头函数的this决定于定义函数时的外层作用域来决定：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arrayFunc</span></span><br><span class="line">    <span class="keyword">var</span> a  = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//定义全局变量a</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">arrayFunc = (</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;)()<span class="comment">//这是一个立即执行函数，也可以在外围多调用一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        a : <span class="number">1</span>,</span><br><span class="line">        func: fun()</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	fun.call(obj);<span class="comment">//将fun的this指向obj</span></span><br><span class="line">	<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>由于fun的this指向obj，而箭头函数的this根据外围函数的this决定，所以arrayFunc的this也指向obj，则a为1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//normal</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a  = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">normalFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;)()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        a : <span class="number">1</span>,</span><br><span class="line">        func: fun()</span><br><span class="line">    &#125;</span><br><span class="line">	fun.call(obj);</span><br><span class="line">	<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>这里普通函数的this根据调用的对象来确定，由于它是单独调用的，所以this指向window，则a为0。</p>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>this的用法相当重要，不管是自己原生开发，或是用框架，特别是使用框架时，由于一般框架会有一个App实例，我们的操作都在这个实例之中进行，所以会无数次用到this，所以我们必须学通。下一期写一下Protype原型链，也是JavaScript中相当重要的一个内容。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>this关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>javaee之struts框架总结</title>
    <url>/2019/08/08/javaee%E4%B9%8Bstruts%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在了解后端开发框架，所以先从SSH（Struts，Spring，Hibernate）开始，因为在企业级开发中SSH任然在使用，所以还是有必要了解一下，后面再详细学习SSM（Spring MVC，Spring，mybatis），目前互联网企业中大多都在使用SSM。</p>
<a id="more"></a>
<p>这一期先介绍struts。</p>
<h1 id="struts"><a href="#struts" class="headerlink" title="struts"></a>struts</h1><h2 id="struts介绍"><a href="#struts介绍" class="headerlink" title="struts介绍"></a>struts介绍</h2><p>struts是一个工作在表示层，负责与JSP页面实现交互，将用户的请求委派给相应的Action处理。</p>
<h2 id="配置过滤器"><a href="#配置过滤器" class="headerlink" title="配置过滤器"></a>配置过滤器</h2><p>在<code>web-app</code>内添加如下内容：</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h2 id="创建action"><a href="#创建action" class="headerlink" title="创建action"></a>创建action</h2><h3 id="方法一-直接创建Action"><a href="#方法一-直接创建Action" class="headerlink" title="方法一 直接创建Action"></a>方法一 直接创建Action</h3><pre><code>public class Democlass{
    public String execute(){
        return &quot;none&quot;;
    }
}
</code></pre><h3 id="方法二-继承ActionSupport类（最常用）"><a href="#方法二-继承ActionSupport类（最常用）" class="headerlink" title="方法二 继承ActionSupport类（最常用）"></a>方法二 继承ActionSupport类（最常用）</h3><pre><code>public class Democlass extends ActionSupport{
    public String execute(){
        return &quot;none&quot;;    
    }
}
</code></pre><h3 id="方法三-实现接口Action"><a href="#方法三-实现接口Action" class="headerlink" title="方法三 实现接口Action"></a>方法三 实现接口Action</h3><pre><code>public class Democlass implements Action{
    public String execute(){
        return &quot;none&quot;;
    }
}
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><strong>配置文件必须是命名为<code>struts.xml</code>，并且位于<code>src</code>目录下。</strong></p>
<h4 id="引入dtd约束"><a href="#引入dtd约束" class="headerlink" title="引入dtd约束"></a>引入dtd约束</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE struts PUBLIC
&quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
&quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;
</code></pre><h4 id="配置action"><a href="#配置action" class="headerlink" title="配置action"></a>配置action</h4><pre><code>&lt;package name=&quot;methoddemo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt;
    &lt;action name=&quot;&quot; class=&quot;cn.itcast.method.BookAction&quot; method=&quot;&quot; &gt;
        &lt;result name=&quot;ok&quot;&gt;hello.jsp&lt;/result&gt;
    &lt;/action&gt;
&lt;/package&gt;
</code></pre><p>结构为：package-&gt;action-&gt;result</p>
<ol>
<li>package参数：<ol>
<li>name:（必填）自定义名称</li>
<li>namespace:（可选）命名空间</li>
<li>extends:（可选）该包继承自其它包，一般填<code>struts-default</code></li>
<li>abstract:（可选）该类是否是一个抽象包，抽象包中不能包含Action定义。</li>
</ol>
</li>
<li><p>action参数：</p>
<ol>
<li>name：（必填）action的标识，在URL访问时后缀为该值。</li>
<li>class：（可选）Action的类的全路径。</li>
<li>method：（可选）指定请求Action时调用的方法，默认为execute方法。</li>
<li>converter：（可选）指定类型转换器的类。</li>
</ol>
</li>
<li><p>result参数：</p>
<ol>
<li>name：（可选）指定逻辑视图的名称，默认为success。（为指定函数的返回值）</li>
<li>type：（可选）指定访问内容的方式，主要有如下方式（默认为dispatcher）<ol>
<li>dispatcher：页面转发</li>
<li>redirect：页面重定向</li>
<li>chain：action转发</li>
<li>redirectAction：action重定向</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="global-result"><a href="#global-result" class="headerlink" title="global-result"></a>global-result</h4><p>如果在action类的方法中，返回了一个字符串，但如果没有配置对应的result，则浏览器会返回404，但是global-result可以匹配任何action中的对应action。</p>
<p><strong>注意：如果action中与global-result同时配置了相同的result。则局部result优先级更高。</strong></p>
<pre><code>&lt;global-results&gt;
    &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt;
&lt;global-results&gt;
</code></pre><h2 id="action获取表单数据"><a href="#action获取表单数据" class="headerlink" title="action获取表单数据"></a>action获取表单数据</h2><h3 id="使用ActionContext类获取"><a href="#使用ActionContext类获取" class="headerlink" title="使用ActionContext类获取"></a>使用ActionContext类获取</h3><pre><code>ActionContext context = ActionContext.getContext();

Map&lt;String,Object&gt; map = context.getParameters();

//使用Map.Entry遍历获取的Map
for(Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
System.out.println(entry.getKey()+&quot;--&quot;+Arrays.toString((Object[]) (entry.getValue())));
}
</code></pre><h3 id="使用SevletActionContext类获取"><a href="#使用SevletActionContext类获取" class="headerlink" title="使用SevletActionContext类获取"></a>使用SevletActionContext类获取</h3><p>该方法直接获取<code>request</code>对象。</p>
<pre><code>HttpServletRequest request = ServletActionContext.getRequest();

//下面就是调用request了
String para1 = request.getParameter(&apos;para1&apos;);
String para2 = request.getParameter(&apos;para2&apos;);
String para3 = request.getParameter(&apos;para3&apos;);
</code></pre><h3 id="使用接口获取request"><a href="#使用接口获取request" class="headerlink" title="使用接口获取request"></a>使用接口获取request</h3><pre><code>public class Demo implements ServletRequestAware{
    @Override
    public void setServletRequest(HttpServletRequest){
        this.request = request;
    }
}
</code></pre><h2 id="在action中操作域对象"><a href="#在action中操作域对象" class="headerlink" title="在action中操作域对象"></a>在action中操作域对象</h2><p>struts的域对象与servlet的域对象一样，用于存储数据，在JSP页面中直接获取。</p>
<p>具体用法：</p>
<ol>
<li><p>request域</p>
<p> HttpServletRequest request = ServletActionContext.getRequest();<br> request.setAttribute(“key”,”value”);</p>
</li>
<li><p>session域</p>
<p> HttpSession session = request.getSession();<br> session.setAttribute(“key”,”value”);</p>
</li>
<li><p>ServletContext域</p>
<p> ServletContext context = ServletAction.getServletContext();<br> context.setAttribute(“key”,”value”);</p>
</li>
</ol>
<h2 id="属性封装"><a href="#属性封装" class="headerlink" title="属性封装"></a>属性封装</h2><p>表单提交的数据会自动封装到类实例的属性</p>
<h3 id="一、直接将表单提交的属性封装到action中"><a href="#一、直接将表单提交的属性封装到action中" class="headerlink" title="一、直接将表单提交的属性封装到action中"></a>一、直接将表单提交的属性封装到action中</h3><ol>
<li>在action成员中定义变量</li>
<li><p>生成变量的set,get方法</p>
<p> private String userName;<br> private String password;<br> private String address;</p>
<p> public String getUserName(){</p>
<pre><code>return this.userName;
</code></pre><p> }</p>
<p> public String setUserName(String userName){</p>
<pre><code>this.userName = userName;
</code></pre><p> }</p>
<pre><code>public String getPassword(){
return this.password;
</code></pre><p> }</p>
<p> public String setPassword(String userName){</p>
<pre><code>this.password = password;
</code></pre><p> }</p>
<p> public String getAddress(){</p>
<pre><code>return this.address;
</code></pre><p> }</p>
<p> public String setAddress(String userName){</p>
<pre><code>this.address = address;
</code></pre><p> }</p>
</li>
</ol>
<h3 id="模型驱动封装-重点"><a href="#模型驱动封装-重点" class="headerlink" title="模型驱动封装(重点)"></a>模型驱动封装(重点)</h3><ol>
<li>action实现接口ModelDriven</li>
<li>实现接口里面的getModel方法</li>
<li><p>在action里创建实体类对象</p>
<p> class Demo extends ActionSupport implements ModelDriven<User>{</p>
<pre><code>private User user = new User();
public User getModel(){
    return user
}
</code></pre><p> }</p>
</li>
</ol>
<ol>
<li>使用模型驱动封装，一个表单只能封装一个模型驱动封装。</li>
<li>不能同时使用属性封装与模型驱动封装。</li>
</ol>
<h4 id="表达式封装"><a href="#表达式封装" class="headerlink" title="表达式封装"></a>表达式封装</h4><p>使用表达式封装是指在表单提交时，name属性则为具体实例的属性（struts有自己的表示方式，比如：User.name）</p>
<ol>
<li>在action中声明实例类</li>
<li><p>生成实例类的set与get方法</p>
<p> private User user;<br> public User getUser(){</p>
<pre><code>return user;
</code></pre><p> }<br> public void setUser(User user){</p>
<pre><code>this.user = user
</code></pre><p> }</p>
</li>
<li><p>在表单输入项的name属性里面写表达式形式</p>
<p> username:&lt;\input type=”test” name=”user.userName”&gt;<br> password:&lt;\input type=”password” name=”user.password”&gt;<br> address:&lt;\input type=”text” name=”user.address”&gt;</p>
</li>
</ol>
<h4 id="封装到集合中"><a href="#封装到集合中" class="headerlink" title="封装到集合中"></a>封装到集合中</h4><h4 id="封装到list集合"><a href="#封装到list集合" class="headerlink" title="封装到list集合"></a>封装到list集合</h4><p>第一步 在action声明List<br>第二步 生成list变量的set和get方法</p>
<pre><code>private List&lt;User&gt; list;
public List&lt;User&gt; getList(){
    return list;
}
public void setList(List&lt;User&gt; list){
    this.list = list;
}
</code></pre><p>第三步 在表单输入项中写表达式</p>
<pre><code>username:&lt;input type=&quot;text&quot; name=&quot;list[0].userName&quot;&gt;
password:&lt;input type=&quot;password&quot; name=&quot;list[0].password&quot;&gt;
address:&lt;input type=&quot;text&quot; name=&quot;list[0].address&quot;&gt;

&lt;br/&gt;&lt;br/&gt;

username:&lt;input type=&quot;text&quot; name=&quot;list[1].userName&quot;&gt;
password:&lt;input type=&quot;password&quot; name=&quot;list[1].password&quot;&gt;
address:&lt;input type=&quot;text&quot; name=&quot;list[1].address&quot;&gt;
</code></pre><h4 id="封装到Map集合"><a href="#封装到Map集合" class="headerlink" title="封装到Map集合"></a>封装到Map集合</h4><p>第一步 声明map集合<br>第二步 生成get和set方法</p>
<pre><code>private Map&lt;String,User&gt; map;
public Map&lt;String,User&gt; getMap(){
    return map;
}
public void setMap(Map&lt;String,User&gt; map){
    this.map = map;
}


username:&lt;input type=&quot;text&quot; name=&quot;map[one].userName&quot;/&gt;
password:&lt;input type=&quot;password&quot; name=&quot;map[one].password&quot;/&gt;
address:&lt;input type=&quot;text&quot; name=&quot;map[one].address&quot;/&gt;
</code></pre><h2 id="OGNL表达式"><a href="#OGNL表达式" class="headerlink" title="OGNL表达式"></a>OGNL表达式</h2><p>与EL表达式一样，OGNL表达式可以用来操作值栈。</p>
<h3 id="引用struts标签库"><a href="#引用struts标签库" class="headerlink" title="引用struts标签库"></a>引用struts标签库</h3><pre><code>//引用标签库
&lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt;
//操作
&lt;s:property value=&quot;&apos;haha&apos;.length()&quot;&gt;
</code></pre><h2 id="值栈"><a href="#值栈" class="headerlink" title="值栈"></a>值栈</h2><ol>
<li>在servlet中，我们把数据放到了域对象中，在页面中使用EL表达式获取；域对象同样在一定范围内，存值和取值。</li>
<li>在struts中也提供了一种存储机制，类似与域对象，被称为值栈，也可以存值获取值。<ul>
<li>在action中把数据存到值栈中，在页面中获取数据。</li>
</ul>
</li>
<li><p>servelet和action区别</p>
<ol>
<li>Servlet：默认在第一次访问创建，创建一次，单实例对象。</li>
<li>Action：访问时创建，每次访问的时候，都会创建一个action对象。所以它是一个多实例对象。</li>
</ol>
</li>
<li><p>值栈存储在action中。</p>
</li>
</ol>
<h3 id="获取值栈对象"><a href="#获取值栈对象" class="headerlink" title="获取值栈对象"></a>获取值栈对象</h3><pre><code>ActionContext context = ActionContext.getContext();
ValueStack stack1 = context.getValueStack();
</code></pre><p><strong>每一个action只有一个值栈对象。</strong></p>
<p>值栈分为两部分：</p>
<ul>
<li>root：list集合</li>
<li>context：map集合（实际就是action的上下文），包含如下内容：<ul>
<li>request：HttpRequest对象的引用</li>
<li>session：HttpSession对象引用</li>
<li>application：ServletContext对象的引用</li>
<li>parameters：传递的相关参数</li>
<li>attr：域对象，使用seAttribute(“key”,”value”)存储</li>
</ul>
</li>
</ul>
<p><code>可以使用s:debug来查看action的结构</code></p>
<h3 id="向值栈中存值"><a href="#向值栈中存值" class="headerlink" title="向值栈中存值"></a>向值栈中存值</h3><ol>
<li><p>使用set方法</p>
<p> ActionContext context = ActionContext.getContext();<br> ValueStack stack = context.getValueStack();</p>
<p> stack.set(“key”,”value”);</p>
</li>
<li><p>使用push方法</p>
<p> ActionContext context = ActionContext.getContext();<br> ValueStack stack = context.getValueStack();</p>
<p> stack.push(“something”);</p>
</li>
</ol>
<ol start="3">
<li><p>向值栈中存放对象</p>
<p> private User user = new User();<br> public User getUser(){</p>
<pre><code>return user;
</code></pre><p> }</p>
<p> public String excute() throws Exception{</p>
<pre><code>user.setUsername(&quot;lucy&quot;);
user.setPassword(&quot;123&quot;);
user.setAddress(&quot;美国&quot;);

return &quot;success&quot;;
</code></pre><p> }</p>
</li>
<li><p>向值栈中存放list集合</p>
<p> private List<User> list = new ArrayList<User>();</p>
<p> public List<User> getList(){</p>
<pre><code>return list;
</code></pre><p> }</p>
<p> public String excute() throws Exception{</p>
<pre><code>User user1 = new User();
user1.setUsername(&quot;lucy&quot;);
user1.setPassword(&quot;123&quot;);
user1.setAddress(&quot;美国&quot;);

User user2 = new User();        
user2.setUsername(&quot;tom&quot;);
user2.setPassword(&quot;12345&quot;);
user2.setAddress(&quot;意大利&quot;);

list.add(user1);
list.add(user2);
return &quot;success&quot;;
</code></pre><p> }</p>
</li>
</ol>
<h3 id="从值栈中取值"><a href="#从值栈中取值" class="headerlink" title="从值栈中取值"></a>从值栈中取值</h3><p>我们都是用OGNL表达式结合struts标签来获取值栈中的值。</p>
<h4 id="获取字符串"><a href="#获取字符串" class="headerlink" title="获取字符串"></a>获取字符串</h4><pre><code>&lt;s:property value=&quot;username&quot;/&gt;
</code></pre><h4 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h4><pre><code>//方法一
&lt;s:property value=&quot;list[0].username&quot;/&gt;
&lt;s:property value=&quot;list[0].password&quot;/&gt;
&lt;s:property value=&quot;list[0].address&quot;/&gt;
&lt;br/&gt;
&lt;s:property value=&quot;list[1].username&quot;/&gt;
&lt;s:property value=&quot;list[1].password&quot;/&gt;
&lt;s:property value=&quot;list[1].address&quot;/&gt;

//方法二
&lt;s:iterator value=&quot;list&quot;&gt;
    &lt;s:property value=&quot;username&quot;/&gt;
    &lt;s:property value=&quot;password&quot;/&gt;
    &lt;s:property value=&quot;address&quot;/&gt;
&lt;s:iterator&gt;

//方法三
&lt;s:iterator value=&quot;list&quot; var = &quot;user&quot;&gt;
    &lt;s:property value=&quot;#user.username&quot;/&gt;
    &lt;s:property value=&quot;#user.password&quot;/&gt;
    &lt;s:property value=&quot;#user.address&quot;/&gt;
&lt;s:iterator&gt;
</code></pre><h4 id="获取set值"><a href="#获取set值" class="headerlink" title="获取set值"></a>获取set值</h4><pre><code>&lt;s:property value=&quot;key&quot;&gt;
</code></pre><h4 id="获取push方法"><a href="#获取push方法" class="headerlink" title="获取push方法"></a>获取push方法</h4><pre><code>&lt;s:property value=&quot;[0].top&quot;&gt;
</code></pre><p>可以通过debug的方式看出，值栈实际上就是存在context中，作为其属性。</p>
<h3 id="EL表达式可以不去值栈数据"><a href="#EL表达式可以不去值栈数据" class="headerlink" title="EL表达式可以不去值栈数据"></a>EL表达式可以不去值栈数据</h3><p><strong>EL表达式实际上是增强了getAttribute方法，如果在request中获取到对应的值，则返回该值，否则再到值栈中检索。</strong></p>
<h3 id="OGBL中的-与"><a href="#OGBL中的-与" class="headerlink" title="OGBL中的#与%"></a>OGBL中的#与%</h3><ol>
<li><p>#</p>
<ol>
<li><p>获取context中的值</p>
<p>&lt;s:property value=”#user.username”/&gt;        </p>
</li>
<li><p>获取request中的值</p>
<p>&lt;s:property value=”#request.req”/&gt;</p>
</li>
</ol>
</li>
<li><p>%</p>
<ol>
<li>在struts2标签中表单标签</li>
</ol>
</li>
</ol>
<p>在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别。</p>
<pre><code>&lt;s:textfield name=&quot;username&quot; value=&quot;%{#request.req}&quot;&gt;
</code></pre><h2 id="struts拦截器"><a href="#struts拦截器" class="headerlink" title="struts拦截器"></a>struts拦截器</h2><p>struts的拦截器是一种AOP(面向切面编程)思想的实践，通俗的来说就是不改变源代码来实现对原来类或方法的拓展。</p>
<p>而在每次action启动的时，我们都会为每个action方法增加一些拦截器，在action对象创建之后，action方法之前，拦截器的方法得到执行，拦截决定是否放行，然后由下一个拦截器接手继续执行，知道所有拦截器执行完。一旦任何一个拦截器拒绝了，那么后面的拦截也都不会执行了。</p>
<h3 id="拦截器与过滤器"><a href="#拦截器与过滤器" class="headerlink" title="拦截器与过滤器"></a>拦截器与过滤器</h3><ol>
<li>过滤器：理论上可以过滤任意内容，包括html,jsp,servlet…</li>
<li>拦截器：只能拦截action</li>
</ol>
<h3 id="自定拦截器"><a href="#自定拦截器" class="headerlink" title="自定拦截器"></a>自定拦截器</h3><h4 id="编写拦截器方法"><a href="#编写拦截器方法" class="headerlink" title="编写拦截器方法"></a>编写拦截器方法</h4><ol>
<li><p>继承<code>MethodFilterInterceptor</code>并重写其中的<code>doIntercept</code>方法。</p>
<p> public class MyFilter extends MthodsFilterInterceptor{</p>
<pre><code>protected String doIntercept(ActionInvocation invocation)throws {
    //如果符合条件，则通过执行invocation.invoke()来放行
    if(somthongright){
        invocation.invoke();
    }else{
        //否则，不执行invocation.invoke()
        return &quot;null&quot;;
        }
}
</code></pre><p> }</p>
</li>
</ol>
<h4 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h4><p>在package中：</p>
<ol>
<li><p>声明拦截器</p>
<p> //class为自定义拦截器的全路径</p>
 <interceptors><br>     <interceptor name="myFilter" class="priv.st.filter"><br> </interceptors>
</li>
<li><p>使用自定义的拦截器<br>在要使用的action内部使用：</p>
<p> //name为上面配置的name值<br> <interceptor-ref name="myFilter"></interceptor-ref></p>
</li>
</ol>
<p>3.还有一点要注意，由于<code>interceptor-ref</code>值默认为执行struts的默认拦截器，我们修改了之后就不会执行默认拦截器了，所以我们还要执行默认拦截器。</p>
<pre><code>&lt;interceptor-ref name=&quot;defultStack&quot;&gt;&lt;/interceptor-ref&gt;
</code></pre><p>这里的<strong>defaultStack</strong>是struts在对默认拦截器的一个名称定义，直接引用不能改变。</p>
<ul>
<li><p>如果我们需要让某些action不进行拦截，我们可以在使用拦截器时加入属性：</p>
<p>  <interceptor-ref name="myFilter"></p>
<pre><code>&lt;param name=&quot;excludeMthods&quot;&gt;login&lt;/param&gt;
</code></pre><p>  </interceptor-ref></p>
</li>
</ul>
<h2 id="struts常用标签库"><a href="#struts常用标签库" class="headerlink" title="struts常用标签库"></a>struts常用标签库</h2><ol>
<li>s:property :使用OGNL表达式获取值栈的值。</li>
<li>s:iterator :使用OGNL迭代获取值栈中的值。</li>
<li>s:iterator :查看值栈的结构和数据。</li>
<li>struts的表单属性，struts对HTML表单属性都有封装，但一般不用，比如&lt;s:input type=”text”&gt;</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>虽然struts目前用的最少，但是最为SSH三大框架之一，了解一下还是有利于以后的工作。</p>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JavaEE</tag>
        <tag>SSH</tag>
        <tag>struts</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS学习3-内存控制</title>
    <url>/2021/04/27/NodeJS%E5%AD%A6%E4%B9%A03-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="V8的内存分配"><a href="#V8的内存分配" class="headerlink" title="V8的内存分配"></a>V8的内存分配</h1><p>在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB），在这样的限制下，将会导致Node无法直接操作大内存对象。比如无法将一个2GB的文件读入内存中进行字符串分析处理，即使物理内存大于2GB，这样在单个Node进程的情况下，计算机的内存资源无法得到充足的使用。</p>
<p>造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上都是通过V8自己的方式来进行分配和管理的。V8这套内存管理机制在浏览器的应用场景下使用起来是绰绰有余，足以胜任前端页面中的所有需求。但在Node中，却限制了开发者随心所欲使用大内存的想法。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>表层原因在于，V8最初为浏览器设计，不大可能设计大内存使用的场景。对于一个网页（在浏览器中，一个tab有一个JS线程），1.5GB已经足够使用。从官方的说法来说，以1.5GB的垃圾回收堆内存为例，V8做一次垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1s以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端无法接受，前端浏览器同样无法接受。</p>
<p>当然，这个限制也不是不能改变，V8依然在启动时提供可选参数来使用更多内存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --max-old-space-size = 1700		//老生代，单位为MB</span><br><span class="line">node --max-new-space-size = 1024		//新生代，单位为KB</span><br></pre></td></tr></table></figure>
<p>但是注意，这个参数在运行中是无法改变的，一旦启动，内存分配就无法改变，这一点，确实限制了Node的发挥。</p>
<h1 id="V8的垃圾回收机制"><a href="#V8的垃圾回收机制" class="headerlink" title="V8的垃圾回收机制"></a>V8的垃圾回收机制</h1><p>之前在分析闭包的那篇文章中，<a href="https://michaelwang.top/2021/01/31/%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/" target="_blank" rel="noopener">全面理解JavaScript作用域与闭包</a>，虽然详细分析了V8的内存结构，但是并没有详细分析垃圾回收机制,这里详细看一下。</p>
<h2 id="V8主要的垃圾回收算法"><a href="#V8主要的垃圾回收算法" class="headerlink" title="V8主要的垃圾回收算法"></a>V8主要的垃圾回收算法</h2><p>V8的垃圾回收策略主要基于分布式垃圾回收机制。在自动垃圾回收的演变过程中，人们发现暂时没有一种垃圾回收算法能够胜任所有的场景。因为在实际应用中，对象的生存周期长短不一，不同的算法只能针对特定情况具有最好的效果。为此，统计学在垃圾回收算法中产生了较大的作用，现在的垃圾回收算法按对象的存活时间将内存的垃圾回收进行不同的分代。然后分别对不同的内存施以更高效的算法。</p>
<h3 id="V8的内存分代"><a href="#V8的内存分代" class="headerlink" title="V8的内存分代"></a>V8的内存分代</h3><p>在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象主要为存活时间较长或或者常驻内存的对象。</p>
<p>所以V8的堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提到的改变Node的内存限制就是用以改变新生代和老生代的内存空间的大小。</p>
<h3 id="Scavenge算法"><a href="#Scavenge算法" class="headerlink" title="Scavenge算法"></a>Scavenge算法</h3><p>在分代的基础上，新生代中的对象主要是通过Scavenge算法进行垃圾回收的。在Scavenge的具体实现中，主要采用了Cheney算法，该算法由C.J.Cheney于1970年首次发表在ACM论文上。</p>
<p>Cheney算法是一种采用复制的方法实现的垃圾回收算法。它将堆的内存一分为二，每一部分空间称为semispace。在这两个semispace中，只有一个处于使用中，另一个处于空闲中。处于使用状态的semispace称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间进行分配。当开始机型垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的工程中，就是通过将存活对象在两个semispace空间之间进行复制。</p>
<p>Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制决定的。但是Scavenge由于只复制存活的对象，并且对于生命周期短的场景只占少部分，所以它在时间效率上有优异的表现。</p>
<p>由于Scavenge是典型的空间换时间的算法，所以无法大规模地应用到所有的垃圾回收机制中。但是可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。所以，V8的堆内存分配应当如下：</p>
<p><img src="\images\Node-JS的内存控制\V8堆结构.jpg" alt="V8堆结构"></p>
<p>实际使用的堆是新生代的两个semispace空间大小和老生代所使用的内存大小之和。</p>
<h4 id="新生代向老生代的转换"><a href="#新生代向老生代的转换" class="headerlink" title="新生代向老生代的转换"></a>新生代向老生代的转换</h4><p>在V8中，在两种情况下，新生代的对象会转变为老生代的对象（对象晋升）：</p>
<ol>
<li>当一个对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，会检查它的内存来判断这个对象是否已经经历过一次Scavenge回收，如果经历过了，将该对象从From空间复制到老生代空间中，如果没有，则复制到To空间中。</li>
<li>当要从From空间复制一个对象到To空间时，如果To空间的内存占用使用超过了25%，则这个对象直接晋升到老生代空间中。这个限制的原因在于当这次Scavenge回收完成后，这个To空间将会变成From空间，接下来的内存分将会在这个空间中进行。如果占比过高，会影响后续的内存分配。</li>
</ol>
<h3 id="Mark-Sweep-amp-Mark-Compact"><a href="#Mark-Sweep-amp-Mark-Compact" class="headerlink" title="Mark-Sweep &amp; Mark-Compact"></a>Mark-Sweep &amp; Mark-Compact</h3><p>在老生代的对象中，由于存活对象占较大的比例，再采用Scavenge算法就会出现两个问题：</p>
<ol>
<li>存活的对象较多，复制存活对象的效率会降低。</li>
<li>浪费另一半内存的弊端在这个就先会放大。</li>
</ol>
<p>为此，V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。</p>
<h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><p>Mark-Sweep即标记清楚，它分为标记和清楚两个阶段。其核心在于，Mark-Sweep再标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清楚阶段中，只清楚没有被标记的对象。</p>
<p>可以看出，Scavenge中只复制标记的对象，而Mark-Sweep只清除死亡的对象。</p>
<p>而活对象在新生代中只占小部分，死对象在老生代只占较少部分，所以这两种算法刚好能够发挥最大性能。示意图如下（黑色表示死亡的对象）：</p>
<p><img src="\images\Node-JS的内存控制\mark-sweep.jpg" alt="mark-sweep"></p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>Mark-Sweep最大问题在于一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后面的内存分配造成问题，因为可能会出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就提前触发垃圾回收，而这次回收是不必要的。</p>
<h4 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h4><p>为了解决上面Mark-Sweep的碎片问题，在Mark-Sweep上的基础上提出了Mark-Compact，即标记整理。他们的差别在，Mark-Compact会在对象被标记为死亡后，在整理的过程中，将活着的对象向一端移动，移动完成后，直接清理掉边界外的内存。示意图如下（白色各自为存活对象，深色格子为死亡对象，浅色对象为存活对象移动后留下的空间）：</p>
<p><img src="\images\Node-JS的内存控制\mark-compact.jpg" alt="mark-compact"></p>
<p>完成移动后，就可以直接清除最右边的存活对象后面的内存区域完成回收。</p>
<p>但是由于Mark-Sweep与Mark-Compact的时间复杂度有很大差距，所以V8采用了结合使用的方式。将其对比如下：</p>
<table>
<thead>
<tr>
<th>参数/回收算法</th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Scavenge</th>
</tr>
</thead>
<tbody>
<tr>
<td>速度</td>
<td>较慢</td>
<td>很慢</td>
<td>较快</td>
</tr>
<tr>
<td>碎片</td>
<td>有</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>空间开销</td>
<td>少</td>
<td>少</td>
<td>双倍空间</td>
</tr>
<tr>
<td>发生移动</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>具体上，V8主要使用Mark-Sweep，在空间不足以对从新生代晋升过来的对象进行分配时才使用Mark-Compact。</p>
<h4 id="Incremental-Marking"><a href="#Incremental-Marking" class="headerlink" title="Incremental Marking"></a>Incremental Marking</h4><p>为了避免出现JavaScript逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都要将应该逻辑暂停下来，待执行完毕垃圾回收后再恢复执行应用的逻辑，这种行为被称为”全停顿“（stop-the-world）。在V8的分布式垃圾回收中，一次小垃圾的回收只影响新生代，由于新生代默认配置得比较少，且存活对象较多，全堆垃圾回收（full垃圾回收）的标记、清理、整理等动作造成得停顿就会比较可怕，需要设法改善。</p>
<p>为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是将回收的时间拆分为多个小”步进“，每做完一个”步进“，就让JavaScript应用逻辑执行一会，垃圾回收与应用逻辑交替执行直到标记阶段完成。</p>
<p>经过改进，垃圾回收的最大停顿时间可以减少到原来的1/6左右。</p>
<p>V8后续还引入了延迟清理（lazy sweeping）与增量式整理（incremental compaction），让清理与整理的动作也变为增量式的。同时还引入了并行标记和并行清理，进一步利用多核性能降低每次的停顿动作。 </p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>我们可以通过在Node启动的时候加上<code>trace_gc</code>来查看Node的垃圾回收日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --trace_gc app.js</span><br></pre></td></tr></table></figure>
<p>下面贴出一部分运行时日志示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[14632:000002A161C54EC0]   395853 ms: Scavenge 21.0 (24.3) -&gt; 19.8 (22.0) MB, 1.4 / 0.0 ms  (average mu = 0.995, current mu = 0.962) allocation failure </span><br><span class="line">[14632:000002A161C54EC0]   395862 ms: Scavenge 20.5 (22.0) -&gt; 20.1 (22.3) MB, 2.0 / 0.0 ms  (average mu = 0.995, current mu = 0.962) allocation failure </span><br><span class="line">[14632:000002A161C54EC0]   395870 ms: Scavenge 20.7 (22.3) -&gt; 20.4 (22.5) MB, 1.9 / 0.0 ms  (average mu = 0.995, current mu = 0.962) allocation failure</span><br><span class="line">[14632:000002A161C54EC0]   395879 ms: Scavenge 21.1 (22.5) -&gt; 20.5 (22.8) MB, 2.3 / 0.0 ms  (average mu = 0.995, current mu = 0.962) allocation failure </span><br><span class="line">[14632:000002A161C54EC0]   395915 ms: Mark-sweep 21.0 (22.8) -&gt; 14.1 (20.0) MB, 10.8 / 0.0 ms  (+ 0.3 ms <span class="keyword">in</span> 3 steps since start of marking, biggest step 0.1 ms, walltime since start of marking 30 ms) (average mu = 1.000, current mu = 1.000) finalize incremental marking via task GC <span class="keyword">in</span> old space requested</span><br></pre></td></tr></table></figure>
<p>通过垃圾回收日志，可以了解垃圾回收的运行状态，找出垃圾回收的哪些阶段比较耗时，触发的原因是什么。</p>
<p>在启动的时候加上<code>--prof</code>参数可以得到V8运行时的性能分析数据。期中也包含垃圾回收时占用的时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --prof app.js</span><br></pre></td></tr></table></figure>
<p>这将会在文件根目录生成一个xxx-v8.log文件，从这个文件可以读到每个内存的动作（包括shared libraries, code-creation, sfi, tick等），但是仍然不是很好读，下面是一段示例代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">v8-version,7,7,299,13,-node.16,0</span><br><span class="line">shared-library,C:\\Program Files\\nodejs\\node.exe,0x7ff76b1a0000,0x7ff76cfc1000,0</span><br><span class="line">shared-library,C:\\Windows\\SYSTEM32\\ntdll.dll,0x7ffcc8750000,0x7ffcc8945000,0</span><br><span class="line">shared-library,C:\\Windows\\System32\\KERNEL32.DLL,0x7ffcc6dd0000,0x7ffcc6e8d000,0</span><br><span class="line">shared-library,C:\\Windows\\System32\\KERNELBASE.dll,0x7ffcc60c0000,0x7ffcc6388000,0</span><br><span class="line">shared-library,C:\\Windows\\System32\\WS2_32.dll,0x7ffcc7270000,0x7ffcc72db000,0</span><br><span class="line">shared-library,C:\\Windows\\System32\\RPCRT4.dll,0x7ffcc6920000,0x7ffcc6a4b000,0</span><br><span class="line">...</span><br><span class="line">code-creation,Builtin,3,156659,0x7ff76bede690,86,Construct</span><br><span class="line">code-creation,Builtin,3,156665,0x7ff76bede6f0,78,ConstructVarargs</span><br><span class="line">code-creation,Builtin,3,156672,0x7ff76bede750,1028,ConstructWithSpread</span><br><span class="line">code-creation,Builtin,3,156678,0x7ff76bedeb70,1080,ConstructWithArrayLike</span><br><span class="line">code-creation,Builtin,3,156685,0x7ff76bedefb0,142,ConstructForwardVarargs</span><br><span class="line">code-creation,Builtin,3,156692,0x7ff76bedf050,142,ConstructFunctionForwardVarargs</span><br><span class="line">code-creation,Builtin,3,156699,0x7ff76bedf0f0,328,JSConstructStubGeneric</span><br><span class="line">code-creation,Builtin,3,156706,0x7ff76bedf250,244,JSBuiltinsConstructStub</span><br><span class="line">code-creation,Builtin,3,156712,0x7ff76bedf350,947,FastNewObject</span><br><span class="line">...</span><br><span class="line">sfi-move,0x3a2b6497110,0xde45da4bb8</span><br><span class="line">sfi-move,0x3a2b6497160,0xde45da3f50</span><br><span class="line">sfi-move,0x3a2b64971b0,0xde45da3fa0</span><br><span class="line">sfi-move,0x3a2b6497200,0xde45da3ff0</span><br><span class="line">...</span><br><span class="line">tick,0x7ffcc87efb14,66266607,0,0x0,6</span><br><span class="line">tick,0x7ffcc87efb14,66283096,0,0x0,6</span><br><span class="line">tick,0x7ffcc87efb14,66298653,0,0x0,6</span><br><span class="line">tick,0x7ffcc87efb14,66314624,0,0x0,6</span><br><span class="line">tick,0x7ffcc87efb14,66330633,0,0x0,6</span><br><span class="line">tick,0x7ffcc87efb14,66346563,0,0x0,6</span><br><span class="line">tick,0x7ffcc87efb14,66362684,0,0x0,6</span><br><span class="line">tick,0x7ffcc87efb14,66378772,0,0x0,6</span><br><span class="line">tick,0x7ffcc87efb14,66394645,0,0x0,6</span><br><span class="line">tick,0x7ffcc87efb14,66410815,0,0x0,6</span><br></pre></td></tr></table></figure>
<p>我们可以通过V8提供的API：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --prof-process isolate-0xnnnnnnnnnnnn-v8.log &gt; processed.txt</span><br></pre></td></tr></table></figure>
<p>生成profile文件，下面是例子（部分）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Statistical profiling result from .\isolate-000001A24906A4A0-14888-v8.log, (4214 ticks, 0 unaccounted, 0 excluded).</span><br><span class="line"></span><br><span class="line"> [Shared libraries]:</span><br><span class="line">   ticks  total  nonlib   name</span><br><span class="line">   4141   98.3%          C:\Windows\SYSTEM32\ntdll.dll</span><br><span class="line">     71    1.7%          C:\Program Files\nodejs\node.exe</span><br><span class="line"></span><br><span class="line"> [JavaScript]:</span><br><span class="line">   ticks  total  nonlib   name</span><br><span class="line">      1    0.0%   50.0%  LazyCompile: *resolve path.js:130:10</span><br><span class="line">      1    0.0%   50.0%  LazyCompile: *nextPart fs.js:1433:31</span><br><span class="line"></span><br><span class="line"> [C++]:</span><br><span class="line">   ticks  total  nonlib   name</span><br><span class="line"></span><br><span class="line"> [Summary]:</span><br><span class="line">   ticks  total  nonlib   name</span><br><span class="line">      2    0.0%  100.0%  JavaScript</span><br><span class="line">      0    0.0%    0.0%  C++</span><br><span class="line">      9    0.2%  450.0%  GC</span><br><span class="line">   4212  100.0%          Shared libraries</span><br></pre></td></tr></table></figure>
<p>也可以采用其他第三方工具进行分析，具体不再细讲。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>V8的这些限制在浏览器端看起来很合理，一个页面很少能占用超多2GB内存，但是在服务端，这就显得捉襟见肘了，为此，Node开发了<code>Buffer</code>，<code>Stream</code>等模块，来弥补V8的不足，后面会陆续详解。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本文大部分参考《深入浅出nodejs》以及<a href="https://nodejs.org/" target="_blank" rel="noopener">Node</a>官网</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>内存控制</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript深入解析3-类与行为委托</title>
    <url>/2019/07/19/javaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%903-%E7%B1%BB%E4%B8%8E%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h1 id="JavaScript中“纠结的类”"><a href="#JavaScript中“纠结的类”" class="headerlink" title="JavaScript中“纠结的类”"></a>JavaScript中“纠结的类”</h1><p>正如前文所说，JavaScript中并没有传统意义上的“类”，可能是因为在JavaScript这门脚本语言诞生之初，并没有人会他会有如今的成就，所以就借用了<a href="https://baike.baidu.com/item/self%E8%AF%AD%E8%A8%80/4376342?fr=aladdin" target="_blank" rel="noopener">Self</a>语言的基于原型的面向对象设计。具体可以看<a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html" target="_blank" rel="noopener">JavaScript的诞生</a></p>
<a id="more"></a>
<h2 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h2><p>面向对象编程是一种编程思想，其重要思维体现在：</p>
<ol>
<li>封装性：讲一组方法，变量封装在一个“模块”中，一般来说是一个类。</li>
<li>继承性：继承性是面向对象技术中的另外一个重要特点，是指一个类继承另一个类的方法，类的继承。他们的关系通常是父与子的关系。</li>
<li>多态性：是指子类对父类的方法进行重写或重载。</li>
</ol>
<p>对于传统的OOP语言，比如java，C++。</p>
<p><strong>类意味着复制。</strong></p>
<p><strong>实例化时，他的行为会被复制到实例中；继承时，行为也会被复制到子类中。</strong></p>
<h2 id="JavaScript中的类"><a href="#JavaScript中的类" class="headerlink" title="JavaScript中的类"></a>JavaScript中的类</h2><p>JavaScript程序员开始大都是由其它语言程序员没经过系统学习这门语言的精髓就开始编程（因为大家认为JavaScript是一门脚本语言，是如此的简单。）所以从开始到现在，程序员们总是试图使用JavaScript来进行面向对象编程，寻找类这个东西的存在。然而不幸的是，<strong>JavaScript没有传统的类</strong>。还好我们拥有[[prototype]]这个好东西，我们才能进行所谓的面向对象编程。但这任然不是我们传统观念上的面向对象编程，<strong>即使是ES6中ECMA提供的class关键字，任然是[[prototype]]的原法糖。</strong></p>
<h3 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h3><p>在许多JavaScript库中都提供了类的语法糖，我们来看一下其内部是如何实现的。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tom = <span class="keyword">new</span> Person(<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">var</span> mike = <span class="keyword">new</span> Person(<span class="string">'mike'</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以直接用new操作符进行“类的实例化”，但是JavaScript中不存在类。所以我们实际上是新创建了一个空对象，然后将其[[prototype]]设为Person.prototype。然后将该函数的this指向新建对象，然后调用该函数，如果函数没有返回对象，就返回新建对象。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>下面是最典型的一种继承实现方式（JavaScript中多种实现继承的方式，但大同小异）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	Person.prototype.me = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Person'</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,id</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//调用父级构造函数，相当于super</span></span><br><span class="line">	Person.call(name);</span><br><span class="line">	<span class="keyword">this</span>.id = id;</span><br><span class="line">	Student.prototype.onduty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Studnet'</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//"继承"</span></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person0 = <span class="keyword">new</span> Person(<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">var</span> student0 = <span class="keyword">new</span> Student(<span class="string">'mike'</span>,<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以看出来，所谓的继承，也就是<code>Student.prototype = Object.create(Person.prototype)</code>这句话，<strong>实际上是将子类Student的[[prototype]]设置为一个空对象，该对象的[[prototype]]指向父级类Person的prototype。（Object.create(obj1)）的意义是创建一个空对象，该对象的[[proottype]]指向obj1</strong>首先我们需要了解的是，我们有4个对象(在JavaScript中函数也是对象，可以拥有自己的属性)来储存数据：</p>
<ol>
<li>student0</li>
<li>student0.<strong>proto</strong> ([[prototype]])（注意通过Object.create方式创建的<code>__proto__</code>并不指向<code>Student.peototype</code>）</li>
<li>Student</li>
<li>Student.prototype</li>
</ol>
<p>根据原型链的查找规则，我们在获取实例的某个属性时，会分别从：student0 —&gt; student0.<strong>proto</strong>-&gt;Student-&gt;Student.prototype查找。</p>
<p>看下面的图：</p>
<p><img src="\images\javaScript深入解析3-类与行为委托\3.1.png" alt="继承链"></p>
<p>我们可以看到，子类的属性在实例的__proto__中，父类的属性在实例的__proto__的__proto__中，因此我们可以获取子类，父类的所有方法，我们就完成就继承。</p>
<h4 id="ES6的中类"><a href="#ES6的中类" class="headerlink" title="ES6的中类"></a>ES6的中类</h4><p>上面提过，ES6中的出现了class关键字，下面我们通过ES6的方法重写一下的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	construct(name)&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	speak()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"name:"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	construct(name,id)&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	me()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"name:"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"id:"</span>+<span class="keyword">this</span>.id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person0 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> student0 = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<p>这个看上去漂亮多了，就像是在写传统的OOP的语言。但是实际上，它的背后任然是混乱的[[prototype]]的链。</p>
<p>ES6的class还有一个常用的特点，静态方法。所谓静态方法，就是直接可以在类上面直接调用的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	construct(name)&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	speak()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"name:"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> sayme()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'me'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想一下class背后的原理，用ES5的语法来实现以下static：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.sayme = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'me'</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>没错，就是这么简单！<strong>只是因为这个方法是类自身的属性，并不是方法的[[prototype]]属性值。</strong></p>
<h3 id="混入-mixin"><a href="#混入-mixin" class="headerlink" title="混入(mixin)"></a>混入(mixin)</h3><p>正如我们之前所说，<strong>传统的OOP意味着复制</strong>。</p>
<p>然而我们JavaScript中模拟的类，并不是传统的复制，而是基于原型链的“伪类”。</p>
<p>所以为了实现很真实的“类”，我们有了<strong>混入(mixin)</strong>这一概念。</p>
<h4 id="显示混入"><a href="#显示混入" class="headerlink" title="显示混入"></a>显示混入</h4><p>看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">sourceObj,tragetObj</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> sourceObj)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(key <span class="keyword">in</span> targetObj))&#123;</span><br><span class="line">			targetObj[key] = sourceObj[key]	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> targetObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Vehicle = &#123;</span><br><span class="line">	engines: <span class="number">1</span>,</span><br><span class="line">	ignition: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"turn on my engine"</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	drive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ignition();</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Steering and move forward!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Car = mixin(Vehicle,&#123;</span><br><span class="line">	wheel: <span class="number">4</span>,</span><br><span class="line">	dirive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		Vehicle.drive.call(<span class="keyword">this</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Rolling on all"</span>+<span class="keyword">this</span>.wheels+<span class="string">"wheels!"</span>)	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​<br>没错，就是一次复制过程。现在我们也可以用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">object.assign(targetObj,sourceObj);</span><br></pre></td></tr></table></figure>
<p>因为这个方法的原理就是上面的mixin函数。</p>
<h4 id="隐式混入"><a href="#隐式混入" class="headerlink" title="隐式混入"></a>隐式混入</h4><p>思考下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> something = &#123;</span><br><span class="line">	cool: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.greeting = <span class="string">"hello wowld!"</span>;</span><br><span class="line">		<span class="keyword">this</span>.count = <span class="keyword">this</span>.count ? <span class="keyword">this</span>.count++ : <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Something.cool();</span><br><span class="line">something.greeting; <span class="comment">//hello world</span></span><br><span class="line">something.count; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Another = &#123;</span><br><span class="line">	cool: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		something.cool.call(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Another.cool();</span><br><span class="line">Another.greeting; <span class="comment">//"hello world"</span></span><br><span class="line">Another.count; <span class="comment">//1 (count不是共享的)</span></span><br></pre></td></tr></table></figure>
<p>关键在于<strong>something.cool.call(this)</strong>，将something.cool函数的this指向了Another这个对象。因此，我们把Something的行为“混入”到Another中。</p>
<h1 id="更合理的编程思想：行为委托"><a href="#更合理的编程思想：行为委托" class="headerlink" title="更合理的编程思想：行为委托"></a>更合理的编程思想：行为委托</h1><h2 id="类与委托的前世今生"><a href="#类与委托的前世今生" class="headerlink" title="类与委托的前世今生"></a>类与委托的前世今生</h2><p>如我们前面所说，JavaScript本身是不存在类的，只是为了适应程序员们的设计习惯，我们使JavaScript中有了“类”的存在，实际上这种设计方式无疑是把吧苹果涂上橙色，在上面插上孔…然后把它装饰成橘子。但他始终都是苹果，无论我们怎么在外部伪装。既然如此，为什么我们不直接把它当成橘子来吃呢？</p>
<h2 id="如何使用行为委托"><a href="#如何使用行为委托" class="headerlink" title="如何使用行为委托"></a>如何使用行为委托</h2><p>看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Task = &#123;</span><br><span class="line">	setId: fucntion(id)&#123;<span class="keyword">this</span>.id = id;&#125;,</span><br><span class="line">	outputID: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.id)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someWork = <span class="built_in">Object</span>.create(Task);</span><br><span class="line"></span><br><span class="line">someWork.prepareTask = fucntion(id,label)&#123;</span><br><span class="line">	<span class="keyword">this</span>.setId(id);</span><br><span class="line">	<span class="keyword">this</span>.label = label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">some.outputTaskDetails = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.outputId();</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someWork0 = <span class="built_in">Object</span>.create(someWork);</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，Task，someWork都不是类（或者函数），而是对象。我们把someWork的[[prototype]]委托给了Task。这很符合Self语言的基于原型的面向对象编程的思想。这也被成为“对象关联（OLOO）”</p>
<p>对象关联风格的代码还有一些不同之处。</p>
<ol>
<li>在代码上，id和label数据成员都是直接存储someWork之上，而不是Task。</li>
<li>在类的思想上，我们鼓励方法的重写（多态）。也就上在子类中定义父类同名的函数。但在委托行为中恰恰相反，我们尽量避免在[[prototype]]链上存在同名函数。</li>
</ol>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>不得不说，行为委托从语言底层来说更加适合JavaScript编程，但是越来越多的程序员习惯使用面向对象的编程思想。这迫使JavaScript不得不改变自己，比如在ES6中推出了class的语法糖，但这代表了官方的认可，也许在不久的将来，我们可以看见真正的class出现在JavaScript。</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>类</tag>
        <tag>行为委托</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-I-12-并发</title>
    <url>/2022/01/24/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-12-%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<hr>
<h1 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h1><blockquote>
<p>在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p>
<p>　　后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。</p>
</blockquote>
<p>下面是一个Java中创建线程的代码：</p>
<ol>
<li><p>将执行这个代码的任务放在一个类的<code>run</code> 方法中。注意这个类必须实现<code>Runnable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Runnable</code>是一个函数式接口，因此可以用一个lambda表达式创建一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123;task code&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从这个<code>Runnable</code>构造一个<code>Thread</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Thread(r);</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<p>注意：不要直接调用<code>Thread</code>或者<code>Runnable</code>对象的<code>run</code>方法。否则其只会在同一个线程中执行这个任务，而没有启动新的线程。</p>
<p>例如：银行转账的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; STEPS; i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> amount = MAX_AMOUNT * Math.random();</span><br><span class="line">            bank.tanfor(<span class="number">0</span>, <span class="number">2</span>, amount);</span><br><span class="line">            Thread.sleep((<span class="keyword">int</span>) (DELAY * Math.random()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Interruption e)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<p>对于给定的步骤数，这个线程会转账一个随机金额，然后休眠一个随机时常。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>Java中的线程有以下6种状态：</p>
<ul>
<li>New-新建</li>
<li>Runnable-可运行</li>
<li>Blocked-阻塞</li>
<li>Waiting-等待</li>
<li>Timed waiting-计时等待</li>
<li>Terminated-终止</li>
</ul>
<p>要确定当前进程的状态，只需调用<code>getState</code>方法。</p>
<h3 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h3><p>当使用<code>new</code>操作符创建一个新线程时，如<code>new Thread(r)</code>，这个线程哈没有开始要运行。此时其状态就是新建<code>new</code>。</p>
<h3 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h3><p>一旦调用<code>start</code>操作，线程就处于可运行（<code>runnbale</code>）状态。但是一个可运行的线程可能正在运行，也可能没有运行。要由操作系统为线程提供具体的运行时间。</p>
<p>一个线程开始运行，它不一定始终保持运行。因为可能不同的操作紫铜调度机制不一样，可能存在抢占式。</p>
<h3 id="阻塞和等待线程"><a href="#阻塞和等待线程" class="headerlink" title="阻塞和等待线程"></a>阻塞和等待线程</h3><p>当线程处于阻塞或等待状态时，他暂时是不活动的。期间不运行任何代码，而且消耗最少资源。要由线程调度器重新激活这个线程。</p>
<ul>
<li>当一个线程试图获取一个内部的对象锁，而这个锁母亲被其他线程占有，该线程就会被阻塞。当其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，它将变成非阻塞的。</li>
<li>当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。实际上，阻塞状态和等待状态并没有很大区别。</li>
<li>有几个方法有超时参数，调用这写方法时会让线程进入计时等待（timed waiting）状态，这一状态会一直保持到超时期满或者接收到适当的通知时。</li>
</ul>
<p>下面时各种状态的转换图：</p>
<p><img src="../images/java核心技术/线程状态.jpg" alt="线程状态"></p>
</li>
</ol>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>线程会由于以下两个原因之一而终止：</p>
<ul>
<li>run方法正常退出，线程自然终止。</li>
<li>因为一个没有捕获的异常终止了run方法，使线程意外终止。</li>
</ul>
<p>另外线程的<code>stop</code>方法也可以手动杀死一个线程。但是该方法已经被废除，最好不要使用。</p>
<h1 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h1><p>线程的各种属性包括中断的状态、守护线程、未捕获异常的处理器以及不应使用的一些遗留特征。</p>
<h2 id="终端线程"><a href="#终端线程" class="headerlink" title="终端线程"></a>终端线程</h2><p>如上终止线程所说，只有run方法自然退出，或因为异常不正常退出才能终止线程。</p>
<p>除了已经废除的stop方法，没有办法可以强制线程终止。</p>
<p>不过，<code>interrupt</code>方法可以用来请求终止一个线程。</p>
<p>当对一个线程调用<code>interrupt</code>方法时，就会设置线程的中断状态。这是每个线程都有的boolean状态。每个线程都应该不是地检查这个标志，以判断这个线程是否被中断。</p>
<p>但是当线程处于阻塞时，无法检测中断状态。</p>
<p>没有任何语言要求被中断地线程应该被终止。中断一个线程只是要引起它地注意。被中断的线程可以决定如何响应中断。某些线程非常重要，所以应当处理这个异常，然后在继续执行下去。但是，更普遍的情况时，线程只希望将中断解释为一个中断请求。其格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span>(!Thread.currentThread().isInterrupeted() &amp;&amp; more works to <span class="keyword">do</span>)&#123;</span><br><span class="line">      <span class="comment">//do more work</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterrutedException e)&#123;</span><br><span class="line">      <span class="comment">//thread was interrupted during sleep or wait</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">//clean up if required</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// existing the run method terminated the thread.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程名"><a href="#线程名" class="headerlink" title="线程名"></a>线程名</h3><p>默认情况下，线程有容易记的名字，如<code>Thread-2</code>。 可以用setName方法为线程设置任何名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">t.setName(<span class="string">"Web crawler"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="未捕获异常的处理器"><a href="#未捕获异常的处理器" class="headerlink" title="未捕获异常的处理器"></a>未捕获异常的处理器</h3><p>现场的run方法不能抛出任何检查型异常，但是，非检查型异常可能会导致线程终止。这种情况下，线程会死亡。</p>
<p>不过，对于可传播的异常，并没有任何<code>catch</code>子句。实际上，在线程死亡之前，异常会传递到一个用于处理未捕获异常的处理器。</p>
<p>这个处理器必须属于一个实现了<code>Thread.UncaughtExceptionHandler</code>接口的类。这个接口只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以用<code>setUncatchExceptionHandler</code>方法为任何线程安装一个处理器。</p>
<p>也可以用<code>Thread</code>类的静态方法<code>setDefaultsetUncatchExceptionHandler</code>为所有线程安装一个默认的处理器。（这些处理器可以将异常信息保存到文件中。）</p>
<p>如果没有安装默认处理器，默认处理器则为null。但是，如果没有为单个线程安装处理器，那么处理器就是该线程的<code>ThreadGroup</code>对象。</p>
<blockquote>
<p>线程组（<code>ThreadGroup</code>）是可以一起管理的线程的集合。默认情况下，所有的线程都属于同一个线程组，但是也可以建立其他的组。由于现在引入了更好的特性来处理线程集合，所以不建议再使用线程组。</p>
</blockquote>
<p><code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionHandler</code>接口。它的<code>uncatchException</code>方法执行一下操作：</p>
<ul>
<li>如果该线程组有父线程组，那么调用父线程组的<code>uncatchException</code>方法。</li>
<li>否则，如果<code>Thread.getDefaultExceptionHandler</code>方法返回一个非nul的处理器，则调用该处理器。</li>
<li>否则，如果<code>Throwable</code>是<code>ThreadDeath</code>的一个实例，什么也不做。</li>
<li>否则，将线程的名字以及<code>Throwable</code>的轨迹输出到<code>System.err</code>。</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在Java程序设计语言中，每个线程都有一个优先级。其优先级有10级，从1（<code>MIN_PRIORITY</code>）到10(<code>max_priority</code>)。其默认为5（<code>NORM_PRIORITY</code>）。</p>
<p>每当线程调度器有机会选择新线程时，它会首先选择具有较高优先级的线程。<strong>但实际的线程优先级会根据操作系统的优先级</strong>。比如<code>Windows</code>有7个优先级。而Linux的线程则所有线程优先级都一样，所以会忽略线程优先级。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>在大多数实际的多线程应用中，两个或两个以上的新线程需要共同修改同一数据。而不同的调用顺序会导致不同的结果。这种情况通常被称为竞态条件（<code>race condition</code>）。</p>
<h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>有两种机制可以防止并发的访问代码块。</p>
<ul>
<li>使用<code>synchronized</code>关键字：会自动提供一个锁以及相关的“条件”。</li>
<li>使用Java5引入的<code>ReentrantLock</code>类。</li>
</ul>
<p>使用<code>ReentrantLock</code>保护代码块的基本结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mylock = <span class="keyword">new</span> ReentrantLock();			<span class="comment">//新建锁对象，一般在其他位置</span></span><br><span class="line">mylock.lock();		<span class="comment">//使用该锁对象加锁</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//critical section</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  mylock.unlock();	<span class="comment">// 使用该锁对象解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构确保任何时候只有一个线程进入临界区。一旦一个线程锁定了锁对象，其他任何使用到该锁的线程都无法通过lock语句。</p>
<p>要把<code>unlock</code>语句操作包括在<code>finally</code>语句中，这一点很关键。如果在临界区的代码抛出一个异常，锁必须释放。否则，其他线程将永远阻塞。</p>
<p>值得注意的是：</p>
<ol>
<li><p>锁不能使用<code>try-with-resources</code>语句。其原因在于：</p>
<ul>
<li>解锁方法不是<code>close</code>。</li>
</ul>
</li>
</ol>
<ul>
<li><code>try-with-resources</code>期望的是一个新变量且在首部声明，而锁变量不是。</li>
</ul>
<ol start="2">
<li>重入锁（reentrant lock），每个对象都拥有唯一的锁。并且每个线程可以反复获得已拥有的锁。锁有一个持有计数（hold count）来跟踪对lock方法的嵌套调用。线程每调用一次lock后都要调用unlock来释放锁。</li>
</ol>
<h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>通常，线程进入临界区后却发现只有满足了某个条件之后它才能执行。可以使用一个条件对象来管理那些已经获得一个锁却不能做有用工作的线程。在Java中，条件对象被称为条件变量（conditional variable）。</p>
<p>即当一个线程拥有锁，但是却仍然不能运行（可能缺少其它资源），那么此时这个线程<strong>应当</strong>放弃这个锁。其实就是防止产生死锁。</p>
<p>例如转账中，当发现账户余额不足的时候，应当放弃这个账户的锁。代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Condition stuffcientFunds;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    sufficientFunds = bankLock.newCondition();			<span class="comment">//关键</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时如果<code>transfer</code>方法发现资金不足，他会调用：</p>
<p><code>stuffcientFunds.await();</code></p>
<p>当前线程现在暂停，并放弃锁。这就允许另一个线程来拥有这个锁，从而防止死锁。</p>
<p>一旦一个线程调用了<code>await</code>方法，他就进入这个条件的等待集（<code>wait set</code>）。当锁可用时，该线程也不会立即变为可运行状态。实际上，他仍然保持非活动状态，知道另一个线程在同一条件上调用<code>signalAll</code>方法。</p>
<p>即，当另外一个线程完成转账时，它应该调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stuffcientFunds.signalAll();</span><br></pre></td></tr></table></figure>
<p>这个调用会重新激活等待这个条件的所有线程。</p>
<p>此时，线程应当再次测试。不能保证现在一定满足条件-<code>signalAll</code>方法仅仅是通知等待的线程：现在有可能满足条件，值得再次检查条件。</p>
<p>通常，<code>await</code>调用应该放在如下形式的循环中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!(process is ok))</span><br><span class="line">  condition.await();</span><br></pre></td></tr></table></figure>
<p>注意<code>signalAll</code>调用不会立即激活一个等待的线程，它只是接触等待线程的阻塞，是这些线程可以在当前线程释放锁之后竞争访问对象。</p>
<p>另一个<code>signal</code>只是随机选择等待集合中的一个线程，并且解决这个线程的阻塞状态。这个方法虽然高效，但也是危险的，因为可能释放的那个线程可能仍然是不能运行的。</p>
<p>注意：只有当线程拥有一个条件的锁时，它才能在这个条件上调用<code>await</code>，<code>signalAll</code>和<code>signal</code>方法。</p>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><code>synchronized</code>关键字</h3><p>在了解<code>synchronized</code>关键字之前，先对锁和条件的要点做一个总结：</p>
<ul>
<li>锁用来保护代码片段，一次只能有一个线程执行被保护的代码。</li>
<li>锁可以管理试图进入被保护代码段的线程。</li>
<li>一个锁可以有一个或多个相关联的条件对象。</li>
<li>每个条件对象管理那些已经进入被保护代码段但还不能运行的线程。</li>
</ul>
<p><code>Lock</code>和<code>Conditon</code>接口允许程序员充分控制锁定。不过，在大多数情况下，你并不需要那样控制，完全可以使用Java语言内置的一种机制。从1.0开始，Java中的每个对象都有一个内部锁。如果一个方法声明时有<code>synchronized</code>方法修饰符，那么对象的锁将保护整个对象。也就是说，要调用这个方法，线程必须获得内部对象锁。</p>
<p>换句话说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//method body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.intrinsicLock.lock();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//method body</span></span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intrnsicLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部对象锁只有一个关联条件。<code>wait</code>方法将一个线程增加到等待集中，<code>notifyAll/notify</code>方法可以解除等待线程的阻塞。换句话说，调用<code>wait</code>或<code>notifyAll</code>等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intrinsicCondition.await();</span><br><span class="line">intrinsicCondition.signalAll();</span><br></pre></td></tr></table></figure>
<p>注释：<code>wait</code>，<code>notifyAll</code>以及<code>notify</code>方法是<code>Object</code>类的<code>final</code>方法。<code>Condition</code>方法必须命名为<code>await</code>、<code>signalAll</code>和<code>signal</code>，从而不会与那些方法发生冲突。</p>
<p>例如，可以用Java如下实现Bank类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> amount)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(accounts[from] &lt; amount)</span><br><span class="line">      wait();	<span class="comment">//wait on intrinsic object lock`s single condition</span></span><br><span class="line">    accounts[from] -= amount;</span><br><span class="line">    accounts[to] += amount;</span><br><span class="line">    notifyAll();		<span class="comment">//notify all the threads waiting on the condition</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用<code>synchronized</code>关键字可以得到更为简洁的代码。</p>
<p>要理解这段代码，必须明白每个对象都有一个内部锁，并且这个锁有一个内部条件。这个锁管理试图进入<code>synchronzed</code>方法的线程，这个条件可以管理调用了<code>wait</code>的线程。</p>
<p>将静态方法声明为同步也可以是合法的。如果调用这样的方法，它会获得相关类对象的内部锁。并且其内置锁会被锁定。因此，没有其他线程可以调用这个类的该方法或任何其他同步静态方法。</p>
<p>内部锁和条件存在一些限制：</p>
<ul>
<li>不能中断一个正在尝试获得锁的线程。</li>
<li>不能指定尝试获得锁时的超时时间。</li>
<li>每个锁仅有一个条件可能是不够的。</li>
</ul>
<p>那么在代码中应该使用哪种方式呢，<code>Lock</code>和<code>Condition</code>对象还是<code>synchronized</code>关键字呢？建议如下：</p>
<ul>
<li>最好既不是用<code>Lock</code>和<code>Condition</code>对象，也不是使用<code>synchronized</code>关键字。在多数情况下，可以使用<code>java.util.concurrent</code>包中的某种机制，他会自动处理所有的锁定。</li>
<li>如果<code>synchronized</code>关键字可以满足需求，则使用<code>synchronized</code>关键字，这样可以减少代码量也可以减少错误。</li>
<li>如果特别需要<code>Lock</code>和<code>Condition</code>结构提供的额外能力，则使用<code>Lock/Condtion</code>。</li>
</ul>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><p>正如前面说的，每一个Java对象都有一个锁。线程可以通过调用同步方法获得锁。还有另外一种方式获得锁：即进入一个同步块。</p>
<p>形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">  <span class="comment">//critical section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部的代码就会获得obj的锁。</p>
<h3 id="监视器概念"><a href="#监视器概念" class="headerlink" title="监视器概念"></a>监视器概念</h3><p>锁和条件是实现线程同步的强大工具。但其严格的讲，并不是面向对象的。而监视器就是为解决这一点诞生的。</p>
<p>从Java的术语来说，监视器具有如下特征（<strong>Java中并没有如此实现</strong>）：</p>
<ul>
<li>监视器是只包含私有字段的类。</li>
<li>监视器类的每个对象有一个关联的锁。</li>
<li>所有方法由这个锁锁定。也就是说，当调用<code>obj.method()</code>时，那么obj对象的锁在方法调用开始时自动获得，并且当方法调用自动释放该锁。并且由于所有字段都是私有的，就可以保证当一个线程处理一个字段时，其他的字段无法访问该字段。</li>
<li>锁可以有任意多个相关联的条件。</li>
</ul>
<p>Java设计者以不太严格的方式实现了监视器概念。其有3处不同于监视器概念:</p>
<ul>
<li>字段不要求是<code>private</code>。</li>
<li>方法不要求是<code>synchronized</code>。</li>
<li>内部锁对客户端是可用的。</li>
</ul>
<h3 id="volatile字段-可见性"><a href="#volatile字段-可见性" class="headerlink" title="volatile字段-可见性"></a>volatile字段-可见性</h3><p><code>volatile</code>关键字为实例字段的同步访问提供了一种免锁机制。如果一个字段声明为<code>volatile</code>，那么编译器和虚拟机就知道该字段可能被另一个线程并发更新。</p>
<p>例如，假设一个对象有一个<code>boolean</code>标记为<code>done</code>，它的值由一个线程设置，而由另外一个线程查询，如同我们讨论的那样，可以用锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> done;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setDone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    done = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，将字段声明为<code>volatile</code>就很合适：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> done;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    done = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会插入适当的代码，以确保如果一个线程对done变量做了修改，这个修改对读取这个变量的所有其他线程都可见。</p>
<p>注意：<code>volatile</code>变量不能提供原子性。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flipDone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    done = !done;</span><br><span class="line">&#125;		<span class="comment">//not atomic</span></span><br></pre></td></tr></table></figure>
<p>不能确保反转字段中的值。不能保证读取、翻转和写入不被中断。</p>
<h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><p>当然也可以使用final来确保读取，因为其只有初始化时可以赋值。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><code>java.util.concurrent.atomic</code>包中有很多类使用了很高效的机器级指令（没有使用锁）来保证其他操作的原子性。</p>
<p>例如，<code>AtomicInteger</code>类使用了方法<code>incrementAndGet</code>和<code>decrementAntGet</code>，它们分别以源自方式将一个整数进行自增或自减。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicLong nextNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="comment">//in some method</span></span><br><span class="line"><span class="keyword">long</span> id = nextNumber.incrementAndGet();</span><br></pre></td></tr></table></figure>
<p><code>decrementAntGet</code>方法以原子方式将<code>AtomicLong</code>自增，并返回自增后的值。也就是说：<strong>获得值，增加1，然后生产新的值的操作不会中断。</strong>所以也可以保证多个线程访问时不会出错。</p>
<p>这个包中有更多的方法（可以用名字看出其功能）</p>
<ul>
<li><code>AtomicBoolean.classAtomicInteger.class</code></li>
<li><code>AtomicIntegerArray.class</code></li>
<li><code>AtomicIntegerFieldUpdater</code></li>
<li><code>classAtomicLong.class</code></li>
<li><code>AtomicLongArray.class</code></li>
<li><code>AtomicLongFieldUpdater.class</code></li>
<li><code>AtomicMarkableReference.class</code></li>
<li><code>AtomicReference.class</code></li>
<li><code>AtomicReferenceArray.class</code></li>
<li><code>AtomicReferenceFieldUpdater.class</code></li>
<li><code>AtomicStampedReference.class</code></li>
<li><code>DoubleAccumulator.class</code></li>
<li><code>DoubleAdder.class</code></li>
<li><code>LongAccumulator.class</code></li>
<li><code>LongAdder.class</code></li>
<li><code>Striped64.class</code></li>
</ul>
<p>值得注意的是，如果有大量的线程要访问相同的原子值，性能就会大幅度下降，因为乐观锁更新需要太多次重试。</p>
<p><code>LongAdder</code>和<code>LongAccumulator</code>类解决了这个问题。<code>LongAdder</code>包含多个变量（加数），其总和值为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，只有当所有工作完成后才需要总和的值，这个时候用<code>LongAdder</code>效果就会很好。</p>
<p>所以，当预计会有很多线程竞争的时候，用<code>LongAdder</code>更高效。</p>
<p>而自增的时候，需要调用<code>add</code>方法，只有调用<code>sum</code>方法时，才会获得其值。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = <span class="keyword">new</span> LongAdder();</span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">  pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">      <span class="keyword">if</span>(...) adder.increment();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> total = adder.sum();</span><br></pre></td></tr></table></figure>
<p>同样也有<code>DoubleAdder</code>和<code>DoubleAccumulator</code>来完成浮点数的操作。</p>
<h3 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h3><p>可以通过<code>ThreadLocal</code>来<strong>为每个线程都单独提供一个变量</strong>，这个变量就不支持共享，也不会存在同步的问题。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormate = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//...code</span></span><br><span class="line">String dateStamp = dateFormat.get().format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><p>Java提供了一些线程安全的集合。用来对应常规的集合。</p>
<h3 id="阻塞线程接口（BlockingQueue-interface）"><a href="#阻塞线程接口（BlockingQueue-interface）" class="headerlink" title="阻塞线程接口（BlockingQueue interface）"></a>阻塞线程接口（<code>BlockingQueue interface</code>）</h3><p>阻塞线程用来对应常规的队列。其提供了两套API，可以在有问题的时候阻塞或者抛出错误。工作线程可以周期性的将中间结果存储在阻塞队列之中。其他工作线程移除中间结果，并进一步进行性修改。队列会自动地平衡负载。下表是阻塞队列地方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>正常动</th>
<th>特殊情况下地动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>添加一个元素</td>
<td>若队满，则抛出<code>IllegalStateException</code>异常</td>
</tr>
<tr>
<td>element</td>
<td>返回队头元素</td>
<td>若队空，则抛出<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td>offer</td>
<td>添加一个元素并返回true</td>
<td>若队满，则返回false</td>
</tr>
<tr>
<td>peek</td>
<td>返回队头元素</td>
<td>若队空，则返回null</td>
</tr>
<tr>
<td>poll</td>
<td>移除并返回队头元素</td>
<td>若队空，则返回null</td>
</tr>
<tr>
<td>put</td>
<td>添加一个元素</td>
<td>若队满，则阻塞</td>
</tr>
<tr>
<td>remove</td>
<td>移除并返回队头元素</td>
<td>若队空，则抛出<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td>take</td>
<td>移除并返回队头元素</td>
<td>若队空，则阻塞</td>
</tr>
</tbody>
</table>
<p>阻塞队列方法分为3类（取决于队满或队空时的动作）：</p>
<ol>
<li>如果使用队列作为线程管理工具，将要使用<code>put</code>和<code>take</code>方法，这两个方法将阻塞进程。</li>
<li>当试图向满队添加元素或向从空队中获取元素时，add、remove和element操作将会抛出异常。</li>
<li>offer、poll和peek方法将会给出提示而不是错误。而offer和poll还支持超时参数。</li>
</ol>
<h3 id="数组阻塞队列（ArrayBlockingQueue）"><a href="#数组阻塞队列（ArrayBlockingQueue）" class="headerlink" title="数组阻塞队列（ArrayBlockingQueue）"></a>数组阻塞队列（<code>ArrayBlockingQueue</code>）</h3><p>数组阻塞队列继承自<code>AbstractQueue</code>并且实现了<code>BlockingQueue</code>。</p>
<p>其基本实现还是数组，并且方法都是<code>BlockingQueue</code>接口中地方法。</p>
<p>同样地，与常规对应，还存在</p>
<ul>
<li><code>LinkedBlockingQueue</code>，其内部实现为链表，同样<code>AbstractQueue</code>并且实现了<code>BlockingQueue</code>。</li>
<li><code>PriorityBlockingQueue</code>和<code>PriorityQueue</code>特性一致，不过是实现了同步。</li>
</ul>
<h3 id="高效映射、集和队列"><a href="#高效映射、集和队列" class="headerlink" title="高效映射、集和队列"></a>高效映射、集和队列</h3><p><code>java.util.concurrent</code>包中还提供了映射、有序集合和队列地高效实现：</p>
<ul>
<li><code>ConcurrentHashMap</code></li>
<li><code>ConcurrentSkipListMap</code></li>
<li><code>ConcurrentSkipListSet</code></li>
<li><code>ConcurrentLinkedQueue</code></li>
</ul>
<p>这些集合使用复杂的算法，通过允许并发地访问数据结构地不同部分尽可能减少竞争。</p>
<p>注意这些集合返回的<code>size</code>并不一定能在常量时间内完成操作。确认这些集合的大小通常需要遍历。</p>
<p>并发散列集可以高效地支持大量的getter和一定数量的setter。一般认为其支持至多16个setter。当多于16个时，其他的将会被暂时阻塞。</p>
<h3 id="并发散列集地批量操作"><a href="#并发散列集地批量操作" class="headerlink" title="并发散列集地批量操作"></a>并发散列集地批量操作</h3><p>批量操作即提供方法来遍历散列集并执行一些操作。具体有3种不同的操作：</p>
<ul>
<li><code>search</code>（搜索）：为每个键或值应用一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函数的结果。</li>
<li><code>reduce</code>（规约）：组合所有建或值，这里要使用所提供的一个累加函数。</li>
<li><code>forEach</code>（遍历）：为所有的键或值应用一个函数。</li>
</ul>
<p>每个操作有4个版本：</p>
<ul>
<li><code>operationKeys</code>: 处理键。</li>
<li><code>operationValues</code>: 处理值。</li>
<li><code>operation</code>: 处理键和值。</li>
<li><code>operationEntries</code>: 处理<code>Mpap.Entry</code>对象。</li>
</ul>
<p>对于上述操作，需要指定一个参数化阈值（<code>parallesion threshold</code>）。如果映射包含的元素多于这个阈值，就会并行完成批操作。</p>
<ul>
<li>如果希望批操作在一个线程中运行，可以使用阈值<code>Long.MAX_VALUE</code>。</li>
<li>如果希望批操作就能够可能快的完成，可以使用阈值1。</li>
</ul>
<p>例如<code>search</code>方法，有以下版本：</p>
<ul>
<li><code>U searchKeys(long threshold, BiFunction&lt;? super K, ? extends U&gt; f)</code></li>
<li><code>U searchValues(long threshold, BiFunction&lt;? super K, ? extends U&gt; f)</code></li>
<li><code>U search(long threshold, BiFunction&lt;? super K, ? extends U&gt; f)</code></li>
<li><code>U searchEntries(long threshold, BiFunction&lt;? super K, ? extends U&gt; f)</code></li>
</ul>
<p>例，假设我们希望找出第一个出现次数超过1000次的单词。则需要搜索键和值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map:&#123;key: word, value: appearTimes&#125;</span></span><br><span class="line">String result = map.search(threshold, (k, v) -&gt; v &gt; <span class="number">1000</span> ? k: <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h3><p>并发集中并没有提供<code>ConcurrentHashSet</code>，但是可以用<code>newKeySet</code>方法会生成一个<code>Set&lt;k&gt;</code>，这实际上<code>concurrentHasMap&lt;K, Boolean&gt;</code>的一个包装类（所有的映射值都为<code>TRUE</code>，只不过将其视为一个<code>Set</code>，所以不关系其值）。</p>
<h3 id="写入数组的拷贝"><a href="#写入数组的拷贝" class="headerlink" title="写入数组的拷贝"></a>写入数组的拷贝</h3><p><code>copyOnWriteArrayList</code>和<code>copyOnWriteArraySet</code>是线程安全集合，其中所有更改器都会建立底层数组的一个副本。</p>
<h3 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="并行数组算法"></a>并行数组算法</h3><p><code>Arrays</code>类提供了大量并行化运算。</p>
<ul>
<li><code>Arrays.parallelSort</code>方法可以对一个基本类型值或对象的数组排序。其用法于基本<code>sort</code>一致。</li>
<li><code>Arrays.paralleSetAll</code>方法会由一个函数计算得到的值填充一个数组。</li>
<li><code>Arrays.parallelPrefix</code>会使用提供的函数，并行地累积给定数组中的每个元素。  </li>
</ul>
<h3 id="遗留的线程安全集合"><a href="#遗留的线程安全集合" class="headerlink" title="遗留的线程安全集合"></a>遗留的线程安全集合</h3><p>从Java最开始的版本中,<code>Vector</code>和<code>Hashtable</code>就提供了动态数组和散列表的线程安全。不过这些类已经被认为是过时的，不应当再使用。</p>
<p>实际上，任何集合类都可以通过使用同步包装器（<code>synchronized wapper</code>）来变成线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; synchArray = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K, V&gt; synchHashMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;K, V&gt;());</span><br></pre></td></tr></table></figure>
<p>结果集的方法应当使用锁加以保护，则可以提供线程安全的访问。并且确保没有任何线程通过原始的非同步方法访问数据结构。（其解决办法一般就是像代码中那样直接传入新建的集合）</p>
<p>不过最好通常使用<code>java.util.concurrent</code>包中定义的集合，而不是同步包装器。</p>
<ul>
<li>特别的，<code>concurrenthashMap</code>经过了精心实现，假设多个线程访问的是不同的位置，则不会发生阻塞。</li>
<li>经常更改的数组列表是个例外。这种情况下，同步的<code>ArrayLst</code>要胜过<code>CopyOnWriterArrayList</code>。</li>
</ul>
<h2 id="任务和线程池"><a href="#任务和线程池" class="headerlink" title="任务和线程池"></a>任务和线程池</h2><p>线程池其实就是一组线程的集合，不过其调用是由其本身来决定的。如果程序中创建了大量的生命周期很短的线程，那么不应该把每个任务映射到一个单独的线程中，而应该使用线程池（<code>Thread pool</code>）。</p>
<h3 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="Callable和Future"></a><code>Callable</code>和<code>Future</code></h3><p><code>Runnable</code>封装一个异步运行的任务，可以将其想象成一个没有参数和返回值的异步方法。</p>
<p><code>Callable</code>与<code>Runnale</code>类似，但是有返回值。</p>
<p><code>Callable</code>接口是一个参数化的类型，只有一个方法<code>call</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型参数是返回值的类型。例如<code>Callable&lt;Integer&gt;</code>表示将返回<code>Integer</code>对象的异步方法。</p>
<p><code>Future</code>保存异步计算的结果。</p>
<p><code>Future&lt;V&gt;</code>接口有下面的方法：</p>
<ul>
<li><code>V get()</code>：调用后会阻塞，直到计算完成。</li>
<li><code>V get(long timeout, TimeUnit unit)</code>：调用后也会阻塞，但是超时之后，会抛出一个<code>TimeoutException</code>。</li>
<li><code>void cancel(boolean mayInterrupt)</code>：取消任务，如果计算任务还没开始，则不会再开始。如果已经开始，那么如果<code>mayInterrupt</code>为<code>true</code>，其将会被中断。</li>
<li><code>boolean isDone()</code>：查询任务是否完成。</li>
</ul>
<p>执行<code>Callable</code>的一种方法是使用<code>FutureTask</code>，它实现了<code>Future</code>和<code>Runnable</code>接口。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = ...;</span><br><span class="line"><span class="keyword">var</span> futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">t.start();</span><br><span class="line">...;</span><br><span class="line">Integer result = task.get();		<span class="comment">//It`s a future</span></span><br></pre></td></tr></table></figure>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>执行器（<code>Executors</code>）类有很多静态工厂方法，用来构造线程池。下表是一些方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>newCachedThreadPool</code></td>
<td>必要时创建新线程，空闲线程会保留60秒。</td>
</tr>
<tr>
<td><code>newFixedThreadPool</code></td>
<td>池中包含固定数目的线程，空闲线程会一直保留。</td>
</tr>
<tr>
<td><code>newWorkStealingPool</code></td>
<td>一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会“密取”较简单的任务。</td>
</tr>
<tr>
<td><code>newStringThreadExecutor</code></td>
<td>只有一个线程的池，会顺序地执行所提交的任务。</td>
</tr>
<tr>
<td><code>newScheduledThreadPool</code></td>
<td>用于调度执行的固定线程池。</td>
</tr>
<tr>
<td><code>newSingleThreadScheduledEcecutor</code></td>
<td>用户调度执行的单线程池。</td>
</tr>
</tbody>
</table>
<p><code>newCachedThreadPool</code> 方法会在线程池有线程的时候直接使用线程，没有的时候新建。</p>
<p>如果线程的生命周期很短，或者大量时间都在阻塞，那么可以使用一个缓存线程池。</p>
<p>为了得到最优的运行速度，并发线程数等于处理器内核数。</p>
<p>可以用以下方法将<code>Runnable</code>或<code>Callable</code>对象提交给<code>ExecutroService</code>：</p>
<ul>
<li><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></li>
<li><code>Future&lt;?&gt; submit(Runnable task)</code></li>
<li><code>Future&lt;T&gt; submit(Runnable task, T result)</code></li>
</ul>
<p>线程池会在方便的时候尽早提交执行提交的任务。并且会返回一个<code>Future</code>对象，可以用来得到结果或者取消任务。</p>
<p><code>Future</code>对象有两个方法来终止植线程池中的所有任务：</p>
<ul>
<li><code>shutdown</code>：这个方法会停止线程池接受新任务，当线程池中的任务都完成时，线程池就会死亡。</li>
<li><code>shutdownNow</code>：线程池会取消所有尚未开始的任务。</li>
</ul>
<h3 id="控制任务组"><a href="#控制任务组" class="headerlink" title="控制任务组"></a>控制任务组</h3><p>执行器方法有两个执行方法：</p>
<ul>
<li><code>invokeAny</code>：接受一个<code>Callable</code>对象集合，并返回最先完成的那个任务的结果。</li>
<li><code>invokeAll</code>：接受一个<code>Callable</code>对象集合，这个方法会阻塞，直到所有任务都完成，然后返回所有的结果集合。（这里的结果顺序是按提交的顺序）</li>
</ul>
<p>但是当我们需要按计算结果的顺序得到结果，就可以使用<code>ExecutorCompletionService</code>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> service = <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(executor);</span><br><span class="line"><span class="keyword">for</span>(Callable&lt;T&gt; task: tasks) service.submit(task);</span><br><span class="line">processFurther(service.take().get());</span><br></pre></td></tr></table></figure>
<h3 id="fork-join"><a href="#fork-join" class="headerlink" title="fork-join"></a>fork-join</h3><p>Java7引入了fork-join框架哦那个与计算密集型任务，其原理是通过递归将大任务分解为小任务到不同的线程。</p>
<p>其需要扩展<code>RecursiveTask&lt;T&gt;</code>类，结果会返回T类型的值。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(to - from &lt; THRESHOLD)&#123;</span><br><span class="line">            <span class="comment">//solve problem directly</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (from + to) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">var</span> first = <span class="keyword">new</span> Counter(values, from, mid, filter);</span><br><span class="line">            <span class="keyword">var</span> first = <span class="keyword">new</span> Counter(values, mid, to, filter);</span><br><span class="line">            invokeAll(first, second);</span><br><span class="line">            <span class="keyword">return</span> first.join() + second.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到整体就是个二分的思路，当小于阈值时直接计算，否则就二分。</p>
<h2 id="异步计算"><a href="#异步计算" class="headerlink" title="异步计算"></a>异步计算</h2><p>这里的异步计算，实际上是一种回调机制。</p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><code>CompletableFuture</code></h3><p>传统的<code>Future</code>对象，要获得其结果时，必须等待阻塞，直到计算完成。</p>
<p>而<code>CompletableFuture</code>类实现了<code>Future</code>，它提供了一个回调的参数，允许将回调先传入，再结果可用时将自动调用。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; f = ...;</span><br><span class="line">f.thenAccept(s -&gt; Process the result string s);</span><br></pre></td></tr></table></figure>
<p>通过这种回调的方式可以无需阻塞获得结果。</p>
<p><code>completableFuture</code>的所有方法如下表（其用法与上述相同）：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thenApply</code></td>
<td>T-&gt;U</td>
<td>对结果应用一个函数</td>
</tr>
<tr>
<td><code>thenAccept</code></td>
<td>T-&gt;void</td>
<td>类似于thenApply，不过结果为void</td>
</tr>
<tr>
<td><code>thenCompose</code></td>
<td>T-&gt;CompletableFuture\&lt;U></td>
<td>对结果调用函数并执行返回的future</td>
</tr>
<tr>
<td><code>handle</code></td>
<td>(T, Throwable)-&gt;U</td>
<td>处理结果或错误，生成一个新结果</td>
</tr>
<tr>
<td><code>whenComplete</code></td>
<td>(T, Throwable)-&gt;void</td>
<td>类似于handle，不过结果为void</td>
</tr>
<tr>
<td><code>exceptionally</code></td>
<td>Throwable-&gt;T</td>
<td>从错误计算一个结果</td>
</tr>
<tr>
<td><code>completeOnTimeout</code></td>
<td>T, long, TimeUnit</td>
<td>如果超时，生成给定值作为结果</td>
</tr>
<tr>
<td><code>orTimeout</code></td>
<td>long, TimeUnit</td>
<td>如果超时，生成一个一个<code>TimeoutException</code>异常</td>
</tr>
<tr>
<td><code>thenRun</code></td>
<td>Runnable</td>
<td>执行<code>Runnable</code>，结果为void</td>
</tr>
</tbody>
</table>
<p>下面还有一些方法来组个多个<code>future</code>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thenCombine</code></td>
<td>CompletableFuture\&lt;U>, (T, U)-&gt;V</td>
<td>执行两个动作并给定函数的组合结果</td>
</tr>
<tr>
<td><code>thenAcceptBoth</code></td>
<td>CompletableFuture\&lt;U>, (T, U)-&gt;void</td>
<td>与<code>thenCombine</code>类似，不过结果为void</td>
</tr>
<tr>
<td><code>runAfterBoth</code></td>
<td>CompletableFuture&lt;?&gt;, Runnable</td>
<td>两个都完成后执行<code>runnable</code></td>
</tr>
<tr>
<td><code>applyToEdither</code></td>
<td>CompletableFuture\&lt;T>, T-&gt;V</td>
<td>得到其中一个的结果时，传递给定的函数</td>
</tr>
<tr>
<td><code>acceptEither</code></td>
<td>CompletableFuture\&lt;T>, T-&gt;void</td>
<td>与<code>applyToEither</code>类似，不过结果为void</td>
</tr>
<tr>
<td><code>runAfterEither</code></td>
<td>CompletableFuture&lt;?&gt;, Runnable</td>
<td>其中一个完成后执行<code>runnable</code></td>
</tr>
<tr>
<td><code>static allOf</code></td>
<td>CompletableFuture&lt;?&gt;…</td>
<td>所有给定的<code>future</code>都完成后完成，结果为void</td>
</tr>
<tr>
<td><code>static anyOf</code></td>
<td>CompletableFuture&lt;?&gt;…</td>
<td>任意给定的future完成后则完成，结果为void</td>
</tr>
</tbody>
</table>
<p>前三个方法并发运行两个泛型类型不同的<code>CompletableFuture</code>，并组合结果。</p>
<p>后三个方法并发运行两个泛型类型相同的<code>CompletableFuture</code>。一旦一个完成，则传递它的结果，并忽略另外的。</p>
<p>后面的静态方法<code>allOf</code>和<code>anyOf</code>取一组<code>CompletableFuture</code>，并生成<code>CompletableFuture&lt;Void&gt;</code>，然后分别在全部完成时任意一个完成时结束。但不会返回任何结果。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<h3 id="建立一个进程"><a href="#建立一个进程" class="headerlink" title="建立一个进程"></a>建立一个进程</h3><p>建立进程必须要指定要执行的命令，可以用<code>List&lt;String&gt;</code>，或者直接提供命令字符串。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = <span class="keyword">new</span> ProcessBulder(<span class="string">"gcc"</span>, <span class="string">"myapp.c"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h4><p>每个进程都有一个工作目录，用来解析相对的目录名。默认情况下，进程的工作与虚拟机相同，通常是启动Java程序的那个目的。也可以使用<code>dictionary</code>方法来 改变工作目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">budiler = budiler.dictionary(path.toFile());</span><br></pre></td></tr></table></figure>
<h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p>默认情况下，输入输出流可以用以下方法访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream processOut = p.getOutputStream();</span><br><span class="line">InputStream processIn = p.getInputStream();</span><br><span class="line">InputStream processErr = p.getErrorStream();</span><br></pre></td></tr></table></figure>
<p>注意：进程的输入流是JVM的一个输出流。我们会写入这个流，而我们写的内容会成为进程的输入。即一个中继的概念。</p>
<p>可以指定新进程的输入、输出和错误流与JVM相同。如果在控制台运行JVM，则所有用户的输入会转发到进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">builder.redirectIO();</span><br></pre></td></tr></table></figure>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>可以使用以下格式来设置环境变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; env = builder.environment();</span><br><span class="line">env.put(<span class="string">"LANG"</span>, <span class="string">"Fr_FR"</span>);</span><br><span class="line">env.remove(<span class="string">"JAVA_HOME"</span>);</span><br><span class="line">Process p = builder.start();</span><br></pre></td></tr></table></figure>
<h3 id="运行一个进程"><a href="#运行一个进程" class="headerlink" title="运行一个进程"></a>运行一个进程</h3><p>要等待进程完成，可以调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result =process.waitFor();</span><br></pre></td></tr></table></figure>
<p>或者，如果不想无限等待，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = ...;</span><br><span class="line"><span class="keyword">if</span>(process.waitFor(delay, TimeUnit.SECONDS))&#123;</span><br><span class="line">    <span class="keyword">int</span> result = process.exitValue();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    process.detroyForcibly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程句柄"><a href="#进程句柄" class="headerlink" title="进程句柄"></a>进程句柄</h3><p>可以通过进程句柄来获得进程的更多信息。有以下4中方式：</p>
<ul>
<li>给定一个<code>Process</code>对象p，使用<code>p.toHandle()</code>方法获得其句柄。</li>
<li>给定一个<code>long</code>类型的操作系统进程ID，<code>ProcessHandle.of(id)</code>获得其句柄。</li>
<li><code>Process.current()</code>是运行这个Java的虚拟机的进程句柄。</li>
<li><code>Process.allprocess()</code>可以生成对当前进程可见的所有操作系统进程的<code>Stream&lt;ProcessHandle&gt;</code></li>
</ul>
<p>给定进程句柄，可以获得其id，父进程，子进程和后代进程：</p>
<ul>
<li><code>long id = handle.pid();</code></li>
<li><code>Optional&lt;ProcessHandle&gt; parent = handle.parent();</code></li>
<li><code>Stream&lt;ProcessHandle&gt; children = handle.childrean();</code></li>
<li><code>Stream&lt;ProcessHandle&gt; descendants = handle.descendants();</code></li>
</ul>
<p>还可以通过<code>ProcessHandle.info</code>来获取其他的信息。</p>
<p>也可以通过进程句柄来监视或终止进程。<code>PorcessHandle</code>接口有<code>isAlive</code>、<code>supportsNormTermination</code>、<code>destroy</code>、<code>destroyForcibly</code>和<code>onEixt()</code>方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>java核心技术-I-12-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>javac命令参数参考</title>
    <url>/2022/04/28/javac%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>标准选项是指用来支撑当前开发环境并且会长期支持的参数。与之对应，还有一些非标准的参数，它们可能使用来自定义虚拟机参数或者编译的实现，标准参数以<code>-X</code>开头。</p>
<h2 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h2><ul>
<li><p>-A<em>key</em>[=value]：传递给注解处理器的选项。这些参数不由javac直接编译，而是交给对应的注解处理器来使用。如果有多个key，则使用<code>.</code>分隔。(<strong>注意，-A与key之间没有空格，后面有些参数也一样</strong>)</p>
</li>
<li><p><code>-cp path or -classpath path</code>：设置类查找目录，即从哪里去寻找后面给出的类。这个选项会覆盖<strong>CLASSPATH</strong>环境变量。如果既没有<strong>CLASSPATH</strong>，也没有配置该属性，则会直接在当前目录下进行查找。</p>
</li>
<li><p><code>-Djava.ext.dirs=directories</code>：覆盖扩展安装的目录。即用扩展类加载器（Extension Class Loader）加载的类，默认是在&lt;JAVA_HOME&gt;\lib\ext。其中包含</p>
<ul>
<li>access-bridge-64.jar</li>
<li>cldrdata.jar</li>
<li>dnsns.jar</li>
<li>jaccess.jar</li>
<li>…</li>
</ul>
<p>如果要自定义（比如添加依赖的时候），就必须把原来的目录也配置上，否则就无法使用这个几个包。</p>
</li>
<li><p><code>-Djava.endorsed.dirs=directories</code>：</p>
<h3 id="java提供了endorsed技术："><a href="#java提供了endorsed技术：" class="headerlink" title="java提供了endorsed技术："></a>java提供了endorsed技术：</h3><p>关于endorsed：可以的简单理解为-Djava.endorsed.dirs指定的目录面放置的jar文件，将有覆盖系统API的功能。可以牵强的理解为，将自己修改后的API打入到JVM指定的启动API中，取而代之。但是能够覆盖的类是有限制的，其中不包括java.lang包中的类。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>比如Java的原生api不能满足需求，假设我们需要修改 ArrayList 类，由于我们的代码都是基于ArrayList做的，那么就必需用到 Javaendorsed 技术，将我们自己的ArrayList，<strong>注意包和类名和java自带的都是一样的</strong>，打包成一个jar包，放入到-Djava.endorsed.dirs指定的目录中，这样我们在使用java的ArrayList的时候就会调用的我们定制的代码中。</p>
</li>
</ul>
<p>​        其默认为<code>$JAVA_HOME/jre/lib/endorsed</code></p>
<p>​        而这个属性可以修改对应endorsed的目录。</p>
<ul>
<li><p><code>-d directory</code>：设置生成的类文件的目标目录。如果目标目录已经存在了，javac就不会创建。如果这个class是当钱包的异步，javac将会将这个类文件放到当前包的映射的对应目录下面（即以当前包为根路径，去使用配置的目录）。如果<code>-d</code>没有指定，javac会将类文件放到Java文件相同的目录中。</p>
</li>
<li><p><code>-deprecation</code>：显示已弃用成员或类的每次使用或重写的描述。如果没有-deprecation, javac将显示使用或覆盖已弃用的成员或类的源文件的摘要。-deprecation是-Xlint:deprecation的简写。</p>
</li>
<li><p><code>-encoding encoding</code>：设置源文件编码名称，如EUC-JP和UTF-8。如果没有指定-encoding，则使用平台默认转换器。</p>
</li>
<li><p><code>-endorseddirs directories</code>：覆盖endorsed的位置。与<code>-Djava.endorsed.dirs=directories</code>作用一样。</p>
</li>
<li><p><code>-extdirs directories</code>：覆盖扩展安装的目录。与<code>-Djava.ext.dirs=directories</code>作用一样。</p>
</li>
<li><p><code>-g</code>：生成所有调试信息，包括本地变量。默认情况下，只生成行号和源文件信息。</p>
</li>
<li><p><code>-g:none</code>：不生成任何调试信息。</p>
</li>
<li><p><code>-g:{keyword list}</code>：只生成某些类型的调试信息，由逗号分隔的关键字列表指定。有效的关键词是:</p>
<ul>
<li>source：Source file debugging information。</li>
<li>lines：Line number debugging information。</li>
<li>vars：Local variable debugging information。</li>
</ul>
</li>
<li><p>-nowarn：禁用警告消息。与<code>-Xlint:none</code>的含义相同。</p>
</li>
<li><p><code>-proc: {none,only}</code>：控制是否完成注释处理和/或编译。</p>
<ul>
<li><code>-proc:none</code>表示编译时不进行注释处理。</li>
<li><code>-proc:only</code>表示只进行注释处理，不进行后续编译。</li>
</ul>
</li>
<li><p><code>-processor class1[,class2,class3...]</code>：要运行的注释处理器的名称。这将绕过默认的发现过程（见下）。</p>
</li>
<li><p><code>-processorpath path</code>：指定在哪里找到注释处理器;<strong>如果不使用此选项，则将从当前路径中搜索处理器</strong>（即该参数优先级更高）。</p>
</li>
<li><p><code>-s dir</code>：一般javac不会生成java源文件，但是在注解处理器中，是可以生成新的Java源文件的。所以这里就是配置该文件生成的目录。</p>
</li>
<li><p><code>-source release</code>：指定可接受的源代码版本。其允许的值如下：</p>
<ul>
<li>1.3：编译器不支持断言、泛型或Java SE 1.3之后引入的其他语言特性。</li>
<li>1.4：编译器接受包含断言的代码，这些断言是在Java SE 1.4中引入的。</li>
<li>1.5：编译器接受包含泛型和Java SE 5中引入的其他语言特性的代码。</li>
<li>5：与1.5相同。</li>
<li>6：与1.6相同。</li>
<li>1.7：这是默认值。编译器接受带有Java SE 7中引入的特性的代码。</li>
<li>7：与1.7相同。</li>
</ul>
</li>
<li><p><code>-sourcepath sourcepath</code>：指定搜索类或接口定义的源代码路径。与用户类路径一样，源路径条目用分号(;)分隔，可以是目录、JAR归档文件或ZIP归档文件。如果使用包，目录或归档文件中的本地路径名必须反映包名。</p>
<p>注意:如果也找到了通过类路径找到的类的源代码，则可能需要自动重新编译。</p>
</li>
<li><p><code>-Werror</code>：如果出现警告，则终止编译。</p>
</li>
<li><p><code>-X</code>：显示非标准选项信息并退出。</p>
</li>
</ul>
<h2 id="交叉编译参数"><a href="#交叉编译参数" class="headerlink" title="交叉编译参数"></a>交叉编译参数</h2><p>默认情况下，类是根据javac附带的平台的引导类和扩展类编译的。但是javac也支持交叉编译，其中类是根据不同Java平台实现的引导程序和扩展类进行编译的。</p>
<ul>
<li><code>-target version</code>：生成针对指定虚拟机版本的类文件。类文件将在指定的目标和更高的版本上运行，但不能在VM的较早版本上运行。其取值如下：<ul>
<li>如果不指定-source，则-target的值为1.7</li>
<li>如果-source为1.2，则-target的值为1.4</li>
<li>如果-source为1.3，则-target的值为1.4</li>
<li>如果-source为1.5，则-target的值为1.7</li>
<li>如果-source为1.6，则-target的值为1.7</li>
<li>对于-source的其他值，-target的值为-source的值。</li>
</ul>
</li>
<li><code>-bootclasspath bootclasspath</code>：根据指定的引导类集交叉编译。与用户类路径一样，引导类路径条目用冒号(:)分隔，可以是目录、JAR归档文件或ZIP归档文件。</li>
</ul>
<h2 id="非标准参数"><a href="#非标准参数" class="headerlink" title="非标准参数"></a>非标准参数</h2><ul>
<li><code>-Xbootclasspath/p:path</code>：前置到引导程序类路径。</li>
<li><code>-Xbootclasspath/a:path</code>：追加到引导程序类路径。</li>
<li><code>-Xbootclasspath/:path</code>：覆盖引导类文件的位置。</li>
<li><code>-Xlint</code>：启用所有推荐警告。</li>
<li><code>-Xlint:all</code>：与<code>-Xlint</code>一样。</li>
<li><code>-Xlint:none</code>：禁用所有警告。</li>
<li><code>-Xlint:name</code>：启用警告的名字。</li>
<li><code>-Xlint:-name</code>：与<code>-Xlint:name</code>一样。</li>
<li><code>-Xmaxerrs number</code>：设置要打印的最大错误数。</li>
<li><code>-Xmaxwarns number</code>：设置要打印的警告的最大数量。</li>
<li><code>-Xstdout filename</code>：将编译器消息发送到指定的文件。默认情况下，编译器消息会进入<code>System.err</code>。</li>
<li><code>-Xprefer:{newer,source}</code>：指定当找到某个类型的源文件和类文件时读取哪个文件。</li>
<li><code>-Xpkginfo:{always,legacy,nonempty}</code>：指定对包信息文件的处理。</li>
<li><code>-Xprint</code>：输出指定类型的文本表示形式，以供调试之用;既不执行注释处理，也不执行编译。输出的格式可能会改变。</li>
<li><code>-XprintProcessorInfo</code>：打印有关处理器被要求处理哪些注释的信息。</li>
<li><code>-XprintRounds</code>：打印关于初始和后续注释处理轮的信息。</li>
</ul>
<h4 id="可以用Xlint配置的警告"><a href="#可以用Xlint配置的警告" class="headerlink" title="可以用Xlint配置的警告"></a>可以用<code>Xlint</code>配置的警告</h4><ul>
<li><p>cast：警告不必要和多余的类型转换。</p>
</li>
<li><p>classfile：警告有关类文件内容的问题。</p>
</li>
<li><p>deprecation：警告使用过时的项目。</p>
</li>
<li><p>dep-ann：对使用@deprecated Javadoc注释记录但没有@deprecated注释的项目发出警告。</p>
</li>
<li><p>divzero：警告被常量整数0除。</p>
</li>
<li><p>empty：警告没有内容的if语句。</p>
</li>
<li><p>fallthrough：检查switch块是否有失败的情况，并为任何发现的情况提供警告信息。失败情况是指switch语句块中不包含break语句，使后面的case无法执行。</p>
</li>
<li><p>finally：警告不能正常完成的finally子句。</p>
</li>
<li><p>options：对与使用命令行选项有关的问题发出警告。</p>
</li>
<li><p>overrides：警告有关方法重写的问题。</p>
</li>
<li><p>path：警告命令行上无效的路径元素和不存在的路径目录(关于类路径、源路径和其他路径)。</p>
</li>
<li><p>processing：警告有关注释处理的问题。 如果有一个具有注释的类，并且使用的注释处理器不能处理该类型的异常，那么编译器将生成此警告。</p>
</li>
<li><p>rawtypes：警告对原始类型进行未检查的操作。例如：<code>void countElements(List l) { ... }</code>。</p>
<p>List是一个原始类型。然而,列表<code>&lt;?&gt;</code>是一个无界通配符参数化类型。因为List是一个参数化接口，所以应该始终指定它的类型参数。在这个示例中，List形式参数是用一个无界通配符(?)作为其形式类型参数指定的，这意味着countElements方法可以接受List接口的任何实例化。</p>
</li>
<li><p>serial：对可序列化类（继了Serializable的类）上缺少serialVersionUID定义发出警告。</p>
</li>
<li><p>static：警告与使用静态相关的问题。</p>
</li>
<li><p>try：警告与使用try块有关的问题，包括try-with-resources语句。例如，以下语句会产生一个警告，因为在try语句中声明的资源ac没有被使用。</p>
</li>
<li><p>unchecked：提供更多关于Java语言规范强制要求的未检查转换警告的细节。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List l = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">List&lt;String&gt; ls = l;       <span class="comment">// unchecked warning</span></span><br></pre></td></tr></table></figure>
<p>类型擦除时，类型<code>ArrayList&lt;Number&gt;</code>和<code>List&lt;String&gt;</code>分别变为ArrayList和List。</p>
<p>变量ls具有参数化类型<code>List&lt;String&gt;</code>。当l引用的List被赋值给ls时，编译器生成一个未检查的警告;如果l指向<code>List&lt;String&gt;</code>类型，编译器在编译时无法确定，而且知道JVM在运行时也无法确定;它不。因此，会发生堆污染。</p>
</li>
<li><p>varargs：警告变量参数(varargs)方法的不安全用法，特别是那些包含不可具体化参数的方法。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addToList</span> <span class="params">(List&lt;T&gt; listArg, T... elements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器遇到varargs方法时，它会将varargs形参转换为数组。但是，Java编程语言<strong>不允许创建参数化类型的数组</strong>。在ArrayBuilder方法中。addToList，编译器转换varargs的形参T…将形式参数T[]元素转化为一个数组。然而，由于类型擦除，编译器将varargs形参转换为Object[]元素。因此，存在堆污染的可能性。</p>
</li>
</ul>
<h2 id="不同包中的文件编译"><a href="#不同包中的文件编译" class="headerlink" title="不同包中的文件编译"></a>不同包中的文件编译</h2><p>不同的文件在同一个文件夹下编译时，不需要考虑包名的问题。但是一般我们编写代码时都是在不同的包中，此时的打包方式稍有不同，需要介绍。</p>
<ol>
<li><p><code>-cp path</code>，<code>-classpath path</code>：在编译时，所有依赖的class文件都会从这个参数属性中去查找。<strong>可以是目录，jar文件，zip文件（里面都是class文件，javac会自动去zip中查找包名和类）</strong>。还需要注意的是，依赖的类在使用的时候，需要到全类名的最外层文件夹，然后直接使用类的全限定名，如<code>priv.mw.MyClass</code>。</p>
<p>例如：</p>
<p>​    abc.java在路径c:\src里面，在任何的目录的都可以执行以下命令来编译。<br>​    javac -classpath c:\classes;c:\jar\abc.jar;c:\zip\abc.zip -sourcepath c:\source\project1\src;c:\source\project2 \lib\src.jar;c:\source\project3\lib\src.zip c:\src\abc.java</p>
<p>​    表示编译需要c:\classed下面的class文件，c:\jar\abc.jar里面的class文件，c:\zip\abc.zip里面的class文件<br>​    还需要c:\source\project1\src下面的源文件，c:\source\project2 \lib\src.jar里面的源文件，c:\source\project3\lib\src.zip里面的源文件，<br>​    注意：jar，zip里面的源文件不会有什么改动，目录下的源文件，有可能会被重新编译。</p>
</li>
<li><p><code>-d directory</code>：参数指定生成的class文件的位置，值得注意的是，生成的class会带上原始的包（即javac会自动创建会src对应的文件夹，但是不会创建<code>-d</code>指定的文件夹，需要我们自行建立）。然后我们在最外侧直接生成类的全限定名即可引用。</p>
</li>
<li><code>-sourcepath path</code>：指定Java源代码的目录，我们配置这个目录之后，之后的<code>xxx.java</code>文件就会先该文件夹进行搜索，<strong>值得注意的是，之后的要编译文件的路径就要相对于该文件夹了</strong>。</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>就以引出这篇文章的例子：注释处理器。</p>
<p>初始包结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">annoTest</span><br><span class="line">		src</span><br><span class="line">			main</span><br><span class="line">				java</span><br><span class="line">					annotaions</span><br><span class="line">							ToString.java</span><br><span class="line">					processors</span><br><span class="line">							SingleToString.java</span><br><span class="line">					POJO.java</span><br><span class="line">				resource</span><br><span class="line">             test</span><br><span class="line">		target</span><br></pre></td></tr></table></figure>
<p>依赖关系为：</p>
<ul>
<li><code>POJO.java</code>依赖<code>ToString.java</code></li>
<li><code>SingleToString.java</code>依赖<code>ToString.java</code></li>
<li><code>SingleToString.java</code>依赖<code>{JAVA_HOME}/lib/tools.jar</code></li>
</ul>
<p>并且由于注解处理器的特殊性，其是先编译，然后在编译<code>POJO.java</code>时使用。</p>
<p>所以其流程如下：</p>
<ol>
<li><p>进入最外层的annoTest目录。</p>
</li>
<li><p>编译<code>ToString.java</code>，注意：</p>
<ol>
<li>要指定输出class的目录为target。</li>
<li>指定Java文件时，还是要指定目录。</li>
</ol>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:/Users/MW/.jdks/corretto-1.8.0_312/bin/javac.exe -d target src/main/java/annotaions/ToString.java					<span class="comment"># 直接使用路径</span></span><br><span class="line"></span><br><span class="line">C:/Users/MW/.jdks/corretto-1.8.0_312/bin/javac.exe -d target -sourcepath src src/main/java/annotaions/ToString.java		<span class="comment"># 使用-sourcepath则可以使用全限定名来引用类</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译<code>SingleToString.java</code>，注意：</p>
<ol>
<li>要指定输出class的目录为target。</li>
<li>由于还要依赖<code>{JAVA_HOME}/lib/tools.jar</code>，所以必须要使用<code>-cp</code>来指定该jar。</li>
<li><code>--encoding utf-8</code>是由于该Java文件中含有中文字符，放置乱码。</li>
</ol>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:/Users/MW/.jdks/corretto-1.8.0_312/bin/javac.exe -d target -cp C:/Users/MW/.jdks/corretto-1.8.0_312/lib/tools.jar  -encoding UTF-8 src/main/java/processors/SingleToString.java					<span class="comment"># 直接使用路径</span></span><br><span class="line"></span><br><span class="line">C:/Users/MW/.jdks/corretto-1.8.0_312/bin/javac.exe -d target  -sourcepath src -cp C:/Users/MW/.jdks/corretto-1.8.0_312/lib/tools.jar  -encoding UTF-8 src/main/java/processors/SingleToString.java				<span class="comment"># 使用-sourcepath则可以使用全限定名来引用类</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>使用注解处理器来编译<code>POJO.java</code>。此时就需要注意了：</p>
<ol>
<li>我们需要将<code>target</code>文件夹加入到<code>-cp</code>中，这是因为我们之前编译生成的<code>ToString.class</code>和<code>SingleToString.class</code>都在该目录下。并且，只要加入了该参数，我们在后面使用类的时候，就必须加上类的全限定名（其实在编译器中也是同样的事情，引入了多个<code>-cp</code>，然后import的时候就使用全限定名）。比如在这里的使用就是<code>-processor processors.SingleToString</code>，我们此时在src下，却可以直接使用类的全限定名来引入，其原理正是来自这里。</li>
<li><code>-processorpath target</code>用来指定注解处理器查找的目录，并且其优先级更高，但由于<code>-cp</code>中已经配置了target，所以可以不用配置的。</li>
</ol>
<p>所以命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:/Users/MW/.jdks/corretto-1.8.0_312/bin/javac.exe -d target -cp  C:/Users/MW/.jdks/corretto-1.8.0_312/lib/tools.jar;target -encoding UTF-8 -processorpath target -processor processors.SingleToString src/main/java/POJO.java				<span class="comment"># 直接使用路径</span></span><br><span class="line"></span><br><span class="line">C:/Users/MW/.jdks/corretto-1.8.0_312/bin/javac.exe -d target -sourcepath src -cp  C:/Users/MW/.jdks/corretto-1.8.0_312/lib/tools.jar;target -encoding UTF-8 -processorpath target -processor processors.SingleToString src/main/java/POJO.java				<span class="comment"># 直接使用路径</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>javac</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术-I-5-继承</title>
    <url>/2022/01/19/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-5-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="类，超类和子类"><a href="#类，超类和子类" class="headerlink" title="类，超类和子类"></a>类，超类和子类</h1><h2 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h2><p>使用以下格式表示继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>即，使用关键字<code>extends</code>表示继承关系。</p>
<ol>
<li>A被被称为超类（super class）、父类（parent class）或基类（base class）。</li>
<li>B被称为子类（subclass）、派生类（derived class）和孩子类（child class）。</li>
<li>由于子类继承父类且可以扩展，所以子类一般比父类有更多的功能。</li>
</ol>
<p><strong>注意：子类中会继承父类的所有属性和方法，但私有属性和方法并不能直接访问。</strong>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">newGetId0</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;				<span class="comment">//editor will report error</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">newGetId1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.setId(<span class="number">1</span>);			<span class="comment">//correct</span></span><br><span class="line">b.getId();			<span class="comment">//correct</span></span><br><span class="line">b.newGetId1();		<span class="comment">//coorect</span></span><br><span class="line">b.newGetId0();		<span class="comment">//incorrect</span></span><br><span class="line">b.id;				<span class="comment">//incorrect</span></span><br></pre></td></tr></table></figure>
<p>即从上面的代码可以看出，在子类的实例中，父类的私有属性会被初始化，只是子类无权限访问，只能通过<code>getter</code>来间接访问。</p>
<h2 id="覆盖方法（重写）"><a href="#覆盖方法（重写）" class="headerlink" title="覆盖方法（重写）"></a>覆盖方法（重写）</h2><p>重写是指在子类中重新定义父类的方法来实现不同的功能。</p>
<p>pre：</p>
<ul>
<li><p><code>this</code>关键字用于访问当前类的作用域</p>
</li>
<li><p><code>super</code>关键字用于访问父类的作用域</p>
</li>
<li><p>当不加前缀时代表从子类开始向父类的作用域中进行搜索。而加了上述关键字则只从特定的作用域中搜索。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'id='</span>+<span class="keyword">super</span>.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上述B类中的<code>getId</code>方法。其内部为了调用父类的<code>getId</code>方法，加了前缀<code>super</code>关键字。（前面的例子之所以可以不加关键字调用父类的<code>getId</code>方法，是子类中不存在<code>getId</code>方法，按照作用域链搜索上去就能找到父类的方法，而此时子类定义了<code>getId</code>方法，如果不加前缀，就会搜索到子类的方法，造成递归调用，显然这不是我们的本意。）</p>
<p>注意：</p>
<ol>
<li>这里的<code>super</code>并不指向某一特定对象，而是指示编译器调用父类方法的关键字。</li>
<li>方法名，参数列表，返回类型（除非子类中方法的返回类型是父类中返回类型的子类）必须相同。</li>
<li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)。</li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法声明更加宽泛的检查型异常。</li>
</ol>
<h2 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h2><p>在子类构造器中，我们可以使用<code>super</code>关键字来调用父类的构造器。且必须位于子构造器的第一句。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>this有两个含义：</p>
<ol>
<li>指隐式参数的调用：<code>this.id = id</code></li>
<li>该类的<strong>其他</strong>构造器（构造器重载）：<code>this()</code></li>
</ol>
<p>super也有两个含义：</p>
<ol>
<li>调用超类的方法：<code>super.getId()</code></li>
<li>调用超类的构造器：<code>super(id)</code></li>
</ol>
<h2 id="多态（继承的角度）"><a href="#多态（继承的角度）" class="headerlink" title="多态（继承的角度）"></a>多态（继承的角度）</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p><code>is-a</code>规则的另一种表述是“替换规则”。<strong>它指出程序中出现超类对象的任何地方都可以使用子类对象替换</strong>。如，可以将子类的对象赋值给超类变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sub b = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>
<p>但注意，替换后的类为父类，也就是说如果子类的扩展了新方法，就无法调用。但是调用旧的方法返回的是子类重写的方法。</p>
<h2 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h2><ol>
<li><p>编译器会一一列举子类和超类中（可访问）的名为xxx的方法。</p>
</li>
<li><p>编译器确定方法调用中提供的参数类型。如果存在名字相同且参数也完全相同的方法，则选择该方法执行。该过程被称为重载解析（overloading resolution）。<strong>如果没找到，则尝试将调用参数进行类型转化，比如继承中父子类的转化。</strong></p>
</li>
<li><p>如果是private方法、static方法、final方法或者构造器，那么编译器知道该从哪个作用域中调用该方法（即这些修饰符修饰的方法只能定义在该对象上，不可能去向上查找父类）。这被称为<strong>静态绑定（static binding）</strong>（即依赖调用该方法的对象类型来判定）。于此对应的是，如果要调用的方法依赖于调用的参数类型，那么其被称为<strong>动态绑定（dynamic binding）</strong>。</p>
<p>可以看出，静态绑定是重写的基础；而动态绑定是重载的基础。</p>
</li>
<li><p>动态绑定时，假设变量b声明为A类型，实际是B类型，则编译器先在B类中查找对应方法，否则在B中查找（若B有超类，也会向上查找）。</p>
</li>
</ol>
<p>实际上为了改善性能，虚拟机为每个类定义了一个方法表，其中列出了所有方法的签名和要调用的实际方法。当要调用时，只需查表即可。</p>
<h2 id="被声明为final的类和方法不能被继承"><a href="#被声明为final的类和方法不能被继承" class="headerlink" title="被声明为final的类和方法不能被继承"></a>被声明为final的类和方法不能被继承</h2><ol>
<li>被声明为final的类和方法不能被继承</li>
<li>final字段在<strong>构造对象</strong>之后就不允许改变他们的值了。</li>
<li>如果一个类被声明为final，则其中的方法自动声明为final，但字段不会转换为final字段。</li>
</ol>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ol>
<li>只能在继承的层次内，将<strong>父类转换为子类</strong>（父类的变量可以接受子类的值-多态）。</li>
<li>在转换之前，应该使用<code>instanceof</code>进行检查。</li>
</ol>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类一般指更加抽象，上层的类定义。其有如下特点：</p>
<ol>
<li>不可被实例化，只有继承它的子类可以被实例化。</li>
<li>任何包含抽象方法（即通过<code>abstract</code>声明）的方法类都必须声明为抽象（<code>abstract</code>），反之不成立，抽象类中可以包含非抽象的方法，并且可以提供实现。</li>
</ol>
<h2 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h2><p><code>protected</code>关键字定义的属性和方法可以在<strong>子类</strong>和同包中可以访问。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> groupId;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGroupId</span><span class="params">(<span class="keyword">int</span> groupId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.groupId = groupId;			<span class="comment">//correct</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId0</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.id = id;						<span class="comment">//incorrect</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中可以看到，<code>protected</code>声明的属性子类可以访问，而<code>private</code>声明的属性子类无法访问。</p>
<p>扩展：Java中4个访问控制符的权限：</p>
<ol>
<li><code>private</code>-仅对本类可见。</li>
<li><code>public</code>-对所有外部类可见。</li>
<li><code>protected</code>-对本包和子类可见。</li>
<li>默认（无修饰符）-对本包可见。</li>
</ol>
<h1 id="Object：所有类型的超类"><a href="#Object：所有类型的超类" class="headerlink" title="Object：所有类型的超类"></a>Object：所有类型的超类</h1><p><code>Object</code>类是所有类型的始祖，所有的类型都继承了<code>Object</code>类。</p>
<h2 id="object类型变量"><a href="#object类型变量" class="headerlink" title="object类型变量"></a>object类型变量</h2><p>在Java中，只有基本类型变量（primitive type）不是对象。其他的所有对象都扩展了<code>Object</code>类。</p>
<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a><code>equals</code>方法</h2><p><code>Object</code>类的<code>equals</code>方法用于检测一个对象是否等于另外一个。其默认实现是对比两个对象的引用是否相同。这是一个基础的定义。显然，如果两个对象引用相同。则其必然相同。但是我们可以扩展其定义。比如，我们确定所有的字段都相等就算相等，即使引用不同。</p>
<p>Java规范要求<code>equals</code>方法具有下面的特征：</p>
<ol>
<li>自反性：<code>x.equals(x) == true</code></li>
<li>对称性：<code>(x.equals(y) == y.equals(x))</code></li>
<li>传递性：<code>x.equals(y);</code>,<code>y.equals(z)</code> =&gt;<code>x.equals(z)</code></li>
<li>一致性：如果x和y引用的对象没有发生变化，则反复调用<code>x.equals(y)</code>应该返回同样的结果</li>
<li>任意非空的引用x，<code>x.equals(null)</code>应该返回<code>false</code></li>
</ol>
<h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a><code>hashCode</code>方法</h2><p><code>hashCode</code>方法返回给定对象的hash值。默认实现是从其<strong>存储地址</strong>导出的。不同的类重写了它。比如<code>String</code>类的实现如下：</p>
<p><code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> v : value) &#123;</span><br><span class="line">        h = <span class="number">31</span> * h + (v &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a><code>toString</code>方法</h2><p>其返回一个表示对象的字符串。默认返回其类型+地址。一般重写以显示其内部属性。比如eclipse默认生成的<code>toString</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Sub [name="</span> + name + <span class="string">", groupId="</span> + groupId + <span class="string">", getName()="</span> + getName() + <span class="string">", getId()="</span> + getId()</span><br><span class="line">			+ <span class="string">", getClass()="</span> + getClass() + <span class="string">", hashCode()="</span> + hashCode() + <span class="string">", toString()="</span> + <span class="keyword">super</span>.toString()</span><br><span class="line">			+ <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h2><p>在Java中，允许在运行时动态声明数组的大小，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer[] getList(Integer size)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是一旦声明，其不能随便改变其大小。</p>
<p>而是用<code>ArrayList</code>则可以动态声明大小并改变容量。</p>
<p><code>ArrayList</code>是一个有参数类型（type parameter）的泛型类（generic class）。其用法如下(3种格式)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ids1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; ids2 = <span class="keyword">new</span> ArrayList&lt;&gt;();				</span><br><span class="line"><span class="keyword">var</span> ids3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<ol>
<li>在Java5之前没有实现泛型，<code>ArrayList</code>只能返回保存<code>Object</code>的<code>ArrayList</code>，获得后需要强转。</li>
<li>在Java的老版本中，会用<code>vector</code>来实现动态数组，但是<code>ArrayList</code>更加高效，现在不应该再使用<code>vector</code>。</li>
</ol>
<p>如果事先知道其大小，可以使用<code>ensureAcpacity</code>来分配确定大小的容量，可以减少扩容时的开销，使之性能更好。也可以再初始参数传入数值来确定容量。（但这并不是强制的，可仍然可以大于该值）</p>
<h2 id="对象的包装器与自动装箱"><a href="#对象的包装器与自动装箱" class="headerlink" title="对象的包装器与自动装箱"></a>对象的包装器与自动装箱</h2><p>所有的基本类型都有一个与之对应的类。如<code>Integer</code>类对应基本类型int。通常，这些类被称为包装器。其有8类：</p>
<ul>
<li><code>Integer</code></li>
<li><code>Long</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Short</code></li>
<li><code>Byte</code></li>
<li><code>Character</code></li>
<li><code>Boolean</code></li>
</ul>
<p>前6类有公共的超类<code>Number</code>。</p>
<ol>
<li>包装器是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。</li>
<li>包装器还是<code>final</code>，因此不能派生他们的子类。</li>
</ol>
<p>注意，泛型尖括号中不允许基本类型。即<code>ArrayList&lt;int&gt;</code>是错误的语法。所以向<code>ArraryList</code>中添加成员时，应该是以下语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(Integer.valueOf(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>但是实际上，直接<code>list.add(9)</code>也是合法，这是因为<strong>自动装箱</strong>。</p>
<p>相反的，其也会自动拆箱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>其实际上会被编译器翻译为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = list.get(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure>
<p>还有一点值得注意的是：基本类型和其包装器是不一样的。基本类型存储在常量池中，因此用==判断时，会完全相等。而包装型则是一个对象，则其判断并不一定相等。</p>
<p>记住以下规定：</p>
<p>自动装箱规范要求boolean，byte，char &lt;= 127 ，介于-128与127之间的short和int将被包装到<strong>固定对象</strong>中。（即符合上述要求的值是包装在同一个对象中，不符合的则可能分布在不同的对象中）所以用==比较时，由于是同一地址，则返回true。</p>
<p>值得注意的是：<strong>拆箱和装箱都是编译器的工作，即编译出的虚拟机指令就包含了拆箱装箱的指令，而不是虚拟机</strong>。</p>
<h2 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h2><p>可以提供参数数量可变的方法 。可以通过下面的方式定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.mw.extendsTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">		varFunc(<span class="number">111</span>,<span class="number">222</span>, <span class="number">333</span>, <span class="number">444</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">varFunc</span><span class="params">(Object... args)</span></span>&#123;</span><br><span class="line">	    System.out.print(Arrays.toString(args));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这样定义的方法，</p>
<ol>
<li>得到的可变参数变量为一个数组。</li>
<li>可变参数必须位于最后一个参数。</li>
</ol>
<p>这也是编译器的工作。当我们调用<code>varFunc(111,222,333)</code>时，实际上编译器会编译为如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">varFunc(<span class="keyword">new</span> Integer[]&#123;<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型即限定其属性只有特定类型。</p>
<p>枚举类型实际上就是一个类，它刚好有4个实例，不可能构造新的对象。其示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size&#123;SMALL, MEDIUM, LARGE&#125;</span><br></pre></td></tr></table></figure>
<p>因此在比较两个枚举类型的值时，并不需要调用<code>equals</code>，直接使用<code>==</code>即可。</p>
<p>但是我们可以在其内部定义变量和方法，且可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size&#123;</span><br><span class="line">    SMALL(<span class="string">"S"</span>), MEDIUM(<span class="string">"M"</span>), LARGE(<span class="string">"L"</span>);				<span class="comment">//实际上是调用下面的构造器方法，参数对应。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Size(String string) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">        name = string;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Size s = Size.valueOf(Size.class, "SMALL");</span><br><span class="line">s.setName(<span class="string">"newS"</span>);</span><br></pre></td></tr></table></figure>
<p>如上，实际上最上面的三个就是初始化的对象，我们可以通过<code>valueOf</code>来新建Size实例，实例化之后可以通过方法来冲洗设定其值。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射（reflection library）提供了丰富而精巧的工具集，可以用来编写能够动态操纵Java代码。</p>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>在Java运行时，系统时钟为所有对象维护一个运行时类型标识。保存其信息的类即为<code>Class</code>。</p>
<p>有以下3种方法获取<code>Class</code>类型的实例</p>
<ol>
<li><code>Object</code>类中的<code>getClass()</code>方法。</li>
<li>使用静态方法<code>forName</code>：<code>Class.forName(&quot;java.util.Random&quot;)</code>。</li>
<li>通过<code>T.class</code>来获取Class实例。（T为Java类型，需要<code>import</code>引入）。</li>
</ol>
<p>注意一个Class对象实际上是一个类型。可能是类，也可能不是类。如<code>int</code>不是类，但<code>int .class</code>是一个Class类型的对象。</p>
<p><strong>虚拟机为每一个类型管理一个唯一的<code>Class</code>对象。</strong>因为可以用==来判断两个类是否相等。</p>
<p>一个Class对象有很多方法和属性，而最关键元素有以下3类：</p>
<ol>
<li>Field: 指类的属性。</li>
<li>Method：指类的方法。</li>
<li>Constructor：指类的构造器。</li>
</ol>
<p>与其对应，有以下六个-3组方法：</p>
<ol>
<li><code>Field[] getFields()</code>：返回该类的所有公开（public）字段，包括父类继承的</li>
<li><code>Field[] getDeclaredFields()</code>：返回该类的所有（<code>public, protected, default，private</code>）字段，不包括父类继承的</li>
<li><code>Method[] getMethods()</code>：返回该类的所有公开（public）方法，包括父类继承的</li>
<li><code>Method[] getDeclaredMethods()</code>：返回该类的所有（<code>public, protected, default，private</code>）方法，不包括父类继承的</li>
<li><code>Constructor[] getConstructors()</code>：返回该类的所有构造器，<strong>公开的</strong></li>
<li><code>Constructor[] getDeclaredConstructors()</code>：返回该类的所有构造器，<strong>所有的</strong></li>
</ol>
<p>注意上述的方法是获取所有的成员，相应的还有获取单个成员的6个方法，含义相同，只是仅返回与之匹配的单个方法：</p>
<ol>
<li><code>Field getFields(String name)</code></li>
<li><code>Field getDeclaredField(String name)</code></li>
<li><code>Method getMethod(String name)</code>：</li>
<li><code>Method getDeclaredMethod(String name)</code></li>
<li><code>Constructor getConstructor(String name)</code></li>
<li><code>Constructor getDeclaredConstructor(String name)</code></li>
</ol>
<p>而在以上3个类中，又可以获取属性（方法）的修饰符（<code>getModifiers()</code>），名称（<code>getName</code>），获取参数（<code>getParameterTypes</code>）或者返回类型（<code>getReturnType()</code>）</p>
<p>注意：上述获取修饰符返回的是一个二进制数据，所以不能直接看出其修饰符有哪些，而需要调用<code>Modifier</code>对象的静态方法<code>isXXX(int modifier)</code>来判断（<code>Modifier.isPublic(modifier)</code>）。</p>
<h3 id="访问对象内部的属性"><a href="#访问对象内部的属性" class="headerlink" title="访问对象内部的属性"></a>访问对象内部的属性</h3><p>我们可以通过上述特征来分析该类的特征，即使用反射来访问对应类的对象的成员。一般是获取到<code>Field</code>对象后，调用其<code>get(obj)</code>的方式来查看。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent(<span class="number">888</span>, <span class="string">"888"</span>); <span class="comment">//id, pubName</span></span><br><span class="line">Class pclass = parent.getClass();</span><br><span class="line">Field pubNameF = pclass.getDeclaredField(<span class="string">"pubName"</span>);</span><br><span class="line">String pubName = (String) pubNameF.get(parent);</span><br><span class="line"><span class="comment">//String pubName = pubNameF.getString(parent);</span></span><br><span class="line">System.out.println(pubName);</span><br></pre></td></tr></table></figure>
<p>如上的代码可以得到<code>parent</code>的值：”888”。</p>
<p>但是下面的代码却不行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent(<span class="number">888</span>, <span class="string">"888"</span>); <span class="comment">//id, pubName</span></span><br><span class="line">Class pclass = parent.getClass();</span><br><span class="line">Field idF = pclass.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line"><span class="keyword">int</span> id = (<span class="keyword">int</span>) pubNameF.get(parent);</span><br><span class="line">System.out.println(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.IllegalAccessException: class test.extendsTest.Test (in module test) cannot access a member of class test.extendsTest.Parent (in module test) with modifiers "private"</span></span><br></pre></td></tr></table></figure>
<p>大意就是私有符修饰的成员不能通过这种方法来访问。</p>
<p>注意反射始终认为其在包外调用。所以只有<code>public</code>的成员可以直接访问。</p>
<h4 id="Feild-setAccessible-flag-Boolean"><a href="#Feild-setAccessible-flag-Boolean" class="headerlink" title="Feild.setAccessible(flag: Boolean)"></a><code>Feild.setAccessible(flag: Boolean)</code></h4><p>我们可以使用<code>setAccessible(true)</code>来覆盖原始的权限，将其设置为<code>public</code>，此时就可以再访问了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent(<span class="number">888</span>, <span class="string">"888"</span>); <span class="comment">//id, pubName</span></span><br><span class="line">Class pclass = parent.getClass();</span><br><span class="line">Field idF = pclass.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">idF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">int</span> id = (<span class="keyword">int</span>) pubNameF.get(parent);</span><br><span class="line">System.out.println(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//888</span></span><br></pre></td></tr></table></figure>
<h3 id="访问对象内部的方法和构造器"><a href="#访问对象内部的方法和构造器" class="headerlink" title="访问对象内部的方法和构造器"></a>访问对象内部的方法和构造器</h3><p>和获取属性类似，我们需要获取<code>Method</code>和<code>Constructor</code>对象后，通过其对象执行。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>对于方法，我们可以通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method.invoke(Object obj, Object... parameters)</span><br></pre></td></tr></table></figure>
<p>来执行对应的方法。其中第一个参数是要执行的对象。后面的参数是要传递给方法的参数。</p>
<p>对于静态方法，第一个参数可以忽略，传入<code>null</code>即可。</p>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>对于构造器，我们可以通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor.newInstance(Object... parameters);</span><br></pre></td></tr></table></figure>
<p>来调用其构造器。唯一注意的是获取的仍然是<code>Object</code>对象，需要强转才能调用其方法和属性。</p>
<h1 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h1><ol>
<li>将公共字段放在超类中</li>
<li>不要使用<code>protected</code>字段</li>
<li>要适当的使用继承，考察两个类是否确实属于同一类。</li>
<li>再覆盖原方法时，不要改变其原始意义。</li>
<li>多使用多态，而不要使用类型信息。（接口学习后更方便）</li>
<li>不要滥用反射。反射是脆弱的，他会弱化编译器的错误检测能力，可能将一些编译时错误推到了运行时才能发现。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>对象与类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术-I-3-Java的基本程序设计结构</title>
    <url>/2022/01/05/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-3-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>注释分为3类：</p>
<ol>
<li><p>单行注释：<code>//</code>其后的部分被视为注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sysout.out.print(<span class="string">"context"</span>) <span class="comment">//annotation</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行注释：<code>/* xxx */</code>内的xxx被视为注释，可以包含多行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	annotation1</span></span><br><span class="line"><span class="comment">	annotation2</span></span><br><span class="line"><span class="comment">	annotation3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文档注释型：这种注释以<code>/**</code>开始，以<code>*/</code>结束，这种注释可以用来自动生成文档。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	annotation1</span></span><br><span class="line"><span class="comment">	annotation2</span></span><br><span class="line"><span class="comment">	annotation3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Java有8中基本类型（primitive type），其中有4种整型、2种浮点类型、1种字符类型和一种表示真假值的Boolean类型。</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td>4字节</td>
<td>-2147483648~2147483647（刚好超过20亿）</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2字节</td>
<td>-32768~32767</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8字节</td>
<td>-9223372036854775808~9223372036854775807</td>
</tr>
<tr>
<td><code>byte</code></td>
<td>1字节</td>
<td>-128~127</td>
</tr>
</tbody>
</table>
<p>Note：</p>
<ol>
<li><p>在Java中，整型的范围与运行Java代码得机器无关。</p>
</li>
<li><p>长整型数值有一个后缀L或l。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long lVal = <span class="number">999999999999999l</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从java7开始，可以为数字字面量添加下划线，如<code>9_999_999</code>即为<code>9999999</code>。</p>
</li>
</ol>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>大约±3.402823E+38F（有效位数为6~7位）</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>大约±1.79769313486231570E+308（有效位数为15位）</td>
</tr>
</tbody>
</table>
<p>Note:</p>
<ol>
<li>定义<code>float</code>类型时，其数值有一个后缀<code>F</code>或者<code>f</code>。没有后缀<code>F</code>或<code>f</code>会被默认视为double类型。（实际上也很少使用<code>float</code>，大多使用<code>double</code>）。</li>
<li><p>常量<code>Double.POSITIVE_INFINITY</code>、<code>Double.NEGATIVE_INFINITY</code>和<code>Double.NaN</code>分别表示IEEE754规定的用于表示溢出和出错情况的三个特殊浮点数值：</p>
<ol>
<li>正无穷大</li>
<li>负无穷大</li>
<li><code>NaN</code>（Not a Number）</li>
</ol>
</li>
<li><p>不能用<code>==</code>判断一个数是否为<code>NaN</code>，而应该用<code>Double.isNaN(param)</code>。</p>
</li>
<li>浮点数存在误差，如经典的(2.0 - 1.1) = 0.899999999999, 而不是0.9。这是由于浮点数值采用二进制系统表示，而在二进制系统中无法精确的表示分数1/10。这就像无法用十进制精确的表达1/3一样。如果需要精确的计算，则应该采用<code>BigDecimal</code>类。</li>
</ol>
<h2 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h2><p>char类型原本表示单个字符，占2字节。不过现在一些Unicode字符需要两个char值来表达。</p>
<p>char类型表示的是十六进制值，其范围是从<code>\u0000</code>到<code>\uffff</code>。如<code>\u2122</code>表示商标（™）。</p>
<p>除了转移序列<code>\u</code>之外，还有一些用于表示特殊字符的转移序列。参见下表。</p>
<table>
<thead>
<tr>
<th>转移序列</th>
<th>名称</th>
<th>Unicode值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\b</code></td>
<td>退格</td>
<td><code>\u0008</code></td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表</td>
<td><code>\u0009</code></td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行</td>
<td><code>\u000a</code></td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
<td><code>\u000d</code></td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
<td><code>\u0022</code></td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
<td><code>\u0027</code></td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠</td>
<td><code>\u005c</code></td>
</tr>
</tbody>
</table>
<p>Note：</p>
<ol>
<li><p>Unicode转义序列会在解析代码之前得到处理。也就是说，Java源代码的任意字符都可以使用 Unicode来编写。</p>
<p>以此会产生一些隐晦的语法错误（现在编译器都会提示），比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// look inside c:\users</span></span><br></pre></td></tr></table></figure>
<p>由于<code>\u</code>并没有跟着4个十六进制数。</p>
</li>
</ol>
<h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><ol>
<li><p>从jdk10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就可以不声明变量类型。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vacationDays = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量的定义使用关键字<code>final</code>，并且其只可以被赋值一次（注意并不是只可以在声明时赋值，可以在声明后在<strong>构造器方法中</strong>赋值，但是仅可以被赋值一次）。</p>
</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>在Java中，使用+,-,*,/表示加、减、乘、除运算。</p>
<ol>
<li>对于/运算，当两个操作数都是整数时，表示整数除法（即只返回整数部分），否则表示浮点除法。</li>
<li>对于%运算，表示求余操作，其操作数可以为整型或者浮点型。</li>
</ol>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>在<code>Math</code>类中，为了达到最佳的性能，所有的方法都是用计算机浮点单元中的例程。如果要求计算更加准确而不是在乎速度，则可以使用<code>StrictMath</code>类，其API与<code>Math</code>类完全相同。</p>
<h2 id="数值类型的转换"><a href="#数值类型的转换" class="headerlink" title="数值类型的转换"></a>数值类型的转换</h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p><img src="\images\java核心技术\数值类型转换.jpg" alt="数值类型转换"></p>
<p>图中展示出各种数值类型的转换，其中实线表示可以无损转换，而虚线表示转换会损失精度。</p>
<p>当一个二元操作符连接两个不同类型的值时，需要先将其转换为同一种类型才能进行运算。这种隐式转换的规则如下：</p>
<ol>
<li>如果两个操作数中有一个是<code>double</code>类型，另一个操作数就会转换为<code>double</code>类型。</li>
<li>否则，如果其中一个操作数是<code>flaot</code>类型，另一个操作数就会转换成为<code>float</code>类型。</li>
<li>否则，如果其中一个操作数是<code>long</code>类型，另一个操作数将会转换为<code>long</code>类型。</li>
<li>否则，两个操作数都将会被转化为<code>int</code>类型。</li>
</ol>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在Java中，通过：<code>(type) variable</code>来完成强制类型转换，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">int</span> intPi = (<span class="keyword">int</span>)pi;	<span class="comment">//会丢失精度，编译器会warn</span></span><br></pre></td></tr></table></figure>
<p>注意以上的转换会直接截断小数点。如果需要四舍五入，则可以使用<code>Math.round()</code>函数来实现。</p>
<h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><p>如下表</p>
<table border="1"><br><tbody><br><tr><br><th><br>优先级</th><br><th><br>运算符</th><br><th><br>结合性</th><br></tr><br><tr><br><th><br>1</th><br><td><br>()、[]、{}</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>2</th><br><td><br>!、+、-、~、++、–</td><br><td><br>从右向左</td><br></tr><br><tr><br><th><br>3</th><br><td><br><em>、/、%</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>4</th><br><td><br>+、-</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>5</th><br><td><br>«、»、&gt;&gt;&gt;</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>6</th><br><td><br>&lt;、&lt;=、&gt;、&gt;=、instanceof</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>7</th><br><td><br><sub>==、!=</sub></td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>8</th><br><td><br>&amp;</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>9</th><br><td><br>^</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>10</th><br><td><br>|</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>11</th><br><td><br>&amp;&amp;</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>12</th><br><td><br>||</td><br><td><br>从左向右</td><br></tr><br><tr><br><th><br>13</th><br><td><br>?:</td><br><td><br>从右向左</td><br></tr><br><tr><br><th><br>14</th><br><td><br>=、+=、-=、</em>=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;=</td><br><td><br>从右向左</td><br></tr><br></tbody><br></table>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>从概念上将，Java的字符串就是Unicode的字符序列。如，字符串”Java\u2122”由5个Unicode字符J、a、v、a和™组成。并且String并不是基础类型之一，所以在标准的Java类库中提供了一个预制类称为String。</p>
<p>String类没有提供修改字符串中某个字符的方法。如果希望修改字符串中某个位置的值，可以使用<code>substring()</code>方法来实现。</p>
<p><strong>不提供修改方法的原因主要在于可以共享字符串的值，将其存储在一个共享池中，提升效率。</strong>详细在jvm虚拟机的内存模型时可以更加详细的了解。</p>
<h2 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h2><p>在检测字符串是否相等时，一般不使用<code>==</code>，这是由于实际上只有通过字面量定义的字符串是共享的，而通过构造器或者<code>substring()</code>得到的方法并不是共享的。所以：</p>
<ol>
<li>如果两个字符串都是用字面量定义的，则可以使用<code>==</code>来判断。</li>
<li>其他情况下，都应当<code>equal()</code>方法来判断相等关系。</li>
<li>综上，还是尽量使用<code>equal()</code>方法来判断，防止不可预知的bug。</li>
</ol>
<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>jdk9之前，String底层是使用char值序列组成，而jdk9中，其底层变成了byte值序列。</p>
<h2 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h2><p>有些时候，需要由较短的字符串来构建字符，这时如果采用字符串拼接会比较消耗性能，这时候可以采用<code>StringBuilder</code>类来构建字符串。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(<span class="string">"str1"</span>);</span><br><span class="line">buidler.append(<span class="string">"str2"</span>);</span><br><span class="line">String s = builder.toString();</span><br></pre></td></tr></table></figure>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String name = in.nextLine();	<span class="comment">//读取一行</span></span><br><span class="line">String firstName = in.next();	<span class="comment">//读取下一个单词</span></span><br><span class="line"><span class="keyword">int</span> age = in.nextInt();			<span class="comment">//读取下一个int</span></span><br><span class="line"><span class="keyword">double</span> tall = in.nextDouble();	<span class="comment">//读取下一个double</span></span><br></pre></td></tr></table></figure>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p><code>Sysout.print.out(x)</code>将数值x输出到控制台。</p>
<p><code>Sysout.out.printf()</code>可以进行格式化输出。如：<code>Sysout.out.printf(&quot;%8.2f&quot;, x)</code>。这种语法沿用了C语言函数库中的<code>printf()</code>方法。</p>
<p>其第一个参数格式如下：</p>
<p><img src="\images\java核心技术\格式化输出.jpg" alt="格式化输出"></p>
<p>分别解释每一项：</p>
<ol>
<li><p><code>%</code>：表示格式化输出的标识符。</p>
</li>
<li><p><code>argument index</code>+<code>$</code>一起表示参数索引，即<code>Sysout.out.printf(FORMAT, x,...restArg)</code>可以接受多个参数，其中<code>1$</code>,<code>2$</code>,<code>n$</code>表示对第一个，第二个，第n个参数进行特定的格式化。</p>
</li>
<li><p><code>flag</code>：指定控制格式化输出外观的各种标志，如下表：</p>
<table border="0" cellspacing="0" cellpadding="5" align="center"><thead><tr><th align="left">标志</th><th align="left">目的</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">打印数字前的符号</td><td align="left">+3333.33</td></tr><tr><td align="left">space</td><td align="left">在正数之前加空格</td><td align="left">| 3333.33|</td></tr><tr><td align="left">0</td><td align="left">在数字前补0</td><td align="left">003333.33</td></tr><tr><td align="left">-</td><td align="left">左对齐</td><td align="left">|3333.33 |</td></tr><tr><td align="left">(</td><td align="left">负数括在括号内</td><td align="left">(3333.33)</td></tr><tr><td align="left">,</td><td align="left">添加分组分隔符</td><td align="left">3,333.33</td></tr><tr><td align="left"># (for <tt><span style="font-family: 新宋体;">f</span></tt> )</td><td align="left">包含小数点</td><td align="left">3,333.</td></tr><tr><td align="left"># (for <tt><span style="font-family: 新宋体;">x</span></tt> or <tt><span style="font-family: 新宋体;">o</span></tt>)</td><td align="left">添加前缀 0x 或 0</td><td align="left">0xcafe</td></tr><tr><td align="left">^</td><td align="left">转化为大写</td><td align="left">0XCAFE</td></tr><tr><td align="left">$</td><td align="left">指定格式化参数索引，如%1$d,%1$d表示以十进制<br>和十六进制打印第一个参数</td><td align="left">159 9F</td></tr><tr><td align="left">&lt;</td><td align="left">格式化前面参数，如%d%&lt;x表示以十进制和十六进<br>制打印同一个参数</td><td align="left">159 9F</td></tr></tbody></table>
</li>
<li><p><code>width</code>：表示输出的位宽，如果原内容不足<code>width</code>，则填空格。</p>
</li>
<li><p><code>t</code>+<code>conversion character</code>：转换符指示要格式化的数据类型。所有内容如下表：</p>
<table border="0" cellspacing="0" cellpadding="5" align="center"><thead><tr><th align="left">转换符</th><th align="left">类型</th><th align="left">　举例</th></tr></thead><tbody><tr><td align="left">d</td><td align="left">十进制整数　　</td><td align="left">159</td></tr><tr><td align="left">x</td><td align="left">十六进制整数</td><td align="left">9f</td></tr><tr><td align="left">o</td><td align="left">八进制整数</td><td align="left">237</td></tr><tr><td align="left">f</td><td align="left">定点浮点数</td><td align="left">15.9</td></tr><tr><td align="left">e</td><td align="left">指数浮点数</td><td align="left">1.59e+01</td></tr><tr><td align="left">g</td><td align="left">通常浮点数</td><td align="left">&nbsp;</td></tr><tr><td align="left">a</td><td align="left">十六进制浮点数</td><td align="left">0x1.fccdp3</td></tr><tr><td align="left">s</td><td align="left">字符串</td><td align="left">Hello</td></tr><tr><td align="left">c</td><td align="left">字符</td><td align="left">H</td></tr><tr><td align="left">b</td><td align="left">布尔型</td><td align="left">TRue</td></tr><tr><td align="left">h</td><td align="left">散列码</td><td align="left">42628b2</td></tr><tr><td align="left">t<em><span style="color: #0000ff;">x</span></em></td><td align="left">日期时间</td><td align="left">见时间介绍表</td></tr><tr><td align="left">%</td><td align="left">百分号</td><td align="left">%</td></tr><tr><td align="left">n</td><td align="left">分隔符　　　　　</td><td align="left">&nbsp;</td></tr></tbody></table>
</li>
<li><p><code>.</code>+<code>precision</code>：表示数值输出的小数点位数，如果不足后面补0。</p>
</li>
</ol>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(Path.of(<span class="string">"file.txt"</span>), StanardCharsets.UTF_8);</span><br><span class="line">String l = in.nextLine();	<span class="comment">//读取一行，还有其他类型如上代码一样</span></span><br></pre></td></tr></table></figure>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"file.txt"</span>, StanardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>在Java中没有<code>goto</code>语句，但是设计了另外一种语法来实现其一部分语法。</p>
<h2 id="带标签的break语法"><a href="#带标签的break语法" class="headerlink" title="带标签的break语法"></a>带标签的<code>break</code>语法</h2><p>可以使用带标签的break来讲程序跳转到确定位置。标签定义后加冒号，其后可以跟任何代码块。<code>break</code>后加标签名字。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环中使用</span></span><br><span class="line">check_point:		<span class="comment">//定义标签位置</span></span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">break</span> check_point;	<span class="comment">//跳转到check_point位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任何位置使用</span></span><br><span class="line">check_point1:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(...) <span class="keyword">break</span> check_point1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h1><p>如果基本的整数和浮点数精度不能满足需求，则可以使用<code>java.Math</code>包中的两个类：</p>
<ul>
<li><code>BigInteger</code>：大整数。</li>
<li><p><code>BigDecimal</code>：大浮点数。</p>
</li>
<li><p>可以使用vlaueOf方法将<strong>普通的数值</strong>转换为大数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger big = BigInteger.valueOf(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用构造器传入<strong>字符串数值</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger big = <span class="keyword">new</span> BigInteger(<span class="string">"99999999999999999999999999999999999999999999999999999999999999999999999999999999"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但值得注意的是，大数不能使用普通的算术运算符（如+, -, *, /）。而是要使用大数类的<code>add</code>，<code>multiply</code>方法等来进行运算。如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger c = a.add(b);</span><br><span class="line">BigInteger d = c.multipy(b.add(BigInteger.valueOf(<span class="number">2</span>)));		<span class="comment">//d = c * (b + 2)</span></span><br></pre></td></tr></table></figure>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a;		<span class="comment">// 一般使用这种，因为更容易区分变量名和数据类型</span></span><br><span class="line"><span class="keyword">int</span> a[];</span><br></pre></td></tr></table></figure>
<p>数组初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明和初始化分开</span></span><br><span class="line"><span class="keyword">int</span>[] a;</span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明和初始化一起</span></span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//字面量方法创建数组</span></span><br><span class="line"><span class="keyword">int</span>[] d = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>一旦创建了数组，就无法改变它的长度。</p>
</li>
<li><p>如果需要可改变大小的数组，可以使用<code>ArrayList</code>。</p>
</li>
<li><p>注意通过字面量方法创建数组时，不需要提供数组大小，也不需要<code>new</code>操作符。</p>
</li>
<li>创建一个数字数组时，所有元素都初始化为0；Boolean数组的元素会初始化为false；对象数组的元素则初始化为一个特殊值<code>null</code>。</li>
</ol>
<h2 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h2><p>可以使用<code>Arrays.copyOf(originalArray, newArrayLength)</code>来创建一个新的数组，并将原数组复制到新数组中，可以间接实现改变数组大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// b = &#123;1, 2, 3, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>Note：当新数组的长度小于原数组，则会截断原始数组。</strong></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>主函数<code>main(String[] args)</code>的参数是作为命令行参数。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java A -g param1 param2</span><br></pre></td></tr></table></figure>
<p>则结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">args[<span class="number">0</span>]: <span class="string">"-g"</span>;</span><br><span class="line">args[<span class="number">1</span>]: <span class="string">"param1"</span>;</span><br><span class="line">args[<span class="number">2</span>]: <span class="string">"param2"</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>Java的基本程序设计结构</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-I-7-异常、断言和日志</title>
    <url>/2022/01/21/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-7-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h1><p>在Java程序设计语言中，所有异常对象都是派生于<code>Throwable</code>类的一个类实例。 </p>
<p>继承关系图如下：</p>
<p><img src="\images\java核心技术\错误类继承.jpg" alt="错误类继承"></p>
<p>可以看到Throwable异常被分为两大类：</p>
<ul>
<li><code>Error</code>：表示Java运行时系统的内部错误和资源耗尽错误。</li>
<li><code>Exception</code>：程序运行的异常，一般我们能操作的都是这种错误。</li>
</ul>
<p><code>RuntimeException</code> 一般是编程错误导致的。</p>
<p>派生于<code>RuntimeException</code>的异常包括以下问题：</p>
<ul>
<li>错误的强制转换</li>
<li>数组访问越界</li>
<li>访问null指针</li>
</ul>
<p><code>IOException</code>的异常包括以下问题：</p>
<ul>
<li>试图超越文件末尾继续读取数据</li>
<li>试图打开一个不存在的文件</li>
<li>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在</li>
</ul>
<blockquote>
<p>如果出现<code>RuntimeException</code>，那么就一定是你的问题。</p>
</blockquote>
<p>所以这句话有一定的根据（当然错误也可能出现在你引用的库中）</p>
<p>Java语言规范将派生于<code>Error</code>类或<code>RuntimeException</code>类的所有异常称为<code>非检查型（unchecked）</code>异常，所有其他的异常称为<code>检查型（check）</code>异常。</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>可以通过<code>throw</code>关键字来抛出异常。</p>
<p>Java在库中定义了很多错误类型，我们可以通过查阅文档来获得相应的错误类型。（当然我们也可以定义自己的错误类型）</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">///do something</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EOFExcepiton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h2><p>我们可以通过继承<code>Exception</code>类或者其子类来创建单独的异常类。</p>
<p>基本示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Throwable</code>类中定义了很多成员，其中主要有<code>message:String</code>和<code>cause:Throwable</code>。而<code>Exception</code>也根据其提供了4个构造方法。</p>
<ul>
<li>无参构造器</li>
<li>只含<code>message</code>的构造器</li>
<li>只含<code>cause</code>的构造器</li>
<li>包含<code>message</code>和<code>cause</code>的构造器</li>
</ul>
<p>所以我们也可以这样定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.mw.ExceptionTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message, cause);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(cause);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>如果发生了某个异常，但没有任何地方捕获这个异常，程序就会停止，并且会在控制面板上打印一个消息：包括这个异常的信息和调用堆栈。</p>
<h3 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>可以通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// normal code</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// code for handling the exception</span></span><br><span class="line">&#125;finaly&#123;</span><br><span class="line">    <span class="comment">// code need to be execeuted anyway</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来捕获异常，其含义如下：</p>
<ol>
<li>如果normal code发生错误，则错误后的代码都不会被执行。</li>
<li>将错误传递到catch块中进行处理</li>
<li>finally中的代码无论如何都会执行（normal code发生错误或不发生错误都会执行）</li>
</ol>
<p>如果normal code中可能发生的错误不只一个。我们可以通过以下两种方式来进行处理：</p>
<ul>
<li>添加多个catch块来分别处理</li>
<li>使用<code>catch(Exception1 | Exception2 | Exception3 e)</code>的格式来捕获多个错误。</li>
<li>使用<code>catch(Exception e)</code>来通过多态来捕获所有可能的异常。（这里即使发生错误，也会在控制台打印出具体的类名，而不是<code>Exception</code>）。</li>
</ul>
<h4 id="再次抛出异常"><a href="#再次抛出异常" class="headerlink" title="再次抛出异常"></a>再次抛出异常</h4><p>一般来说，我们可以再次抛出异常。而在最外围来捕获所有的异常。其有两种形式：</p>
<ul>
<li><p>在<code>catch</code>中捕获到后再次抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接在方法上抛出错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> String <span class="title">save</span><span class="params">()</span>  <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="try…with-Resource语句"><a href="#try…with-Resource语句" class="headerlink" title="try…with-Resource语句"></a>try…with-Resource语句</h3><p>有时我们需要在try语句中打开一些资源，并且最后必须关闭，我们通常会使用<code>finally</code>语句来实现。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    source.open();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">///handle</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    source.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java7之后，可以用<code>try...with-Resource</code>语句来关闭资源，前提是这个资源实现了<code>AutoCloseable</code>接口。格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Resource res = ...)&#123;</span><br><span class="line">    <span class="comment">//res is accessible in the scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在try语句退出之后，会自动调用<code>res.close()</code>。</p>
<p>也可以指定多个资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Resource res1 = <span class="keyword">new</span> Resource();</span><br><span class="line">    Resource res2 = <span class="keyword">new</span> Resource();</span><br><span class="line">   )&#123;</span><br><span class="line">    <span class="comment">//res1 and res2 is include in the scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用异常的技巧"><a href="#使用异常的技巧" class="headerlink" title="使用异常的技巧"></a>使用异常的技巧</h2><ol>
<li>异常处理不能代替简单的判断：即能用<code>if</code>判断是否出现异常的，就不直接用异常。</li>
<li>不要过分的细化异常。</li>
<li><strong>不要只捕获<code>Exception</code>或者<code>Throwable</code>，因为这对代码阅读并不友好，无法直接判断可能出现的错误。</strong></li>
<li>不要对异常进行静默处理。即<code>catch</code>必须做点什么，而不是仅捕获，什么都不做。</li>
<li><strong>并不一定要捕获所有异常，有时候抛出到外层是更好的选择（可以在外层做统一处理）。</strong></li>
</ol>
<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>有时候我们需要在<strong>测试期间</strong>加入一些判断，如果条件不成立，则退出程序。但是在正式版本中，将会删除这部分代码，这是很麻烦的。</p>
<p>所以引入了断言机制，其格式如下：</p>
<ol>
<li><code>assert conditon;</code>：如果condition为false，则退出程序，并抛出<code>AssertionError</code>。</li>
<li><code>assert condition : expresssion</code>：如果condition为false，则退出程序，并抛出<code>AssertionError</code>，并且信息为expression。</li>
</ol>
<h3 id="启用断言"><a href="#启用断言" class="headerlink" title="启用断言"></a>启用断言</h3><p>断言默认是被禁用的。。</p>
<p>启用断言需要加上vm关键字：<code>-ea</code>或者<code>-enableassertions</code>。</p>
<p>也可以使用<code>-desableassertions</code>或<code>-da</code>来禁止断言。</p>
<p>idea或eclipse中可以在环境参数中配置。</p>
<p>启用或禁用断言是类加载器的功能。断言被禁用时，类加载器会去除断言代码，因此不会降低程序运行时的代码。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>在Java程序中，我们经常需要打印中间信息。</p>
<p>我们通常使用<code>System.out.print</code>来进行打印。</p>
<p>但是其具有很多缺点。相较于直接输出，日志API有以下 优点：</p>
<ul>
<li>日志分级。并且可以分级打印特定日志级别下的信息。</li>
<li>可以很简单的禁止日志记录。</li>
<li>可以将日志信息打印到控制台或保存在文件中。</li>
<li>可以对所有日志进行过滤。</li>
<li>可以单独的格式化日志信息。</li>
<li>可以单独的配置日志设置。</li>
</ul>
<p>Java从1.5开始，在<code>java.util</code>下增加了<code>Logger</code>类。但是这个类已经很少有人使用。使用<code>Log4j</code>的更多，所以这里不详细介绍。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>异常、断言和日志</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习5-补丁</title>
    <url>/2022/02/27/git%E5%AD%A6%E4%B9%A05-%E8%A1%A5%E4%B8%81/</url>
    <content><![CDATA[<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git apply [--<span class="built_in">stat</span>] [--numstat] [--summary] [--check] [--index | --intent-to-add] [--3way]</span><br><span class="line">	  [--apply] [--no-add] [--build-fake-ancestor=&lt;file&gt;] [-R | --reverse]</span><br><span class="line">	  [--allow-binary-replacement | --binary] [--reject] [-z]</span><br><span class="line">	  [-p&lt;n&gt;] [-C&lt;n&gt;] [--inaccurate-eof] [--recount] [--cached]</span><br><span class="line">	  [--ignore-space-change | --ignore-whitespace]</span><br><span class="line">	  [--whitespace=(nowarn|warn|fix|error|error-all)]</span><br><span class="line">	  [--exclude=&lt;path&gt;] [--include=&lt;path&gt;] [--directory=&lt;root&gt;]</span><br><span class="line">	  [--verbose | --quiet] [--unsafe-paths] [--allow-empty] [&lt;patch&gt;…]</span><br></pre></td></tr></table></figure>
<p>将补丁应用于文件和/或索引。</p>
<p>读取提供的diff输出并将其应用到文件中。当从存储库中的子目录运行时，将忽略该目录外已修补的路径。</p>
<p>使用<code>--index</code>选项，补丁也会应用到索引。</p>
<p>而使用<code>--cached</code>选项，补丁只会应用到索引。</p>
<p>如果没有这些选项，该命令只将补丁应用于文件，而不要求它们存在于Git存储库中。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>&lt;patch&gt;…</code>：要读取补丁的文件。-可用于从标准输入读取。</li>
<li><code>--stat</code>：不应用补丁，而从输入中输出diffstat。。</li>
<li><code>--summary</code>：不应用补丁，而是输出从git diff扩展头中获得的信息的压缩摘要，例如创建、重命名和模式更改。</li>
<li><code>--check</code>：应用补丁，而是查看补丁是否适用于当前的工作树和/或索引文件，并检测错误。</li>
<li><code>--index</code>：将补丁应用到索引和工作树中(或者只是检查它是否会干净地应用到这两个树中，如果<code>--check</code>有效的话)。注意,树副本<code>--index</code>预计索引条目和工作相关的路径是相同的(其内容和元数据等文件模式必须匹配),并将提高一个错误如果他们不是,即使补丁对双方都应用干净指数和隔离工作树。</li>
<li><code>--cached</code>：只对索引应用补丁，而不触及工作树。如果<code>--check</code>生效，只需要检查它是否完全适用于索引项。</li>
<li><code>--allow-empty</code>：可以应用空的补丁或者只含提交文本的补丁。</li>
</ul>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a><code>cherry-pick</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick [--edit] [-n] [-m &lt;parent-number&gt;] [-s] [-x] [--ff]</span><br><span class="line">		  [-S[&lt;keyid&gt;]] &lt;commit&gt;…</span><br><span class="line">git cherry-pick (--<span class="built_in">continue</span> | --skip | --abort | --quit)</span><br></pre></td></tr></table></figure>
<p>给定一个或多个现有提交，应用每个提交引入的更改，为每个提交记录一个新提交。这需要你的工作树是干净的（没有来自HEAD提交的修改）。</p>
<h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>&lt;commit&gt;…</code>：要提交给cherry-pick的提交。</li>
<li><code>e; --edit</code>：通过这个选项，<code>git cherry-pick</code>将允许你在提交之前编辑提交消息。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li><p><code>git cherry-pick master</code>：在主分支的顶端应用提交引入的更改，并使用此更改创建一个新的提交。</p>
</li>
<li><p><code>`</code>bash<br>git cherry-pick ..master<br>git cherry-pick ^HEAD master</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  应用由master的祖先(而不是HEAD的祖先)的所有提交引入的更改来产生新的提交。</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;bash</span><br><span class="line">  git cherry-pick maint next ^master</span><br><span class="line">  git cherry-pick maint master..next</span><br></pre></td></tr></table></figure>
<p>应用所有提交引入的更改，这些提交是维护或下一个的祖先，而不是master或它的任何祖先。</p>
</li>
<li><p><code>git cherry-pick master~4 master~2</code></p>
<p>应用由master指向的第五次和第三次提交所引入的更改，并使用这些更改创建2个新的提交。</p>
</li>
<li><p><code>git cherry-pick (commitid1..commitid100])</code>：commitid1为想复制的最老提交(不包括),commitid100为想复制的最新提交(包括)。</p>
</li>
<li><p><code>git cherry-pick [commitid1^..commitid100]</code>：commitid1为想复制的最老提交(<strong>包括</strong>),commitid100为想复制的最新提交(包括)。</p>
</li>
<li><p><code>git rev-list --reverse master -- README | git cherry-pick -n --stdin</code>：将涉及到README的主分支上的所有提交所引入的更改应用到工作树和索引中，这样就可以检查结果，并在合适的情况下将其转换为单个新提交。</p>
</li>
</ul>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a><code>diff</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff [&lt;options&gt;] [&lt;commit&gt;] [--] [&lt;path&gt;…]</span><br><span class="line">git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…]</span><br><span class="line">git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; [&lt;commit&gt;…] &lt;commit&gt; [--] [&lt;path&gt;…]</span><br><span class="line">git diff [&lt;options&gt;] &lt;commit&gt;…&lt;commit&gt; [--] [&lt;path&gt;…]</span><br><span class="line">git diff [&lt;options&gt;] &lt;blob&gt; &lt;blob&gt;</span><br><span class="line">git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>显示工作树和索引或树之间的更改、索引和树之间的更改、两棵树之间的更改、合并导致的更改、两个blob对象之间的更改或磁盘上两个文件之间的更改。</p>
<h3 id="git-diff-lt-options-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] [--] [&lt;path&gt;…]</code></h3><p>该形式用于查看相对于索引(下一次提交的暂存区域)所做的更改。换句话说，区别在于您可以告诉Git进一步添加到索引中的内容，但仍然还没有添加。</p>
<h3 id="git-diff-lt-options-gt-no-index-lt-path-gt-lt-path-gt"><a href="#git-diff-lt-options-gt-no-index-lt-path-gt-lt-path-gt" class="headerlink" title="git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;"></a><code>git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;</code></h3><p>该形式用于比较文件系统中给定的两条路径。当在一个由Git控制的工作树中运行命令，并且至少有一个路径点在工作树之外时，或者当在一个由Git控制的工作树之外运行命令时，可以省略<code>--no-index</code>选项。</p>
<h3 id="git-diff-lt-options-gt-cached-merge-base-lt-commit-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-cached-merge-base-lt-commit-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…]</code></h3><p>该形式用于查看您为下一次提交而进行的相对于命名的<code>&lt;commit&gt;</code>的更改。通常，您希望与最近的提交进行比较，因此，如果您没有给出<code>&lt;commit&gt;</code>，则默认为HEAD。如果HEAD不存在(例如未出生的分支)，并且<code>&lt;commit&gt;</code>没有给出，它会显示所有的分段更改。<code>--staging</code>是<code>--cached</code>的同义词。</p>
<h3 id="git-diff-lt-options-gt-merge-base-lt-commit-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-merge-base-lt-commit-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; [--] [&lt;path&gt;…]</code></h3><p>该形式用于查看工作树中相对于命名的<code>&lt;commit&gt;</code>的更改。您可以使用HEAD将其与最近的提交进行比较，或者使用分支名称将其与不同分支的尖端进行比较。</p>
<h3 id="git-diff-lt-options-gt-merge-base-lt-commit-gt-lt-commit-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-merge-base-lt-commit-gt-lt-commit-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…]</code></h3><p>该形式用于查看两个任意<code>&lt;commit&gt;</code>之间的更改。</p>
<h3 id="git-diff-lt-options-gt-lt-commit-gt-lt-commit-gt-…-lt-commit-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-lt-commit-gt-lt-commit-gt-…-lt-commit-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] &lt;commit&gt; &lt;commit&gt;… &lt;commit&gt; [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] &lt;commit&gt; &lt;commit&gt;… &lt;commit&gt; [--] [&lt;path&gt;…]</code></h3><p>该形式用于查看合并提交的结果。列出的第一个<code>&lt;commit&gt;</code>必须是merge本身;剩下的两个或更多的提交应该是它的父节点。生成所需修订集的一种方便的方法是使用^@后缀。例如，如果master命名了一个合并提交，<code>git diff master master^@</code>将给出与<code>git show master</code>相同的diff组合。</p>
<h3 id="git-diff-lt-options-gt-lt-commit-gt-lt-commit-gt-lt-path-gt-…"><a href="#git-diff-lt-options-gt-lt-commit-gt-lt-commit-gt-lt-path-gt-…" class="headerlink" title="git diff [&lt;options&gt;] &lt;commit&gt;..&lt;commit&gt; [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] &lt;commit&gt;..&lt;commit&gt; [--] [&lt;path&gt;…]</code></h3><p>这与前面的形式(没有..)是同义的，用于查看两个任意<code>&lt;commit&gt;</code>之间的更改。如果在一边省略<code>&lt;commit&gt;</code>，它将具有与使用HEAD相同的效果。</p>
<h3 id="git-diff-lt-options-gt-lt-commit-gt-lt-commit-gt-lt-path-gt-…-1"><a href="#git-diff-lt-options-gt-lt-commit-gt-lt-commit-gt-lt-path-gt-…-1" class="headerlink" title="git diff [&lt;options&gt;] &lt;commit&gt;...&lt;commit&gt; [--] [&lt;path&gt;…]"></a><code>git diff [&lt;options&gt;] &lt;commit&gt;...&lt;commit&gt; [--] [&lt;path&gt;…]</code></h3><p>该形式用于查看包含第二个<code>&lt;commit&gt;</code>的分支上的更改，从两个<code>&lt;commit&gt;</code>的共同祖先开始。</p>
<h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>-p; -u; --patch</code>：生成补丁文件。这是默认值。</li>
<li><code>-s; --no-patch</code>：禁止diff输出。对于<code>git show</code>这样的命令很有用，可以默认显示补丁，或者取消<code>--patch</code>的效果。</li>
<li><code>--output=&lt;file&gt;</code>：输出到特定的文件，而不是标准输出。</li>
<li><code>--raw</code>：以原始格式生成diff。</li>
<li><code>--name-only</code>：只显示更改文件的名称。文件名通常用UTF-8编码。</li>
<li><code>--name-status</code>：只显示更改文件的名称和状态。</li>
</ul>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--<span class="built_in">exec</span> &lt;cmd&gt;]</span><br><span class="line">	[--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt; [&lt;branch&gt;]]</span><br><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--<span class="built_in">exec</span> &lt;cmd&gt;] [--onto &lt;newbase&gt;]</span><br><span class="line">	--root [&lt;branch&gt;]</span><br><span class="line">git rebase (--<span class="built_in">continue</span> | --skip | --abort | --quit | --edit-todo | --show-current-patch)</span><br></pre></td></tr></table></figure>
<p>在另一个基地址的顶端应用提交。</p>
<p>如果指定了<code>&lt;branch&gt;</code>， <code>git rebase</code>会在做其他事情之前自动切换<code>&lt;branch&gt;</code>。否则，它将保持在当前分支上。</p>
<p>当前分支中由提交所做的、但不在<code>&lt;upstream&gt;</code>中的所有更改都被保存到一个临时区域。通过<code>git log &lt;upstream&gt;..HEAD</code>命令可以进行显示。</p>
<p>如果提供了<code>--onto</code>选项，则当前分支被重置为<code>&lt;upstream&gt;</code>，或者<code>&lt;newbase&gt;</code>。这与<code>git reset --hard &lt;upstream&gt;</code>(或<code>&lt;newbase&gt;</code>)有完全相同的效果。在重置之前，ORIG_HEAD被设置为指向分支的顶端。</p>
<p>之前保存到临时区域的提交将依次重新应用到当前分支。请注意，在HEAD中任何提交都会引入与在HEAD中提交相同的文本更改。<code>&lt;upstream&gt;</code>都省略了。</p>
<h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>--onto &lt;newbase&gt;</code>：创建新提交的起始点。</li>
<li><code>--keep-base</code>：设置将新提交到<code>&lt;upstream&gt; &lt;branch&gt;</code>的合并基的起点。这个选项在上游分支上开发特性的情况下非常有用。当这个特性正在开发的时候，上游分支可能会向前推进，而保持在上游的顶部重基可能不是最好的主意，而是保持基本的提交。</li>
<li><code>&lt;upstream&gt;</code>：进行比较的上游分支。可以是任何有效的提交，而不仅仅是现有的分支名称。默认为当前分支配置的上游。</li>
<li><code>&lt;branch&gt;</code>：工作分支；默认为HEAD。</li>
<li><code>--continue</code>：在解决合并冲突后重新启动重基流程。</li>
<li><code>--abort</code>：中止重基操作并将HEAD重置到原始分支。如果在rebase操作开始时提供了<code>&lt;branch&gt;</code>，那么HEAD将被重置为<code>&lt;branch&gt;</code>。否则，HEAD将被重置到重基操作开始时的位置。</li>
<li><code>--quit</code>：中止重基操作，但不会将HEAD重置回原始分支。因此，索引和工作树也保持不变。如果使用<code>--autostash</code>创建了一个临时存储条目，那么它将被保存到<code>stash</code>列表中。</li>
<li><code>--apply</code>：使用应用策略来重基(在内部调用git-am)。一旦合并后端处理了应用程序所做的所有事情，这个选项可能在将来不会发生任何操作。</li>
<li><code>--empty={drop,keep,ask}</code>：如何处理那些在启动时不是空的、也不是任何上游提交的干净的、但在重基之后变成空的提交(因为它们包含已经上游更改的子集)。</li>
</ul>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p>假设存在以下历史记录，并且当前分支为“topic”:</p>
<pre><code>      A---B---C topic
     /
D---E---F---G master
</code></pre><p>从这里开始，以下任意一个命令的结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase master</span><br><span class="line">git rebase master topic</span><br></pre></td></tr></table></figure>
<p>其结构将会变为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">              A&#39;--B&#39;--C&#39; topic</span><br><span class="line">             &#x2F;</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>后一种形式只是简单的<code>git checkout topic</code>后面跟着<code>git rebase master</code>。当<code>rebase</code>退出时，主题将仍然是签出的分支。</p>
</li>
</ol>
<ol start="2">
<li><p>如果是下面的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     G---H---I dev1</span><br><span class="line">    &#x2F;          </span><br><span class="line">      A---B---C dev</span><br><span class="line">     &#x2F;</span><br><span class="line">D---E---A&#39;---F master</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   那么执行<code>git rebase --onto master dev dev1</code></p>
<p>   将会得到结果</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     A---B---C dev         </span><br><span class="line">    &#x2F;          </span><br><span class="line">D---E---A&#39;---F master</span><br><span class="line">			\</span><br><span class="line">			 G---H---I dev1</span><br></pre></td></tr></table></figure>
<p>   此时dev1线上就包括master的最新代码。</p>
<ol start="3">
<li><p>去除分支中的一些提交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A---B---C---D---E dev1</span><br></pre></td></tr></table></figure>
<p>执行以下命令后，B和C将会从dev1分支的提交记录中去除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --onto dev1~4 dev1~1 dev1</span><br></pre></td></tr></table></figure>
<p>其结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A---D---E			dev1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果发生冲突，git rebase会在第一个有问题的提交时停止，并在树中留下冲突标记。您可以使用git diff来定位标记(&lt;&lt;&lt;&lt;&lt;&lt;)并进行编辑以解决冲突。</p>
<h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…</span><br><span class="line">git revert (--<span class="built_in">continue</span> | --skip | --abort | --quit)</span><br></pre></td></tr></table></figure>
<p>给定一个或多个现有提交，恢复相关补丁引入的更改，并记录一些记录这些更改的新提交。这需要您的工作树是干净的(没有来自HEAD提交的修改)。</p>
<p><strong>注意：</strong>git revert用来记录一些新的提交，<strong>以逆转之前的一些提交的效果</strong>(通常是一个错误的提交)。如果希望丢弃工作目录中所有未提交的更改，应该看到<code>git-reset</code>，特别是<code>--hard</code>选项。如果您想提取在另一个提交中的特定文件，您应该看到<code>git-restore</code>，特别是<code>--source</code>选项。要注意这些选项，因为它们都会丢弃工作目录中未提交的更改。</p>
<h3 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>&lt;commit&gt;…</code>：要逆转的提交。</li>
<li><code>-e; --edit</code>：有了这个选项，git revert将允许你在提交恢复之前编辑提交消息。默认是从命令行读取。</li>
<li><code>-m parent-number;--mainline parent-number</code>：通常您不能恢复合并，因为您不知道合并的哪一边应该被视为主线。此选项指定主线的父节点号(从1开始)，并允许恢复到反转相对于指定父节点的更改。</li>
<li><code>-n; --no-commit</code>：通常，该命令会自动创建一些提交，并使用提交日志消息来说明哪些提交被还原。此标志应用将命名提交恢复到工作树和索引所需的更改，但不进行提交。此外，当使用这个选项时，您的索引不必与HEAD提交匹配。恢复是针对索引的开始状态进行的。</li>
</ul>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><ul>
<li><code>git revert HEAD~3</code>：恢复HEAD中第四次提交所指定的更改，并使用恢复的更改创建一个新提交。</li>
<li><code>git revert -n master~5..master~2</code>：将主系统中最后一次提交(包括)的第五次提交的修改恢复到主系统中最后一次提交(包括)的第三次提交，但不要使用恢复后的修改创建任何提交。恢复操作只修改工作树和索引。</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>补丁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术-I-4-对象与类</title>
    <url>/2022/01/08/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-4-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是构建对象的模板或蓝图。由类构造(construct)对象的过程被称为创建类的实例(instance)。</p>
<p>封装是指不能让类中的方法直接访问其他类的实例字段。程序只能通过对象得到方法与对象数据进行交互。（这些实例字段就是这个对象的当前状态）</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象的3个主要特征</p>
<ol>
<li>对象的行为（behavior）：有哪些方法。</li>
<li>对象的状态（state）：有哪些实例属性。</li>
<li>对象的标识（identity）：对象的标识（内存中的地址表示）。</li>
</ol>
<h2 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h2><ol>
<li>依赖(“uses-a”)：A类中调用了B类或其实例。</li>
<li>聚合(“has-a”)：A类中含有B类实例<strong>属性</strong>。</li>
<li>继承(“is-a”)：A类继承自B类。</li>
</ol>
<p>其UML表示如下：</p>
<p><img src="\images\java核心技术\表达类关系的UML符号.jpg" alt="表达类关系的UML符号"></p>
<h2 id="final实例字段"><a href="#final实例字段" class="headerlink" title="final实例字段"></a>final实例字段</h2><p>注意final定义的实例字段必须在定义时、或者构造器对象时进行初始化。</p>
<h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>一个方法的方法名和参数类型被称为方法的签名（signature）。即区分不同的方法是靠这两个点。</p>
<p>重载是指多个方法拥有相同的名字，不同的参数类型。在调用时传入特定的参数，由编译器选出对应的方法，如果不存在特定方法，则报错。这个过程被称为重载解析（overloading resolution）。</p>
<p>Note：</p>
<p>返回类型和修饰符都不是方法签名的一部分，因此不能存在两个名字相同、参数类型相同却有不同返回类型或不同修饰符的方法。（在Java语言层面不行，但是在虚拟机层面，是可以存在的，在类型擦除时经常会出现这样的情况）</p>
<h2 id="数据字段初始化"><a href="#数据字段初始化" class="headerlink" title="数据字段初始化"></a>数据字段初始化</h2><ol>
<li>在构造器中设置值。</li>
<li>在声明中赋值。</li>
<li>初始化块。</li>
</ol>
<p>在一个类的声明中，可以包含任意多个代码块。只要构造这个类，这些块就会被执行。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Object initialization block</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方式不是必须的，也不常见。通常会直接将初始化代码放置到构造器中。</p>
<h2 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h2><p>一个类可以始终所属包中的所有类，以及其他包中的公共类（public class）。</p>
<p>我们可以采用两种方式来访问另一个包中的公共类。</p>
<ol>
<li>使用完全限定名。</li>
<li>使用import语句导入后直接使用。</li>
</ol>
<p>Note：</p>
<ol>
<li><p>只能使用星号（*）导入一个包，而不能使用<code>import java.*</code>或者<code>import .*.*</code>导入以Java为前缀的所有包。</p>
</li>
<li><p>当导入的两个包含有相同的方法名字，如果还是使用简写名，则会报错；此时需要使用全限定名。</p>
</li>
</ol>
<h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>在import后加上static关键字则可以导入静态方法和静态字段，而不只是类。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line">out.println(<span class="string">"hello world!"</span>);</span><br></pre></td></tr></table></figure>
<p>还可以导入特定的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out</span><br><span class="line">    </span><br><span class="line">out.println(<span class="string">"hello world!"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h2><ol>
<li>一定要保证数据的私有。</li>
<li>一定要对数据进行初始化。</li>
<li>不要在类中使用过多的基本类型。</li>
<li>不是所有的字段都需要单独的字段访问器和字段更改器。</li>
<li>分解有过多职责的类。</li>
<li>类名和方法名要能够体现它们的职责。优先使用不可变的类：即尽量使用那些调用方法后返回副本的类，而不是修改其内部属性的类。主要在于多线程同时试图更新一个对象，就会发生并发修改。其结果就是不可预料的。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>对象与类</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-II-2-输入与输出</title>
    <url>/2022/02/15/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="输入与输出流"><a href="#输入与输出流" class="headerlink" title="输入与输出流"></a>输入与输出流</h1><p>在Java API中，输入流是一个可以读入字节的对象；输出流是一个可以写如字节的对象。这些字节的来源和目的地可以是文件、网络甚至是内存块。</p>
<p>抽象类<code>InputStream</code>和<code>OutputStream</code>构成了输入/输出类层次结构的基础。（注意与上一节的流操作完全不同）</p>
<h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a><code>InputStream</code></h2><p><code>InputStream</code>是输入流，即通过文件等获取一个<code>InputStream</code>的子类。然后通过其API获得输入流中的内容。其主要API如下：</p>
<ol>
<li><p><code>abstract int read()</code>：从数组中读取一个字节，并返回该字节。结尾时返回-1。</p>
</li>
<li><p><code>int read(byte[] b)</code>：读入一个字节数组，并返回实际读入的字节数，结尾时返回-1。其最多读入<code>b.length</code>个字节。</p>
</li>
<li><p><code>int read(byte[] b, int off, int len)</code>：读取<code>len</code>个字节存入b数组，而且从b数组的第off个位置开始写入。</p>
</li>
<li><p><code>byte[] readNBytes(int len)</code>：与2相同，不过该API只有在读取到<code>len</code>个字节、流结束或发生错误时才会返回。否则会一直阻塞。</p>
</li>
<li><p><code>int readNBytes(byte[] b, int off, int len)</code>：3+4.</p>
</li>
<li><code>byte[] readAllBytes()</code>：读取流中所有的字节到一个数组。本质是调用<code>return readNBytes(Integer.MAX_VALUE);</code></li>
<li><code>long transferTo(OutputStream out)</code>：将当前输入流中的所有字节传送到给定的输出流，返回传递的字节数。这两个流都不应该处于关闭状态。</li>
<li><code>long skip(long n)</code>：在输入流中跳过n个字节，返回实际跳过的字节数（遇到输入流的结尾，则可能小于n）。</li>
<li><code>int available()</code>：返回在不阻塞的情况下可获取的字节数。</li>
<li><code>void close()</code>：关闭这个输入流。</li>
<li><code>void mark(int readlimit)</code>：在输入流的当前位置打一个标记（并非所有的流都支持整个标记）。如果从输入流中已经读入的字节多余readlimit个，则这个流允许忽略整个标记。</li>
<li><code>void reset()</code>：返回到最后一个标记，随后对read的调用将重新读入这些字节。如果当前没有任何标记，则这个流不被重置。</li>
<li><code>void markSupported()</code>：检测当前流是否支持打标记。</li>
</ol>
<h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a><code>OutputStream</code></h2><ol>
<li><code>abstract void write(int n)</code>：写出一个字节的数据。</li>
<li><code>void write(byte[] b)</code>：将b中的字节写入到输出流中。</li>
<li><code>void  write(byte[] b, int off, int len)</code>：与2相同，不过是从b的off位置开始，写出len个字节。</li>
<li><code>void close()</code>：冲刷并关闭输出流。</li>
<li><code>void flush()</code>：冲刷输出流，即将所有缓冲的数据发送到目的地。</li>
</ol>
<h2 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader/Writer"></a><code>Reader/Writer</code></h2><p>Java Stream相关类是用来处理字节流的,但不适合用来字符流.因为一个字节是8bit,而一个字符是16bit.字符串是由字符组成,字符串类型天然处理的是字符而不是字节.更重要的是,字节流无法知道字符集及其字符编码.Java中可以用Reader/Writer相关类来处理字符.</p>
<p>而<code>Reader/Writer</code>类的基本方法与<code>InputStream/OutputStream</code>基本一致。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wirite</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>read</code>方法将返回一个<code>Unicode</code>码元（一个在0-65535之间的整数），或者在碰到文件结尾的时返回-1。<code>write</code>方法在被调用时，需要传递一个<code>Unicode</code>码元。</p>
<h2 id="所有输入输出流及其关系"><a href="#所有输入输出流及其关系" class="headerlink" title="所有输入输出流及其关系"></a>所有输入输出流及其关系</h2><p><img src="\images\java核心技术\输入流与输出流的层次结构.jpg" alt="输入流与输出流的层次结构"></p>
<p><img src="\images\java核心技术\Reader和Writer的层次结构.jpg" alt="Reader和Writer的层次结构"></p>
<p><img src="\images\java核心技术\Java输入输出流.jpg" alt="Java输入输出流"></p>
<h2 id="组合输入-输出流过滤器"><a href="#组合输入-输出流过滤器" class="headerlink" title="组合输入/输出流过滤器"></a>组合输入/输出流过滤器</h2><p>在Java中，不同的输入输出类有自己的职能。</p>
<p>例如，</p>
<ol>
<li><p><code>FileInputStream</code>和<code>FileOutputStream</code>可以提供一个磁盘文件上的输入输出流，并且只需要想起构造器提供文件名或晚间的完整路径名。如：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fin = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.dat"</span>);</span><br></pre></td></tr></table></figure>
<p> 但是两个类与抽象类<code>InputStream/OutputStream</code>一样，这些类只支持在字节级别上的读写。即只能从fin对象读入字节或字节数组：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>) fin.read();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DataInputStream</code>和<code>DataoutputStream</code>能够读入数字，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataInputStream din = ...;</span><br><span class="line"><span class="keyword">double</span> x = din.readDouble();</span><br></pre></td></tr></table></figure>
<p>但是<code>DataInputStream</code>和<code>DataoutputStream</code>却没有任何能够读取文件的方法。</p>
</li>
</ol>
<p>这正是Java的流的设计机制，即一个流只负责对应的单一功能。需要复合功能时（如：从文件中读取数字），则将负责不同职能的流组合起来已到达效果。</p>
<p>例如：从文件中读取一个数字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.dat"</span>);</span><br><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(fin);</span><br><span class="line"><span class="keyword">double</span> x = din.readDouble();</span><br></pre></td></tr></table></figure>
<p>这样的流可以多层嵌套来实现更多的效果。</p>
<p>例如：输入流在默认情况下是不被缓冲区缓存的，也就是说，每个对read的调用都会请求操作系统再分发一个字节。而<code>BufferedInputStream</code>可以为输入流提供一个缓冲区，则读取会更加高效。则代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">	<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    	<span class="keyword">new</span> FileInputStream(<span class="string">"employee.data"</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意，我们把<code>DataInputStream</code>置于构造器链的最后，这是因为我们希望使用<code>DataInputStream</code>的方法，并且希望它们能够使用带缓冲区机制的<code>read</code>方法。</p>
<p>当我们需要调用中间输入流的方法时，我们可以在传递参数时对外部引用进行赋值。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedInputStream bbin = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">var</span> din = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">    bbin = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">"data"</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>一般来说输入输出流的顺序并不是特别重要，主要是最外层和最内层的输入输出流，因为需要调用这两个的API和构造器</strong></p>
<h1 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h1><p>在保存数据时，可以选择二进制格式或文本格式。</p>
<p>如，整数1234存储为二进制时，会被写为由字节<code>00 00 04 D2</code>构成的格式（十六进制表示法）。而被存储为文本格式时，则会被写入字符串”1234“。</p>
<p>二进制格式的I/O高速且高效，但是并不适合人类阅读。</p>
<h2 id="写出文本输出"><a href="#写出文本输出" class="headerlink" title="写出文本输出"></a>写出文本输出</h2><p>对于文本的输出，可以使用<code>PrintWriter</code>。这个类拥有以文本格式打印字符串和数字的方法。</p>
<p>为了输出到打印写出器，需要使用与<code>System.out</code>时相同的<code>print</code>、<code>println</code>和<code>printf</code>方法。可以用其来打印各种数据结构。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrinterWriter(<span class="string">"employee.txt"</span>, StandardCharsets.UTF_8);</span><br><span class="line">String name = <span class="string">"Harry Hacker"</span>;</span><br><span class="line"><span class="keyword">int</span> salary = <span class="number">75000</span>;</span><br><span class="line">out.print(name);</span><br><span class="line">out.print(<span class="string">" "</span>);</span><br><span class="line">out.print(salary)</span><br></pre></td></tr></table></figure>
<p>其将会把字符<code>Harry Hacker 75000.0</code>输出到写出器out，之后这些字符将会被转换为字节并最终写入<code>employee.txt</code></p>
<p>与<code>System.out</code>一样，<code>println</code>在行中添加了对目标系统的来说恰当行结束符（Windows系统是<code>&quot;\r\n&quot;</code>，UNIX系统是<code>&quot;\n&quot;</code>）。</p>
<p><code>PrinterWriter</code>第二个参数是确定是否为自动冲刷模式，如果为true，则打开自动冲刷模式。那么只要<code>println</code>被调用，缓冲区中的所有字符都会被发送到目的地。默认是<code>false</code>。</p>
<h2 id="读取文本输入"><a href="#读取文本输入" class="headerlink" title="读取文本输入"></a>读取文本输入</h2><h3 id="通过Files类"><a href="#通过Files类" class="headerlink" title="通过Files类"></a>通过<code>Files</code>类</h3><p>一般现在使用Java7引入的<code>Files</code>类来读取文本内容。</p>
<p>例如：</p>
<ol>
<li><p>读取小文件直接到String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Path.of(<span class="string">"./a.txt"</span>);</span><br><span class="line">Charset charset = StandardCharsets.UTF_8;</span><br><span class="line">String content = Files.readString(path, charset);</span><br></pre></td></tr></table></figure>
</li>
<li><p>按行读取文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; lines = Files.readAllLines(path, charset);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果文件过大，还可以处理为<code>Stream对</code>象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(path, charset))&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通过Scanner来实现"><a href="#通过Scanner来实现" class="headerlink" title="通过Scanner来实现"></a>通过<code>Scanner</code>来实现</h3><p>也可以通过<code>Scanner</code>类来读取文件，虽然现在主要通过<code>new Scanner(System.in)</code>来读取控制台输入。</p>
<p><code>Scanner</code>类有多种重载：</p>
<ul>
<li><code>private Scanner(Readable source, Pattern pattern)</code></li>
<li><code>public Scanner(Readable source)</code></li>
<li><code>public Scanner(InputStream source)</code></li>
<li><code>public Scanner(InputStream source, String charsetName)</code></li>
<li><code>public Scanner(InputStream source, Charset charset)</code></li>
<li><code>public Scanner(File source)</code></li>
<li><code>public Scanner(File source, String charsetName)</code></li>
<li><code>public Scanner(File source, Charset charset)</code></li>
<li><code>private Scanner(File source, CharsetDecoder dec)</code></li>
<li><code>public Scanner(Path source)</code></li>
<li><code>public Scanner(Path source, String charsetName)</code></li>
<li><code>public Scanner(Path source, Charset charset)</code></li>
<li><code>public Scanner(String source)</code></li>
<li><code>public Scanner(ReadableByteChannel source)</code></li>
<li><code>public Scanner(ReadableByteChannel source, String charsetName)</code></li>
<li><code>public Scanner(ReadableByteChannel source, Charset charset)</code></li>
</ul>
<p>可以看出，其可以从实现了<code>Readable</code>接口的对象、<code>InputStream</code>、<code>File</code>、<code>Path</code>、<code>String</code>或者实现了<code>ReadableByteChannel</code>接口的对象来读取文本。</p>
<p>下面演示从<code>Path</code>和<code>File</code>中读取</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Path.of(<span class="string">"a.txt"</span>);</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">Charset charset = StandardCharsets.UTF_8;</span><br><span class="line">ArrayList&lt;String&gt; conents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Scanner pathScanner = <span class="keyword">new</span> Scanner(path, charset);		<span class="comment">//从Path读取</span></span><br><span class="line">    Scanner pathScanner = <span class="keyword">new</span> Scanner(file, charset);		<span class="comment">//从File读取</span></span><br><span class="line">    <span class="keyword">while</span>(pathScanner.hasNextLine()) &#123;</span><br><span class="line">        String aString = pathScanner.nextLine();</span><br><span class="line">        conents.add(aString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过BufferedReader"><a href="#通过BufferedReader" class="headerlink" title="通过BufferedReader"></a>通过<code>BufferedReader</code></h3><p>在早期的Java版本中，处理文本输入的唯一方式就是通过<code>BufferedReader</code>类。它的<code>readLine</code>方法方法将产生一行文本，在没有更多输出时，返回null。</p>
<p>例如代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream inputStream = ...;</span><br><span class="line"><span class="keyword">try</span>(<span class="keyword">var</span> in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputstream, charset)))&#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span>((line = in.readLine() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h1><h2 id="DataInput和DataOutput接口"><a href="#DataInput和DataOutput接口" class="headerlink" title="DataInput和DataOutput接口"></a><code>DataInput</code>和<code>DataOutput</code>接口</h2><p><code>DataOutput</code>接口定义了下面用于以二进制格式写数组、字符、Boolean值和字符串的方法：</p>
<ul>
<li><code>writeChars</code></li>
<li><code>writeByte</code></li>
<li><code>writeInt</code></li>
<li><code>writeShort</code></li>
<li><code>writeLong</code></li>
<li><code>writeFloat</code></li>
<li><code>writeDouble</code></li>
<li><code>writeChar</code></li>
<li><code>writeBoolean</code></li>
<li><code>writeUTF</code></li>
</ul>
<p>如，<code>writeInt</code>总是将一个整数写出为4字节的二进制数量值，而不管它有多少位。<code>writeDouble</code>总是将一个double值写出为8字节的二进制值（取决与处理器类型）。</p>
<p>这样产生的结果并非人可阅读的，但是对于给定类型的每个值，使用的空间都是相同的，而且将其都会也比解析文本要更快。</p>
<p><code>writeUTF</code>方法使用修订版的8位Unicode转换格式写出字符串。这中方式与直接使用标准的<code>UTF-8</code>编码不一样，其中，Unicode码元序列首先用<code>UTF-8</code>表示，其结果之后使用<code>UTF-8</code>规则进行编码。修订后的编码方式对于编码大于<code>OXFFFF</code>的字符的处理有所不同，这是为了向后兼容在Unicode还没有超过16位时构建的虚拟机。<strong>这种编码应该在只用于Java虚拟机的字符串时使用。</strong></p>
<p>为了读回数据，可以使用在<code>DataInput</code>接口中定义的下列方法：</p>
<ul>
<li><code>readInt</code></li>
<li><code>readShort</code></li>
<li><code>readLong</code></li>
<li><code>readFloat</code></li>
<li><code>readDouble</code></li>
<li><code>readChar</code></li>
<li><code>readBoolean</code></li>
<li><code>readUTF</code></li>
</ul>
<p>具体来说，可以使用实现了<code>DataInput</code>和<code>DataOutput</code>接口的<code>DataInputStream</code>和<code>DataOutputStream</code>类。</p>
<p>其分别继承了<code>FilterInputStream</code>和<code>FilterOutputStream</code>类。</p>
<p>所以也分别实现了其中的<code>read</code>和<code>write</code>方法。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Path path = Path.of(<span class="string">"e:\\a.data"</span>);</span><br><span class="line">    Files.createFile(path);</span><br><span class="line">    FileOutputStream fStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"e:\\a.data"</span>);</span><br><span class="line">    DataOutputStream oStream = <span class="keyword">new</span> DataOutputStream(fStream);</span><br><span class="line">    oStream.writeChars(<span class="string">"ssss"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随机访问文件"><a href="#随机访问文件" class="headerlink" title="随机访问文件"></a>随机访问文件</h2><p><code>RandomAccessFile</code>类可以在文件中的任何位置<strong>读取或写入</strong>文件。磁盘文件都是随机访问的，但网阔套接字的输入/输出流却不是。</p>
<p>可以直接通过构造器来获得一个文件的<code>RandomAccessFile</code>引用。而第二个参数为模式。具体如下：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>只能读文件，写时会抛出<code>IOException</code>。</td>
</tr>
<tr>
<td>rw</td>
<td>可读可写，如果不存在将会尝试创建。</td>
</tr>
<tr>
<td>rws</td>
<td>可读可写，并且每次更新文件时都将<strong>内容和元信息同步</strong>更新到文件中。</td>
</tr>
<tr>
<td>rwd</td>
<td>可读可写，并且每次更新文件时都将内容<strong>同步</strong>更新到文件中。</td>
</tr>
</tbody>
</table>
<p>随机访问我呢见有一个表示下一个将被读入或写入的字节所处位置的文件指针，</p>
<p><code>seek</code>方法可以用来将这个文件指针设置到文件中的任意字节位置。seek接受一个long整型数。</p>
<p><code>getFilePointer</code>方法将返回文件指针的当前位置。</p>
<p><code>RandomAccessFile</code>类同时实现了<code>DataInput</code>和<code>DataOutput</code>接口。因此可以调用之前提到的<code>readInt/writeInt</code>或<code>readChar/writeChar</code>。</p>
<p>例如，我们要存储一个对象为二进制，我们可以分别确定对象的每个成员变量字节数进而确定每个对象的字节数。</p>
<p>整数和浮点数在二进制格式中都具有固定的尺寸。对于字符串，可以固定长度，不够的话填0来解决。对于含有以下成员的对象：</p>
<ul>
<li>1String-40字符, 80个字节。用于名词。</li>
<li>1double=8字节。用于薪水。</li>
<li>3 int=12字节。用于日期。</li>
</ul>
<p>则整体包含100个字节。</p>
<p>则插入一个对象为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> RECORD_SIZE = <span class="number">100</span>;</span><br><span class="line">in.seek((n-<span class="number">1</span>) * RECORD_SIZE);</span><br><span class="line"><span class="keyword">var</span> e = <span class="keyword">new</span> Employee();</span><br><span class="line">in.write(FixString(e.getName()));		<span class="comment">//FixString为填充字符串固定长度的函数</span></span><br><span class="line">in.write(e.getSalary());</span><br><span class="line">in.write(e.getYear());</span><br><span class="line">in.write(e.getMonth());</span><br><span class="line">in.write(e.getDay());					<span class="comment">//下面操作封装为一个函数比较好</span></span><br></pre></td></tr></table></figure>
<h2 id="ZIP文档"><a href="#ZIP文档" class="headerlink" title="ZIP文档"></a>ZIP文档</h2><p>ZIP文档（通常）以压缩格式存储了一个或多个文件，每个ZIP文件都有一个头。包含注入每个文件名字和所使用的压缩方法等信息。在Java中，可以使用<code>ZipInputStream</code>来读入ZIP文档。</p>
<h2 id="读取ZIP文档"><a href="#读取ZIP文档" class="headerlink" title="读取ZIP文档"></a>读取ZIP文档</h2><p>而<code>getNextEntry</code>方法就可以返回一个描述这些项的<code>ZipEntry</code>对象。在获得一个<code>ZipEntry</code>对象后，需要调用<code>closeEntry</code>来关闭当前的<code>ZipEntry</code>对象。以便访问下一个<code>ZipEntry</code>对象。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> zin = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(zipname));</span><br><span class="line">ZipEntry entry;</span><br><span class="line"><span class="keyword">while</span>((entry = zin.getNextEntry()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] contents = entry.getExtra();		<span class="comment">//read the content of zin</span></span><br><span class="line">    zin.closeEntry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="写入ZIP文档"><a href="#写入ZIP文档" class="headerlink" title="写入ZIP文档"></a>写入ZIP文档</h2><p>在写如ZIP文档时，大致步骤如下：</p>
<ol>
<li><p>获得一个<code>ZipOutputStream</code>。其构造器接受一个<code>OutputStream</code>对象。可以用<code>FileOutputStream</code>对象。</p>
</li>
<li><p>新建<code>ZipEntry</code>对象。构造器为ZIP项的名字，其他信息将自动设置，也可以自己手动调用<code>setXXX</code>方法覆盖。</p>
</li>
<li>调用<code>ZipOutoutStream</code>的<code>putNextEntry</code>方法来写出新文件，并将文件数据发送到ZIP输出流中。</li>
<li>完成后调用<code>closeEntry</code>。</li>
</ol>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.zip"</span>);</span><br><span class="line"><span class="keyword">var</span> zout = <span class="keyword">new</span> ZipOutputStream(fout);</span><br><span class="line"><span class="keyword">var</span> ze = <span class="keyword">new</span> ZipEntry(filename);</span><br><span class="line">zout.putNextEntry(ze);</span><br><span class="line">zout.closeEntry();</span><br><span class="line">zout.close();</span><br></pre></td></tr></table></figure>
<h2 id="ZipFile"><a href="#ZipFile" class="headerlink" title="ZipFile"></a><code>ZipFile</code></h2><p>另外还有一个<code>ZipFile</code>，用于创建Zip文件。其有以下ZPI：</p>
<ul>
<li><code>ZipFile(String name, Charset charset)</code></li>
<li><code>ZipFile(File file, Charset charset)</code>：创建一个<code>ZipFile</code>，用于从给定的字符串或File对象读入文件。其中编码用于文件的名字和注释。</li>
<li><code>Enumeration entries()</code>：返回一个<code>Enumeration</code>对象，他枚举描述了这个<code>ZipFile</code>中各个项中的<code>ZipEntry</code>对象。</li>
<li><code>ZipEntry getEntry(String name)</code>：返回给定名字所对应的项。不存在的时候返回null。</li>
<li><code>InputStream getInputStream(ZipEntry ze)</code>：返回用于给定项的<code>InputStream</code>。</li>
<li><code>String getName()</code>：返回这个ZIP文件的路径。</li>
</ul>
<h1 id="对象输入-输出流与序列化"><a href="#对象输入-输出流与序列化" class="headerlink" title="对象输入/输出流与序列化"></a>对象输入/输出流与序列化</h1><p>上面简单演示了如何将一个对象存储到文件系统，但是其具有很多缺点，例如多态的问题。而Java语言支持一种称为对象序列化（<code>object serialization</code>）的非常通用的机制，它可以将任何对象写出到输出流中，并在之后将其读回。</p>
<h2 id="保存和加载序列化对象"><a href="#保存和加载序列化对象" class="headerlink" title="保存和加载序列化对象"></a>保存和加载序列化对象</h2><h3 id="保存序列化对象"><a href="#保存序列化对象" class="headerlink" title="保存序列化对象"></a>保存序列化对象</h3><p>步骤如下：</p>
<ul>
<li>获得一个<code>ObjectOutputStream</code>对象<code>out</code>和目标对象<code>obj</code>。</li>
<li>调用<code>out.write(obj)</code>来写入对象。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"employee.dat"</span>));</span><br><span class="line"><span class="keyword">var</span> harry = <span class="keyword">new</span> Employee(<span class="string">"Harry"</span>, <span class="number">50000</span>, <span class="number">1989</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> boss = <span class="keyword">new</span> Manager(<span class="string">"Tom"</span>, <span class="number">100000</span>, <span class="number">1900</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">out.writeObject(harry);</span><br><span class="line">out.writeObject(boss);</span><br></pre></td></tr></table></figure>
<h3 id="加载序列化对象"><a href="#加载序列化对象" class="headerlink" title="加载序列化对象"></a>加载序列化对象</h3><p>步骤如下：</p>
<ul>
<li>获得一个<code>ObjectInputStream</code>对象<code>in</code>。</li>
<li>调用<code>in.readObject()</code>按照写入的顺序来获取对象。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"employee.dat"</span>));</span><br><span class="line"><span class="keyword">var</span> harry = (Employee)in.readObject();</span><br><span class="line"><span class="keyword">var</span> boss = (Manager)in.readObject();</span><br></pre></td></tr></table></figure>
<p><strong>Note：这里只能按照写入时的顺序来读取。</strong></p>
<h2 id="前提和原理"><a href="#前提和原理" class="headerlink" title="前提和原理"></a>前提和原理</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>要进行序列化的对象必须要实现了<code>Serializable</code>接口，该接口没有任何方法。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>之所以叫序列化，是因为每个序列化的对象都用一个序列号（<code>serial number</code>）来保存的。所以对于嵌套的对象，其算法如下：</p>
<ul>
<li>对遇到的每个对象引用都关联一个序列号。</li>
<li>对于每个对象，当第一次遇到时，保存期对象数据到输出流中。</li>
<li>如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”。</li>
</ul>
<p>而读回对象时，整个过程是反过来的。</p>
<ul>
<li>对于对象输入流中的对象，第一次遇到其序列号时，构建它，并使用流中的数据来初始化它，然后记录这个序列号和新对象之间的关联。</li>
<li>当遇到“与之前保存过的序列号为x的对象相同”这一标记时，获取这个序列号相关联的对象引用。</li>
</ul>
<h2 id="修改默认的序列化机制"><a href="#修改默认的序列化机制" class="headerlink" title="修改默认的序列化机制"></a>修改默认的序列化机制</h2><p>序列化有其默认的逻辑，但实际上有时候我们需要自定义某个域的存储逻辑。这个时候就可以修改其默认的序列化机制。  </p>
<h3 id="跳过数据域"><a href="#跳过数据域" class="headerlink" title="跳过数据域"></a>跳过数据域</h3><p>使用<code>transient</code>修饰符可以跳过指定数据域的序列化。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1580502463316993420L</span>;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> ProcessHandle handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///...</span></span><br></pre></td></tr></table></figure>
<p>此时<code>handle</code>将不会被序列化，（一般进程序列化之后，下一次读取就并不具有时效性了）。</p>
<h3 id="自定义内部序列化方法"><a href="#自定义内部序列化方法" class="headerlink" title="自定义内部序列化方法"></a>自定义内部序列化方法</h3><p>通过重写目标对象的<code>writeObject</code>和<code>readObject</code>方法可以实现自定义序列化对象。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1580502463316993420L</span>;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String position; <span class="comment">//x-y</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> ProcessHandle handle;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		out.writeInt(id);</span><br><span class="line">		out.writeInt(Integer.parseInt(position.split(<span class="string">"-"</span>)[<span class="number">0</span>]));</span><br><span class="line">		out.writeInt(Integer.parseInt(position.split(<span class="string">"-"</span>)[<span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		id = in.readInt();</span><br><span class="line">		position = String.valueOf(in.readInt()) + <span class="string">"-"</span> + String.valueOf(in.readInt());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>值得注意的是：</strong></p>
<ol>
<li>字符串的长度仍然需要我们自定义（数据库的中<code>varchar</code>需要定义长度可能也是这个原因吧），所以这里只展示了存储<code>Integer</code>，然后将其转化格式后存储到数据域中。</li>
<li>一旦对象中出现这两个方法，那么序列化时只会调用这两个方法，默认方法将不会起作用。</li>
<li>这两个方法是私有的</li>
<li>这两个方法仅仅为对象自己的数据与加载和保存对象，而不必去关系父类和其他任何信息。</li>
</ol>
<h3 id="自定义外部序列化方法"><a href="#自定义外部序列化方法" class="headerlink" title="自定义外部序列化方法"></a>自定义外部序列化方法</h3><p>对于整体的对象的数据域（包括父类和其他）恢复和加载，则需要实现<code>Externalizable</code>接口。其定义了两个方法<code>readExternal</code>和<code>writeExternal</code>方法，目标对象必须重写这两个方法。即可以在内部为父类和其他的数据域进行赋值。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput s)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    name = s.readUTF();</span><br><span class="line">    salary = s. readDouble();</span><br><span class="line">    hireDay = LocalDate.ofEpochDay(s.readLont());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput s)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    s.writeUTF(name);</span><br><span class="line">    s.writeDouble(salary);</span><br><span class="line">    s.writeLong(hireDay.toEpochDay());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>这两个方法是<code>public</code>的。因此也可以从外部访问。</li>
<li><code>readExternal</code>还潜在地允许修改现有对象的状态。</li>
</ul>
<h2 id="序列化单例和类型安全的枚举"><a href="#序列化单例和类型安全的枚举" class="headerlink" title="序列化单例和类型安全的枚举"></a>序列化单例和类型安全的枚举</h2><p>在序列化和反序列化时，如果目标对象是唯一的，那么必须小心，因为在序列化和反序列化后，对象的地址往往发生了变化，那么在Java虚拟机中，两者就不相等了。这种情况往往发生在自定义的枚举类型</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orientation</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Orientation HORIZONTAL = <span class="keyword">new</span> Orientation(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Orientation VERTICAL = <span class="keyword">new</span> Orientation(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Orientation</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意构造器是私有的，所以不能构造出<code>HORIZONTAL</code>和<code>VERTICAL</code>之外的对象。</p>
<p>那么此时，如果对<code>HORIZONTAL</code>，<code>VERTICAL</code>进行序列化和反序列化之后。得到新的<code>NEW_HORIZONTAL</code>,<code>NEW_VERTICAL</code>.</p>
<p>则极大概率<code>HORIZONTAL != NEW_HORIZONTAL</code>，<code>VERTICAL != NEW_VERTICAL</code>。</p>
<p>因为经过序列化和反序列化之后，得到的对象就是完全新的两个对象，与之前的对象都不同。</p>
<h2 id="为克隆使用序列化"><a href="#为克隆使用序列化" class="headerlink" title="为克隆使用序列化"></a>为克隆使用序列化</h2><p>序列化往往可以用在深拷贝中，如JS中常用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> new_a = <span class="built_in">JSON</span>.pasrse(<span class="built_in">JSON</span>.stringify(a));</span><br></pre></td></tr></table></figure>
<p>而在Java中，也可以这样使用。原理也参见上一节的为什么不能对单例进行序列化，因为其本质就是另外的对象了，所以肯定就是深拷贝了。</p>
<h1 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h1><h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p>Path在JDK7引入，其表示一个目录名序列，其后还可以跟着一个文件名。</p>
<p>Path对象使用<code>Path.of()</code>来创建。其有两个重载：</p>
<ol>
<li><code>public static Path of(String first, String... more)</code></li>
<li><code>public static Path of(URI uri)</code></li>
</ol>
<p>一般使用第一个方法，而其第一个参数是根目录。后面接层级的目录名字。实际也可以直接赋值目录到第一个参数。而分开的好处是Java会自动选择对应系统的分隔符来组成目录。（如UNIX文件系统时<code>/</code>，而Windows时<code>\</code>）。</p>
<h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>可以通过Path对象提供的方法来获取一个相对目录。即在<code>Path.of</code>的第一个参数使用<code>&quot;path&quot;</code>而不是<code>&quot;\path&quot;</code>的方式。</p>
<h3 id="Path-resolve-basePath-dir"><a href="#Path-resolve-basePath-dir" class="headerlink" title="Path.resolve(basePath, dir)"></a><code>Path.resolve(basePath, dir)</code></h3><p>使用<code>Path.resolve(basePath, dir)</code>可以查找<code>basePath</code>中的dir目录，并返回该目录的<code>Path</code>对象。</p>
<h3 id="path-relative-q"><a href="#path-relative-q" class="headerlink" title="path.relative(q)"></a><code>path.relative(q)</code></h3><p><code>path.relative(q)</code>可以返回相对于q相对于path的相对路劲。如<code>path = /home/harry</code>，而<code>q = /home/fred/input.txt</code>。则会返回<code>../fred/input</code>的<code>Path</code>路径。</p>
<h3 id="Path-resolveSibling-basePath-siblingDir"><a href="#Path-resolveSibling-basePath-siblingDir" class="headerlink" title="Path.resolveSibling(basePath, siblingDir)"></a><code>Path.resolveSibling(basePath, siblingDir)</code></h3><p><code>Path.resolveSibling(basePath, siblingDir)</code>可以获取与<code>basePath</code>同级的<code>siblingDir</code>目录的<code>Path</code>对象。</p>
<h3 id="path-normaliza"><a href="#path-normaliza" class="headerlink" title="path.normaliza()"></a><code>path.normaliza()</code></h3><p><code>path.normaliza()</code>将移除多余的<code>.</code>和<code>..</code>部件。如，<code>/home/harry/../fred/./input.txt</code>规范化后将返回<code>home/fred/input.txt</code>。</p>
<h3 id="path-toAbsolutePath"><a href="#path-toAbsolutePath" class="headerlink" title="path.toAbsolutePath()"></a><code>path.toAbsolutePath()</code></h3><p><code>path.toAbsolutePath()</code>方法将返回路径的绝对地址，该绝对地址从根部件开始。如<code>/home/fred/input.txt</code>或<code>c:\User\fred\input.txt</code>。</p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>JDK7引入的Files类可以使读写普通文件更加简单。前面简单介绍了读操作  ，下面详细介绍其写API。</p>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>见前文</p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件主要使用以下两个API：</p>
<ul>
<li><code>public static Path write(...)</code></li>
<li><code>public static Path writeString(...)</code></li>
</ul>
<p>如，写一个字符串到文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.writeString(path, content, charset);</span><br></pre></td></tr></table></figure>
<p>而追加内容时，可以添加第三个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.write(path, content.getBytes(charset), StandardOption.APPEND);</span><br></pre></td></tr></table></figure>
<p>如果内容过长的话，就该使用流的方式来处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = Files.newInputStream(path);</span><br><span class="line">OutputStream out = Files.newOutputStream(path);</span><br><span class="line">Reader in = Files.newBufferedReader(path, charset);</span><br><span class="line">Writer out = Files.<span class="keyword">new</span> BufferedWriter(path, charset);</span><br><span class="line"><span class="comment">//操作流</span></span><br></pre></td></tr></table></figure>
<h2 id="创建文件和目录"><a href="#创建文件和目录" class="headerlink" title="创建文件和目录"></a>创建文件和目录</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>可以使用<code>Files.createDirectory(path)</code>来创建新目录。</p>
<p>如果需要创建一个嵌套目录，即自动创建中间目录，则需要使用<code>Files.createDirectories(path)</code>。如：要创建<code>dir/dir1/dir2</code>目录，但<code>dir1</code>并不存在，则第二个API会自动创建<code>dir1</code>，而第一个会报错。</p>
<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>可以使用<code>Files.createFile(path)</code>来创建一个新文件。如果文件存在则报异常。检查文件存在和创建文件是原子操作，如果文件不存在，那么文件会被创建，并且其他程序在此过程中是无法执行文件创建操作的。</p>
<h3 id="创建临时目录、文件"><a href="#创建临时目录、文件" class="headerlink" title="创建临时目录、文件"></a>创建临时目录、文件</h3><p>还可以使用以下API在执行位置或者系统执行位置来创建临时目和文件</p>
<ul>
<li><code>public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute&lt;?&gt;... attrs)</code></li>
<li><code>public static Path createTempFile(String prefix, String suffix, FileAttribute&lt;?&gt;... attrs)</code></li>
<li><code>public static Path createTempDirectory(Path dir, String prefix, FileAttribute&lt;?&gt;... attrs)</code></li>
<li><code>public static Path createTempDirectory(String prefix, FileAttribute&lt;?&gt;... attrs)</code></li>
</ul>
<p>注意文件名是由系统命名的，而我们只提供前后缀。如：<code>createTempFile(null, &quot;.txt&quot;)</code>将在系统指定的临时文件目录创建一个诸如<code>12231434456235423321.txt</code>的文件。</p>
<h2 id="复制、移动和删除文件"><a href="#复制、移动和删除文件" class="headerlink" title="复制、移动和删除文件"></a>复制、移动和删除文件</h2><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>可以用<code>Files.copy(fromPath, toPath)</code>来复制文件。</p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>可以使用<code>Files.move(fromPath, toPath)</code>来移动文件。</p>
<p>如果目标路径已存在，那么复制或移动将会失败。如果想要覆盖已有的目标路径，可以使用<code>REPLACE_EXISTING</code>选项。</p>
<p>如果想要复制所有的文件属性，可以使用<code>COPY_ATTRIBUTES</code>选项。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING,StandardCopyOption.COPY_ATTRIBUTES);</span><br></pre></td></tr></table></figure>
<p>如果要将移动定义为为原子性的，要么移动成功，要么原来的文件不变。可以使用<code>ATOM_MOVE</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>
<p>还可以价格你一个流复制到Path中，这表示想要将改输入流存储到硬盘上。类似地，还可以将一个<code>Path</code>复制到输出流中。可以使用以下的调用：</p>
<ul>
<li><code>Files.copy(inputStream, toPath)</code></li>
<li><code>Files.copy(fromPath, outputStream)</code></li>
</ul>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>可以使用<code>Files.delete(path)</code>。</p>
<p>但是这个API在文件不存在的时候会抛出异常。而以下方法不会存在这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> deleted = Files.deleteIfExist(path);</span><br></pre></td></tr></table></figure>
<p>该方法还可以用来删除空目录。</p>
<p>下面是一些选项</p>
<ul>
<li><p><code>StandardOpenOption</code></p>
<table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>READ</td><td>用于读取而打开</td></tr><tr><td>WRITE</td><td>用于写入而打开</td></tr><tr><td>APPEND</td><td>写入时在文件末尾追加</td></tr><tr><td>TRUNCATE_EXISTING</td><td>写入时移除文件已有内容</td></tr><tr><td>CREATE</td><td>自动在文件不存在的情况下创建文件</td></tr><tr><td>CREATE_NEW</td><td>创建文件时如果文件存在则创建失败</td></tr><tr><td>DELETE_ON_CLOSE</td><td>当文件被关闭时尽“可能”的删除该文件</td></tr><tr><td>SPARSE</td><td>给文件系统一个提示，表示文件是稀疏的</td></tr><tr><td>SYNC</td><td>对数据和元数据的每次更新都必须同步的写入到存储设备中</td></tr><tr><td>DSYNC</td><td>对文件数据每次更新都必须同步的写入到存储设备中</td></tr></tbody></table>
</li>
<li><p><code>StandardCopyOption</code></p>
<table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>REPLACE_EXISTING</td><td>如果目标已存在，则替换他</td></tr><tr><td>COPY_ATTRIBUTES</td><td>复制文件的所有属性</td></tr><tr><td>ATOMIC_MOVE</td><td>原子性的移动文件</td></tr></tbody></table>

</li>
</ul>
<h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><p>下面的静态方法都会返回一个boolean值，表示检查路径的某个属性的结果：</p>
<ul>
<li><code>exists</code></li>
<li><code>isHidden</code></li>
<li><code>isReadable</code>，<code>isWritable</code>，<code>isExecutable</code></li>
<li><code>isRegularFile</code>，<code>isDirectory</code>，<code>is SymbolicLink</code></li>
<li><code>size</code>方法会返回文件的字节数。</li>
<li><code>getOwner</code>方法将文件的拥有者返回。（<code>UserPrincipal</code>对象）</li>
</ul>
<p>用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.exists(path);</span><br></pre></td></tr></table></figure>
<p>而其他的基本属性将会被封装在一个<code>BasicFileAttributes</code>接口中。可以通过以下方式获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BasicFileAttributes attributes = Files.readAttributes(path, BasicFileAttributes<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="获取目录中的项"><a href="#获取目录中的项" class="headerlink" title="获取目录中的项"></a>获取目录中的项</h2><p>静态的<code>Files.list</code>方法将会返回可以读取目录中各个项的<code>Stream&lt;Path&gt;</code>对象。注意该方法不会列出深层目录内容，即只列出次级目录的项。如果要看到深层的目录内容，需要使用<code>Files.walk</code>方法来遍历。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream&lt;Path&gt; entries = Files.walk(pathRoot))&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还可以调用<code>Files.walk(pathRoot, depth)</code>来限制想要访问的树的深度。（默认是全部遍历）</p>
<h2 id="使用目录流"><a href="#使用目录流" class="headerlink" title="使用目录流"></a>使用目录流</h2><p>还有一个<code>DirectrotyStream</code>对象（与<code>IntegerStream</code>等相似），所以使用这个对象更加合理。而不是泛型的流。可以使用<code>Files.newDirectoryStream</code>来获取该对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(DirectrotyStream&lt;Path&gt; entries = Files.newDirectoryStream(dir))&#123;</span><br><span class="line">    <span class="keyword">for</span>(Path entry: entries)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用glob模式来过滤文件，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectrotyStream&lt;Path&gt; entries = Files.newDirectoryStream(dir, <span class="string">"*.java"</span>)</span><br></pre></td></tr></table></figure>
<p>下面是所有的glob模式</p>
<table><thead><tr><th>模式</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><em></td><td>匹配路径组成部分中0个或多个字符（不含子目录）</td><td></em>.java</td></tr><tr><td><strong></td><td>匹配跨目录边界的0个或多个字符（含子目录）</td><td></strong>.java</td></tr><tr><td>？</td><td>匹配一个字符</td><td>demo?.java</td></tr><tr><td>[…]</td><td>匹配一个字符集（[0-9]、[A-F]、[!0-9]）</td><td>demo[0-9].java</td></tr><tr><td>{…}</td><td>匹配由逗号隔开的多个可选项之一</td><td>*.{java, class}</td></tr><tr><td>\</td><td>转译上述任意模式中的字符以及\字符</td><td></td></tr></tbody></table>

<h2 id="ZIP文件系统"><a href="#ZIP文件系统" class="headerlink" title="ZIP文件系统"></a>ZIP文件系统</h2><p>Path类会在默认文件系统中查找路径，即在用户本地磁盘中的文件。而还有别的文件系统，例如<code>ZIP</code>文件系统。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileSystem fs = FileSystem.newFileSystem(Path.of(zipname), nmull);		<span class="comment">//zipname为默认文件系统中的zip文件名</span></span><br></pre></td></tr></table></figure>
<p>接下来需要获取ZIP文件系统中的Path则可以使用<code>fs.getPath(sourceName)</code>的方式，如下是一个复制操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.copy(fs.getPath(sourceName), targetPath);</span><br></pre></td></tr></table></figure>
<p>而<code>fs.getPath</code>就与默认文件系统中的<code>Path.of</code>类似。</p>
<h1 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h1><p>大多数操作系统都可以利用虚拟内存实现将一个文件或者文件得到一部分“映射”到内存中。然后这个文件就可以被当成内存数组的一部分来访问，这比传统的文件操作要块很多。</p>
<p> 其主要是<code>FileChannel</code>类。基本操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel channel = FileChannel.open(path, options);</span><br></pre></td></tr></table></figure>
<p>然后通过调用<code>FileChannel</code>类的map方法熊这个通道中获得一个<code>ByteBuffer</code>。</p>
<p>我们可以指定映射文件区域与映射模式。支持的模式有3种：</p>
<ul>
<li><code>FileChannel.MapMode.READ_ONLY</code>：所产生的缓冲区是只读的，任何对该缓冲区写入的尝试都会导致<code>ReadOnlyBufferException</code>。</li>
<li><code>FileChannel.MapMode.READ_WRITE</code>：所产生的缓冲区可读可写，任何修改都会在某个时刻写入到问家中。（注意，这个修改并不是即时的）</li>
<li><code>FileChannel.MapMode.PRIVATE</code>：所产生的缓冲区可读可写，但是任何的修改都不会传播到文件中，其是私有的。 </li>
</ul>
<p>一旦拥有了缓冲区，就可以使用<code>ByteBuffer</code>类和<code>Buffer</code>超类的方法来读写数据了。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Path.of(<span class="string">"E:\\a.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.CREATE_NEW);</span><br><span class="line">    MappedByteBuffer buffer = fileChannel.map(MapMode.PRIVATE, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//buffer has gotten</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓冲区支持顺序和随机数据访问，可以通过<code>get</code>和<code>put</code>来操作数据。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">    <span class="keyword">byte</span> b = buffer.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = ol i &lt; buffer.limit(); i++)&#123;</span><br><span class="line">    <span class="keyword">byte</span> b = buffer.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，buffer还提供了</p>
<p><code>get(Int|Long|Short|Char|Float|Double)</code></p>
<p><code>put(Int|Long|Short|Char|Float|Double)</code></p>
<p>来进行确定的操作。</p>
<p>在恰当的时机、通道关闭或者调用<code>force</code>方法的时候，会将这些修改回写到文件中。</p>
<h1 id="文件加锁机制"><a href="#文件加锁机制" class="headerlink" title="文件加锁机制"></a>文件加锁机制</h1><p>当多个进程同时要修改一个文件的时候，则两个进程之间必须存在交互来确保文件不随意被修改。所以为文件提供了加锁的机制。有以下几个API可供使用：</p>
<ol>
<li><p><code>FileChannel.lock()</code>：会阻塞调用，知道获得锁。</p>
</li>
<li><p><code>FileChannel.tryLock()</code>：将立即返回，要么返回锁；要么在锁不可获得情况下返回null。</p>
</li>
<li><p><code>FileChannel.lock(long start, long size, boolean shared)</code>：与1一致，不过是锁定文件的一部分。</p>
</li>
<li><p><code>FileChannel.tryLock(long start, long size, boolean shared)</code>：与2一致，不过是锁定文件的一部分。</p>
</li>
</ol>
<p><code>shared</code>参数表示是否是一个共享锁。如果为<code>false</code>，则表示是一个独占锁。而如果是<code>true</code>，则是一个共享锁，允许多个进程从文件中读入，并阻止任何进程获得独占的锁。单并非所有的操作系统都支持共享锁，因此可能获得的是独占锁。此时可以调用<code>FileLock</code>类的<code>isShared</code>方法来确定是否支持共享锁。</p>
<p>这个文件将保持锁定状态，直到通道关闭或者在锁上调用<code>release</code>方法。</p>
<p>文件共享锁可以使用<code>try...Resource</code>语句。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(FileLock lock = channel.lock())&#123;</span><br><span class="line">    <span class="comment">//access the locked file or segment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>在某些操作系统中，文件加锁仅仅是建议性的，如果一个应用未获得锁，它依旧可以被另外一个应用并发锁定的文件执行写操作。</li>
<li>在某些操作系统中，不能在锁定一个文件的同时将其映射到内存中。</li>
<li>文件锁是由整个Java虚拟机持有的。如果两个应用由同一个虚拟机启动，那么他们不可能每一个都获得一个在同一个文件上的锁。当调用<code>lock</code>和<code>tryLock</code>方法，如果虚拟机已经在同一个文件上持有了另外一个重叠锁，那么这两个方法将会抛出<code>OverlappingFileLockException</code>。</li>
<li>在一些系统中，关闭一个通道会释放由Java虚拟机持有的底层文件上的所有的锁。因此，在同一个锁定文件上应避免使用多个通道。</li>
<li>在网络文件系统上锁定文件高度依赖于系统的，因此应该尽量避免。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>输入与输出</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-II-1-Java8的流库</title>
    <url>/2022/02/14/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-1-Java8%E7%9A%84%E6%B5%81%E5%BA%93/</url>
    <content><![CDATA[<h1 id="迭代与流"><a href="#迭代与流" class="headerlink" title="迭代与流"></a>迭代与流</h1><p>与集合相比，流提供了一种可以让我们在更高的概念级别上指定任务的数据视图。</p>
<p>流提供了几种操作函数，其调用要比一般的迭代更加简洁。并且其可以链式调用，每一次调用都返回一个新的流对象。</p>
<p>如：统计一个List中长度大于12的单词数量。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String w : words)&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.length() &gt; <span class="number">12</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>
<h3 id="流与集合的差异"><a href="#流与集合的差异" class="headerlink" title="流与集合的差异"></a>流与集合的差异</h3><ol>
<li>流并不存储其元素。这些元素可能存储在底层的集合中，或者是按需生成的。</li>
<li>流的操作并不会修改其数据源。如<code>filter</code>方法不会从流中移除元素，二十会生成一个新的流，其中不包含过滤掉的元素。</li>
<li>流的操作是尽可能惰性执行的。这意味着直至需要其结果时，操作才会执行。例如，如果只是想查找前5个单词而不是所有的单词，那么<code>filter</code>方法会在匹配到第5个单词后就停止过滤。因此，我们甚至可以操作无限流。</li>
</ol>
<h1 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h1><h2 id="从集合Collections接口创建流"><a href="#从集合Collections接口创建流" class="headerlink" title="从集合Collections接口创建流"></a>从集合<code>Collections</code>接口创建流</h2><p>对于实现了<code>Collection</code>接口的类。可以使用<code>Stream.of</code>方法来获得一个接口。详见<a href="https://michaelwang.top/2022/01/24/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-9-%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">java核心技术-I-9-集合</a></p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">"apple"</span>);</span><br><span class="line">arrayList.add(<span class="string">"banana"</span>);</span><br><span class="line">arrayList.add(<span class="string">"pear"</span>);</span><br><span class="line">Stream stream = arrayList.stream();</span><br></pre></td></tr></table></figure>
<h2 id="从数组生成Stream"><a href="#从数组生成Stream" class="headerlink" title="从数组生成Stream"></a>从数组生成<code>Stream</code></h2><h3 id="用所有元素生成Stream"><a href="#用所有元素生成Stream" class="headerlink" title="用所有元素生成Stream"></a>用所有元素生成<code>Stream</code></h3><p>如果要用所有的数组元素来生成一个<code>Stream</code>，则可以使用<code>Stream.of</code></p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>&#125;; </span><br><span class="line">Stream stream1 = Stream.of(arr);</span><br></pre></td></tr></table></figure>
<h3 id="用部分数组元素（连续）生成Stream"><a href="#用部分数组元素（连续）生成Stream" class="headerlink" title="用部分数组元素（连续）生成Stream"></a>用部分数组元素（连续）生成<code>Stream</code></h3><p>如果只需要数组的一部分元素（连续）生成<code>Stream</code>，则可以使用<code>Array.stream(array, from, to)</code>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>&#125;; </span><br><span class="line">Stream stream2 = Arrays.stream(arr, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="直接从基本元素生成Stream"><a href="#直接从基本元素生成Stream" class="headerlink" title="直接从基本元素生成Stream"></a>直接从基本元素生成<code>Stream</code></h2><p>可以通过<code>Stream.of</code>来将基本元素转变为<code>Stream</code>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream stream2 = Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="创建一个空流"><a href="#创建一个空流" class="headerlink" title="创建一个空流"></a>创建一个空流</h2><p>可以通过<code>Stream.empty()</code>来生成一个不包含任何元素的流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; silence = Stream.empty();</span><br></pre></td></tr></table></figure>
<h2 id="创建一个无限流"><a href="#创建一个无限流" class="headerlink" title="创建一个无限流"></a>创建一个无限流</h2><p>可以通过<code>Stream.generate(FunctionInterface)</code>来获取一个无线流，其来源是参数中的函数式接口。</p>
<p>如-通过一个字符串创建流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; echos = Stream.generate(() -&gt; <span class="string">"Echo"</span>);</span><br></pre></td></tr></table></figure>
<p>如-通过随机函数来获取一个包含无限随机数的流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Double&gt; echos = Stream.generate(Math::random);</span><br></pre></td></tr></table></figure>
<h2 id="创建一个无线的序列流"><a href="#创建一个无线的序列流" class="headerlink" title="创建一个无线的序列流"></a>创建一个无线的序列流</h2><p>可以通过<code>Stream.iterate(Iterable)</code>来通过迭代器创建一个指定的序列流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br></pre></td></tr></table></figure>
<h2 id="创建一个长度仅为0或1的流"><a href="#创建一个长度仅为0或1的流" class="headerlink" title="创建一个长度仅为0或1的流"></a>创建一个长度仅为0或1的流</h2><p>通过<code>Stream.ofNullable(T t)</code>方法可以创建一个长度仅为0或1的流。当参数t为null时，则长度为0，否则长度为1，即是包含该对象。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>值得注意的是，在执行流的操作的时候，我们并没有修改流背后的集合。但是如果手动修改了流的集合（指在流操作外部修改，在流操作，比如<code>forEach</code>中，则会报错），那么流的操作就会变成不可预知的。JDK文档称之为不干涉性。</p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="filter-Predicate-lt-T-gt"><a href="#filter-Predicate-lt-T-gt" class="headerlink" title="filter(Predicate&lt;T&gt;)"></a><code>filter(Predicate&lt;T&gt;)</code></h2><p><code>filter</code>函数会按照参数中的函数式接口来过滤所有元素。然后将符合条件的元素组合为新的流返回。</p>
<p>如-过滤所有长度大于12的单词：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; words = ...;</span><br><span class="line">Stream&lt;String&gt; longWords = words.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>注意<code>filter</code>的参数为一个<code>Predicate&lt;T&gt;</code>函数式接口。即从T到Boolean的函数。</p>
<h2 id="map-FunctionInterface"><a href="#map-FunctionInterface" class="headerlink" title="map(FunctionInterface)"></a><code>map(FunctionInterface)</code></h2><p><code>map(FunctionInterface)</code>会对流中的每个元素应用参数的函数式接口。并且将所有的结果组合为一个新的流返回。</p>
<p>如-截取所有单词的首字母：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; words = ...;</span><br><span class="line">Stream&lt;String&gt; firstLetter = words.stream().map(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h2 id="flatMap-FunctionInterface"><a href="#flatMap-FunctionInterface" class="headerlink" title="flatMap(FunctionInterface)"></a><code>flatMap(FunctionInterface)</code></h2><p><code>flatMap(FunctionInterface)</code>是对流中的每个元素应用参数的函数式接口（其都返回一个流），然后将每个参数的返回值组合为一个流。</p>
<p>如<code>codePoints(&quot;boat&quot;)</code>返回的流是<code>[&quot;b&quot;, &quot;o&quot;, &quot;a&quot;, &quot;t&quot;]</code></p>
<p>所以<code>Stream&lt;Stream&lt;String&gt;&gt; result = words.stream().map(w -&gt; codePoints(w))</code>会返回一个流的嵌套。<code>[...[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]</code></p>
<p>而使用<code>Stream&lt;Stream&lt;String&gt;&gt; result = words.stream().flatMap(w -&gt; codePoints(w))</code>会返回一个所有子流的组合流，即<code>[..., &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</code></p>
<h2 id="stream-limit-n"><a href="#stream-limit-n" class="headerlink" title="stream.limit(n)"></a><code>stream.limit(n)</code></h2><p><code>stream.limit(n)</code>会截取流中的前n个元素（如果其长度小于n，则会返回流中的全部元素组成的新流）。</p>
<p>这个方法可以用于裁剪无限流。</p>
<p>如-获取100个随机数的流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Double&gt; randoms = Streams.generate(Math::random).limit(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h2 id="stream-skip-n"><a href="#stream-skip-n" class="headerlink" title="stream.skip(n)"></a><code>stream.skip(n)</code></h2><p><code>stream.skip(n)</code>方法正好相反，其会丢弃前n个元素。</p>
<p>如-跳过单词表中的前5个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; newWords = words.stream().skip(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h2 id="stream-takeWhile-predicate"><a href="#stream-takeWhile-predicate" class="headerlink" title="stream.takeWhile(predicate)"></a><code>stream.takeWhile(predicate)</code></h2><p><code>stream.takeWhile(predicate)</code>会在谓词为真时获取该元素。</p>
<p>如-收集分割字符串中的所有数字元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; initialDigits = codePoints(str).takeWhile(s -&gt; <span class="string">"0123456789"</span>.contains(s));</span><br></pre></td></tr></table></figure>
<h2 id="stream-takeWhile-predicate-1"><a href="#stream-takeWhile-predicate-1" class="headerlink" title="stream.takeWhile(predicate)"></a><code>stream.takeWhile(predicate)</code></h2><p><code>takeWhile</code>方法正好相反，他会在条件为真的时候丢弃元素。</p>
<p>如-收集分割字符串中的所有<strong>非数字元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; initialDigits = codePoints(str).dropWhile(s -&gt; <span class="string">"0123456789"</span>.contains(s));</span><br></pre></td></tr></table></figure>
<h2 id="Stream-concat-Stream-stream1-Stream-stream1"><a href="#Stream-concat-Stream-stream1-Stream-stream1" class="headerlink" title="Stream.concat(Stream stream1, Stream stream1)"></a><code>Stream.concat(Stream stream1, Stream stream1)</code></h2><p>与字符串一样，<code>conact</code>方法可以将两个流的元素连接在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.concat(codePoints(<span class="string">"hello"</span>), codeoPints(<span class="string">"world"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="stream-disinct"><a href="#stream-disinct" class="headerlink" title="stream.disinct()"></a><code>stream.disinct()</code></h2><p><code>stream.disinct()</code>会将原流中的重复元素剔除之后，返回一个新的无重复元素的流。</p>
<p>如：剔除重复字母</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>).disinct();</span><br><span class="line"><span class="comment">//["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>
<h2 id="stream-sorted-comparator"><a href="#stream-sorted-comparator" class="headerlink" title="stream.sorted(comparator)"></a><code>stream.sorted(comparator)</code></h2><p>与其他集合排序一样，流的排序也是接受一个<code>comparator</code>。其会根据这个<code>comparator</code>，返回排序后的元素。</p>
<p>如-将最长的字符串排在前面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; longsFirst = words.stream().sorted(Comparator.comparing(String::length).reverse());</span><br></pre></td></tr></table></figure>
<h2 id="stream-peek-FunctionInterface"><a href="#stream-peek-FunctionInterface" class="headerlink" title="stream.peek(FunctionInterface)"></a><code>stream.peek(FunctionInterface)</code></h2><p><code>stream.peek(FunctionInterface)</code>的即预览这个流的元素，但是并不会将其取出。（其本质是生成一个新的流，然后获取新流中的元素，所以原来的流并无变化）然后对这个元素应用参数的函数式接口。</p>
<p>如-打印流中的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>).peek(e -&gt; System.out.println(<span class="string">"item-"</span> + e));</span><br></pre></td></tr></table></figure>
<h1 id="简单约简（注意以前方法均返回Option对象，将在下一章介绍）"><a href="#简单约简（注意以前方法均返回Option对象，将在下一章介绍）" class="headerlink" title="简单约简（注意以前方法均返回Option对象，将在下一章介绍）"></a>简单约简（注意以前方法均返回<code>Option</code>对象，将在下一章介绍）</h1><p>通过约简可以获得通过前面处理的流的指定结果。约简是一种<strong>终结操作</strong>，他们会将流约简为可以在程序中使用的非流值。</p>
<p>其有以下API：</p>
<h2 id="stream-max-comparator"><a href="#stream-max-comparator" class="headerlink" title="stream.max(comparator)"></a><code>stream.max(comparator)</code></h2><p>通过比较器返回流中最大的元素。</p>
<h2 id="stream-min-comparator"><a href="#stream-min-comparator" class="headerlink" title="stream.min(comparator)"></a><code>stream.min(comparator)</code></h2><p>通过比较器返回流中最小的元素。</p>
<h2 id="stream-findFirst"><a href="#stream-findFirst" class="headerlink" title="stream.findFirst()"></a><code>stream.findFirst()</code></h2><p>返回流中的第一个元素。如果流为空，则返回空的<code>Option</code>对象。</p>
<h2 id="stream-findAny"><a href="#stream-findAny" class="headerlink" title="stream.findAny()"></a><code>stream.findAny()</code></h2><p>返回流中的任意一个元素。如果流为空，则返回空的<code>Option</code>对象。</p>
<h2 id="stream-anyMatch-predicate"><a href="#stream-anyMatch-predicate" class="headerlink" title="stream.anyMatch(predicate)"></a><code>stream.anyMatch(predicate)</code></h2><p>流中的是否存在一个元素满足给定谓词。</p>
<h2 id="stream-allMatch-predicate"><a href="#stream-allMatch-predicate" class="headerlink" title="stream.allMatch(predicate)"></a><code>stream.allMatch(predicate)</code></h2><p>流中是否所有元素是否都满足给定谓词。</p>
<h2 id="stream-noneMatch-predicate"><a href="#stream-noneMatch-predicate" class="headerlink" title="stream.noneMatch(predicate)"></a><code>stream.noneMatch(predicate)</code></h2><p>流中是否没有元素满足给定谓词。</p>
<h1 id="Optional类型"><a href="#Optional类型" class="headerlink" title="Optional类型"></a><code>Optional</code>类型</h1><p><code>Optional&lt;T&gt;</code>对象是一种包装器对象，其可能包装了T对象或者没有包装任意对象。其被视为更安全的方式，用来替代类型T的引用。</p>
<h2 id="获取Optional值"><a href="#获取Optional值" class="headerlink" title="获取Optional值"></a>获取<code>Optional</code>值</h2><p>其有3个方法来获取<code>Opitons</code>的值。</p>
<h3 id="Opions-orElse-T-t"><a href="#Opions-orElse-T-t" class="headerlink" title="Opions.orElse(T t)"></a><code>Opions.orElse(T t)</code></h3><p>该方法会在options存在值的时候返回该值，否则返回传递的t。</p>
<h3 id="Options-orElseGet-FunctionInterface"><a href="#Options-orElseGet-FunctionInterface" class="headerlink" title="Options.orElseGet(FunctionInterface)"></a><code>Options.orElseGet(FunctionInterface)</code></h3><p>该方法会在options存在值的时候返回该值，否则返回传递的函数参数调用的结果。</p>
<h3 id="Options-orElseThrow-exceptionSupplier"><a href="#Options-orElseThrow-exceptionSupplier" class="headerlink" title="Options.orElseThrow(exceptionSupplier)"></a><code>Options.orElseThrow(exceptionSupplier)</code></h3><p>该方法会在options存在值的时候返回该值，否则抛出传递参数的异常。</p>
<h2 id="消费Optional值"><a href="#消费Optional值" class="headerlink" title="消费Optional值"></a>消费<code>Optional</code>值</h2><p>除了直接获取optional包装的值，还可以接受一个函数接口，让函数接口直接处理该函数。</p>
<h3 id="optional-ifPresent-Consumer-action"><a href="#optional-ifPresent-Consumer-action" class="headerlink" title="optional.ifPresent(Consumer action)"></a><code>optional.ifPresent(Consumer action)</code></h3><p> 该方法会在值存在的情况下，将其传递给参数函数。否则不会有任何效果。</p>
<h2 id="optional-ifPresentOrElse-Consumer-action-Runnable-emptyAction"><a href="#optional-ifPresentOrElse-Consumer-action-Runnable-emptyAction" class="headerlink" title="optional.ifPresentOrElse(Consumer action, Runnable emptyAction)"></a><code>optional.ifPresentOrElse(Consumer action, Runnable emptyAction)</code></h2><p>该方法会在值存在的情况下，将其传递给第一个参数函数；否则会调用第二个空的处理方法。</p>
<h2 id="管道化Optional值"><a href="#管道化Optional值" class="headerlink" title="管道化Optional值"></a>管道化<code>Optional</code>值</h2><p>管道化即获取optional的值，但不消费。可以使用与管道相似的方法来操作<code>Optional</code>对象，同时返回一个新的<code>0ptional</code>对象。此时可以将<code>Optional</code>对象看为一个长度为0或1的流。</p>
<p>其有以下3个API：</p>
<h3 id="optional-map-FunctionInterface"><a href="#optional-map-FunctionInterface" class="headerlink" title="optional.map(FunctionInterface)"></a><code>optional.map(FunctionInterface)</code></h3><p>通过参数函数处理原<code>optional</code>对象的值。然后返回新的<code>Oprtional</code>对象。</p>
<h3 id="optional-filter-predicate"><a href="#optional-filter-predicate" class="headerlink" title="optional.filter(predicate)"></a><code>optional.filter(predicate)</code></h3><p>若原<code>Optional</code>的值满足给定谓词，就返回一个新的一样值的<code>Optional</code>对象，否则，返回一个空的<code>Optional</code>对象。</p>
<h3 id="Optional-or-supplier"><a href="#Optional-or-supplier" class="headerlink" title="Optional.or(supplier)"></a><code>Optional.or(supplier)</code></h3><p>如果当前<code>Optional</code>对象不为空，则产生当前的<code>Optional</code>，否则由<code>supplier</code>产生一个<code>Optional</code>。</p>
<h2 id="用flatMap构建Optional值的函数"><a href="#用flatMap构建Optional值的函数" class="headerlink" title="用flatMap构建Optional值的函数"></a>用<code>flatMap</code>构建<code>Optional</code>值的函数</h2><p><code>flatMap</code>会在<code>Optional</code>包装部位空时，产生将<code>mapper</code>应用于当前<code>Optional</code>值所产生的结果，或者在当前<code>Optional</code>为空时，返回一个空<code>Optional</code>。</p>
<p>由于<code>Opional&lt;T&gt;</code>是一个包装类型，所以无法直接调用T的相关方法。而可以使用<code>flatMap</code>来直接获取到包装类内部的值。并且调用其方法，然后返回。</p>
<p>如：</p>
<p>类型S有一个f方法来产生一个<code>Optional&lt;T&gt;</code>对象。</p>
<p>类型T有一个g方法来产生一个<code>Optional&lt;U&gt;</code>对象。</p>
<p>为我们无法使用<code>s.f().g()</code>来获得<code>Optional&lt;U&gt;</code>对象。</p>
<p>但是我们可以使用下面的方式来获取该对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;U&gt; res = s.f().flatMap(T::g);</span><br></pre></td></tr></table></figure>
<h2 id="将Optional转换为流"><a href="#将Optional转换为流" class="headerlink" title="将Optional转换为流"></a>将<code>Optional</code>转换为流</h2><p>通过<code>optional.stream()</code>可以将<code>Optional</code>值转变为一个长度为0或1的流。</p>
<h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><ul>
<li><code>Optional</code>类型的便利永远都不应该为null；</li>
<li>不要使用<code>Optional</code>类型的域。因为其代价是额外多出来一个对象。在累的内部，使用null表示缺失的域更易于操作。</li>
<li>不要在集合中放置<code>Optional</code>对象，并且不要将他们作为map的key。应该直接收集其中的值。</li>
</ul>
<h1 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h1><p>当处理完流之后，通常需要查看其结果。则可以通过以下方法来查看内部元素。</p>
<h2 id="stream-iterator"><a href="#stream-iterator" class="headerlink" title="stream.iterator"></a><code>stream.iterator</code></h2><p>可以使用<code>stream.iterator</code>来生成一个迭代器，则可以按照普通的迭代器方法来查看内部元素。</p>
<h2 id="stream-forEach-Comsumer-action"><a href="#stream-forEach-Comsumer-action" class="headerlink" title="stream.forEach(Comsumer action)"></a><code>stream.forEach(Comsumer action)</code></h2><p>可以通过<code>stream.forEach</code>来直接遍历流中的元素。</p>
<h2 id="stream-forEachOrdered-Comsumer-action"><a href="#stream-forEachOrdered-Comsumer-action" class="headerlink" title="stream.forEachOrdered(Comsumer action)"></a><code>stream.forEachOrdered(Comsumer action)</code></h2><p>使用该方法遍历时，此时会完全按照流中的顺序。但会丧失并行处理的部分甚至全部优势。</p>
<h2 id="stream-toArray-Constructor"><a href="#stream-toArray-Constructor" class="headerlink" title="stream.toArray(Constructor)"></a><code>stream.toArray(Constructor)</code></h2><p>调用此方法会返回一个数组，如果不传递参数，则返回<code>Object[]</code>，需要强转。其参数为对应类型的构造函数，此时可以返回对应类型的数组。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Object[] objArr = s.toArray();</span><br><span class="line">Integer[] intArr = s.toArray(Ingeter::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<h2 id="stream-toList"><a href="#stream-toList" class="headerlink" title="stream.toList()"></a><code>stream.toList()</code></h2><p>此方法会返回一个<code>List</code>用于查看内容。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; strings = stream1.toList();</span><br></pre></td></tr></table></figure>
<h2 id="stream-collect-Collector-collector"><a href="#stream-collect-Collector-collector" class="headerlink" title="stream.collect(Collector collector)"></a><code>stream.collect(Collector collector)</code></h2><p>可以通过该方法将流中的元素收集到指定的集合中。其中<code>Collector collector</code>一般是通过<code>Collectors.toXXX()</code>或者<code>Collectors.toCollection(XXX:new)</code>来获取。</p>
<p>如：</p>
<p>1-收集到List（与上面的API作用相同）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = stream.collect(Collections.toList());</span><br></pre></td></tr></table></figure>
<p>2-收集到Set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; res = stream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>
<p>3-收集到指定的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;String&gt; res = stream.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
<h3 id="收集到字符串"><a href="#收集到字符串" class="headerlink" title="收集到字符串"></a>收集到字符串</h3><p>还可以通过<code>stream.collect</code>收集到一个字符串。关键是<code>collector</code>必须是一个<code>Collectors.join()</code>产生的。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String res = stream.collect(Collectors.join());			<span class="comment">//不加间隔符</span></span><br><span class="line">String res = stream.collect(Collectors.join(<span class="string">","</span>));			<span class="comment">//间隔符为,</span></span><br></pre></td></tr></table></figure>
<p>如果流中除字符串外还包含其他对象，那么我们需要先将其转化为字符串。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String res = stream.map(Object::toString).collect(Collectors.join(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure>
<h2 id="收集到映射表"><a href="#收集到映射表" class="headerlink" title="收集到映射表"></a>收集到映射表</h2><p>假设流中的对象是一个<code>Person</code>对象，而我们要将其收集到映射表中，<code>key</code>为<code>Person.id</code>；<code>value</code>为<code>Person.name</code>。</p>
<p>则可以使用<code>Collectors.toMap()</code>方法。该方法接受两个参数，用来产生映射表的键和值。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; idToName = people.collect(Collectors.toMap(Person::getId, Person::getName));</span><br></pre></td></tr></table></figure>
<p>如果需要获取对象本身，则使用<code>Funciton.identity()</code>。即返回的是流中的类型元素T。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; idToPerson = people.collect(Collectors,toMap(Person::getId, Function.identity));</span><br></pre></td></tr></table></figure>
<h3 id="嵌套集合"><a href="#嵌套集合" class="headerlink" title="嵌套集合"></a>嵌套集合</h3><p>假如要收集每个国家支持的语言。则我们需要一个<code>Map&lt;String, Set&lt;String&gt;&gt;</code>，此时我们由该如何直接从流中获取呢。</p>
<p>此时的<code>Collectors.map</code>需要3个参数：</p>
<ul>
<li>key值。</li>
<li>指定value的值。</li>
<li>组合set的函数</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryLang = locales.collect(</span><br><span class="line">	Collecotors.toMap(</span><br><span class="line">    	locale::getDisplayCountry,</span><br><span class="line">        l -&gt; Collectors.singleton(l.getDisplayLanguage()),</span><br><span class="line">        (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> union = <span class="keyword">new</span> HasSet&lt;String&gt;(a);</span><br><span class="line">            union.addAll(b);</span><br><span class="line">            <span class="keyword">return</span> union;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果需要使用<code>TreeMap</code>，则需要将其构造器<code>TreeMap::new</code>指定为第4个参数。</p>
<h1 id="组群和分组"><a href="#组群和分组" class="headerlink" title="组群和分组"></a>组群和分组</h1><p>上面嵌套集合的方式可以使用组群和分区更简洁的解决。</p>
<h2 id="Collectors-groupingBy"><a href="#Collectors-groupingBy" class="headerlink" title="Collectors.groupingBy()"></a><code>Collectors.groupingBy()</code></h2><p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Locale&gt;&gt; countryToLocales = locales.collect(</span><br><span class="line">	Collectors.groupingBy(Locale::getCountry)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中函数<code>Locale::getCountry</code>是组群的分类函数。</p>
<h2 id="Collectors-partitioningBy"><a href="#Collectors-partitioningBy" class="headerlink" title="Collectors.partitioningBy()"></a><code>Collectors.partitioningBy()</code></h2><p>当分类函数是一个断言函数（即返回Boolean值的函数），流的元素可能分为两个列表。该函数返回true的元素和其他元素。</p>
<p>如：将<code>locale</code>分成了使用英语和使用其他所有语言的两类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Locale&gt;&gt; englishAndOther = locales.collect(</span><br><span class="line">	Collectors.partitioningBy(l -&gt; l.getLanguage().equals(<span class="string">"en"</span>))</span><br><span class="line">);</span><br><span class="line">List&lt;Locale&gt; englishLocales = englishAndOther.get(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h1 id="下游收集器"><a href="#下游收集器" class="headerlink" title="下游收集器"></a>下游收集器</h1><p><code>groupingBy</code>方法会产生一个映射表，其每个值都是一个列表。如果想要以某种方式来处理这些列表，则需要下游收集器。</p>
<h2 id="Collectors-counting"><a href="#Collectors-counting" class="headerlink" title="Collectors.counting()"></a><code>Collectors.counting()</code></h2><p><code>Collectors.counting()</code>会产生收集到的元素的个数。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, lOng&gt; countryToLocaleCounts = locales.collect(groupBy(Locale::getCountry, Collectors.counting()));</span><br></pre></td></tr></table></figure>
<p>可以对每个国家有多少个local进行计数。</p>
<h2 id="Collectors-summing-Int-Long-Double"><a href="#Collectors-summing-Int-Long-Double" class="headerlink" title="Collectors.summing(Int|Long|Double)()"></a><code>Collectors.summing(Int|Long|Double)()</code></h2><p>上面的方法会返回收集到的数据的和。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; stateToPopulation = cities.collect(</span><br><span class="line">	groupingBy(City::getState, Collectors.summingInt(city::getPopulation));</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>可以计算城市流中每个州的人口总和。</p>
<h2 id="Collectors-maxBy-amp-amp-Collectors-minBy"><a href="#Collectors-maxBy-amp-amp-Collectors-minBy" class="headerlink" title="Collectors.maxBy&amp;&amp;Collectors.minBy"></a><code>Collectors.maxBy</code>&amp;&amp;<code>Collectors.minBy</code></h2><p>以上两个方法会接受一个比较器，并分别产生下游元素中的最大值和最小值。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Optional&lt;City&gt;&gt; stateToLargestCity =  cities.collect(</span><br><span class="line">	groupingBy(</span><br><span class="line">        City::getState,</span><br><span class="line">    	Collectors.maxBy(Comparator.comparing(City::getPopulation))</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Collectors-collectAndThen"><a href="#Collectors-collectAndThen" class="headerlink" title="Collectors.collectAndThen"></a><code>Collectors.collectAndThen</code></h2><p>该收集器会在收集器后面添加一个最终处理步骤。例如，我们想要知道有多少种不同的结果，那么就可以将他们收集到一个集合中，然后计算其尺寸：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; stringCountByStartingLetter = strings.collect(</span><br><span class="line">	groupingBy(s -&gt;  s.charAt(<span class="number">0</span>),</span><br><span class="line">              Collectors.collectAndThen(toSet(), Set::size)</span><br><span class="line">              )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Collectors-mapping"><a href="#Collectors-mapping" class="headerlink" title="Collectors.mapping"></a><code>Collectors.mapping</code></h2><p><code>Collectors.mapping</code>与<code>Collectors.collectAndThen</code>相反，他会将参数函数应用于收集到的每个元素，并将其结果传递给下游收集器。</p>
<p>如：按照首字母进行收集，咋子每个分组内部，计算字符串的长度并将其传递给下游收集器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Character, Set&lt;Integer&gt;&gt; stringLengthByStartingLetter = strings.collect(</span><br><span class="line">	groupingBy(</span><br><span class="line">    	s -&gt; s.charAt(<span class="number">0</span>),</span><br><span class="line">        Collectors.mapping(String::length, toSet())</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Collectors-flatMap"><a href="#Collectors-flatMap" class="headerlink" title="Collectors.flatMap"></a><code>Collectors.flatMap</code></h2><p>此处作用也是一致，可以将每个组结果返回的结果进行铺平。</p>
<h2 id="Collectors-filtering"><a href="#Collectors-filtering" class="headerlink" title="Collectors.filtering"></a><code>Collectors.filtering</code></h2><p><code>Collectors.filtering</code>会将过滤器应用到每个组上的元素中，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Set&lt;City&gt;&gt; largeCitiesByState = cities.collect(</span><br><span class="line">	groupingBy(City::getState,</span><br><span class="line">              filtering(c -&gt; c.getPopulation() &gt; <span class="number">5000000</span>),</span><br><span class="line">               toSet()</span><br><span class="line">              )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="TIPS-1"><a href="#TIPS-1" class="headerlink" title="TIPS"></a>TIPS</h2><p>将收集器组合起来是一种很强大的方式，但是它也可能会导致产生非常复杂的表达式。最佳用法是与<code>groupingBy</code>和<code>partitioningBy</code>一起处理下游的映射表中的值。否则，应该直接在流上应用诸如<code>map</code>、<code>reduce</code>、<code>count</code>、<code>max</code>和<code>min</code>这样的方式。</p>
<h1 id="约简操作"><a href="#约简操作" class="headerlink" title="约简操作"></a>约简操作</h1><p><code>reduce</code>方法是一种用于从流中计算某个值的通用机制。其有3个重载。</p>
<h2 id="Optional-lt-T-gt-reduce-BinaryOperator-lt-T-gt-accumulator"><a href="#Optional-lt-T-gt-reduce-BinaryOperator-lt-T-gt-accumulator" class="headerlink" title="Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);"></a><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</code></h2><p>其接受一个二元表达式，其第一个操作符为上一次调用该表达式的返回值（首次为第一个元素）。</p>
<p>如：对一个流求和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; values = ...;</span><br><span class="line">Options&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y);		<span class="comment">//v1 + v2 + v3+...</span></span><br><span class="line">Options&lt;Integer&gt; sum = values.reduce(Intger::sum);			<span class="comment">//效果一样</span></span><br></pre></td></tr></table></figure>
<h2 id="T-reduce-T-identity-BinaryOperator-lt-T-gt-accumulator"><a href="#T-reduce-T-identity-BinaryOperator-lt-T-gt-accumulator" class="headerlink" title="T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);"></a><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</code></h2><p>与上面用法相同，只是首次的元素会被替换为<code>identity</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; values = ...;</span><br><span class="line">Options&lt;Integer&gt; sum = values.reduce(<span class="number">1</span>, (x, y) -&gt; x + y);		<span class="comment">//1 + v1 + v2 + v3 +...</span></span><br></pre></td></tr></table></figure>
<h2 id="lt-U-gt-U-reduce-U-identity-BiFunction-lt-U-super-T-U-gt-accumulator-BinaryOperator-lt-U-gt-combiner"><a href="#lt-U-gt-U-reduce-U-identity-BiFunction-lt-U-super-T-U-gt-accumulator-BinaryOperator-lt-U-gt-combiner" class="headerlink" title="&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);"></a><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</code></h2><p>这种形式用于当我们需要统计流中元素的某个属性进行约简操作时。其中<code>BiFunction</code>用于累加操作，而<code>accumulator</code>用于合并并行处理的结果。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = words.reduce(<span class="number">0</span>, </span><br><span class="line">                       (total, word) -&gt; total + word.length, </span><br><span class="line">                       (total1, total2) -&gt; total1 + total2</span><br><span class="line">                      );</span><br></pre></td></tr></table></figure>
<h1 id="基本类型流"><a href="#基本类型流" class="headerlink" title="基本类型流"></a>基本类型流</h1><p>与基本类型的包装类相似，流对于基本类型也有对应的基本类型流：</p>
<ul>
<li><code>IntStream</code>：Integer, Short, Char, Byte, Boolean</li>
<li><code>LongStream</code>：Long</li>
<li><code>DoubleStream</code>：Double, Float</li>
</ul>
<p>与对象流一样，我们还可以使用静态的<code>generate</code>和<code>iterate</code>方法。</p>
<p>此外，<code>IntStream</code>和<code>LongStream</code>有静态方法<code>range</code>和<code>rangeClosed</code>，可以生成步长为1的整数范围（后者包含上限）。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream zeroToNinetyNine = IntStream.range(<span class="number">0</span>, <span class="number">100</span>);	<span class="comment">//0-99</span></span><br><span class="line">IntStream zeroToHundred = IntStream.range(<span class="number">0</span>, <span class="number">100</span>);	<span class="comment">//0-100</span></span><br></pre></td></tr></table></figure>
<h2 id="基本流与对象流的转化"><a href="#基本流与对象流的转化" class="headerlink" title="基本流与对象流的转化"></a>基本流与对象流的转化</h2><h3 id="对象流转基本流"><a href="#对象流转基本流" class="headerlink" title="对象流转基本流"></a>对象流转基本流</h3><p>可以使用<code>stream</code>的<code>mapToInt</code>，<code>mapToLong</code>，<code>mapToDouble</code>来将其转换为基本流，可以将原流中的属性转化为新的基本流。</p>
<p>如：将单词的长度转化为新的<code>IntStream</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; words = ...;</span><br><span class="line">IntStream lengths = words.mapToInt(String::length);</span><br></pre></td></tr></table></figure>
<h3 id="基本流转对象流"><a href="#基本流转对象流" class="headerlink" title="基本流转对象流"></a>基本流转对象流</h3><p>可以使用<code>boxed</code>方法转化为对象流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integers = IntStream.range(<span class="number">0</span>, <span class="number">100</span>).boxed();</span><br></pre></td></tr></table></figure>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><code>toArray</code>方法会返回对应的基本类型数组。（注意：虽然上面提到<code>IntStream</code>可以存储<code>Integer, Short, Char, Byte, Boolean</code>，但是仍然返回的是<code>intt[]</code>）。</li>
<li>产生可选结果的方法会返回一个<code>OptionalInt</code>、<code>OptionalLong</code>或<code>OptionalDouble</code>。这些方法与<code>Optional</code>相似，但是具有<code>getAsInt</code>，<code>getAsLong</code>、<code>getAsDouble</code>方法，而不是<code>get</code>方法。</li>
<li>具有分别返回总和、平均值、最大值和最小值的sum、max和min方法。对象流没有定义这些方法。</li>
<li><code>summaryStatistics</code>方法会产生一个类型为<code>IntSummaryStatistics</code>、<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code>的对象，他们可以同hi报告流的总和、数量、平均值、最大值和最小值。</li>
</ul>
<h1 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h1><p>流时并行处理块操作变的容易。整个过程几乎是自动的。</p>
<h2 id="创建并行流"><a href="#创建并行流" class="headerlink" title="创建并行流"></a>创建并行流</h2><h3 id="Collection-parallelStream"><a href="#Collection-parallelStream" class="headerlink" title="Collection.parallelStream()"></a><code>Collection.parallelStream()</code></h3><p>可以使用<code>Collection.parallelStream()</code>方法从任何集合中获取一个并行流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; parallelWords = words.parallelStream();</span><br></pre></td></tr></table></figure>
<h3 id="stream-parallel"><a href="#stream-parallel" class="headerlink" title="stream.parallel()"></a><code>stream.parallel()</code></h3><p>对于现有的流，可以通过<code>stream.parallel()</code>来获取一个并行流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; parallelWords = Stream.of(wordArray).parallel();</span><br></pre></td></tr></table></figure>
<h2 id="相关注意点"><a href="#相关注意点" class="headerlink" title="相关注意点"></a>相关注意点</h2><p>只要在终结方法执行时流处于并行模式，所有的中间流操作都将被并行化。</p>
<p>只要是并行就会存在竞态的问题。</p>
<p>如下面的例子就是有问题的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shortWords = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br><span class="line">words.parallelStream().forEach(</span><br><span class="line">	s -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">12</span>) shortWords[s.length()]++;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>因为<code>shortWords</code>会被传递到多个线程中，这就会存在竞态的问题，所以不能得到预期的结果。</p>
<p>排序并不排斥高效的并行处理。例如，当计算<code>Stream.map(fun)</code>时，流可以被划分为n部分，它们会被并行的处理。然后结果会按照顺序重新组装起来。</p>
<h3 id="stream-unordered"><a href="#stream-unordered" class="headerlink" title="stream.unordered"></a><code>stream.unordered</code></h3><p>当然，如果不需要排序的需求，并行操作的性能将会得到很大的提升。此时可以通过<code>stream.unordered</code>方法来标记对顺序没有要求。</p>
<p>例如<code>stream.instinct</code>就会从中获得更高效率，原因是不用考虑哪一个相同的元素将会被保留。</p>
<h2 id="TIPS-2"><a href="#TIPS-2" class="headerlink" title="TIPS"></a>TIPS</h2><ul>
<li>并行化会导致大量的开销，只有面对非常大的数据集才划算。</li>
<li>只有在底层的数据源可以被有效地分割为多个部分时，将流并行化才有意义。</li>
<li>并行流使用的线程池可能会因诸如文件I/O或者网络访问这样的操作被阻塞而饿死。</li>
</ul>
<p>只有面对海量的内存数据和运算密集处理，并行流才会工作最佳。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>Java8的流库</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-II-6-日期和时间API</title>
    <url>/2022/02/16/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-6-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java1.0有一个<code>Date</code>类，事后证明其太过简单了，当Java1.1引入<code>Calendar</code>之后，Date类中的大部分方法就被其弃用了。但是<code>Calendar</code>的API还是有缺陷，它的实例是可以修改的，并且它没有处理诸如闰秒这样的问题。 第三次在Java SE 8中引入了<code>java.time</code>API，它修正了过去的错误。并且应该会服役相当长一段时间。</p>
<h1 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h1><p>Java的Date和Time API规范要求Java使用的时间尺度为：</p>
<ul>
<li>每天86400秒。</li>
<li>每天正午与官方时间精确匹配。</li>
<li>在其他时间点上，以精确定义的方式与官方时间接近匹配。</li>
</ul>
<p>在Java中，<code>Instance</code>类表示时间线上的某个点。被称为“新纪元”的时间线远点被设置为穿过伦敦格林尼治皇家天文台的本初子午线所处时区的1970年1月1日的午夜。这与<code>UNIX/POSIX</code>时间使用的惯例相同。从该原点开始，时间按照每天86400秒向前或向回度量，精确到纳秒。其有以下API：</p>
<ul>
<li><code>Instance.MIN()</code>：最小值，表示10亿年前。</li>
<li><code>Instance.MAX()</code>：最大值，是公元1000 000 000年的12月21日。</li>
<li><code>Instance.now()</code>：给出当前的时刻。</li>
<li><code>Instance.between(start, end)</code>：表示两个时间点的差距。返回的是一个<code>Duriation</code>对象，可以对其调用<code>toNanos</code>、<code>toMills</code>、<code>getSeconds</code>、<code>toMinutes</code>，<code>toHours</code>和<code>toDays</code>来获取<code>Duration</code>按照传统单位度量的时间长度。（值得注意的是，转换为纳秒时，long类型只能存储大约300年的长度。）</li>
</ul>
<p>TIP：<code>Instance</code>和<code>Duration</code>类都是不可修改的类，所以诸如<code>multipliedBy</code>和<code>minus</code>这样的方法都会返回一个新的实例。</p>
<h2 id="日历类"><a href="#日历类" class="headerlink" title="日历类"></a>日历类</h2><p>除了上述的<code>Date</code>与<code>Time</code>类，Java还拥有一个时<code>Calender</code>类。其代表了系统此刻日期对应的日历对象。</p>
<p>其主要有5个方法：</p>
<ol>
<li><code>public get(int filed)</code>：获取日期中的某个字段信息。</li>
<li><code>public void set(int field, int value)</code>：修改日历中的某个字段。</li>
<li><code>public void add(int field, int amount)</code>：为某个字段增加或减少值。</li>
<li><code>public final Date getTime()</code>：获取此刻日期对象。</li>
<li><code>public long getTimeInMillis()</code>：获取此刻时间毫秒值。</li>
</ol>
<h1 id="本地日期"><a href="#本地日期" class="headerlink" title="本地日期"></a>本地日期</h1><p>在Java API中有两种人类时间，本地日期/时间和时区时间。本地日期/时间包含日期和当天的时间。但是与时区信息没有和关系。例如2021年1月1日就是一个本地日期，因为整个日期既没有当天的时间，也没有时区信息，因此它不对应精确的时刻。与之对应的是，2021年1月1日 06:11:11 UTC+8 是一个时区日期/时间，表示的是时间线上的一个精确的时刻。</p>
<p><code>LocalDate</code>对象是带有年月日的日期，用于表示本地日期。</p>
<h2 id="创建LocalDate"><a href="#创建LocalDate" class="headerlink" title="创建LocalDate"></a>创建<code>LocalDate</code></h2><p>可以使用以下两个API构建<code>LocalDate</code>对象</p>
<ul>
<li><code>public static LocalDate now()</code>：获取当前的本地日期对象。</li>
<li><code>public static LocalDate of(int year, int month, int dayOfMonth)</code>：获取指定日期的本地日期对象。</li>
</ul>
<h2 id="改变LocalDate"><a href="#改变LocalDate" class="headerlink" title="改变LocalDate"></a>改变<code>LocalDate</code></h2><p><code>LocalDate</code>有众多的方法用来通过一个<code>LocalDate</code>构建新的<code>LocalDate</code>对象。（注意<code>LocalDate</code>是不可修改，所以以下方法都是返回新的类。）</p>
<ul>
<li><code>public LocalDate plus(TemporalAmount amountToAdd)</code>：产生一个新对象，在原来对象上加一个<code>Peroid</code>对象，参数一般是一个<code>Period</code>对象（<code>Period</code>实现了<code>TemporalAmount</code>接口）。</li>
<li><code>public LocalDate minus(TemporalAmount amountToAdd)</code>：产生一个新对象，在原来对象上减一个<code>Peroid</code>对象，参数一般是一个<code>Period</code>对象（<code>Period</code>实现了<code>TemporalAmount</code>接口）。</li>
<li><code>public LocalDate (plus|minus)(Days|Weeks|Months|Years)(long number)</code>：产生一个新对象，在原来对象上加或减指定的时间单位获得。</li>
<li><code>public LocalDate with(TemporalAdjuster adjuster)</code>：产生一个新对象，按照<code>Peroid</code>对象修改原对象中的数据。</li>
<li><code>with(Year|Month|DayOfMonth|DayOfYear)</code>(int xxx)：产生一个新对象，修改原对象中的数据，注意<code>DayOfMonth</code>表示月份日期（如2022年6月6日），<code>DayOfYear</code>表示年日期（如2022年第5天）。</li>
<li><code>get(Year|Month|MonthValue|DayOfMonth|DayOfYear)()</code>：获取当前对象的对应数据。注意<code>getMonth</code>返回的是<code>Month</code>对象，而<code>getMonthValue</code>返回的是月份的数字（1-12）。<code>getDayOfMonth</code>和<code>getDayOfYear</code>表示分别返回月份日（1-31）和年日期（1-366）。</li>
<li><code>public String format(DateTimeFormatter formatter)</code>：返回格式化的日期。</li>
</ul>
<h2 id="间隔"><a href="#间隔" class="headerlink" title="间隔"></a>间隔</h2><p>本地日期的时长间隔为<code>Period</code>对象（与<code>Instance</code>对象的<code>Duration</code>对象相似）。可以通过以下API创建<code>Period</code>对象：</p>
<ul>
<li><code>public static Period of(int years, int months, int days)</code></li>
<li><code>public static Period of(Year|Month|Weeks|Days)(int xxx)</code></li>
</ul>
<p>并且其也有<code>withXXX</code>来修改数据，<code>plusXXX</code>方法来加数据，<code>minusXXX</code>方法来减数据。</p>
<p>然后可以使用<code>LocalDate</code>的重载方法来使用这个<code>Peroid</code>来改变原数据。</p>
<h1 id="日期调整器"><a href="#日期调整器" class="headerlink" title="日期调整器"></a>日期调整器</h1><p>有些时候需要计算例如“每月的第一个周二”这样的日期。<code>TemporalAdjusters</code>类提供了一些方法来用于计算，具体API如下：</p>
<ul>
<li><code>public static TemporalAdjuster firstDayOfMonth()</code></li>
<li><code>public static TemporalAdjuster lastDayOfMonth()</code></li>
<li><code>public static TemporalAdjuster firstDayOfNextMonth()</code></li>
<li><code>public static TemporalAdjuster firstDayOfYear()</code></li>
<li><code>public static TemporalAdjuster lastDayOfYear()</code></li>
<li><code>public static TemporalAdjuster firstDayOfNextYear()</code></li>
<li><code>public static TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)</code></li>
<li><code>public static TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)</code></li>
<li><code>public static TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)</code></li>
<li><code>public static TemporalAdjuster next(DayOfWeek dayOfWeek)</code></li>
<li><code>public static TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek)</code></li>
<li><code>public static TemporalAdjuster previous(DayOfWeek dayOfWeek)</code></li>
<li><code>public static TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek)</code></li>
</ul>
<p>（这些方法看名字就可以很明显的看出其功能，就不再介绍）</p>
<p>注意这些方法都返回了一个<code>TemporalAdjuster</code>方法，我们需要将其传递给<code>LocalDate.with</code>方法以获得一个新的<code>LocalDate</code>对象。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate nowDate = LocalDate.of(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">TemporalAdjuster a = TemporalAdjusters.firstDayOfNextMonth();</span><br><span class="line">LocalDate newDate = nowDate.with(a);</span><br><span class="line">System.out.println(newDate);					<span class="comment">//2000-02-01</span></span><br></pre></td></tr></table></figure>
<h2 id="创建自定义调整器"><a href="#创建自定义调整器" class="headerlink" title="创建自定义调整器"></a>创建自定义调整器</h2><p>还可以通过实现<code>TemporalAdjuster</code>接口来创建自定义的调整器。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TempoalAdjuster NEXT_WEORKDAY = w -&gt; &#123;</span><br><span class="line">    LocalDate res = w;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        res = res.plusDays(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.getDayOfWeek().getValue() &gt;= <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是w原本是一个Temporal类型，我们需要将其转为<code>LocalDate</code>对象（<code>LocalDate</code>也实现了<code>Temporal</code>接口）。</p>
<h1 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h1><p><code>LocalTime</code>表示当前时刻。如：<code>15:30:00</code>。</p>
<h2 id="创建LocalTime"><a href="#创建LocalTime" class="headerlink" title="创建LocalTime"></a>创建<code>LocalTime</code></h2><p>可以使用<code>of</code>和<code>now</code>来创建<code>LocalTime</code>对象。</p>
<ul>
<li><code>public static LocalTime now()</code></li>
<li><code>public static LocalTime of(int hour, int minute)</code></li>
<li><code>public static LocalTime of(int hour, int minute, int second)</code></li>
<li><code>public static LocalTime of(int hour, int minute, int second, int nanoOfSecond)</code></li>
</ul>
<p>用法基本与<code>LocalDate</code>一致，只是参数不同。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><code>LocalTime</code>也是拥有<code>with</code>、<code>minus</code>、<code>plus</code>、<code>get</code>、<code>to</code>系列方法。</p>
<p>值得注意的是<code>get</code>和<code>to</code>系列方法的设计。</p>
<ul>
<li><code>get()</code>可以传入<code>TemporalField</code>对象来获取对应域（如时分秒）的值。也可以用<code>get(Hour|Minutes|Second|Nano)</code>方法来获取对应域的值。</li>
<li><code>to</code>方法有两个方法:<ul>
<li><code>public int toSecondOfDay()</code>：获取当前对应于一天中的多少秒。</li>
<li><code>public long toNanoOfDay()</code>：获取当前对应于一天中的多少纳秒</li>
</ul>
</li>
</ul>
<h1 id="时区时间"><a href="#时区时间" class="headerlink" title="时区时间"></a>时区时间</h1><p>在Java中，用<code>ZonedDateTime</code>来表示时区日期。其大部分方法都与<code>LocalDateTime</code>（相当于<code>LocalDate</code>与<code>LocalTime</code>的结合）的方法相同。不同的是必须传入一个时区ID。这个ID可以从<code>ZonedId</code>对象中获取。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZonedDateTime skipped = ZonedDateTime.of(</span><br><span class="line">	LocalDate.of(<span class="number">2013</span>, <span class="number">3</span>, <span class="number">31</span>),</span><br><span class="line">    LocalTime.of(<span class="number">2</span>, <span class="number">30</span>),</span><br><span class="line">    ZonedId.of(<span class="string">"Europe/Berlin"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h2><p>一个时区的时间与另外时区的时间是不同的，而且设计夏令时问题。所以一般使用<code>withZoneSameLocal(ZoneId)</code>方法来进行转换。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以中国时区获取当前时间:</span></span><br><span class="line">ZonedDateTime Shanghai = ZonedDateTime.now(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line"><span class="comment">// 转换为纽约时间:</span></span><br><span class="line">ZonedDateTime NewYork = Shanghai.withZoneSameInstant(ZoneId.of(<span class="string">"America/New_York"</span>));</span><br><span class="line">System.out.println(Shanghai);</span><br><span class="line">System.out.println(NewYork);</span><br></pre></td></tr></table></figure>
<h1 id="本地日期时间"><a href="#本地日期时间" class="headerlink" title="本地日期时间"></a>本地日期时间</h1><p><code>LocalDateTime</code></p>
<p>LocalDateTime可以存储日期和时间，其中时间包括秒后10位。比如：<code>2nd October 2007 at 13:45.30.123456789</code></p>
<p>其用法和<code>LocalDate</code>基本一致。</p>
<h1 id="格式化和解析"><a href="#格式化和解析" class="headerlink" title="格式化和解析"></a>格式化和解析</h1><p>日期时间的格式化采用的是<code>DateTimeFormatter</code>类。</p>
<p><code>DateTimeFormatter</code>类提供了是三种用于打印日期/时间值的格式器：</p>
<ul>
<li>预定义的格式。</li>
<li><code>locale</code>相关的格式器。</li>
<li>带有定制模式的格式器。</li>
</ul>
<h2 id="预定义的格式"><a href="#预定义的格式" class="headerlink" title="预定义的格式"></a>预定义的格式</h2><p>下面是预定义的格式器</p>
<p><img src="\images\java核心技术\预定义的格式器.jpg" alt="预定义的格式器"></p>
<p>要使用标准的格式，可以世界调用其<code>format</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">String formatted = DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(localDateTime);		<span class="comment">//20220216</span></span><br></pre></td></tr></table></figure>
<p>标准格式器主要是为了机器可读的时间戳而设计的。</p>
<h2 id="locale相关的格式器"><a href="#locale相关的格式器" class="headerlink" title="locale相关的格式器"></a><code>locale</code>相关的格式器</h2><p>对于日期和时间而言，有4种locale相关的格式化风格，即<code>SHORT</code>、<code>MEDIUM</code>、<code>LONG</code>和<code>FULL</code>。见下表：</p>
<p><img src="\images\java核心技术\locale相关的格式化风格.jpg" alt="locale相关的格式化风格"></p>
<p>使用<code>ofLocalizedDate</code>、<code>ofLocalizedTime</code>和<code>ofLocalizedDateTime</code>可以创建这种格式。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG);</span><br><span class="line">String reString1 = formatter.format(localDateTime);</span><br><span class="line">System.out.println(reString1);			<span class="comment">//February 16, 2022</span></span><br></pre></td></tr></table></figure>
<p>这里使用了默认的locale，为了切换locale，可以直接使用<code>withLocale</code>方法。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String reString2 = formatter.withLocale(Locale.CHINA).format(localDateTime);</span><br><span class="line"><span class="comment">//2002年2月16日</span></span><br></pre></td></tr></table></figure>
<h2 id="定制日期格式"><a href="#定制日期格式" class="headerlink" title="定制日期格式"></a>定制日期格式</h2><p>在自定义格式中，规定了特定字母表达的日期中的部分，例如<code>yyyy</code>表示<code>2000</code>年这种格式。</p>
<p>所以，一个经典的例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">formatter = DateTimeFormatter.ofPattern(<span class="string">"E yyyy-MM--dd HH:mm"</span>);</span><br></pre></td></tr></table></figure>
<p>具体所有格式化符号如下表。</p>
<p><img src="\images\java核心技术\常用的日期时间格式的格式化符号.jpg" alt="常用的日期时间格式的格式化符号"></p>
<h2 id="解析字符串"><a href="#解析字符串" class="headerlink" title="解析字符串"></a>解析字符串</h2><p>可以利用日期格式来解析对应的字符串。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate churchsBirthday = LocalDate.parse(<span class="string">"1903-06-14"</span>);</span><br><span class="line">ZonedDateTime apollolllauch = ZonedDateTime.parse(<span class="string">"1969-07-16 03:32:00-0400"</span>, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ssxx"</span>));</span><br></pre></td></tr></table></figure>
<p>第一个例子使用了标准的<code>ISO_LOCAL_DATE</code>格式器，而第二个调用了一个自定义的格式器。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>日期和时间API</tag>
      </tags>
  </entry>
  <entry>
    <title>java的正则表达式</title>
    <url>/2021/09/19/java%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h2><p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String regexPat = <span class="string">"\\abc"</span></span><br><span class="line"><span class="keyword">private</span> Pattern pattern = Pattern.compile(regexPat);</span><br></pre></td></tr></table></figure>
<h2 id="Matcher-类"><a href="#Matcher-类" class="headerlink" title="Matcher 类"></a>Matcher 类</h2><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
<h2 id="PatternSyntaxException"><a href="#PatternSyntaxException" class="headerlink" title="PatternSyntaxException"></a>PatternSyntaxException</h2><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
<h1 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h1><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p>
<p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p>
<ul>
<li>((A)(B(C)))</li>
<li>(A)</li>
<li>(B(C))</li>
<li>(C)</li>
</ul>
<p>可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。</p>
<p>还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。</p>
<h1 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h1>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-II-8-脚本、编译和注解处理</title>
    <url>/2022/02/17/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-8-%E8%84%9A%E6%9C%AC%E3%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="Java平台的脚本机制"><a href="#Java平台的脚本机制" class="headerlink" title="Java平台的脚本机制"></a>Java平台的脚本机制</h1><p>Java平台的脚本API可以使之运行诸如JavaScript和Groovy这样的脚本语言代码。</p>
<p>脚本语言是一种在运行时解释程序文本，从而避免了编译、链接等步骤。其具有以下优势：</p>
<ul>
<li>便于快速变更，鼓励不断实验。</li>
<li>可以修改运行着的程序的行为。</li>
<li>支持程序用户的定制化。</li>
</ul>
<h2 id="获取脚本引擎"><a href="#获取脚本引擎" class="headerlink" title="获取脚本引擎"></a>获取脚本引擎</h2><p>脚本引擎是一个可以执行特定语言编写的脚本的类库。当虚拟机启动的时候，它会发现可以用的脚本引擎。为了枚举这些引擎，需要构造一个<code>ScriptEngineManager</code>，并调用<code>getEngineFactories</code>方法。可以向每个引擎工厂询问它们所支持的引擎名、MIME类型和文件扩展名。</p>
<p>下表显示对应的典型值的表格。</p>
<table>
<thead>
<tr>
<th>引擎</th>
<th>名字</th>
<th>MIME类型</th>
<th>文件扩展</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Nashorm</code>（包含在JDK中，从jdk6开始，jdk11开始标记将要移除，jdk17已移除）</td>
<td><code>narsh，Nashorn，js，JS，JavaScript，javascript，ECMAScript，ecmascript</code></td>
<td><code>application/javascript, application/ecmascript, text/javascript, text/ecmascript</code></td>
<td><code>js</code></td>
</tr>
<tr>
<td><code>Groovy</code></td>
<td><code>groovy</code></td>
<td>无</td>
<td>groovy</td>
</tr>
<tr>
<td><code>Renjin</code></td>
<td><code>Renjin</code></td>
<td><code>text/x-R</code></td>
<td><code>R, r, S, s</code></td>
</tr>
</tbody>
</table>
<p>通常，你可以所需要的引擎，因此可以直接通过名字、<code>MIME</code>类型或文件扩展来请求它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScriptEngineManager manager = <span class="keyword">new</span> ScriptEngineManager();</span><br><span class="line">ScriptEngine engine = manager.getEngineByName(<span class="string">"nashron"</span>);</span><br></pre></td></tr></table></figure>
<p>Java8引入了<code>Nashorn</code>，这是由<code>Oracle</code>开发的一个<code>JavaScript</code>解释器。可以通过在类路径中提供必要的JAR文件来添加更多语言的支持。</p>
<h2 id="脚本计算和绑定"><a href="#脚本计算和绑定" class="headerlink" title="脚本计算和绑定"></a>脚本计算和绑定</h2><h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><p>可以分别从字符串或者文件中执行脚本。</p>
<h3 id="从字符串执行脚本"><a href="#从字符串执行脚本" class="headerlink" title="从字符串执行脚本"></a>从字符串执行脚本</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object result = engine.eval(scriptString);</span><br></pre></td></tr></table></figure>
<h3 id="从文件执行脚本"><a href="#从文件执行脚本" class="headerlink" title="从文件执行脚本"></a>从文件执行脚本</h3><p>首先要从文件中获得一个<code>Reader</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object result = engine.eval(reader);</span><br></pre></td></tr></table></figure>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>值得的注意的是，大部分引擎的上下文都是同一个。即多次执行是在同一个上下文中进行的，所以其变量也会被共享。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">engine.eval(<span class="string">"n = 1728"</span>);</span><br><span class="line">Object result = engien.eval(<span class="string">"n + 1"</span>);		<span class="comment">//1729</span></span><br></pre></td></tr></table></figure>
<h3 id="与上下文变量交换"><a href="#与上下文变量交换" class="headerlink" title="与上下文变量交换"></a>与上下文变量交换</h3><h4 id="添加变量"><a href="#添加变量" class="headerlink" title="添加变量"></a>添加变量</h4><p>不光可以使用脚本语法申明变量，也可以通过Java的API来为其添加变量。</p>
<p>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">engine.pus(<span class="string">"k"</span>, <span class="number">1728</span>);</span><br></pre></td></tr></table></figure>
<h4 id="取变量"><a href="#取变量" class="headerlink" title="取变量"></a>取变量</h4><p>可以从脚本上下文取变量</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object result = engine.get(<span class="string">"k"</span>);</span><br></pre></td></tr></table></figure>
<p>注意：如果需要自定义作用域，可以自定义一个实现了<code>ScriptContext</code>接口，并管理一个作用域集合。每个作用域都是由一个整数标识的，而且数字越小应该越先被搜索到。（标准库提供了<code>SimpleScriptConext</code>类，但是它只能持有全局作用域和引擎作用域）</p>
<h2 id="重定向输入和输出"><a href="#重定向输入和输出" class="headerlink" title="重定向输入和输出"></a>重定向输入和输出</h2><p>可以通过调用脚本上下文的<code>setReader</code>和<code>setWriter</code>方法来重定向脚本的标准输入和输出。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">engine.getContext().setWriter(<span class="keyword">new</span> PrintWriter(writer, <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure>
<p>在上例中，JavaScript的<code>console.log</code>产生的输出都将被发送到<code>writer</code>。</p>
<p><code>Nashorn</code>引擎没有标准输入源的概念，因此调用<code>setReader</code>没有任何效果。</p>
<h2 id="调用脚本的函数和方法"><a href="#调用脚本的函数和方法" class="headerlink" title="调用脚本的函数和方法"></a>调用脚本的函数和方法</h2><p>有两个方法用于触发脚本语言的方法。</p>
<ul>
<li><code>invokeFunction</code>：面向函数式编程。</li>
<li><code>invokeMethod</code>：面向对象编程，可以调用某个对象上的方法。</li>
</ul>
<p>如：</p>
<p>例1：<code>invokeFcuntion</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">engine.eval(<span class="string">"function greet(how, whom)&#123;return how + ', ' + whom + '!'&#125;"</span>);</span><br><span class="line">Invocable res = ((Invocable)engine).invokeFunction(<span class="string">"greet"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>
<p>例2：<code>invokeMethod</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">engine.eval(<span class="string">"function Greeter(how)&#123;this.how = how&#125;"</span>);</span><br><span class="line">engine.eval(<span class="string">"Greeter.prototype.welcome = function(whom)&#123;return this.how + ', ' + whom + '!'&#125;"</span>);</span><br><span class="line">Object yo = engine.eval(<span class="string">"new Greeter('Yo')"</span>);</span><br><span class="line">res = ((Invocable) engine).invokeMethod(yo, <span class="string">"welcome"</span>, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>
<p> 并且还可以用脚本引擎来实现Java的接口，然后调用其方法。</p>
<p>如下接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greeter</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">welcome</span><span class="params">(String whom)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">engine.eval(<span class="string">"function welcome(whom)&#123;return 'Hello, ' + whom + '!'&#125;"</span>);</span><br><span class="line">Greeter g = ((Invocable)engine).getInterface(Greeter<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">Object res = g.welcome(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h2><p>某些脚本引擎处于对执行效率的考虑，可以将脚本代码编译为某种中间格式。这些引擎实现了<code>Compilable</code>接口。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reder = <span class="keyword">new</span> FileReader(<span class="string">"script.js"</span>);</span><br><span class="line">CompiledScript  script = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(engine implements Compilable)&#123;</span><br><span class="line">    script = ((Compilable)engine).compile(reader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦该脚本被编译，就可以执行它。例如下面的代码展示了如果可以编译就执行编译后的结果，否则执行原始脚本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(script != <span class="keyword">null</span>)&#123;</span><br><span class="line">    script.eval();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    engine.eval(reder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编译器API"><a href="#编译器API" class="headerlink" title="编译器API"></a>编译器API</h1><p>可以在Java代码中编译Java代码。</p>
<h2 id="调用编译器"><a href="#调用编译器" class="headerlink" title="调用编译器"></a>调用编译器</h2><p>调用编译器API非常简单，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaScompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">OutputStream outStream = ...;</span><br><span class="line">OutputStream errStream = ...;</span><br><span class="line"><span class="keyword">int</span> result = compiler.run(<span class="keyword">null</span>, outStream, errStream, <span class="string">"-sourcepath"</span>, <span class="string">"src"</span>, <span class="string">"Test.java"</span>);</span><br></pre></td></tr></table></figure>
<p>返回值为0则表示成功。</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种<strong>注释机制</strong>。<br>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p>
<h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p> 在Java中，注解是当作修饰符来使用的。他被置于被备注项之前，中间没有分号（修饰符就是诸如<code>public</code>和<code>static</code>之类的关键词）。每个注解的名称前面都加上了@符号。这有点类似于Javadoc注释出现在<code>/**...*/</code>之间定界符的内部，而注解是代码的一部分。</p>
<p>注解可以定位包含元素的形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(timeout = <span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这些元素可以被读取这些注解的工具去处理。</p>
<h2 id="注解语法"><a href="#注解语法" class="headerlink" title="注解语法"></a>注解语法</h2><h3 id="注解接口-注解定义"><a href="#注解接口-注解定义" class="headerlink" title="注解接口-注解定义"></a>注解接口-注解定义</h3><p>注解是由注解接口来定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">modifiers <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">    elementDeclatarion1;</span><br><span class="line">    elementDeclatarion2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个元素申明都具有下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">elementName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>或者附带默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">elementName</span><span class="params">()</span> <span class="keyword">default</span> value</span>;</span><br></pre></td></tr></table></figure>
<p>例如，下面的注解具有两个元素：<code>assignedTo</code>和<code>severity</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BugReport&#123;</span><br><span class="line">    <span class="function">String <span class="title">assignedTo</span><span class="params">()</span> <span class="keyword">default</span> "[none]"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">severity</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的注解接口都隐式的扩展自<code>java.lang.annotation.Annotation</code>接口。这个接口是一个常规接口，不是一个注解接口。</p>
<p>不必要为注解接口提供实现类。</p>
<p>注解元素的类型为下列之一“</p>
<ul>
<li>基本类型（<code>int</code>、<code>short</code>、<code>long</code>、<code>byte</code>、<code>char</code>、<code>double</code>、<code>float</code>或者<code>boolean</code>）。</li>
<li><code>String</code>。</li>
<li><code>Class</code>（具有一个可选的类型参数，如<code>Class&lt;? extends MyClass&gt;</code>）。</li>
<li><code>enum</code>类型。</li>
<li>由前面提到的类型构成的数组。</li>
</ul>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BugReport&#123;</span><br><span class="line">    <span class="keyword">enum</span> Status &#123;UNCONFIRMED, CONFIMED, FIXED, NOTABUG&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">showStopper</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    String assignedTo <span class="keyword">default</span> <span class="string">"[none]"</span>;</span><br><span class="line">    <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">default</span> Status.UNCONFIRMED</span>;</span><br><span class="line">    String[] reportedBy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义注解位置"><a href="#定义注解位置" class="headerlink" title="定义注解位置"></a>定义注解位置</h3><p>注解可以出现在很多地方，这些地方可以分为两类：声明和类型用法声明注解可以出现在下列声明处：</p>
<ul>
<li>包</li>
<li>类（包括<code>enum</code>）</li>
<li>接口（包括注解接口）</li>
<li>方法</li>
<li>构造器</li>
<li>实例域（包含num常量）</li>
<li>局部变量</li>
<li>参数变量</li>
<li>类型参数</li>
</ul>
<p>对于类和接口，需要将注解放置在class和interface关键词的前面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于变量，需要将其放置在类型的前面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) List&lt;User&gt; user = ...;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@Param(<span class="string">"id"</span>)</span> String userId</span>;)</span><br></pre></td></tr></table></figure>
<p>泛型类或方法中的类型参数可以像下面这样被注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;@<span class="title">Immutable</span> <span class="title">V</span>&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>包是在文件<code>packge-info.java</code>中注解的，该文件中只包含注解先导的包语句，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	Packge-level javadoc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GPL</span>(version = <span class="string">"3"</span>)</span><br><span class="line"><span class="keyword">package</span> priv.xxx.xxx;</span><br><span class="line"><span class="keyword">import</span> org.gun.GPL;</span><br></pre></td></tr></table></figure>
<h3 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h3><p>每个注解都具有下面的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@annotationName</span>(elementName1 = value1, elementName2 = value2)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BugReported</span>(assignedTo=<span class="string">"Harry"</span>, severity=<span class="string">"10"</span>)</span><br></pre></td></tr></table></figure>
<p>参数元素的顺序无关紧要。</p>
<p>如果某个值没有指定，就是用默认值。如<code>@BugReported(severity=&quot;10&quot;)</code>中<code>assignedTo</code>元素默认值为<code>&quot;[none]&quot;</code>。</p>
<p>注意：默认值并不是和注解存储在一起的。相反地，它们是动态计算而来得到。例如，如果将<code>assignedTo</code>的默认值改为<code>[]</code>，那么不仅后面声明的为<code>[]</code>，之前申明的也为<code>[]</code>了。</p>
<p>注解有两种特殊形式：</p>
<ul>
<li><code>@annotation</code>：（标记注解）表示所有元素都用默认参数。</li>
<li><code>@annotation(value)</code>：（单值注解）如果一个元素名字为<code>value</code>，那么可以直接在括号中进行赋值。</li>
</ul>
<p>还有两点值得注意：</p>
<ol>
<li><p>数组的赋值：对于数组的赋值可以采用以下格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BugReported</span>(..., repotedBy=&#123;<span class="string">"Harry"</span>, <span class="string">"Carl"</span>&#125;)			<span class="comment">//多值数组</span></span><br><span class="line"><span class="meta">@BugReported</span>(..., repotedBy=<span class="string">"Harry"</span>)					<span class="comment">//单值数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注解的嵌套</p>
<p>由于一个注解元素可以是另一个注解，那么可以创建出任意复杂的注解，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BugReported</span>(ref=<span class="meta">@Reference</span>(id=<span class="string">"213213"</span>), ...)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h2><p>Java SE在<code>java.lang</code>、<code>java.lang.annotation</code>和<code>javax.annotation</code>包中定义了大量的注解接口。其中四个是元注解，用于描述注解接口的行为属性，其他的三个是规则接口，可以用它们来注解你的源代码中的项。</p>
<table><br><tbody><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle"><strong><span style="font-size: 16px">注 解 接 口</span></strong></td><br><td style="width: 200px" align="center" valign="middle"><strong><span style="font-size: 16px">应 用 场 景</span></strong></td><br><td style="width: 350px" align="center" valign="middle"><strong><span style="font-size: 16px">目 的</span></strong></td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle">Deprecated</td><br><td style="width: 200px" align="left" valign="middle">全部</td><br><td style="width: 350px">将项标记为过时的</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle">SuppressWarnings</td><br><td style="width: 200px" align="left" valign="middle">除了包和注解之外的所有情况</td><br><td style="width: 350px">阻止某个给定类型的警告信息</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle">Override</td><br><td style="width: 200px" align="left" valign="middle">方法</td><br><td style="width: 350px">检查该方法是否覆盖了某一个超类方法</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle">PostConstruct</td><br><td style="width: 200px" rowspan="2" align="left" valign="middle">方法</td><br><td style="width: 350px">被标记的方法应该在构造之后立即被调用</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle">PreDestroy</td><br><td style="width: 350px">被标记的方法应该在移除之前立即被调用</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle">Resource</td><br><td style="width: 200px" align="left" valign="middle">类、接口、方法、域</td><br><td style="width: 350px"><br><p>在类或者接口上：标记为在其他地方要用到的资源</p><br><p>在方法或者域上 ：为 “注入” &nbsp;而标记</p><br></td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle">Resources</td><br><td style="width: 200px" align="left" valign="middle">类、接口</td><br><td style="width: 350px">一个资源组</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle">Grenerated</td><br><td style="width: 200px" align="left" valign="middle">全部</td><br><td style="width: 350px">&nbsp;</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle"><span style="color: rgba(255, 0, 0, 1)">Target</span></td><br><td style="width: 200px" align="left" valign="middle">注解</td><br><td style="width: 350px">指明可以应用这个注解的那些项</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle"><span style="color: rgba(255, 0, 0, 1)">Retention</span></td><br><td style="width: 200px" align="left" valign="middle">注解</td><br><td style="width: 350px">指明这个注解可以保留多久</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle"><span style="color: rgba(255, 0, 0, 1)">Documented</span></td><br><td style="width: 200px" align="left" valign="middle">注解</td><br><td style="width: 350px">指明这个注解应该包含在注解项的文档中</td><br></tr><br><tr><br><td style="width: 200px; height: 30px" align="center" valign="middle"><span style="color: rgba(255, 0, 0, 1)">Inherited</span></td><br><td style="width: 200px" align="left" valign="middle">注解</td><br><td style="width: 350px">指明当这个注解应用于一个类的时候，能够在被他的子类继承</td><br></tr><br></tbody><br></table>

<h2 id="用于编译的注解"><a href="#用于编译的注解" class="headerlink" title="用于编译的注解"></a>用于编译的注解</h2><ul>
<li><code>@Deprecated</code>注解可以被添加到任何不再鼓励使用的项上。这个注解与<code>JavaDoc</code>的<code>@deprecated</code>效果相同。</li>
<li><code>@SuppressWarning</code>注解会告知编译器阻止特定类型的警告信息。</li>
<li><code>@Override</code>用于方法上，编译器会检查具有这种注解的方式是否真的覆盖了一个来自超类的方法。</li>
<li><code>@Generated</code>注解的目的是共提供代码生成的工具来使用。任何生成的源代码都可以被注解，从而与程序员提供的代码区分开。例如，代码编辑器可以隐藏生成的代码，或者代码生成器可以移除生成代码的旧版本。</li>
</ul>
<h2 id="用于管理资源注解"><a href="#用于管理资源注解" class="headerlink" title="用于管理资源注解"></a>用于管理资源注解</h2><ul>
<li><code>@PostConstruct</code>和<code>@PreDestroy</code>注解用于控制对象生命周期的环境中。</li>
<li><code>@Resource</code>注解用于资源的注入。</li>
</ul>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p><code>@Target</code> 表示该注解用于什么地方，可能的值在枚举类 <code>ElemenetType</code> 中，包括：</p>
<ul>
<li><code>ElemenetType.CONSTRUCTOR</code>—————————–构造器声明 </li>
<li><code>ElemenetType.FIELD</code> ———————————-域声明（包括 enum 实例） </li>
<li><code>ElemenetType.LOCAL_VARIABLE</code>————————- 局部变量声明 </li>
<li><code>ElemenetType.METHOD</code> ———————————方法声明 </li>
<li><code>ElemenetType.PACKAGE</code> ——————————–包声明 </li>
<li><code>ElemenetType.PARAMETER</code> ——————————参数声明 </li>
<li><code>ElemenetType.TYPE</code>  ———————————– 类，接口（包括注解类型）或enum声明  </li>
</ul>
<p><code>@Retention</code> 表示在什么级别保存该注解信息。可选的参数值在枚举类型 <code>RetentionPolicy</code> 中，包括：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>————-注解将被编译器丢弃 </li>
<li><code>RetentionPolicy.CLASS</code> ————-注解在class文件中可用，但会被VM丢弃 </li>
<li><code>RetentionPolicy.RUNTIME</code> ———VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。</li>
</ul>
<p><code>@Documented</code> 将此注解包含在 <code>javadoc</code> 中 ，它代表着此注解会被<code>javadoc</code>工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。</p>
<p><code>@Inherited</code> 允许子类继承父类中的注解。即如果一个类具有继承注解，那么它的子类都自动具有同样的注解。</p>
<h2 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h2><p>在定义和使用注解后，我们需要考虑如何去读取传入注解的信息。</p>
<p>一般来说，我们使用反射来获取注解列表和注解中的信息。</p>
<p>但是要注意，要使用反射来获取注解，则必须将注解标记为<code>RetentionPolicy.RUNTIME</code>，这样其生命周期才会到达虚拟机可到达位置，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Annotaiaon1 &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以通过以下API获取注解：</p>
<ol>
<li><p><code>Annotation[] getAnnotations()</code> ：返回该元素上的所有注解（包括继承的注解）</p>
</li>
<li><p><code>Annotation getAnnotation(Class&lt;A&gt; annotationClass)</code>：返回该元素上的对应类别的注解（包括继承的注解）</p>
</li>
<li><p><code>Annotation getDeclaredAnnotation(Class&lt;A&gt; annotationClass)</code>：返回该元素上的所有注解（不包括继承的注解）</p>
</li>
<li><p><code>Annotation getDeclaredAnnotationsByType(Class&lt;A&gt;)</code>：返回该元素上的对应类别的第一个注解（不包括继承的注解）</p>
</li>
<li><p><code>Annotation[] getDeclaredAnnotations()</code>：返回该元素上的对应类别的所有注解（不包括继承的注解）</p>
</li>
</ol>
<p>实际上上面的方法还要更复杂一些：</p>
<p><img src="../images/java核心技术/注解方法.jpg" alt="注解方法"></p>
<p>对于上面的<code>Kind of Presence</code>的解释如下：</p>
<ul>
<li>直接出现（directly present）：直接加在该元素的上面得注解。</li>
<li>间接出现（indirectly present）：加载该元素上的注解中，其中一个注解的的参数是注解A，则该注解被称为间接出现。</li>
<li>出现（present）：<ul>
<li>直接出现。</li>
<li>父类继承的注解。</li>
</ul>
</li>
<li>关联（associated）：<ul>
<li>直接或者间接出现</li>
<li>父类继承的注解。</li>
</ul>
</li>
</ul>
<p>通过这些API我们可以获得<code>Annotation</code>对象。注意这里赋值就直接赋值给我们自定义的注解类型了。在此之前，我们可以通过以下API来判断是否存在对应的注解：</p>
<ul>
<li><code>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></li>
</ul>
<p>如果存在，则使用上面的2来获取对应的注解，然后通过注解定义的域来获取传入的值。</p>
<p>例如：</p>
<p><code>Annotation1.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Annotaiaon1 &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Dog.java</code>-使用注解的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mw;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Annotaiaon</span>1(<span class="string">"123"</span>)</span><br><span class="line"><span class="meta">@Annotation</span>2(<span class="string">"000"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Integer idInteger;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class dog = Class.forName(<span class="string">"mw.Dog"</span>);</span><br><span class="line"><span class="keyword">if</span>(dog.isAnnotationPresent(Annotaiaon1<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">    Annotaiaon1 anno = (Annotaiaon1) dog.getAnnotation(Annotaiaon1<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    String value = anno.value();</span><br><span class="line">    System.out.println(<span class="string">"存在annotation1注解，value= "</span> + value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"不存在annotation1注解"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>脚本、编译和注解处理</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-I-9-集合</title>
    <url>/2022/01/24/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-9-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="集合接口与实现分离"><a href="#集合接口与实现分离" class="headerlink" title="集合接口与实现分离"></a>集合接口与实现分离</h2><p>Java集合类库也将接口与实现分离。</p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>在Java类库中，集合类的基本接口是<code>Collection</code>接口。这个接口有两个<strong>基本方法</strong>：</p>
<ul>
<li><code>boolean add(E element);</code></li>
<li><code>Iterator&lt;E&gt; ietrator();</code></li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Iterator接口包含4个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Cusumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过反复调用next方法，可以逐个访问集合中的每个元素。</p>
<p>但是如果达到了集合的末尾，next方法将抛出一个<code>NoSuchElementException</code>。所以可以在调用next方法之前调用hasNext方法来判定是否有一下个元素。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">  String element = iter.next();</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>但是在jdk5中引入了增强for循环：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">for</span>(String element : c)&#123;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器简单地将<code>for each</code>循环转换为带有迭代器的循环。增强for循环可以处理任何带有低迭代器的循环。</p>
<p>使用<code>forEachRemaining</code>来便利。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line">iter.forEachRemaining(ele -&gt; <span class="keyword">do</span> something);</span><br></pre></td></tr></table></figure>
<p>Iteratot的next方法和hasNext方法与Enumeration接口的nextElement和hasMoreElements方法的作用一样。而Iterator接口的设计初衷就是为了用更短的名称代替它。</p>
<blockquote>
<p>其实迭代器的方式与流的读取类似。每用一次都会消耗掉一个元素。</p>
</blockquote>
<h2 id="泛型使用方法"><a href="#泛型使用方法" class="headerlink" title="泛型使用方法"></a>泛型使用方法</h2><p>由于<code>Collection</code>与<code>Iterator</code>都是泛型接口，这意味着可以编写处理任何集合类型的使用方法。</p>
<p><code>Collection</code>接口内部定义很多实用的方法。如：</p>
<ul>
<li><code>int size();</code></li>
<li><code>boolean isEmpty();</code></li>
<li><code>blooean contains();</code></li>
<li><code>boolean equals();</code></li>
<li>…</li>
</ul>
<p>但是由于每个子类都要实现这些方法，所以又定义了<code>AbstractCollection</code>抽象类。其保持了那些基础的方法，比如<code>size</code>和<code>Iterator</code>。但是实现了其他的例行方法。</p>
<p>这样具体类可以扩展<code>AbstractCollection</code>类。</p>
<h1 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h1><p>Java集合框架为不同类型的集合定义了大量接口。如下</p>
<p><img src="/images/java核心技术/集合框架的接口.jpg" alt="集合框架的接口"></p>
<p>其主要有两个基本接口，<code>Collection</code>和<code>Map</code>。其子结构的介绍如下</p>
<ul>
<li><code>Collection</code>：表示单个值的集合。<ul>
<li><code>List</code>： 是一个有序集合。元素会增加到指定的特定位置。</li>
<li><code>Set</code>： 无序但其内部元素不允许重复。</li>
<li><code>Queue</code>：队列。</li>
</ul>
</li>
<li><code>Map</code> ：表示键值对的集合。</li>
</ul>
<h2 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h2><p>下面的表格简单介绍了Java库的一部分具体集合</p>
<table>
<thead>
<tr>
<th>接口类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ArrayList</code></td>
<td>可以动态增加和缩减的一个索引序列。</td>
</tr>
<tr>
<td><code>LinkedList</code></td>
<td>可以在任何位置高效插入和删除的一个有序序列。</td>
</tr>
<tr>
<td><code>ArrayDeque</code></td>
<td>实现为循环数组的一个双端队列。（Deque-&gt;Queue-&gt;Collection）</td>
</tr>
<tr>
<td><code>Stack</code></td>
<td>一个栈的实现。（List）</td>
</tr>
<tr>
<td><code>HashSet</code></td>
<td>没有重复元素的一个无序集合。</td>
</tr>
<tr>
<td><code>TreeSet</code></td>
<td>一个有序树集。</td>
</tr>
<tr>
<td><code>EnumSet</code></td>
<td>一个包含枚举类型值的集合。</td>
</tr>
<tr>
<td><code>LinkedHashSet</code></td>
<td>一个可以记住元素插入次序的集合。(HashSet，-&gt;Set)</td>
</tr>
<tr>
<td><code>PriorityQueue</code></td>
<td>允许高效删除最小元素的一个集合。(AbstractQueue-&gt;Queue-&gt;Collection)</td>
</tr>
<tr>
<td><code>HashMap</code></td>
<td>存储键/值对的一个数据结构。</td>
</tr>
<tr>
<td><code>TreeMap</code></td>
<td>键有序的一个映射。</td>
</tr>
<tr>
<td><code>EnumMap</code></td>
<td>键属于枚举类型的一个映射。</td>
</tr>
<tr>
<td><code>LinkedHashMap</code></td>
<td>可以记住键值对添加次序的一个映射。</td>
</tr>
<tr>
<td><code>WeakHashMap</code></td>
<td>值不在别处使用时就可以被垃圾回收的一个映射。</td>
</tr>
<tr>
<td><code>IdentityHashMap</code></td>
<td>用==而不是equls比较键的一个映射。（即比较地址，并不是相等）</td>
</tr>
</tbody>
</table>
<h3 id="链表（LinkedList）"><a href="#链表（LinkedList）" class="headerlink" title="链表（LinkedList）"></a>链表（<code>LinkedList</code>）</h3><p>链表的实现与<code>ArrayList</code> 不同，其是由节点一个个连接起来的链。所以其特点也与数组列表不同。</p>
<p>具体链表和数组的为什么会出现这些特点不再赘述，基本知识。其知识如下：</p>
<ol>
<li>链表插入和删除更快。</li>
<li>链表不能直接按下标查找值，需要遍历。</li>
</ol>
<h3 id="数组列表（ArrayList）"><a href="#数组列表（ArrayList）" class="headerlink" title="数组列表（ArrayList）"></a>数组列表（<code>ArrayList</code>）</h3><p>这个类的底层是用数组实现的，因此可以直接实现按下表查找值。</p>
<p>注意：<code>vector</code>也可以实现动态数组，但是vector是同步的，所以在不需要多线程访问的时候，即不需要同步的时候，选择<code>ArrayList</code> 效率更高。因为其不需要同步。（vector是老版本的结构，建议使用新的ArrayList）</p>
<h3 id="散列集（HashSet）"><a href="#散列集（HashSet）" class="headerlink" title="散列集（HashSet）"></a>散列集（<code>HashSet</code>）</h3><p><code>HashSet</code> 是利用了hash table的原理，具体原理也是基础知识，不再赘述。</p>
<p>其主要特点是：</p>
<ul>
<li>没有顺序。</li>
<li>不会存在重复的值。</li>
</ul>
<h3 id="树集（TreeSet）"><a href="#树集（TreeSet）" class="headerlink" title="树集（TreeSet）"></a>树集（<code>TreeSet</code>）</h3><p>TreeSet类与散列集十分相似，元素不允许重复。</p>
<p>不过，它比散列集有所改进。树集是一个有序集合（sorted collection）。</p>
<p>可以将任意顺序的元素插入到集合中。在对集合进行遍历的时候，值将自动按照排序后的顺序呈现。</p>
<p>其底层实现是<strong>红黑树</strong>。</p>
<p>每将一个元素添加到树中时，都会将其放置到正确的位置。因此迭代器总会以有序的访问每个元素。</p>
<p>将一个元素添加到树中总要比添加到散列表中慢。</p>
<p>所以到底是选用散列表还是树集要根据需求，如果不要求数据有序，则选用散列表。但是如果元素过多，则速度会很慢。</p>
<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（<code>Queue</code>）</h3><p>队列是一个先进先出的集合。其本身是一个接口。定义了需要的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列（即Deuqe）允许在头部和尾部都高效地添加或删除元素。Java6引入了Deque接口。</p>
<p>其中一部分接口：</p>
<ul>
<li><code>void addFirst(E e);</code></li>
<li><code>void addLast(E e);</code></li>
<li><code>void addLast(E e);</code></li>
<li><code>boolean offerFirst(E e);</code></li>
<li><code>boolean offerLast(E e);</code></li>
<li><code>E removeFirst();</code></li>
<li><code>E removeLast();</code></li>
<li><code>E pollFirst();</code></li>
<li><code>E pollLast();</code></li>
<li><code>E getLast();</code></li>
<li><code>E peekFirst();</code></li>
<li><code>E peekLast();</code></li>
<li><code>int size();</code></li>
<li><code>Iterator&lt;E&gt; iterator();</code></li>
</ul>
<p><code>ArrayDeque</code>和<code>LinkedList</code> 类实现了这个接口。</p>
<h3 id="数组双端队列（ArrayDeque）"><a href="#数组双端队列（ArrayDeque）" class="headerlink" title="数组双端队列（ArrayDeque）"></a>数组双端队列（<code>ArrayDeque</code>）</h3><p>在<code>import java.util.ArrayDeque;</code> 中定义了<code>ArrayDeque</code> 。</p>
<p><code>ArrayDeque</code> 实现了<code>Deque</code> 中的所有方法。并且其内部是一个数组来存储数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br></pre></td></tr></table></figure>
<p>由于数组不能增加长度的问题，其内部又定义了一些方法来实现动态增加长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity of this deque by at least the given amount.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> needed the required minimum extra capacity; must be positive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> needed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity;</span><br><span class="line">        <span class="comment">// Double capacity if small; else grow by 50%</span></span><br><span class="line">        <span class="keyword">int</span> jump = (oldCapacity &lt; <span class="number">64</span>) ? (oldCapacity + <span class="number">2</span>) : (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (jump &lt; needed</span><br><span class="line">            || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = newCapacity(needed, jump);</span><br><span class="line">        <span class="keyword">final</span> Object[] es = elements = Arrays.copyOf(elements, newCapacity);</span><br><span class="line">        <span class="comment">// Exceptionally, here tail == head needs to be disambiguated</span></span><br><span class="line">        <span class="keyword">if</span> (tail &lt; head || (tail == head &amp;&amp; es[head] != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// wrap around; slide first leg forward to end of array</span></span><br><span class="line">            <span class="keyword">int</span> newSpace = newCapacity - oldCapacity;</span><br><span class="line">            System.arraycopy(es, head,</span><br><span class="line">                             es, head + newSpace,</span><br><span class="line">                             oldCapacity - head);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head, to = (head += newSpace); i &lt; to; i++)</span><br><span class="line">                es[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Capacity calculation for edge conditions, especially overflow. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> needed, <span class="keyword">int</span> jump)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = elements.length, minCapacity;</span><br><span class="line">        <span class="keyword">if</span> ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needed &gt; jump)</span><br><span class="line">            <span class="keyword">return</span> minCapacity;</span><br><span class="line">        <span class="keyword">return</span> (oldCapacity + jump - MAX_ARRAY_SIZE &lt; <span class="number">0</span>)</span><br><span class="line">            ? oldCapacity + jump</span><br><span class="line">            : MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列（priority queue）中的元素可以按照任意的顺序插入，但会按照有序的顺序进行检索。且特点就是：</p>
<p>无论何时调用<code>remove()</code> 方法，总会获得当前优先队列中<strong>最小的元素</strong>。</p>
<p>优先队列其内部是采用了堆来获取最小值。其原理是DS基础，不再赘述。</p>
<p>这个方法也实现了<code>Comparable</code>接口，方便在堆中比较大小。</p>
<p>其也是采用了数组存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>
<p>整个<code>remove()</code>的调用栈如下：</p>
<p><code>remove()-Abstract</code>-&gt;<code>pool()-PriorityQueue</code>-&gt;<code>siftDownUsingComparator()-PriorityQueue</code></p>
<p>其中<code>pool</code>是移除队列顶的元素，<code>siftDownUsingComparator</code>是将x插入后排好顺序。</p>
<p>值得注意的是：优先队列也支持特定元素出队列。即<code>remove(E e)</code>方法。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射<code>map</code>数据结构是为了存储键值对。可以通过键来查找值。</p>
<p>其特点就是键不能重复，值可以重复。</p>
<p>Java底层定义了<code>Map</code>接口用于统一映射的操作，抽象类<code>AbstractMap</code>是一个实现了<code>Map</code>接口的抽象类。</p>
<p>而<code>HashMap</code>和<code>TreeMap</code>都实现了    <code>Map</code>接口并且继承了<code>AbstractMap</code>类。</p>
<h3 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射<code>Map</code></h3><p><code>Map</code>提供了一下方法定义：</p>
<ul>
<li><code>int size();</code></li>
<li><code>boolean isEmpty();</code></li>
<li><code>boolean containsKey(Object key);</code></li>
<li><code>boolean containsValue(Object value);</code></li>
<li><code>V get(Object key);</code></li>
<li><code>V put(K key, V value);</code></li>
<li><code>V remove(Object key);</code></li>
<li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m);</code></li>
<li><code>void clear();</code></li>
</ul>
<p>而其中又定义了</p>
<p><code>Entry</code>这种数据接口用于保存单个键值对的子接口，其内部又定义了一些方法：</p>
<ul>
<li><code>K getKey();</code></li>
<li><code>V getValue();</code></li>
<li><code>V setValue(V value);</code></li>
<li><code>boolean equals(Object o);</code></li>
<li>…</li>
</ul>
<h3 id="顺序映射SortedMap"><a href="#顺序映射SortedMap" class="headerlink" title="顺序映射SortedMap"></a>顺序映射<code>SortedMap</code></h3><p><code>SortedMap</code>是一个继承了<code>Map</code>的接口。其主要目的是提供一个根据key排序的映射。其内部仅仅提供了一些函数定义（如获取<code>key</code>的<code>Set</code>，获取<code>value</code>的集合），并没有给出默认实现。</p>
<h3 id="导航映射NavigableMap"><a href="#导航映射NavigableMap" class="headerlink" title="导航映射NavigableMap"></a>导航映射<code>NavigableMap</code></h3><p><code>NavigableMap</code>是一个继承了<code>SortedMap</code>的接口。这个抽象类的目的是提供一些用来获取key或value的最大/最小值的方法申明。</p>
<p>比如:</p>
<ul>
<li><code>Map.Entry&lt;K,V&gt; lowerEntry(K key);</code>：返回按照key排序的最大的那个小于给定key的<code>Entry</code>。</li>
<li><code>K lowerKey(K key);</code>：返回按照key排序的最大的那个最小于给定key的<code>key</code>。</li>
<li><code>Map.Entry&lt;K,V&gt; floorEntry(K key);</code>：返回按照key排序的最大的那个小于或等于给定key的<code>Entry</code>。</li>
<li><code>K floorKey(K key);</code>：返回按照key排序的最大的那个小于或等于给定key的 <code>key</code>。</li>
<li><code>Map.Entry&lt;K,V&gt; ceilingEntry(K key);</code>：返回按照key排序的最小的那个大于给定key的<code>Entry</code>。</li>
<li><code>K ceilingKey(K key);</code>： …</li>
<li><code>Map.Entry&lt;K,V&gt; higherEntry(K key);</code>： 返回按照key排序的最小的那个大于给定key的<code>Entry</code>。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="number">4</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="number">6</span>: <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当给点key为-4时：</p>
<ul>
<li>lowerEntry: {3: 3}</li>
<li>floorEntry: {4: 4}</li>
<li>ceilingEntry: {4, 4}</li>
<li>higherEntry: {5: 5}</li>
</ul>
<p>返回key的规则也一样。</p>
<h3 id="抽象映射AbstractMap"><a href="#抽象映射AbstractMap" class="headerlink" title="抽象映射AbstractMap"></a>抽象映射<code>AbstractMap</code></h3><p>与<code>Set</code>类似，<code>Map</code>也定义了一个实现了<code>Map</code>接口的抽象类<code>AbstractMap</code>。</p>
<p>其内部为<code>Map</code>的方法提供了一些默认实现，比如<code>get</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">  <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">      <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">      <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">        <span class="keyword">return</span> e.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其利用了<code>Iterator</code>和<code>Entry</code>来为其提供了一个通用的实现。因为<code>Map</code>的数据总会为元素提供这两个实现。</p>
<p>而一些方法则没有实现，需要具体类自己去实现，比如<code>put</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="散列映射HashMap"><a href="#散列映射HashMap" class="headerlink" title="散列映射HashMap"></a>散列映射<code>HashMap</code></h3><p>其内部定义了<code>Node</code>实现了原<code>Map</code>中的<code>Entry</code>子接口。</p>
<p>其基本实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o <span class="keyword">instanceof</span> Map.Entry&lt;?, ?&gt; e</span><br><span class="line">                    &amp;&amp; Objects.equals(key, e.getKey())</span><br><span class="line">                    &amp;&amp; Objects.equals(value, e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说<code>HashMap</code>实际上也是由一个个的Node类的实例数组组成的。</p>
<p>其存储在<code>table</code>中，其初始化函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reset to initial default state.  Called by clone and readObject.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  table = <span class="keyword">null</span>;</span><br><span class="line">  entrySet = <span class="keyword">null</span>;</span><br><span class="line">  keySet = <span class="keyword">null</span>;</span><br><span class="line">  values = <span class="keyword">null</span>;</span><br><span class="line">  modCount = <span class="number">0</span>;</span><br><span class="line">  threshold = <span class="number">0</span>;</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>HashMap</code>的默认表长为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>
<p>装填因子为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<h3 id="树映射TreeMap"><a href="#树映射TreeMap" class="headerlink" title="树映射TreeMap"></a>树映射<code>TreeMap</code></h3><p><code>TreeMap</code> 实现了<code>AbstractMap</code>，并且实现了<code>NavigableMap</code>。</p>
<p>所以也实现了上面<code>NavigableMap</code>的所有方法，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the entry for the greatest key less than the specified key; if</span></span><br><span class="line"><span class="comment">    * no such entry exists (i.e., the least key in the Tree is greater than</span></span><br><span class="line"><span class="comment">    * the specified key), returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">       Entry&lt;K,V&gt; p = root;</span><br><span class="line">       <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">           <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">                   p = p.right;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> p;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   p = p.left;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                   Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                   <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</span><br><span class="line">                       ch = parent;</span><br><span class="line">                       parent = parent.parent;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> parent;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里采用了中序递归遍历的方式来查找等于这个值得node，然后返回其parent（这里有个判定其左子树是否存在过程）。</p>
<p>注意这里<code>TreeMap</code>中，重写了<code>Entry</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Make a new cell with given key, value, and parent, and with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; child links, and BLACK color.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value associated with the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value associated with the key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the value currently associated with the key with the given</span></span><br><span class="line"><span class="comment">     * value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value associated with the key before this method was</span></span><br><span class="line"><span class="comment">     *         called</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即这里除了定义了k,v还定义了<code>left</code>和<code>right</code>来作为树节点的左右节点。 而这里的树是一种特殊的平衡二叉树-红黑树。DS基础不再赘述。</p>
<h3 id="映射集合"><a href="#映射集合" class="headerlink" title="映射集合"></a>映射集合</h3><p>集合框架不认为映射映射本身是一个集合。不过，可以得到得映射的视图。</p>
<p>有3种视图：键集、值集合（不是一个集）以及键/值对集。键和键/值可以构成一个集合，因为映射中一个键只能有一个副本。下面是方法：</p>
<ul>
<li><code>Set&lt;K&gt;KeySet()</code></li>
<li><code>Collection&lt;V&gt; values()</code></li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></li>
</ul>
<p>需要说明的是，<code>KeySet</code> 不是<code>HashSet</code> 或 <code>TreeSet</code>，而是实现了<code>Set</code> 的另外某个类的对象。</p>
<p>tips：可以用<code>var</code> 来代替<code>Map.Entry</code> 这种复杂的声明方式。（尤其在增强for循环中）</p>
<h3 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h3><p>弱散列映射意在解决这样一个问题：如果一个散列映射中，如果一个键已经不在任何地方引用，那么理论上来说，这个映射就无法被任何地方获取，那么它仍然会在jvm中存在，并且不会被垃圾回收。这样显然是内存浪费。</p>
<p>而<code>WeakHashMap</code> 的设计就是为了解决这个问题，通过<code>WeakHashMap</code> 定义的键值对，只要键不在任何地方引用，则一定时间后，这个键值对就会被垃圾回收。</p>
<p><code>WeakHashMap</code> 使用的是弱引用(weak reference)保存键。WeakReference对象将包含另一个对象的引用，此处就是一个散列表键。</p>
<p>对于这种类型的对象，垃圾回收器采用了一种特殊的方式进行处理。正常情况下，如果垃圾回收器发现某个特点的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器也会将其回收。</p>
<p>这个回收过程是现将这个对象的弱引用放入一个队列。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。</p>
<p>一个弱引用进入队列意味着这个键不再被他人使用，并且已经回收。于是，WeakHashMap将删除相关联的映射条目。</p>
<h3 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h3><p><code>LinkedHashSet</code> 、<code>LinkedHashMap</code> 与<code>HashSet</code> 、<code>HashMap</code> 基本操作一样，只是其实现用了链表的方式。</p>
<p>所以在需要频繁增删元素时选用链表比较合适，否则直接使用数组形式更加方法。</p>
<h3 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h3><p><code>EnumSet</code> 是一个枚举类型元素集的高效实现。</p>
<p>由于枚举类型只有有限个实例，所以<code>EnumSet</code> 内部用位序列实现。如果对应的值在集中，</p>
<p><code>EnumSet</code>没有公共的构造器。要使用静态工厂方法构造这个集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> WeekDay&#123;MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SAUNDAY&#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FEIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; someday = EnumSet.of(Weekday.MONDAY, Weekday.THURSDAY);</span><br></pre></td></tr></table></figure>
<p><code>EnumMap</code> 是一个键类型为枚举类型的映射。其可以直接且高效地实现为一个值数组。</p>
<p>需要在构造器中指定键类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> personIncharge = <span class="keyword">new</span> EnumMap&lt;Weekday, Employee&gt;(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="标识散列映射（IdentityHahMap）"><a href="#标识散列映射（IdentityHahMap）" class="headerlink" title="标识散列映射（IdentityHahMap）"></a>标识散列映射（<code>IdentityHahMap</code>）</h3><p><code>IdentityHahMap</code> 有特殊的用途。在这个类中，键的散列值不是用<code>hashCode</code> 函数计算的，而是用<code>System.identityHashCode</code> 方法计算。这是<code>Object.hashCode</code> 根据对象的内存地址计算散列码时所使用的的方法。而且，在对两个对象进行比较时，<code>IdentityHahMap</code> 类使用<code>==</code>， 而不使用<code>equals</code>。</p>
<p>也就是说，不同的键对象即使内容相同，也被视为不同的对象。在实现对象遍历算法（如对象串行化）时，这个类非常有用，可以用来跟踪哪些对象已经遍历过。</p>
<h2 id="视图和包装器"><a href="#视图和包装器" class="headerlink" title="视图和包装器"></a>视图和包装器</h2><p><strong>视图</strong>就是<strong>集合</strong>或者<strong>映射</strong>中<strong>某一部分或者某一类</strong>数据的<strong>再映射</strong>得到的<strong>结果集</strong>，这个结果集一般<strong>不允许更新</strong>(有些视图允许更新某个元素，但是不允许新增或者删除元素)，只允许读取，结果集中的数据使用的还是原来集合或者映射中的数据的引用。</p>
<h3 id="小集合"><a href="#小集合" class="headerlink" title="小集合"></a>小集合</h3><p>Java9引入了一些静态方法，可以生成给定元素的集或列表，以及给定键/值对的映射。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = List.of(<span class="string">"Perter"</span>, <span class="string">"Paul"</span>, <span class="string">"Mary"</span>);</span><br><span class="line">Set&lt;Integer&gt; numbers = Set.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>会生成包含3个元素的一个列表和一个集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; sources = Map.of(<span class="string">"Peter"</span>, <span class="number">2</span>, <span class="string">"Paul"</span>, <span class="number">3</span>, <span class="string">"Mary"</span>, <span class="number">4</span>);</span><br><span class="line">Map&lt;String, Integer&gt; sources1 = Map.ofEntries(</span><br><span class="line">	entry(<span class="string">"Peter"</span>, <span class="number">2</span>),</span><br><span class="line">  	entry(<span class="string">"Paul"</span>, <span class="number">3</span>),</span><br><span class="line">  	entry(<span class="string">"Mary"</span>, <span class="number">4</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>元素、键或值不能为null。</p>
<p>这些方法返回的视图都为<code>ImmutableCollections</code> 的相关子类：</p>
<ul>
<li><code>static abstract class AbstractImmutableCollection&lt;E&gt; extends AbstractCollection&lt;E&gt;</code> ：所有内部类的父类。</li>
<li><code>static final class List12&lt;E&gt; extends AbstractImmutableList&lt;E&gt;</code>： 含有一个或多个的List。</li>
<li><code>static final class ListN&lt;E&gt; extends AbstractImmutableList&lt;E&gt;</code>：含有多个元素的List。</li>
<li><code>static abstract class AbstractImmutableSet&lt;E&gt; extends AbstractImmutableCollection&lt;E&gt;</code>： 所有内部Set的父类。</li>
<li><code>static final class Set12&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;</code>： 含有一个或两个元素的Set。</li>
<li><code>static final class SetN&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;</code>： 含有多个元素的Set。</li>
<li><code>abstract static class AbstractImmutableMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Serializable</code> ：所有内部Map类的父类。</li>
<li><code>static final class Map1&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt;</code>： 含有一个或多个的Map。</li>
<li><code>static final class MapN&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt;</code>： 含有多个元素的Map。</li>
</ul>
<p>值得注意的是：</p>
<ul>
<li>这些内部类的实例无法改变。（尝试改变会抛出一个<code>UnsupportedOperation Exception</code>）。</li>
<li><code>Collection</code> 类包含很多实用方法，这些方法的参数和返回值都是集合。不要将它与<code>Collection</code> 接口混淆。</li>
</ul>
<h3 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h3><p>可以为很多集合建立子范围（subrange）视图。比如</p>
<ul>
<li><code>List</code> 的<code>subList</code> 方法。</li>
<li><code>SortedSet&lt;E&gt; subSet(E from, E to);</code></li>
<li><code>SortedSet&lt;E&gt; headSet&lt;E to&gt;;</code></li>
<li><code>SortedSet&lt;E&gt; tailSet(E from );</code></li>
<li><code>SortedMap&lt;K, V&gt; subSet(K from, K to);</code></li>
<li><code>SortedMap&lt;K, V&gt; headSet&lt;K to&gt;;</code></li>
<li><code>SortedMap&lt;K, V&gt; tailSet(K from );</code></li>
<li><code>NavigableSet&lt;E&gt; subSet(E from, boolean fromInclusive, E to, boolean toInclusive);</code></li>
<li><code>NavigableSet&lt;E&gt; headSet&lt;E to, boolean toInclusive&gt;;</code></li>
<li><code>NavigableSet&lt;E&gt; tailSet(E from, blooean fromInclusive);</code> </li>
</ul>
<p>以上方法返回截取确定的集合，然后返回对应内容。</p>
<h3 id="不可修改视图"><a href="#不可修改视图" class="headerlink" title="不可修改视图"></a>不可修改视图</h3><p><code>Colelctions</code> 工具类（注意不是<code>Collection</code>接口）还有几个方法，可以生成集合的不可修改视图（unmodifiable view）。这些视图对现有集合增加了一个运行时检查。试图对其进行修改时会抛出错误，且集合不会改变。</p>
<p>以下8个方法可以获得不修改的视图：</p>
<ul>
<li><code>Collections.unmodifiable</code></li>
<li><code>CollectionCollections.unmodifiableList</code></li>
<li><code>Collections.unmodifiableSet</code></li>
<li><code>Collections.unmodifiable</code></li>
<li><code>SortedSetCollections. unmodifiableNavigable</code></li>
<li><code>SetCollections.unmodifiableMap</code></li>
<li><code>Collections.unmodifiableSortedMap</code></li>
<li><code>Collections.unmodifiableNavigableMap</code></li>
</ul>
<p>每个方法都定义处理一个接口。如：</p>
<p><code>CollectionCollections.unmodifiableList</code> 处理<code>ArrayList</code>、<code>LinkedList</code>或者任何实现了<code>List</code> 接口的类。</p>
<h3 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h3><p>如果从多个线程访问集合，就必须保证集合不会被意外破坏。例如散列表不是同步的，多个线程同时访问会出现错误。这就是灾难性的。所以，同步中设计了很多线程安全集合。例如<code>Collections.synchronizedMap</code>就是一个线程安全的Map，使用方法相同，具体详见以后的多线程介绍。</p>
<h3 id="检查性视图"><a href="#检查性视图" class="headerlink" title="检查性视图"></a>检查性视图</h3><p>“检查型”视图是用来对泛型可能出现的问题提供调试支持。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList rawList = strings;</span><br><span class="line">rawList.add(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>
<p>这个错误的命令在运行时检测不到。实际上，只有当另一部分代码调用get方法，并且将这个结果强制转换为String时，才会出现一个类的强制转换异常。</p>
<p>而检查型视图可以探测这个问题。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Strting&gt; safeStrings = Collections.checkedList(strings, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这个视图的add方法将检查插入的对象是否属于给定的类。如果不是，就会抛出转换错误。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList rawList = safeStrings;</span><br><span class="line">rawList.add(<span class="keyword">new</span> Date());			<span class="comment">//ClassCastException</span></span><br></pre></td></tr></table></figure>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h3><p>泛型集合接口有一个很大的优点，即算法只需实现一次。</p>
<h3 id="排序和混排"><a href="#排序和混排" class="headerlink" title="排序和混排"></a>排序和混排</h3><ul>
<li><code>Arrays.sort</code> 采用的是快排的方式。</li>
<li>而对于链表的排序，Java采用的是先将其复制到一个数组中，经过排序再复制回链表中。</li>
</ul>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><code>Collections.binarySearch</code>是一个二分查找的实现。</p>
<h3 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h3><p>由于Java平台API的大部分内容都是在集合框架创建之前设计的，所以，有时候需要在传统的数组和更加现代的集合之间进行转换。</p>
<h3 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h3><p><code>list.of</code> 包装器可以达到这个目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] values = ...;</span><br><span class="line"><span class="keyword">var</span> staff = <span class="keyword">new</span> HashSet&lt;&gt;(List.of(values));</span><br></pre></td></tr></table></figure>
<h3 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h3><p>可以使用<code>toArray</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] values = staff.toArray();</span><br></pre></td></tr></table></figure>
<p>但是注意这个方法只能返回<code>Object[]</code>，并且不能强制转换。</p>
<h2 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h2><p>从Java第一版本以来，在集合框架中已经存在大量的“遗留的”容器类。</p>
<h3 id="Hashtable-类"><a href="#Hashtable-类" class="headerlink" title="Hashtable 类"></a><code>Hashtable</code> 类</h3><p>经典的<code>Hashtable</code>类与<code>HashMap</code> 类作用一样。实际上接口也基本相同。与<code>Vector</code> 类的方法一样，<code>Hashtable</code>方法也是同步的。如果对遗留代码的兼容性没有需求，则应当使用<code>HashMap</code> 。</p>
<p>如果对并发有需求，则应当使用<code>ConcurrentHashMap</code> 。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>遗留的集合使用<code>Enumeration</code>接口遍历元素序列。其<code>hasMoreElements</code> 和<code>nextElement</code> 与<code>Iterator</code> 接口的<code>hasNext</code> 和<code>next</code> 方法作用一致。以后应该都使用<code>Iterator</code> 。</p>
<h3 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h3><p>属性映射（<code>property map</code>）是一个特殊类型的映射结构。其有以下特点：</p>
<ul>
<li>键和值都是字符串。</li>
<li>这个映射可以很容易地保存到文件以及从文件中加载。</li>
<li>有一个二级表存放默认值。</li>
</ul>
<p>在Java平台中类名为<code>properties</code>。 一般可以用于加载<code>xxx.proprties</code> 文件。</p>
<h3 id="位集"><a href="#位集" class="headerlink" title="位集"></a>位集</h3><p>Java平台的<code>BitSet</code> 类主要存储一个未序列（它不是数学上的集，如果称为位向量或位组更为合适）。如果需要高效的存储位序列（例如，标志），就可以使用位集。由于位集合包装在字节里，因此位集要比使用boolean对象的ArrayList高效很多。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitSet bSet = <span class="keyword">new</span> BitSet();</span><br><span class="line">bSet.set(<span class="number">0</span>);</span><br><span class="line">bSet.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以对第n位调用<code>set</code>方法。此时第n位状态就为 “开”。</p>
<p>这时再调用<code>get</code>方法就会返回<code>true</code>，否则返回<code>false</code>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>java核心技术-I-9-集合</tag>
      </tags>
  </entry>
  <entry>
    <title>node-js基本用法解析</title>
    <url>/2018/09/22/node-js%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fvm3zfyeanj30ja0c1aa1.jpg" alt="node"></p>
<p>为什么会想到搞一下node呢，emmmm，主要是之前想收图片，每个人4张，一共几十个人，如果都通过qq发过来那简直市场噩梦（虽然我最后还是经历了这擦会给你噩梦），所以下定决心要搞一下后端的东西，PHP，ASP学习成本有点高，速成还是有点难，所以我想到了node.js这个神奇的东西，用js的语言来写后端的东西，nice哦。所以就有了这篇文章。<br><a id="more"></a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="EventEmitter模块"><a href="#EventEmitter模块" class="headerlink" title="EventEmitter模块"></a>EventEmitter模块</h2><p>这个模块可以说是node中一个核心的模块，包括fs，http，net等模块的事件都是继承自该模块，若不使用继承的方法，其基本用法是：</p>
<pre><code>//引入events模块
var eventEmitter = require(&apos;events&apos;);
//创建eventEmitter
var  events = new events.EventEmitter();


event.on(&apos;some_event1&apos;,function(){
    console.log(&quot;监听器1执行&quot;);
})


event.addListener(&apos;some_event2&apos;,function(){
    console.log(&quot;监听器2执行&quot;);
})


event.removeListener(&apos;some_event1&apos;,function(){
    console.log(&quot;监听器1移除&quot;);
})

event.emit(&apos;some_event1&apos;);
</code></pre><p>这是一些基本的用法，不过这个方法在平时不怎么用，所以了解一下就ok了。</p>
<h2 id="文件系统fs"><a href="#文件系统fs" class="headerlink" title="文件系统fs"></a>文件系统fs</h2><h3 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h3><p>由于node是基于JS，所以异步与同步是不可回避的一个问题，在之前的博文中，我们也解析过JS的异步与同步操作，这里不再赘述。而node中文件操作是同时支持异步与同步操作，具体区别这里也不再赘述。</p>
<h4 id="异步与同步代码"><a href="#异步与同步代码" class="headerlink" title="异步与同步代码"></a>异步与同步代码</h4><pre><code>var fs = require(&apos;fs&apos;);

//异步读取
fs.readFile(&apos;input.txt&apos;,function(err,data){
    if(err){
        return console.error(err);
        }
    console.log(&apos;异步读取&apos;+data.toString());
});

//同步读取
var data = fs.readFileSync(&apos;input.txt&apos;);
console.log(&quot;同步读取：&quot;+dataString());
console.log(&apos;文件操作完毕&apos;);
</code></pre><p>注意这里是展示同步与异步的代码区别，一般是在操作代码后加上“Sync”(同步)，但一般我们并不使用这种同步的方法，因为在文件大一点的时候这会严重影响代码执行的效率。</p>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p><strong>语法格式</strong></p>
<pre><code>fs.open(path,flag,callback)
</code></pre><p><strong>参数</strong></p>
<p>path-文件路径</p>
<p>flag-文件打开的模式</p>
<p>callback-回调函数，该函数带有两个参数（err,fd），err-&gt;错误，fd-fileData，文件内容及信息</p>
<p>下面是flag的参数及其说明</p>
<p><a href="https://imgchr.com/i/iucQaQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/23/iucQaQ.md.jpg" alt="iucQaQ.md.jpg"></a></p>
<h3 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h3><p><strong>语法格式</strong></p>
<pre><code>fs.stat(path,callback)
</code></pre><p><strong>参数</strong></p>
<p>path-文件路径</p>
<p>call-回调函数</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.stat(&apos;/Users/liuht/code/itbilu/demo/fs.js&apos;, function (err, stats) {
console.log(stats.isFile());         //true
})
</code></pre><p>下面是该类中的方法：</p>
<p><img src="https://s1.ax1x.com/2018/09/23/iucG2q.jpg" alt="iucG2q.jpg"></p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p><strong>语法格式</strong></p>
<pre><code>fs.writeFile(file,data[,option],callback)
</code></pre><p><strong>参数</strong></p>
<p>file-文件名或文件描述</p>
<p>data-要写入的数据，可以是字符串（String）或缓冲变量（Buffer）对象</p>
<p>option-该参数是一个对象，包含{encoding,mode,flag}。默认为{utf8,0666,w}</p>
<p>callback-回调函数（仅包含err，在写入失败时返回）</p>
<pre><code>var fs = require(&apos;fs&apos;);

console.log(&apos;准备写入文件&apos;);
fs.writeFile(&apos;input.txt&apos;,&apos;我是通过fs.file写入的内容&apos;,function(err){
    return console.log(err);
}
console.log(&apos;数据写入成功！&apos;);
console.log(&apos;读取写入的数据!&apos;);
fs.readFile(&apos;input.txt&apos;,function(err,data){
    if(err){
    return console.log(err);}
    console.log(&apos;读取文件内容：&apos;+data.toString());
  });
});
</code></pre><p>这是代码执行效果：</p>
<pre><code>$ node file.js 
准备写入文件
数据写入成功！
读取写入的数据！
异步读取文件数据: 我是通 过fs.writeFile 写入文件的内容
</code></pre><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p><strong>语法格式</strong></p>
<pre><code>fs.readFile(fd,buffer,offset,length,position,callback)
</code></pre><p>参数</p>
<p>fd - 通过 fs.open() 方法返回的文件描述符。</p>
<p>buffer - 数据写入的缓冲区。</p>
<p>offset - 缓冲区写入的写入偏移量。</p>
<p>length - 要从文件中读取的字节数。</p>
<p>position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</p>
<p>callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</p>
<pre><code>var fs = require(&quot;fs&quot;);
var buf = new Buffer.alloc(1024);

console.log(&quot;准备打开已存在的文件！&quot;);
fs.open(&apos;input.txt&apos;, &apos;r+&apos;, function(err, fd) {
if (err) {
   return console.error(err);
}
console.log(&quot;文件打开成功！&quot;);
console.log(&quot;准备读取文件：&quot;);
fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){
  if (err){
     console.log(err);
  }
  console.log(bytes + &quot;  字节被读取&quot;);

  // 仅输出读取的字节
  if(bytes &gt; 0){
     console.log(buf.slice(0, bytes).toString());
  }
 });
});
</code></pre><p>下面是代码执行效果：</p>
<pre><code>$ node file.js 
准备打开已存在的文件！
文件打开成功！
准备读取文件：
25  字节被读取
This is a test inputtxt
</code></pre><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><pre><code>fs.close(fd,callback)
</code></pre><p>参数</p>
<p>fd - 通过 fs.open() 方法返回的文件描述符。</p>
<p>callback - 回调函数，没有参数。</p>
<pre><code>fs.close(fd, function(err){
     if (err){
        console.log(err);
     } 
     console.log(&quot;文件关闭成功&quot;);
</code></pre><h3 id="截取文件"><a href="#截取文件" class="headerlink" title="截取文件"></a>截取文件</h3><pre><code>fs.ftruncate(fd,len,callback)
</code></pre><p><strong>参数</strong></p>
<p>fd - 通过 fs.open() 方法返回的文件描述符。</p>
<p>len - 文件内容截取的长度。</p>
<p>callback - 回调函数，没有参数（但含有err参数）。</p>
<pre><code>fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){
     if (err){
        console.log(err);
     }

     // 仅输出读取的字节
     if(bytes &gt; 0){
        console.log(buf.slice(0, bytes).toString());
     }
</code></pre><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><pre><code>fs.unlink(path,callback)
</code></pre><p><strong>参数</strong></p>
<p>path-路径</p>
<p>callback-回调函数，没有参数（但含有err参数）</p>
<p><strong>实例</strong></p>
<pre><code>var fs = require(&apos;fs&apos;);

console.log(&apos;开始删除文件！&apos;);
fs.unlink(&apos;input.txt&apos;,function(err){
if(err){
return console.log(err);
}
    console.log(&quot;删除成功！&quot;);
})
</code></pre><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><pre><code>fs.mkdir(path,[,mode],callback)
</code></pre><p>参数</p>
<p>path - 文件路径。</p>
<p>mode - 设置目录权限，默认为 0777。</p>
<p>callback - 回调函数，没有参数。</p>
<p><strong>实例</strong></p>
<pre><code>var fs = require(&apos;fs&apos;);

console.log(&apos;创建目录 /tmp/test/&apos;);

fs.mkdir(&quot;/tmp/test/&quot;,function(err){
    if(err){
        return console.log(err);
    }
    console.log(&apos;目录创建成功&apos;);
})
</code></pre><p>这是执行效果</p>
<pre><code>$ node file.js 
创建目录 /tmp/test/
目录创建成功。
</code></pre><p>###读取目录###<br><strong>语法</strong><br>    fs.readdir(path,callback)</p>
<p>参数</p>
<p>path - 文件路径。</p>
<p>callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</p>
<p><strong>实例</strong></p>
<pre><code>var fs = require(&quot;fs&quot;);

console.log(&quot;查看 /tmp 目录&quot;);
fs.readdir(&quot;/tmp/&quot;,function(err, files){
if (err) {
   return console.error(err);
}
files.forEach( function (file){
   console.log( file );
 });
});
</code></pre><p><strong>执行效果</strong></p>
<pre><code>$ node file.js 
查看 /tmp 目录
input.out
output.out
test
test.txt
</code></pre><p>###删除目录###</p>
<p><strong>语法</strong><br>    fs.rmdir(path,callback)</p>
<p><strong>实例</strong></p>
<pre><code>var fs = require(&quot;fs&quot;);
// 执行前创建一个空的 /tmp/test 目录
console.log(&quot;准备删除目录 /tmp/test&quot;);
fs.rmdir(&quot;/tmp/test&quot;,function(err){
if (err) {
   return console.error(err);
}
console.log(&quot;读取 /tmp 目录&quot;);
fs.readdir(&quot;/tmp/&quot;,function(err, files){
  if (err) {
      return console.error(err);
  }
  files.forEach( function (file){
      console.log( file );
  });
 });
});
</code></pre><p>执行效果：</p>
<pre><code>$ node file.js 
准备删除目录 /tmp/test
读取 /tmp 目录
……
</code></pre><p><strong>文件模块还有很多方法，具体可以参见<a href="http://nodejs.cn/api/" target="_blank" rel="noopener">node.js官方文档</a></strong></p>
<h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>http模块一般是使用createServer方法来创建服务器，下面是<br>不使用html文件的代码：</p>
<pre><code>//获取http方法并定义到变量
var http = require(&apos;http&apos;);
http.createServer(function(req,res){
    res.writeHead(400,{&apos;Content-Type&apos;:&apos;text/html&apos;})
res.end(&quot;This is a test&quot;);
}).listen(3000);
console.log(&quot;server running at http://127.0.0.1:3000/&quot;);
</code></pre><p>这个代码执行后会在网页上显示This is a test 的字样。</p>
<p>下面是使用html文件来作为网页显示：</p>
<pre><code>var http = require(&apos;require&apos;);
var fs = require(&apos;fs&apos;);
var url = require(&apos;&apos;);

//创建服务器
http.createServer(function(req,res){
    //解析请求，包括文件名
    var pathname = url.parse(req.url).pathname;

    //从文件系统中请求文件内容
    console.log(&apos;request for&apos;+pathname+&apos;received&apos;);

    fs.readFile(pathname.substr(1),function(err,data){

        if(err){
            console.lor(err);
            //发送404（未查找到文件）HTTP状态码并规定解析文件为html文件
            res.writeHead(404,{&apos;Content-Type&apos;:&apos;text/html&apos;});
        }else{
            //发送200（正常）HTTP状态码并规定解析文件为html
            res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;});

                        //响应文件内容
        res.write(data.toString());
    })
    res.end();
}).listen(3000);

console.log(&quot;Server running at http://127.0.0.1:3000/&quot;);
</code></pre><p>index文件：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;我的第一个标题&lt;/h1&gt;
&lt;p&gt;我的第一个段落。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>执行上面JS代码，并在浏览器中填入：<a href="http://127.0.0.1:8080/index.html，就会显示出index.html网页内容。" target="_blank" rel="noopener">http://127.0.0.1:8080/index.html，就会显示出index.html网页内容。</a></p>
<h2 id="url及post和get请求"><a href="#url及post和get请求" class="headerlink" title="url及post和get请求"></a>url及post和get请求</h2><p>url是指请求的地址，其中不仅包含路径，还了可以包含多个参数，如下图，网址<br><em>‘<a href="http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&#39;" target="_blank" rel="noopener">http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&#39;</a></em></p>
<p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fvm14lsh7rj30js0ctmxs.jpg" alt="url"></p>
<p>以下代码可以从url中获取相关的参数：</p>
<pre><code>var http = require(&apos;http&apos;);
var url = require(&apos;url&apos;);
var util = require(&apos;util&apos;);

http.createServer(function(req,res){
    res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;;&apos;charset=utf-8&apos;});
    res.end(util.inspect(url.parse(req.url,true)));
}).listen(3000);
</code></pre><p>其效果：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/06/4A1C02B2-2EB8-4976-9F35-F3760713D495.jpg" alt="url2"></p>
<p>其中util模块是一个工具模块，提供了很多功能，其中util.inspect(object[,options]),这里option的选项很多，这里不再展开叙述。其作用是一个将任意对象转换 为字符串的方法,通常用于调试和错误输出。</p>
<p>将url中的属性值提取出来，</p>
<pre><code>var http = require(&apos;http&apos;);
var url = require(&apos;url&apos;);
var util = require(&apos;util&apos;);

http.createServer(function(req,res){
    res.writeHead(200,{&apos;Conten-Type&apos;:&apos;text/plain&apos;});

    var params = url.parse(req.url,true).query;
    res.write(&quot;网站名：&quot;+params.name);
    res.write(&quot;\n&quot;);
    res.write(&quot;网站URL：&quot;params.url);
    res.end();
}).listen(3000);
</code></pre><p>效果：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/06/ADF34B0E-6715-41EE-9A88-4BE067100868.jpg" alt="url3"></p>
<p><strong>获取表单数据</strong></p>
<pre><code>var http = require(&apos;http&apos;);
var querystring = require(&apos;querystring&apos;);

var postHTML = 
&apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;&apos; +
&apos;&lt;body&gt;&apos; +
&apos;&lt;form method=&quot;post&quot;&gt;&apos; +
&apos;网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;&apos; +
&apos;网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;&apos; +
&apos;&lt;input type=&quot;submit&quot;&gt;&apos; +
&apos;&lt;/form&gt;&apos; +
&apos;&lt;/body&gt;&lt;/html&gt;&apos;;

http.createServer(function (req, res) {
var body = &quot;&quot;;
req.on(&apos;data&apos;, function (chunk) {
body += chunk;
});
req.on(&apos;end&apos;, function () {
// 解析参数
body = querystring.parse(body);
// 设置响应头部信息及编码
res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/html; charset=utf8&apos;});

if(body.name &amp;&amp; body.url) { // 输出提交的数据
    res.write(&quot;网站名：&quot; + body.name);
    res.write(&quot;&lt;br&gt;&quot;);
    res.write(&quot;网站 URL：&quot; + body.url);
} else {  // 输出表单
    res.write(postHTML);
}
    res.end();
});
}).listen(3000);
</code></pre><p>其效果如图：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/06/nodepost.gif" alt="url3"></p>
<h2 id="将表单提交的数据"><a href="#将表单提交的数据" class="headerlink" title="将表单提交的数据"></a>将表单提交的数据</h2><h3 id="利用express框架获取表单内容"><a href="#利用express框架获取表单内容" class="headerlink" title="利用express框架获取表单内容"></a>利用express框架获取表单内容</h3><pre><code>var express = require(&apos;express&apos;);
var app = express();

//将文件夹public设为express公开文件夹(express模块已经将fs方法至于其中，因此在设置公开文件夹时不需再引用fs模块)。
app.use(express.static(&apos;public&apos;));

app.get(&apos;/index.html&apos;,function(req,res){
    res.sendFile(_dirname+&apos;/&apos;+&apos;index.html&apos;);
})

app.get(&apos;/process_get&apos;,function(req,res){
    var response = {
        &quot;first_name&quot;:req.query.first_name,
        &quot;last_name&quot;:req.query.last_name

    };
    console.log(response);
    res.end(JSON.stringify(response));
});

var server = app.listen(8081,function(req,res){
    var host = server.address().address
    var port = server.address().port
    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port);
});
</code></pre><p>html代码：</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;http://127.0.0.1:8081/process_get&quot; method=&quot;GET&quot;&gt;
First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt;  &lt;br&gt;

Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>效果如图：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/09/nodejs-gif6.gif" alt="express"></p>
<p>express模块是一个web应用框架，他提供了很多强大的功能来更简单的创建web应用。</p>
<h3 id="利用express及multer来实现文件的上传"><a href="#利用express及multer来实现文件的上传" class="headerlink" title="利用express及multer来实现文件的上传"></a>利用express及multer来实现文件的上传</h3><p>multer模块主要处理表单文件的上传。</p>
<pre><code>var express = require(&apos;express&apos;);
var multer = require(&apos;multer&apos;);
var app = express();
app.use(express.static(&apos;public&apos;));
// 通过 filename 属性定制
var storage = multer.diskStorage({
destination: function (req, file, cb) {
    cb(null, &apos;/web开发/测试/upload&apos;);    // 保存的路径，备注：需要自己创建
},
filename: function (req, file, cb) {
    // 将保存文件名设置为 字段名 + 时间戳+后缀，比如 logo-1478521468943
    cb(null, file.fieldname + &apos;-&apos; + Date.now()+&apos;.jpg&apos;);
}
});

// 通过 storage 选项来对 上传行为 进行定制化
var upload = multer({ storage: storage })

//var upload = multer({dest : &apos;upload/&apos; });
//var upload = multer({storage:storage});
 app.get(&apos;/index&apos;,function(req,res){
res.send(_dirname+&quot;/&quot;+&quot;index.html&quot;);
})
//single中的第二个参数代表可以接受几个文件，2代表可以接受两个文件
app.post(&apos;/upload&apos;,upload.single(&apos;pics，2&apos;),function(req,res){
res.send(&quot;ok&quot;);
})

var server=app.listen(3030,function(){
 var host = server.address().address
 var port = server.address().port
 console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)
 })
</code></pre><p>上面这段代码可以实现文件的上传并将其放在规定的文件夹及其规律化的命名：</p>
<p>html代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
&lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
&lt;!--   &lt;span&gt;first item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;first_item&quot;&gt;&lt;br/&gt;
 &lt;span&gt;second item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;second_item&quot;&gt;&lt;br/&gt; --&gt;
 &lt;span&gt;file&lt;/span&gt;&lt;input type=&quot;file&quot; name=&quot;pics&quot;&gt;&lt;br/&gt;
 &lt;/be/&gt;
 &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>终于把这个简单的文章写完了，这只是node的冰山一角，node还有很多模块及其方法，想要精通段时间内几乎是不可能的，后面还是要继续努力xio习啊！</p>
<p><strong>引用</strong></p>
<p><a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<p><a href="https://www.cnblogs.com/chyingp/p/express-multer-file-upload.html" target="_blank" rel="noopener">Nodejs进阶：基于express+multer的文件上传</a></p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的事件绑定</title>
    <url>/2019/12/22/react%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>最近想试一下React，之前一直用Vue在写东西。稍微看了几篇教程后，就开始写，能够基本运行起来，可能是因为项目比较简单吧。但是也遇到了几个问题，<strong>首先就是React的事件绑定问题</strong>：</p>
<p>我第一次的写法是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleEvent()&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=<span class="string">"handleEvent"</span>&gt; &lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样普通的点击事件是能够正常触发的。</p>
<h2 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h2><p>但是当我要使用<code>this</code>时，这种写法就出了问题。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleEvent()&#123;</span><br><span class="line">	<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        state1 : <span class="number">111</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=<span class="string">"handleEvent"</span>&gt; &lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就会报错this为undefined的。于是我就想起了之前看过的文章以及结合之前对JavaScript的函数的this分析。就明白此时函数在调用时不是被react对象直接调用的。所以该函数的this的指向为undefined。所以要想使用react对象的方法，只有将函数的this指向为react。根据之前文章对this的分析，要想绑定this，可以使用：</p>
<ol>
<li>call（一次绑定并调用）</li>
<li><p>apply （一次绑定并调用）</p>
</li>
<li><p>bind（永久绑定）</p>
</li>
<li>箭头函数 () =&gt; {}永久绑定</li>
</ol>
<p>但是事件是要多次调用并且不是绑定时就调用，而是事件被触发时才调用，所以排除call与apply方法。所以选择bind与箭头函数为最佳(后来看官方文档时发现官方也是推荐了这两种方法来绑定this)。</p>
<p>所以有以下方法：</p>
<ol>
<li><p>在构造函数中绑定函数的this指向</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">	<span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.handleEvent = <span class="keyword">this</span>.handleEvent.bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//此时指向react对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=&#123;handleEvent&#125;&gt;&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在事件绑定时绑定函数this</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleEvent()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//此时指向react对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=&#123;<span class="keyword">this</span>.handleEvent.bind(<span class="keyword">this</span>)&#125;&gt;&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>至此，this的指向问题基本解决。</p>
<h2 id="函数传参的问题"><a href="#函数传参的问题" class="headerlink" title="函数传参的问题"></a>函数传参的问题</h2><p>接下来遇到需要传参的函数。我使用了与Vue与原始HTML同样的写法</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleEvent = <span class="function">(<span class="params">para</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(para)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=&#123;<span class="keyword">this</span>.handleEvent(<span class="string">"123"</span>)&#125;&gt;&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我尝试触发事件时，发现事件触发不成功，并且在打开控制面板时发现在页面初始化时，该事件被自动触发了3次，点击按钮无法触发。于是我不禁思考JSX的语法，让我想到了<code>EL表达式</code>，<code>EL表达式</code>中的代码会被直接运行，该位置会被填充为运行后的结果。再来看这个问题就发现自己的问题了。</p>
<p><strong>{}内的代码在JSX模板编译时被当成代码直接运行，而<code>tihs.handleEvent(&quot;123&quot;)</code>在JavaScript中不就是直接运行函数吗，所以函数在模板编译时直接被运行了，而onClick的事件则被绑定为函数的返回值，但是这个函数没有返回值，所以事件绑定失败。</strong></p>
<p>所以如何解决这个问题就很简单了，只要在事件绑定的位置放置一个函数而不是函数的调用就行了,方法也有两个：</p>
<ol>
<li><p>bind方法传参</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleEvent = <span class="function">(<span class="params">para</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(para)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=&#123;<span class="keyword">this</span>.handleEvent.bind(<span class="keyword">this</span>,<span class="string">"123"</span>)&#125;&gt;&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>箭头函数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleEvent = <span class="function">(<span class="params">para</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(para)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=&#123;() =&gt; &#123;<span class="keyword">this</span>.handleEvent(<span class="number">123</span>)&#125;&#125;&gt;&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="折腾一下"><a href="#折腾一下" class="headerlink" title="折腾一下"></a>折腾一下</h3><p>在看到箭头函数时我又思考能不能不用箭头函数，直接用匿名函数实现函数的调用。像这样：        </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleEvent = <span class="function">(<span class="params">para</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(para)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=&#123;<span class="function"><span class="keyword">function</span>(<span class="params">para</span>)</span>&#123;<span class="keyword">this</span>.handleEvent(para)&#125;&#125;&gt;&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<p>再一想发现好想更不行，匿名函数没有绑定this指向。所以也就拿不到<code>this.handleEvent()</code>函数了。那就试试绑定一下匿名函数的this指向，像这样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleEvent = <span class="function">(<span class="params">para</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(para)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=&#123;<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.handleEvent(<span class="number">123</span>)&#125;.bind(<span class="keyword">this</span>)&#125;&gt;&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<p>OK，事件成功绑定，但是转念一想，这么搞还不如直接bind原函数，也避开了使用箭头函数。纯属折腾吧。</p>
<h2 id="获取事件对象event"><a href="#获取事件对象event" class="headerlink" title="获取事件对象event"></a>获取事件对象event</h2><p>在Vue或者原生HTML中，event被存储在window下的event对象中，在绑定事件时将event对象传入即可获得点击事件对象。</p>
<p>但在React中，我们可以这么做：</p>
<ol>
<li><p>当我们不需要为这个函数传参时，event对象会自动传入该函数，我们通过第一个参数获取event对象</p>
</li>
<li><p>当我们需要传参时，我们需要手动传入event对象</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleEvent = <span class="function">(<span class="params">para,e</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(para)</span><br><span class="line">   <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button onClick=&#123;(e) =&gt; &#123;<span class="keyword">this</span>.handleEvent(<span class="number">123</span>,e)&#125;&#125;&gt;&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/或者这样</span></span><br><span class="line"><span class="regexp">&lt;Button onClick=&#123;this.handleEvent(123,e)&#125;&gt;&lt;/</span>Button&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>至此，React中的函数事件绑定基本可以搞定。写了一段时间的React，感觉相较于Vue，更灵活。刚入手的话，习惯了Vue模板文件的 <code>&lt;template&gt;</code> <code>&lt;style&gt;</code> <code>&lt;script&gt;</code>这种分明的设计，React中的JSX写起来感觉有点复杂。在对比anted与elemenui，感觉elementui的api简直太简单了。后期在多体验看看吧！</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>事件绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-II-9-Java平台模块系统</title>
    <url>/2022/02/18/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-9-Java%E5%B9%B3%E5%8F%B0%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h1><p>在Java系统中，提供了多种封装的层级。</p>
<p>在面向对象编程中，基础的构建要素就是类。类提供了封装，私有特征只能被具有明确访问权限的代码访问。</p>
<p>包提供了更高一级的组织方式，包是类的集合。包也提供了一种封装级别，具有包访问权限的所有特征（无论是公有还是私有）都只能被同一个包中的方法访问。</p>
<p>但是在大型系统中，这些控制级别还是显得不够，所以设计了模块的概念。</p>
<p>一般来说，一个Java平台模块包含以下部分：</p>
<ul>
<li>一个包集合。</li>
<li>可选地包含资源文件和像本地库这样的其他文件。</li>
<li>一个有关模块中可访问的包的列表。</li>
<li>一个有关这个模块依赖的所有其他模块的列表。</li>
</ul>
<h1 id="对模块命名"><a href="#对模块命名" class="headerlink" title="对模块命名"></a>对模块命名</h1><p>模块是包的集合。模块中的包名无需彼此相关。并且模块名和包名是可以完全相同的。</p>
<p>模块名是由字母、数字、下划线和句点构成的。而且，和路径名一样，模块之间没有任何层次关系。如<code>priv.mw</code>与<code>priv.mw.dao</code>是完全不同的两个模块。</p>
<p>一般来说模块的名字与包名类似，都遵循“反向域名”惯例，就像和包名一样。命名模块最简单的方式就是按照模块提供的顶级包来命名。这个惯例可以防止模块中产生报名冲突，因为任何给定的模块都只能被放到一个模块中。</p>
<h1 id="一个例子：模块化的”Hello-World-”程序"><a href="#一个例子：模块化的”Hello-World-”程序" class="headerlink" title="一个例子：模块化的”Hello World!”程序"></a>一个例子：模块化的”Hello World!”程序</h1><p>我们要将一个普通程序改为模块化，可以按照以下步骤：</p>
<ul>
<li><p>类必须放置在一个具名的包中（不具名包是不能包含在模块中的），代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.mw.hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>创建一个<code>module-info.java</code>模块声明文件，用于存储模块的信息。该文件位于基目录中（即，与包含<code>com</code>目录的目录相同）。按照惯例，基目录的名字与模块名相同，目录结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mymudule.hellomod/</span><br><span class="line">    <span class="keyword">module</span>-info.java</span><br><span class="line">    priv/</span><br><span class="line">    	mw/</span><br><span class="line">    		hello/</span><br><span class="line">    			HelloWorld.java</span><br></pre></td></tr></table></figure>
<p><code>module-info.java</code>文件包含模块声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mymudule.hellomod</span><br><span class="line">&#123;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模块声明之所以为空，是因为该模块没有任何可以向其他人提供的内容，也不需要依赖任何其他模块。</p>
<p><code>module-info.java</code>这个文件与一般的Java资源文件不同。从名字上也能看出来。因为类名不能包含连字符。在该文件中，用<code>require</code>和<code>exports</code>等”限定关键词（仅在模块声明中具有特殊意义）“来确定导入和导出的关键词。</p>
</li>
</ul>
<h1 id="对模块的需求"><a href="#对模块的需求" class="headerlink" title="对模块的需求"></a>对模块的需求</h1><p> 在Java9之后，jdk就被模块化了，其被分成了多个模块。每个模块都有一个<code>module-info.java</code>用于确定导入导出的模块。由于<code>java.base</code>包含的是Java最基础的类，所以这个模块是默认加载的，而其他的一些类别，如前面提到的<code>ScriptEngineManager</code>都需要自己在<code>module-info.java</code>文件中自己导入。</p>
<p>而模块中的还可能会依赖其他的模块，就会形成一个依赖链。例如下面的依赖链：</p>
<p><img src="E:\myblog\source\images\java核心技术\模块依赖.png" alt="模块依赖"></p>
<p>注意在模块依赖中不能有环，即，一个模块不能直接或间接地对自己产生依赖。</p>
<h1 id="导出-导入包"><a href="#导出-导入包" class="headerlink" title="导出/导入包"></a>导出/导入包</h1><h2 id="导出包"><a href="#导出包" class="headerlink" title="导出包"></a>导出包</h2><p>在模块系统中，可以在<code>module-info.java</code>使用关键字<code>export</code>来指定导出的模块。例如，下面是<code>java.xml</code>模块地模块声明中地一部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.dataType;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.namespace;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.parsers;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是：</p>
<ul>
<li>只有导出了的类才能被外部使用，也就是说可以隐藏内部地部分类。</li>
</ul>
<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>同样地，可以使用<code>requires</code>关键字来导入需要使用的模块。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> priv.mw</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">requires</span> java.scripting;</span><br><span class="line">	<span class="keyword">requires</span> java.desktop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>exports</code>到处的是<strong>包</strong>，而<code>requires</code>引用的是<strong>模块</strong>。</p>
<h1 id="模块化的JAR"><a href="#模块化的JAR" class="headerlink" title="模块化的JAR"></a>模块化的JAR</h1><p>模块可以通过将其所有的类都置于一个JAR文件中而得已部署，其中<code>module-info.class</code>在JAR文件的根部。这样的JAR文件被称为模块的JAR。</p>
<p>要想创建JAR文件，只需要以通常的方式使用<code>jar</code>工具。如果有多个包，那么最好使用<code>-d</code>选项来编译，这样可以将类文件置于单独的目录中，如果目录不存在，那么会创建该目录。然后，在收集这些类文件时使用<code>-C</code>选项的<code>jar</code>命令来修改该目录。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -d modules/com.horstman.greet $(find com.horstman.greet -name *.java)</span><br><span class="line">jar -cvf com.horstman.greet.jar -C modules/com.horstman.greet .</span><br></pre></td></tr></table></figure>
<p>如果使用<code>Maven, Gradle</code>这样的构建工具，那么只需要按照管用的方式来构建jar。只要<code>module-info.class</code>包含在内，就可以得到该模块的JAR文件。</p>
<p>然后，在模块路径中包含该模块化的JAR，该模块就会被加载。</p>
<p>也可以指定模块化的JAR中的主类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -p com.horstman.greet.jar -d modules/v2ch09.exportedpkg $(find v2ch09.exportedpkg -name *.java)</span><br><span class="line">jar -c -v -f v2ch09.exportedpkg.jar -e com.horstman.hello.hello.HelloWorld -C modules/v2ch09.exportedpkg .</span><br></pre></td></tr></table></figure>
<p>当启动该程序时，可以指定包含主类的模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -o com.horstman.greet.jar:v2ch09.exportedpkg.jar -m v2ch09.exportedpkg</span><br></pre></td></tr></table></figure>
<h1 id="模块和反射式访问"><a href="#模块和反射式访问" class="headerlink" title="模块和反射式访问"></a>模块和反射式访问</h1><p>对于类，可以通过反射来克服其权限问题，但是在模块中，则不能再这样吧访问了。即：如果一个类位于<strong>某个模块</strong>中，那么<strong>非公有成员</strong>的反射式访问将失败。</p>
<p>理论上来讲，这种破坏封装的特性是不合理的，但是由于长期的存在和使用，Java为其设计了<code>open</code>关键字。只要将某个模块的导出设定为<code>open</code>，则其内部的变量都是可以通过反射来访问的，无论是公开还是私有。也可以单独确定模块中的某个包为开放的。例如：</p>
<ol>
<li>模块开放</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open <span class="keyword">module</span> xxx&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>模块中的包开放</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> xxx&#123;</span><br><span class="line">    opens yyy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是：模块采用的是<code>open</code>，而包采用的<code>opens</code>关键字。</p>
<h1 id="自动模块和不具名模块"><a href="#自动模块和不具名模块" class="headerlink" title="自动模块和不具名模块"></a>自动模块和不具名模块</h1><p>为了过度（即Java9之前的应用都是没有模块系统的），Java设计了两个机制来缓解模块化前后的不兼容：</p>
<ul>
<li>自动化模块</li>
<li>不具名模块</li>
</ul>
<h2 id="自动模块"><a href="#自动模块" class="headerlink" title="自动模块"></a>自动模块</h2><p>如果是为了迁移，我们可以通过把任何JAR文件置于模块路径的目录而不是类路径的目录中，实现将其转换为一个模块。模块路径上没有<code>module-info.class</code>文件的JAR被称为自动模块。自动模块具有下面的属性:</p>
<ul>
<li>模块隐式的包含对其他所有模块的<code>requires</code>子句。</li>
<li>其所有包都被导出，且是开放的（<code>open</code>）。</li>
<li>如果在JAR清单<code>META-INF/MANIFEST.MF</code>中具有键为<code>Automatic-Module-Name</code>的项，那么它的值会变为模块名。</li>
<li>否则，模块名将从<code>JAR</code>文件名中获得，具体为：将文件名中尾部的版本号删除，并将非字母数字的字符替换为句点。</li>
</ul>
<p>前两条规则表明自动模块中的包的行为和在类路径上一样。使用模块路径的原因是为u了让其他模块受益，使得它们可以表示对这个模块的依赖关系。</p>
<h2 id="不具名模块"><a href="#不具名模块" class="headerlink" title="不具名模块"></a>不具名模块</h2><p>任何不在模块路径中的类都是不具名模块的一部分。从技术上讲，可能会有多个不具名模块，但是它们合起来看就像是单个不具名的模块。与自动模块一样，不具名模块可以访问所有其他的模块，它的所有包都会被导出，并且都是开放的。</p>
<p>但是，没有任何明确模块可以访问不具名的模块。（明确模块是既不是自动模块也不是不具名模块，即，<code>module-info.java</code>在模块路径上的模块。）</p>
<h1 id="传递需求和静态需求"><a href="#传递需求和静态需求" class="headerlink" title="传递需求和静态需求"></a>传递需求和静态需求</h1><h2 id="传递需求"><a href="#传递需求" class="headerlink" title="传递需求"></a>传递需求</h2><p>前面提到，模块的需求是不会传递的，即A需要B，B需要C，则A并不会直接需要C。但是有时候这种需求又是存在的，比如一些列的包都是需要底层的一个包，可以使用<code>requires transitive</code>来满这个需求。</p>
<p>例如，JavaFX用户界面元素的<code>javafx.controls</code>模块。<code>javafx.controls</code>模块需要<code>javafx.base</code>模块，因此每个使用<code>javafx.controls</code>的程序都需要<code>javafx.base</code>模块。因此<code>javafx.controls</code>模块声明需要使用<code>transitive</code>修饰符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> javafx.controls</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">requires</span> transitive javafx.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何声明需要<code>javafx.controls</code>的模块现在都自动需要<code>javafx.base</code>。</p>
<p><code>requires transitive</code>语句的一种很有吸引力的用法是聚集模块，即导入一个模块，自动导入可能需要的所有模块，无需再手动导入。</p>
<p><code>java.se</code>模块就是这样的模块，它被声明为下面的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java.se</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">requires</span> transitive java.compiler;</span><br><span class="line">    <span class="keyword">requires</span> transitive java.datatransfer;</span><br><span class="line">    <span class="keyword">requires</span> transitive java.desktop;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">requires</span> transitive java.sql;</span><br><span class="line">    <span class="keyword">requires</span> transitive java.sql.rowset;</span><br><span class="line">    <span class="keyword">requires</span> transitive java.xml;</span><br><span class="line">    <span class="keyword">requires</span> transitive java.xml.crypto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对细颗粒度模块依赖不感兴趣的程序员可以直接声明需要<code>java.se</code>，然后获取<code>Java SE</code>平台的所有模块。</p>
<h2 id="静态需求"><a href="#静态需求" class="headerlink" title="静态需求"></a>静态需求</h2><p><code>requires static</code>声明了一种需求，它声明一个模块必须再编译时出现，而在运行时是可选的。下面是两个用例：</p>
<ul>
<li><p>当问再编译时进行处理的注解，而该注解是在不同的模块中声明的。</p>
</li>
<li><p>对于位于不同模块中的类，如果它可用，就是用它，否则就执行其他操作。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> oracle.jdbc.driver.OracleDriver();</span><br><span class="line">    ...;</span><br><span class="line">&#125;<span class="keyword">catch</span>(NoClassDefFoundError err)&#123;</span><br><span class="line">    Do something <span class="keyword">else</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="限定导出和开放"><a href="#限定导出和开放" class="headerlink" title="限定导出和开放"></a>限定导出和开放</h1><p><code>exports</code>和<code>open</code>有一种变体用于将模块导出或开放给指定的模块，而不是所有的模块都可以访问。</p>
<p>格式如下：</p>
<ul>
<li><code>exports ... to ...</code></li>
<li><code>opens ... to ...</code></li>
</ul>
<p>如：</p>
<ol>
<li>限定导出<code>exports ... to ...</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exports</span> com.sun.java.javafx.collections to javafx.controls, javafx.graphics, javafx.fxml, javafx.swing;</span><br></pre></td></tr></table></figure>
<p>则<code>com.sun.java.javafx.collections</code>包只能被<code>javafx.controls, javafx.graphics, javafx.fxml, javafx.swing</code>访问。</p>
<ol start="2">
<li>限定开放<code>opens ... to ...</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> priv.mw</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">requires</span> com.xxx.yyy;</span><br><span class="line">    opens priv.mw.utils to priv.jack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>则<code>priv.mw.utils</code>就只对<code>priv.jack</code>模块开放。</p>
<h1 id="服务加载"><a href="#服务加载" class="headerlink" title="服务加载"></a>服务加载</h1><p><code>ServiceLoader</code>类提供了一种轻量级机制，用于将服务接口与现实匹配起来。下面是对服务加载的一个快速回顾。服务拥有一个接口和多个可能的接口。下面是一个简单的接口示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GreeterService</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">greet</span><span class="params">(String subject)</span></span>;</span><br><span class="line">    <span class="function">Locale <span class="title">getLocale</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个或多个模块提供了实现，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrenchGreeter</span> <span class="keyword">implements</span> <span class="title">GreeterService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">(String subject)</span></span>&#123;<span class="keyword">return</span> <span class="string">"Bonjour "</span> + subject;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">getLocale</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Locale.FRENCH;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务消费者必须基于其认为合适的标准在提供的所有实现中选择一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;GreeterService&gt; greeterLoader = ServiceLoader.load(GreeterService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">GreeterService chosenGreeter;</span><br><span class="line"><span class="keyword">for</span>(GreeterService greeter : greeterLoader)&#123;</span><br><span class="line">    <span class="keyword">if</span>(...)&#123;</span><br><span class="line">        chosenGreeter = greeter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在过去，实现是通过将文本放置到包含实现类的JAR文件的<code>META-INF/services</code>目录中而提供给服务消费者。模块系统提供了一种更好的方式，与提供文本不同，可以添加语句刀到模块描述符中。</p>
<h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><p>服务提供者可以使用<code>provides...with...</code>关键字，他列出了服务接口（可能定义在任何模块中），以及实现类（必须是该模块的一部分）。下面是<code>jdk.security.auth</code>模块的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> jdk.security.auth</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    provides javax.security.auth.spi.LoginModule with </span><br><span class="line">    com. sun . security.auth.<span class="keyword">module</span>.Krb5LoginModule,</span><br><span class="line">    com. sun . security.auth.<span class="keyword">module</span>.UnixLoginModule,</span><br><span class="line">    com . sun . security.auth.<span class="keyword">module</span>.JndiLoginModule,</span><br><span class="line">    com . sun. security.auth.<span class="keyword">module</span>.KeyStoreLoginModule,</span><br><span class="line">    com. sun . security.auth.<span class="keyword">module</span>.LdapLoginModule,</span><br><span class="line">    com. sun . security.auth.<span class="keyword">module</span>.NTLoginModule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与<code>META-INF/service</code>问价等价。</p>
<h2 id="消费服务"><a href="#消费服务" class="headerlink" title="消费服务"></a>消费服务</h2><p>服务使用者需要使用<code>uses</code>关键词来使用服务，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java.base</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    uses javax.security.auth.api.LoginModule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当消费模块中的代码调用<code>ServiceLoader.load(ServiceInterface.class)</code>时，匹配的提供者类将被加载。 </p>
<p>例如：将上面的<code>GreeterService</code>提供了不地区的实现。</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">moudle com.horstman.greetsvc</span><br><span class="line">&#123;</span><br><span class="line">    export com.horstman.greetsvc;</span><br><span class="line">    </span><br><span class="line">    provides com.hosrtman.greetsvc.GreeterService with</span><br><span class="line">        com.hosrtman.greetsvc.internal.FrechGreeter,</span><br><span class="line">    	com.hosrtman.greetsvc.internal.GermanGreeter,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费模块声明消费该模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module priv.mw </span><br><span class="line">&#123;</span><br><span class="line">	uses com.hosrtman.greetsvc.GreeterService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.mw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> com.hosrtman.greetsvc.*;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ServiceLoader&lt;GreeterService&gt; greeterLoader = ServiceLoader.load(GreeterService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    String desiredlanguage = args.length &gt; <span class="number">0</span> ? args[<span class="number">0</span>] : <span class="string">"de"</span>;</span><br><span class="line">    GreeterService chosenGreeter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(GreeterService greeter : greeterLoader)&#123;</span><br><span class="line">        <span class="keyword">if</span>(greeter.getLocale().getLanguage().equals(desiredlanguage)) chosenGreeter = greeter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(greeter == <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"No suitable greeter."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.printlm(chosenGreeter.greet(<span class="string">"Modular world"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>[object Object]</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-I-6-接口、lambda表达式与内部类</title>
    <url>/2022/01/20/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-6-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>接口不是类，而是希望符合这个接口的类的一组要求。接口不能实例化。</p>
<p>注意：</p>
<ol>
<li>接口中方法会默认指定为<code>public abstract</code>。</li>
<li>接口中的方法可以有实现，需加<code>default</code>关键字，使其作为该方法的默认实现（jdk1.8）。</li>
<li>接口中有静态方法和方法体（jdk1.8）。</li>
<li>接口中允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。（jdk1.9）。</li>
<li>接口中的变量会被默认指定为<code>public static final</code>。（且只能为<code>public</code>，<code>private</code>会报错）。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Minterface</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mm = <span class="number">123</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h2><ol>
<li><p>尽管不能构造接口的对象，却能声明接口的变量。且接口的变量必须引用实现了这个接口的类对象。（这也是实现解耦的关键）</p>
</li>
<li><p>接口也允许扩展，通过<code>extends</code>关键词来实现扩展（其中的静态变量也会被继承）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类可以实现多个接口（而一个类只能继承一个超类）。</p>
</li>
</ol>
<h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>从概念上来讲，接口是指一个类要满足一些要求；而抽象类，本质上是一个类，即一个种类。</p>
<p>比如Runnable和Thread。前者是一个接口，就是指满足可以run就行了。而Thraed就是指他是一个线程类。</p>
<p>从代码层面上来讲：</p>
<ol>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
<li>接口中不能含有静态代码块，而抽象类是可以有静态代码块。</li>
<li><strong>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</strong></li>
</ol>
<p>在一些编程语言中允许一个类继承多个类，如C++，这个特性被称为多继承（multiple inheritance）。Java的设计者选择了不支持多继承，其主要原因是多继承会让语言变得非常复杂，或者效率会降低。</p>
<h2 id="默认方法冲突"><a href="#默认方法冲突" class="headerlink" title="默认方法冲突"></a>默认方法冲突</h2><h3 id="接口与超类的冲突"><a href="#接口与超类的冲突" class="headerlink" title="接口与超类的冲突"></a>接口与超类的冲突</h3><p>当接口中的默认方法与超类中的方法冲突时，按<strong>超类优先</strong>的规则来调用方法，即同名的接口中的方法都会被忽略。（注意，只有方法名和参数都相同才会被认为是同一个方法，即函数名和参数类型二者被称为<strong>方法签名</strong>）</p>
<h3 id="接口冲突"><a href="#接口冲突" class="headerlink" title="接口冲突"></a>接口冲突</h3><p>当两个接口都实现了<code>getName</code>方法，则编译器会报错，并且要求开发者自己决定选择哪个方法。</p>
<p>可以用以下方式来二选一方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Inter1</span>, <span class="title">Inter2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inter1.<span class="keyword">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>lambda表达式是一个可传递的代码块，可以执行多次或一次。</p>
<p>（实际上我觉得这是面向对象的函数式编程的补充，比如回调场景要传递一个函数，这时候在Java中，就必须新建一个对象，内部包含一个函数。这明显是浪费的。不如直接传递一个函数，这也是lambda表达式出现的原因吧）</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String i, String j) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> i.length - j.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点如下：</p>
<ol>
<li><p>把这些代码放在{}中，并包含显式的return 语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> first.length() - second-length();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>即使lambda表达式没有参数，也必须要写括号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果该方法只有一个参数，而且这个参数的类型可以推导出，那么可以省略小括号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActionListener listen = event -&gt; System.out.print(event);</span><br></pre></td></tr></table></figure>
</li>
<li><p>无需指定lambda表达式的返回类型。lambda表达式的返回值类型总是由上下文推导得出。</p>
</li>
<li><p>当lambda表达式只包含一条语句且其就是返回值，则可以不用加<code>return</code>和花括号，直接写该句即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length - seconde.length;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口(Functional Interface)就是一个<strong>有且仅有一个抽象方法</strong>，但是可以有多个非抽象方法的接口。</p>
<p>Java中有很多封装代码的接口，如<code>ActionListener</code>或<code>Comparator</code>。lambda表达式与这些接口兼容。 </p>
<p>对于需要这些接口的位置，提供一个lambda表达式即可达到同等的效果。</p>
<p>如，（<code>Arrays.sort</code>方法第二个参数需要一个<code>Comparator</code>实例，而<code>Comparator</code>就是一个函数式接口）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(words, (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>
<p>在底层，<code>Arrays.sort</code>方法会接受实现了<code>Comparator&lt;String&gt;</code>的某个类的对象。在这个对象上调用<code>compare</code>方法会执行这个lambda表达式的体。</p>
<p>实际上，对lambda表达式所能做的也只是转换为函数式接口。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>有时需要直接调用一个定义好的函数作为lambda表达式体。可以通过以下格式</p>
<ol>
<li><code>object.instanceMethod</code>：等价于向方法中传递参数的lambda表达式。</li>
<li><code>Class.instanceMethod</code>：第一个参数会成为方法的隐式参数，如，<code>String::comparaToIgnoreCase</code>等同于<code>(x, y) -&gt;  x.comparaToIgnoreCase(y)</code>。</li>
<li><code>Class.staticMethod</code>：所有参数都传递到静态方法，如：<code>Math::pow</code>等价于<code>(x, y) -&gt; Math.pow(x, y)</code>。</li>
</ol>
<p>来作为该方法的引用。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> Time(<span class="number">1000</span>, event -&gt; System.out::println)</span><br></pre></td></tr></table></figure>
<p>同样的，方法引用也不是一个对象。不过，为一个类型为函数式接口的变量赋值时会生成一个对应的对象。</p>
<p><strong>注意：</strong></p>
<ol>
<li>只有当lambda表达式的体只有调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用。</li>
<li>也可以在方法引用中使用this参数。如<code>this::equals</code>等同于<code>x-&gt;this.equals(x)</code>。</li>
<li>也可以使用super表达式来引用super中的方法，，如<code>super.equals</code>。</li>
</ol>
<h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><p>构造器引用与方法引用很类似，只不过方法名为<code>new</code>。如，<code>Person::new</code>是<code>Person</code>构造器的一个引用。具体选择哪一个引用取决上下文。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ...;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Person&gt; people = stream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>Java有一个限制，无法构造泛型类型T的数组。数组构造器引用对于克服这个限制很有用。如：<code>new T[n]</code>会产生错误，因为这会改为<code>new Object[n]</code>。</p>
<p>但是我们可以使用<code>Stream.toArray()</code>来获得一个数组，如果不传参，则默认返回<code>Object[]</code>。</p>
<p>但是可以如果传入对象的构造器引用，则可以获得对应的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] people = stream.toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>在lambda表达式中，可以引用lambda表达式外部的变量。从而形成闭包（enclosure）。但是其由如下特点：</p>
<ol>
<li>引用的外部变量只能读取，不能改变。</li>
<li>在lambda表达式中引用的变量，在外部也不能别改变。</li>
</ol>
<p>简而言之，lambda表达式中捕获的变量必须实际上最终变量（effective final）。即这个变量初始化之后就不会再为它赋新值。</p>
<p>其还有如下特点：</p>
<ol>
<li>lambda表达式中声明的变量名不能为外部已经声明的变量名。</li>
<li>lambda表达式中的this，指向创建这个表达式的方法的this参数。</li>
</ol>
<p>java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的部分函数式接口有：</p>
<table><br>    <tr><br>        <td>序号</td><br>        <td>接口 &amp; 描述</td><br>    </tr><br>    <tr><br>        <td>1</td><br>        <td>BiConsumer&lt;T,U&gt;<br>代表了一个接受两个输入参数的操作，并且不返回任何结果<br></td><br>    </tr><br>    <tr><br>        <td>2</td><br>        <td>BiFunction&lt;T,U,R&gt;<br>代表了一个接受两个输入参数的方法，并且返回一个结果<br></td><br>    </tr><br>    <tr><br>        <td>3</td><br>        <td>BinaryOperator&lt;T&gt;<br>代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果<br></td><br>    </tr><br>    <tr><br>        <td>4</td><br>        <td>BiPredicate&lt;T,U&gt;<br>代表了一个两个参数的boolean值方法<br></td><br>    </tr><br>    <tr><br>        <td>5</td><br>        <td>BooleanSupplier<br>代表了boolean值结果的提供方<br></td><br>    </tr><br>    <tr><br>        <td>6</td><br>        <td>Consumer&lt;T&gt;<br>代表了接受一个输入参数并且无返回的操作<br></td><br>    </tr><br>    <tr><br>        <td>7</td><br>        <td>DoubleBinaryOperator<br>代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。<br></td><br>    </tr><br>    <tr><br>        <td>8</td><br>        <td>DoubleConsumer<br>代表一个接受double值参数的操作，并且不返回结果。<br></td><br>    </tr><br>    <tr><br>        <td>9</td><br>        <td>DoubleFunction&lt;R&gt;<br>代表接受一个double值参数的方法，并且返回结果<br>        </td><br>    </tr><br></table>



<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类（inner class）是定义在另一个类中的类。其存在原因主要有以下：</p>
<ol>
<li>内部类可以对同一个包中的其他类隐藏。</li>
<li>内部类的方法可以访问外部类的作用域中的数据，包括原本私有的数据。</li>
</ol>
<p>内部类原来是用来简洁的实现回调，但现在lambda表达式是更好的选择。</p>
<h2 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h2><p>我们可以通过<code>OuterClass.this</code>的语法来引用外部对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        pirvate String name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;			</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner i = o.getInner();				<span class="comment">//这样引用内部类</span></span><br><span class="line">i.getId();							<span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p>同样的，可以像上面代码中的<code>Outer.Inner</code>来从外部引用内部类。</p>
<h2 id="内部类的底层"><a href="#内部类的底层" class="headerlink" title="内部类的底层"></a>内部类的底层</h2><p>内部类实际上是编译器的工作，而不是虚拟机的工作。所以实际上编译器会把内部类转换为常规的类文件，用$分隔外部类名与内部类名，而虚拟机并不知晓。</p>
<p>例如，<code>Outer$Inner</code>表示其内部类。</p>
<p>实际上在内部类中，会生成一个<code>this$0</code>来表示外部引用。</p>
<p>而既然在虚拟机中内部类被分为两个类，又是如何做到访问外部类的私有成员呢。</p>
<p>其原因在于，编译器向外围类中添加了静态方法<code>access$0</code>之类的方法。它将返回作为参数传递的那个对象的字段。（具体名字取决于编译器。）</p>
<p>此时在内部类中调用外部的成员时。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(id)</span><br></pre></td></tr></table></figure>
<p>会被翻译为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Outer.access$<span class="number">0</span>(outer))</span><br></pre></td></tr></table></figure>
<p>例如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> general;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Innter</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被编译后会生成两个文件：</p>
<ul>
<li>Outer.class</li>
<li>Outer$Innter.class</li>
</ul>
<p>其代码分别如下：</p>
<p>Outer.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> general;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Innter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Innter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Outer.<span class="keyword">this</span>.id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Outer$Innter.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> general;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">Innter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Outer$Innter(Outer var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类是指在一个方法中局部的定义这个类。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BiSUM</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> newA, <span class="keyword">int</span> newB)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newA + newB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BiSUM bs = <span class="keyword">new</span> BiSUM();</span><br><span class="line">    <span class="keyword">return</span> bs.sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>局部类时不能拥有访问符（即<code>public</code>和<code>private</code>）</li>
<li>局部类的作用域仅限于在声明这个类的块中。</li>
<li>局部类可以做到完全隐藏，除了方法，连兄弟内部类都不知道。</li>
</ol>
<p><strong>局部内部类不仅可以访问外部类的字段，还可以访问方法的局部变量。</strong>但是，与lambda表达式类似，这些局部变量必须是最终变量。即，他们一旦赋值就绝不会改变。</p>
<p>同样的，编译器会在内部类中定义引用的局部变量的复制。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    String name = <span class="string">"123"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BiSUM</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> newA, <span class="keyword">int</span> newB)</span></span>&#123;</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            <span class="keyword">return</span> newA + newB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BiSUM bs = <span class="keyword">new</span> BiSUM();</span><br><span class="line">    <span class="keyword">return</span> bs.sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被翻译为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Outer$Inner&#123;</span><br><span class="line">    <span class="keyword">final</span> Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> val$name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>使用局部内部类时，通常还可以省略类名。这样的类被称为内部匿名类。</p>
<p>语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SuperType(construction parameters)&#123;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">method</span> <span class="title">and</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>superType可以是接口，如<code>ActionListener</code>，这样就是扩展这个接口。</strong></p>
<p>也可以是类，如果是这样，内部类就要扩展这个类。</p>
<p>由于匿名内部类没有名字，所以也没有构造器。如果需要初始化，则可以加一个对象初始化块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="keyword">new</span> Person(<span class="string">"Tim"</span>)&#123;</span><br><span class="line">    &#123;initialization&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用最多的实际上是一种我们常用的一种编程trick，即新建List并向其中初始化元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList()&#123;&#123;</span><br><span class="line">    add(<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">2</span>);</span><br><span class="line">    add(<span class="number">3</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并<strong>不需要内部类有外围类对象的一个引用</strong>。为此，可以将内部类声明为static，这样就不会生成那个引用。</p>
<p>注意：</p>
<ol>
<li>并且只有内部类可以声明为static。</li>
<li>与常规类不同，静态内部类可以有静态字段和方法。</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draw</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">Pair</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">getPair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Draw.Euclidean euclidean = Math.getPair(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这种形式其实更像是类的命名空间，相当于一个类的集合。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>接口、lambda表达式与内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中ES6代码的压缩问题</title>
    <url>/2019/03/16/webpack%E4%B8%ADES6%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>webpack中ES6代码压缩问题：</strong></p>
<p>在使用webpack插件<code>uglifyjs-webpack-plugin</code>压缩JS代码时，发现该插件只能压缩ES5-的代码，遇到ES6，就会报错<code>ERROR in xxx.js from UglifyJs</code>,遂查找解决办法。<br><a id="more"></a></p>
<h1 id="原理解决办法"><a href="#原理解决办法" class="headerlink" title="原理解决办法"></a>原理解决办法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如上所说，<code>uglifyjs-webpack-plugin</code>该插件仅支持ES5-的JS代码。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="1-不使用ES6语法"><a href="#1-不使用ES6语法" class="headerlink" title="1. 不使用ES6语法"></a>1. 不使用ES6语法</h3><p>这个办法理论上可行，但是面对ES6那么多方便快捷的语法，不使用的话会大大降低开发的进度，所以一般不使用该方法。</p>
<h3 id="2-使用babel-loader将ES6转化为ES5代码"><a href="#2-使用babel-loader将ES6转化为ES5代码" class="headerlink" title="2. 使用babel-loader将ES6转化为ES5代码"></a>2. 使用babel-loader将ES6转化为ES5代码</h3><p>该方法是网上流行最广的解决办法，具体是：</p>
<ol>
<li><p>安装es2015插件</p>
<p> <code>npm install --save babel-preset-es2015</code></p>
</li>
<li><p>安装babel-loader</p>
<p> <code>npm install babel-loader</code></p>
</li>
</ol>
<p>也许是我环境的问题，网上的教程上都没这一步，但是，如果不安装<code>babel-loader</code>，就会报错<code>ERROR in Entry module not found: Error: Can&#39;t resolve &#39;babel-loader&#39; in.........</code>,</p>
<p><strong>这一步需要注意的是：</strong></p>
<p>babel-loader必须与babel-core版本相同，否则会报错<code>Error: Cannot find module &#39;@babel/core&#39;</code>,这一点需要自己到<code>package.json</code>中查看<code>babel-loader</code>,与<code>babel-core</code>的版本来确定。（比如，babel-core版本是：6.23.3那么你装的babel-loader必须是7.1.5以下的版本，否则loader就与core不匹配了，注意如果直接<code>npm install babel-loader</code>，默认是安装8.0.0的，所以不兼容）</p>
<ol start="3">
<li>配置webpack.congfig.js</li>
</ol>
<p>在rules里加入对js代码的过滤</p>
<pre><code>{
  test: /\.js$/,
  loader: &apos;babel-loader&apos;,
  options:{
    presets:[&quot;es2015&quot;]
  },
  exclude:[/node_modules/]

}
</code></pre><ol start="4">
<li>建.babelrc文件</li>
</ol>
<p>在项目根目录新建一个文件名为<code>.babelrc</code>的文件，填入以下内容：</p>
<pre><code>{
&quot;presets&quot;: [&quot;es2015&quot;]
}
</code></pre><p>这是网上流传最广的办法，不过步骤繁琐，麻烦，下面介绍最优解决方案</p>
<h3 id="3-使用uglifyes-webpack-plugin插件"><a href="#3-使用uglifyes-webpack-plugin插件" class="headerlink" title="3.使用uglifyes-webpack-plugin插件"></a>3.使用uglifyes-webpack-plugin插件</h3><p>其实上面的坑都是我一个一个经历的，网上的解决办法都是不完整，当我踩完所有坑，感觉这个方法太繁琐了。然后我就准备去深入了解一下<code>uglifyjs-webpack-plugin</code>这个插件，结果无意间发现uglify有一个专门针对ES6的插件<code>uglifyes-webpack-plugin</code>，哇，一试就知道有多爽，完全没有那么多步骤：</p>
<p>安装：</p>
<pre><code>npm install uglifyes-webpack-plugin 
</code></pre><p>webpack.config.js：</p>
<ol>
<li><p><code>const UglifyEsPlugin = require(&quot;uglifyes-webpack-plugin&quot;);</code></p>
</li>
<li><p> plugins:[</p>
<pre><code>new MiniCssExtractPlugin({            //css压缩
    filename:&apos;[name][hash].css&apos;,
    chunkFilename:&apos;[id].[hash].css&apos;
})
</code></pre><p> ],<br> optimization:{</p>
<pre><code>minimizer :[
    new UglifyEsPlugin({}),   //直接引用
    new OptimizeCSSAssetsPligin({})        //css压缩
]
</code></pre></li>
</ol>
<p>其实就一句话：<code>new UglifyEsPlugin({}),</code>,与<code>uglifyjs-webpack-plugin</code>的使用一样简单。</p>
<p><strong>需要注意的是uglifyes-webpack-plugin与uglify-es-webpack-plugin并不是同一个插件，前者是官方的，也就是与uglifyjs-webpack-plugin一个维护者的，而后者已被弃用并不再维护</strong></p>
<p><strong>Point</strong></p>
<p>该插件默认就会将ES6代码改成ES5代码，并且有压缩，混淆等功能，与<code>uglifyjs-webpack-plugin</code>基本一致，下面是他的一些重要的API：</p>
<ol>
<li>test:匹配的文件，默认<code>/.js($|?)/i</code>，接受正则表达式</li>
<li>mangle:是否混淆代码，默认为true</li>
<li>sourceMap：是否启用SourceMap,默认为false</li>
<li>compress: 自定义压缩选项，内容是一个对象，默认{}，该选项下的子选项很重要，提一下<ol>
<li>sequences：是否使用逗号运算符来连接连续的表达式，默认true</li>
<li>properties：是否优化属性读取方式：a[“foo”] → a.foo，默认true</li>
<li>dead_code：是否丢弃不可达代码，默认true</li>
<li>drop_debugger：是否丢弃调试语句，默认true</li>
<li>unsafe：是否优化危险代码，默认false</li>
<li>conditionals：是否优化 if-else 条件语句，默认true</li>
<li>comparisons：是否优化比较代码，默认true</li>
<li>evaluate：是否直接计算常量的值，默认true</li>
<li>booleans：优化布尔表达式，默认true</li>
<li>loops：是否优化循环代码，默认true</li>
<li>unused：是否丢弃不使用的变量，函数，默认true。<strong>这里需要注意，如果你的函数本来就是一个DOM触发事件函数，请关闭此选项，否则，该函数将会被丢弃！！！</strong></li>
<li>hoist_funs：是否提升函数的申明，默认true</li>
<li>hoist_vars：是否提升变量的申明，默认false</li>
<li>if_return：是否优化优化if/return 和 if/continue</li>
<li>join_vars：是否将加入变量申明，默认true</li>
<li>cascade：优化连续语句，将 x, x 转成 x，x = something(), x 转成 x = something()——声明变量，默认true</li>
<li>side_effects：丢弃副作用声明，默认true</li>
<li>warnings：警告潜在的危险优化/代码，默认true</li>
<li>global_defs：定义全局变量，默认{}</li>
</ol>
</li>
<li>extractComments：是否要删除注释，默认false，接受boolean，正则，函数，对象。</li>
<li>include： 要转化的文件，默认无，接受字符串，正则</li>
<li>exclude：在test验证通过后不转化的文件，默认空，接受字符串，正则</li>
</ol>
<p><strong>相较于<code>uglifyjs-webpack-plugin</code>，<code>uglify-es-webpack-plugin</code>功能要相对少一些，但基本也能满足要求</strong></p>
<p><strong>附uglifyjs-webpack-plugin常用API：</strong></p>
<ol>
<li>test：测试匹配的文件，接受<code>String|RegExp|Array&lt;String|RegExp&gt;</code>,默认<code>/.js(?.*)?$/i</code></li>
<li>cache: 是否启用文件缓存 ，接受<code>Boolean|String</code>,默认<code>false</code></li>
<li>parallel:是否启用多进程来提高构建速度，接受<code>Boolean|Number</code>，默认<code>false</code></li>
<li>sourceMap: 是否启用SourceMap(将错误信息映射值模块源文件)，开启可能会降低编译速度，接受<code>Boolean</code>，默认<code>false</code></li>
<li>uglifyOptions：压缩选项<ol>
<li>extractComments：是否保留注释，接受<code>Boolen,String,RegEXp,function,Object</code>,默认false</li>
<li>warningsFilter:允许过滤uglify-js警告。返回true以保持警告，否则为false。接受<code>Function&lt;(warning, source) -&gt; Boolean&gt; Default: () =&gt; true</code></li>
</ol>
</li>
</ol>
<p>最后是UglifyJS的<a href="http://lisperator.net/uglifyjs/compress" target="_blank" rel="noopener">官网</a>。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>xhellAnEcsd</title>
    <url>/2018/07/22/xhellandcsd/</url>
    <content><![CDATA[<h1 id="关于ecs服务器的连接问题"><a href="#关于ecs服务器的连接问题" class="headerlink" title="关于ecs服务器的连接问题"></a>关于ecs服务器的连接问题</h1><p>最近看阿里云有一个学生优惠，就申请了一个优惠的ecs服务器，一个月9.9,2G内存，40G云盘，血赚不亏。<br><a id="more"></a><br>然后我就开始配置服务器，发现这个廉价的服务器是没办法更换操作系统的，自带的是一个<span style="color:red;font-size:20px">Windows Server 2008 32位。</span>然后我就开始准备连接服务器。阿里云自带有连接服务，但每天都要登陆网页会很麻烦。</p>
<p>然后我就下载了xshell，但一直连接不上，查看服务器端口配置，发现ssh端口22是打开的。后来我在网上查了很多资料，发现还是连接不上。最后我才意识到可能是操作系统的问题。果然我查询了sxhell支持的操作系统。得到如下结果：</p>
<ol>
<li>xshell等软件仅支持Linux，UNIX，centos等。</li>
<li>对于windows系统，需要用RDCMan或者windows自带的远程桌面连接。</li>
</ol>
]]></content>
      <categories>
        <category>ecs</category>
      </categories>
      <tags>
        <tag>ecs</tag>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术-I-8-泛型程序设计</title>
    <url>/2022/01/21/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-8-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="泛型简介"><a href="#泛型简介" class="headerlink" title="泛型简介"></a>泛型简介</h1><p>泛型实际上就是类型参数。即事先不确定参数类型，而在调用时传入对应参数类型才确定其类型。</p>
<p>在泛型出现之前，一般是使用多态来实现，即使用<code>Object</code>来接受所有参数，确定就是接收到参数后需要强转。</p>
<h2 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h2><p>泛型类（generic type）就是一个或多个类型变量的类。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.mw.ExceptionTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T first;</span><br><span class="line">	<span class="keyword">private</span> T second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.first = first;</span><br><span class="line">		<span class="keyword">this</span>.second = second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.first = first;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.second = second;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Pair类中引入了一个参数类型T。这里用尖括号&lt;&gt;进行定义。可以按如下格式进行实例化。三种方法都可以，但是第一种比较常用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair pair1 = <span class="keyword">new</span> Pair&lt;String&gt;(<span class="string">"1"</span>, <span class="string">"2"</span>);</span><br><span class="line">Pair&lt;String&gt; pair1 = <span class="keyword">new</span> Pair(<span class="string">"1"</span>, <span class="string">"2"</span>);</span><br><span class="line">Pair&lt;String&gt; pair1 = <span class="keyword">new</span> Pair&lt;String&gt;(<span class="string">"1"</span>, <span class="string">"2"</span>);</span><br></pre></td></tr></table></figure>
<p>同样的，我们可以，通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来定义多个类型泛型。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>同样的，我们可以定义带有泛型的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> staic &lt;T&gt; <span class="function">T <span class="title">getMid</span><span class="params">(T... a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>&#125;;</span><br><span class="line"></span><br><span class="line">ArrayAlg.getMid&lt;String&gt;(arr);</span><br></pre></td></tr></table></figure>
<p>注意这里的格式与类中稍有不同，需要按：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[限定符] [修饰符...] [&lt;泛型,...&gt;] [返回类型-可以为前面的泛型] [name]([parameters ...])&#123;</span><br><span class="line">    	<span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>我们可以通过以下格式来限定泛型继承了某个类或者实现了某个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Class1</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过以下格式来限定继承了多个父类或者实现了多个接口。（<strong>类和接口都是用extends</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Class1</span> &amp; <span class="title">Interface1</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h2><p>虚拟机中并没有泛型对象-所有的对象都是普通类，即其实际上是一个编译器的语法糖。其最主要的特点在于<strong>类型擦除</strong>。</p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>在Java编译器中，所有的泛型都将被擦除为最低限定类。最低限定类指符合上述限定规则的类型。</p>
<p>例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T first;</span><br><span class="line">	<span class="keyword">private</span> T second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.first = first;</span><br><span class="line">		<span class="keyword">this</span>.second = second;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被擦除为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object first;</span><br><span class="line">	<span class="keyword">private</span> Object second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.first = first;</span><br><span class="line">		<span class="keyword">this</span>.second = second;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为T没有限制。</p>
<p>例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Float</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T first;</span><br><span class="line">	<span class="keyword">private</span> T second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.first = first;</span><br><span class="line">		<span class="keyword">this</span>.second = second;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被擦除为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Float first;</span><br><span class="line">	<span class="keyword">private</span> Float second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Float first, Float second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.first = first;</span><br><span class="line">		<span class="keyword">this</span>.second = second;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为T被限定为继承了Float的类。所以被擦除为<code>Float</code>。</p>
<p>例3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T first;</span><br><span class="line">	<span class="keyword">private</span> T second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.first = first;</span><br><span class="line">		<span class="keyword">this</span>.second = second;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被擦除为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Serializable first;</span><br><span class="line">	<span class="keyword">private</span> Serializable second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Serializable first, Serializable second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.first = first;</span><br><span class="line">		<span class="keyword">this</span>.second = second;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有多个限定时规则如下：</p>
<ul>
<li><strong>将类型转换为第一个超类（接口）。</strong></li>
<li>在必要时需要向<code>Comparable</code>接口插入强制类型转换。</li>
</ul>
<p><strong>所以应该尽量把包含方法的接口方法在第一个，可以减少强制转换。提高效率。</strong></p>
<h3 id="转换泛型表达式"><a href="#转换泛型表达式" class="headerlink" title="转换泛型表达式"></a>转换泛型表达式</h3><p>由于编译器对泛型做了擦除。所以实际上<strong>编译器</strong>在接受到泛型的位置加上了强制类型转换。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, Integer&gt; pair = <span class="keyword">new</span> Pair(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Integer f = pair.getFirst();</span><br></pre></td></tr></table></figure>
<p>实际上会被转化为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair pair = <span class="keyword">new</span> Pair(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Integer f = (Integer)pair.getFirst();</span><br></pre></td></tr></table></figure>
<p>因为这里<code>pair.getFirst()</code>返回的实际上是<code>Object</code>。</p>
<h3 id="泛型方法与桥方法"><a href="#泛型方法与桥方法" class="headerlink" title="泛型方法与桥方法"></a>泛型方法与桥方法</h3><p>泛型方法也一样会被擦除类型，与类一样的规则。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> staic &lt;T&gt; <span class="function">T <span class="title">getMid</span><span class="params">(T... a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被擦除为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> staic Object <span class="title">getMid</span><span class="params">(Object... a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说是不会存在问题，但是如果出现以下情况：</p>
<p>原Pair类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T first;</span><br><span class="line">	<span class="keyword">private</span> T second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.first = first;</span><br><span class="line">		<span class="keyword">this</span>.second = second;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.first;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">  	<span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.second;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Piar</span>&lt;<span class="title">LocalDate</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类型擦除之后，会编为如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Piar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是由于父类原始的<code>setSecond</code>参数类型为T，则会被擦除为<code>Object</code>，所以实际上这个类中会包含两个<code>setSecond</code>方法</p>
<ul>
<li><code>public void setSecond(Object second)</code>：来自擦除后的父类。</li>
<li><code>public void setSecond(LocalDate second)</code>：来自擦除后的本身类。 </li>
</ul>
<p>那么考虑如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> interval = <span class="keyword">new</span> DateInterval(...);</span><br><span class="line">Pair&lt;LocalDate&gt; pair = interval;</span><br><span class="line">pair.setSecond(aDate);</span><br></pre></td></tr></table></figure>
<p>这里我们将子类赋值给父类。而父类由于是个泛型类，所以其<code>setSecond(T second)</code>会被擦除为<code>setSecond(Object second)</code>。</p>
<p>我们实际上是想调用子类的<code>public void setSecond(LocalDate second)</code>方法。但是由于父类并没有这个<strong>重载方法</strong>，所以会调用父类的<code>public void setSecond(Object second)</code>方法。这样就不符合我们的预期了。</p>
<p>所以编译器创建了所谓的<strong>桥方法</strong>。这个桥方法会去调用子类的方法<code>DataInterval.setSecond(LocalData);</code>。</p>
<p>但是考虑如下情况：</p>
<p>当子类重载了父类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (LocalDate)<span class="keyword">super</span>.getSecond()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在子类中，经过擦除之后，会有以下这个两个方法：</p>
<ul>
<li><code>LocalDate getSecond()</code></li>
<li><code>Object getSecond()</code></li>
</ul>
<p>虽然我们在编写代码时并允许这样的情况存在，因为方法名和参数共同构成了方法的方法签名用于识别这个方法。</p>
<p>但由于这是编译器生成的，所以虚拟机能够正确处理这种情况。</p>
<p>所以实际需要记住以下的特点：</p>
<ul>
<li>虚拟机中没有泛型，只有普通的累和方法。</li>
<li>所有的类型参数都会被替换为它们的限定类型。</li>
<li><strong>会合成桥方法来保持多态。</strong></li>
<li>为保持类型安全性，必要时会插入强制类型转换。</li>
</ul>
<h1 id="限制与局限性"><a href="#限制与局限性" class="headerlink" title="限制与局限性"></a>限制与局限性</h1><h2 id="1-不能用基本类型实例化类型参数"><a href="#1-不能用基本类型实例化类型参数" class="headerlink" title="1. 不能用基本类型实例化类型参数"></a>1. 不能用基本类型实例化类型参数</h2><p>不能用基本类型实例化类型参数。即没有<code>Pair&lt;double&gt;</code>，只有<code>Pair&lt;Double&gt;</code>。其主要原因还是在于类型擦除。擦除之后，Pair类含有Object类型的字段，而Object不能存储基本类型。但是也并会有很大的影响，因为每种基本类型都有其包装类型。</p>
<h2 id="2-类型查询不能检查出同一类别泛型的不同"><a href="#2-类型查询不能检查出同一类别泛型的不同" class="headerlink" title="2. 类型查询不能检查出同一类别泛型的不同"></a>2. 类型查询不能检查出同一类别泛型的不同</h2><p>即类型查询只产生原始类型。</p>
<p>所以，<code>instanceof</code>不能用于检查泛型类型，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(pair1 <span class="keyword">instanceof</span> Pair&lt;String&gt;)&#123;&#125;; 	<span class="comment">//Cannot perform instanceof check against parameterized type Pair&lt;String&gt;. Use the form Pair&lt;?&gt; instead since further generic type information will be erased at runtime</span></span><br></pre></td></tr></table></figure>
<h2 id="3-不能创建参数化类型的数组"><a href="#3-不能创建参数化类型的数组" class="headerlink" title="3. 不能创建参数化类型的数组"></a>3. 不能创建参数化类型的数组</h2><p>以下代码会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];	<span class="comment">//Cannot create a generic array of Pair&lt;String&gt;</span></span><br></pre></td></tr></table></figure>
<p>其原因也在于类型擦除，如果允许这种机制的存在，那么擦除后table将是一个<code>Object[]</code>，但我们期望的是<code>Pair&lt;String&gt;</code>类型，则类型检查失效，因此禁用这样的声明。</p>
<p>注意：声明这种类型是允许的，但是使用其初始化是不允许的。</p>
<p>要想存储泛型数组有以下两种方法：</p>
<ol>
<li><p>先使用通配类型来初始化，在强转为对应类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> table = (Pair&lt;String&gt;[]) <span class="keyword">new</span> Pair&lt;?&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>但这样并不安全，因为这样同样会失去对泛型的类型检查。</p>
</li>
<li><p>使用<code>ArrayList</code>来存储泛型对象：<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code></p>
</li>
</ol>
<h2 id="4-Varargs警告"><a href="#4-Varargs警告" class="headerlink" title="4. Varargs警告"></a>4. Varargs警告</h2><p>上面提到了不能创建泛型类数组，但是当我们向方法中传递可变长参数时，方法内部实际得到的是一个对应参数类型的数组。那么如果传递的是泛型类的对象，则违背了第3条规定。此时虚拟机是允许这种方式的存在，但是会产生一个<code>Varargs</code>警告。</p>
<blockquote>
<p>Type safety: Potential heap pollution via varargs parameter pairs</p>
</blockquote>
<p>有两种方法可以来抑制这个错误：</p>
<ol>
<li>增加注解<code>@SuppressWarning(&quot;unchecked&quot;)</code></li>
<li>增加注解<code>@SafeVarargs</code></li>
</ol>
<h2 id="5-不能实例化类型变量"><a href="#5-不能实例化类型变量" class="headerlink" title="5. 不能实例化类型变量"></a>5. 不能实例化类型变量</h2><p>不能在类似<code>new T(...)</code>的表达式中使用类型变量。</p>
<p>在Java8之后，最好的解决办法是让调用者提供一个构造器表达式。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p><code>makePair</code>接受一个<code>Supplier&lt;T&gt;</code>，这是一个函数式接口，表示一个无参数而且返回类型为T 的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java8之前，一般是通过反射<code>Constructor.new Instance</code>来实现。</p>
<p>但是不能通过<code>T.class.getConstructor().newInstance()</code>来构建，<strong>因为T会被擦除为<code>Object</code></strong>。</p>
<p>一个示例的函数应当如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(cl.getConstructor().newInstance(), cl.getConstructor().newInstance());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="comment">// handle Exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="6-不能构造泛型数组"><a href="#6-不能构造泛型数组" class="headerlink" title="6. 不能构造泛型数组"></a>6. 不能构造泛型数组</h2><p>不能实例化泛型变量，则同样的，也不能构造泛型数组。</p>
<p>即<code>T[] mm = new T[2];</code>这样是不合法的。</p>
<p>类型擦除会使其总构造出<code>Object[]</code>。</p>
<p>这里同样可以</p>
<ul>
<li>使用提供构造器<code>String[]::new</code>。</li>
<li>使用反射<code>Array.newInstance</code>来实现。</li>
</ul>
<h2 id="7-泛型类的静态上下文中类型变量无效"><a href="#7-泛型类的静态上下文中类型变量无效" class="headerlink" title="7. 泛型类的静态上下文中类型变量无效"></a>7. 泛型类的静态上下文中类型变量无效</h2><p>即<strong>不能在静态字段或方法中引用类型变量</strong>。即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T var1;		<span class="comment">//Cannot make a static reference to the non-static type T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-不能抛出或捕获泛型类的实例"><a href="#8-不能抛出或捕获泛型类的实例" class="headerlink" title="8. 不能抛出或捕获泛型类的实例"></a>8. 不能抛出或捕获泛型类的实例</h2><p>既不能抛出也不能捕获泛型类的对现象。实际上，泛型类扩展<code>Throwable</code>甚至都是不合法的。</p>
<p>如扩展<code>Throwable</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;	<span class="comment">//ERROR--can`t extend Throwable</span></span><br></pre></td></tr></table></figure>
<p>抛出含有泛型的<code>Throwable</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(T e)&#123;		<span class="comment">// ERROR--can`t catch type variable</span></span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，在异常规范中使用类型变量是允许的。即以下方法是合理的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="keyword">void</span> d&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-可以取消对检查型异常的检查"><a href="#9-可以取消对检查型异常的检查" class="headerlink" title="9. 可以取消对检查型异常的检查"></a>9. 可以取消对检查型异常的检查</h2><p>Java异常处理的一个基本原则是，必须为所有检查型异常提供一个处理器。不过可以利用泛型取消这个机制。</p>
<h2 id="10-注意擦除后的冲突"><a href="#10-注意擦除后的冲突" class="headerlink" title="10. 注意擦除后的冲突"></a>10. 注意擦除后的冲突</h2><p>当泛型类型被擦除后，不允许创建引发冲突的条件。</p>
<p>假定Piar类增加一个<code>equals</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> blooean <span class="title">equals</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当T为String时，则在类型擦除之前，其会有两个<code>equals</code>方法：</p>
<ul>
<li><code>boolean equals(String var)</code>：定义在Pair中</li>
<li><code>blooean equals(Object var)</code>：从Object中继承</li>
</ul>
<p>但是在擦除之后就会有两个相同的<code>blooean equals(Object)</code>方法，这就产生了冲突。</p>
<p>所以，泛型还增加了另外一个原则：<strong>如果两个接口类型是同一接口的不同参数化，一个类或类型变量就不能同时作为这两个接口类型的子类</strong>。即如下代码就是错误的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Manager</span>&gt;</span>&#123;...&#125;		<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>其原因在于，又可能会与合成的桥方法产生冲突。</p>
<p>实现<code>Comparable&lt;X&gt;</code>的类将会获得一个桥方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">comparaTo</span><span class="params">(Object other)</span></span>&#123;<span class="keyword">return</span> compareTo((X) other);&#125;</span><br></pre></td></tr></table></figure>
<p>不能对不同的类型x有两个这样的方法。</p>
<h2 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h2><p>泛型中的继承规则很简单，就是<strong>类型参数完全与继承链无关</strong>。</p>
<p>例如，<code>ArrayList&lt;Double&gt;</code>与<code>ArrayList&lt;Number&gt;</code>完全没有关系。</p>
<p>而<code>ArrayList&lt;Double&gt;</code>是<code>AbstractList&lt;Double&gt;</code>的一个子类。（<code>ArrayList&lt;E&gt;</code>是<code>AbstractList&lt;E&gt;</code>的子类）</p>
<p><code>ArrayList&lt;Double&gt;</code>是对原<code>ArrayList&lt;E&gt;</code>的一个继承。</p>
<h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>由于Java中的泛型规定的很严格，所以设计了“<strong>通配符类型</strong>”来缓解。</p>
<h3 id="子类型限定"><a href="#子类型限定" class="headerlink" title="子类型限定"></a>子类型限定</h3><p>在通配符类型中，允许类型参数发生变化，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;? extends Employee&gt; pair1 = <span class="keyword">new</span> Pair&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>
<p>表示任何泛型<code>Pair</code>类型，只要其为Employee或者其子类即可。如<code>Pair&lt;Manager&gt;</code>。</p>
<p>记得前面说的，泛型参数中不允许其子类多态存在。即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不能这么定义Pair</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Employee&gt; pair1 = <span class="keyword">new</span> Pair&lt;Manager&gt;();</span><br></pre></td></tr></table></figure>
<p>但是现在可以使用通配符来实现该功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;? extends Employee&gt; = <span class="keyword">new</span> Pair&lt;Manager&gt;();</span><br></pre></td></tr></table></figure>
<p>所以从继承的角度来说，</p>
<p><code>Pair&lt;Manager&gt;</code>和<code>Pair&lt;Employee&gt;</code>继承自<code>Pair&lt;? extends Employee&gt;</code>；</p>
<p><code>Pair&lt;? extends Employee&gt;</code>继承自<code>Pair&lt;T&gt;</code>；</p>
<p><strong>但是其缺点在于其不能调用含通配类型的参数的方法</strong>，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;? extends Employee&gt; pari1= <span class="keyword">new</span> Pair&lt;Manager&gt;();</span><br><span class="line">pair1.setFirst(employee1);			<span class="comment">//compile error</span></span><br></pre></td></tr></table></figure>
<p>这是因为在编译器中，<code>setFirst</code>接受的参数是一个继承自<code>Employee</code>，但不知道具体是什么类型。<strong>所以它拒绝接受任何特定的类型</strong>。毕竟?不能匹配。（也就是说：<strong>编译器并不知道具体代码中的继承链，？仅仅是占位</strong>）</p>
<p>但是<code>getFirst</code>是可以执行的，因为其将<code>getFirst</code>的返回值赋值给一个<code>Employee</code>是完全合法的。</p>
<h3 id="超类型限定"><a href="#超类型限定" class="headerlink" title="超类型限定"></a>超类型限定</h3><p>超类型限定限定指限定?必须为某一个类的父类。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">? <span class="keyword">super</span> Manager</span><br></pre></td></tr></table></figure>
<p>指定?必须为Sub的父类。</p>
<p>则这里的行为与子类限定相反，<strong>?不能作为方法的返回值，但是可以作为方法的参数。</strong>其道理也恰好相反。</p>
<p><code>setFirst</code>方法中，编译器无法知道其具体类型，所以不能接受参数类型为<code>Employee</code>或者<code>Object</code>的方法调用。只能传递Manager类的对象，或者某个子类型。另外，如果调用<code>getFirst</code>方法，不能保证返回对象的类型。只能将其赋值给一个<code>Object</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>带有子类型限定符的泛型通配符允许你获取一个泛型对象；而带有超类型限定符的泛型通配符允许你写入一个对象。</strong></p>
<p>其主要原因我们需要理解一个点就是：<strong>？仅仅是一个类的限定代指，他不会翻译为任何具体的类，也就是说编译器不会判断你传入的这个类是否是XXX的子类或者父类，其只会按照可以安全转换的方式来执行</strong>。</p>
<p>比如子类限定，<code>? extends Employee</code>，这里的？仅仅是限定一个<code>Employee</code>子类的代指。而且编译器不会判定我们传入的类型是否是其子类。所以即使我们传入<code>Manager</code>，也不会被接受，因为根本不会判断。但是get方法返回的?可以确定为Employee的子类，所以可以在在外部被接收到。</p>
<p>父类限定也是一样，记住?不代表任何具体的类，其只是一个限定的代指，编译器不会为其做任何判定。</p>
<h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><p>除了上面的限定通配符，无限定通配符也是存在的：<code>Pair&lt;?&gt;</code>。其可以看成<code>Pair&lt;? extends Object&gt;</code>。因为所有的对象都是基于<code>Object</code>，所以也相当于无限定。</p>
<p>这相当于是子类限定，所以其set方法仍然是无法调用的。而get方法会返回一个<code>Object</code>对象。</p>
<p>所以虽然无限定通配符<code>Pair&lt;?&gt;</code>与泛型类型<code>Pair&lt;T&gt;</code>形式上相似，但实际上是不相同的。</p>
<h3 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h3><p>所谓通配符捕获，即解决无法在方法中获取含有通配符的类的通配符类型的问题，具体例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不能拿到?的类型</span></span><br><span class="line">    ? temp = p.getFirst();		<span class="comment">//ERROR</span></span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是错误的，因为<code>?</code>不能用来声明变量。（就像之前说的，它不代表任何一个具体的类，其只是一个限定）</p>
<p>但是我们要实现这样功能又该怎么做呢？</p>
<p>可以用一个辅助类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Paor&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">    T temp = p.getFirst();		<span class="comment">//ERROR</span></span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再swap中调用helper类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wapHelper(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们将p传入helper中，而helper是一个普通泛型类，所以其可以捕捉T的类型。</p>
<p>当然这个例子看起来有点蠢，但只是一个例子。</p>
<h2 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h2><p>如果通过反射去分析泛型参数，那么将不会得到太多信息，因为其已经被编译器擦除了，而反射是工作在虚拟机中的。</p>
<h3 id="泛型Class类"><a href="#泛型Class类" class="headerlink" title="泛型Class类"></a>泛型Class类</h3><p>Class类实际是一个泛型类。如：<code>String.class</code>实际上是一个<code>Class&lt;String&gt;</code>类的对象。（也是唯一的对象）</p>
<h3 id="使用Class-lt-T-参数进行类型匹配"><a href="#使用Class-lt-T-参数进行类型匹配" class="headerlink" title="使用Class\&lt;T>参数进行类型匹配"></a>使用Class\&lt;T>参数进行类型匹配</h3><p>匹配泛型方法中<code>Class&lt;T&gt;</code>参数的类型变量有时会很有用。比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> InstantiataionException, IllegalAccesssException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(c.newInstance(), c.newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在外部，我们就可以这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">makePair(Empployee<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>即通过<code>Class&lt;T&gt;</code>反射来新建特定类的对象。</p>
<h3 id="虚拟机中的泛型类型信息"><a href="#虚拟机中的泛型类型信息" class="headerlink" title="虚拟机中的泛型类型信息"></a>虚拟机中的泛型类型信息</h3><p>Java泛型的突出特点之一是在虚拟机中擦除泛型类型。但实际上，在擦除过后，其类型仍然保留对泛型的微弱信息。例如，原始的Pair类知道其是源于泛型类<code>Pair&lt;T&gt;</code>，虽然并不知道T具体为什么类型。</p>
<p>我们可以通过反射<code>java.lang.reflect</code>包中的接口<code>Type</code>来查看一些信息：</p>
<ul>
<li>Class类：描述具体类型。</li>
<li><code>TypeVariable</code>接口：描述类型变量（如<code>T extends Comparable&lt;? super T&gt;</code>）</li>
<li><code>WildcardType</code>接口：描述通配符（如<code>? super T</code>）</li>
<li><code>ParameteriszedType</code>接口：描述泛型类或接口类型（如<code>Comparable&lt;? super T&gt;</code>）</li>
<li><code>GenericArrayType</code>接口：描述泛型数组（如<code>T[]</code>）</li>
</ul>
<p>以上的接口都继承自<code>Type</code>接口，而<code>Class&lt;T&gt;</code>是<code>Type</code>的实现。</p>
<h3 id="类型字面量-重要"><a href="#类型字面量-重要" class="headerlink" title="类型字面量-重要"></a>类型字面量-重要</h3><p>如上一节介绍的，我们可以通过反射来获取泛型的相关信息，因此，我们也可以通过这种方式来捕获泛型类型，假设定义了一个泛型类\&lt;T>，我们可以通过以下示例的方式来捕获其类型接口<code>Type</code>来进行判断和处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeLiteral</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Type type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TypeLiteral</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Type parentType = getClass().getGenericSuperClass();</span><br><span class="line">        <span class="keyword">if</span>(parentType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            type = ((ParameterizedType) parentType).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Construct as new TypeLiteral&lt;...&gt;()&#123;&#125;"</span>)</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在调用时需要这么调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="keyword">new</span> TypeLiteral&lt;ArrayList&lt;Integer&gt;&gt;()&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>注意这里的格式是在new之后加了一个大括号，这种格式有以下几种类型：</p>
<ol>
<li><p><strong>创建其匿名内部类</strong>，如<code>new Parent(){}</code>实际上创建了一个<code>Parent</code>的子类。{}内部可以重写其方法。值得注意的是，我们可以用<code></code>来表示初始化块。实际之前也介绍过，其等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//init</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际中我们可以通过继承<code>ArrayList</code>或者<code>HashMap</code>然后用初始化块的方式来快速为其赋值(但注意，这里实际用的就是对应类型的子类，而不是其本身，虽然方法都继承了过来)。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Object&gt; study = <span class="keyword">new</span> HashMap&lt;String,Object&gt;()&#123;&#123;</span><br><span class="line">    put(<span class="string">"name"</span>,<span class="string">"java"</span>);</span><br><span class="line">    put(<span class="string">"id"</span>,<span class="string">"1"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">2</span>);</span><br><span class="line">    add(<span class="number">3</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p><strong>实例化接口</strong>，同样的，我们可以通过这种方式来实现一个接口，比如最常见的，<code>Runable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接开启一个线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程开启！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里有一篇关于这种写法的 <a href="https://blog.csdn.net/weixin_39570751/article/details/121253167?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ELandingCtr%7EHighlightScore-2.queryctrv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ELandingCtr%7EHighlightScore-2.queryctrv2&amp;utm_relevant_index=3" target="_blank" rel="noopener">文章</a>，其内容大致是正确的，但是有些表述不太准确。供参考。</p>
]]></content>
      <categories>
        <category>Jav</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术</tag>
        <tag>java核心技术-I-8-泛型程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>requestWrapper的用法</title>
    <url>/2022/06/22/requestWrapper%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><code>requestWrapper</code>实际上是一种装饰器模式的类。该类位于<code>javax.servlet.http</code>下，也是Java官方提供的包，与<code>HttpServletRequest</code>等位于同一个包下。他本身并没有任何功能，其会直接调用包装类的的方法。</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>该类的主要作用就是提供给开发者一个自定义request的父类。由于其功能是直接调用包装类，所以开发者可以直接继承该类，然后自定义改变原来request中的默认方法。</p>
<h2 id="为什么不直接实现一个类似的包装类？"><a href="#为什么不直接实现一个类似的包装类？" class="headerlink" title="为什么不直接实现一个类似的包装类？"></a>为什么不直接实现一个类似的包装类？</h2><p>由于request存在很多的方法，开发者并不知道应用中会使用到哪些方法，所以就必须要像<code>requestWrapper</code>一样全部重写，不需要的自定义的方法还要使用<code>super.xxx()</code>来调用。这实际上是一种冗余的行为。而这一部分由装饰器类来实现，我们直接继承该类，然后去自定义需要修改的方法就行，就免去了不需要的方法重写。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>前面提到<code>requestWrapper</code>本身就是一个装饰器，我们可以自定义我们需要的方法，而这个类应用最广泛的地方莫过于request body的多次读取问题。详见<a href="https://www.mw530.cn/2022/06/21/SpringMVC%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%85%A8%E8%A7%A3%E4%B8%8EJSON%E5%B1%9E%E6%80%A7%E5%88%86%E8%A7%A3/" target="_blank" rel="noopener">SpringMVC参数解析全解与JSON属性分解</a>。</p>
<h2 id="解决request-body的多次读取问题"><a href="#解决request-body的多次读取问题" class="headerlink" title="解决request body的多次读取问题"></a>解决request body的多次读取问题</h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: MichaelWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/6/20 19:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: XPanRequestWrapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPanRequestWrapper</span>  <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a wrapper for the specified request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request The request to be wrapped</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XPanRequestWrapper</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">        body = IOUtils.toByteArray(<span class="keyword">super</span>.getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestBodyCachingInputStream(body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBodyCachingInputStream</span> <span class="keyword">extends</span> <span class="title">ServletInputStream</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lastIndexRetrieved = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> ReadListener listener;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RequestBodyCachingInputStream</span><span class="params">(<span class="keyword">byte</span>[] body)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.body = body;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isFinished()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = body[lastIndexRetrieved + <span class="number">1</span>];</span><br><span class="line">            lastIndexRetrieved++;</span><br><span class="line">            <span class="keyword">if</span> (isFinished() &amp;&amp; listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onAllDataRead();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    listener.onError(e);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lastIndexRetrieved == body.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This implementation will never block</span></span><br><span class="line">            <span class="comment">// We also never need to call the readListener from this method, as this method will never return false</span></span><br><span class="line">            <span class="keyword">return</span> isFinished();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadListener</span><span class="params">(ReadListener listener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"listener cann not be null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"listener has been set"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.listener = listener;</span><br><span class="line">            <span class="keyword">if</span> (!isFinished()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onAllDataRead();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    listener.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onAllDataRead();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    listener.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> body.length - lastIndexRetrieved - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            lastIndexRetrieved = body.length - <span class="number">1</span>;</span><br><span class="line">            body = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义返回的属性"><a href="#自定义返回的属性" class="headerlink" title="自定义返回的属性"></a>自定义返回的属性</h2><p>例如，重写<code>getParameter</code>方法，如果遇到某个值就返回特定的值。</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">"xpan"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"xpan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getParameter(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getParameter(<span class="string">"xpan"</span>);</span><br><span class="line">---&gt;<span class="string">"xpan"</span></span><br></pre></td></tr></table></figure>
<p>但是这种用法并不常见，仅作为抛砖引玉。</p>
<h2 id="切面做日志记录"><a href="#切面做日志记录" class="headerlink" title="切面做日志记录"></a>切面做日志记录</h2><p>由于这种包装模式，我们也可以用来为日志记录，即调用request的方法时，进行日志记录。</p>
<p>例如，重写<code>getMethod</code>方法，在返回方法之前，打印调用的的函数和结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Throwable ex = <span class="keyword">new</span> Throwable();</span><br><span class="line">    StackTraceElement[] stackElements = ex.getStackTrace();</span><br><span class="line">    StackTraceElement stackElement = stackElements[<span class="number">0</span>];</span><br><span class="line">    System.out.println(stackElement.getClassName());<span class="comment">//返回类的完全限定名，该类包含由该堆栈跟踪元素所表示的执行点。</span></span><br><span class="line">    System.out.println(stackElement.getFileName());<span class="comment">//返回源文件名，该文件包含由该堆栈跟踪元素所表示的执行点。</span></span><br><span class="line">    System.out.println(stackElement.getLineNumber());<span class="comment">//返回源行的行号，该行包含由该堆栈该跟踪元素所表示的执行点。</span></span><br><span class="line">    System.out.println(stackElement.getMethodName());<span class="comment">//返回方法名，此方法包含由该堆栈跟踪元素所表示的执行点。</span></span><br><span class="line">    System.out.println(<span class="string">"调用方法：getMethod"</span>+<span class="string">"--- 结果为："</span>+ <span class="keyword">super</span>.getMethod());<span class="comment">//返回方法名，此方法包含由该堆栈跟踪元素所表示的执行点。</span></span><br><span class="line">    System.out.println(<span class="string">"------------------------------------------------------------"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priv.mw.xpan.utils.XPanRequestWrapper</span><br><span class="line">XPanRequestWrapper.java</span><br><span class="line">44</span><br><span class="line">getMethod</span><br><span class="line">调用方法：getMethod--- 结果为：GET</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综合来说，这种装饰器模式大致就相当于AOP，可以劫持方法，达到Spring中AOP的效果。上面实际上就是<em>缓存优化</em>、<em>方法功能修改</em>和<em>日志记录</em>。所以在实际场景中，需要对request进行自定义的方法都可以通过该类进行代理。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>requestWrapper</tag>
      </tags>
  </entry>
  <entry>
    <title>《亮剑》精神-军人的尊严</title>
    <url>/2018/07/25/%E3%80%8A%E4%BA%AE%E5%89%91%E3%80%8B%E7%B2%BE%E7%A5%9E/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/08/31/PvalPH.jpg" alt="PvalPH.jpg"><br>近来3天读完了《亮剑》一书。说来奇怪，平时读书无不是强忍困意的煎熬，唯独这本书，里面的情节，人物，仿佛有莫大的吸引力。把我带入那个战火纷飞的年代……<br><a id="more"></a><br>我对李云龙的理解，仅限于电视剧中的那个形象，鲁莽，草率，但却勇敢，敢作敢当，思维已与常人。甚至当我刚读到原著时，我也这么认为，因为电视剧几乎是忠于原文，没有做改动，确是都梁笔下的那个李云龙。</p>
<p>但也是当我读到后来我才发现，电视剧未免有些片面，只塑造了一个能征善战的李云龙，这恐怕不是都梁的本意，也是由于敏感原因，导演无法将都梁笔下的那个李云龙活生生塑造出来。不过在我看来，李云龙这个人物的关键就在于后面的部分，前面的部分塑造了他的英勇，而后面李云龙的改变与他的坚持正是这个人物的灵魂所在。他在成长，却也有他坚持的信条！</p>
<p>当他岳父谈及党内出现错误之时，他严厉的表示反对，因为他认为他跟及的共产党是不可能犯错误的，错在岳父根深蒂固的资产阶级思想。甚至在他的岳父岳母被拉到农村进行改造之时他仍认为这是他们的错误所对应的惩罚。</p>
<p>他信念的动摇是在赵刚死之后，作为搭档十几年的老战友，他相信赵刚是不会犯这种错误的，但他还是不明白到底是谁的错，他要去打死害死赵刚的人，被田雨制止，从这里他开始了他的思考，到底是谁的错误，使这些原本无罪的人受到非人的待遇。</p>
<p>当时他已是一军之长，管理着一个军的庞大队伍，而这一个军队却被两派所谓的左系革命派骑在头上，当其中一派要求得到他的支持时，他装病躲进来医院，以此来避开，而新来的副军长马天生确实一个极其“聪明”之人，他在李云龙“养病”之时，选着了其中一方支持，而另一方却得到省军区的支持。两派系随之进入了军事级别的斗争，若不是书中描述，我怎么也不会想到两个工人组成的团体可以在一座城市中兵戎相见，动辄就是大炮相见，甚至想要夺取军库，拿取大型榴弹炮，而这种榴弹炮的攻击半径几乎是半个城市。</p>
<p>李云龙不敢抵抗，因为一旦抵抗，毫无疑问，下场和赵刚没有区别。李云龙是个聪明人，他一忍再忍，企图想到一个两全其美的办法，但还没等到他想出来，他的一个师部就被革命派占领，军事机密，武器全落入他人之手，他明白只意味着什么，一旦不加以制止，整个城市都将毁于一旦。</p>
<p>李云龙还是那个李云龙，他亮剑了。就如同他在平安城下的那句“开炮！”。他开始下达了命令。这命令也代表这李云龙的灭亡，一颗流星的陨落，一个时代的结束。</p>
<p>最终，李云龙在他家里的阁楼上用那把楚云飞送他的勃朗宁手枪结束了自己的一生。</p>
<p>赵刚在临终的信中写着死亡也是一种反抗，他是对自己信条的坚持，所不同的是，李云龙坚持的是他的军人尊严！宁死不屈的精神！</p>
<p>原文中对李云龙自杀前用了大量的文笔，无非是为了诠释，李云龙一生戎马，可倾尽一生，也无法想出，到底是谁的错，毛主席不会错，共产党不会错，那可能就是他李云龙的错误吧。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>读书</tag>
        <tag>感情</tag>
      </tags>
  </entry>
  <entry>
    <title>开发一个简单的个人博客（1）UI设计</title>
    <url>/2018/08/13/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%881%EF%BC%89UI%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本来早该写这个博客，因为前一段时间一直在学习各种框架，为这个开发做准备。所以一直拖到现在才开始这个系列的文章，估计这个系列文章会持续4-5期，来写下我开发这个网站的全过程。我会尽力开发到理想状态，具体效果在月底估计会出来。<br><a id="more"></a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h2><hr>
<p>在具体开发开发之前，我先概括的设计出来一个几个用户界面，包括主页，文章界面，后台用户界面。具体设计软件时使用Axure。</p>
<h3 id="主页界面"><a href="#主页界面" class="headerlink" title="主页界面"></a>主页界面</h3><hr>
<p><img src="https://s1.ax1x.com/2018/08/13/Pg819e.png" alt="Pg819e.png"><br>主页是采用了比较简洁通用的设计样式，顶部是采用了稍隐藏式的顶部栏样式，顶部栏左侧是Tags,Home链接；左侧是后台界面的登录按钮。其次整个上部是一个轮播图，右侧是一个作者介绍，包括简书，github等的链接，头像，头像左侧准备设计一个按钮，点击时头像隐藏到右侧。</p>
<p><img src="https://s1.ax1x.com/2018/08/13/Pg8MtO.png" alt="Pg8MtO.png"></p>
<h2 id="在底部没有采用过多的装饰，作者权限以及在有条件下可以开发一个浏览人数（图片上未展示）。"><a href="#在底部没有采用过多的装饰，作者权限以及在有条件下可以开发一个浏览人数（图片上未展示）。" class="headerlink" title="在底部没有采用过多的装饰，作者权限以及在有条件下可以开发一个浏览人数（图片上未展示）。"></a>在底部没有采用过多的装饰，作者权限以及在有条件下可以开发一个浏览人数（图片上未展示）。</h2><h3 id="文章界面"><a href="#文章界面" class="headerlink" title="文章界面"></a>文章界面</h3><p><img src="https://s1.ax1x.com/2018/08/13/Pg88cd.png" alt="Pg88cd.png"><br>文章界面上部是没有做改动，与主页界面一样，唯一不同的是轮播图改为静态图片展示，为了更好的阅读体验。其次在界面左侧引用了百度的分享控件，用来分享。<br><img src="https://s1.ax1x.com/2018/08/13/Pg831H.png" alt="Pg831H.png"><br>在底部，我准备自己开发一个简单的评论系统，并不打算采用第三方评论系统。方案在后面写出。</p>
<hr>
<h3 id="后台界面"><a href="#后台界面" class="headerlink" title="后台界面"></a>后台界面</h3><p><img src="https://s1.ax1x.com/2018/08/13/Pg8QhD.png" alt="Pg8QhD.png"></p>
<p>最后的后台用户界面，具体选项目前只准备了写博客与删除博客，以及使用工具的选项。具体美化可以在后期自我发挥~</p>
]]></content>
      <categories>
        <category>博客开发系列</category>
      </categories>
      <tags>
        <tag>博客开发</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JS单线程，异步执行的理解</title>
    <url>/2018/08/22/%E5%85%B3%E4%BA%8EJS%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fuicpsmm4ej30lt09gglg.jpg" alt="JS"><br>在这几天的开发过程中，遇到了不少问题，阻塞最久的应该就是一段JS代码没有按照我以为的执行顺序去执行，想想好像也没有具体的了解JS的执行过程，所以花了一整天的时间来了解了一下JS的执行机制。<br><a id="more"></a></p>
<h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><pre><code>for(var i=0;i&lt;=3;i++){
    $(document).ready(function){
        console.log(i);
    });
</code></pre><p>出现问题的代码简化过后大概是这个样式，我的预期是输出<strong>1，2，3</strong>，但输出的结果却为<strong>3,3,3</strong>，我开始以为是JS单线程执行的缘故，所以Jquery代码被放在了callback queue（任务队列）的最后执行，但我查询资料后发现仅发现浏览器会为定时器，ajax等多开线程，jquery应该不算，正在我疑惑之时，我打开了Jquery的官方文档，看到了<br>    $(document).ready(function(){});<br>的定义：文档准备完成后，内部的匿名函数作为document(ready)的回调函数进行执行，而此时for早已进行玩了。这就解释了为什么都是<strong>3,3,3</strong>。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="从浏览器谈起"><a href="#从浏览器谈起" class="headerlink" title="从浏览器谈起"></a>从浏览器谈起</h2><h3 id="浏览器的进程与线程"><a href="#浏览器的进程与线程" class="headerlink" title="浏览器的进程与线程"></a>浏览器的进程与线程</h3><h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h4><ol>
<li>Browser进程：负责浏览器的主进程（协调，主控）。</li>
<li>第三方插件进程：每一个插件对应一个进程。</li>
<li>GPU进程：用于绘制3D图形等。</li>
<li>浏览器渲染进程 （render进程，浏览器内核）：每一个Tab页面一个进程，这个进程渲染我们所看到的每个页面。</li>
</ol>
<h4 id="浏览器渲染进程是多线程的"><a href="#浏览器渲染进程是多线程的" class="headerlink" title="浏览器渲染进程是多线程的"></a>浏览器渲染进程是多线程的</h4><p>前面我们说到我们所看到的页面都是有渲染进程进行渲染的，而他又是多线程的：</p>
<ol>
<li><p>GUI渲染线程（浏览器内核）</p>
<ul>
<li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li>
<li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>
<li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li>
</ul>
</li>
<li><p>JS引擎线程</p>
<ul>
<li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li>
<li>JS引擎线程负责解析Javascript脚本，运行代码。</li>
<li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li>
<li>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
</li>
<li><p>事件触发进程</p>
<ul>
<li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li>
<li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li>
<li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li>
</ul>
</li>
<li><p>定时触发线程</p>
<ul>
<li>传说中的setInterval与setTimeout所在线程</li>
<li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li>
<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li>
<li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li>
</ul>
</li>
<li><p>异步http请求线程</p>
<ul>
<li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li>
</ul>
</li>
</ol>
<p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fuicngcpr4j307z0g1wet.jpg" alt="线程数"></p>
<h2 id="进入正题，JS的执行过程"><a href="#进入正题，JS的执行过程" class="headerlink" title="进入正题，JS的执行过程"></a>进入正题，JS的执行过程</h2><p><strong>js的同步任务和异步任务</strong><br><a href="https://imgchr.com/i/Pow2cQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/08/22/Pow2cQ.png" alt="Pow2cQ.png"></a></p>
<ol>
<li>所有同步任务（能够立即被执行，不消耗时间的任务，如变量核函数的初始化，时间的绑定等等<strong>不需要回调函数的任务</strong>）都在主线程中执行，形成<strong>执行栈（stack）</strong>，heap（堆）用来存储变量，对象等。</li>
<li>所有异步任务（一半会有操作，如点击事件，定时事件，<strong>具有回调函数</strong>的事件）运行在事件触发线程中，当异步任务有结果是，其<strong>回调函数（Callback Function）</strong>就会被放到任务队列中，等待执行。</li>
<li>当执行栈中同步任务执行完毕后， JS引擎就会从<strong>任务队列中（callback queue）</strong>中查找任务放入执行栈中，这个过程就被称之为<strong>事件循环event loop</strong>。</li>
</ol>
<p>从上面的解释中可以看到JS引擎始终是在执行栈中单线程执行任务，当执行栈空时，接下来的任务才回从任务队列中读取下一任务。</p>
<p><strong>何为异步</strong></p>
<p>所谓的异步，就是在其他线程（事件触发线程，异步http请求线程等）的辅助下，JS线程实现异步处理任务。举个栗子：</p>
<pre><code>consloe.log(&quot;a&quot;)
setTimeout(function() {
console.log(&quot;b&quot;)
}, 0)
console.log(&quot;c&quot;)
</code></pre><p>模拟其运行过程：</p>
<pre><code>1.consloe.log(&quot;a&quot;)// JS引擎发现这是一个同步任务，立即执行打印出a;
2.setTimeout(function() {
console.log(&quot;b&quot;)
}, 0)//JS引擎只想此处时发现这是一个异步任务，所以直接交由定时触发线程。
JS引擎继续向下执行，与此同时，定时触发线程接收到该事件，解析代码过后，
将在0毫秒实际是4毫秒，因为在上面我们讲到，W3C规定定时引擎的最低时间为4毫秒）后向JS引擎发送
回调函数，并将其推到任务队列中等待执行。
3.console.log(&quot;c&quot;)//再向定时引擎发送定时事件后立即执行该代码。打印出c。
4.定时引擎将console.log(&quot;b&quot;)推入任务队
列，在console.log（&quot;c&quot;）运行完成后，执行栈空，再将其推入执行栈，然后执console.log(&quot;c&quot;)，
打印出c,因此这段代码输出的结果为a,c,b,而不是a,b,c.
</code></pre><p><strong>注意，即使setTimeout不是4毫秒后，而是0毫秒后返回回调函数，执行结果任然是a,c,b。因为这是一个排队的过程，console.log(“b”)任是排在console.log(“c”)之后的。</strong></p>
<p>由此，一个异步任务就在JS引擎与其他线程的共同作用下完成了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>
<p><a href="https://www.cnblogs.com/woodyblog/p/6061671.html" target="_blank" rel="noopener">js的单线程和异步</a></p>
<p><a href="https://www.cnblogs.com/sxz2008/p/6513619.html" target="_blank" rel="noopener">JavaScript单线程和异步机制</a></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这只是一个简单的理解，其中还有许多部分可能没有完善，等以后有更深的理解时再来完善吧。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm配置文件随记</title>
    <url>/2021/12/25/ssm%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>这里简单记录一下SSM里的各种配置文件，简单记录一下，作为基础。注意，xml中某些配置是有顺序要求的。</p>
<h1 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h1><ol>
<li><p>引入约束：约束是作为其子标签的编写规范，可以作为提示和规范。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>配置spring配置文件的位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>配置乱码过滤器：此处的配置是为了配置<strong>接受数据</strong>的编码信息。（注意是<strong>接收参数</strong>）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--乱码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>spring监听器：此配置是确保在webapp启动的时候spring容器也被初始化。（所以这里也配置了spring配置文件的位置）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring 监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-mvc前端控制器：此配置即springMVC的servlet，让所有的请求都走springMVC的控制器，即只走springMVC的servlet。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--springmvc的前端控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="applicationContext-xml（spring配置文件）"><a href="#applicationContext-xml（spring配置文件）" class="headerlink" title="applicationContext.xml（spring配置文件）"></a>applicationContext.xml（spring配置文件）</h1><ol>
<li><p>引入约束：注意spring不同的部分有不同的约束，如基本 的beans，aop，contex等（这里也不需要记每个地址，只需要将xmlns:xxx=…xxx…中的xxx改为对应的单词，如aop，tx）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>配置组件扫描（扫描service和mapper）：注意<code>context:component-scan</code>内部可以包含<code>context:exclude-filter</code>或者<code>context:include-filter</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描 扫描service和mapper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除controller的扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:exclude-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加载properties文件：可以引入外部的文件，使用其中的变量</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载propeties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置数据源：这里采用的c3p0连接池。连接池的本质是为我们维护一系列的数据库连接，防止每此都要打开和关闭连接，浪费资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置sessionFactory：配置mybatis的sessionFactory，用来获取mybatis的session</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置sessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载mybatis核心文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:sqlMapConfig-spring.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描mapper包，为mapper接口创建实现类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描mapper所在的包 为mapper创建实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.itheima.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明事务控制</p>
<ol>
<li><p>平台事务管理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置事务增强：注意<code>transaction-manager=&quot;transactionManager&quot;</code>可以省略，因为其默认即为<code>transaction-manager=&quot;transactionManager&quot;</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span>  <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置事务的aop织入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务的aop织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h1><ol>
<li><p>引入约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>组件扫描：只扫描controller</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描  主要扫描controller--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima.controller"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置mvc注解驱动：这个标签注册了一系列的beans和adapts，比如JSON（当我们引入了Jackson，则不需要单独配置，在直接在@ResponseBody的controller中返回以额对象就会直接返回一个json），valid等等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置mvc注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultCharset"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注册文件上传（可选）:注意id必须为<code>multipartResolver</code>，因为spring是按id获取这个bean的。（需要引入<code>commons-fileupload</code>坐标）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"5242800"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSizePerFile"</span> <span class="attr">value</span>=<span class="string">"5242800"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置默认servlet：当spring-mvc无法匹配到请求的请求时，使用默认的servlet来处理，可以用来暴露静态资源。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="sqlMapConfig-xml（不整合spring时的配置）"><a href="#sqlMapConfig-xml（不整合spring时的配置）" class="headerlink" title="sqlMapConfig.xml（不整合spring时的配置）"></a>sqlMapConfig.xml（不整合spring时的配置）</h1><ol>
<li><p>设置打印sql语句和结果</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<pre><code>2. 引入约束

   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>

3. 加载properties文件

   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

4. 定义别名：这里定义实体类的别名，我们在mapper中的可以使用别名来代替很长的全路径名称。注意这里可以单独配置，也可以扫包。

   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;typeAlias type="com.itheima.domain.Account" alias="account"&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.itheima.domain"</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

5. 配置环境：这里配置环境，即可以配置多套设置，比如`development`，`production`。

   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 前面在spring配置文件中配置bean之后就不用在这里配了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"developement"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"developement"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

6. 加载映射文件：加载`XXXmapper.xml`。用在配置文件的情况下。同样可以扫包和单独配置。

   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;mapper resource="com/itheima/mapper/AccountMapper.xml"&gt;&lt;/mapper&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.itheima.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

# sqlMapConfig-spring.xml（整合spring的mybatis）

注意mybatis和spring整合后，大部分的配置都在spring里写好了。所以这里不用配置太多。

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--定义别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type="com.itheima.domain.Account" alias="account"&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.itheima.domain"</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

# xxxmapper.xml（mapper注解方式）

注意：xxxmapper.xml必须与xxxmapper.class位于同一个包下（可以是放在src中，也可以是在resource下新建路劲完全相同的包，否则无法匹配）。

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"priv.mw.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"selectAll"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"selectAll"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        insert user values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;birthday&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        update user set</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span></span><br><span class="line">            username = #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null"</span>&gt;</span></span><br><span class="line">            password = #&#123;password&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null"</span>&gt;</span></span><br><span class="line">            birthday = #&#123;birthday&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        delete user from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre><h1 id="xxx-class-mapper接口方式"><a href="#xxx-class-mapper接口方式" class="headerlink" title="xxx.class(mapper接口方式)"></a>xxx.class(mapper接口方式)</h1>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> priv.mw.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"><span class="keyword">import</span> priv.mw.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;birthday&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update user set username = #&#123;username&#125;, password=#&#123;password&#125;, birthday=#&#123;birthday&#125; where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from user where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">delete</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h1>   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Hibernate, Relational Persistence for Idiomatic Java</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># License: GNU Lesser General Public License (LGPL), version 2.1 or later.</span></span><br><span class="line"><span class="comment"># See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### direct log messages to stdout ###</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.Target</span>=<span class="string">System.err</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### direct messages to file hibernate.log ###</span></span><br><span class="line"><span class="comment">#log4j.appender.file=org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="comment">#log4j.appender.file.File=hibernate.log</span></span><br><span class="line"><span class="comment">#log4j.appender.file.layout=org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment">#log4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### set log levels - for more verbose logging change 'info' to 'debug' ###</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">all, stdout</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>配置文件</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的防抖与节流以及一些重要的函数模式</title>
    <url>/2019/11/17/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h1><p>在学习单片机开发时，<strong>按键防抖</strong>非常重要，我们必须使用一定的方法来进行防抖，否则会造成一次按键按键的多次触发的情况。而在JavaScript中，同样会有这样的问题，即<strong>在用户进行持续性的操作时，在用户大概率完成后，在进行后续操作（请求服务器，浏览器渲染等）</strong>。如果不进行防抖操作，会导致服务器或浏览器的性能浪费。</p>
<p>其具体定义：<strong>在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms</strong>，然后：</p>
<pre><code>- 如果在一段时间内没有再次触发滚动事件，那么就执行函数
- 如果在一段时间内再次触发滚动事件，那么当前的计时取消，重新开始计时
</code></pre><p>下面是一个函数实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fun, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">arguments</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//获取函数的作用域和变量</span></span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer) <span class="comment">// 清除定时器</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fun.apply(that, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数接受一个目标函数与延迟，该函数内部返回了一个函数，并将目标函数的id设为定时器的id。如果第一次调用该函数，会设置一个定时器，设定在delay毫秒后执行目标函数，但是如果在delay毫秒时间内再次调用该函数的防抖函数，那么就会清除掉目标函数的定时器，也就不会执行了。并再次设置一个定时器，循环以上步骤。</p>
<h2 id="节流（Throttle）"><a href="#节流（Throttle）" class="headerlink" title="节流（Throttle）"></a><strong>节流（</strong>Throttle<strong>）</strong></h2><p>节流更是一个重要的概念，<strong>特别是在进行渲染的操作时（比如，mousemove，scoll）</strong>，如果不进行节流，那么浏览器将会消耗很多性能，致使页面卡顿与操作不流畅。</p>
<p>具体定义：<strong>是指在一定的时间内只允许函数执行特定次数。</strong>    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> _self = fn,</span><br><span class="line">       timer,</span><br><span class="line">       firstTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        _this = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">if</span>(firstTime)&#123;</span><br><span class="line">            _self.apply(_this, args)</span><br><span class="line">            <span class="keyword">return</span> firstTime = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">            _self.apply(_this, args)</span><br><span class="line">        &#125;, delay||<span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的核心是在：在外部先判断目标函数fun的timer属性是否为空。如果为空，则代表一次函数还未执行完，则直接返回。否则则设定目标函数的timer属性为一个定时器，在定时器的函数中将timer清空，并执行目标函数。</p>
<h1 id="2021-2-17"><a href="#2021-2-17" class="headerlink" title="2021/2/17"></a>2021/2/17</h1><p>最近在读《JavaScript设计模式与开发实践》，发现除了函数的节流与防抖，还有一些高级函数模式，可以用来解决一些问题。</p>
<h3 id="分时函数"><a href="#分时函数" class="headerlink" title="分时函数"></a>分时函数</h3><p>当一个任务需要进行大量同类操作，此时可能会造成页面的卡顿。此时，为了防止页面卡顿，我们要把单个大型任务分割成为多个小的任务，典型的场景是：大量数据插入表格。</p>
<p>我们把但分时函数代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timeChunk = <span class="function"><span class="keyword">function</span>(<span class="params">ary, fn, count</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj</span><br><span class="line">    <span class="keyword">let</span> t</span><br><span class="line">    <span class="keyword">let</span> len = ary.length</span><br><span class="line">    <span class="keyword">let</span> start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(count || <span class="number">1</span>, ary.length); i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> obj = ary.shift()</span><br><span class="line">            fn(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        t = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ary.length === <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> clearInterval(t)</span><br><span class="line">            &#125;</span><br><span class="line">            start()</span><br><span class="line">        &#125;, <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们需要添加1000调信息到页面中，我们采用每次创建8个节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)&#123;</span><br><span class="line">    ary.push(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> renserList = timeChunk(ary, <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dic.innerHTML = n</span><br><span class="line">    <span class="built_in">document</span>.body.appenChild(div)</span><br><span class="line">&#125;, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">renderList()</span><br></pre></td></tr></table></figure>
<h3 id="惰性加载函数"><a href="#惰性加载函数" class="headerlink" title="惰性加载函数"></a>惰性加载函数</h3><p>当一个任务在执行之前后悔事先执行一些预先性工作，并且这些工作在每次执行时的结果都是一样的，那我们可以在第一次得到结果后就将其凝固，在以后的每一次执行时就可以减少判断次数，提高性能。</p>
<p>一个典型的场景就是浏览器能力检测，常见的写法如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener)&#123;</span><br><span class="line">        <span class="keyword">return</span> elem.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span><br><span class="line">        <span class="keyword">return</span> elem.attachEvent(<span class="string">'on'</span> + type, handler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的缺点是，当它每次被调用的时候都会执行里面的<code>if</code>条件分支，虽然执行这些<code>if</code>分支的开销不算大，但也许有一些方法可以让程序避免这些重复的执行条件。如下面的方案就是在最开始调用一次判断，后续调用该函数时，就不会再进行判断了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>)</span>&#123;</span><br><span class="line">           elem.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> elem.attachEvent(<span class="string">'on'</span> + type, handler)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>第三种方案就是我们的<strong>懒加载函数</strong>，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener)&#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>)</span>&#123;</span><br><span class="line">            elem.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>)</span>&#123;</span><br><span class="line">            elem.attachEvent(<span class="string">'on'</span>+type, handler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent(elem, type, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数在第一次调用时，会根据条件分支，对<code>addEvent</code>事件进行重载，并且对其进行调用一次。这个函数不必判断第一次，而是自动在第一次时重载，很妙。</p>
<p>这里有一个知识点是，在具名函数的执行过程中是可以对具名函数进行重新赋值的。</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>总体来说，在进行某些操作时，比如表单实时验证或者绘图的操作等，函数的防抖与节流会大幅度节省服务器与浏览器的性能！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>反射获取私有数据问题</title>
    <url>/2022/03/30/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这里记录通过反射访问私有变量并赋值的方法。第一种是最普遍的，可以访问没有公开的私有变量。而后两种似乎有点多余，直接调用方法也行，权当记录一下后两种操作方法吧。</p>
<h1 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h1><p>User对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String email)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.email = email;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> email;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.email = email;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", email="</span> + email + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="通过Field赋值"><a href="#通过Field赋值" class="headerlink" title="通过Field赋值"></a>通过Field赋值</h1><p>这种方法是通过获取Field，然后直接赋值。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>, <span class="string">"tom"</span>, <span class="string">"111@11.cc"</span>);</span><br><span class="line">Class clazz = user.getClass();</span><br><span class="line">Field f = clazz.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">f.setInt(user, <span class="number">100</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User [id&#x3D;100, name&#x3D;tom, email&#x3D;111@11.cc]</span><br></pre></td></tr></table></figure>
<h1 id="通过Set方法赋值"><a href="#通过Set方法赋值" class="headerlink" title="通过Set方法赋值"></a>通过Set方法赋值</h1><p>这种方法是通过Class获取对应Field的Set方法（如果有的话），然后直接赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>, <span class="string">"tom"</span>, <span class="string">"111@11.cc"</span>);</span><br><span class="line">Class clazz = user.getClass();</span><br><span class="line">Field f = clazz.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">Method me = clazz.getDeclaredMethod(<span class="string">"setId"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">me.invoke(user, <span class="number">123</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>
<p><strong>这里有一点值得注意的是：查找方法时，如果方法含有参数，则需要传入参数的类型，否则是找不到的。</strong></p>
<h1 id="通过PropertyDescriptor获取其Set方法"><a href="#通过PropertyDescriptor获取其Set方法" class="headerlink" title="通过PropertyDescriptor获取其Set方法"></a>通过PropertyDescriptor获取其Set方法</h1><p>这里的方法可以直接通过方法名还获取该字段的set方法和get方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>, <span class="string">"tom"</span>, <span class="string">"111@11.cc"</span>);</span><br><span class="line">Class clazz = user.getClass();</span><br><span class="line">PropertyDescriptor pro = <span class="keyword">new</span> PropertyDescriptor(<span class="string">"id"</span>, clazz);</span><br><span class="line">Method me = pro.getWriteMethod();</span><br><span class="line">me.invoke(user, <span class="number">999</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射获取私有数据问题</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>利用SS（Shadowsocks）快速搭建一个vpn</title>
    <url>/2018/08/20/%E5%88%A9%E7%94%A8SS%EF%BC%88Shadowsocks%EF%BC%89%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAvpn/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天玩kali时发现需要下一个插件，但是需要科学上网，无奈打开之前的vpn软件，发现几乎都关闭了服务，于是我就诞生了自己搭建一个vpn的想法，于是在参考了网上的教程后，折腾了一上午终于成功了。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一，购买服务器（vps）"><a href="#一，购买服务器（vps）" class="headerlink" title="一，购买服务器（vps）"></a>一，购买服务器（vps）</h2><p>国外的服务器提供商比较多，比如DigtaOcean，Vultr，Amazon等等，我选择了Vultr，因为它提供的vps价格最低的一款仅2.5$/月（后来才发现是个坑，后人谨记），其实DigtaOcean也还不错，绑定信用卡就送10刀，而他价格最低的一款vps价格为5刀，相当于是说送你两个月的体验时间，Amazon好像开可以免费体验一年，所以选择服务器时要多方考虑一下，<br><a id="more"></a><br><img src="https://s1.ax1x.com/2018/08/20/PhoWC9.png" alt="PhoWC9.png"><br>地点我们尽量选在米国，具体速度我没有测试过。<br><img src="https://s1.ax1x.com/2018/08/20/Phohg1.png" alt="Phohg1.png"><br><strong>注意：千万不要选择2.5刀那款服务器，因为它只有一个ipv6的地址，是无法用来搭建的（具体原因我没有深入探索，但估计也是，不是所有的服务都兼容ipv6，购买这款服务器时官方也会有提示）</strong>，所以我们选择5刀的那款，系统选择Ubuntu，当然其他的也是可以的。<br><img src="https://s1.ax1x.com/2018/08/20/Phof3R.png" alt="Phof3R.png"><br>但我们在后面还是把enable ipv6勾上，为我们分配一个ipv6的地址。label和hostname是你自己的信息。<br>至此，服务器的购买就完成了，等待服务器初始化和开机。</p>
<h2 id="二，连接服务器"><a href="#二，连接服务器" class="headerlink" title="二，连接服务器"></a>二，连接服务器</h2><p><img src="https://s1.ax1x.com/2018/08/20/PhTnbT.md.jpg" alt="PhTnbT.md.jpg"><br>此时，我们可以在你的控制面板里看到你服务器端的ip地址以及用户名和密码。<br>然后我们需要远程连接到你的服务器，这里我们选择Xshell这款软件。<br><img src="https://s1.ax1x.com/2018/08/20/PhTbLV.png" alt="PhTbLV.png"><br>点击文件，新建。<br><img src="https://s1.ax1x.com/2018/08/20/PhTLZT.png" alt="PhTLZT.png"><br>在主机输入我们在控制面板中看到的IPV4的地址，<br>之后会提示我们输入用户名及密码，这些信息也都在控制面板中，我就不再截图。</p>
<p>之后我们就会连接上我们的服务器。</p>
<p>然后就输几行代码就ok了。</p>
<pre><code>apt-get install python-pip
pip install shadowsocks
</code></pre><p>两行代码就安装好了ShadowSocks,下面就是配置SS文件</p>
<pre><code>nano /etc/shadowsocks.json
</code></pre><p>nano相比于vim更对Linux新手友好。<br>之后将下面这段代码改为你的账户后粘贴进去。<br>    {<br>    “server”:”0.0.0.0”,<br>    “server_port”:8388,<br>    “local_address”: “127.0.0.1”,<br>    “local_port”:1080,<br>    “password”:”mypassword”,<br>    “timeout”:300,<br>    “method”:”aes-256-cfb”,<br>    “fast_open”: false<br>    }</p>
<p>多账户：<br>    {<br>    “server”:”0.0.0.0”,<br>    “port_password”:{<br>     “8381”:”xxxxxxx”,<br>     “8382”:”xxxxxxx”,<br>     “8383”:”xxxxxxx”,<br>     “8384”:”xxxxxxx”<br>     },<br>    “timeout”:300,<br>    “method”:”aes-256-cfb”,<br>    “fast_open”: false<br>    }</p>
<p>| 字段 | 说明 |<br>| server |    ss服务监听地址，0.0.0.0允许所有人访问，如果只是自己用，可以改成自己使用端的ip |<br>| server_port | ss服务监听端口 |<br>| local_address | 本地的监听地址 |<br>| local_port | 本地的监听端口 |<br>| password | 密码 |<br>| timeout | 超时时间，单位秒 |<br>| method | 加密方法，默认是aes-256-cfb |<br>| fast_open    | 使用TCP_FASTOPEN, true / false |<br>| workers    | workers数，只支持Unix/Linux系统 |</p>
<p>然后启动服务</p>
<pre><code>ssserver -c /etc/shadowsocks.json -d start
</code></pre><p>如果需要关闭服务  </p>
<pre><code>ssserver -c /etc/shadowsocks.json -d stop  
</code></pre><p>至此，我们服务器端就配置好了，现在就是需要下载shadowsocks连接就ok了。</p>
<h2 id="客户端的使用"><a href="#客户端的使用" class="headerlink" title="客户端的使用"></a>客户端的使用</h2><p>由于SS在天朝已经GG了，官网已经打不开了，只在github中更新，所以，在<a href="https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients" target="_blank" rel="noopener">这里</a>下载以及查看官方文档。<br>！<a href="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fugf2ddr9gj30k00fmq3t.jpg" target="_blank" rel="noopener">client</a></p>
<p>下载完客户端后，输入我们的服务器IP，刚刚在SS中设置端口及密码，点击确定就可以连接到我们的vpn了。</p>
<p>然后就查找学习资料吧~</p>
<p><img src="https://img-blog.csdn.net/20180710173951744?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvbHloZWRyb254/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="youtube"></p>
]]></content>
      <categories>
        <category>Shadowsocks</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>千万不要躺太久-三和大神的生活</title>
    <url>/2018/08/30/%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E8%BA%BA%E5%A4%AA%E4%B9%85-%E4%B8%89%E5%92%8C%E5%A4%A7%E7%A5%9E%E7%9A%84%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h1 id="三和大神"><a href="#三和大神" class="headerlink" title="三和大神"></a>三和大神</h1><p>“三和大神”是一群平凡而又特殊的工人，平凡在于他们也是干活领工资，也在人才市场找工作。特殊在于他们的工作信仰与普通的工人不同，他们的理念是“干一天，玩三天”，只要身上有钱，就不去工作，什么时候口袋空了，什么时候就去工作。<br><a id="more"></a></p>
<h1 id="三和大神的贫瘠生活"><a href="#三和大神的贫瘠生活" class="headerlink" title="三和大神的贫瘠生活"></a>三和大神的贫瘠生活</h1><h2 id="经济的贫瘠"><a href="#经济的贫瘠" class="headerlink" title="经济的贫瘠"></a>经济的贫瘠</h2><p>“干一天玩三天”，这就是三和大神所信奉的生活状态，那这一天挣多少呢？</p>
<p>–大约<strong>86元人民币</strong></p>
<p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1furz7apd9pj30jg0elt95.jpg" alt=""></p>
<p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1furz7apfr1j30jg0dfaai.jpg" alt=""></p>
<p>接下来的三天就可以过着<strong>自由</strong>的生活，安逸的躺在十几元的廉价旅馆中，把已经发霉的被子盖在身上，闻着各种习以为常的异味，连着WiFi刷着破损的手机，吃着4元一碗的挂逼面，喝着1元一瓶的挂逼水，或者是在1元一小时的网吧中玩上两天。在身上已经没有钱够吃一碗挂逼面时，又站起来去到“人才市场”干一天。</p>
<h2 id="精神的贫瘠"><a href="#精神的贫瘠" class="headerlink" title="精神的贫瘠"></a>精神的贫瘠</h2><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1furz7bed4yj30jg0ayjsb.jpg" alt=""><br>干完这一天又回到那家小旅馆，躺下……</p>
<p>这样一个又一个的循环，他们生活里毫无波澜，仿佛一滩没有生命的死水，唯一能激起一圈涟漪的应该就是兜里没有钱时，又要去干一天的无奈。他们希望通过网络弥补现实生活的贫瘠，在手机中看着这个明星又出轨了，那个人扶老奶奶又被讹了，他们手指迅速点击着屏幕，批判这个明星的生活作风太差，指责这个社会的黑暗，没有好人了。或者在游戏中虐一下对手，或者嘲讽一下对手，或者夸耀一下自己，将自己想象为游戏角色，以此拾得自己早已丢失在生活中自豪感。</p>
<p>然后又到了工作的那一天，他们将自己的精神冻结起来，以一种自我麻痹的状态完成工作，然后又回到网络上，拾回自己的精神，他们不敢把自己的精神带回到现实生活，因为他们不敢面对那个真实的自己，那个一无所有的自己，那个毫无地位的自己。</p>
<h2 id="感情的贫瘠"><a href="#感情的贫瘠" class="headerlink" title="感情的贫瘠"></a>感情的贫瘠</h2><p>在“三和大神”的行列中，感情似乎是一件不可望更不可及的东西，没有亲人或者亲人根本不联系，更别提爱情，不想要更不需要，一人吃饱全家喝足的状态，这样毫无牵挂，似乎完全没有必要再在社会中跌跟头了，一直躺在地上就挺舒服。</p>
<h1 id="他们为什么到这一步？"><a href="#他们为什么到这一步？" class="headerlink" title="他们为什么到这一步？"></a>他们为什么到这一步？</h1><p>每个人自来到这个世界，都不甘于低于别人，那为什么“三和大神”会甘于这样的生活？</p>
<p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1furz7ben08j30jg0axdgf.jpg" alt=""></p>
<h2 id="对生活失去希望"><a href="#对生活失去希望" class="headerlink" title="对生活失去希望"></a>对生活失去希望</h2><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fus3pz3babj30j80dn0t3.jpg" alt=""><br>宋春江，27岁迈入大神的行列，中专学习的服装和电脑，本以为毕业后可以找个好工作，有个温馨的家庭，平静的生活。可学校分配的工作是做流水线工人，早上7点工作到晚上11点甚至更晚。刚毕业那会还觉得有机会，七八年后，他已不再想过日子，这期间他也从流水线工人变成了标准的“三合大神”。过着“干一天玩三天”的生活。是什么让他成为了“三和大神”？—<strong>失去生活的希望</strong></p>
<p>流水线的工作，无限制的循环一件事情，似乎完全看不见自己的未来，还是带着每日全身的疲倦，与其如此，不如过着“三和大神”的生活来的实在，累一天“舒服”三天。</p>
<h2 id="误入歧途"><a href="#误入歧途" class="headerlink" title="误入歧途"></a>误入歧途</h2><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fus4l9c6isj30jg0acaak.jpg" alt=""></p>
<p>东东，22岁，来自农村，因为上班时打瞌睡被老板娘说了几句就辞职来到三和，住进了15元一晚的宾馆。开始“三和大神”的生活。</p>
<h2 id="躺下太久就站不起来了！"><a href="#躺下太久就站不起来了！" class="headerlink" title="躺下太久就站不起来了！"></a>躺下太久就站不起来了！</h2><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1furz7apofbj30gy09j3yk.jpg" alt=""></p>
<p>对于“三和大神”，我感到的不是同情，而是可怜，甚至是可笑，所有的一切不过都是自己不想站起来的原因罢了！不过是自己懒惰的借口！我们不得不承认社会的不公，你也许永远无法成为王健林，马云，但你是可以靠自己的努力让你过上普通人的生活。觉得自己的工作没希望就换个有希望的工作，找不到就去学习。这中国这片土地上永远不缺可供学习的地方。唯一缺的是愿意一心一意去学习的人。所谓的“三和大神”不过是那些受不了现实的打击或承受不了现实的打磨，倒在路上的一群人！他们甘愿倒在半路！他们甘愿走在社会的最低层！那么这就是不会被同情的，因为是他们自己选择了自己的道路，不是别人，更不是这个社会！<br><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1furz7app6ej30jg0aymy0.jpg" alt=""><br>“讨厌长期劳动，喜欢日结”不过是自己不愿努力的掩饰罢了，就如同“讨厌站起来，喜欢躺在在床上”一样可笑。<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1furz7apbasj30hs0a0t97.jpg" alt=""></p>
<h1 id="我们都一样"><a href="#我们都一样" class="headerlink" title="我们都一样"></a>我们都一样</h1><h2 id="人性相同"><a href="#人性相同" class="headerlink" title="人性相同"></a>人性相同</h2><p>其实他们与我们有什么不同？哪一个人不希望每天轻轻松松，什么都不干，不去承受，不去负担。这种人性的弱点是始终存在的。即使是再伟大的人，也会有偷懒的想法。古代的皇帝，每天翻阅奏章，管理国家大事，几乎所有的大事都会通过皇帝的脑袋，难道他不想随便完成然后去后宫吃喝玩乐？如今的富商哪一个不是每天满满的日程，用尽心思的去经营自己的生意，难道他们不想停下来休息一下？芸芸众生谁不辛苦？谁生活在温室中？谁不想停下来“躺在地上”？但我们没有那么做，因为“躺下太久，就站不起来了”！</p>
<h2 id="选择不同"><a href="#选择不同" class="headerlink" title="选择不同"></a>选择不同</h2><p>但我们的选择不同，我们选择了站起来，继续前进。现实一次又一次的将我们击倒，但仍然有人站起来，继续前进！“三和大神”就是被击倒后站不起来的那一群人。他们倒下后发现原来躺着是这么舒服啊，那就别站起来了，干脆做他一场黄粱大梦，或在梦中，或在网络中。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1furz7bfymyj30to21cwkq.jpg" alt=""></p>
<h2 id="请不要躺太久！"><a href="#请不要躺太久！" class="headerlink" title="请不要躺太久！"></a>请不要躺太久！</h2><p>请不要躺太久，以至于忘记如何站立！不管自己的梦想是否遥远，都请一直走下去，因为至少你可以更清晰的看见自己的梦想啊。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>社会</tag>
        <tag>见解</tag>
      </tags>
  </entry>
  <entry>
    <title>周报(0)</title>
    <url>/2018/12/01/%E5%91%A8%E6%8A%A5(0)/</url>
    <content><![CDATA[<p>LeetCode：<br><img src="https://img-blog.csdn.net/20180909171005249?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjQxMjM5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="题目"></p>
<p>简单思路：令i从0开始向后跑寻找与下标为length-1不相等的数，找到之后将那个数放到length的位置上，并且令length长度加1，最后返回length就行了。<br><a id="more"></a><br>代码部分：</p>
<pre><code>int removeDuplicates(int* nums, int numsSize) {
if(numsSize==0){
    return 0;
}
int length = 1;
for(int i=0;i&lt;numsSize;i++){
    if(nums[i]!=nums[length-1]){
        nums[length++]=nums[i];
    }
}
return length;
}
</code></pre><h1 id="Java学习部分内容"><a href="#Java学习部分内容" class="headerlink" title="Java学习部分内容"></a>Java学习部分内容</h1><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><h2 id="重写：在子类中"><a href="#重写：在子类中" class="headerlink" title="重写：在子类中"></a>重写：在子类中</h2><pre><code>1. 参数列表必须完全与被重写方法的相同
2. 返回类型必须与被重写方法的返回类型相同
3. 访问权限不能比父类中被重写的方法的访问权限更低。例如，父类的一个方法被申明为public，那么该子类中重写该方法就不能申明为protected。
4. 父类的成员方法只能被它的子类重写
5. 申明为final的方法不能被重写
6. 申明为static的方法不能被重写，但是能够被再次申明
7. 子类与父类在同一个包中，那么子类可以重写父类的所有方法，除了声明为private与final的方法
8. 子类与父类不在一个包中，那么子类只能够重写父类的声明为public和protected的非final方法
9. 构造方法不能被重写
10. 如果不能继承一个方法，则不能重写这个方法
</code></pre><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><pre><code>1. 在父类的某一方法被重写后，如果需要调用原父类的方法，需在该方法前加super关键字
</code></pre><h2 id="重载-：在同一个类中"><a href="#重载-：在同一个类中" class="headerlink" title="重载 ：在同一个类中"></a>重载 ：在同一个类中</h2><pre><code>1. 被重载的方法必须改变参数列表（参数个数或类型不一样）
2. 被重载的方法可以改变返回类型
3. 被重载的方法可以改变访问修饰符
4. 被重载的方法可以声明新的或更广的检查异常
5. 方法能够在同一个类中或者一个子类中被重载
6. 无法以返回值类型作为重载函数的区分标准
</code></pre><p>区别点    重载方法    重写方法</p>
<p>参数列表    必须修改    一定不能修改</p>
<p>返回类型    可以修改    一定不能修改</p>
<p>异常    可以修改    可以减少或删除，一定不能抛出新的或者更广的异常</p>
<p>访问    可以修改    一定不能做更严格的限制（可以降低限制）</p>
<p>来自 <a href="http://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-override-overload.html</a> </p>
<p>2.多态：同一个行为具有多个不同表现形式或形态的能力。</p>
<p>向上转型：子类引用的对象转换为父类类型称为向上转型。</p>
<p>重写式多态：也叫运行时多态，这种多态通过动态绑定技术来实现，是指在执行期间判断所引用的对象的实际类型调用起相应的方法。</p>
<p>Animal animal = new Cat(); //向上转型</p>
<pre><code>1. 向上转型时，子类单独定义的方法会丢失。比如上面Dog类中定义的run方法，当animal引用指向Dog类实例时是访问不到run方法的，animal.run()会报错。
2. 子类引用不能指向父类对象。Cat c = (Cat)new Animal()这样是不行的。
</code></pre><p>向上转型后方法引用的优先级问题：</p>
<p>继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</p>
<p>注意：此时的（super）O 指的是O的父类。以下面的8为例：</p>
<p>b.show(C)</p>
<ol>
<li>由于b的引用对象为B，所以可以调用的方法有：show(B)，show(A)</li>
<li>（this.show(O)） 又b的类型也为B，所以方法也先在B中选择，发现没有show(C)方法</li>
<li>（super.show(O)） 在B的父类，即A中查找show(C)方法，任然没有查找到</li>
<li>（this.show(super)O） 原式为：b.show（C），又C的父类为B，所以该式变为：b.show(b)，并且在B中查找，找到了该方法，于是执行该方法，得到结果：B and B   </li>
</ol>
<p>实例<br>class A {<br>    public String show(D obj) {<br>        return (“A and D”);<br>    }</p>
<pre><code>public String show(A obj) {
    return (&quot;A and A&quot;);
}
</code></pre><p>}</p>
<p>class B extends A{<br>    public String show(B obj){<br>        return (“B and B”);<br>    }</p>
<pre><code>public String show(A obj){
    return (&quot;B and A&quot;);
}
</code></pre><p>}</p>
<p>class C extends B{</p>
<p>}</p>
<p>class D extends B{</p>
<p>}</p>
<p>public class Demo {<br>    public static void main(String[] args) {<br>        A a1 = new A();<br>        A a2 = new B();<br>        B b = new B();<br>        C c = new C();<br>        D d = new D();</p>
<pre><code>    System.out.println(&quot;1--&quot; + a1.show(b));
    System.out.println(&quot;2--&quot; + a1.show(c));
    System.out.println(&quot;3--&quot; + a1.show(d));
    System.out.println(&quot;4--&quot; + a2.show(b));
    System.out.println(&quot;5--&quot; + a2.show(c));
    System.out.println(&quot;6--&quot; + a2.show(d));
    System.out.println(&quot;7--&quot; + b.show(b));
    System.out.println(&quot;8--&quot; + b.show(c));
    System.out.println(&quot;9--&quot; + b.show(d));
}
</code></pre><p>}<br>//结果：<br>//1–A and A<br>//2–A and A<br>//3–A and D<br>//4–B and A<br>//5–B and A<br>//6–A and D<br>//7–B and B<br>//8–B and B<br>//9–A and D</p>
<p>从4向后的解析原理：<br>当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。<br>Animal animal = new Cat(); //向上转型<br> Animal为引用对象<br>Cat为引用变量</p>
<p>首先，a2是类型为A的引用类型，它指向类型为B的对象。A确定可调用的方法：show(D obj)和show(A obj)。<br>a2.show(b) ==&gt; this.show(b)，这里this指的是B。</p>
<p>然后.在B类中找show（B obj），找到了，可惜没用，因为show（B obj）方法不在可调用范围内，this.show(O)失败，进入下一级别：super.show(O)，super指的是A。</p>
<p>在A 中寻找show（B obj)，失败，因为没用定义这个方法。进入第三级别：this.show((super)O)，this指的是B。<br>在B中找show（（A）O）,找到了：show(A obj)，选择调用该方法。</p>
<p>输出：B and A</p>
<p>上面的例子简单的介绍了多态的意义，同一个行为具有不同的表现形式或形态的能力。</p>
<p>多态（重写式）实现的条件：</p>
<pre><code>1. 继承（实现）
2. 重写
3. 向上转型
</code></pre><p>重载式多态：也叫编译时多态，也就是说这种多态在编译时已经确定好了。在调用这种方法时，通过传入不同的参数得到不同的结果。</p>
<p>此处重载式多态有不同的说法，部分观点认为：重载不属于多态，认为多态仅仅指的是在程序运行时根据不同的输入，而方法有不同的响应称之为多态；但重载指的是：在一个类里，方法名字相同，而参数不同。也就是说在程序编译时就确定了该方法的响应。所以不能称之为多态。关于这个部分，我还没有更深的理解，所以暂时保留意见。</p>
]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>周报</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>基于java的脚本语言hair的开发思路2-语法分析</title>
    <url>/2021/09/26/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80hair%E7%9A%84%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>在经过上一步的词法分析之后，我们已经将程序字符串分以上三种token。要想让程序运行起来，我们还必须将其构造为抽象语法树(Abstract Syntax Tree)。</p>
<p>它是用来表示程序结构的树形结构。其中树的节点也分为不同的类型。</p>
<p>具体的树节点类型后面介绍。</p>
<p>在我们得到AST之后，想要得到结果，就很简单了：我们只需要自底而上活得每个树节点的对应的值。其根节点的值就是最终的程序结果。</p>
<p>所以问题的关键是如何通过token队列来获得AST。这里我们首先引入BNF的概念。</p>
<h2 id="BNF"><a href="#BNF" class="headerlink" title="BNF"></a>BNF</h2><p>BNF即<strong>巴科斯范式</strong>，其是一种描述语法的一种形式体系，是一种典型的元语言（相当于一种伪代码来描述语法规则）。其规则如下：</p>
<ol>
<li>字符本身： “xxx” - 表示xxx字符本身。如：”function”表示匹配function字符。</li>
<li>[xxx]表示xxx模式出现0次或1次。</li>
<li>{xxx}表示xxx模式至少出现0次。</li>
<li>(xxx)表示括号内的模式为一个整体。</li>
<li>xxx|yyy表示匹配xxx或yyy模式。</li>
</ol>
<p>后来BNF也做了很多扩展，我们这里仅使用以上5种模式。</p>
<p>整个匹配过程中包含两个过程，即：</p>
<ol>
<li>创建匹配模式实例。</li>
<li>使用该模式匹配token串。</li>
</ol>
<p>下面分别介绍：</p>
<h2 id="创建匹配模式"><a href="#创建匹配模式" class="headerlink" title="创建匹配模式"></a>创建匹配模式</h2><p>对于一个匹配模式，就是一个Parser对象。其有两个成员变量：</p>
<ol>
<li>elements：用于存放模式匹配的子模式，即子树模式结构。</li>
<li>factory：用于创建该模式对应的树节点。</li>
</ol>
<p>接下来我们看看具体的创建代码：</p>
<p>其调用栈如下顺序：</p>
<ol>
<li>第一步：通过rule()最外层API创建模式，其有两个重载，分别对应是否传入匹配到的树节点类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create an empty Parser without a parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Parser <span class="title">rule</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rule(<span class="keyword">null</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a Parser with a ASTree parameter, caution that this Parser is a single node with the parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Parser <span class="title">rule</span><span class="params">(Class&lt;? extends ASTree&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Parser(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Parser的构造方法，也有两个重载，其中第一个是用于构建模式树的根节点；而第二个适用于直接接受一个Parser并将其成员变量复制过来，其主要是用在<code>maybe</code>方法的实现中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Element&gt; elements;</span><br><span class="line"><span class="keyword">protected</span> Factory factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This constructor is used for first create Parser.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Parser</span><span class="params">(Class&lt;? extends ASTree&gt; clazz)</span> </span>&#123;</span><br><span class="line">    reset(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This constructor is used for chain call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Parser</span><span class="params">(Parser p)</span> </span>&#123;</span><br><span class="line">    elements = p.elements;</span><br><span class="line">    factory = p.factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>接下来的reset方法其实就是初始化（或者重置）Parser的成员：elements和factory</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the parser, elements and factory are all need to be reset. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Parser <span class="title">reset</span><span class="params">(Class&lt;? extends ASTree&gt; clazz)</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">    factory = Factory.getForASTList(clazz);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>然后就是Factory对象的<code>getForASTList</code>静态方法，这里的两个方法比较重要，主要是如何来构建一个factory。首先会从外部传来的<code>class</code>来构建一个<code>Factory</code>。我们后面再看<code>get</code>方法，首先来分析<code>f == null</code>时的情况。</p>
<p>这里就直接通过new方法来构建一个新的factory，值得注意的是这里实现了本来是<code>make0</code>方法。</p>
<p><strong>注意：</strong>这个方法是用在匹配token串，使用该方法创建对应的AST节点。</p>
<p>这里的逻辑是：判断传入的<code>arg</code>的长度是等于1。如果等于1则返回其第一个元素。否则的话就利用<code>org</code>返回一个新的<code>ASTList</code>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Factory <span class="title">getForASTList</span><span class="params">(Class&lt;? extends ASTree&gt; clazz)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Get the class with the ASTree class transferred by user.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    Factory f = get(clazz, List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If user did not transferred the class,</span></span><br><span class="line"><span class="comment">     * we implement the make0 method and new a factory which make a normal ASTree object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        f = <span class="keyword">new</span> Factory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> ASTree <span class="title">make0</span><span class="params">(Object arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                List&lt;ASTree&gt; results = (List&lt;ASTree&gt;)arg;</span><br><span class="line">                <span class="keyword">if</span> (results.size() == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> results.get(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ASTList(results);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>接下来我们来看<code>get</code>方法。这里主要是如何利用传入的<code>class</code>来构建这个<code>factory</code>。首先如果是没有传入class，则直接返回class。</p>
<p>如果<code>class != null</code>时，则会有两种情况：</p>
<ol>
<li>首先判断这个class有没有<code>create</code>方法（<code>factoryName</code>为字符串<code>creatr</code>），如果有的话就获取这个方法，然后实现了<code>make0</code>方法。</li>
<li>其次判断是否有构造器，如果有的话，<code>make0</code>方法就会直接利用该构造函数来新建一个该对象。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Factory <span class="title">get</span><span class="params">(Class&lt;? extends ASTree&gt; clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Class&lt;?&gt; argType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * If user transferred no class, get method return null.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * Judge whether the class transferred by user has a "create" function.</span></span><br><span class="line"><span class="comment">    	 * If true, we just use the function to create the ASTree.</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">        <span class="keyword">final</span> Method m = clazz.getMethod(factoryName,</span><br><span class="line">                                         <span class="keyword">new</span> Class&lt;?&gt;[] &#123; argType &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Factory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> ASTree <span class="title">make0</span><span class="params">(Object arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (ASTree)m.invoke(<span class="keyword">null</span>, arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If the class has not a "create" function.</span></span><br><span class="line"><span class="comment">     * We judge whether the class has a constructor.</span></span><br><span class="line"><span class="comment">     * If true, we use the constructor to create the ASTree. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;? extends ASTree&gt; c</span><br><span class="line">            = clazz.getConstructor(argType);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Factory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> ASTree <span class="title">make0</span><span class="params">(Object arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> c.newInstance(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是<code>Parser</code>对象还有很对方法用来对应BNF的规则：</p>
<ol>
<li>number：用于向<code>Parser</code>的elements添加number型AToken（这里的AToken是在Parser中的内部类，属于模式AST类）。</li>
<li>identifier：用于向<code>Parser</code>的elements添加identifier型AToken。</li>
<li>string：用于向<code>Parser</code>的elements添加srting型AToken。</li>
<li>sep：用于向<code>Parser</code>的elements添加用于间隔型AToken，在BNF中对应字符串本身。</li>
<li>ast：用于向<code>Parser</code>的elements添加基本的树结构，常用于直接传递其他模式串作为子串。</li>
<li>or：用于向<code>Parser</code>的elements添加分支结构的树结构，对应BNF的|。</li>
<li>maybe：用于向<code>Parser</code>的elements添加可省略的模式。</li>
<li>option：用于向<code>Parser</code>的elements添加可省略的模式，对应BNF的[]。</li>
<li>repeat： 用于向<code>Parser</code>的elements添加可重复的模式，对应BNF的{}。</li>
<li>expression：用于向<code>Parser</code>的elements添加以Express为树节点的模式。</li>
</ol>
<p>下面是一个简单的模式的创建：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Parser classNew = rule(NewStmnt.class).sep("new").identifier(reserved).sep("(").option(args).sep(")");</span><br></pre></td></tr></table></figure>
<p>其主要是匹配新建对象时的语法，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Obj(<span class="number">111</span>, <span class="number">222</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到rule首先接受了一个<code>NewStmnt.class</code>参数，这就意味着，当这个模式匹配成功时，其创建的节点是<code>NewStmnt</code>类型的。</p>
<p>然后<code>sep(&quot;new&quot;)</code>即匹配new这个字符。</p>
<p><code>identifier(reserved)</code>即匹配保留字，即变量名等。</p>
<p><code>option(args)</code>即表示匹配可以省略的arguments，这里的<code>args</code>也是在前面定义的一个模式，匹配诸如：<code>222,&quot;uuu&quot;</code>之类的参数模式。</p>
<h2 id="匹配token串"><a href="#匹配token串" class="headerlink" title="匹配token串"></a>匹配token串</h2><p>在<code>Parser</code>中定义了诸多子类即模式节点，这些节点自己定义了<code>parser</code>方法用于解析对应的<code>token</code>是否匹配。</p>
<p>我们上面构建语法规则实际上形成了一个树，其节点就是之前定义在<code>Parser</code>内部的各种子类。</p>
<p>但其主要依然是一个递归的过程，首先会从队列中<code>peek</code>一个token（<code>peek</code>是不会让该token出队的），然后从匹配树的根部开始向下遍历，查找到其叶节点，然后匹配，如果通过则将调用其<code>factory</code>的<code>make</code>方法，来构建一个对应class的叶节点并且将其推入其<code>elements</code>中。</p>
<p><img src="D:\myblog\myblog\source\images\hair\Parser结构.png" alt="Parser结构"></p>
<p>这里给出了一部分的结构（定义类的结构），我们模拟一下其解析过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span>&#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    constructor(param1)&#123;</span><br><span class="line">        a = param1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们会通过Lexer会生成一个queue：</p>
<p>StrToken:”class”-&gt;IdToken:Myclass-&gt;StrToken:”a”-&gt;…</p>
<ol>
<li><p><code>peek</code>一个<code>token</code>，即第一个StrToken。</p>
</li>
<li><p>遍历树：从program-&gt;classDef-&gt;”class”，匹配成功。（若第一次没有匹配成功，将会在树上进行回溯）。</p>
</li>
<li>新建一个<code>ClassDef</code>对象的树节点。</li>
<li>接下来再<code>peek</code>一个token，即IdToken:Myclass</li>
<li>再从<code>classDef</code>的第二个节点开始匹配，发现也匹配成功。</li>
<li>创建一个<code>Name</code>树节点并将其加入刚才<code>ClassDef</code>的<code>elements</code>中。</li>
<li>后面也是如此，一次递归，失败就回溯；成功就继续匹配。</li>
</ol>
<p>下面附上目前版本定义的规则（包括类，数组）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> parser;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> parser.Parser.rule;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> parser.Parser.*;</span><br><span class="line"><span class="keyword">import</span> scanner.Lexer;</span><br><span class="line"><span class="keyword">import</span> token.Token;</span><br><span class="line"><span class="keyword">import</span> ast.*;</span><br><span class="line"><span class="keyword">import</span> entity.Function;</span><br><span class="line"><span class="keyword">import</span> exception.ParseException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicParser</span> </span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; reserved = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    Operators operators = <span class="keyword">new</span> Operators();</span><br><span class="line">    Parser expr0 = rule();</span><br><span class="line">    Parser primary = rule(PrimaryExpr<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        .or(rule().sep("(").ast(expr0).sep(")"),</span><br><span class="line">            rule().number(NumberLiteral<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            <span class="title">rule</span>().<span class="title">identifier</span>(<span class="title">Name</span>.<span class="title">class</span>, <span class="title">reserved</span>),</span></span><br><span class="line"><span class="class">            <span class="title">rule</span>().<span class="title">string</span>(<span class="title">StringLiteral</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">        	)</span>;</span><br><span class="line">    Parser factor = rule().or(rule(NegativeExpr.class).sep("-").ast(primary),</span><br><span class="line">                              primary);                               </span><br><span class="line">    Parser expr = expr0.expression(BinaryExpr<span class="class">.<span class="keyword">class</span>, <span class="title">factor</span>, <span class="title">operators</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Parser statement0 = rule();</span><br><span class="line">    Parser block = rule(BlockStmnt<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        .sep("&#123;").option(statement0)</span><br><span class="line">        .repeat(rule().sep(<span class="string">";"</span>, Token.EOL).option(statement0))</span><br><span class="line">        .sep(<span class="string">"&#125;"</span>);</span><br><span class="line">    Parser simple = rule(PrimaryExpr<span class="class">.<span class="keyword">class</span>).<span class="title">ast</span>(<span class="title">expr</span>)</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Function Parser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Parser param = rule().identifier(reserved);</span><br><span class="line">    Parser params = rule(ParameterList.class).ast(param).repeat(rule().sep(",").ast(param));</span><br><span class="line">    Parser paramList = rule().sep(<span class="string">"("</span>).maybe(params).sep(<span class="string">")"</span>);</span><br><span class="line">    Parser function = rule(FunctionStmnt.class).sep("function").identifier(reserved).ast(paramList).ast(block);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * InnerFunction Parser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Parser innerFunction = rule(InnerFunc.class).sep("func").ast(paramList).ast(block);</span><br><span class="line">    Parser args = rule(Arguments.class).ast(expr).repeat(rule().sep(",").ast(expr));</span><br><span class="line"><span class="comment">//    Parser postfix = rule().sep("(").maybe(args).sep(")");</span></span><br><span class="line">    Parser postfix = rule().or(rule(Dot.class).sep(".").identifier(reserved), </span><br><span class="line">    		rule().sep(<span class="string">"("</span>).ast(args).sep(<span class="string">")"</span>),</span><br><span class="line">    		rule(Squarebracket.class).sep("[").ast(expr).sep("]")</span><br><span class="line">    		);</span><br><span class="line">    Parser statement = statement0.or(</span><br><span class="line">            rule(IfStmnt.class).sep("if").sep("(").ast(expr).sep(")").ast(block).option(rule().sep("else").ast(block)),</span><br><span class="line">            rule(WhileStmnt.class).sep("while").sep("(").ast(expr).sep(")").ast(block),</span><br><span class="line">            simple);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * class Parser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Parser constructor = rule(Construtor.class).sep("constructor").ast(paramList).ast(block);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The order can not be changed. Or constructor maybe regard as simple parser.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Parser classEle = rule().or(constructor, function, simple);</span><br><span class="line">    Parser classBody = rule(ClassBody.class).sep("&#123;").option(classEle).</span><br><span class="line">    		repeat(rule().sep(<span class="string">";"</span>, Token.EOL).option(classEle)).sep(<span class="string">"&#125;"</span>);</span><br><span class="line">    Parser classDef = rule(ClassStmnt.class).sep("class").identifier(reserved).option(rule().sep("extends").identifier(reserved)).ast(classBody);</span><br><span class="line">    Parser classNew = rule(NewStmnt.class).sep("new").identifier(reserved).sep("(").option(args).sep(")");</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Array Parsers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Parser arrayDef = rule(ArrayStmnt.class).sep("[").ast(expr).repeat(rule().sep(",").ast(expr)).sep("]");</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * final program Parser.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Parser program = rule().or(classDef, statement, rule(NullStmnt<span class="class">.<span class="keyword">class</span>))</span></span><br><span class="line">            .sep(";", Token.EOL);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	reserved.add(<span class="string">")"</span>);</span><br><span class="line">        reserved.add(<span class="string">";"</span>);</span><br><span class="line">        reserved.add(<span class="string">"&#125;"</span>);</span><br><span class="line">        reserved.add(<span class="string">"]"</span>);</span><br><span class="line">        reserved.add(Token.EOL);</span><br><span class="line"></span><br><span class="line">        operators.add(<span class="string">"="</span>, <span class="number">1</span>, Operators.RIGHT);</span><br><span class="line">        operators.add(<span class="string">"=="</span>, <span class="number">2</span>, Operators.LEFT);</span><br><span class="line">        operators.add(<span class="string">"&gt;"</span>, <span class="number">2</span>, Operators.LEFT);</span><br><span class="line">        operators.add(<span class="string">"&lt;"</span>, <span class="number">2</span>, Operators.LEFT);</span><br><span class="line">        operators.add(<span class="string">"+"</span>, <span class="number">3</span>, Operators.LEFT);</span><br><span class="line">        operators.add(<span class="string">"-"</span>, <span class="number">3</span>, Operators.LEFT);</span><br><span class="line">        operators.add(<span class="string">"*"</span>, <span class="number">4</span>, Operators.LEFT);</span><br><span class="line">        operators.add(<span class="string">"/"</span>, <span class="number">4</span>, Operators.LEFT);</span><br><span class="line">        operators.add(<span class="string">"%"</span>, <span class="number">4</span>, Operators.LEFT);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * avoid cycle reference, so we repair some Parser here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        primary.repeat(postfix);</span><br><span class="line">        primary.insertChoice(innerFunction);</span><br><span class="line">        primary.insertChoice(classNew);</span><br><span class="line">        primary.insertChoice(arrayDef);</span><br><span class="line">        simple.option(rule().sep(<span class="string">")"</span>).option(args).sep(<span class="string">")"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ASTree <span class="title">parse</span><span class="params">(Lexer lexer)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> program.parse(lexer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>reserved</code>即为保留字符，不会被识别为标识符等。</p>
<p><code>operators</code>即为操作符，主要用在<code>BinaryExpress</code>即二元表达式中。</p>
<p><code>add</code>函数的参数第一个是操作符，第二个是优先级，第三个是左先计算还是右先计算。</p>
]]></content>
      <categories>
        <category>hair</category>
      </categories>
      <tags>
        <tag>hair</tag>
        <tag>脚本语言</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>基于java的脚本语言hair的开发思路3-执行</title>
    <url>/2021/09/30/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80hair%E7%9A%84%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF3-%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>经过上面的操作，我们已经根据程序生成了一个抽象语法树。此时我们需要让程序达到其预期的结果。即需要我们翻译为Java可执行的代码。实际上执行的过程很简单，既然我们已经生成了抽象语法树。我们只需要将每个节点的结果得到，最后得到根节点的结果，即为该程序的结果。所以这实际上也是一个树的遍历工作，从左边的叶节点开始遍历。依次得到上层的非叶节点的值。</p>
<p>针对不同的节点，我们的实现方法不同，但是我们都将其定义为<code>eval</code>方法，意为evaluate，即得到结果。</p>
<p>下面简单介绍几种类型的节点的实现：</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基本节点"><a href="#基本节点" class="headerlink" title="基本节点"></a>基本节点</h3><p>针对一些基本节点，比如</p>
<p>二元运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For a binary operation, the operation symbol will be considered to process different operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">eval</span><span class="params">(Environment env)</span> </span>&#123;</span><br><span class="line">    String op = operator();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"="</span>.equals(op)) &#123;</span><br><span class="line">    	ASTree rightTree = right();</span><br><span class="line">    	Object rightVal = rightTree.eval(env);</span><br><span class="line">        <span class="keyword">return</span> computeAssign(env, rightVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object left = left().eval(env);</span><br><span class="line">        Object right = right().eval(env);</span><br><span class="line">        <span class="keyword">return</span> computeOp(left, op, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For a if statement, condition will eval first to decide whether the if block be executed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">eval</span><span class="params">(Environment env)</span> </span>&#123;</span><br><span class="line">    Object c = condition().eval(env);</span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> Integer &amp;&amp; ((Integer)c).intValue() != FALSE)</span><br><span class="line">        <span class="keyword">return</span> thenBlock().eval(env);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ASTree b = elseBlock();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> b.eval(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上这里就是递归的执行元素的<code>eavl</code>方法，实际上就是遍历ast的过程。</p>
<p>注意这里就是脚本语言与编译语言的区别，脚本语言会直接遍历ast执行。而预编译语言会先对源码进行编译，生成可执行程序或中间二进制代码，比如C语言编译会生成对应平台的可执行程序。java会通过Java虚拟机产生javac二进制文件，以此来解决跨平台的问题。</p>
<p>正是因为这个预编译的过程中，会对源码进行一定的分析和运算，将可运算先运算出来，使得预编译程序的效率会远高于脚本语言。</p>
]]></content>
      <categories>
        <category>hair</category>
      </categories>
      <tags>
        <tag>hair</tag>
        <tag>脚本语言</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>基于java的脚本语言hair的开发思路1-词法分析</title>
    <url>/2021/09/21/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80hair%E7%9A%84%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>申明：本脚本语言前面的开发思路基本是《两周自制脚本语言》中Stone语言的模型，后期将逐渐分离，添加更多特征。</strong>这本书作为入门读物确实不错，但是其设计规范还是有待商榷，一是没有给出一个确定的项目架构、二是部分的结构的成分不够规范（比如token的定义，运算优先级的处理等）。</p>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>一个程序片段被编译器解析的时候是一个很长的字符串。我们的目标是通过一定的手段分析将这个字符串分开来。</p>
<p>而这个被分割后的子字符串我们一般称为Token，Token有很多类型。在V8中定义的部分代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_OP_TOKEN_LIST(T, E) \</span></span><br><span class="line">  E(T, NULLISH, <span class="string">"??"</span>, <span class="number">3</span>)           \</span><br><span class="line">  E(T, OR, <span class="string">"||"</span>, <span class="number">4</span>)                \</span><br><span class="line">  E(T, AND, <span class="string">"&amp;&amp;"</span>, <span class="number">5</span>)               \</span><br><span class="line">  E(T, BIT_OR, <span class="string">"|"</span>, <span class="number">6</span>)             \</span><br><span class="line">  E(T, BIT_XOR, <span class="string">"^"</span>, <span class="number">7</span>)            \</span><br><span class="line">  E(T, BIT_AND, <span class="string">"&amp;"</span>, <span class="number">8</span>)            \</span><br><span class="line">  E(T, SHL, <span class="string">"&lt;&lt;"</span>, <span class="number">11</span>)              \</span><br><span class="line">  E(T, SAR, <span class="string">"&gt;&gt;"</span>, <span class="number">11</span>)              \</span><br><span class="line">  E(T, SHR, <span class="string">"&gt;&gt;&gt;"</span>, <span class="number">11</span>)             \</span><br><span class="line">  E(T, MUL, <span class="string">"*"</span>, <span class="number">13</span>)               \</span><br><span class="line">  E(T, DIV, <span class="string">"/"</span>, <span class="number">13</span>)               \</span><br><span class="line">  E(T, MOD, <span class="string">"%"</span>, <span class="number">13</span>)               \</span><br><span class="line">  E(T, EXP, <span class="string">"**"</span>, <span class="number">14</span>)              \</span><br><span class="line">  E(T, ADD, <span class="string">"+"</span>, <span class="number">12</span>)               \</span><br><span class="line">  E(T, SUB, <span class="string">"-"</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPAND_BINOP_ASSIGN_TOKEN(T, name, string, precedence) \</span></span><br><span class="line">  T(ASSIGN_##name, <span class="built_in">string</span> <span class="string">"="</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPAND_BINOP_TOKEN(T, name, string, precedence) \</span></span><br><span class="line">  T(name, <span class="built_in">string</span>, precedence)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOKEN_LIST(T, K)                                           \</span></span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* BEGIN PropertyOrCall */</span>                                       \</span><br><span class="line">  <span class="comment">/* BEGIN Member */</span>                                               \</span><br><span class="line">  <span class="comment">/* BEGIN Template */</span>                                             \</span><br><span class="line">  <span class="comment">/* ES6 Template Literals */</span>                                      \</span><br><span class="line">  T(TEMPLATE_SPAN, <span class="literal">nullptr</span>, <span class="number">0</span>)                                     \</span><br><span class="line">  T(TEMPLATE_TAIL, <span class="literal">nullptr</span>, <span class="number">0</span>)                                     \</span><br><span class="line">  <span class="comment">/* END Template */</span>                                               \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* Punctuators (ECMA-262, section 7.7, page 15). */</span>              \</span><br><span class="line">  <span class="comment">/* BEGIN Property */</span>                                             \</span><br><span class="line">  T(PERIOD, <span class="string">"."</span>, <span class="number">0</span>)                                                \</span><br><span class="line">  T(LBRACK, <span class="string">"["</span>, <span class="number">0</span>)                                                \</span><br><span class="line">  <span class="comment">/* END Property */</span>                                               \</span><br><span class="line">  <span class="comment">/* END Member */</span>                                                 \</span><br><span class="line">  T(QUESTION_PERIOD, <span class="string">"?."</span>, <span class="number">0</span>)                                      \</span><br><span class="line">  T(LPAREN, <span class="string">"("</span>, <span class="number">0</span>)                                                \</span><br><span class="line">  <span class="comment">/* END PropertyOrCall */</span>                                         \</span><br><span class="line">  T(RPAREN, <span class="string">")"</span>, <span class="number">0</span>)                                                \</span><br><span class="line">  T(RBRACK, <span class="string">"]"</span>, <span class="number">0</span>)                                                \</span><br><span class="line">  T(LBRACE, <span class="string">"&#123;"</span>, <span class="number">0</span>)                                                \</span><br><span class="line">  T(COLON, <span class="string">":"</span>, <span class="number">0</span>)                                                 \</span><br><span class="line">  T(ELLIPSIS, <span class="string">"..."</span>, <span class="number">0</span>)                                            \</span><br><span class="line">  T(CONDITIONAL, <span class="string">"?"</span>, <span class="number">3</span>)                                           \</span><br><span class="line">  <span class="comment">/* BEGIN AutoSemicolon */</span>                                        \</span><br><span class="line">  T(SEMICOLON, <span class="string">";"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  T(RBRACE, <span class="string">"&#125;"</span>, <span class="number">0</span>)                                                \</span><br><span class="line">  <span class="comment">/* End of source indicator. */</span>                                   \</span><br><span class="line">  T(EOS, <span class="string">"EOS"</span>, <span class="number">0</span>)                                                 \</span><br><span class="line">  <span class="comment">/* END AutoSemicolon */</span>                                          \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* BEGIN ArrowOrAssignmentOp */</span>                                  \</span><br><span class="line">  T(ARROW, <span class="string">"=&gt;"</span>, <span class="number">0</span>)                                                \</span><br><span class="line">  <span class="comment">/* BEGIN AssignmentOp */</span>                                         \</span><br><span class="line">  <span class="comment">/* IsAssignmentOp() relies on this block of enum values being */</span> \</span><br><span class="line">  <span class="comment">/* contiguous and sorted in the same order! */</span>                   \</span><br><span class="line">  T(INIT, <span class="string">"=init"</span>, <span class="number">2</span>) <span class="comment">/* AST-use only. */</span>                          \</span><br><span class="line">  T(ASSIGN, <span class="string">"="</span>, <span class="number">2</span>)                                                \</span><br><span class="line">  BINARY_OP_TOKEN_LIST(T, EXPAND_BINOP_ASSIGN_TOKEN)               \</span><br><span class="line">  <span class="comment">/* END AssignmentOp */</span>                                           \</span><br><span class="line">  <span class="comment">/* END ArrowOrAssignmentOp */</span>                                    \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* Binary operators sorted by precedence. */</span>                     \</span><br><span class="line">  <span class="comment">/* IsBinaryOp() relies on this block of enum values */</span>           \</span><br><span class="line">  <span class="comment">/* being contiguous and sorted in the same order! */</span>             \</span><br><span class="line">  T(COMMA, <span class="string">","</span>, <span class="number">1</span>)                                                 \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* Unary operators, starting at ADD in BINARY_OP_TOKEN_LIST  */</span>  \</span><br><span class="line">  <span class="comment">/* IsUnaryOp() relies on this block of enum values */</span>            \</span><br><span class="line">  <span class="comment">/* being contiguous and sorted in the same order! */</span>             \</span><br><span class="line">  BINARY_OP_TOKEN_LIST(T, EXPAND_BINOP_TOKEN)                      \</span><br><span class="line">                                                                   \</span><br><span class="line">  T(NOT, <span class="string">"!"</span>, <span class="number">0</span>)                                                   \</span><br><span class="line">  T(BIT_NOT, <span class="string">"~"</span>, <span class="number">0</span>)                                               \</span><br><span class="line">  K(DELETE, <span class="string">"delete"</span>, <span class="number">0</span>)                                           \</span><br><span class="line">  K(TYPEOF, <span class="string">"typeof"</span>, <span class="number">0</span>)                                           \</span><br><span class="line">  K(VOID, <span class="string">"void"</span>, <span class="number">0</span>)                                               \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* BEGIN IsCountOp */</span>                                            \</span><br><span class="line">  T(INC, <span class="string">"++"</span>, <span class="number">0</span>)                                                  \</span><br><span class="line">  T(DEC, <span class="string">"--"</span>, <span class="number">0</span>)                                                  \</span><br><span class="line">  <span class="comment">/* END IsCountOp */</span>                                              \</span><br><span class="line">  <span class="comment">/* END IsUnaryOrCountOp */</span>                                       \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* Compare operators sorted by precedence. */</span>                    \</span><br><span class="line">  <span class="comment">/* IsCompareOp() relies on this block of enum values */</span>          \</span><br><span class="line">  <span class="comment">/* being contiguous and sorted in the same order! */</span>             \</span><br><span class="line">  T(EQ, <span class="string">"=="</span>, <span class="number">9</span>)                                                   \</span><br><span class="line">  T(EQ_STRICT, <span class="string">"==="</span>, <span class="number">9</span>)                                           \</span><br><span class="line">  T(NE, <span class="string">"!="</span>, <span class="number">9</span>)                                                   \</span><br><span class="line">  T(NE_STRICT, <span class="string">"!=="</span>, <span class="number">9</span>)                                           \</span><br><span class="line">  T(LT, <span class="string">"&lt;"</span>, <span class="number">10</span>)                                                   \</span><br><span class="line">  T(GT, <span class="string">"&gt;"</span>, <span class="number">10</span>)                                                   \</span><br><span class="line">  T(LTE, <span class="string">"&lt;="</span>, <span class="number">10</span>)                                                 \</span><br><span class="line">  T(GTE, <span class="string">"&gt;="</span>, <span class="number">10</span>)                                                 \</span><br><span class="line">  K(INSTANCEOF, <span class="string">"instanceof"</span>, <span class="number">10</span>)                                  \</span><br><span class="line">  K(IN, <span class="string">"in"</span>, <span class="number">10</span>)                                                  \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* Keywords (ECMA-262, section 7.5.2, page 13). */</span>               \</span><br><span class="line">  K(BREAK, <span class="string">"break"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  K(CASE, <span class="string">"case"</span>, <span class="number">0</span>)                                               \</span><br><span class="line">  K(CATCH, <span class="string">"catch"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  K(CONTINUE, <span class="string">"continue"</span>, <span class="number">0</span>)                                       \</span><br><span class="line">  K(DEBUGGER, <span class="string">"debugger"</span>, <span class="number">0</span>)                                       \</span><br><span class="line">  K(<span class="literal">DEFAULT</span>, <span class="string">"default"</span>, <span class="number">0</span>)                                         \</span><br><span class="line">  <span class="comment">/* DELETE */</span>                                                     \</span><br><span class="line">  K(DO, <span class="string">"do"</span>, <span class="number">0</span>)                                                   \</span><br><span class="line">  K(ELSE, <span class="string">"else"</span>, <span class="number">0</span>)                                               \</span><br><span class="line">  K(FINALLY, <span class="string">"finally"</span>, <span class="number">0</span>)                                         \</span><br><span class="line">  K(FOR, <span class="string">"for"</span>, <span class="number">0</span>)                                                 \</span><br><span class="line">  K(FUNCTION, <span class="string">"function"</span>, <span class="number">0</span>)                                       \</span><br><span class="line">  K(IF, <span class="string">"if"</span>, <span class="number">0</span>)                                                   \</span><br><span class="line">  <span class="comment">/* IN */</span>                                                         \</span><br><span class="line">  <span class="comment">/* INSTANCEOF */</span>                                                 \</span><br><span class="line">  K(NEW, <span class="string">"new"</span>, <span class="number">0</span>)                                                 \</span><br><span class="line">  K(RETURN, <span class="string">"return"</span>, <span class="number">0</span>)                                           \</span><br><span class="line">  K(SWITCH, <span class="string">"switch"</span>, <span class="number">0</span>)                                           \</span><br><span class="line">  K(THROW, <span class="string">"throw"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  K(TRY, <span class="string">"try"</span>, <span class="number">0</span>)                                                 \</span><br><span class="line">  <span class="comment">/* TYPEOF */</span>                                                     \</span><br><span class="line">  K(VAR, <span class="string">"var"</span>, <span class="number">0</span>)                                                 \</span><br><span class="line">  <span class="comment">/* VOID */</span>                                                       \</span><br><span class="line">  K(WHILE, <span class="string">"while"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  K(WITH, <span class="string">"with"</span>, <span class="number">0</span>)                                               \</span><br><span class="line">  K(THIS, <span class="string">"this"</span>, <span class="number">0</span>)                                               \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* Literals (ECMA-262, section 7.8, page 16). */</span>                 \</span><br><span class="line">  K(NULL_LITERAL, <span class="string">"null"</span>, <span class="number">0</span>)                                       \</span><br><span class="line">  K(TRUE_LITERAL, <span class="string">"true"</span>, <span class="number">0</span>)                                       \</span><br><span class="line">  K(FALSE_LITERAL, <span class="string">"false"</span>, <span class="number">0</span>)                                     \</span><br><span class="line">  T(NUMBER, <span class="literal">nullptr</span>, <span class="number">0</span>)                                            \</span><br><span class="line">  T(SMI, <span class="literal">nullptr</span>, <span class="number">0</span>)                                               \</span><br><span class="line">  T(BIGINT, <span class="literal">nullptr</span>, <span class="number">0</span>)                                            \</span><br><span class="line">  T(STRING, <span class="literal">nullptr</span>, <span class="number">0</span>)                                            \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* BEGIN Callable */</span>                                             \</span><br><span class="line">  K(SUPER, <span class="string">"super"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  <span class="comment">/* BEGIN AnyIdentifier */</span>                                        \</span><br><span class="line">  <span class="comment">/* Identifiers (not keywords or future reserved words). */</span>       \</span><br><span class="line">  T(IDENTIFIER, <span class="literal">nullptr</span>, <span class="number">0</span>)                                        \</span><br><span class="line">  K(GET, <span class="string">"get"</span>, <span class="number">0</span>)                                                 \</span><br><span class="line">  K(SET, <span class="string">"set"</span>, <span class="number">0</span>)                                                 \</span><br><span class="line">  K(ASYNC, <span class="string">"async"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  <span class="comment">/* `await` is a reserved word in module code only */</span>             \</span><br><span class="line">  K(AWAIT, <span class="string">"await"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  K(YIELD, <span class="string">"yield"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  K(LET, <span class="string">"let"</span>, <span class="number">0</span>)                                                 \</span><br><span class="line">  K(STATIC, <span class="string">"static"</span>, <span class="number">0</span>)                                           \</span><br><span class="line">  <span class="comment">/* Future reserved words (ECMA-262, section 7.6.1.2). */</span>         \</span><br><span class="line">  T(FUTURE_STRICT_RESERVED_WORD, <span class="literal">nullptr</span>, <span class="number">0</span>)                       \</span><br><span class="line">  T(ESCAPED_STRICT_RESERVED_WORD, <span class="literal">nullptr</span>, <span class="number">0</span>)                      \</span><br><span class="line">  <span class="comment">/* END AnyIdentifier */</span>                                          \</span><br><span class="line">  <span class="comment">/* END Callable */</span>                                               \</span><br><span class="line">  K(ENUM, <span class="string">"enum"</span>, <span class="number">0</span>)                                               \</span><br><span class="line">  K(CLASS, <span class="string">"class"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  K(CONST, <span class="string">"const"</span>, <span class="number">0</span>)                                             \</span><br><span class="line">  K(EXPORT, <span class="string">"export"</span>, <span class="number">0</span>)                                           \</span><br><span class="line">  K(EXTENDS, <span class="string">"extends"</span>, <span class="number">0</span>)                                         \</span><br><span class="line">  K(IMPORT, <span class="string">"import"</span>, <span class="number">0</span>)                                           \</span><br><span class="line">  T(PRIVATE_NAME, <span class="literal">nullptr</span>, <span class="number">0</span>)                                      \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* Illegal token - not able to scan. */</span>                          \</span><br><span class="line">  T(ILLEGAL, <span class="string">"ILLEGAL"</span>, <span class="number">0</span>)                                         \</span><br><span class="line">  T(ESCAPED_KEYWORD, <span class="literal">nullptr</span>, <span class="number">0</span>)                                   \</span><br><span class="line">                                                                   \</span><br><span class="line">  <span class="comment">/* Scanner-internal use only. */</span>                                 \</span><br><span class="line">  T(WHITESPACE, <span class="literal">nullptr</span>, <span class="number">0</span>)                                        \</span><br><span class="line">  T(UNINITIALIZED, <span class="literal">nullptr</span>, <span class="number">0</span>)                                     \</span><br><span class="line">  T(REGEXP_LITERAL, <span class="literal">nullptr</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到V8定义了很多token类型，符号、关键字都被分开来定义。</p>
<p>但是作为一门简单的脚本语言，书中简单的将Token分为了3大类：</p>
<ol>
<li>Number Token：整形Token。</li>
<li>String Token：字符串Token。</li>
<li>Identifier Token: 标识符、关键字、变量名、运算符等。（除Number， String以外的单词）。</li>
</ol>
<p>每种Token我们定义了一个类，其存储的主要信息有行号和实值（数字，字符串，标识符）。</p>
<p>最主要对于代码的解析我们用到了Java的正则匹配。而在V8中是自己写了匹配规则。</p>
<p>我们简单介绍一下：</p>
<h2 id="java的正则表达式"><a href="#java的正则表达式" class="headerlink" title="java的正则表达式"></a>java的正则表达式</h2><h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。下面是他的所有成员：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile(String regex, ?int flags)</td>
<td>Pattern类没有构造函数，都是通过该函数来获得匹配实体。其中regex是正则表达式，flags是模式，比如是否匹配换行等，一般使用Patter提供的静态变量来传递。</td>
<td>Pattern：由传入正则表达式编译形成的patter实体。</td>
</tr>
<tr>
<td>match(String regex, CharSequence input)</td>
<td>通过传入的regex创建匹配实体并且尝试匹配input。</td>
<td>boolean：是否成功匹配。</td>
</tr>
<tr>
<td>quote(String s)</td>
<td>将返回一个仅匹配s的正则表达式。（实际上是在s前后分别\Q和\E）。</td>
<td>String：一个仅可匹配s的一个字符串。</td>
</tr>
<tr>
<td>CANON_EQ: int</td>
<td>表示当两个字符严格相等时才匹配。主要是对于Unicode字符而言。（不重要，不再赘述）。</td>
<td>/</td>
</tr>
<tr>
<td>CASE_INSENSITIVE:int</td>
<td>是否大小写敏感，默认是，传入该变量则表示不敏感（也可在regex中插入?i表示此意）。</td>
<td>/</td>
</tr>
<tr>
<td>COMMENTS:int</td>
<td>是否忽略regex中的空格，不是//s，而是空格或者tab等（也可在regex中插入?x表示此意）。</td>
<td>/</td>
</tr>
<tr>
<td>DOTALL:int</td>
<td>表示点(.)是否可以匹配所有字符，包括结束符。（也可在regex中插入?s表示此意）。</td>
<td>/</td>
</tr>
<tr>
<td>LITERAL:int</td>
<td>表示启用字面值解析模式。         指定此标志后，指定模式的输入字符串就会作为字面值字符序列来对待。输入序列中的元字符或转义序列不具有任何特殊意义。</td>
<td>/</td>
</tr>
<tr>
<td>MULTILINE:int</td>
<td>默认情况下，输入的字符串被看作是一行，即便是这一行中包好了换行符也被看作一行。当匹配“^”到“$”之间的内容的时候，整个输入被看成一个一行。启用多行模式之后，包含换行符的输入将被自动转换成多行，然后进行匹配。</td>
<td>/</td>
</tr>
<tr>
<td>UNIX_LINES:int</td>
<td>表示仅以\n为换行，\r\n将不会被识别为换行。（也可在regex中插入?d表示此意）。</td>
<td>/</td>
</tr>
</tbody>
</table>
<p>所以基本只会使用<code>compile</code>这个函数和以下的几个静态变量。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String regexPat = <span class="string">"\\abc"</span></span><br><span class="line"><span class="keyword">private</span> Pattern pattern = Pattern.compile(regexPat);</span><br></pre></td></tr></table></figure>
<h3 id="Matcher-类"><a href="#Matcher-类" class="headerlink" title="Matcher 类"></a>Matcher 类</h3><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
<p>下面是其成员：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public MatchResult toMatchResult()</td>
<td>将匹配结果以MatchResult的形式返回</td>
</tr>
<tr>
<td>public Matcher usePattern(Pattern newPattern)</td>
<td>修改Matcher对象的Pattern，用以进行新的模式匹配。</td>
</tr>
<tr>
<td>public Matcher reset()</td>
<td>重置匹配器的状态。</td>
</tr>
<tr>
<td>public Matcher reset(CharSequence input)</td>
<td>重置匹配器的状态，重置目标字符串的值为input。</td>
</tr>
<tr>
<td>public int start()</td>
<td>返回当前匹配到的字符串在原目标字符串中的起始索引位置</td>
</tr>
<tr>
<td>public int start(int group)</td>
<td>返回当前匹配到的字符串中group组在目标字符串的起始索引位置</td>
</tr>
<tr>
<td>public int end()</td>
<td>返回当前匹配的字符串的最后一个字符在原目标字符串中的offset（偏移量），这个需要大家注意一下。</td>
</tr>
<tr>
<td>public int end(int group)</td>
<td>返回当前匹配的字符串中group组的最后一个字符在原目标字符串中的offset（偏移量），这个需要大家注意一下。</td>
</tr>
<tr>
<td>public String group()</td>
<td>返回匹配到的所有字符串，结合find函数使用。</td>
</tr>
<tr>
<td>public String group(int group)</td>
<td>返回匹配到的字符串中的对应index的group组的字符串。</td>
</tr>
<tr>
<td>public String group(String name)</td>
<td>返回被named-capturing组捕获的字符串，关于named-capturing group（命名捕获组）是JDK1.7新增的功能，可以将正则表达式中的组进行命名。</td>
</tr>
<tr>
<td>public int groupCount()</td>
<td>返回当前Matcher对象捕获的组的个数。</td>
</tr>
<tr>
<td>public boolean matches()</td>
<td>将整个目标字符串与正则表达式进行匹配，只有完全匹配才能返回true，否则false。</td>
</tr>
<tr>
<td>public boolean find()</td>
<td>对目标字符串进行正则匹配，通过while可以多次执行find方法，获取多次的匹配结果，代码编写方式类似于iterator.next()。</td>
</tr>
<tr>
<td>public boolean find(int start)</td>
<td>在指定的索引位置对目标字符串进行正则匹配。</td>
</tr>
<tr>
<td>public boolean lookingAt()</td>
<td>目标字符串的起始字符串与正则表达式匹配返回true，否则返回false。</td>
</tr>
<tr>
<td>public static String quoteReplacement(String s)</td>
<td>返回字符串s字面意义的替代字符串。</td>
</tr>
<tr>
<td>public Matcher appendReplacement(StringBuffer sb, String replacement)</td>
<td>向sb中追加replacement字符串，replacement字符串中可以包含匹配器中的分组参数，如1，2。</td>
</tr>
<tr>
<td>public StringBuffer appendTail(StringBuffer sb)</td>
<td>将Matcher匹配后的尾部字符串追加至sb中。</td>
</tr>
<tr>
<td>public String replaceAll(String replacement)</td>
<td>将目标字符串中所有满足正则匹配的字符串替换为replacement。</td>
</tr>
<tr>
<td>public String replaceFirst(String replacement)</td>
<td>将目标字符串中第一个满足正则匹配的字符串替换为replacement。</td>
</tr>
<tr>
<td>public Matcher region(int start, int end)</td>
<td>设置目标字符串的匹配范围。</td>
</tr>
<tr>
<td>public int regionStart()</td>
<td>返回匹配器区域的起始点索引位置。</td>
</tr>
<tr>
<td>public int regionEnd()</td>
<td>返回匹配器区域的结束点索引位置。</td>
</tr>
<tr>
<td>public boolean hasTransparentBounds()</td>
<td>TransparentBounds标志位：查询TransparentBounds标志位true</td>
</tr>
<tr>
<td>public Matcher useTransparentBounds(boolean b)</td>
<td>设置TransparentBounds标志位的值true</td>
</tr>
<tr>
<td>public boolean hasAnchoringBounds()</td>
<td>AnchoringBounds标志位：查询AnchoringBounds标志位的值，此标志位默认为true。在应用正则表达式的时候，我们可以指定目标字符串的检索范围，也就是说在目标字符串的子字符串中应用正则表达式。但此时会有一个问题，那就是 ^ 和 $ 应该匹配整个字符串的开头和结尾呢？ 还是检索范围的起始和结束位置呢？Java 为我们提供了足够的灵活性，我们可以通过下面的方法来查看和设置，默认值是匹配检索范围的起始和结束位置。</td>
</tr>
<tr>
<td>public Matcher useAnchoringBounds(boolean b)</td>
<td>设置AnchoringBounds标志位的值true</td>
</tr>
<tr>
<td>public boolean hitEnd()</td>
<td></td>
</tr>
<tr>
<td>public boolean requireEnd()</td>
<td></td>
</tr>
<tr>
<td>boolean match(int from, int anchor)</td>
<td></td>
</tr>
<tr>
<td>int getTextLength()</td>
<td>返回目标字符串的长度。</td>
</tr>
<tr>
<td>CharSequence getSubSequence(int beginIndex, int endIndex)</td>
<td>获取目标字符串的子字符串。</td>
</tr>
<tr>
<td>char charAt(int i)</td>
<td>返回目标字符串中索引为i的字符</td>
</tr>
</tbody>
</table>
<h3 id="PatternSyntaxException"><a href="#PatternSyntaxException" class="headerlink" title="PatternSyntaxException"></a>PatternSyntaxException</h3><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
<h3 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h3><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p>
<p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p>
<ul>
<li>((A)(B(C)))</li>
<li>(A)</li>
<li>(B(C))</li>
<li>(C)</li>
</ul>
<p>可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。</p>
<p>还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。 </p>
<h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><p>有一个需要注意的点：</p>
<p>Java中的转移字符为两个反斜杠\\,这与其他语言不同。即当我们需要对一个字符进行转义的时候，我们需要在前面写两个\。</p>
<p>如：一般的我们需要匹配换行符\n这个符号的时候，我们只需要这么写：\n。</p>
<p>而在Java中，我们需要这么写：\\n。</p>
<p>下面是匹配的字符：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， n匹配字符 n。\n 匹配换行符。序列 \\\\ 匹配 \\ ，\\( 匹配 (。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td>
</tr>
<tr>
<td>*</td>
<td>零次或多次匹配<strong>前面</strong>的字符或子表达式。例如，zo<em> 匹配”z”和”zoo”。</em> 等效于 {0,}。</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次匹配<strong>前面</strong>的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次匹配<strong>前面</strong>的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td>?</td>
<td>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”\(“或者”\)”。</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配 <em>pattern</em> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (\</td>
<td>) 组合模式部件的情况很有用。例如，’industr(?:y\</td>
<td>ies) 是比 ‘industry\</td>
<td>industries’ 更经济的表达式。</td>
</tr>
<tr>
<td>(？=pattern)</td>
<td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <em>pattern</em> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95\</td>
<td>98\</td>
<td>NT\</td>
<td>2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <em>pattern</em> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95\</td>
<td>98\</td>
<td>NT\</td>
<td>2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td>x\</td>
<td>y</td>
<td>匹配 <em>x</em> 或 <em>y</em>。例如，’z\</td>
<td>food’ 匹配”z”或”food”。’(z\</td>
<td>f)ood’ 匹配”zood”或”food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td>
</tr>
<tr>
<td>\B</td>
<td>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符匹配。等效于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>非数字字符匹配。等效于 [^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r    \v] 等效。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td>\t</td>
<td>制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符匹配。与 \x0b 和 \cK 等效。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td>\W</td>
<td>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td>\xn</td>
<td>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td>\num</td>
<td>匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td>\n</td>
<td>标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</td>
</tr>
<tr>
<td>\nm</td>
<td>标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td>\nml</td>
<td>当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</td>
</tr>
<tr>
<td>\un</td>
<td>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
<tr>
<td>\p{Punct}</td>
<td>匹配任何标点字符。</td>
</tr>
</tbody>
</table>
<p>下面我们看一下主要的regexPat：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String regexPat = </span><br><span class="line">		<span class="string">"\\s*((//.*)|([0-9]+)|(\"(\\\\\"|\\\\\\\\|\\\\n|[^\"])*\")"</span></span><br><span class="line">		+<span class="string">"|[A-Z_a-z][A-Z_a-z0-9]*|==|&lt;=|&gt;=|&amp;&amp;|\\|\\||\\p&#123;Punct&#125;)?"</span>;</span><br></pre></td></tr></table></figure>
<p>接下来我们按上面的规则来分析这个解析表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"\\s*((//.*)|([0-9]+)|(\"(\\\\\"|\\\\\\\\|\\\\n|[^\"])*\")|[A-Z_a-z][A-Z_a-z0-9]*|==|&lt;=|&gt;=|&amp;&amp;|\\|\\||\\p&#123;Punct&#125;)?"</span>;</span><br></pre></td></tr></table></figure>
<p>我们经过格式化。可以得到以下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\s*                                            匹配空格</span><br><span class="line">(											  	  group(1)</span><br><span class="line">	(</span><br><span class="line">		&#x2F;&#x2F;.*										  匹配注释-group(2)</span><br><span class="line">	)                                        </span><br><span class="line">	|</span><br><span class="line">	(</span><br><span class="line">		[0-9]+										  匹配数字-group(3)</span><br><span class="line">	)                                      </span><br><span class="line">	|</span><br><span class="line">	(</span><br><span class="line">		\&quot;(\\\\\&quot;|\\\\\\\\|\\\\n|[^\&quot;])*\&quot;            匹配字符串-group(4)</span><br><span class="line">	)          </span><br><span class="line">	|</span><br><span class="line">	[A-Z_a-z][A-Z_a-z0-9]*                        匹配标识符，identifier</span><br><span class="line">	|</span><br><span class="line">	&#x3D;&#x3D;											  匹配&#x3D;&#x3D;</span><br><span class="line">	|</span><br><span class="line">	&lt;&#x3D;                                            匹配&lt;&#x3D;</span><br><span class="line">	|</span><br><span class="line">	&gt;&#x3D;                                            匹配&gt;&#x3D;</span><br><span class="line">	|</span><br><span class="line">	&amp;&amp;                                            匹配&amp;&amp;</span><br><span class="line">	|</span><br><span class="line">	\\                                            匹配\</span><br><span class="line">	|</span><br><span class="line">	\\|											  匹配|</span><br><span class="line">	|</span><br><span class="line">	\\p&#123;Punct&#125;                                    匹配任何标点字符</span><br><span class="line">)?                                                匹配0次或1次</span><br></pre></td></tr></table></figure>
<p>可以看出，我们将其分割开来，还是比较容易看懂的。所以此时我们再看匹配的Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToken</span><span class="params">(<span class="keyword">int</span> lineNumber, Matcher matcher)</span> </span>&#123;</span><br><span class="line">    String m = matcher.group(<span class="number">1</span>);  <span class="comment">//最外层匹配项</span></span><br><span class="line">    <span class="comment">//			System.out.println(m);</span></span><br><span class="line">    <span class="keyword">if</span>(m != <span class="keyword">null</span>) &#123; <span class="comment">//not a space</span></span><br><span class="line">        <span class="keyword">if</span>(matcher.group(<span class="number">2</span>) == <span class="keyword">null</span>) &#123; <span class="comment">//not a comment</span></span><br><span class="line">            Token token;</span><br><span class="line">            <span class="keyword">if</span>(matcher.group(<span class="number">3</span>) != <span class="keyword">null</span>) &#123; <span class="comment">//数字Token，例如123</span></span><br><span class="line">                token = <span class="keyword">new</span> NumToken(lineNumber, Integer.parseInt(m));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matcher.group(<span class="number">4</span>) != <span class="keyword">null</span>) &#123;	<span class="comment">//字符串匹配，例如 "123"</span></span><br><span class="line">                token = <span class="keyword">new</span> StrToken(lineNumber, toStringLiteral(m));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;		<span class="comment">//id匹配，例如while</span></span><br><span class="line">                token = <span class="keyword">new</span> IdToken(lineNumber, m);</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即可以完全和Java代码匹配出来。</p>
<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>所以词法分析的主要流程很简答：</p>
<ol>
<li>将代码读取出来为stream，按行读取。</li>
<li>使用正则表达式匹配每一行的代码，将其识别为对应的单词（token）。</li>
<li>将识别出的token加入到Lexer的ArrayList中。</li>
</ol>
]]></content>
      <categories>
        <category>hair</category>
      </categories>
      <tags>
        <tag>hair</tag>
        <tag>脚本语言</tag>
        <tag>词法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的sql调优手段</title>
    <url>/2022/07/11/%E5%B8%B8%E8%A7%81%E7%9A%84sql%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/</url>
    <content><![CDATA[<h1 id="常见手段"><a href="#常见手段" class="headerlink" title="常见手段"></a>常见手段</h1><h2 id="1-limit分页优化"><a href="#1-limit分页优化" class="headerlink" title="1. limit分页优化"></a>1. limit分页优化</h2><p>当偏移量特别大时，limit效率会非常低。</p>
<p>比如：</p>
<p><strong>SELECT id FROM A LIMIT 1000,10   很快</strong></p>
<p>SELECT id FROM A LIMIT 90000,10 很慢</p>
<p><strong>方案一</strong>：结合<code>order by</code>使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> A <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>其原理在于<code>order by</code>会调用索引，所以速度会快的多。</p>
<p><strong>方案二</strong>：结合<code>between...and...</code>，缩小检索范围。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> A <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>  <span class="keyword">between</span> <span class="number">90000</span> <span class="keyword">and</span> <span class="number">90010</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-利用limit-1-（MySQL）、top-1（SQL-Server）-取得一行"><a href="#2-利用limit-1-（MySQL）、top-1（SQL-Server）-取得一行" class="headerlink" title="2.利用limit 1 （MySQL）、top 1（SQL Server） 取得一行"></a>2.利用limit 1 （MySQL）、top 1（SQL Server） 取得一行</h2><p>有些业务逻辑进行查询操作时(特别是在根据某一字段DESC,取最大一笔)。可以使用limit 1 或者 top 1 来终止[数据库索引]继续扫描整个表或索引。</p>
<p>反例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">LIKE</span> <span class="string">'abc%'</span></span><br></pre></td></tr></table></figure>
<p>正例：limit</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">LIKE</span> <span class="string">'abc%'</span> <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="3-任何情况都不要用-select-from-table-，用具体的字段列表替换”“，不要返回用不到的字段-避免全盘扫描！"><a href="#3-任何情况都不要用-select-from-table-，用具体的字段列表替换”“，不要返回用不到的字段-避免全盘扫描！" class="headerlink" title="3. 任何情况都不要用 select  from table ，用具体的字段列表替换”“，不要返回用不到的字段,避免全盘扫描！"></a>3. 任何情况都不要用 select <em> from table ，用具体的字段列表替换”</em>“，不要返回用不到的字段,避免全盘扫描！</h2><p>反例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A</span><br></pre></td></tr></table></figure>
<p>正例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A</span><br></pre></td></tr></table></figure>
<p>但是值得注意的是：MyISAM引擎在计算<code>COUNT(*)</code>全表时会很快。</p>
<h2 id="4-批量插入优化"><a href="#4-批量插入优化" class="headerlink" title="4. 批量插入优化"></a>4. 批量插入优化</h2><p>反例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> person(<span class="keyword">name</span>,age) <span class="keyword">values</span>(<span class="string">'A'</span>,<span class="number">24</span>)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> person(<span class="keyword">name</span>,age) <span class="keyword">values</span>(<span class="string">'B'</span>,<span class="number">24</span>)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> person(<span class="keyword">name</span>,age) <span class="keyword">values</span>(<span class="string">'C'</span>,<span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>正例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> person(<span class="keyword">name</span>,age) <span class="keyword">values</span>(<span class="string">'A'</span>,<span class="number">24</span>),(<span class="string">'B'</span>,<span class="number">24</span>),(<span class="string">'C'</span>,<span class="number">24</span>),</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sql语句的优化主要在于对索引的正确使用，而我们在开发中经常犯的错误便是对表进行全盘扫描，一来影响性能，而来耗费时间!</p>
</blockquote>
<h2 id="5-like语句的优化"><a href="#5-like语句的优化" class="headerlink" title="5.like语句的优化"></a>5.like语句的优化</h2><p>反例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%abc%'</span></span><br></pre></td></tr></table></figure>
<p>由于abc前面用了“%”，因此该查询必然走全表查询,除非必要(模糊查询需要包含abc)，否则不要在关键词前加%</p>
<p>正例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'abc%'</span></span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p>mysql版本：5.7.26</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> nick_name <span class="keyword">from</span> <span class="keyword">member</span> <span class="keyword">where</span> nick_name <span class="keyword">like</span> <span class="string">'%小明%'</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/常见的sql调优手段/%无索引.jpg" alt="%无索引"></p>
<p><strong>like’%小明%’</strong> 并未使用索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> nick_name <span class="keyword">from</span> <span class="keyword">member</span> <span class="keyword">where</span> nick_name <span class="keyword">like</span> <span class="string">'小明%'</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/常见的sql调优手段/%有索引.jpg" alt="%有索引"></p>
<p><strong>like’小明%’</strong> 成功使用索引。</p>
<h2 id="6-where子句使用or的优化"><a href="#6-where子句使用or的优化" class="headerlink" title="6.where子句使用or的优化"></a>6.where子句使用or的优化</h2><p>通常使用 union all 或 union 的方式替换“or”会得到更好的效果。where子句中使用了or关键字,索引将被放弃使用。</p>
<p>反例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">num</span> = <span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>正例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">num</span> = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h2 id="7-where子句中使用-IS-NULL-或-IS-NOT-NULL-的优化"><a href="#7-where子句中使用-IS-NULL-或-IS-NOT-NULL-的优化" class="headerlink" title="7.where子句中使用 IS NULL 或 IS NOT NULL 的优化"></a>7.where子句中使用 IS NULL 或 IS NOT NULL 的优化</h2><p>反例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">num</span> <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<p>在where子句中使用 IS NULL 或 IS NOT NULL 判断，索引将被放弃使用，会进行全表查询。</p>
<p>正例</p>
<p><strong>优化成num上设置默认值0</strong>，确保表中num没有null值, IS NULL 的用法在实际业务场景下SQL使用率极高，我们应注意<strong>避免全表扫描</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">num</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="8-where子句中对字段进行表达式操作的优化"><a href="#8-where子句中对字段进行表达式操作的优化" class="headerlink" title="8.where子句中对字段进行表达式操作的优化"></a>8.where子句中对字段进行表达式操作的优化</h2><p>不要在where子句中的“=”左边进行函数、算数运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<ul>
<li><strong>1</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">datediff</span>(<span class="keyword">day</span>,createdate,<span class="string">'2019-11-30'</span>)=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>优化为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> createdate&gt;=<span class="string">'2019-11-30'</span> <span class="keyword">and</span> createdate&lt;<span class="string">'2019-12-1'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>2</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">year</span>(addate) &lt;<span class="number">2020</span></span><br></pre></td></tr></table></figure>
<p>优化为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">where</span> addate&lt;<span class="string">'2020-01-01'</span></span><br></pre></td></tr></table></figure>
<h2 id="9-排序的索引问题"><a href="#9-排序的索引问题" class="headerlink" title="9. 排序的索引问题 "></a>9. 排序的索引问题 </h2><p>mysql查询只是用一个索引，因此如果where子句中已经使用了索引的话，那么<strong>order by中的列是不会使用索引</strong>。因此数据库默认排序可以符合要求情况下不要使用排序操作；</p>
<p>尽量不要包含多个列的排序，如果需要最好给这些列创建<strong>复合索引</strong>。</p>
<h2 id="10-尽量用-union-all-替换-union"><a href="#10-尽量用-union-all-替换-union" class="headerlink" title="10. 尽量用 union all 替换 union"></a>10. 尽量用 union all 替换 union</h2><p>union和union all的差异主要是<strong>前者</strong>需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的cpu运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用union all而不是union</p>
<h2 id="11-Inner-join-和-left-join、right-join、子查询"><a href="#11-Inner-join-和-left-join、right-join、子查询" class="headerlink" title="11.Inner join 和 left join、right join、子查询"></a>11.Inner join 和 left join、right join、子查询</h2><ul>
<li>第一：inner join内连接也叫等值连接是，left/rightjoin是外连接。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.id,A.name,B.id,B.name <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id =B.id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> A.id,A.name,B.id,B.name <span class="keyword">FROM</span> A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="keyword">ON</span> B A.id= B.id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> A.id,A.name,B.id,B.name <span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">ON</span> A.id =B.id;</span><br></pre></td></tr></table></figure>
<p>经过来之多方面的证实 inner join性能比较快，因为inner join是等值连接，或许返回的行数比较少。但是我们要记得有些语句隐形的用到了等值连接，如：</p>
<p><strong>SELECT A.id,A.name,B.id,B.name FROM A,B WHERE A.id = B.id;</strong></p>
<p><strong>推荐：能用inner join连接尽量使用inner join连接</strong></p>
<ul>
<li>第二：子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。</li>
</ul>
<p>反例</p>
<p>mysql是先对外表A执行全表查询，然后根据uuid逐次执行子查询，如果外层表是一个很大的表，我们可以想象查询性能会表现比这个更加糟糕。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>* <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">3000</span> <span class="keyword">and</span> A.uuid=B.uuid);</span><br></pre></td></tr></table></figure>
<p><strong>执行时间：2s左右</strong></p>
<p>正例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>* <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">ON</span> A.uuid=B.uuid <span class="keyword">where</span> b.uuid&gt;=<span class="number">3000</span>;  这个语句执行测试不到一秒；</span><br></pre></td></tr></table></figure>
<p><strong>执行时间：1s不到</strong></p>
<ul>
<li>第三：使用JOIN时候，应该用小的结果驱动大的结果</li>
</ul>
<p>left join 左边表结果尽量小，如果有条件应该放到左边先处理，right join同理反向。如：</p>
<p>反例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B A.id=B.ref_id <span class="keyword">where</span>  A.id&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>正例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> A wehre <span class="keyword">id</span> &gt;<span class="number">10</span>) T1 <span class="keyword">left</span> <span class="keyword">join</span> B <span class="keyword">on</span> T1.id=B.ref_id;</span><br></pre></td></tr></table></figure>
<h3 id="12-exist-amp-in-优化"><a href="#12-exist-amp-in-优化" class="headerlink" title="12.exist &amp; in 优化"></a>12.exist &amp; in 优化</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> A <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">in</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">from</span> B )</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> A <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">from</span> A.id= B.id )</span><br></pre></td></tr></table></figure>
<h1 id="查询的拆分"><a href="#查询的拆分" class="headerlink" title="查询的拆分"></a>查询的拆分</h1><p>设计查询的时候一个需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。在传统实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。</p>
<p>但是这样的想法对于MySQL并不适用，对于MySQL，可以适当的拆分（比如需要使用联合查询与子查询的地方）。</p>
<p>其主要原因有以下几点：</p>
<ul>
<li>MySQL从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。</li>
<li>减少锁的持有时间，比如一个大型的任务，拆分后方便其他任务有时间执行。</li>
<li>可以有效地利用缓存。许多应用程序可以方便地缓存单表查询对应的结果对象。</li>
<li>可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。</li>
</ul>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag post <span class="keyword">ON</span> tag post.tag_id=tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag post.post_id post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag <span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure>
<p>应该改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag post <span class="keyword">WHERE</span> tag_id=<span class="number">1</span>’;</span><br><span class="line"><span class="keyword">SELECT</span>*<span class="keyword">FROM</span> tag post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span>*<span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">in</span> (<span class="number">123</span>,<span class="number">456</span>, <span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>对于JS中localStorage的理解</title>
    <url>/2018/08/20/%E5%AF%B9%E4%BA%8EJS%E4%B8%ADlocalStorage%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在开发博客的过程中，遇到了数据储存的问题，由于我服务器中还未安装sql，加上我对数据库的操作还不是很熟悉，所以先把数据放入了localStorage中，所以我就具体了解了一下这个本地数据库。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前端的存储数据的三种方式"><a href="#前端的存储数据的三种方式" class="headerlink" title="前端的存储数据的三种方式"></a>前端的存储数据的三种方式</h2><p>前端一般数据存储的方式有三种：</p>
<ol>
<li>cookies</li>
<li>sessionStorage</li>
<li><p>localStorage</p>
<a id="more"></a>
<p>简单介绍一下这三种方式的异同：</p>
</li>
<li><p>cookies与localStorage可以是永久存储（cookies可设置失效时间；用户不主动清除）</p>
</li>
<li>sessionStorage与localStorage属于H5引入的新标签，在IE8，Chrome4.0等以上才能执行；并且存储空间更大（5MB/站点）相对于cookies（4KB/站点）。<h2 id="具体localStorage的解析"><a href="#具体localStorage的解析" class="headerlink" title="具体localStorage的解析"></a>具体localStorage的解析</h2></li>
</ol>
<h3 id="localStorage的优势与局限"><a href="#localStorage的优势与局限" class="headerlink" title="localStorage的优势与局限"></a>localStorage的优势与局限</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>相对于cookies拓展了空间大小。</li>
<li>相对于sessionStorage，可永久存储信息。</li>
</ol>
<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><ol>
<li>由于是H5引入的属性，可能一些老版的浏览器不支持该属性。</li>
<li>localStorage所存储的信息被限定被string类型，但由于有JSON等对象转换算法，所以也无所谓了。</li>
<li>另外我在网上了解到，localStorage无法被爬虫抓取到，这一点我目前没有深入探究。</li>
</ol>
<h3 id="localStorage的使用"><a href="#localStorage的使用" class="headerlink" title="localStorage的使用"></a>localStorage的使用</h3><h4 id="判断浏览器是否支持-localStorage属性"><a href="#判断浏览器是否支持-localStorage属性" class="headerlink" title="判断浏览器是否支持 localStorage属性"></a>判断浏览器是否支持 localStorage属性</h4><pre><code>if(！window.localStorage){
    alert(&quot;您的浏览器不支持localStorage&quot;)
    return false}
else{
        //执行代码
    }
</code></pre><h4 id="localStorage的写入"><a href="#localStorage的写入" class="headerlink" title="localStorage的写入"></a>localStorage的写入</h4><p>三种方法：</p>
<pre><code>var data=window.localStorage;
data[&quot;name&quot;] = MJ;//关键字name写入
data.age = 20;//关键字age的写入
data.setItem = [&quot;shcool&quot;,清华大学];//关键字school写入
</code></pre><p>注意：前面是将localStorage属性放入了data变量，同样可以不放入变量，直接调用，所以前面的代码等同于:</p>
<pre><code>localStorage[&quot;name&quot;]=MJ;
localStorage.age=20;
localStorage.setItem(&quot;school&quot;,清华大学);
</code></pre><h4 id="localStorage的读取"><a href="#localStorage的读取" class="headerlink" title="localStorage的读取"></a>localStorage的读取</h4><p>三种方法：</p>
<pre><code>var name = localStorage[&quot;name&quot;];
var age = localStorage.age;
var school = localStorage.getItem(&quot;school&quot;);
</code></pre><p>同样想写入方法一样，也可以将localStorage放入变量中在调用。</p>
<p><strong>值得注意的是，官方更推荐使用，setItem与getItem语法，其原因未具体说明，我猜测可能是为了与JS中的对象区分开，更加语言话，不产生混淆</strong></p>
<h4 id="localStorage的删改"><a href="#localStorage的删改" class="headerlink" title="localStorage的删改"></a>localStorage的删改</h4><p>localStorage改关键字的值其实就是重新为其赋值，即：</p>
<pre><code>localStorage.setItem(&quot;name&quot;,MW);
var nameAfter=localStorage.getItem(&quot;name&quot;);
//nameAfter===MW-&gt;true
</code></pre><p>localStorage的删除：</p>
<pre><code>localStorage.clear();//删除改站点的所有localStorage数据
localStorage.removeItem(&quot;name&quot;);
//此时localStorage.name-&gt;nudifined
</code></pre><h3 id="关于存储的数据仅为string的解决办法（JSON数据类型转换）"><a href="#关于存储的数据仅为string的解决办法（JSON数据类型转换）" class="headerlink" title="关于存储的数据仅为string的解决办法（JSON数据类型转换）"></a>关于存储的数据仅为string的解决办法（JSON数据类型转换）</h3><p>一，写入时转换为JSON格式输入</p>
<pre><code>var person={
        name = &quot;MJ&quot;,
        age = 20,
        maritalStatus = true
        }
    localStorage.setItem(&quot;person&quot;,JSON.string(person));
</code></pre><p>二，读取时转换为JS变量</p>
<pre><code>var person =JSON.parse(localStorage.getItem(&quot;person&quot;));
typof(person.age) //typeof检查变量类型为number
typeof(person.maritalStstus)//boolean
</code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本来写之前感觉有很多注意要写，但写起来感觉哪些之前感觉是注意点的地方其实只是一个普通的点，所以感觉写起来感觉没有太重要的点，但需要注意的点还是有滴，比如三种存储的异同，localStorage存储的数据仅为string等等。ok，就这样把！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>localStorage</tag>
      </tags>
  </entry>
  <entry>
    <title>开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）</title>
    <url>/2018/08/25/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%89%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%EF%BC%88%E5%88%A9%E7%94%A8localStorage%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://imgchr.com/i/PHzEY4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/08/25/PHzEY4.md.jpg" alt="PHzEY4.md.jpg"></a><br>这个小项目花了我大概10天的时间（每天5h左右），可以说是很慢了，主要是JS的很多知识点不熟悉，边研究边开发。而且数据库部分仍然时使用本地存储，也就是说这个案例是无法投入到实际使用中，但后面我会去研究一下mysql，在服务器端部署一个小型的数据库，估计不会花太长时间，另外觉得node.js挺有意思，hexo就是基于node.js，将JS用于与计算机系统的直接沟通，That`s cool，本来我的原计划是将博客信息存储在本地文件中，比如直接在本地存储一个JSON文件用来存储一篇博客，后来发现这个是实现不了的，因为浏览器内核无法与系统直接沟通，内核是在浏览器提供的一个BOX中运行，无法直接操作系统文件，emmmm，可能这也是为系统安全把，不然随便一个恶意网页就可以操作你的文件，This is unimaginative。也是因为这个所以才有了node.js的诞生的吧！<br><a id="more"></a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>BB了那么久，咳咳，进入正题。</p>
<h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p><img src="https://s1.ax1x.com/2018/08/25/PHxkRA.png" alt="PHxkRA.png"></p>
<p>布局过后首页上半部分是这样，和当初的设计差不多。整个上半部分是一个<strong>轮播图</strong>。</p>
<pre><code>var i=0;
setInterval(function(){
  if(i&lt;4)
  {
  i++;
   $(document).ready(function(){
     $(&quot;.item&quot;).eq(i).fadeIn(2000).siblings().fadeOut(2000);
   });
 }
 else
 {
   $(document).ready(function(){
     $(&quot;.item&quot;).eq(3).fadeIn(2000).siblings().fadeOut(2000);
   });
   i=-1;
 }
  //console.log(i);
}, 4000);
</code></pre><p>用了<strong>jquery</strong>的fadeIn,fadeOut方法，由于没有按钮使代码很简单，只用了十多行代码。唯一有问题的最后一张图片与第一张总是相差设定时间的2倍，想了许多办法没有解决，我就直接班另一张图片插入到最后一张与第一张的间隔之间，这样就实现图片的播放速度是均匀的，但问题是不循环播放的，有一张图片要多出现一次。</p>
<p>顶部分别是home，catalogue，和login的链接，左半部分有博主本人的logo。</p>
<p>点击<strong>logo</strong>可以将其大部分隐藏到屏幕外侧，like this，</p>
<p><img src="https://s1.ax1x.com/2018/08/25/PHxAxI.png" alt="PHxAxI.png"></p>
<p>再次点击边缘部分，可再次点击召唤出logo &lt;- &lt;-<br>其原理也很简单，只是利用了jquery的动画方法，</p>
<pre><code>animate（）
</code></pre><p>布局方面整个上半部分设计简单，只用了原生的CSS与html完成。</p>
<p><img src="https://s1.ax1x.com/2018/08/25/PHvzqK.png" alt="PHvzqK.png"></p>
<p>下半部分是文章展示部分，我是在首页设置了几篇置顶文章，具体方法是直接在在html文档中写入写入这一部分代码，不是JS后期插入到文档中，然后下面是使用JS写入的文章部分，这些文章都是存储在数据库中的部分，并且可以在article页面查看。<br>具体实现方式是在写入博客时将博客的title，date，tags，article写入到一个对象中，再JSON化写入本地（这里JSON化的原因在上期关于localStorage的介绍中已经写到，主要原因是localStorage只能存储string要想保留格式，JSON化是一种比较好的办法）。然后在首页读取数据再<strong>JSON.parse</strong>，在格式插入到文档中。</p>
<p>另外在首页还需要解决问题就是将文章序号传输到文章展示页面，因为当点击文章标题或more时，需要跳转至文章展示页面，展示该文章。我所想到的解决办法是在添加文章到首页文档流中时就把序号写入放置该文章的div的id的尾部，传输到展示页面时再通过this关键字读取id关键字（在测试中我也发现this无法获取class属性的值，原因我正在探索中，后面会出一起专门关于<strong>this</strong>的文章），并通过<strong>charAt()</strong><br>获取该序号，然后通过URL传值的方法将其传递到展示页面。</p>
<h2 id="展示页面"><a href="#展示页面" class="headerlink" title="展示页面"></a>展示页面</h2><p><img src="https://s1.ax1x.com/2018/08/25/PHxiPH.png" alt="PHxiPH.png"></p>
<p>文章展示页面提供问文章的全面展示，并且提供评论功能。（本来是打算在首页也只展示文章的部分，后来感觉有点麻烦，看后面有时间了再实现）。</p>
<p>接上面首页传输文章序号到展示页面，展示页面通过函数解析序号，这个函数我实用的网上的一个模板，代码如下。</p>
<pre><code>UrlParm = function() { // url参数
var data, index;
(function init() {
data = [];
index = {};
var u = window.location.search.substr(1);
if (u != &apos;&apos;) {
  var parms = decodeURIComponent(u).split(&apos;&amp;&apos;);
  for (var i = 0, len = parms.length; i &lt; len; i++) {
    if (parms[i] != &apos;&apos;) {
      var p = parms[i].split(&quot;=&quot;);
      if (p.length == 1 || (p.length == 2 &amp;&amp; p[1] == &apos;&apos;)) {// p | p=
        data.push([&apos;&apos;]);
        index[p[0]] = data.length - 1;
      } else if (typeof(p[0]) == &apos;undefined&apos; || p[0] == &apos;&apos;) { // =c | =
        data[0] = [p[1]];
      } else if (typeof(index[p[0]]) == &apos;undefined&apos;) { // c=aaa
        data.push([p[1]]);
        index[p[0]] = data.length - 1;
      } else {// c=aaa
        data[index[p[0]]].push(p[1]);
      }
    }
  }
}
})();
return {
// 获得参数,类似request.getParameter()
parm : function(o) { // o: 参数名或者参数次序
  try {
    return (typeof(o) == &apos;number&apos; ? data[o][0] : data[index[o]][0]);
  } catch (e) {
  }
},
//获得参数组, 类似request.getParameterValues()
parmValues : function(o) { //  o: 参数名或者参数次序
  try {
    return (typeof(o) == &apos;number&apos; ? data[o] : data[index[o]]);
  } catch (e) {}
},
//是否含有parmName参数
hasParm : function(parmName) {
  return typeof(parmName) == &apos;string&apos; ? typeof(index[parmName]) != &apos;undefined&apos; : false;
},
// 获得参数Map ,类似request.getParameterMap()
parmMap : function() {
  var map = {};
  try {
    for (var p in index) {  map[p] = data[index[p]];  }
  } catch (e) {}
  return map;
  }
 }
}();
</code></pre><p>有点长，权当备份一下，后面在分析这个函数。</p>
<p>展示页面解析到文章序号后，展示函数直接通过读取数据库读取到数据添加到文档流中。</p>
<p><strong>评论部分</strong>的实现也比较简单，通过读取文档中用户输入的信息并将其重新写入该文章数据库中的JSON中，展示时自动展示出来。</p>
<h2 id="目录页面"><a href="#目录页面" class="headerlink" title="目录页面"></a>目录页面</h2><p><img src="https://s1.ax1x.com/2018/08/25/PHxCIe.png" alt="PHxCIe.png"></p>
<p>目录页面展示了所有通过JS放入数据库的文章（不包括首页置顶文章）。</p>
<p>这里的实现就是直接遍历数据库中的博客文章信息，因为当时存储时是格式命名的，所以遍历很简单，再把title循环添加到文档流中就ok了。</p>
<h2 id="登录及后台管理页面"><a href="#登录及后台管理页面" class="headerlink" title="登录及后台管理页面"></a>登录及后台管理页面</h2><p><img src="https://s1.ax1x.com/2018/08/25/PHxVMt.png" alt="PHxVMt.png"></p>
<p>登录页面使用MD5加密方式，与本地存储的密匙（未来的密匙存储在服务器端）进行对比。</p>
<p><img src="https://s1.ax1x.com/2018/08/25/PHxFGd.png" alt="PHxFGd.png"></p>
<p>这里是在登录过后显示页面，首先这里布局还是用了frame框架，我暂时还没想到更好的替代办法，虽然frame在H5已被抛弃。</p>
<p>在写博客页面，用户将自己的文章内容输入，然后提交，文章内容会被JSON化后被保存到数据库，下次进入首页时就会直接被展示出来。</p>
<p><img src="https://s1.ax1x.com/2018/08/25/PHx9aD.png" alt="PHx9aD.png"></p>
<p>删改页面也是遍历数据库，直接修改数据库内容就好了，还是比较简单了，具体过程就不再赘述。</p>
<p>最后的工具页面是我想没事可以自己开发一些简单的工具，比如什么颜色拾取等等，这也是后话。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>其实这个小项目还是比较简单，代码量也不是很大，主要是练一下手，熟悉以一下前端的一些知识，当然这个小项目还有很多不足需要满足，包括在代码规范等等,方便后面的深入学习。当然后面在学习玩数据库后会把本地数据库改为服务器端的数据库，使之可以实际运行。</p>
]]></content>
      <categories>
        <category>博客开发系列</category>
      </categories>
      <tags>
        <tag>博客开发</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习1-决策树算法</title>
    <url>/2021/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="算法回忆总述"><a href="#算法回忆总述" class="headerlink" title="算法回忆总述"></a>算法回忆总述</h1><p>首先决策树算法的一个核心思想是通过一些方法将数据递归的划分为一个树状结构。其算法流程大致如下：</p>
<ol>
<li>读取数据<ol>
<li>注意CSV是文本格式，读取时是r；Excel是二进制文件，读取时是rb</li>
</ol>
</li>
<li>根据标准计算最优属性，一般选择香农熵，其流程如下：<ol>
<li>递归每一个属性，计算该属性的总熵值，总熵值为每个值得熵得和<ol>
<li>先统计该属性得所有不重复值的数据条数</li>
<li>根据公式：ent = (-item/count)*np.log2(item/count)  计算每个属性值的熵值 ， 其中item为该属性<span style="color:red">值</span>的数据数量、count为该属性的数据数量</li>
<li>将上面的每个属性值的ent相加，就得到该属性的总熵值</li>
</ol>
</li>
</ol>
</li>
<li>根据最优属性划分数据</li>
<li>根据划分得到的数据构建决策树，接下来有几种可能：<ol>
<li>如果最优属性的label唯一，那么则该属性的值即为该树节点的值</li>
<li>如果不是唯一的，则根据属性值来将其划分为对应的数据字典（例如： {属性值1：[数据1-1， 数据1-2，…]}），然后遍历该字典：<ol>
<li>如果该属性值的list的label唯一，则该属性的该值几位一个节点，由此构造节点。</li>
<li>否则对该属性递归该过程来构建树。</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>杂记兼第一个开源项目</title>
    <url>/2019/05/20/%E6%9D%82%E8%AE%B0%E5%85%BC%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>最近过完了第一遍《JavaScript高级程序设计》，有两个感觉</p>
<ol>
<li>JavaScript体系还是很巨大，值得深入挖掘</li>
<li>这本书太过老旧，我看了一下第一版是在2012年发行，最近一次修订是在2019年，但这一次修订并没有大范围修改书中的内容，仅仅添加了部分ES6的内容，并且ES6还是不是正式版，其中的ArrayType在正式版ES6中并没有实现。<a id="more"></a>
虽然如此，总体来说这本书还是非常有价值的，深入的讲解了JavaScript，包括组成部分，ECMAScript+BOM+DOM,HTMLDOM与XML的关系这些以前比较少了解的东西，还有原型链，作用域，实现继承等老生常谈的东西。感觉这本书还是要多刷几次，暑假回家配合《你不知道的JavaScript》二刷，去研究更细微的东西。</li>
</ol>
<h2 id="第一个开源项目：PageWindow"><a href="#第一个开源项目：PageWindow" class="headerlink" title="第一个开源项目：PageWindow"></a>第一个开源项目：PageWindow</h2><p>一直在学习，做工程项目，想想也该是时候做一点开源项目，让明年面试更有利一点~</p>
<p>这个项目使我一直想做的，其实很简单，就是实现页面上模拟windows窗口，好像目前是有这种东西，但我是想将其封装成一个UI库。进而实现伪多任务。</p>
<p>这里主要就是涉及DOM操作。包括鼠标操作比较多：</p>
<ol>
<li>mousedown</li>
<li>mouseup</li>
<li>mousemove</li>
<li>click</li>
</ol>
<p>第一个demo遇到就是阻止冒泡与阻止默认事件</p>
<h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><ol>
<li>e.stopPropagation() 标准W3C方法</li>
<li>e.cancelBubble = true  IE专用，但chrome，firefox也实现了属性</li>
</ol>
<h3 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h3><ol>
<li>e.preventDefault()  标准W3C</li>
<li>e.returnValue = false  IE专用，但chrome，firefox也实现了属性</li>
</ol>
]]></content>
      <categories>
        <category>pageWindow</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>pageWindow</tag>
      </tags>
  </entry>
  <entry>
    <title>全面理解JavaScript作用域与闭包</title>
    <url>/2021/01/31/%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="pre：块语句"><a href="#pre：块语句" class="headerlink" title="pre：块语句"></a>pre：块语句</h2><p><strong>块语句</strong>（或其他语言的<strong>复合语句</strong>）用于组合零个或多个语句。该块由一对大括号界定，可以是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label" target="_blank" rel="noopener"><code>labelled</code></a>：</p>
<p>块语句会生成一个块级作用域，生成块级作用域包含两种方法：</p>
<ol>
<li><p>使用任意声明符号（’’, <code>var</code>,<code>let</code>,<code>const</code>）在函数中会生成一个块级作用域。</p>
</li>
<li><p>使用<code>let</code>,<code>const</code>在任何块语句中生成一个块级作用域。</p>
<p>注意：<code>var</code>在非函数的块语句中<strong>不会</strong>生成一个块级作用域。</p>
</li>
</ol>
<p>介绍中都会使用<code>var</code>来进行举例，在变量声明中会对<code>let</code>和<code>const</code>进行说明。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>变量的简单说作用域就是在哪里可以访问到该变量。在JavaScript中，变量的作用域分为</p>
<ol>
<li>全局作用域。</li>
<li>局部作用域。</li>
</ol>
<p>这个全局与局部是相对的。因为在浏览器环境下，<code>window</code>对象被称为全局对象（在ES6中，顶层对象被规范为<code>globalThis</code>对象，在node中会指向<code>global</code>对象。）。而相对的，函数中的变量被称为局部变量。特点如下：</p>
<ol>
<li>局部变量只能在该作用域和其子作用域中访问到。</li>
<li>全部变量可以在任作用域中访问到。</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> out = <span class="string">'out-msg'</span></span><br><span class="line"><span class="comment">//全局变量-作用域是全局作用域，可以在任何位置访问到</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">in</span> = <span class="string">'in-msg'</span></span><br><span class="line">    <span class="comment">//局部变量-作用域是局部作用域， </span></span><br><span class="line">    <span class="built_in">console</span>.log(out)	<span class="comment">//out-msg</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">in</span>)	<span class="comment">//in-msg</span></span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">in</span>)			<span class="comment">//VM229:1 Uncaught ReferenceError: out is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(out)			<span class="comment">//out-msg</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>由于上面提到，全局与局部是相对的。由于<code>window</code>是浏览器环境中的最基础的变量，所以他被称为全局变量。而函数中（局部作用域）链中的还可以再定义函数，而内部函数仍然可以访问到外部函数中定义的变量。这样多个函数嵌套就会形成一个<strong>作用域链</strong>。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'window'</span></span><br><span class="line"><span class="comment">//可以访问到a，访问不到v3,v4,v2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v1 = <span class="string">'v1'</span></span><br><span class="line">    <span class="comment">//可以访问到a,v1，访问不到v3,v4,v2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> v2 = <span class="string">'v2'</span></span><br><span class="line">        <span class="comment">//可以访问到a,v1,v2，访问不到v3,v4</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> v3 = <span class="string">'v3'</span></span><br><span class="line">            <span class="comment">//可以访问到a,v1,v2,v3，访问不到v4</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">func4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//可以访问到a,v1,v2,v3,v4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，这样由<code>window-fun1-&gt;fun2-&gt;fun3-&gt;func4</code>形成了一个作用域链。</p>
<p>tip：</p>
<ol>
<li>当要使用一个变量时，系统会按照作用域链的顺序向上依次查询。所以，变量名相同时，局部变量会优先被访问。</li>
<li>使用<code>var</code>定义变量时，局部作用域只会在函数内部产生，当使用<code>let,const</code>时，只要是花括号内部，都会产生一个作用域。</li>
</ol>
<h1 id="变量申明"><a href="#变量申明" class="headerlink" title="变量申明"></a>变量申明</h1><p>目前JavaScript中4中声明变量的方式：无声明标志，<code>var</code>,<code>let</code>,<code>const</code></p>
<h2 id="无声明标志"><a href="#无声明标志" class="headerlink" title="无声明标志"></a>无声明标志</h2><p>所谓不用声明标志，就是直接使用变量名进行声明，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样申明的变量有一些特点：</p>
<ol>
<li>无论在哪里申明（即使是在函数块中），其都是一个全局变量，即会被挂载在全局对象<code>window</code>上，即无声明标志<strong>无论如何都不会构成局部作用域</strong>。</li>
</ol>
<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><code>var</code>是ES6出现之前JavaScript中的声明标志之一（另外一个时<code>function</code>用来声明一个函数变量）。所以他也具有一些特征。</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><h4 id="变量的声明与赋值"><a href="#变量的声明与赋值" class="headerlink" title="变量的声明与赋值"></a>变量的声明与赋值</h4><p>在理解变量提升之前，我们要明白变量声明与变量赋值之间的关系。</p>
<ol>
<li><p>变量声明是指确定这个作用域中该变量的存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量赋值就是为已经声明的变量进行赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">v = <span class="string">'variable'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这两个操作可以一起进行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="string">'variable'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>由于变量声明（以及其他声明）总是在任意代码执行之前处理的</strong>，所以在代码中的任意位置声明变量总是等效于在代码开头声明。<strong>这意味着变量可以在声明之前使用</strong>，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。</p>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bla = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> bla;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以隐式地（implicitly）将以上代码理解为：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bla;</span><br><span class="line">bla = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>重要的是，提升将影响变量声明，而不会影响其值的初始化。当到达赋值语句时，该值将确实被分配：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">111</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// 111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is implicitly understood as:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// undefined</span></span><br><span class="line">  bar = <span class="number">111</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// 111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是：</p>
<p>变量提升是在对应作用域下进行的，内层的作用域变量不会提升到外部中，所以会产生下面的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ov = <span class="string">'out'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ov)</span><br><span class="line">    <span class="keyword">var</span> ov = <span class="string">'in'</span></span><br><span class="line">&#125;</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>问结果是什么。</p>
<p>答：由于变量提升的按照作用域进行的，所以虽然这里外部声明了一个<code>ov</code>，但是在函数<code>func</code>内部也声明了一个<code>ov</code>变量，且在这个函数赋值之前就使用了，所以这里实际上等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ov = <span class="string">'out'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ov</span><br><span class="line">    <span class="built_in">console</span>.log(ov)</span><br><span class="line">    ov = <span class="string">'in'</span></span><br><span class="line">&#125;</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>而单独的变量声明不赋值，在JavaScript中其默认值为<code>undefined</code>，所以这里打印出来的是<code>undefined</code></p>
<p>值得注意的是：</p>
<p>只要是在变量还没有赋值之前进行操作，其值都是<code>undefined</code>。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = y, y = <span class="string">'A'</span></span><br><span class="line"><span class="built_in">console</span>.log(x + y)			<span class="comment">//undefinedA</span></span><br></pre></td></tr></table></figure>
<p>由于<code>x = y</code>时进行时，A还没有被赋值。但是由于变量提升，y是存在的，且其值为<code>undefined</code>，根据<code>JavaScript</code>的<code>primitive</code>算法，得<code>x + y</code>结果为<code>undefinedA</code>。</p>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><code>let</code>声明符号是ES6引入的新的声明符号，为了解决<code>var</code>的一些问题。其有一下特点：</p>
<ol>
<li>其在块语句中声明就会生成一个块级作用域（只要花括号存在）。</li>
<li>同一个变量名，只能被声明一次。</li>
<li>不会存在变量提升，取而代之的是<strong>暂时性死区</strong>。</li>
</ol>
<p>下面依次解释：</p>
<h3 id="其在块语句中声明就会生成一个块级作用域（只要花括号存在）。"><a href="#其在块语句中声明就会生成一个块级作用域（只要花括号存在）。" class="headerlink" title="其在块语句中声明就会生成一个块级作用域（只要花括号存在）。"></a>其在块语句中声明就会生成一个块级作用域（只要花括号存在）。</h3><p>以前JavaScript中只有全局作用域和函数作用域。而ES6引入的<code>let</code>与<code>const</code>相当于为<code>JavaScript</code>引入了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。</p>
<h3 id="同一个变量名，只能被声明一次。"><a href="#同一个变量名，只能被声明一次。" class="headerlink" title="同一个变量名，只能被声明一次。"></a>同一个变量名，只能被声明一次。</h3><p>使用<code>var</code>时，同一个变量名，可以被多次声明。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span></span><br><span class="line"><span class="comment">//不会报错</span></span><br></pre></td></tr></table></figure>
<p>但是使用<code>let</code>时，不允许重复声明同一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'abc'</span></span><br><span class="line"><span class="comment">//VM971:2 Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure>
<h3 id="不会存在变量提升，取而代之的是暂时性死区。"><a href="#不会存在变量提升，取而代之的是暂时性死区。" class="headerlink" title="不会存在变量提升，取而代之的是暂时性死区。"></a>不会存在变量提升，取而代之的是<strong>暂时性死区</strong>。</h3><p>上面提到，使用<code>var</code>声明变量时，会存在变量提升的现象。即相当于所有的变量，无论何处声明，其都被在最顶部声明，且默认赋值为<code>undefined</code>，然后在运行到声明处，在会被赋值为对应的值。所以在声明之前使用该变量，其结果都是<code>undefined</code>。</p>
<p>而使用<code>let</code>声明时，在声明之前，是无法使用的。从程序开始之前，到声明之间，被称为<strong>暂时性死区</strong>。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)			Uncaught <span class="built_in">ReferenceError</span>: b is not defined</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<h4 id="立即执行函数（IIFE）"><a href="#立即执行函数（IIFE）" class="headerlink" title="立即执行函数（IIFE）"></a>立即执行函数（IIFE）</h4><p>定义一个函数后将其立即执行的形式，形如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'100'</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数会立即执行，并输出100</span></span><br></pre></td></tr></table></figure>
<p>其具有以下特点：</p>
<ol>
<li><p>函数会立即执行</p>
</li>
<li><p>每执行一次，就会创建一个块级作用域，可以解决典型的异步问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>众所周知，这里的结果是：<code>555~</code>，其原因就是：</p>
<ol>
<li><code>setTimeout</code>是一个异步函数，当其回调函数执行的时候，<code>for</code>循环，已经完成了。所以后面打印出来的都是4。</li>
<li>用<code>var</code>时，不存在块级作用域，所以一个for循环中，使用的都是同一个i，导致前面的i会被后面的i所覆盖。</li>
</ol>
<p>所以前面提到<code>IIFE</code>每执行一次都会创建一个快进作用域，所以可以这么解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样其结果就是：1234</p>
</li>
</ol>
<p>但是当ES6的let出现之后，我们不再需要立即执行函数了来创建块级作用域了。直接使用<code>let</code>进行变量声明即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其结果也是：1234</p>
<p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><code>const</code>也是ES6引入的声明符号。其基本与<code>let</code>一致：</p>
<ol>
<li><p>每使用一次都会创建一个块级作用域。</p>
</li>
<li><p>同一个变量名，只能被声明一次。</p>
<p>并且，其还有一下特征：</p>
</li>
</ol>
<ul>
<li><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
</li>
<li><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>值得注意的是：变量不可以被更改，但是其属性是可以被更改的。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj = &#123;&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">3</span>   </span><br><span class="line"><span class="comment">//成功</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    a: 3,</span></span><br><span class="line"><span class="string">    b: 2</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>基于最开始JavaScript设计的初衷，JavaScript的内存管理都是自动执行的，而且是不可见的。程序员基本上不需要自动管理内存。</p>
<h2 id="V8内存模型"><a href="#V8内存模型" class="headerlink" title="V8内存模型"></a>V8内存模型</h2><p>要想更好的理解JavaScript的内存回收机制，要先简单理解一下JavaScript的内存模型（这里以V8为例）</p>
<p>首先JavaScript的变量分为两大类：</p>
<ol>
<li>基本变量<ol>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>String</code></li>
<li><code>Symbol</code></li>
<li><code>BigInt</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ol>
</li>
<li>引用变量：<code>Object，Array，Date，RegExp</code></li>
</ol>
<p>然后看一下V8的内存模型：</p>
<p><img src="D:\myblog\myblog\source\images\V8内存模型.png" alt=""></p>
<h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>栈区用于存储变量的<strong>名称以及内存中的地址</strong>。该地址又指向堆区、常量区或函数定义区。</p>
<p>例如：</p>
<p>在我们定义一个变量时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'string'</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>a为基本类型，所以他的值存储在池（常量区），所以：</p>
<ol>
<li>在栈区建立一个单元：|变量名|内存地址|（如<code>|a|0x1245a|</code>）</li>
<li>在池（常量区）的<code>0x1245a</code>存储’string’</li>
</ol>
<p>b为引用类型，其值存储在堆区，所以：</p>
<ol>
<li>在栈区建立一个单元：|变量名|内存地址|（如<code>|b|0x1245b|</code>）</li>
<li>在堆的<code>0x1245b</code>的位置存储<code>{}</code></li>
</ol>
<p><strong>值得注意的是：</strong></p>
<p>变量未被初始化或者被赋值为<code>undefined</code>时，栈区的地址部分被置空。表示没有任何意义。</p>
<h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>用于存放引用类型的值，如上面的b，其具体的值就存储在堆区。</p>
<p><strong>值得注意的是：</strong></p>
<p>在堆区，预存着一个特殊对象<code>null</code>，其地址固定，所有的值为null的变量都指向这一块内存。</p>
<p>所以，需要手动释放一个变量时，只需要将该变量赋值为<code>null</code>，则此时其指向<code>null</code>，原来的内存在无引用时会被GC（garbage recycle）机制回收。</p>
<h3 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h3><p>与堆区相对，其存储常量的值。如上面的a变量。</p>
<p>常量区具有以下特征：</p>
<ol>
<li>所有的值一旦写入无法改变。</li>
<li>所有相同的常量值在常量区都是惟一的。</li>
</ol>
<p>注意：常量区的值与常量是不同的。常量区的值不可改变是指对应地址的内存内容是无法改变的。而当我们在改变常量时，实际上大概是这么个流程：</p>
<ol>
<li>先检索常量区是否存在新的变量值。</li>
<li>如果存在，则直接将栈区的地址改为该常量的地址；若不存在，则在常量区新开辟一个地区，将新的变量存储到该地址，再将该常量的地址改为新的内存地址。</li>
</ol>
<h3 id="函数定义区"><a href="#函数定义区" class="headerlink" title="函数定义区"></a>函数定义区</h3><p>函数定义区用于存放被定义的函数代码段。</p>
<p>值得注意的是：函数的声明有两种：</p>
<ol>
<li><p>函数声明，形如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种定义的方式不会再栈区生成相应的函数名，因为此时其不是一个变量。引擎会直接在函数定义区定义这个函数，我们在调用这个函数的时候，引擎会去函数定义区搜索这个函数名进行调用。</p>
</li>
<li><p>函数引用，形如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式会在栈区生成一个变量来保存这个函数的地址。函数代码段仍然保存在函数定义区。</p>
<p>两种定义方式在调用的时候会表现出一些不同。</p>
<ol>
<li>对于第一种方式，V8引擎会在预扫描阶段进行函数提升，也就是说，你可以在函数定义之前调用该函数；</li>
<li>对于第二种方式，尽管引擎也会进行变量提升（因为其本身就是一个变量），但是并不会在提升的时候对变量赋值，因此不可以在定义之前调用该函数。</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以正常调用，因为引擎会提前扫描代码，将该函数存储到函数定义区</span></span><br><span class="line">f();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错，因为虽然g也进行了变量提升，但此时g的值是undefined，不能调用</span></span><br><span class="line">g();</span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>另外，如果函数名发生了重名，浏览器会以通过栈区变量引用的函数优先。如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//会调用第一个函数</span></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>之所以出现这种情况，是因为JavaScript引擎总是优先搜索栈区，所以上面的函数会优先被调用。但是如果调用发生在函数定义之前，那么就会调用通过函数声明定义的函数，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//会调用下面的以函数声明定义的函数</span></span><br><span class="line">f();</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//这个函数被调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>究其原因，还是在调用函数时变量f的值为undefined，因此引擎才会去函数定义区搜索函数f。总的来说，引擎在调用函数时会以栈区的变量优先，如果搜索不到或为undefined，则会去函数定义区搜索。</p>
<p>但是两者实际上并不冲突，我们同样可以用一个变量来指向一个声明式函数，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> g = f;</span><br></pre></td></tr></table></figure>
<p>现在变量g也拿到了函数f的内存地址，使用g同样可以访问该函数。</p>
<h3 id="函数缓冲区"><a href="#函数缓冲区" class="headerlink" title="函数缓冲区"></a>函数缓冲区</h3><p>函数缓冲区用于存放函数运行时动态申请的空间。函数运行时引擎会为其分配一片空间。当函数运行结束后，会回收其空间。只有当闭包产生的时候才会保留函数缓冲区中的数据。            </p>
<h2 id="垃圾回收机制-1"><a href="#垃圾回收机制-1" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>JavaScript 中内存管理的主要概念是<strong>可达性（Reachability）</strong>。简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。</p>
<p>从上面的内存分配可以看出，每一个变量都会在栈区存储其名字和地址，地址又指向堆区或池。所以JavaScript的GC机制就是当不存在一个变量指向一个内存地址，则引擎认定该内存可以被回收。</p>
<p>这其中有一部分变量是一定可达的，被称为<strong>根（root）</strong>，如：</p>
<ul>
<li>全局对象</li>
<li>正被调用的函数的局部变量和参数</li>
<li>相关嵌套函数里的变量和参数</li>
<li>其他（引擎内部调用的一些变量）</li>
</ul>
<p>这些根上面挂载的变量则也一定可达。</p>
<p>具体比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> cont = <span class="number">11</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'str'</span></span><br><span class="line"><span class="keyword">let</span> cs = <span class="string">'cs'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    cont,</span><br><span class="line">    cs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时内存分配结构为：</p>
<p><img src="\images\全面理解JavaScript作用域与闭包\V8-2.png" alt="V8-流程"></p>
<p>即池和堆中的每个被分配的内存块都可以通过栈区的变量访问到。所以他们都是可达的，故不会被GC回收。</p>
<p>但是当我们将某一个变量赋为<code>null</code>时候，原来堆池中的值就变成不可达，GC就会进行回收。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> cont = <span class="number">11</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'str'</span></span><br><span class="line"><span class="keyword">let</span> cs = <span class="string">'cs'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    cont,</span><br><span class="line">    cs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num = <span class="literal">null</span></span><br><span class="line">cont = <span class="literal">null</span></span><br><span class="line">str = <span class="literal">null</span></span><br><span class="line">cs = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>这个时候把所有的基础变量都置为<code>null</code>，则本来按照回收机制，其所有的基础变量都会被GC回收，但是由于<code>obj</code>中引用了<code>cont</code>,<code>cs</code>，所以虽然这两个变量被置为<code>null</code>了，但是内存中实际的值并没有被回收。此时其内存状况如下</p>
<p><img src="\images\全面理解JavaScript作用域与闭包\V8-3.png" alt="V8-3"></p>
<p>可以看到由于可以从<code>obj</code>访问到<code>cs</code>,<code>11</code>，所以他们不会被回收。</p>
<h3 id="回收算法（精简版）"><a href="#回收算法（精简版）" class="headerlink" title="回收算法（精简版）"></a>回收算法（精简版）</h3><p>基本的垃圾回收算法称为<strong>“标记-清除”</strong>，<strong>定期</strong>执行以下“垃圾回收”步骤:</p>
<ol>
<li><p>垃圾回收器获取根并<strong>“标记”</strong>(记住)它们。</p>
</li>
<li><p>然后它访问并“标记”所有来自它们的引用。</p>
</li>
<li><p>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</p>
</li>
<li><p>以此类推，直到有未访问的引用(可以从根访问)为止。</p>
</li>
<li><p>除标记的对象外，所有对象都被删除。</p>
</li>
</ol>
<p>下面是一个简单的过程（via<a href="https://segmentfault.com/a/1190000018605776" target="_blank" rel="noopener">前端面试：谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776)</a>）：</p>
<p><img src="\images\全面理解JavaScript作用域与闭包\GCprocess1.webp" alt="GCprocess1"></p>
<p><img src="\images\全面理解JavaScript作用域与闭包\GCprocess2.webp" alt="GCprocess2"></p>
<p><img src="\images\全面理解JavaScript作用域与闭包\GCprocess3.webp" alt="GCprocess3"></p>
<p>可以看出，这实际上是一个<a href="https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fromtitle=%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86&amp;fromid=23665934&amp;fr=aladdin" target="_blank" rel="noopener">广度遍历</a>的过程，对整个栈区的变量构成的图进行广度遍历，并对遍历到的内存坐下标记。当遍历完成时，内存中未被遍历到的内存则证明时不可达的，则GC则可以将其回收。</p>
<p><img src="\images\全面理解JavaScript作用域与闭包\GCprocess4.webp" alt="GCprocess4"></p>
<p>剩下的内存是不可达的，则会被回收。</p>
<p>上面就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。</p>
<p>一些优化:</p>
<ul>
<li><strong>分代回收</strong>——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。</li>
<li><strong>增量回收</strong>——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</li>
<li><strong>空闲时间收集</strong>——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。</li>
</ul>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>上面谈了这么多，都是为了更好的理解闭包。既然理解了内存模型和垃圾回收机制，再理解闭包就是如鱼得水了。</p>
<p>首先我们知道函数内的变量的生命周期只是该函数的运行过程。函数运行一旦结束，函数内的变量就会从<strong>函数缓冲区</strong>中删除掉。但是有的时候我们需要将函数中的变量永久（或长时间）保存下来，这个时候只需要在函数内部再新建一个函数，并且再内层函数中使用外层函数的变量。再将内层函数作为结果返回出来。由于此时外层函数中的变量由于被内层函数中使用，所以他们是<strong>可达的</strong>，则GC不会将其回收。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">in</span> = out()</span><br><span class="line"><span class="keyword">in</span>()			<span class="comment">//1</span></span><br><span class="line"><span class="keyword">in</span>()			<span class="comment">//2</span></span><br><span class="line"><span class="keyword">in</span>()			<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>这里就是一个典型的闭包。我们将使用外层函数的内部函数作为结果返回。我们调用该返回函数就可以操作到外层函数的变量。</p>
<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h3><p>编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。</p>
<p>而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p>
<p>下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 <a href="http://www.google.com/search?q=javascript+module+pattern" target="_blank" rel="noopener">模块模式（module pattern）：</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 1 */</span></span><br></pre></td></tr></table></figure>
<p>在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：<code>Counter.increment，`</code>Counter.decrement<code>和</code>Counter.value`。</p>
<p>该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 <code>privateCounter</code> 的变量和名为 <code>changeBy</code> 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。</p>
<p>这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 <code>privateCounter</code> 变量和 <code>changeBy</code> 函数。</p>
<p>你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量<code>Counter</code>。我们可以把这个函数储存在另外一个变量<code>makeCounter</code>中，并用他来创建多个计数器。</p>
<h3 id="使用闭包形成一个块级作用域，完成异步回调函数（这里使用let解决更好）"><a href="#使用闭包形成一个块级作用域，完成异步回调函数（这里使用let解决更好）" class="headerlink" title="使用闭包形成一个块级作用域，完成异步回调函数（这里使用let解决更好）"></a>使用闭包形成一个块级作用域，完成异步回调函数（这里使用let解决更好）</h3><p>就像上面的<code>IIFE</code>中，我们使用了闭包来形成一个块级作用域，来完成异步回调函数，不至于造成异步函数执行时循环以完毕。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(item.id) = <span class="string">`内容-<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">    &#125;)(item)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里就是利用闭包形成了一个块级作用域。使每一次循环都有一个作用域，使在异步回调执行的时候，其值是正确的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://segmentfault.com/a/1190000018605776" target="_blank" rel="noopener">前端面试：谈谈 JS 垃圾回收机制</a></li>
<li><a href="https://www.jianshu.com/p/c19038bab924" target="_blank" rel="noopener">Javascript垃圾回收机制</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener"><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/block" target="_blank" rel="noopener">block</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>作用域</tag>
        <tag>垃圾回收机制</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM1-2.1-自动内存管理-垃圾收集器与内存分配策略（垃圾收集算法和HostSpot算法细节）</title>
    <url>/2022/03/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM1-2.1-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8CHostSpot%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%EF%BC%89/</url>
    <content><![CDATA[<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="对象死亡判定"><a href="#对象死亡判定" class="headerlink" title="对象死亡判定"></a>对象死亡判定</h2><p>在堆里存放着几乎所有的Java对象，垃圾收集器在对堆进行回收的前，必须先对堆中的对象进行判定，哪些对象是活的，哪些对象是死的。</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数法是一种很经典的计数算法，即为每个对象添加一个引用计数器，当有一个地方引用它时，计数器的值就加一；当引用失效的时候，计数器的值就减一。任何时刻计数器为零的对象就是不可能再被使用的对象。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>原理简单。</li>
<li>判定效率高。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>单纯的引用技术很难解决循环引用的问题。即A-&gt;B，B-&gt;A。则A，B对象循环计数器都为1，但没有其他对象引用他们。则系统也无法对其进行回收。</li>
</ul>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>当前主流的商用程序语言（Java，C#等）的内存管理系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活。其算法的基本思路就是通过一系列的根对象，被称为<code>GC Roots</code>，作为起始节点集，然后从这些节点开始，根据对象引用关系向下搜索，搜索过程中走过的路径被称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达的时候，则证明这个对象是不可能再被使用的。</p>
<p>例如，下图中对象object5、object6、object7虽然互有相关联，但是他们到GC Roots是不可达的，因此他们将会被判定为可回收的对象。</p>
<p><img src="\images\深入理解JVM\可达性分析例.png" alt="可达性分析例"></p>
<p>在Java技术体系中，固定可作为FC Roots的对象包括以下几种：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量（String Table）引用的对象。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象，如（<code>NullPointException</code>、<code>OutOfMemoryError</code>等），还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反应虚拟机内部情况的<code>XMLBean</code>、<code>JVMTI</code>中注册回调、本地代码缓存等。</li>
</ul>
<p>除了这些固定的GC Roots集合以外，根据对象所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”的加入，共同构成完整GC Roots集合。</p>
<h3 id="引用的分类"><a href="#引用的分类" class="headerlink" title="引用的分类"></a>引用的分类</h3><p>在JDK1.2之前，Java里的引用都是很传统的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块的内存、某对象的引用。这种定义有时候不能满足一些特殊的对象，比如一些可有可无的对象，在内存空间足够的时候，保留其可能会增加好处，但是当内存不足的时候，将其丢弃也不会有太大影响的对象。</p>
<p>因此在JDK1.2之后，Java对应用进行了扩充，将引用分为强引用（<code>Strongly Reference</code>）、软引用（<code>Soft Reference</code>）、弱引用（<code>Weak Reference</code>）和虚引用（<code>Phantom Reference</code>）4种，这4种引用强度一次逐渐减弱。</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似<code>Object obj = new Object()</code>这种引用关系。无论在任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉引用的对象。</li>
<li>软引用是用来描述一些还有用，但非必须的对象。制备软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出溢出异常。在JDK1.2半之后提供了<code>SoftReference</code>类来实现软引用。</li>
<li>弱引用也是用来描述哪些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存道下一次来及收集发生为止。在垃圾收集器开始工作，无论当前内存是否足够，都会回收掉制备弱引用关联的对象。在JDK1.2版之后提供了<code>WeakReference</code>类来实现弱引用。</li>
<li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存实践构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后提供了<code>PhantomReference</code>类来实现虚引用。</li>
</ul>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a><code>finalize()</code>方法</h3><p>当一个对象在可达性分析算法中被判定为不可达对象，也不是一定就会被回收，要真正宣布一个对象死亡，至少需要经历两次标记过程：</p>
<ol>
<li>通过从GC Roots出发，发现该对象没有于其相连接的引用链，此时它会被第一次标记。随后会进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。假如对象没有覆盖<code>finalize()</code>方法，或者其<code>finalize()</code>方法已经被执行过了，那么虚拟机将这两种情况都被视为“没有必要执行”。如果这个对象被判定为有必要执行<code>finalize()</code>方法，那么该对象将会被放置在一个<code>F-Queue</code>队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的<code>Finalizer</code>线程区执行它们的<code>finalize()</code>方法。这里的执行并不会承诺其会执行结束，因为如果某一个<code>finalize()</code>方法执行很缓慢，或者陷入了死循环，将会导致<code>F-Queue</code>队列队中的其他对象永久处于等待、导致整个内存回收子系统的崩溃。</li>
<li><code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后收集器将会对<code>F-Queue</code>中的对象进行第二次小规模标记，如果对象要在<code>finalize()</code>对象中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可。比如将自己（<code>this</code>关键字）赋值给某个类或者对象的成员变量。那么在第二次标记时它将被移出“即将回收”的集合。如果对象这时候还没有逃脱，那么基本它就真的要被回收了。</li>
</ol>
<p><strong>值得注意的是：任何一个对象的<code>finalize()</code>方法都只会被系统自动调用一次，如果对象面临下一次回收，它的<code>finalize()</code>方法不会被再次执行。</strong></p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>对于方法区，《Java虚拟机规范》中提到可以不要求在虚拟机在方法区中实现垃圾回收，实际上也有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类型卸载）。方法区的垃圾回收条件比较苛刻，并且回收效率也比较低，所以其性价比比较低。</p>
<p>方法区的垃圾收集主要回收两部分内容：</p>
<ul>
<li>废弃的常量：如<code>&quot;java&quot;</code>曾经被一个变量引用，但现在已经不存在任何一个变量引用该字符串，那么其就应该被移除出常量池。</li>
<li>不再使用的类型</li>
</ul>
<p>而判断一个类是否需要回收就更加复杂了，一般需要同时满足下面3个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的来类加载器已经被回收了，整个条件除非是经过精心设计的可替代类加载器的场景，如<code>OSGi</code>，<code>JSP</code>等的重加载。否则通常很难达到。</li>
<li>该类对应的<code>java.lang.class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类。 </li>
</ul>
<p>Java虚拟机被允许对满足了上述3个条件的无用类进行回收，这里仅仅说的是“被允许”，而并不是和对象一样，没有引用了就必然会被回收。</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类卸载的能力，以保证不会堆方法区造成太大的内存压力。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾收集算法的实现设计大量的程序细节，且各个平台的虚拟机操作内存的方法都有差异，在本节中只介绍分代收集理论和几种算法思想及其法阵过程。从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（<code>Reference Counting GC</code>）和“追踪式垃圾收集”（<code>Tracaing GC</code>），这两类也经常被称为“直接垃圾收集”和“间接垃圾收集”。由于引用式垃圾收集算法在主流的Java虚拟机中均未涉及，所以这里介绍的所有算法均属于追踪式垃圾收集的范畴。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多都遵循了“分代收集”（Generation Collection）的理论进行设计，分代收集名为理论，实际上是一套符合大多数程序运行情况的经验法则，其建立在两个分代假说之上：</p>
<ol>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以灭亡。</li>
</ol>
<p>这两个假说奠定了多款常用垃圾收集器的一致设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象按照年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</p>
<p>在Java堆划分出不同区域之后，垃圾收集器才可以每次回收其中某一个特定的区域，因此产生了</p>
<ul>
<li>“Minor GC”，“Major GC”和“Full GC”这样回收类型的划分。</li>
<li>针对不同区域的的收集算法，比如“标记-复制算法”，“标记-清除算法”，“标记-整理算法”等。</li>
</ul>
<p>在一般的商用Java虚拟机中，设计者一般至少会把Java堆分为新生代（Young Generation）和老年代（Old Generation）两个区域。</p>
<p>还需要思考的一个问题，就是不同代际对象之间的引用问题，例如要对新生代区域进行收集（Minor GC），但新生代中的对象完全可能被老年代引用，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中的对象来确保可达性分析结果的正确性，反过来也一样。遍历整个老年代所有对象的方案理论上可行，但无疑会为内存回收带来很大的负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p>
<ol start="3">
<li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>这其实是可根据前两条假说逻辑推理得出的隐含推论：存在相互引用关系的两个对象应该更倾向于同时生存或者同时消亡。</p>
<p>名词解释：</p>
<ul>
<li>部分收集（Partial GC）：值目标不是完全收集整个Java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC/Young GC）：指目标指示新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集器。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</li>
</ul>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最早出现的也是最基础的垃圾收集算法即为“标记-清除（Mark-Sweep）算法”，其主要分为两部分：</p>
<ul>
<li>首先标记处所有需要回收的对象。</li>
<li>在标记完成后，统一回收掉所有被标记的对象。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>标记-清除算法是最基础的算法，因为其后续的算法大多都是以标记-清除算法为基础，对其缺点改进而得。其主要有以下两个缺点：</p>
<ul>
<li>执行效率不稳定，如果Java堆包含大量标记对象，而其中大部分是需要被回收的，这是必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随着对象数量增长而降低。</li>
<li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后再程序运行过程中需要分配较打对象时产生不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p>其原理如图：</p>
<p><img src="\images\深入理解JVM\标记-清除算法.png" alt="标记-清除算法"></p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>标记-复制算法常被称简称为复制算法，其是为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。最原始的思路主要为：将可用内存划分为容量大小相等的两部分，每次只是用其中一块。其中一块使用完后，就将其该块中存活的对象复制到另外一块中去，然后再把已使用的内存空间一次性清除掉。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>在多数对象都是可回收时，需要复制的对象很少，效率高。</li>
<li>每次复制时，都是针对整个半区，进而可以避免内存碎片化的问题。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>在只有少数对象是可回收时，需要复制大量的对象，此时就会产生大量的内存复制开销。</li>
<li>将可用内存缩小为原来的一般，空间浪费有点多。</li>
</ul>
<p>其原理如图：</p>
<p><img src="\images\深入理解JVM\标记-复制算法.png" alt="标记-复制算法"></p>
<p>后期IBM公司一项研究证明-新生代对象有98%熬不过第一轮收集。因此不必要按照1：1的比例来划分新生代的内存空间。</p>
<p>1989年Andrew Appel又提出了新的划分思路：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只是用Eden和其中一块Survivor空间。发生垃圾收集时，将Eden和该Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已经使用过的那块Survivor。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。当然不可能确保每次以使用的内存都小于一块Survivor空间的大小。所以Appel式回收还有一个充当罕见情况的“逃生门”的安全设计：当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>由于老年代中的对象普遍存活率较高，所以标记-复制算法不再适用。</p>
<p>所以针对老年代对象的死亡特征，1974年Edward Lueders提出了另外一种针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程依然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清除，而是让所有存活的对象都向内存空间的一端移动，然后直接清理边界意外的内存，其主要思路如图：</p>
<p><img src="\images\深入理解JVM\标记-整理.png" alt="标记-整理"></p>
<p>该算法也存在缺点：即移动对象的收，必须暂停用户进程。（又被称为Stop the World）。</p>
<h2 id="HotSpot虚拟机的算法细节实现"><a href="#HotSpot虚拟机的算法细节实现" class="headerlink" title="HotSpot虚拟机的算法细节实现"></a>HotSpot虚拟机的算法细节实现</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>由之前的介绍可知，GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（如栈帧中本地变量表），虽然明确，但是随着应用体积的正大，这也是一项很大的工作。</p>
<p>且迄今为止，所有的垃圾收集器在根节点枚举这一步骤中，都是必须暂停用户线程的。</p>
<p>当前主流的Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停下来后，起始并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机会从某个位置直接获得相应的信息。在HotSpot虚拟机的解决方案中，是使用一组称为OopMap的数据结构来达到整个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定位置记录下栈里和寄存器里哪些位置是引用。这样收集器就可以直接得知这些信息了，而不需要真正的从GC Roots开始遍历。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>为了节省空间，HotSpot并没有为所有的指令都生成OopMap。只是在特定的位置记录这些信息，这些位置被称为安全点（SafePoint）。即只有当用户程序执行到安全点才能停顿，而不是在任意位置停下来都会开始垃圾收集。因此安全的选定既不能太少一直收集器等待时间太长，也不能太多以至于过分增加垃圾收集带来的性能损失。</p>
<p>所以安全点的选取基本上是以“是否具有让程序长时间执行的特征”为标准来选定的。长时间执行的最明显特征就是指令序列的复用，例如方法的调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
<p>对于安全点，还有一个需要思考的问题是，如何在垃圾收集发生时让所有线程都跑到最近的安全点，然后停顿下来。其主要有两种方案：</p>
<ul>
<li>抢先式中断（Preemptive Suspension）：不需要线程的执行代码主动配合，在垃圾收集发生时，系统首先把所有的用户现场全部中断，如果发现有用户线程中断的位置不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程相应GC事件。</li>
<li>主动式中断（Voluntary Suspension）：当垃圾收集需要中断的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动轮询这个标志，一旦发现中断标志为真时就自己在最近地安全点上主动终端挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要套在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够的内存分配新对象。</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点机制在保证了程序在执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序在不执行时，比如Sleep或者Blocked状态。此时就无法走到安全点去中断挂起自己。此时就引入了安全区域（Safe Region）来解决。</p>
<p>安全区域是指能够确保在某一段代码片段中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。可以将其看作是扩展拉伸了的安全点。</p>
<p>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点的枚举，如果完成了，那么线程就会离开安全区域，继续执行。否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<h3 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h3><p>为了解决对象跨代引用带来的问题，垃圾收集器在新生代建立了名为记忆集（Remember Set）的数据结构，用来避免把整个老年代加入Roots GC扫描范围。事实上不仅是新生代、老年代之间会存在跨代引用的问题，所有的部分区域收集（Partial GC）行为的垃圾收集器都会存在跨代引用的问题。</p>
<p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
<p>在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。那么设计者在实现记忆集的时候，便可以选择更加粗犷的记录颗粒来节省记忆集的存储和维护成本，下面列举了一些可供选择的记录精度：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长，该字节包含跨代指针。</li>
<li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有独享含有跨代指针。</li>
</ul>
<p>其中第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记录集，这也是目前最常用的一种记忆集实现形式。</p>
<p>但其与记忆集是完全不同的概念。记忆集是一个抽象的数据结构，即之定义了行为意图，并没有定义其具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。</p>
<p>卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这么做的。</p>
<p>字节数组<code>CARD_TABLE</code>中的每个元素都对应整个表示的内存区域中一块特定大小的内存块，这个内存块被称为“卡页”（Card Page）。</p>
<p>一个卡页的内存通常包含不止一个对象，只要卡页内有一个（或多个）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标记为1，称这个元素变脏（Dirty），没有则为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>前面已经解决了如何使用记忆集来所见GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。</p>
<p>针对第一个问题，答案是很明显的-有其他分代区域中对象引用本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。</p>
<p>对于第二个问题，由于虚拟机负责每条字节码的执行，可以由其进行处理。但在编译执行的场景中，就必须找到一个在机器码层面，把维护卡表的动作放到每一个赋值操作之中。</p>
<p>在HotSpot虚拟机中是通过写屏障（Write Barrier）技术维护卡表状态的。写屏障可以看作是虚拟机层面对“引用类型字段赋值”这个动作的AOP切面。在引用对象赋值时会产生一个环行（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫做写前屏障（pre-Write Barrier），在赋值后的则叫做写后屏障（Post-Write Barrier）。</p>
<p>例如下面的一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> oop_field <span class="title">store</span> <span class="params">(oop* field,oop new_value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用字段赋值操作</span></span><br><span class="line">    *field = new_value;</span><br><span class="line">    <span class="comment">//写后屏障，在这里完成卡表状态更新</span></span><br><span class="line">    post_write_barrier (field,new_value) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新 卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</p>
<p>除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。</p>
<h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析， 这意味着必须全程冻结用户线程的运行。</p>
<p>对于GC Roots的遍历，由于其很少，而且通过OopMap等优化技术，停顿时间已经非常短了。但是对于堆的遍历，由于堆的大小就和停顿时间成正比了。堆越大，停顿时间就越长了。</p>
<p>想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进 行对象图的遍历？为了能解释清楚这个问题，我们引入三色标记（Tri-color Marking）[1]作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。 </li>
<li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代<br>表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对 象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li>
</ul>
<p>收集器在对象图上标记颜色，同时用户线程在修改引用 关系——即修改对象图的结构，这样可能出现两种后果。一种是把原本消亡的对象错误标记为存活， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理 掉就好。另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误，下面表演示了这样的致命错误具体是如何产生的。</p>
<p><img src="\images\深入理解JVM\并发出现“对象消失”问题.png" alt="并发出现“对象消失”问题"></p>
<p>Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问 题，即原本应该是黑色的对象被误标为白色：</p>
<ul>
<li><p><strong>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</strong></p>
</li>
<li><p><strong>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</strong></p>
</li>
</ul>
<p>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别 产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。</p>
<p><strong>增量更新：</strong>要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新 插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫 描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象<br>了。</p>
<p><strong>原始快照：</strong>要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删 除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来<br>进行搜索。</p>
<p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集器与内存分配策略</tag>
        <tag>垃圾收集算法和HostSpot算法细节</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro、spring和JWT的集成</title>
    <url>/2022/03/25/shiro%E4%B8%8Espring%E7%9A%84%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h1><h2 id="1-配置web-xml"><a href="#1-配置web-xml" class="headerlink" title="1. 配置web.xml"></a>1. 配置web.xml</h2><ol>
<li><p>配置<code>springShiro.xml</code>文件读取</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml classpath:springShiro.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以和<code>applicationContext.xml</code>一起写。</p>
</li>
<li><p>配置过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这里filter的名字必须为：<code>shiroFilter</code>。因为Shiro内部是直接读取名字的。</p>
<h2 id="配置springShiro-xml"><a href="#配置springShiro-xml" class="headerlink" title="配置springShiro.xml"></a>配置springShiro.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- proxy-target-class="true"强制使用CGLib代理，为false则spring会自动选择，否则事务不生效 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置relam --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tidyRealm"</span> <span class="attr">class</span>=<span class="string">"priv.mw.shiro.TidyRealm"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置权限管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realms"</span> <span class="attr">ref</span>=<span class="string">"tidyRealm"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.cache.MemoryConstrainedCacheManager"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tidyFilter"</span> <span class="attr">class</span>=<span class="string">"priv.mw.filter.JWTFilter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置shiro的过滤器工厂类，id- shiroFilter要和我们在web.xml中配置的过滤器一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 调用我们配置的权限管理器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"tidyFilter"</span> <span class="attr">value-ref</span>=<span class="string">"tidyFilter"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                /login/**=anon</span><br><span class="line">                /register/**=anon</span><br><span class="line">                /**=tidyFilter</span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置shiro bean生命周期管理类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中最主要的是filter的配置，因为这里结合的是JWT，并不是基于session，所以并不需要shiro来帮助我们保存用户信息。</p>
<p>然后就是<code>ShiroFilterFactoryBean</code>的配置。</p>
<p>其中会配置<code>securityManager</code>和<code>filters</code>，其中<code>filterChainDefinitions</code>是用来进行url权限地址认证：</p>
<p>其中有几个点：</p>
<ul>
<li>url中的<code>*</code>表示任意一级url匹配。比如：<code>/url/*</code>可以匹配<code>/url/a</code>或者<code>/url/aaa</code>，但不能匹配<code>/url/a/aa</code>因为产生2级目录了。</li>
<li>url中的<code>**</code>表示任意多级的url匹配。比如<code>/url/**</code>既可以匹配<code>/url/a</code>又可以匹配<code>/url/a/aa</code></li>
<li><code>=</code>后是需要的权限，可以是shiro定义的Filter，也可以是我们自己定义的Filter。其内置的有filter，并且有简写<ul>
<li>anon—————org.apache.shiro.web.filter.authc.AnonymousFilter</li>
<li>authc————–org.apache.shiro.web.filter.authc.FormAuthenticationFilter</li>
<li>authcBasic———org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</li>
<li>logout————-org.apache.shiro.web.filter.authc.LogoutFilter</li>
<li>noSessionCreation–org.apache.shiro.web.filter.session.NoSessionCreationFilter</li>
<li>perms————–org.apache.shiro.web.filter.authz.PermissionAuthorizationFilter</li>
<li>port—————org.apache.shiro.web.filter.authz.PortFilter</li>
<li>rest—————org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</li>
<li>roles————–org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</li>
<li>ssl—————-org.apache.shiro.web.filter.authz.SslFilter</li>
<li>user—————org.apache.shiro.web.filter.authz.UserFilter</li>
</ul>
</li>
</ul>
<p>这里还没有做授权，所以Realm并没有贴出来，本来应该是从token中拿出id，然后去查询数据库，看权限是否合法。</p>
<p>可以在<code>FormAuthenticationFilter</code>中通过<code>getSubject(servletRequest, servletResponse)</code>获取subject来进行登录。</p>
</li>
</ol>
<h2 id="tidyFilter"><a href="#tidyFilter" class="headerlink" title="tidyFilter"></a>tidyFilter</h2><p>   下面是<code>tidyFilter</code>的代码：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTFilter</span> <span class="keyword">extends</span> <span class="title">FormAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        String rawToken = req.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"text/json;charset=utf-8"</span>);</span><br><span class="line">        <span class="keyword">if</span>(rawToken == <span class="keyword">null</span> || <span class="string">""</span>.equals(rawToken))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.getWriter().println(mapper.writeValueAsString(Result.data(<span class="string">""</span>).msg(<span class="string">"未认证，请先认证！"</span>).code(<span class="number">401</span>)));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            String token = rawToken.substring(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">boolean</span> tokenValid = JWTUtils.checkToken(token);</span><br><span class="line">            <span class="keyword">if</span>(!tokenValid)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    response.getWriter().println(mapper.writeValueAsString(Result.data(<span class="string">""</span>).msg(<span class="string">"认证已过期，请重新登录！"</span>).code(<span class="number">401</span>)));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        String token = req.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"text/json;charset=utf-8"</span>);</span><br><span class="line">        <span class="keyword">if</span>(token == <span class="keyword">null</span> || <span class="string">""</span>.equals(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> tokenValid = JWTUtils.checkToken(token);</span><br><span class="line">            <span class="keyword">if</span>(!tokenValid)&#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.executeLogin(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   这个类就是用来验证header中携带的token信息，由于其是无状态的。所以直接通过工具类验证就行了。</p>
<p>   这个类继承了<code>FormAuthenticationFilter</code>，其两个方法：</p>
<ul>
<li><code>isAccessAllowed</code>：判断这个请求是否允许。</li>
<li><code>onAccessDenied</code>：如果不允许，则引导用户进行认证。（此处是直接返回false，并返回未认证的JSON）</li>
</ul>
<p>下面是一个简单的JWTUtils，有待加强：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String key = <span class="string">"secret"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> aliveDay = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkToken</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            JWT.decode(token).getPayload();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateToken</span><span class="params">(HashMap&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        localDate.plusDays(aliveDay);</span><br><span class="line"></span><br><span class="line">        Algorithm algorithm = Algorithm.HMAC256(key);</span><br><span class="line">        String token = JWT.create()</span><br><span class="line">                .withPayload(map)</span><br><span class="line">                .withJWTId(UUID.randomUUID().toString())</span><br><span class="line">                .withExpiresAt(Date.from(localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant()))</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseTokenToName</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(checkToken(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> JWT.decode(token).getClaim(<span class="string">"name"</span>).asString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">parseTokenToId</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(checkToken(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> JWT.decode(token).getClaim(<span class="string">"id"</span>).asInt();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="class配置（待完成）"><a href="#class配置（待完成）" class="headerlink" title="class配置（待完成）"></a>class配置（待完成）</h1>]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Shiro</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>idea注释模板配置</title>
    <url>/2022/05/24/idea%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="类头注释"><a href="#类头注释" class="headerlink" title="类头注释"></a>类头注释</h1><p>settings-&gt;File and Code Templates-&gt;class</p>
<p>然后在上面填上想要的内容，一个模板如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: MichaelWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: $&#123;DATE&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;NAME&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>其中内置变量如下：</p>
<ul>
<li>$[PACKAGE_NAME] name of the package in which the new file is created$[USER} current user system login name</li>
<li>$[DATE] current system date</li>
<li>${TIME] current system time$[YEAR] current year</li>
<li>${MONTH] current month</li>
<li>${MONTH_NAME_SHORT} first 3 letters of the current month name.Example: Jan, Feb,etc.${MONTH_NAME_FULL} full name of the current month.</li>
<li>${HOUR] current hour</li>
<li>${MINUTE] current minute</li>
<li>$[PROJECT_NAME] the name of the current project</li>
</ul>
<p><img src="/images/idea注释模板配置/类头注释.jpg" alt="类头注释"></p>
<h1 id="函数头注释"><a href="#函数头注释" class="headerlink" title="函数头注释"></a>函数头注释</h1><p>函数头的注释就比文件头要复杂一点了。其菜单为：</p>
<p>settings-&gt;Live Templates-&gt;+-&gt;Template Group</p>
<p>用来新建一个组，接下里在这个组上再点+号用来新建一个Live Template。</p>
<p><img src="/images/idea注释模板配置/函数头注释1.jpg" alt="函数头注释1"></p>
<p>接下来就输入对应的内容，这里需要注意的是，必须按照1,2,3的顺序来（至少2,3不能改变，否则就读取不到函数的参数类型和名称）</p>
<p><img src="/images/idea注释模板配置/函数头注释2.jpg" alt="函数头注释2"></p>
<p>文件类型一般就选择所有Java，当然也可以自定义：</p>
<p><img src="/images/idea注释模板配置/函数头注释3.jpg" alt="函数头注释3"></p>
<p>而环境变量的填写也比较简单，都是选择。</p>
<p><img src="/images/idea注释模板配置/函数头注释4.jpg" alt="函数头注释4"></p>
<p>比如这里date就直接选date()函数即可。</p>
<p>但是如果我们需要javaDoc形式的参数注释，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MichaelWang </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>  2022/6/5  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> para1: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> para2: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> para3:  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String para1, Integer para2, Boolean para3)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则必要要自定义，此时就需要GroovyScript来自己编写了。下面给出一个模板：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">groovyScript(<span class="string">"     def result='';     def params=\"$&#123;_1&#125;\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList();     for(i = 0; i &lt; params.size(); i++) &#123; 		if(i==0)result+= '* ';         if(i!=0)result+= ' * ';         result+='@Param ' + params[i] + ': ' + ((i &lt; (params.size() - 1)) ? '\\n' : '');     &#125;;     return result"</span>, methodParameters())</span><br></pre></td></tr></table></figure>
<p>不用格式化，直接写入<code>param</code>参数对应的<code>Expression</code>即可。</p>
<p><strong>最重要的一点是：这样定义的注释模板，必须要使用/*fcc的形式进行键入，才能获取方法的参数，直接通过其名字得到的注释模板是获取不到的。</strong></p>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM2-2-虚拟机执行子系统-虚拟机类加载机制</title>
    <url>/2022/04/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM2-2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最 终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<p>与那些在编译时需要进行连接的语言不同，<strong>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的</strong>，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销， 但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。</p>
<p>其中验证、准备、解析三个部分统称 为连接（Linking）。</p>
<p><img src="/images/深入理解JVM/类的生命周期.png" alt="类的生命周期"></p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。</p>
<p>类型的加载过程必须按 照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p>
<p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束。但是对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到<code>new、getstatic、putstatic或invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解 析结果为<code>REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语 ——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。例如：</p>
<ul>
<li>引用父类的静态字段，并不会使子类初始化。</li>
<li>使用数组定义来引用类，并不会使类初始化。</li>
<li>引用类的常量，并不会使类初始化。（因为常量在编译时就被存入常量池，本质上并没有引用到定义的类，所以也不会出发定义常量）</li>
<li>。。。</li>
</ul>
<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>注意“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，并不是同一个意思。在加载阶段，Java虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>《Java虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与Java应用的灵活度都是 相当大的。例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条规则，它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。因此衍生出很多获取方式：</p>
<ul>
<li>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是Web Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用 了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</li>
<li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择 把程序安装到数据库中来完成程序代码在集群间的分发。</li>
<li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文 件来保障程序运行逻辑不被窥探。</li>
</ul>
<p>相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进 制字节流的动作）是开发人员可控性最强的阶段。</p>
<p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也<strong>可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节 流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</strong></p>
<p>而数组类本身不通过类加载器创建，它是由Java虚拟机直接在 内存中动态构造出来的。</p>
<p>但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类 型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C 标记为与引导类加载器关联。</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的 可访问性将默认为public，可被所有的类和接口访问到。</li>
</ul>
<p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中 了，方法区中的数据存储格式完全由虚拟机实现自行定义。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p><strong>Java语言本身是相对安全的编程语言</strong>（起码对于C/C++来说是相对安全的），使用纯粹的Java代码 无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情。<strong>但Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出 Class文件在内的任何途径产生。</strong></p>
<p>验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节 码验证和符号引用验证。</p>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶 段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
<li>。。。</li>
</ul>
<p>实际上第一阶段的验证点还远不止这些，上面所列的只是从HotSpot虚拟机源码[1]中摘抄的一小 部分内容，该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</p>
<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>第二阶段是对字节码描述的信息进行<strong>语义分析</strong>，以保证其描述的信息符合《Java语言规范》的要 求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。</li>
<li>。。。</li>
</ul>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定<strong>程序语义</strong>是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要 对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全 的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
<li>。。。</li>
</ul>
<p>如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法 体通过了字节码验证，也仍然不能保证它一定就是安全的。</p>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p>本阶段通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当 前类访问。</li>
<li>。。。</li>
</ul>
<p>符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机 将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>的子类异常，典型的如：<br><code>java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError</code>等。</p>
<blockquote>
<p>如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都 已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。</p>
<p>注意准备阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那变量value在准备阶段过后的初始值为0而不是123，因为这时尚未开始执行任何Java方法，而把 value赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</p>
<p>下表列出了Java中所有基本数据类型的零值。</p>
<p><img src="/images/深入理解JVM/基本数据类型的零值.png" alt="基本数据类型的零值"></p>
<p>上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“特殊情况”：如果类字段的字段属性表中存在<code>ConstantValue</code>属性，那在准备阶段变量值就会被初始化为<code>ConstantValue</code>属性所指定的初始值，假设上面类变量value的定义修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>编译时Javac将会为value生成<code>ConstantValue</code>属性，在准备阶段虚拟机就会根据<code>ConstantValue</code>的设置 将value赋值为123。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。如<code>CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info</code>等类型的常量。</p>
<ul>
<li>符号引用（Symbolic References）：<strong>符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。</strong>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</li>
<li>直接引用（Direct References）：<strong>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。</strong>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7 类符号引用进行，分别对应于常量池的<code>CONSTANT_Class_info</code>、<code>CON-STANT_Fieldref_info</code>、 <code>CONSTANT_Methodref_info</code>、<code>CONSTANT_InterfaceMethodref_info</code>、 <code>CONSTANT_MethodType_info</code>、<code>CONSTANT_MethodHandle_info</code>、<code>CONSTANT_Dyna-mic_info</code>和<code>CONSTANT_InvokeDynamic_info</code> 8种常量类型。</p>
<p>下面讲解前4种引用的解析过程，对于后4 种，它们都和动态语言支持密切相关。</p>
<h3 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h3><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<ul>
<li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名<strong>传递给D的类加载器去加载这个类C</strong>。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类 似、<code>[Ljava/lang/Integer</code>的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所 假设的形式，需要加载的元素类型就是<code>java.lang.Integer</code>，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li>
<li>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了， 但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</li>
</ul>
<p>具体权限验证中，由于JDK9引入的模块化，则具有权限意味着以下3条规则中至少有其中一条成立：</p>
<ul>
<li>被访问类C是public的，并且与访问类D处于同一个模块。</li>
<li>被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的 模块进行访问。</li>
<li>被访问类C不是public的，但是它与访问类D处于同一个包中。</li>
</ul>
<h3 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h3><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完 成，那把这个字段所属的类或接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：</p>
<ul>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li>
</ul>
<p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权 限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p>
<h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><p>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index项中索引的方 法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p>
<ul>
<li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li>
<li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则 返回这个方法的直接引用，查找结束。</li>
<li>否则，在<strong>类C的父类中递归查找</strong>是否有简单名称和描述符都与目标相匹配的方法，如果有则返 回这个方法的直接引用，查找结束。</li>
<li>否则，在<strong>类C实现的接口列表及它们的父接口之中递归查找</strong>是否有简单名称和描述符都与目标 相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出<code>java.lang.AbstractMethodError</code>异常。</li>
<li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。</li>
</ul>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此 方法的访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p>
<h3 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h3><p>接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引 用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<ul>
<li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那 么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li>
<li>否则，在<strong>接口C中查找</strong>是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方 法的直接引用，查找结束。</li>
<li>否则，在<strong>接口C的父接口中递归查找</strong>，直到java.lang.Object类（接口方法的查找范围也会包括 Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>对于规则3，<strong>由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找</strong>，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li>
<li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类的初始化阶段是类加载过程的最后一个步骤。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p>
<p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通 过程序编码制定的主观计划去初始化类变量和其他资源。</p>
<p>我们也可以从另外一种更直接的形式来表 达：初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p>
<p>其特点如下：</p>
<ul>
<li><p><strong><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的</strong>，静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显 式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在Java虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是<code>java.lang.Object</code>。</p>
</li>
<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。例如，下面代码中字段B的值将会是2而不是1。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    System.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的 赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁同步，如果多个线程同 时去初始化一个类，那么只会有其中一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等 待，直到活动线程执行完毕<code>&lt;clinit&gt;()</code>方法。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p>
</li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节 流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于 任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
<p>即比<strong>较两个类是否“相 等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（<code>Bootstrap ClassLoader</code>），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有 的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</p>
<p>站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK 1.2以来，Java一直保持着<strong>三层类加载器</strong>、双亲委派的类加载架构，尽管这套架构在Java模块化系统出现后有了一些调整变动，但依然未改变其主体结构。</p>
<p>其结构如下图:</p>
<p><img src="/images/深入理解JVM/类加载器双亲委派模型.png" alt="类加载器双亲委派模型"></p>
<h3 id="启动类加载器（Bootstrap-Class-Loader）"><a href="#启动类加载器（Bootstrap-Class-Loader）" class="headerlink" title="启动类加载器（Bootstrap Class Loader）"></a>启动类加载器（Bootstrap Class Loader）</h3><p>这个类加载器负责加载存放在 &lt;JAVA_HOME&gt;\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（<strong>按照文件名识别</strong>，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类 库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</p>
<h3 id="·扩展类加载器（Extension-Class-Loader）"><a href="#·扩展类加载器（Extension-Class-Loader）" class="headerlink" title="·扩展类加载器（Extension Class Loader）"></a>·扩展类加载器（Extension Class Loader）</h3><p>这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code> 中以Java代码的形式实现的。它负责加载&lt;JAVA_HOME&gt;\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</p>
<p>JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK 9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</p>
<h3 id="应用程序类加载器（Application-Class-Loader）"><a href="#应用程序类加载器（Application-Class-Loader）" class="headerlink" title="应用程序类加载器（Application Class Loader）"></a>应用程序类加载器（Application Class Loader）</h3><p>这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。</p>
<p>JDK 9之前的Java应用都是由这三种类加载器互相配合来完成加载的，如果用户认为有必要，还可 以加入自定义的类加载器来进行拓展，典型的如增加除了磁盘位置之外的Class文件来源，或者通过类加载器实现类的隔离、重载等功能。</p>
<h3 id="双亲委派模型-1"><a href="#双亲委派模型-1" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="双亲委派模型的工作过程"><a href="#双亲委派模型的工作过程" class="headerlink" title="双亲委派模型的工作过程"></a>双亲委派模型的工作过程</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加 载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的 加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类 加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类 在程序的各种类加载器环境中都能够保证是同一个类。</p>
<p>反之，如果没有使用双亲委派模型，都由各个 类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应<br>用程序将会变得一片混乱。</p>
<h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><h3 id="第一次破坏"><a href="#第一次破坏" class="headerlink" title="第一次破坏"></a>第一次破坏</h3><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远 古”时代。由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的 protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。</p>
<p>双亲委派的具体逻辑就实现loadClass()方法里面， 按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h3 id="第二次破坏"><a href="#第二次破坏" class="headerlink" title="第二次破坏"></a>第二次破坏</h3><p>双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被 称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务， 它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型 了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码。</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方 法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<h3 id="第三次破坏"><a href="#第三次破坏" class="headerlink" title="第三次破坏"></a>第三次破坏</h3><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。</p>
<p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实 现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ul>
<li>将以java.*开头的类，委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器 加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ul>
<p>上面的查找顺序中只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加 载器中进行的。</p>
<h1 id="Java模块化系统"><a href="#Java模块化系统" class="headerlink" title="Java模块化系统"></a>Java模块化系统</h1><p>在JDK 9中引入的Java模块化系统（Java Platform Module System，JPMS）是对Java技术的一次重 要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。</p>
<h2 id="模块化的兼容性"><a href="#模块化的兼容性" class="headerlink" title="模块化的兼容性"></a>模块化的兼容性</h2><p>为了使可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK 9提出了与“类路 径”（ClassPath）相对应的“模块路径”（ModulePath）的概念。、</p>
<p>简单来说，就是某个类库到底是模块还是传统的JAR包，只取决于它存放在哪种路径上。只要是放在类路径上的JAR文件，无论其中是否包 含模块化信息（是否包含了module-info.class文件），它都会被当作传统的JAR包来对待；相应地，只 要放在模块路径上的JAR文件，即使没有使用JMOD后缀，甚至说其中并不包含module-info.class文<br>件，它也仍然会被当作一个模块来对待。</p>
<ul>
<li>JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在 一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li>
<li>模块在模块路径的访问规则：模块路径下的具名模块（Named Module）只能访问到它依赖定义 中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。</li>
<li>JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路 径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将 默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li>
</ul>
<h2 id="模块化下的类加载器"><a href="#模块化下的类加载器" class="headerlink" title="模块化下的类加载器"></a>模块化下的类加载器</h2><p>为了保证兼容性，JDK 9并没有从根本上动摇从JDK 1.2以来运行了二十年之久的三层类加载器架 构以及双亲委派模型。但是为了模块化系统的顺利施行，模块化下的类加载器仍然发生了一些应该被注意到变动，主要包括以下几个方面：</p>
<ul>
<li><p><strong>扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。</strong></p>
<p>这其实是一个很顺理成章的变动，既然整个JDK都基于模块化进行构建（原来的rt.jar和tools.jar被拆分 成数十个JMOD文件），其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留 &lt;JAVA_HOME&gt;\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没<br>有继续存在的价值了，用来加载这部分类库的扩展类加载器也完成了它的历史使命。</p>
</li>
<li><p><strong>平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader。</strong></p>
<p>如果有程序直接 依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK 9及更高版<br>本的JDK中崩溃。</p>
</li>
<li><p><strong>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。</strong></p>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能 够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，也许这可以算是对双亲委派的第四次破坏。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机执行子系统</tag>
        <tag>虚拟机类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM1-2.2-自动内存管理-垃圾收集器与内存分配策略（垃圾收集器及其选择）</title>
    <url>/2022/03/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM1-2.2-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%89%E6%8B%A9%EF%BC%89/</url>
    <content><![CDATA[<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p>垃圾收集器是对垃圾收集算法的实现，由于《Java虚拟机规范》中并没有明确垃圾收集器的实现细节。所以不同的厂商对于垃圾收集器都有不同的实现。而这里的经典垃圾收集器主要针对的是JDK 7 Update 4 之后JDK11正式发布之前，Oracle JDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。下图是各款经典垃圾收集器之间的关系：</p>
<p><img src="\images\深入理解JVM\HotSpot垃圾收集器.png" alt="HotSpot垃圾收集器"></p>
<p>这里的垃圾收集器都有各自不同的优缺点，还没有出现一个没有短板的收集器，因此后续的工作实际上是根据工作场景选择合适的垃圾收集器。（希望以后能有一个完美的垃圾收集器）。</p>
<p>（注意：Serial+CMS与ParNew+Serial Old的组合在JDK9中已经被废除）</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial是最基础、存在时间最长的收集器，在JDK1.31之前，其是HotSpot虚拟机新生代唯一的收集器。</p>
<p>其特点是单线程，其中的含义包括两层：</p>
<ul>
<li>只会启动一个线程进行垃圾收集。</li>
<li>当Serial运行的时候，用户线程必须停止。</li>
</ul>
<p>其原理如图：</p>
<p><img src="\images\深入理解JVM\Serial运行示意图.png" alt="Serial运行示意图"></p>
<p>就大多数场景来说，可能这种完全停止用户的场景并不是理想的行为。例如堆过大的时候，那么用户线程需要停顿的时间就会加长。例如对于一个C端应用，停顿几秒甚至十几秒的时间是非常致命的。</p>
<p>也因为如此，HotSpot团队也一直在研究新的收集器来缓解这种情况。从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）和Garbage First（G1）收集器，最终至现在垃圾收集器的最前沿成果Shenandoah和ZGC等。</p>
<p>但实际上其也有优点和缺点：</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>简单、高效，Serial收集器由于没有线程交互的开销。对于Java堆较小的环境中，其停顿时间并不会很长，其专一性也可以提升效率（比如最近流行的微服务或者桌面端程序）。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>收集时需要停止用户线程，对于大的Java堆，停顿时间会非常长，很致命。</li>
</ol>
<h3 id="ParNew收集器（新生代-多线程）"><a href="#ParNew收集器（新生代-多线程）" class="headerlink" title="ParNew收集器（新生代-多线程）"></a>ParNew收集器（新生代-多线程）</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之 外，其余的行为包括Serial收集器可用的所有控制参数（例如：<code>-XX：SurvivorRatio、-XX： PretenureSizeThreshold、-XX：HandlePromotionFailure</code>等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>
<p>其（搭配Serial Old）原理如图：</p>
<p><img src="\images\深入理解JVM\parNew收集器原理.png" alt="parNew收集器原理"></p>
<p>ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处。但由于目前除Serial之外，仅有该收集器可以与CMS收集器搭配使用，所以其仍然是不少服务端HotSpot虚拟机的新生代收集器。</p>
<p>CMS是HotSpot在JDK5推出的一个跨时代的老年代收集器，其意义在于可以使垃圾收集与用户线程并行执行。遗憾的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p>
<p>但是随着G1收集器的登场，CMS也不再是官方的推荐老年代收集器。G1作为全堆收集器，不再需要其他收集器配合，因此ParNew收集器也不再被广泛使用。</p>
<p>值得注意的是：ParNew收集器并不一定就比Serial收集器性能更好，特别是在单线程，单核的情况下。甚至由于线程间交互的开销，在使用超线程实现的多线程环境下的表现可能比Serial更差。</p>
<h3 id="Parallel-Scavenge收集器（吞吐量）"><a href="#Parallel-Scavenge收集器（吞吐量）" class="headerlink" title="Parallel Scavenge收集器（吞吐量）"></a>Parallel Scavenge收集器（吞吐量）</h3><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器。其主要特点是：Parallel Scavenge收集器的目标则是<strong>达到一个可控制的吞吐量</strong>（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的<code>-XX：MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的-<code>XX：GCTimeRatio</code>参数。这两个参数实际上互斥的，一个优秀就会牺牲另一个的性能。</p>
<ul>
<li><code>-XX：MaxGCPauseMillis</code>：允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的 时间不超过用户设定值。当把这个值设的很低时，即停顿的时间很低，那么相应停顿次数就会增加，那么吞吐量就会减少。</li>
<li><code>XX：GCTimeRatio</code>：允许的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的 比率，相当于吞吐量的倒数。</li>
</ul>
<p>由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。</p>
<p>该收集器还提供了一个<code>-XX：+UseAdaptiveSizePolicy</code>参数，其作为一个开关属性，可以设定是否让Parallel Scavenge自己决定新生区的大小（<code>-Xmn</code>）、Eden、Survivor区的比例（<code>-XX：SurvivorRatio</code>）、晋升老年代对象大小（<code>-XX：PretenureSizeThreshold</code>）等细节参数。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数<strong>以提供最合适设定的停顿时间或者最大的吞吐量</strong>。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收 集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用 途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
<p>原理图如下：</p>
<p><img src="\images\深入理解JVM\Serial-SerialOld运行示意图.png" alt="Serial-SerialOld运行示意图"></p>
<blockquote>
<p>需要说明一下，Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集，并非 直接调用Serial Old收集器，但是这个PS MarkSweep收集器与Serial Old的实现几乎是一样的，所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解。</p>
</blockquote>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p>
<p>这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相 当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PSMarkSweep）收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。但是由于Serial Old单线程的性能问题，其吞吐量能甚至不如ParNew加CMS。</p>
<p>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
<p>其原理如图：</p>
<p><img src="\images\深入理解JVM\Parallel-ParallelOld收集器组合.png" alt="Parallel-ParallelOld收集器组合"></p>
<h3 id="CMS收集器（停顿时间）"><a href="#CMS收集器（停顿时间）" class="headerlink" title="CMS收集器（停顿时间）"></a>CMS收集器（停顿时间）</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。其基于标记-清除算法实现。</p>
<p>它的运作 过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</li>
<li>并发标记（CMS concurrent mark）：从GC Roots的直接关联对象开始遍历整个对 象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li>重新标记（CMS remark）：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>并发清除（CMS concurrent sweep）：清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ul>
<p>所以其中初始标记、重新标记这两个步骤仍然需要“Stop The World”，其他两个阶段是可以并发的。</p>
<p>但由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>其原理如图：</p>
<p><img src="\images\深入理解JVM\CMS原理.png" alt="CMS原理"></p>
<p>CMS从初创性来说是很优秀的，基本实现了与用户进程并发的要求。但其仍然存在以下问题：</p>
<ul>
<li>CMS收集器对处理器资源非常敏感：由于并发，所以收集器本身也需要占用一定的处理器资源，所以如果处理器性能不行，相反回拖慢程序的运行。CMS默认启动的回收线程数是（处理器核心数量 +3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的 处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时， CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。</li>
<li>CMS收集器无法处理“浮动垃圾”（Floating Garbage）：有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为<strong>“浮动垃圾”</strong>。同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数<code>-XX：CMSInitiatingOccu-pancyFraction</code>的值 来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动 阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满 足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不 得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。</li>
<li>CMS无法很好处理内存碎片的问题：CMS是一款基于“标记-清除”算法实现的收集器，其基本原理就决定了回产生内存碎片，并且在碎片过多，导致无法分配大对象的时候，就不得不启动一次Full GC。因此其后提供了<code>-XX：+UseCMS-CompactAtFullCollection</code>参数用来在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程。<code>-XX：CMSFullGCsBeforeCompaction</code>参数用来要求CMS收集器在执行过若干次（数量 由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理。</li>
</ul>
<h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h3><p>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集 器面向局部收集的设计思路和基于Region的内存布局形式。</p>
<p>G1是一款主要面向服务端应用的垃圾收集器。HotSpot开发团队最初赋予它的期望是（在比较长 期的）未来可以替换掉JDK 5中发布的CMS收集器。JDK 9发布之 日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。</p>
<p>G1的设计思路与之前的收集器都不相同，其面向整个Java堆，而不仅仅是新生代或者老年代，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>
<p>G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。</p>
<p>虽然G1也仍是遵循分代收集理 论设计的，但其堆内存的布局与其他收集器有非常明显的差异：<strong>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</strong>收集器能够对扮演不同角色的 Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p>
<p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数<code>-XX：G1HeapRegionSize</code>设 定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。</p>
<p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作 为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免 在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃 圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数<code>-XX：MaxGCPauseMillis</code>指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。</p>
<p>其分区示意图如下：</p>
<p><img src="\images\深入理解JVM\G1收集器分区示意图.png" alt="G1收集器原理图"></p>
<p>如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的 运作过程大致可划分为以下四个步骤：</p>
<ul>
<li><strong>初始标记（Initial Marking）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际<br>并没有额外的停顿。</li>
<li><strong>并发标记（Concurrent Marking）</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li><strong>最终标记（Final Marking）</strong>：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。</li>
<li><strong>筛选回收（Live Data Counting and Evacuation）</strong>：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ul>
<p>从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的， 换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才能担当起“全功能收集器”的重任与期望。</p>
<p>其原理图如下：</p>
<p><img src="\images\深入理解JVM\G1收集器原理图.png" alt="G1收集器原理图"></p>
<p>与CMS 的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region 之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>
<p>不过，G1相对于CMS仍然不是占全方位、压倒性优势的，其仍然具有以下缺点：</p>
<ul>
<li>就内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间。</li>
<li>在执行负载的角度上，同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会 有不同，譬如它们都使用到写屏障，CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行 同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。</li>
</ul>
<h2 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h2><p>HotSpot的垃圾收集器从Serial发展到CMS再到G1，经历了逾二十年时间，经过了数百上千万台服 务器上的应用实践，已经被淬炼得相当成熟了，不过它们距离“完美”还是很遥远。</p>
<p>衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟 （Latency），三者共同构成了一个“不可能三角”。三者总体的表现会随技术进步而越来越好，但是 要在这三个方面同时具有卓越表现的“完美”收集器是极其困难甚至是不可能的，一款优秀的收集器通常最多可以同时达成其中的两项。</p>
<p>图3-14中浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的。由图 3-14可见，在CMS和G1之前的全部收集器，其工作的所有步骤都会产生“Stop The World”式的停顿； CMS和G1分别使用增量更新和原始快照（见3.4.6节）技术，实现了标记阶段的并发，不会因管理的堆 内存变大，要标记的对象变多而导致停顿时间随之增长。但是对于标记阶段之后的处理，仍未得到妥 善解决。CMS使用标记-清除算法，虽然避免了整理阶段收集器带来的停顿，但是清除算法不论如何优 化改进，在设计原理上避免不了空间碎片的产生，随着空间碎片不断淤积最终依然逃不过“Stop The World”的命运。G1虽然可以按更小的粒度进行回收，从而抑制整理阶段出现时间过长的停顿，但毕竟也还是要暂停的。</p>
<p><img src="\images\深入理解JVM\各款收集器的并发情况.png" alt="各款收集器的并发情况"></p>
<p>最后的两款收集器，Shenandoah和ZGC，几乎整个工作过程全 部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上是固定 的，与堆的容量、堆中对象的数量没有正比例关系。实际上，它们都可以在任意可管理的（譬如现在 ZGC只能管理4TB以内的堆）堆容量下，实现垃圾收集的停顿都不超过十毫秒这种以前听起来是天方 夜谭、匪夷所思的目标。这两款目前仍处于实验状态的收集器，被官方命名为“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time Garbage Collector）。</p>
<h3 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h3><p>Shenandoah收集器由于并不是Oracle公司开发的垃圾收集器，不可避免地会受到一些来自“官方”的排挤。Oracle仍明确拒绝在OracleJDK 12中支持Shenandoah收集器，并执意在打包 OracleJDK时通过条件编译完全排除掉了Shenandoah的代码，换句话说，Shenandoah是一款只有OpenJDK才会包含，而OracleJDK里反而不存在的收集器。</p>
<p>最初Shenandoah是由RedHat公司独立发展的新型收集器项目，在2014年RedHat把Shenandoah贡献 给了OpenJDK，并推动它成为OpenJDK 12的正式特性之一。这个项目的目标 是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器，该 目标意味着相比CMS和G1，Shenandoah不仅要进行并发的垃圾标记，还要并发地进行对象清理后的整理动作。</p>
<p>Shenandoah收集器与G1有很多相同的特点：</p>
<ul>
<li>基于Region的堆内存布局。</li>
<li>存在存放大对象的Humongous Region。</li>
<li>默认的回收策略也同样是优先处理回收价值最大的 Region。</li>
</ul>
<p>但在管理堆内存方面，其与G1至少有三个明显的不同之处：</p>
<ul>
<li>最重要的当然是支持并发的整理算法，G1的回收阶段是可以多线程并行的，但却不能与用户线程并发。而Shenandoah收集器可以与用户线程并发。</li>
<li>Shenandoah（目前）是默认不使用分代收集的，换言之，不会有 专门的新生代Region或者老年代Region的存在，没有实现分代，并不是说分代对Shenandoah没有价值，这更多是出于性价比的权衡，基于工作量上的考虑而将其放到优先级较低的位置上。</li>
<li>Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率（连接矩阵可以简单理解为一张二维表格，如果Region N有 对象指向Region M，就在表格的N行M列中打上一个标记）。</li>
</ul>
<p>例如下面的对象引用和连接矩阵的关系：</p>
<p><img src="\images\深入理解JVM\shenandosh示例.jpg" alt="shenandosh示例"></p>
<p>Shenandoah收集器的工作过程大致可以划分为以下九个阶段：</p>
<ol>
<li><p>初始标记（Initial Marking）：与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍 是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。</p>
</li>
<li><p>并发标记（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，这个阶段 是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。</p>
</li>
<li><p>最终标记（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。</p>
</li>
<li><p>并发清理（Concurrent Cleanup）：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。</p>
</li>
<li><p>并发回收（Concurrent Evacuation）：<strong>并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。</strong>在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之 中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进 行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通 过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。</p>
</li>
<li><p>初始引用更新（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未 做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收 集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。</p>
</li>
<li><p>并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，这个阶段是与用户 线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它 不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。</p>
</li>
<li><p>最终引用更新（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GC Roots 中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。</p>
</li>
<li><p>并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已 再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</p>
</li>
</ol>
<p>其中最主要的有3个阶段：并发标记、并发回收、并发引用更新。</p>
<p>下图中展示了Shenandoah三个并发阶 段的工作过程，还能形象地表示出并发标记阶段如何找出回收对象确定回收集，并发回收阶段如何移 动回收集中的存活对象，并发引用更新阶段如何将指向回收集中存活对象的所有引用全部修正，此后回收集便不存在任何引用可达的存活对象了。</p>
<p><img src="\images\深入理解JVM\Shenandoah收集器的工作过程.jpg" alt="Shenandoah收集器的工作过程"></p>
<p>还有一个关键的概念-Brooks Pointer。“Brooks”是一个人的名字，由他提出了Forwarding Pointer的概念。</p>
<p>Brooks提出的新方案不需要用到内存保护陷阱，而是在原有对象布局结构的最前面统一增加一个 新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。</p>
<p>有了转发指针之后，有何收益暂且不论，所有间接对象访问技术的缺点都是相同的，也是非常显 著的——每次对象访问会带来一次额外的转向开销，尽管这个开销已经被优化到只有一行汇编指令的程度。</p>
<p>转发指针加入后带来的收益自然是当对象拥有了一份新的副本时，只需要修 改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转 发到新的副本上。这样只要旧对象的内存仍然存在，未被清理掉，虚拟机内存中所有通过旧引用地址访问的代码便仍然可用，都会被自动转发到新对象上继续工作。</p>
<p>需要注意，Brooks形式的转发指针在设计上决定了它是必然会出现多线程竞争问题的，如果收集 器线程与用户线程发生的只是并发读取，那无论读到旧对象还是新对象上的字段，返回的结果都应该 是一样的，这个场景还可以有一些“偷懒”的处理余地；但如果发生的是并发写入，就一定必须保证写<br>操作只能发生在新复制的对象上，而不是写入旧对象的内存中。</p>
<p>不妨设想以下三件事情并发进行 时的场景：</p>
<ol>
<li>收集器线程复制了新的对象副本； </li>
<li>用户线程更新对象的某个字段；</li>
<li>收集器线程更新转发指针的引用值为新副本地址。</li>
</ol>
<p>如果不做任何保护措施，让事件2在事件1、事件3之间发生的话，将导致的结果就是用户线程对对 象的变更发生在旧对象上，所以这里必须针对转发指针的访问操作采取同步措施，让收集器线程或者用户线程对转发指针的访问只有其中之一能够成功，另外一个必须等待，避免两者交替进行。实际上 Shenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性的。</p>
<p>代码里对象读取的出现频率要比对象写入的频率高出很多，读屏障数量自然也要比写屏障多得多，所以读屏障的使用必须更加谨慎，不允许任何的重量级操作。 其开发者也意识到数量庞大的读屏障带来的性 能开销会是Shenandoah被诟病的关键点之一，所以计划在JDK 13中将Shenandoah的内存屏障模型改 进为基于引用访问屏障（Load Reference Barrier）的实现，所谓“引用访问屏障”是指内存屏障只拦 截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写，这能够省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的消耗。</p>
<h3 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h3><p>ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现 在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。但其实现思路与Shenandoah完全不一样，Shenandoah更像是G1的模式，而ZGC更像是Azul System公司的PGC个C4的继承者。</p>
<p>而ZGC的特点在于以下：</p>
<ul>
<li>基于Region内存布局的。</li>
<li>不设分代的。</li>
<li>使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法。</li>
<li>以低延迟为首要目标。</li>
</ul>
<h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p>与Shenandoah和G1一样，ZGC也采用基于Region的堆内存布局，但 与它们不同的是，ZGC的Region（在一些官方资料中将它称为Page或者ZPage）具有动态性——动态创建和销毁，以及动态的区域容量大小。</p>
<p>在x64硬件平台下，ZGC的 Region可以具有如图3-19所示的大、中、小三类容量：</p>
<ul>
<li>小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li>
<li>中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对 象。</li>
<li>大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置 4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型 Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配。</li>
</ul>
<p><img src="\images\深入理解JVM\ZGC的内存布局.jpg" alt="ZGC的内存布局"></p>
<h4 id="并发整理算法的实现"><a href="#并发整理算法的实现" class="headerlink" title="并发整理算法的实现"></a>并发整理算法的实现</h4><p>ZGC收集器有一个标志性的设计是它采用的染色指针技术（Colored Pointer，其他类似的技术中可 能将它称为Tag Pointer或者Version Pointer）。</p>
<p>以前对象的一些只供虚拟机访问的属性（如，对象的哈希码、分代年龄、锁记录等）一般存放再对象头中，但如果对象发生移动，即不能保证对象访问能够成功或者有一些根本就不会去访问对象，但又希望得知该对象的某些信息的应用场景。</p>
<p>HotSpot虚拟机的几种收集器有不同的标记实现方案，有的把标记直接记录在 对象头上（如Serial收集器），有的把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使 用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息），而ZGC的染色指针是最直接的、最纯粹的，它直接把标记信息记在引用对象的指针上。</p>
<p>在不同的平台，内存地址的长度是不一样的，而ZGC想在牺牲一定可管理内存空间的情况下，来使用内存地址中的几位来存储信息。</p>
<p>例如Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64TB内存在今天仍然能够充分满足大型服务器的需要。ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对 象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。如下图，当然，由于这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致 ZGC能够管理的内存不可以超过4TB（JDK13目前已经扩展到16TB）（2的42次幂）：</p>
<p><img src="\images\深入理解JVM\染色指针.jpg" alt="染色指针"></p>
<p>而染色指针具有以下优点：</p>
<ul>
<li><p>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用 掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</p>
</li>
<li><p>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。实际上，到目前为止ZGC都并未使用任何写屏障，只使用了读屏障（一部分是染色指针的功劳，一部分是ZGC现在还不支持分代收集，天然就没有跨代引用的问题）。</p>
</li>
<li><p>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</p>
<blockquote>
<p>（现在Linux下的64位指针还有前18位并未使用，它们虽然不能用来寻址，却可 以通过其他手段用于信息记录。如果开发了这18位，既可以腾出已用的4个标志位，将ZGC可支持的 最大堆内存从4TB拓展到64TB，也可以利用其余位置再存储更多的标志，譬如存储一些追踪信息来让垃圾收集器在移动对象时能将低频次使用的对象移动到不常访问的内存区域。）</p>
</blockquote>
</li>
</ul>
<h4 id="ZGC的工作流程"><a href="#ZGC的工作流程" class="headerlink" title="ZGC的工作流程"></a>ZGC的工作流程</h4><p>ZGC的运作过程大致可划分为以下四个大的阶 段。全部四个阶段都是可以并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段，这些小阶段，<br>譬如初始化GC Root直接关联对象的Mark Start。</p>
<ol>
<li>并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的 阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记（尽管ZGC中的名字不叫这些）的 短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。与G1、Shenandoah不同的是，ZGC 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。</li>
<li>并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。重分配集与G1收集器 的回收集（Collection Set）还是有区别的，ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收。相反，ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的 维护成本。因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面 的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对<br>全堆的。此外，在JDK 12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。</li>
<li>并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分 配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。</li>
<li>得益于染色指针的支持，ZGC收集器能仅从引用上就明 确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次 访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象 上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。其有两点好处：<ol>
<li>只有第一次访问旧对象会陷入转发，也就是只慢一次，对比 Shenandoah的Brooks转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢，因此ZGC对用户程序的运行时负载要比Shenandoah来得更低一些。</li>
<li>由于染 色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于 新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都是可以自愈的。</li>
</ol>
</li>
<li>并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的，但是ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第 一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。因此，ZGC很巧妙地把并发重映射 阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所 有对象的，这样合并就节省了一次遍历对象图[9]的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。</li>
</ol>
<p>ZGC的设计理念与Azul System公司的PGC和C4收集器一脉相承，是迄今垃圾收集器研究的最 前沿成果，它与Shenandoah一样做到了几乎整个收集过程都全程可并发，短暂停顿也只与GC Roots大小相关而与堆内存大小无关，因而同样实现了任何堆上停顿都小于十毫秒的目标。</p>
<p>但是由于其不存在分代的概念，也为其带来了优点和缺点：</p>
<p>优点：ZGC就完全没有使 用记忆集，它甚至连分代都没有，连像CMS中那样只记录新生代和老年代间引用的卡表也不需要，因而完全没有用到写屏障，所以给用户线程带来的运行负担也要小得多。</p>
<p>缺点：ZGC的这种选择也限制了它能承受的对象分配速率不会太高。假设其全过程要持续十分钟以 上（切勿混淆并发时间与停顿时间，ZGC立的Flag是停顿时间不超过十毫秒），在这段时间里 面，由于应用的对象分配速率很高，将创造大量的新对象，这些新对象很难进入当次收集的标记范 围，通常就只能全部当作存活对象来看待——尽管其中绝大部分对象都是朝生夕灭的，这就产生了大 量的浮动垃圾。如果这种高速分配持续维持的话，每一次完整的并发收集周期都会很长，回收到的内存空间持续小于期间并发产生的浮动垃圾所占的空间，堆中剩余可腾挪的空间就越来越小了。目前唯一的办法就是尽可能地增加堆容量大小，获得更多喘息的时间。</p>
<h3 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h3><p>Epsilon收集器并不会真正的进行垃圾收集工作。</p>
<p>从JDK 10开始，为了隔离垃圾收集器与Java虚拟机解释、编译、监 控等子系统的关系，RedHat提出了垃圾收集器的统一接口，即JEP 304提案，Epsilon是这个接口的有效性验证和参考实现。</p>
<p>其主要作用在于<strong>剥离垃圾收集器影响的性能测试和压力测试。</strong></p>
<p>传统Java有着内存占用较大，在容器中启动时间 长，即时编译需要缓慢优化等特点，这对大型应用来说并不是什么太大的问题，但对短时间、小规模的服务形式就有诸多不适。为了应对新的技术潮流，最近几个版本的JDK逐渐加入了提前编译、面向应用的类数据共享等支持。Epsilon也是有着类似的目标，如果读者的应用只要运行数分钟甚至数秒， 只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。</p>
<h3 id="收集器的权衡"><a href="#收集器的权衡" class="headerlink" title="收集器的权衡"></a>收集器的权衡</h3><p>对于不同的场景应该具体权衡，如：</p>
<ul>
<li>收集器特点。</li>
<li>硬件条件。</li>
<li>服务场景。</li>
</ul>
<p>最好还是经过测试，来选择确定的收集器。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集器与内存分配策略</tag>
        <tag>垃圾收集器及其选择</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM3-2-程序编译与代码优化-后端编译与优化</title>
    <url>/2022/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM3-2-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>如果我们把字节码看作是程序语言的一种中间表示形式（Intermediate Representation，IR）的话， 那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。</p>
<p>后面所提及的即时编译器都是特指HotSpot虚 拟机内置的即时编译器，虚拟机也是特指HotSpot虚拟机。</p>
<h1 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h1><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过解释器 （Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认 定为“热点代码”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。</p>
<h2 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h2><p>目前主流的商用Java虚拟 机，譬如HotSpot、OpenJ9等，内部都同时包含解释器与编译器。</p>
<p>解释器与编译器两者各有优势：</p>
<p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在），反之可以使用编译执行来提升效率。</p>
<p>同时，解释器还可以作为编译器激进优化时后备的“逃生门”，让编译器根据概率 选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设 不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行。</p>
<p>编译器与解释器的交互关系如图：</p>
<p><img src="/images/深入理解JVM/解释器编译器交互.jpg" alt="解释器编译器交互"></p>
<p>HotSpot虚拟机中内置了三个即时编译器:</p>
<ul>
<li>客户端编译器（Client Compiler、C1编译器）</li>
<li>服务端编译器（Server Compiler、C2编译器）</li>
<li>Graal编译器（实验状态）</li>
</ul>
<p>在分层编译（Tiered Compilation）的工作模式出现以前，HotSpot虚拟机通常是采用解释器与其中 一个编译器直接搭配的方式工作，程序使用哪个编译器，只取决于虚拟机运行的模式。（用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在客户端模式还是服务端模式）。</p>
<p>默认状态下，解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”（Mixed Mode）。也可以使用启动参数进行修改：</p>
<ul>
<li><code>-Xint</code>：强制虚拟机运行于“解释模 式”（Interpreted Mode）。</li>
<li><code>-Xcomp</code>：强制虚拟机运行于“编译模式”（Compiled Mode）。</li>
</ul>
<p>可以通过虚拟机的“version”命令的输出结果显示出这三种模式。如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\MW&gt;java -version</span><br><span class="line">java version <span class="string">"16.0.2"</span> 2021-07-20</span><br><span class="line">Java(TM) SE Runtime Environment (build 16.0.2+7-67)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 16.0.2+7-67, mixed mode, sharing)</span><br><span class="line"></span><br><span class="line">C:\Users\MW&gt;java -Xint -version</span><br><span class="line">java version <span class="string">"16.0.2"</span> 2021-07-20</span><br><span class="line">Java(TM) SE Runtime Environment (build 16.0.2+7-67)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 16.0.2+7-67, interpreted mode, sharing)</span><br><span class="line"></span><br><span class="line">C:\Users\MW&gt;java -Xcomp -version</span><br><span class="line">java version <span class="string">"16.0.2"</span> 2021-07-20</span><br><span class="line">Java(TM) SE Runtime Environment (build 16.0.2+7-67)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 16.0.2+7-67, compiled mode, sharing)</span><br></pre></td></tr></table></figure>
<p>上面说到解释器与编译器各自的优缺点，如：</p>
<ul>
<li>由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长。</li>
<li>而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信 息，这对解释执行阶段的速度也有所影响。</li>
</ul>
<p>所以为了在程序启动响应速度与运行效率之间达到最佳平衡， HotSpot虚拟机在编译子系统中加入了分层编译的功能。（分层编译的概念其实很早就已经提出，但 直到JDK 6时期才被初步实现，后来一直处于改进阶段，最终在JDK 7的服务端模式虚拟机中作为默认编译策略被开启）</p>
<p>分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包 括：</p>
<ul>
<li>第0层。程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。</li>
<li>第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。</li>
<li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li>
<li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li>
<li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li>
</ul>
<p>以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。</p>
<p>各层次编译之间的交互、转换关系如图所示：</p>
<p><img src="/images/深入理解JVM/分层编译的交互关系.jpg" alt="分层编译的交互关系"></p>
<p>实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多 次编译，用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量，在解释执行 的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间。</p>
<h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p>首先明确热点代码主要包括两类：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<p>对于第一种情况，依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机<br>中标准的即时编译方式。</p>
<p>而对于第二种情况，尽管编译动作是由循环体所触发的，热点只是方法的一分，<strong>但编译器依然必须以整个方法作为编译对象</strong>，只是执行入口（从方法第几条字节码指令开始执行）会稍有不同，编译时会传入执行入口点字节码序号（Byte Code Index，BCI）。这种编译方式因为 编译发生在方法执行的过程中，因此被很形象地称为“栈上替换”（On Stack Replacement，OSR），即方法的栈帧还在栈上，方法就被替换了。</p>
<p>关于多次的定义，上面看起来是一个模糊的概念，必须要一个定量的定义。</p>
<p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“热点探测”（Hot Spot Code Detection），目前主流的热点探测判定方式有两种，分别是：</p>
<ul>
<li>基于采样的热点探测（Sample Based Hot Spot Code Detection）：采用这种方法的虚拟机会周期性 地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方 法”。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>
<li>基于计数器的热点探测（Counter Based Hot Spot Code Detection）：采用这种方法的虚拟机会为 每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为 它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li>
</ul>
<p>这两种探测手段在商用Java虚拟机中都有使用到，譬如J9用过第一种采样热点探测，而在HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法。为了实现热点计数，HotSpot为每个方法准备了 两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter，“回边”的意思 就是指在循环边界往回跳转）。当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈值，计数器阈值一旦溢出，就会触发即时编译。</p>
<h3 id="方法计数器"><a href="#方法计数器" class="headerlink" title="方法计数器"></a>方法计数器</h3><p>对于方法计数器，其用来统计方法被调用的次数，它的 默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数<code>-XX：CompileThreshold</code>来人为设定。并且此时执行流程如下：</p>
<p>当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的 版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法 的调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。如下图：</p>
<p><img src="/images/深入理解JVM/方法调用计数器触发即时编译.jpg" alt="方法调用计数器触发即时编译"></p>
<p>值得注意的是：在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频 率，即一段时间之内方法被调用的次数。且该值会有一个半衰期，即在一定时间内调用次数仍然不足以让它提交给即时编译器，那么该方法的调用计数器就会被减半。这个时间就是半衰期的具体值。可以使用<code>-XX：UseCounterDecay</code>参数来关闭热度衰减。也可以使用<code>-XX：CounterHalfLifeTime</code>参数来设置半衰期。</p>
<h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><p>关于回边计数器的阈值，虽然HotSpot虚拟机也提供了一个类似于方法调用计数器阈值<code>-XX： CompileThreshold</code>的参数<code>-XX：BackEdgeThreshold</code>供用户设置，但是当前的HotSpot虚拟机实际上并未 使用此参数，我们必须设置另外一个参数<code>-XX：OnStackReplacePercentage</code>来间接调整回边计数器的阈值，其计算公式有如下两种。</p>
<ul>
<li>虚拟机运行在客户端模式下，回边计数器阈值计算公式为：方法调用计数器阈值（<code>-XX： CompileThreshold</code>）乘以OSR比率（<code>-XX：OnStackReplacePercentage</code>）除以100。其中<code>-XX： OnStackReplacePercentage</code>默认值为933，如果都取默认值，那客户端模式虚拟机的回边计数器的阈值为13995。</li>
<li>虚拟机运行在服务端模式下，回边计数器阈值的计算公式为：方法调用计数器阈值（<code>-XX： CompileThreshold</code>）乘以（OSR比率（<code>-XX：OnStackReplacePercentage</code>）减去解释器监控比率（<code>-XX： InterpreterProfilePercentage</code>）的差值）除以100。其中<code>-XX：OnStack ReplacePercentage</code>默认值为140，<code>-XX：InterpreterProfilePercentage</code>默认值为33，如果都取默认值，那服务端模式虚拟机回边计数器的阈值为10700。</li>
</ul>
<p>其流程如下：</p>
<p><img src="/images/深入理解JVM/回边计数器触发即时编译.jpg" alt="回边计数器触发即时编译"></p>
<p>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循 环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>在默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器 还未完成编译之前，都仍然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行。用户可以通过参数<code>-XX：-BackgroundCompilation</code>来禁止后台编译，后台编译被禁止后，当达到触发即 时编译的条件时，执行线程向虚拟机提交编译请求以后将会一直阻塞等待，直到编译过程完成再开始执行编译器输出的本地代码。</p>
<p>在后台执行编译的过程中，服务端编译器和客户端编译器的编译 过程是有所差别的。</p>
<p>对于客户端编译器来说，它是一个相对简单快速的三段式编译器，主要的关注点 在于局部性的优化，而放弃了许多耗时较长的全局优化手段。其过程如下：</p>
<ul>
<li>第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level Intermediate Representation，HIR，即与目标机器指令集无关的中间表示）。HIR使用静态单分配 （Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后 进行的优化动作更容易实现。在此之前编译器已经会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。</li>
<li>第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</li>
<li>最后的阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配 寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。</li>
</ul>
<p>其流程如下图：</p>
<p><img src="/images/深入理解JVM/Client Compiler架构.jpg" alt="Client Compiler架构"></p>
<p>而服务端编译器则是专门面向服务端的典型应用场景，并为服务端的性能配置针对性调整过的编译器，也是一个能容忍很高优化复杂度的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的 优化强度。</p>
<p>它会执行大部分经典的优化动作，如：无用代码消除（Dead Code Elimination）、循环展开 （Loop Unrolling）、循环表达式外提（Loop Expression Hoisting）、消除公共子表达式（Common Subexpression Elimination）、常量传播（Constant Propagation）、基本块重排序（Basic Block Reordering）等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除（Range Check Elimination）、空值检查消除（Null Check Elimination，不过并非所有的空值检查消除都是依赖编译器优化的，有一些是代码运行过程中自动优化了）等。</p>
<h1 id="提前编译器"><a href="#提前编译器" class="headerlink" title="提前编译器"></a>提前编译器</h1><p>所谓提前编译器，就是根据平台的不同，提前将虚拟机代码编译为对应平台的代码。但由于其与Java的一个核心优势-平台中立性的冲突后沉寂下来。但在2013年的Android平台上，提前编译的ART（Android Runtime）的高效性（并且迅速替代了Dalvik编译器）让其又进入大众的视野。</p>
<h2 id="提前编译的优劣得失"><a href="#提前编译的优劣得失" class="headerlink" title="提前编译的优劣得失"></a>提前编译的优劣得失</h2><p>现在提前编译产品和对其的研究有着两条明显的分支：</p>
<ul>
<li>做与传统C、C++编译器类似 的，在程序运行之前把程序代码编译成<strong>机器码</strong>的静态翻译工作；</li>
<li>把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用。</li>
</ul>
<p>对于第一条，就是传统的提前编译应用形式，它在Java中存在的价值直指即时编译的最大弱点：即时编译要占用程序运行时间和运算资源。即时经过再多的优化，这个事实是不会变化的。</p>
<p>对于第二条，本质是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。这种提前编译被称为动态提前编译（Dynamic AOT）或者索性就大大方方地直接叫即时编译缓存（JIT Caching）。在目前的Java技术体系里，这条路径的提前编译已经完全被主流的商用JDK支持。</p>
<p>对于提前编译，不仅需要考虑平台的不同；还需要考虑虚拟机参数的不同等等。所以其实也是一个比较复杂的过程。</p>
<p>还有一个需要思考的问题是：提前编译的代码输出质量，一定会比即时编译更高吗？提前编译在获得时间和资源的优势的同时，也失去了运行时的信息分析能力。</p>
<p>即以下三种即时编译器相对于提前编译器的天然优势：</p>
<ul>
<li>性能分析制导优化：在运行时，虚拟机可以获取程序运行时的具体信息，如某个程序 点抽象类通常会是什么实际类型、条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等，这些数据一般在静态分析时是无法得到的，或者不可能存在确定且唯一的解， 最多只能依照一些启发性的条件去进行猜测。</li>
<li>激进预测性优化：这也已经成为很多即时编译优化措施的基础。静态优化无论如何都必须保证优化后所有的程序外部可见影响（不仅仅是执行结果）与优化前是等效的，不然优化之后会导致程序报错或者结果不对，若出现这种情况，则速度再快也是没有价值的。然而，相对于提前编译来说，即时编译的策略就可以不必这样保守，如果性能监控信息 能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断，就已经可以大胆地按照高概 率的假设进行优化，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果。只要出错概率足够低，这样的优化往往能够大幅度降低目标程序的复杂度， 输出运行速度非常高的代码。</li>
<li>链接时优化：Java语言天生就是动态链接的，一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码。但对于C、C++等语言，程序要调用某个动态链接库的某个方法，就会出现很明显的边界隔阂，还难以优化。<strong>因为主程序与动态链接库的代码在它们编译时是完全独立的，两者各自编译、优化自己的代码。</strong></li>
</ul>
<h1 id="编译器优化技术"><a href="#编译器优化技术" class="headerlink" title="编译器优化技术"></a>编译器优化技术</h1><p>由于编译器优化技术是一种很复杂的技术，包括很多方法，例如，方法内联，逃逸分析等。下面介绍仅仅时编译器优化技术的很小一部分。</p>
<h2 id="优化技术概览"><a href="#优化技术概览" class="headerlink" title="优化技术概览"></a>优化技术概览</h2><p>OpenJDK的官方Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面的、即时编译器中采用的优化技术列表。其中有不少经典编译器的优化手段，也有许多针对Java语言，或 者说针对运行在Java虚拟机上的所有语言进行的优化。在后面，我们挑选几种最经典或重要的优化作为分析。</p>
<p><img src="/images/深入理解JVM/即时编译器优化技术一览1.jpg" alt="即时编译器优化技术一览1"></p>
<p><img src="/images/深入理解JVM/即时编译器优化技术一览2.jpg" alt="即时编译器优化技术一览2"></p>
<p>上述的优化技术看起来很多，而且名字看起来大多显得有点“高深莫测”，实际上要实现这些优化 确实有不小的难度，但大部分优化技术理解起来都并不困难。</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联式编译器优化的最重要手段，甚至都可以不加 上“之一”。</p>
<p>内联被业内戏称为优化之母，因为除了消除方法调用的成本之外，它更重要的意义是为其 他优化手段建立良好的基础。</p>
<p>如下代码：例子里testInline()方法的内部全部是无用的代码，但如 果不做内联，后续即使进行了无用代码消除的优化，也无法发现任何“Dead Code”的存在。如果分开来看，foo()和testInline()两个方法里面的操作都有可能是有意义的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object obj)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123; </span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInline</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Object obj = <span class="keyword">null</span>; foo(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法内联的优化行为理解起来是没有任何困难的，不过就是把目标方法的代码原封不动地“复 制”到发起调用的方法之中，避免发生真实的方法调用而已。但实际上Java虚拟机中的内联过程却远没 有想象中容易，甚至如果不是即时编译器做了一些特殊的努力，按照经典编译原理的优化理论，大多数的Java方法都无法进行内联。</p>
<p>无法内联的原因其实在于Java方法分配的原理：只有使用 invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析。除了上述四种方法之外（最多再除去被final修饰的方法这种特殊情况，尽管它使 用invokevirtual指令调用，但也是非虚方法，《Java语言规范》中明确说明了这点），其他的Java方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，<strong>简而言之，Java语言中默认的实例方法是虚方法。</strong></p>
<p><strong>对于一个虚方法，编译器静态地去做内联的时候很难确定应该使用哪个方法版本。</strong></p>
<p>糟糕的情况是，由于Java提倡使用面向对象的方式进行编程，而Java对象的方法默认就是虚方 法，可以说Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑。</p>
<p>为了解决虚方法的内联问题，Java虚拟机首先引入了一种名为<strong>类型继承关系分析</strong>（Class Hierarchy Analysis，CHA）的技术，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。</p>
<p>这样，编译器在进行内联时就会分不同情况采取不同的处理：</p>
<ul>
<li>如果是非虚方法，那么直接进 行内联就可以了，这种的内联是有百分百安全保障的。</li>
<li>如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择。<ul>
<li>如果查询到只有一个版本，那就可以假设“应用程序 的全貌就是现在运行的这个样子”来进行内联，这种内联被称为守护内联（Guarded Inlining）。不过由 于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属 于激进预测性优化，必须预留好“逃生门”，即当假设条件不成立时的“退路”（Slow Path）。假如在程 序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这 个内联优化的代码就可以一直使用下去。<strong>如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</strong></li>
<li>如果查询到的结果是该方法确实有多个版本的目标方法可供选择，那即时编译器还将进行最后一次努力，使用<strong>内联缓存</strong>（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用是真正发生了的，但是比起直接查虚方法表还是要快一些。内联缓存是一个建立在目标方法正常入口 之前的缓存，它的工作原理大致为：<em>在未发生方法调用之前，内联缓存状态为空，当第一次调用发生 后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。如果以后进 来的每次调用的方法接收者版本都是一样的，那么这时它就是一种单态内联缓存（Monomorphic Inline Cache）。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销而已。但如果真的出现方法接收者不一致的情况，就说明程序用到了虚方法的多态特性，这时候会退化成超多态内联缓存（Megamorphic Inline Cache），其开销相当于真正查找虚方法表来进行方法分派</em>。</li>
</ul>
</li>
</ul>
<p>所以说，在多数情况下Java虚拟机进行的方法内联都是一种激进优化。事实上，激进优化的应用在高性能的Java虚拟机中比比皆是，极为常见。除了方法内联之外，对于出现概率很小（通过经验数 据或解释器收集到的性能监控信息确定概率大小）的隐式异常、使用概率很小的分支等都可以被激进优化“移除”，<strong>如果真的出现了小概率事件，这时才会从“逃生门”回到解释状态重新执行。</strong></p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一 样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。</p>
<p>逃逸分析的基本原理是：<em>分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，<strong>例如作为调用参数传递到其他方法中，这种称为方法逃逸</strong>；甚至还有可能被外部线程访 问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为<strong>对象由低到高的不同逃逸程度</strong></em>。</p>
<p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化，如：</p>
<ul>
<li>栈上分配：在Java虚拟机中，Java堆上分配创建对象的内存空间几乎是 Java程序员都知道的常识，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回 收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸。</li>
<li>标量替换：若一个数据已经无法再分解成更小的数据来表示了，Java虚拟 机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为<strong>标量</strong>。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java 中的对象就是典型的<strong>聚合量</strong>。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。<strong>假如逃逸分析能够证明一个对象不会被方法外部 访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创</strong><br><strong>建它的若干个被这个方法使用的成员变量来代替。</strong>将对象拆分后，除了可以让对象的成员变量在栈上 （栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。</li>
<li>同步消除：线程同步本身是一个相对耗时的过程，如果逃逸分析 能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。</li>
</ul>
<p>例如：</p>
<p>原始代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完全未优化的代码 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> xx = x + <span class="number">2</span>; Point p = <span class="keyword">new</span> Point(xx, <span class="number">42</span>); <span class="keyword">return</span> p.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步：将Point的构造函数和getX()方法进行内联优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：构造函数内联后的样子 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> xx = x + <span class="number">2</span>; </span><br><span class="line">    Point p = point_memory_alloc();</span><br><span class="line">	p.x = xx;</span><br><span class="line">	p.y = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> p.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二部：经过逃逸分析，发现在整个test()方法的范围内Point对象实例不会发生任何程度的逃逸， 这样可以对它进行标量替换优化，把其内部的x和y直接置换出来，分解为test()方法内的局部变量，从而避免Point对象实例被实际创建，优化后的结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤2：标量替换后的样子 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> xx = x + <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">int</span> px = xx; </span><br><span class="line">    <span class="keyword">int</span> py = <span class="number">42</span>; </span><br><span class="line">    <span class="keyword">return</span> px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，通过数据流分析，发现py的值其实对方法不会造成任何影响，那就可以放心地去做无效 代码消除得到最终优化结果，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤3：做无效代码消除后的样子 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术，它的含义是：如果一 个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。</p>
<p>对于这种表达式，没有必要花时间再对它重新进行计算，只需要直 接用前面计算过的表达式结果代替E。</p>
<p>如果这种优化仅限于程序基本块内，便可称为局部公共子表达 式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = (c * b) * <span class="number">12</span> + a + (a + b * c);</span><br></pre></td></tr></table></figure>
<p>当这段代码进入虚拟机即时编译器后，它将进行如下优化：编译器检测到c*b与b*c是一样的表达 式，而且在计算期间b与c的值是不变的。因此其可能被优化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">12</span> + a + (a + E);</span><br></pre></td></tr></table></figure>
<p>这时候，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化 ——代数化简（Algebraic Simplification），在E本来就有乘法运算的前提下，把表达式变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">13</span> + a + a;</span><br></pre></td></tr></table></figure>
<p>表达式进行变换之后，再计算起来就可以节省一些时间了。</p>
<h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术。我们知道Java语言是一门动态安全的语言，对数组的读写访问也不像C、C++那样实质上就是裸指针操作。但实际上虚拟机就必须在每次访问的时候去检测下标是否超过了范围，这也是一种性能消耗。</p>
<p>为了消除这些隐式开销，除了如数组 边界检查优化这种尽可能把运行期检查提前到编译期完成的思路之外，还有一种避开的处理思路—— 隐式异常处理，Java中空指针检查和算术运算中除数为零的检查都采用了这种方案。举个例子，程序 中访问一个对象（假设对象叫foo）的某个属性（假设属性叫value），那以Java伪代码来表示虚拟机访<br>问foo.value的过程为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo != <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> foo.value;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用隐式异常优化之后，虚拟机会把上面的伪代码所表示的访问过程变为如下伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> foo.value;</span><br><span class="line">&#125; <span class="keyword">catch</span> (segment_fault) &#123; </span><br><span class="line">    uncommon_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟机会注册一个Segment Fault信号的异常处理器（伪代码中的uncommon_trap()，务必注意这里 是指进程层面的异常处理器，并非真的Java的try-catch语句的异常处理器），这样当foo不为空的时 候，对value的访问是不会有任何额外对foo判空的开销的，而代价就是当foo真的为空时，必须转到异 常处理器中恢复中断并抛出NullPointException异常。进入异常处理器的过程涉及进程从用户态转到内 核态中处理的过程，结束后会再回到用户态，速度远比一次判空检查要慢得多。当foo极少为空的时 候，隐式异常优化是值得的，但假如foo经常为空，这样的优化反而会让程序更慢。幸好HotSpot虚拟机足够聪明，它会根据运行期收集到的性能监控信息自动选择最合适的方案。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>程序编译与代码优化</tag>
        <tag>后端编译与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM2-3-虚拟机执行子系统-虚拟机字节码执行引擎</title>
    <url>/2022/04/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM2-3-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p>在不同的虚拟机实现中，执行引擎在执行字节码的 时候，通常会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。</p>
<h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法 调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual MachineStack）的栈元素。见<a href="https://www.mw530.cn/2022/03/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM1-1-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" target="_blank" rel="noopener">深入理解JVM1-1-自动内存管理-Java内存区域与内存溢出异常</a></p>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算 出来，并且写入到方法表的Code属性之中。即一个栈帧需要分配多少内存，并不会受到程序 运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p>
<p>一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在 调用堆栈的所有方法都同时处于执行状态。而对于执行引擎来讲，在活动线程中，只有位于栈顶的方 法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame），与 这个栈帧所关联的方法被称为“当前方法”（Current Method）。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义 的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。</p>
<p>局部变量表的容量以变量槽（Variable Slot）为最小单位，《Java虚拟机规范》中并没有明确指出 一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、 byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储。</p>
<p><img src="/images/深入理解JVM/栈帧结构.png" alt="栈帧结构"></p>
<p>一个变量槽可以存放一个 32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference和returnAddress这8种类型。</p>
<p>对于64位的数据类型，Java虚拟机会以高位对齐的方式为其<strong>分配两个连续的变量槽空间</strong>。Java语言 中明确的64位的数据类型只有long和double两种。这里把long和double数据类型分割存储的做法与“long 和double的非原子性协定”中允许把一次long和double数据类型读写分割为两次32位读写的做法有些类似。由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。</p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO） 栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项 之中。其特点如下：</p>
<ul>
<li>操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。</li>
<li>32位数据类型所占 的栈容量为1，64位数据类型所占的栈容量为2。</li>
<li>Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</li>
</ul>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器 必须要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p>
<p>另外在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在 大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。</p>
<p><img src="/images/深入理解JVM/两个栈帧之间的数据共享.jpg" alt="两个栈帧之间的数据共享"></p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>每个栈帧都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p>
<p>通过第6章的讲解，我们知道Class文件的常量池中存 有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号 引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。</p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>当一个方法开始执行后，只有两种方式退出这个方法:</p>
<ol>
<li>执行引擎遇到任意一个方法 返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用 者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”（Normal Method Invocation Completion）。</li>
<li>方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方 法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为“异常调用完成（Abrupt Method Invocation Completion）”。</li>
</ol>
<p>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。</p>
<ul>
<li><p>方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这 个计数器值。</p>
</li>
<li><p>方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存 这部分信息。</p>
</li>
</ul>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<h2 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h2><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、 性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>
<h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本 （即调用哪一个方法），暂时还未涉及方法内部的具体运行过程。</p>
<p>Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使 得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>由于所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用。在类加载阶段确定具体的方法并转化为直接引用。这种行为就称为方法的解析，其前提是方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。</p>
<p>在Java语言中符合“<strong>编译期可知，运行期不可变</strong>”这个要求的方法，主要有静态方法和私有方法两大类，<strong>前者与类型直接关联</strong>，<strong>后者在外部不可被访问</strong>，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>调用不同类型的方法，字节码指令集里设计了不同的指令。在Java虚拟机支持以下5条方法调用字 节码指令，分别是：</p>
<ul>
<li>invokestatic：用于调用静态方法。</li>
<li>invokespecial：用于调用实例构造器<code>&lt;init&gt;()</code>方法、私有方法和父类中的方法。</li>
<li>invokevirtual：用于调用所有的虚方法。</li>
<li>invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象。</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4 条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</li>
</ul>
<p>只要能被<strong>invokestatic</strong>和<strong>invokespecial</strong>指令调用的方法，都可以在解析阶段中确定唯一的调用版本， Java语言里符合这个条件的方法共有<strong>静态方法、私有方法、实例构造器、父类方法4种，再加上被final 修饰的方法（尽管它使用invokevirtual指令调用）</strong>，这5种方法调用会在类加载的时候就可以把符号引 用解析为该方法的直接引用。这些方法统称为“<strong>非虚方法</strong>”（Non-Virtual Method），与之相反，其他方法就被称为“<strong>虚方法</strong>”（Virtual Method）。</p>
<p>解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号 引用全部转变为明确的直接引用，不必延迟到运行期再去完成。</p>
<h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p>分派 （Dispatch）调用则要复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况，下面我们来看看虚拟机中的方法分派是如何进行的。</p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>为了解释静态分派和重载（Overload），笔者准备了一段经常出现在面试题中的程序代码，读者 不妨先看一遍，想一下程序的输出结果是什么。后面的话题将围绕这个类的方法来编写重载代码，以分析虚拟机和编译器确定方法版本的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic; <span class="comment">/** * 方法静态分派演示 * <span class="doctag">@author</span> zzm */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello,guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello,gentleman!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello,lady!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Human man = <span class="keyword">new</span> Man(); Human woman = <span class="keyword">new</span> Woman(); StaticDispatch sr = <span class="keyword">new</span> StaticDispatch(); sr.sayHello(man); sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello, guy!</span><br><span class="line">hello, guy!</span><br></pre></td></tr></table></figure>
<p>下面从例子中引出两个基本概念：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
<ul>
<li>上面代码中的“Human”称为变量的“<strong>静态类型</strong>”（Static Type），或者叫“外观类 型”（Apparent Type）。</li>
<li>后面的“Man”则被称为变量的“<strong>实际类型</strong>”（Actual Type）或者叫“运行时类 型”（Runtime Type）</li>
</ul>
<p>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，<strong>并且最终的静态类型是在编译期可知的</strong>；</p>
<p>而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化 </span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化 </span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br></pre></td></tr></table></figure>
<p>对象human的<strong>实际类型</strong>是可变的，编译期间它完全是个“薛定谔的人”，到底是Man还是Woman，必 须等到程序运行到这行的时候才能确定。</p>
<p>而human的静态类型是Human，也可以在使用时（如 sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()方法的调用，在编译期完全可以明确转型的是Man还是Woman。</p>
<p>main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。代码中故意定义了两个静态类型相同，而实际类型不 同的变量，但虚拟机（或者准确地说是编译器）<strong>在重载时是通过参数的静态类型而不是实际类型作为判定依据的</strong>。由于静态类型在编译期可知，所以在编译阶段，<strong>Javac编译器</strong>就根据参数的静态类型决定 了会使用哪个重载版本，因此选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</p>
<p>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用表 现就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，这点也是为何一些资料选择把它归入“解析”而不是“分派”的原因。</p>
<p>需要注意Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯 一”的，往往只能确定一个“相对更合适的”版本。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello char ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        sayHello(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码运行后会输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello char</span><br></pre></td></tr></table></figure>
<p>这很好理解，’a’是一个char类型的数据，自然会寻找参数类型为char的重载方法，如果注释掉 sayHello(char arg)方法，那输出会变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello int</span><br></pre></td></tr></table></figure>
<p>这时发生了一次自动类型转换，’a’除了可以代表一个字符串，还可以代表数字97（字符’a’的 Unicode数值为十进制数字97），因此参数类型为int的重载也是合适的。</p>
<p>继续注释掉sayHello(int arg)方法，那输出会变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello long</span><br></pre></td></tr></table></figure>
<p>这时发生了两次自动类型转换，’a’转型为整数97之后，进一步转型为长整数97L，匹配了参数类型 为long的重载。</p>
<p>实际上自动转型还能继 续发生多次，按照char&gt;int&gt;long&gt;float&gt;double的顺序转型进行匹配，但不会匹配到byte和short类型的重载，因为char到byte或short的转型是不安全的。</p>
<p>继续注释掉sayHello(long arg)方法，那输出会变 为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello Character</span><br></pre></td></tr></table></figure>
<p>这时发生了一次自动装箱，’a’被包装为它的封装类型java.lang.Character，所以匹配到了参数类型为 Character的重载，继续注释掉sayHello(Character arg)方法，那输出会变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello Serializable</span><br></pre></td></tr></table></figure>
<p>出现hello Serializable， 是因为<code>java.lang.Serializable</code>是<code>java.lang.Character</code>类实现的一个接口，当自动装箱之后发现还是找不到装 箱类，但是找到了装箱类所实现的接口类型，所以紧接着又发生一次自动转型。char可以转型成int， 但是<code>Character</code>是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。Character还实现 了另外一个接口<code>java.lang.Comparable&lt;Character&gt;</code>，如果同时出现两个参数分别为<code>Serializable</code>和 <code>Comparable&lt;Character&gt;</code>的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示“类型模糊”（Type Ambiguous），并拒绝编译。</p>
<p>但是要注意的是，有一些 在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不成立的。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>动态分派与Java语言的另一个特征-重写有密切的关系。</p>
<p>还是从例子看起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic; <span class="comment">/** * 方法动态分派演示 * <span class="doctag">@author</span> zzm */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Human man = <span class="keyword">new</span> Man(); </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman(); </span><br><span class="line">        man.sayHello(); </span><br><span class="line">        woman.sayHello(); </span><br><span class="line">        man = <span class="keyword">new</span> Woman(); </span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man say hello </span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>
<p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为静态类型同样都是Human 的两个变量man和woman在调用sayHello()方法时产生了不同的行为，甚至变量man在两次调用中还执行了两个不同的方法。导致这个现象的原因很明显，是因为这两个变量的实际类型不同。</p>
<p>这里的调用在字节码层面上即使用了<code>invokevirtual</code>指令。根据《Java虚拟机规范》， invokevirtual指令的运行时解析过程[4]大致分为以下几步：</p>
<ul>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果 通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ul>
<p>正是因为invokevirtual指令执行的第一步就是在<strong>运行期</strong>确定接收者的实际类型，所以两次调用中的 invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。 </p>
<h3 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h3><p>方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于著名的《Java与模式》 一书。</p>
<p>根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。</p>
<p>单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * 单分派、多分派演示 * <span class="doctag">@author</span> zzm */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123; </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123; </span><br><span class="line">                System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Father father = <span class="keyword">new</span> Father(); </span><br><span class="line">        Father son = <span class="keyword">new</span> Son(); </span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360()); </span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">father choose 360 </span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure>
<p>此时看在编译阶段中编译器的选择过程，也就是静态分派过程。</p>
<p>这时候选择目标方法的依据有两点：</p>
<ul>
<li>静态类型是Father还是Son，</li>
<li>方法参数是QQ还是360。</li>
</ul>
<p>这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向 Father::hardChoice(360)及Father::hardChoice(QQ)方法的符号引用。因为是根据<strong>两个宗量</strong>进行选择，所以Java语言的静态分派属于多分派类型。</p>
<hr>
<p>再看运行阶段中虚拟机的选择，也就是动态分派的过程。</p>
<p>在执行“son.hardChoice(new QQ())”这 行代码时，更准确地说，是在执行这行代码所对应的invokevirtual指令时，由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯QQ”还是“奇 瑞QQ”，因为这时候参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的接受者的实际类型是Father还是Son。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p>
<h3 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h3><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的 方法元数据中搜索合适的目标方法，因此，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法 区中建立一个虚方法表（Virtual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也 会用到接口方法表——Interface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。</p>
<p>例如下面方法表结构：</p>
<p><img src="/images/深入理解JVM/方法表结构.png" alt="方法表结构"></p>
<p><strong>虚方法表中存放着各个方法的实际入口地址。</strong>如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了 这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。在上图中，Son重写 了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。</p>
<h1 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h1><p>Java虚拟机的字节码指令集的数量自从Sun公司的第一款Java虚拟机问世至今，二十余年间只新增 过一条指令，它就是随着JDK 7的发布的字节码首位新成员——invokedynamic指令。这条新增加的指 令是JDK 7的项目目标：实现动态类型语言（Dynamically Typed Language）支持而进行的改进之一，也是为JDK 8里可以顺利实现Lambda表达式而做的技术储备。</p>
<h2 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h2><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的。如Groovy、 JavaScript、Lisp、Lua等。</p>
<p>那相对地，在编译期就 进行类型检查过程的语言，譬如C++和Java等就是最常用的静态类型语言。</p>
<h2 id="Java与动态类型"><a href="#Java与动态类型" class="headerlink" title="Java与动态类型"></a>Java与动态类型</h2><p>Java虚拟机层面对动态类型语言的支持一直都还有所欠缺，主要表现在方法调用方 面：JDK 7以前的字节码指令集中，4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是被调用的方法的符号引用。前面已经提到过，方法的符号引用在编译时产生，而动 态类型语言只有在运行期才能确定方法的接收者。</p>
<p>所以，在Java虚拟机上实现的动态类型语言就不得不采用更复杂的方法（如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符 类型的适配）。这样肯定会带来更大的开销。</p>
<p>例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrays = &#123;<span class="string">"abc"</span>, <span class="keyword">new</span> ObjectX(), <span class="number">123</span>, Dog, Cat, Car..&#125; </span><br><span class="line"><span class="keyword">for</span>(item in arrays)&#123; </span><br><span class="line">    item.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在动态类型语言下这样的代码是没有问题。</p>
<p>但在Java的处理方法中，由于在运行时arrays中的元素可以是任意类型，即使它们的类型中都有sayHello()方法，也肯定无法在编译优化的时候就确定具体sayHello()的代码在哪里， 编译器只能不停编译它所遇见的每一个sayHello()方法，并缓存起来供执行时选择、调用和内联，如果arrays数组中不同类型的对象很多，就势必会对内联缓存产生很大的压力，缓存的大小总是有限的，类型信息的不确定性导致了缓存内容不断被失效和更新，先前优化过的方法也可能被不断替换而无法重 复使用。所以这种动态类型方法调用的底层问题终归是应当在Java虚拟机层次上去解决才最合适。因此，在Java虚拟机层面上提供动态类型的直接支持就成为Java平台发展必须解决的问题，这便是JDK 7时JSR-292提案中invokedynamic指令以及java.lang.invoke包出现的技术背景。</p>
<h2 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a>java.lang.invoke包</h2><p>JDK 7时新加入的java.lang.invoke包是JSR 292的一个重要组成部分，这个包的主要目的是在之前 单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）。</p>
<p>但在之前Java语言中做不到这一点，没有办法单独把一个函数作为参数进行传递。普遍的做法是设计 一个带有compare()方法的Comparator接口，以实现这个接口的对象作为参数。</p>
<p>不过，在拥有方法句柄之后，Java语言也可以拥有类似于函数指针或者委托的方法别名这样的工具了。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"><span class="comment">/** * JSR 292 MethodHandle基础用法演示 * <span class="doctag">@author</span> zzm */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA(); <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。 </span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"icyfenix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和 具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接 收者，也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo() 方法来完成这件事情。</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法getPrintlnMH()中实际上是模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固 化在Class文件的字节码上，而是通过一个由用户设计的Java方法来实现。而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。</p>
<p>仅站在Java语言的角度看，MethodHandle在使用方法和效果上与Reflection有众多相似之 处。不过，它们也有以下这些区别：</p>
<ul>
<li>Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的 java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是方法在Java端的全面映像，包含了方法 的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而 后者仅包含执行该方法的相关信息。用开发人员通俗的话来讲，Reflection是重量级，而MethodHandle是轻量级。</li>
<li>由于MethodHandle是对字节码的方法指令调用的模拟，那理论上虚拟机在这方面做的各种优化 （如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还在继续完善中），而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施。</li>
<li>Reflection API的设计目标是只为Java语言服务的，而MethodHandle 则设计为可服务于所有Java虚拟机之上的语言，其中也包括了Java语言而已，而且Java在这里并不是主角。</li>
</ul>
<h3 id="nvokedynamic指令"><a href="#nvokedynamic指令" class="headerlink" title="nvokedynamic指令"></a>nvokedynamic指令</h3><p>某种意义上可以说invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4 条“invoke*”指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机 转嫁到具体用户代码之中，让用户（广义的用户，包含其他程序语言的设计者）有更高的自由度。而且，它们两者的思路也是可类比的，都是为了达成同一个目的，只是一个用上层代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。</p>
<p>每一处含有invokedynamic指令的位置都被称作“<strong>动态调用点</strong>（Dynamically-Computed Call Site）”， 这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK 7 时新加入的CONSTANT_InvokeDynamic_info常量，从这个新常量中可以得到3项信息：引导方法 （Bootstrap Method，该方法存放在新增的BootstrapMethods属性中）、方法类型（MethodType）和 名称。引导方法是有固定的参数，并且返回值规定是java.lang.invoke.CallSite对象，这个对象代表了<strong>真正要执行的目标方法调用</strong>。根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用到要执行的目标方法上。</p>
<h1 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h1><h2 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h2><p>无论是解释还是编译，也无论是物理机还是虚拟机，对于应用程序，机器都不可能如人那样阅 读、理解，然后获得执行能力。大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤。</p>
<p><img src="/images/深入理解JVM/编译过程.jpg" alt="编译过程"></p>
<p>在Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法 树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p>
<h2 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h2><p>Javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。</p>
<p>与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令 集，如果说得更通俗一些就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作。</p>
<p>例如分别使用这两种指令集去计算“1+1”的结果，基于栈的指令集会是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconst_1 </span><br><span class="line">iconst_1 </span><br><span class="line">iadd</span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure>
<p>两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果 放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个变量槽中。这种指令流中的指令通常都是 不带参数的，使用操作数栈中的数据作为指令的运算输入，指令的运算结果也存储在操作数栈之中。</p>
<p>而如果用基于寄存器的指令集，那程序可能会是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, 1 </span><br><span class="line">add eax, 1</span><br></pre></td></tr></table></figure>
<p>mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。 这种二地址指令是x86指令集中的主流，每个指令都包含两个单独的输入参数，依赖于寄存器来访问和存储数据。</p>
<h3 id="基于栈的指令集优点"><a href="#基于栈的指令集优点" class="headerlink" title="基于栈的指令集优点"></a>基于栈的指令集优点</h3><ul>
<li>可以由虚拟机实现来自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存等）放到 寄存器中以获取尽量好的性能，这样实现起来也更简单一些。</li>
<li>代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）</li>
<li>编译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈上操作）</li>
</ul>
<h3 id="基于栈的指令集缺点"><a href="#基于栈的指令集缺点" class="headerlink" title="基于栈的指令集缺点"></a>基于栈的指令集缺点</h3><ul>
<li>理论上执行速度相对来说会稍慢一些（所有主流物理机的指令集都是 寄存器架构[3]也从侧面印证了这点）</li>
</ul>
<p>其原因在于：</p>
<ul>
<li>在解释执行时，栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。</li>
<li>更重要的是栈实现在内存中， 频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚 拟机可以采取栈顶缓存的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是 优化措施而不是解决本质问题的方法。因此由于指令数量和内存访问的原因，导致了栈架构指令集的执行速度会相对慢上一点。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机执行子系统</tag>
        <tag>虚拟机字节码执行引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>经典1-在浏览器地址栏输入URL后回车，背后所经历的步骤</title>
    <url>/2021/03/05/%E7%BB%8F%E5%85%B81-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%9B%9E%E8%BD%A6%EF%BC%8C%E8%83%8C%E5%90%8E%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="在浏览器地址栏输入URL后回车，背后所经历的步骤"><a href="#在浏览器地址栏输入URL后回车，背后所经历的步骤" class="headerlink" title="在浏览器地址栏输入URL后回车，背后所经历的步骤"></a>在浏览器地址栏输入URL后回车，背后所经历的步骤</h1><h2 id="浏览器层面"><a href="#浏览器层面" class="headerlink" title="浏览器层面"></a>浏览器层面</h2><h3 id="0、URL解析"><a href="#0、URL解析" class="headerlink" title="0、URL解析"></a>0、URL解析</h3><p>现在几乎所有浏览器都实现了地址栏快捷搜索的功能，所以这里需要判断用户输入的到底是关键词还是地址，然后进行不同的操作。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>使用浏览器内置的搜索引擎地址与关键词来拼接得到最终的URL。</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>对URL进行补全，编码转换等工作。</p>
<p>例如：用户在输入URL时，一般都不会携带协议与端口。当用户输入<code>baidu.com</code>的时候，浏览器会将其补全为：</p>
<p><code>https://baidu.com:80</code>。</p>
<p>chrome默认是补全<code>https</code>协议</p>
<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p>浏览器还会进行其他操作，比如</p>
<h5 id="历史记录缓存检查"><a href="#历史记录缓存检查" class="headerlink" title="历史记录缓存检查"></a>历史记录缓存检查</h5><p>这一步即可以让我们直接访问之前访问过的URL。</p>
<h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><p>有些浏览器会对部分网站进行拦截。</p>
<h3 id="1、缓存检查"><a href="#1、缓存检查" class="headerlink" title="1、缓存检查"></a>1、缓存检查</h3><p>根据浏览器缓存原则，其会优先检查本地是否已经有缓存文件，然后再向服务器发送请求，具体流程如下：</p>
<p><img src="\images\浏览器-URL\cache-check.jpg" alt="缓存检查"></p>
<h3 id="2-1、-浏览器检查DNS缓存（DNS查询1）"><a href="#2-1、-浏览器检查DNS缓存（DNS查询1）" class="headerlink" title="2.1、 浏览器检查DNS缓存（DNS查询1）"></a>2.1、 浏览器检查DNS缓存（DNS查询1）</h3><p>浏览器检查自己是否有该域名的DNS的缓存。</p>
<h2 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h2><h3 id="2-2、-操作系统检查DNS缓存（DNS查询2）"><a href="#2-2、-操作系统检查DNS缓存（DNS查询2）" class="headerlink" title="2.2、 操作系统检查DNS缓存（DNS查询2）"></a>2.2、 操作系统检查DNS缓存（DNS查询2）</h3><p>如果浏览器查询DNS失败，则调用系统的API进行DNS查询，系统则会先检查自己的本地缓存文件。</p>
<h3 id="2-3、-路由器检查DNS缓存（DNS查询3）"><a href="#2-3、-路由器检查DNS缓存（DNS查询3）" class="headerlink" title="2.3、 路由器检查DNS缓存（DNS查询3）"></a>2.3、 路由器检查DNS缓存（DNS查询3）</h3><p>系统在本地文件中没有发现改DNS条目的时候，请求会依次向上请求，其中路由器也会保有自己的DNS表，也会进行查询。</p>
<h3 id="2-4、ISP-Internet-Service-Provider-DNS缓存"><a href="#2-4、ISP-Internet-Service-Provider-DNS缓存" class="headerlink" title="2.4、ISP(Internet Service Provider) DNS缓存"></a>2.4、ISP(Internet Service Provider) DNS缓存</h3><p>即互联网服务提供商（移动、联通、典型等）的DNS缓存服务器。</p>
<h3 id="2-5、根域名服务器查询DNS缓存"><a href="#2-5、根域名服务器查询DNS缓存" class="headerlink" title="2.5、根域名服务器查询DNS缓存"></a>2.5、根域名服务器查询DNS缓存</h3><p>根域名服务是最高层次的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。</p>
<p>如果上面几步都没有查询到对应的DNS缓存，则请求会被发送到根域名服务器查询。</p>
<h3 id="2-6、顶级域名服务器查询（如：org域名服务器、com域名服务器、deu域名服务器）"><a href="#2-6、顶级域名服务器查询（如：org域名服务器、com域名服务器、deu域名服务器）" class="headerlink" title="2.6、顶级域名服务器查询（如：org域名服务器、com域名服务器、deu域名服务器）"></a>2.6、顶级域名服务器查询（如：org域名服务器、com域名服务器、deu域名服务器）</h3><p>在多数情况下，根域名服务器并不会直接返回IP地址，而是告诉请求应该去请求哪一个顶级服务器（即告诉该顶级服务器的IP地址，系统再请求顶级服务器拿到目标IP地址）</p>
<p>注意：应用层的DNS（域名系统）在传输层采用的是UDP协议。下面是运输层与应用的对应：</p>
<p><img src="\images\浏览器-URL\运输层-应用层.jpg" alt="运输层-应用层"></p>
<h3 id="建立TCP链接"><a href="#建立TCP链接" class="headerlink" title="建立TCP链接"></a>建立TCP链接</h3><p>由于HTTP协议是建立在TCP协议之上，所以客户端与服务器之间需要先建立TCP连接，然后再在TCP连接之上发送HTTP请求。</p>
<p>注意：在五层协议中：</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p>中，上面4层都会有一个头部<code>head</code>来对正文进行封装，物理层传输的数据单位是<code>bit</code>，所以流程大概如下：</p>
<p><img src="\images\浏览器-URL\head.jpg" alt="head"></p>
<p>在服务器接受到数据包后，会对报文进行一层一层的去头部，并在每层进行处理，主要是在传输层，TCP协议会进行连接确定，即三次握手过程。</p>
<ol>
<li><p>第一次</p>
<p>第一次握手：建立连接时，客户端发送syn包（初始序号seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。注意：这个请求不能带数据，但是会消耗一个序号。</p>
</li>
<li><p>第二次</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包（即把报文中的SYN和ACK都设为1），此时服务器进入SYN_RECV状态。</p>
</li>
<li><p>第三次</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
</li>
</ol>
<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><h4 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h4><p>由于HTTP是无状态的，所以HTTP只能一次一次的进行。在客户端与服务器建立TCP连接后，客户端开始发送HTTP请求，此处URL的请求是<code>GET</code>方式的。</p>
<h4 id="服务器返回"><a href="#服务器返回" class="headerlink" title="服务器返回"></a>服务器返回</h4><h5 id="接受请求"><a href="#接受请求" class="headerlink" title="接受请求"></a>接受请求</h5><p>在HTTP请求到达服务器之后，一般会有一些容器来监听HTTP请求，具体的容器有：</p>
<ul>
<li>Apache </li>
<li>Nginx</li>
<li>IIS</li>
</ul>
<p>这些容器会开启一个子进程来处理这个请求。</p>
<h5 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h5><p>接受HTTP报文后，会对其进行解析，获得其中的一些参数（请求方法、域名、路径、来源等），然后对其中的一些参数进行验证：</p>
<ul>
<li>验证是否接受此方法</li>
<li><p>验证请求的地址是否正确</p>
</li>
<li><p>等</p>
</li>
</ul>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>如果服务器对该请求地址配置了HTTP重定向，则会返回301永久重定向响应，浏览器会根据响应，重新发送HTTP请求到重定向地址。</p>
<h2 id="浏览器层面（接受HTTP请求）"><a href="#浏览器层面（接受HTTP请求）" class="headerlink" title="浏览器层面（接受HTTP请求）"></a>浏览器层面（接受HTTP请求）</h2><p>浏览器在接受到服务器的响应消息后，会对资源进行分析。</p>
<p>首先是分析<code>Response header</code>，根据状态码做具体的动作。</p>
<p>如果进行了压缩（比如<code>gzip</code>），还需要进行解压。</p>
<p>然后对相应资源做缓存。</p>
<p>然后根据响应资源里的<code>MIME</code>类型去解析响应内容（比如HTML，JSON等）</p>
<h3 id="渲染页面（如果响应是HTML文件）"><a href="#渲染页面（如果响应是HTML文件）" class="headerlink" title="渲染页面（如果响应是HTML文件）"></a>渲染页面（如果响应是HTML文件）</h3><p>浏览器渲染过程很复杂，其基本流程为：</p>
<p><img src="\images\浏览器-URL\render-process.jpg" alt="render-process"></p>
<h4 id="HTML解析（构建DOM树）"><a href="#HTML解析（构建DOM树）" class="headerlink" title="HTML解析（构建DOM树）"></a>HTML解析（构建DOM树）</h4><h5 id="1-解码（encoding）"><a href="#1-解码（encoding）" class="headerlink" title="1. 解码（encoding）"></a>1. 解码（encoding）</h5><p>传输回来的其实一些二进制数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML代码。</p>
<h5 id="2-预解析（pre-parsing）"><a href="#2-预解析（pre-parsing）" class="headerlink" title="2.预解析（pre-parsing）"></a>2.预解析（pre-parsing）</h5><p>预解析做的事情是提前加载资源，减少处理事件，系统会识别一些请求资源的属性，比如<code>img</code>标签，<code>video</code>的<code>src</code>属性，并将其加入到请求队列中。</p>
<h5 id="3-符号化（Tokenization）"><a href="#3-符号化（Tokenization）" class="headerlink" title="3. 符号化（Tokenization）"></a>3. 符号化（<strong>Tokenization</strong>）</h5><p>符号化就是词法分析的过程，将HTML代码解析成为符号，HTML符号包括，开始标签、结束标签、属性名和属性值。</p>
<h5 id="4-构建树"><a href="#4-构建树" class="headerlink" title="4. 构建树"></a>4. 构建树</h5><blockquote>
<p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p>
</blockquote>
<p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p>
<h4 id="CSS解析（构建CSSOM树）"><a href="#CSS解析（构建CSSOM树）" class="headerlink" title="CSS解析（构建CSSOM树）"></a>CSS解析（构建CSSOM树）</h4><p>当CSS被下载后，CSS解析器就会处理任何CSS，根据语法规范解析出所有的CSS并进行标记化，然后我们得到一个规则表。</p>
<h5 id="CSS匹配规则"><a href="#CSS匹配规则" class="headerlink" title="CSS匹配规则"></a>CSS匹配规则</h5><p>在匹配一个节点对应的CSS规则时，是按照从右到左的顺序，例如<code>div p { font-size :14px }</code>，会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。</p>
<p>所以我们在写选择器的时候，尽量用id和class，不要用太多层级的选择器。</p>
<h4 id="渲染树"><a href="#渲染树" class="headerlink" title="渲染树"></a>渲染树</h4><p>这个过程是一个DOM树与CSS规则树合并的过程。</p>
<blockquote>
<p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p>
</blockquote>
<h5 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h5><p>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p>
<h5 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h5><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p>
<ol>
<li><code>!important</code></li>
<li>内联样式</li>
<li>id、class、标签名</li>
</ol>
<p>的顺序来计算准确的样式。</p>
<h5 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h5><p>在<a href="https://michaelwang.top/2021/02/09/JavaScript%E5%AE%8F%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8EEvent-loop/" target="_blank" rel="noopener">JavaScript宏任务，微任务与Event-loop</a>中，简单介绍了浏览器进程，其中一点是JavaScript线程与GUI渲染线程无法同时进行，遇到JavaScript标签，就会暂停DOM树的解析。</p>
<p>所以如果要对DOM树进行操作或者不阻塞页面，应当将<code>script</code>标签放在<code>body</code>标签的底部，或者使用<code>defer</code>与<code>async</code>，下面是<code>defer</code>与<code>async</code>的区别：</p>
<p><img src="\images\浏览器-URL\defer-async.webp" alt="defer-async"></p>
<h4 id="布局与绘制"><a href="#布局与绘制" class="headerlink" title="布局与绘制"></a>布局与绘制</h4><p>确定渲染树中的所有节点的几何属性，位置，大小等。最后输入一个盒模型，然后遍历渲染树，将其渲染在屏幕中。</p>
<h4 id="合并渲染层"><a href="#合并渲染层" class="headerlink" title="合并渲染层"></a>合并渲染层</h4><p>将以上绘制的所有图片合并，最终输出一张图片。</p>
<h4 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h4><h5 id="回流（reflow）"><a href="#回流（reflow）" class="headerlink" title="回流（reflow）"></a>回流（reflow）</h5><p>当浏览器发现某个部分发生变化并且影响了布局时，需要倒回去重新渲染，会从<code>html</code>标签开始递归往下，重新计算位置和大小。</p>
<p> 因为回流可能导致整个dom树的重新构造，所以会影响性能。</p>
<h5 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h5><p>当浏览器发现某个部分发生变化但是没有影响布局的时候，比如：改变某个元素的背景色，文字颜色等，就会发生重回。</p>
<p>每次重绘后，浏览器还需合并渲染层并输出到屏幕上。</p>
<p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p>
<p>比如：</p>
<ul>
<li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li>
</ul>
<p>因为：</p>
<p>display:none会脱离文档流，不占据页面空间；</p>
<p>visibility:hidden,只是隐藏内容，并没有脱离文档流，会占据页面的空间。</p>
<h4 id="JavaScript编译执行"><a href="#JavaScript编译执行" class="headerlink" title="JavaScript编译执行"></a>JavaScript编译执行</h4><p>这里涉及到编译原理的过程，大概是：</p>
<p><img src="\images\浏览器-URL\JavaScript.jpg" alt="JavaScript"></p>
<h5 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h5><p>JavaScript脚本加载完成后，会首先进入词法分析阶段，首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。具体有：</p>
<ul>
<li>分词，例如将<code>var a = 2</code>，分成<code>var</code>、<code>a</code>、<code>=</code>，<code>2</code>这样的词法单元。</li>
<li>解析：将词法单元转换为抽象语法树<code>AST</code>。</li>
<li>代码生成，将抽象语法树转换成机器指令。</li>
</ul>
<h5 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h5><p>JavaScript中有三种运行环境：</p>
<ul>
<li>全局环境</li>
<li>函数环境</li>
<li>eval</li>
</ul>
<p>（ES6的<code>let</code>，<code>const</code>会生成块级作用域）</p>
<p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/80551769" target="_blank" rel="noopener">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></li>
<li>计算机网络-谢希仁</li>
</ul>
]]></content>
      <categories>
        <category>经典面试题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>经典面试题</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>考研遇到了问题！！！</title>
    <url>/2020/04/22/%E8%80%83%E7%A0%94%E9%81%87%E5%88%B0%E4%BA%86%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h1 id="回顾考研与2020"><a href="#回顾考研与2020" class="headerlink" title="回顾考研与2020"></a>回顾考研与2020</h1><p>想想考试复习考研已经有整整3个多月了，大概一月下旬就开始复习了！</p>
<p>首先复习了两门科目</p>
<ul>
<li>数学</li>
<li>英语</li>
</ul>
<p>数学采用了看视频的方式进行了一轮复习，到四月十号左右就完成了。</p>
<p>英语的话由于最开始没有资料，只有几套真题，所以我直接上手真题。当然，错误率非常之高，问题只有一点：单词和短语积累不够，感觉每一道题，只要单词，短语90%理解，那基本不会错的。所以后面开始用百词斩背单词。由于之前背过，所以考研的词汇还有事多天就要背完了，当然会忘记，所以在考研的过程中，要不间断的背下去。</p>
<p>总体回顾的话，我感觉4月之前，也就是1,2,3月份的状态比较好，早上做英语，下午看视频学习数学，晚上复习数学。作息比较规律，至少可以做到不赖床。</p>
<h1 id="四月的问题"><a href="#四月的问题" class="headerlink" title="四月的问题"></a>四月的问题</h1><p>进入四月，数学的基础部分基本完成，英语也看了许多视频，把刘晓艳得语法，长难句都看了一遍。书也差不多过了一遍。但是接近四月中旬时出现了很大的问题：</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>身体出现了问题：<ol>
<li>最开始是牙龈出血严重，平时都能感觉口型腔内的血腥味</li>
<li>耳鸣开始困扰我，只要周围声音一大，耳膜就开始震动，耳朵很敏感；晚上睡觉时耳鸣严重（倒是没太影响睡眠）。后来去检测发现鼻炎严重，开始治疗鼻炎。</li>
</ol>
</li>
<li>开始上课了，导致不得不频繁的使用电子设备，很容易分心。</li>
<li>看书感觉很难集中精力去想问题，看着讲义上的内容，完全不想动脑。</li>
<li>不节制玩游戏。</li>
<li>聊天过于频繁。</li>
</ol>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>既然出现的问题，就必须去解决问题。否则只会被问题一点点拖垮！以我现在的状态，不配考上研究生！</p>
<ol>
<li>对于身体问题，只能说加紧治疗，毕竟没有更好的办法，只要不影响学习（但是我感觉最近这一系列问题的出现都是身体问题引起的）。</li>
<li>上完课就将电子设备放到远离自己的位置，避免手能够直接接触。</li>
<li>难集中精力，我觉得80%因为电子设备在旁边，所以先实行方法2，看是否还有其他原因。</li>
<li>立刻戒掉游戏，可以在周末玩一会。</li>
<li>当断不断，必受其乱！现在不是时候！</li>
</ol>
<h1 id="接下来的安排"><a href="#接下来的安排" class="headerlink" title="接下来的安排"></a>接下来的安排</h1><p>既然选择了考研，我就不会退缩！所以我有以下安排来恢复状态，想想高中时一天学习14.5个小时的时候，现在这些算的了什么？！毕竟我是南实出来的人，还是练出来了吧！</p>
<p>想想自己为什么考研？之前的我还不是很明确，但是现在，我觉得考研的目的很简单，就是为了实现自己的人生目标，<strong>实现阶级的跨越</strong>，在这样一个阶级越来越固化的时代，中国为底层提供了一个很好的工具，就是读书。起码读完硕士，就迈入了中薪阶层。后面在考虑是否读博士，现在的我并不很排斥继续读博士。</p>
<p>具体措施如下：</p>
<ol>
<li>恢复斗志很关键，必须要恢复斗志，这是一切的来源！</li>
<li>尽量隔离电子设备，学习时不看手机！</li>
<li>每天计划，用纸打印表格。</li>
<li>每周总结，并发布到博客上。</li>
<li>规律作息，早上6:30起床，晚上23:30睡觉。</li>
<li>每周天放松，早上看书，下午玩游戏，晚上看技术文章，写总结。（作息仍然不变！）</li>
</ol>
<h1 id="一定要坚持下去"><a href="#一定要坚持下去" class="headerlink" title="一定要坚持下去"></a>一定要坚持下去</h1><p>最开始我在想考研该是有多困难啊！那么多人考不上，后来我才发现原来不是考研难，而是复习的这个过程最困难。不比高中，有人24hours的监督你来学习，时间制定好，饭做好。大部分人可能都没有高考时一半用心，所以考上的人那么少。我现在是真的体会到了他们常说的一句话，考研比的是坚持，比的是身体，比的是自律！一点没错！智商的影响只在于你是否能考上北大清华。加油，记住你对自己的定位！</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类的几种算法简述</title>
    <url>/2021/08/11/%E8%81%9A%E7%B1%BB%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><p>聚类是无监督学习中应用最广泛的算法。聚类会将数据集中的样本划分为若干个不同的子集，每个子集称为一个簇。</p>
<h2 id="原型聚类"><a href="#原型聚类" class="headerlink" title="原型聚类"></a>原型聚类</h2><p>原型聚类假设聚类结构能通过一组原型刻画。通常情况下，该类算法先对原型进行初始化，然后对原型进行迭代更新求解。</p>
<h3 id="k均值算法（k-means）"><a href="#k均值算法（k-means）" class="headerlink" title="k均值算法（k-means）"></a>k均值算法（k-means）</h3><p>该算法的目的是最小化每个簇中每个样本到对应原型的距离。</p>
<p>但是直接求解的话会是一个NP难问题，较难求解，因此我们仍然采用迭代更新的贪心算法来求解可能的最近似解。值得注意的是，这样并不一定能求得最优解。</p>
<p>其算法大致思想如下：</p>
<ol>
<li>初始化簇的数目K和一组原型向量（从样本中随机选择K个）</li>
<li>迭代每个样本和原型向量，为每个样本找到其距离最近的簇，并将其划为到对应的簇中。</li>
<li>重新计算每个簇对应的原型向量</li>
<li>检查新的原型向量和原来的原型向量是否相等，如果全部更新就停止迭代，即找到了最近似解。</li>
</ol>
<p>python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Tue Aug 10 15:17:10 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: mw530</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProBasedClusterin</span>:</span></span><br><span class="line">    clusterNum = <span class="number">3</span></span><br><span class="line">    data = <span class="literal">None</span></span><br><span class="line">    dataLen = <span class="number">0</span></span><br><span class="line">    clusterVector = []</span><br><span class="line">    clusterSplit = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,  data, clusterNum = <span class="number">3</span>)</span>:</span></span><br><span class="line">        self.clusterNum = clusterNum</span><br><span class="line">        self.data = data</span><br><span class="line">        self.dataLen = data.shape[<span class="number">0</span>]</span><br><span class="line">        randArray = self.uniqueRandInt(clusterNum, <span class="number">0</span>, self.data.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(clusterNum):</span><br><span class="line">            self.clusterVector.append(data[randArray[i]])</span><br><span class="line">            self.clusterSplit.append([])</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueRandInt</span><span class="params">(self, num, low, high)</span>:</span></span><br><span class="line">        randArray = []</span><br><span class="line">        currNum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> currNum &lt; num:</span><br><span class="line">            randInt = np.random.randint(low, high)</span><br><span class="line">            <span class="keyword">if</span> randInt <span class="keyword">not</span> <span class="keyword">in</span> randArray:</span><br><span class="line">                randArray.append(randInt)</span><br><span class="line">                currNum += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> randArray</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eucDistance</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.sqrt(np.sum((x - y)**<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self)</span>:</span></span><br><span class="line">        vectorChangeNum = <span class="number">-1</span></span><br><span class="line">        cycle = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> vectorChangeNum != <span class="number">0</span>:</span><br><span class="line">            cycle += <span class="number">1</span></span><br><span class="line">            vectorChangeNum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.clusterNum):</span><br><span class="line">                self.clusterSplit[i] = []</span><br><span class="line">            <span class="comment"># 将每个样本分到对应的簇</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.dataLen):</span><br><span class="line">                minDis  = <span class="number">9999999</span></span><br><span class="line">                clusterIndex = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(self.clusterNum):</span><br><span class="line">                    dis = self.eucDistance(self.data[i], self.clusterVector[j])</span><br><span class="line">                    <span class="keyword">if</span>(dis &lt; minDis):</span><br><span class="line">                        minDis = dis</span><br><span class="line">                        clusterIndex = j</span><br><span class="line">                self.clusterSplit[clusterIndex].append(self.data[i])</span><br><span class="line">            <span class="comment"># print(self.clusterSplit)</span></span><br><span class="line">            print(<span class="string">"##############################"</span>)</span><br><span class="line">            <span class="comment">#计算每个簇的新原型向量</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.clusterNum):</span><br><span class="line">                vector = np.mean(self.clusterSplit[i], axis=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (vector == self.clusterVector[i]).all():</span><br><span class="line">                    vectorChangeNum += <span class="number">1</span></span><br><span class="line">                self.clusterVector[i] = vector</span><br><span class="line">            print(<span class="string">"第"</span>, cycle, <span class="string">"次遍历"</span>, <span class="string">"有"</span>, vectorChangeNum, <span class="string">"个原型向量不同"</span>)</span><br><span class="line">            <span class="keyword">if</span> vectorChangeNum == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"找到最佳原型向量，共循环"</span>, cycle, <span class="string">"次"</span>)</span><br><span class="line">        <span class="keyword">return</span> self.clusterSplit</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadData</span><span class="params">(name)</span>:</span></span><br><span class="line">    path = <span class="string">'./data/'</span> + name</span><br><span class="line">    file = open(path, <span class="string">'r'</span>)</span><br><span class="line">    csv = pd.read_csv(file)</span><br><span class="line">    arr = np.array(csv)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">data = loadData(<span class="string">'cetics_game.csv'</span>)</span><br><span class="line"><span class="comment"># print(data[1:20, :])</span></span><br><span class="line">clustering = ProBasedClusterin(data)</span><br><span class="line">clusterSplit = clustering.train()</span><br><span class="line"><span class="comment"># print(clusterSplit)</span></span><br></pre></td></tr></table></figure>
<h3 id="学习向量量化（Learning-Vector-Quantization）"><a href="#学习向量量化（Learning-Vector-Quantization）" class="headerlink" title="学习向量量化（Learning Vector Quantization）"></a>学习向量量化（Learning Vector Quantization）</h3><p>该算法仍然属于原型聚类，因此与K均值相似。也是试图使用一组原型向量来刻画聚类结构。但是该算法假设每个样本有一个标记，学习算法的过程会利用样本的这些监督信息来辅助聚类。</p>
<p>其算法大致思想如下:</p>
<ol>
<li>初始化学习率 μ，原型向量的个数K，K个原型向量（从样本中随机选择）</li>
<li>从样本集随机选择一个样本x，迭代每个原型向量，找到距离x最近的原型向量p。</li>
<li></li>
<li>根据公式p = p ± μ * (x - p) 更新该原型向量。（如果x与p标记相同为＋，否则为-）</li>
</ol>
<p>注意该算法的迭代一般就人为确定循环次数。</p>
<p>python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Tue Aug 10 18:34:25 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: mw530</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LearningVectorQuan</span>:</span></span><br><span class="line">    protoVecNum = <span class="number">0</span></span><br><span class="line">    eTa = <span class="number">0.5</span></span><br><span class="line">    data = <span class="literal">None</span></span><br><span class="line">    dataLen = <span class="number">0</span></span><br><span class="line">    labels =<span class="literal">None</span></span><br><span class="line">    protoVector = []</span><br><span class="line">    protoLabels = []</span><br><span class="line">    cycleNum = <span class="number">1000</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, labels, protoVecNum = <span class="number">3</span>, eTa = <span class="number">0.5</span>, cycleNum = <span class="number">1000</span>)</span>:</span></span><br><span class="line">        self.protoVecNum = protoVecNum</span><br><span class="line">        self.eTa = eTa</span><br><span class="line">        self.cycleNum = cycleNum</span><br><span class="line">        self.data = data</span><br><span class="line">        self.labels = labels</span><br><span class="line">        self.dataLen = self.data.shape[<span class="number">0</span>]</span><br><span class="line">        randInt = self.uniqueRandInt(self.protoVecNum, <span class="number">0</span>, self.dataLen - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> randInt:</span><br><span class="line">            self.protoVector.append(self.data[i])</span><br><span class="line">            self.protoLabels.append(self.labels[i])</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueRandInt</span><span class="params">(self, num, low, high)</span>:</span></span><br><span class="line">        randArray = []</span><br><span class="line">        currNum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> currNum &lt; num:</span><br><span class="line">            randInt = np.random.randint(low, high)</span><br><span class="line">            <span class="keyword">if</span> randInt <span class="keyword">not</span> <span class="keyword">in</span> randArray:</span><br><span class="line">                randArray.append(randInt)</span><br><span class="line">                currNum += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> randArray</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eucDistance</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.sqrt(np.sum((x - y)**<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.cycleNum):</span><br><span class="line">            randIndex = np.random.randint(<span class="number">0</span>, self.dataLen - <span class="number">1</span>)</span><br><span class="line">            randData = self.data[randIndex]</span><br><span class="line">            randLabel = self.labels[randIndex][<span class="number">0</span>]</span><br><span class="line">            minIndex = <span class="number">-1</span></span><br><span class="line">            minDis = <span class="number">9999999</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.protoVecNum):</span><br><span class="line">                dis = self.eucDistance(randData, self.protoVector[j])</span><br><span class="line">                <span class="keyword">if</span> dis &lt; minDis:</span><br><span class="line">                    minDis = dis</span><br><span class="line">                    minIndex = j</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> randLabel == self.labels[minIndex]:</span><br><span class="line">                self.protoVector[minIndex] = self.protoVector[minIndex] + self.eTa * (randData - self.protoVector[minIndex])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.protoVector[minIndex] = self.protoVector[minIndex] - self.eTa * (randData - self.protoVector[minIndex])</span><br><span class="line">        <span class="keyword">return</span> self.protoVector</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadData</span><span class="params">(name)</span>:</span></span><br><span class="line">    path = <span class="string">'./data/'</span> + name</span><br><span class="line">    file = open(path, <span class="string">'r'</span>)</span><br><span class="line">    csv = pd.read_csv(file)</span><br><span class="line">    arr = np.array(csv)</span><br><span class="line">    <span class="keyword">return</span> arr[:, :<span class="number">-1</span>], arr[:, <span class="number">-1</span>:]</span><br><span class="line"></span><br><span class="line">data, labels = loadData(<span class="string">'cetics_game.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(data, labels)</span></span><br><span class="line">clustering = LearningVectorQuan(data, labels)</span><br><span class="line">clusterSplit = clustering.train()</span><br><span class="line">print(np.array(clusterSplit).shape)</span><br></pre></td></tr></table></figure>
<h3 id="高斯混合聚类（高斯分布即正态分布）"><a href="#高斯混合聚类（高斯分布即正态分布）" class="headerlink" title="高斯混合聚类（高斯分布即正态分布）"></a>高斯混合聚类（高斯分布即正态分布）</h3><p>与以上两种算法不同，该算法使用的概率模型来表达聚类原型。</p>
<h2 id="密度聚类"><a href="#密度聚类" class="headerlink" title="密度聚类"></a>密度聚类</h2><p>该算法亦称为“基于密度的聚类”，此类算法假设聚类结构能够通过样本分布的紧密程度确定。并基于可连接样本不断扩展聚类簇以获得最终的聚类结果。</p>
<p>DBSCAN是一种著名的密度聚类算法，它基于一组“邻域”参数（ε，MinPts）来刻画样本分布的紧密程度。给定数据集D，有一下几个概念需要了解。</p>
<ul>
<li>ε-邻域：对于xi∈D，其ε-邻域包括样本集D中与xi距离不大于ε的所有样本。</li>
<li>核心对象：若xi的ε-邻域中至少包含MinPts个样本，则xi为一个核心对象。</li>
<li>密度直达：若xi位于xj的ε-邻域中，且xj是一个核心对象，则称xi由xj密度直达。</li>
<li>密度可达：对于xi和xj，若存在样本序列p1, p2, p3, … , pn，其中p1 = xi, pn = xj, 且pi+1由pi密度直达，则称xj由xi密度直达。</li>
<li>密度相连：对xi与xj，若存在xk使得xi与xj均由xk密度可达，则称xi与xj密度相连。</li>
</ul>
<p>该算法的核心思想如下：</p>
<ol>
<li>算法先根据给定的邻域参数（ε， MinPts）找出所有的核心对象</li>
<li>以任一核心对象为出发点，找出由其密度可达的样本生成聚类簇，直到所有核心对象均被访问过。</li>
</ol>
<h2 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h2><p>层次聚类（hierarchical clustering）试图在不同层次上对数据集进行划分，从而形成树状的聚类结构。数据集的划分可以采用自底向上的聚类策略，也可以采用自顶而下的分拆策略。</p>
<p>AGNES是以这种采用自底向上聚类策略的层次聚类算法。</p>
<p>其算法思想如下：</p>
<ol>
<li>它先将数据集中的每个样本看作一个初始聚类簇。</li>
<li>然后再算法运行的每一步中找出距离最近的两个聚类进行合并，该过程不断重复，直到达到预设的聚类簇个数。</li>
</ol>
<p>注意：以上的代码都是自己手写的，可能会有不足。</p>
]]></content>
      <categories>
        <category>聚类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书总结2-模型评估与选择</title>
    <url>/2021/08/30/%E8%A5%BF%E7%93%9C%E4%B9%A6%E6%80%BB%E7%BB%932-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="经验误差与过拟合"><a href="#经验误差与过拟合" class="headerlink" title="经验误差与过拟合"></a>经验误差与过拟合</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>错误率：分类错误的样本数占样本总数的比例。</p>
<p>精度：1 - 错误率。</p>
<p>训练误差（经验误差）：学习器在训练集上的误差。</p>
<p>泛化误差：学习器在新样本上的误差。</p>
<p>过拟合：把训练样本自身的一些特点当作了所有潜在样本都具有的一般特征。一般无法彻底避免，只能缓解。</p>
<p>欠拟合：与过拟合相反，即对训练样本的一般性质未学习好。</p>
<h1 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h1><h2 id="留出法"><a href="#留出法" class="headerlink" title="留出法"></a>留出法</h2><p>留出法（hold-out）直接将数据集D划分为两个互斥的集合，其中一个集合用作训练集S，另一个作为测试集T。即D=S∪T，S∩T=Ø。</p>
<p>其缺点在于少了一部分数据，所以训练出来的模型必然会有一定的偏差。</p>
<h2 id="交叉验证法"><a href="#交叉验证法" class="headerlink" title="交叉验证法"></a>交叉验证法</h2><p>交叉验证法（cross validation）先将数据集D划分为k个大小相似的互斥子集，即D=D<sub>1</sub>∪D<sub>2</sub>∪…∪D<sub>k</sub>，D<sub>i</sub>∩D<sub>j</sub>=Ø(i ≠ j)。每个子集都尽可能保持数据分布的一致性，即从D通过分层采样获得。然后每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集；这样可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值。通常将其称为“k折交叉验证”。k的最常用取值为10，此时称为10折交叉验证。</p>
<p>其缺点在于时间复杂度会提升，k折即需要训练k次，在高复杂度的算法中，就会有较大影响。</p>
<h2 id="自助法"><a href="#自助法" class="headerlink" title="自助法"></a>自助法</h2><p>自助法是基于自助采样法（bootstrap sampling）。其过程为：每次随机从D中挑选出一个样本，将其“拷贝”到D<sub>1</sub>（注意是拷贝，即D<sub>1</sub>中的数据仍然可以在下一次采样中采集到），这个过程重复执行m次后，我们就得到了包含m个样本的数据集D<sub>1</sub>。</p>
<p>显然，D中的一部分样本会在D<sub>1</sub>中出现多次，也可能一次都不出现。</p>
<p>做一个简单的估计，某一样本x在m次采样中都不出现的概率为：(1 - 1//m)<sup>m</sup>，取极限可得其大概为 1/e = 0.368。即，初始样本集D中约有36.8%的样本未出现在采样集D中D<sub>1</sub>中，所以我们将D<sub>1</sub>作为训练集，D/D<sub>1</sub>作为测试集。这样，实际的评估模型与期望评估的模型都使用了m个训练样本。而仍然有1/3的数据样本没出现在训练集中，可以用于测试。</p>
<p>该方法一般用于样本数量较小，难以有效划分训练集/测试集时。</p>
<p>缺点：改变了初始数据集的分布，这会引入估计偏差。</p>
<h1 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h1><p>性能度量是指衡量模型泛化能力的评价标准。</p>
<h2 id="错误率与精度"><a href="#错误率与精度" class="headerlink" title="错误率与精度"></a>错误率与精度</h2><p>见上文</p>
<h2 id="查准率、查全率与F1"><a href="#查准率、查全率与F1" class="headerlink" title="查准率、查全率与F1"></a>查准率、查全率与F1</h2><table style="border: 1px solid black;"><br>  <tr><br>    <td rowspan="2" style="text-align: center;">真实情况</td><br>    <td colspan="2" style="text-align: center;">预测情况</td><br>  </tr><br>  <tr><br>    <td style="text-align: center;">正例</td><br>    <td style="text-align: center;">反例</td><br>  </tr><br>  <tr><br>    <td style="text-align: center;">正例</td><br>    <td style="text-align: center;">TP(真正例)</td><br>    <td style="text-align: center;">FN(假反例)</td><br>  </tr><br>  <tr><br>      <td style="text-align: center;">反例</td><br>      <td style="text-align: center;">FP(假正例)</td><br>      <td style="text-align: center;">TN(真反例)</td><br>  </tr><br></table>

<p>则查准率 P与查全率R分别为：</p>
<p>P = TP / (TP + FP)</p>
<p>R = TP / (TP + FN)</p>
<p>即查准率为预测正例中真实也正例的比例。</p>
<p>查全率为真实情况为正例中预测也为正例的比例。</p>
<p>查准率和查全率是一对矛盾的度量。</p>
<p>P-R图中面积越小则性能越好。</p>
<p>平衡点（BEP）为 查准率 = 查全率时的取值。</p>
<p>F1 = (2 <em> P </em> R)/ (P + R) = (2 * TP) / (样本总数 + TP - TN)</p>
<p>更一般的形式F<sub>β</sub>：</p>
<p>F<sub>β</sub> = [(1 + β<sup>2</sup>) <em> P </em> R] / [(β<sup>2</sup> * P) + P]</p>
<hr/>

<p>实际上F1是基于查准率与查全率的调和平均（harmonic mean）：</p>
<p>1 / F1 = (1 / 2) * (1 / P + 1 / R)</p>
<p>同样，F<sub>β</sub>则是加权调和平均：</p>
<p>1 / F<sub>β</sub> = 1 / (1 + β<sup>2</sup>) * (1 / P + β<sup>2</sup> / R)</p>
<h2 id="ROC与AUC"><a href="#ROC与AUC" class="headerlink" title="ROC与AUC"></a>ROC与AUC</h2><p>ROC全称为“受试者工作特征”（Receiver Operating Characteristic）曲线。</p>
<p>其纵轴为“真正例率”（True Positive Rate，简称TPR）</p>
<p>横轴为“假正例率”（False Positive Rate，简称FPR）</p>
<p>即：</p>
<p>TPR = TP / (TP + FN)</p>
<p>FPR = FP / (TN + FP)</p>
<hr>

<p>AUC(Area Under ROC Curve)即ROC曲线下的面积。</p>
<h2 id="代价敏感错误率与代价曲线"><a href="#代价敏感错误率与代价曲线" class="headerlink" title="代价敏感错误率与代价曲线"></a>代价敏感错误率与代价曲线</h2><p>一般对于不同的类别，我们错误的预测会造成不同的后果。例如把患者诊断为健康人和把健康人预测为病人，显然前者的后果更加严重。基于此，我们给出以下表格来定义不同的样本之间错误预测的代价：</p>
<table style="border: 1px solid black;"><br>  <tr><br>    <td rowspan="2" style="text-align: center;">真实情况</td><br>    <td colspan="2" style="text-align: center;">预测情况</td><br>  </tr><br>  <tr><br>    <td style="text-align: center;">第0类</td><br>    <td style="text-align: center;">第1类</td><br>  </tr><br>  <tr><br>    <td style="text-align: center;">第0类</td><br>    <td style="text-align: center;">0</td><br>      <td style="text-align: center;">cost<sub>01</sub></td><br>  </tr><br>  <tr><br>      <td style="text-align: center;">第1类</td><br>      <td style="text-align: center;">cost<sub>10</sub></td><br>      <td style="text-align: center;">0</td><br>  </tr><br></table>

<p>所谓代价敏感错误率即要最小化所有样本预测的cost均值最小化。即：</p>
<p><img src="\images\西瓜书总结2-模型评估与选择\代价敏感错误率.jpg" alt="代价敏感错误率"></p>
<p>注：假定上表中的第0类为正例，第1类为反例，令D<sup>+</sup>与D<sup>-</sup>分别代表样例集D的正例子集和反例子集</p>
<hr>

<p>在非均等代价下，ROC曲线不能直接反映出学习器的期望总和代价，而代价曲线（cost curve）可以达到该目的。</p>
<p>其横轴为正概率代价：</p>
<p><img src="\images\西瓜书总结2-模型评估与选择\正概率代价.jpg" alt="正概率代价"></p>
<p>其中p是样例为正例的概率。</p>
<p>纵轴是取值为[0, 1]的归一化代价。</p>
<p><img src="\images\西瓜书总结2-模型评估与选择\归一化代价.jpg" alt="归一化代价"></p>
<p>其中FPR为上面提到的假正例率，</p>
<p>FNR = 1 - TPR是假反例率</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>西瓜书</tag>
        <tag>模型评估与选择</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次Java文件占用的故障排除</title>
    <url>/2022/07/04/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Java%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E7%9A%84%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这个问题是在一个项目中的有一个压缩文件的功能，其服务逻辑比较复杂，如下：</p>
<ol>
<li>生成压缩文件的路径。</li>
<li>调用ZipFile进行压缩。<ol>
<li>确保文件夹是否存在，如果不存在就新建。</li>
<li>看文件是否存在，如果存在就先删除。</li>
<li>新建ZipFile对象。</li>
<li>新建ZipParameters对象。</li>
<li>为zipFile添加文件。</li>
<li>关闭zipFile文件。</li>
</ol>
</li>
<li>为文件生成hash值。</li>
<li>利用hash值生成新的文件名并重命名。</li>
</ol>
<p>主要是第4步这里一直不成功，即重命名返回失败。下面就是排查过程</p>
<h1 id="排除过程"><a href="#排除过程" class="headerlink" title="排除过程"></a>排除过程</h1><h2 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h2><p>对于文件的操作失败，首先应当想到的是文件锁定。然后利用工具查看，确实如此。文件被jdk锁定了。</p>
<p><img src="/images/记录一次Java文件占用的故障排除/lock.jpg" alt="lock"></p>
<h2 id="流的排查"><a href="#流的排查" class="headerlink" title="流的排查"></a>流的排查</h2><p><strong>一般文件锁定都是文件对应的流没有关闭导致的，因为文件流需要从文件中读取数据，所以都会将文件锁定。</strong></p>
<p>由于这里是新建的压缩文件，所以我首先看是否在新建文件的时候是否锁定了文件。</p>
<h2 id="新建文件部分"><a href="#新建文件部分" class="headerlink" title="新建文件部分"></a>新建文件部分</h2><p>值得注意的是，使用<code>new File()</code>时确实会锁定文件，因为这里是对文件的写操作。所以我单步debug。</p>
<p>但是发现并不是这里的问题，一般只要<code>new File()</code>成功，那么就会解除锁定了，因为文件生成了。</p>
<h2 id="压缩库文件"><a href="#压缩库文件" class="headerlink" title="压缩库文件"></a>压缩库文件</h2><p>压缩工具类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFiles</span><span class="params">(List&lt;XPanFile&gt; files, String filePath, Integer compressLevel, Boolean encrypt, String password)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断外围文件夹是否存在，如果不存在则创建</span></span><br><span class="line">        String filePathWithoutName = FileUtils.getFilePathWithoutName(filePath);</span><br><span class="line">        File pathFile = <span class="keyword">new</span> File(filePathWithoutName);</span><br><span class="line">        <span class="keyword">if</span>(!pathFile.exists())&#123;</span><br><span class="line">            pathFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断源文件存在，则删除</span></span><br><span class="line">        File tempFile = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">if</span>(tempFile.exists())&#123;</span><br><span class="line">            tempFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        ZipFile zipFile;</span><br><span class="line">        <span class="keyword">if</span>(encrypt)&#123;</span><br><span class="line">            zipFile = <span class="keyword">new</span> ZipFile(filePath, password.toCharArray());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           zipFile = <span class="keyword">new</span> ZipFile(filePath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ZipParameters zipParameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">        zipParameters.setEncryptFiles(encrypt);</span><br><span class="line">        zipParameters.setCompressionLevel(pairLevel(compressLevel));</span><br><span class="line">        zipParameters.setEncryptionMethod(EncryptionMethod.AES);</span><br><span class="line">        zipParameters.setAesKeyStrength(AesKeyStrength.KEY_STRENGTH_128);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (XPanFile xpanFile : files) &#123;</span><br><span class="line">            String curFileName = xpanFile.getFile_name();</span><br><span class="line">            String absolutePath = FileUtils.getAbsolutePath(xpanFile.getUrl(), <span class="keyword">true</span>);</span><br><span class="line">            File curFile = <span class="keyword">new</span> File(absolutePath);</span><br><span class="line">            zipFile.addFile(curFile, zipParameters);</span><br><span class="line">            zipFile.renameFile(curFileName, xpanFile.getUser_file_name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于Java自代的zip压缩库并没有加密功能，所以我采用了zip4j进行压缩。那么我就怀疑是不是库文件在写入后没有关闭流文件。</p>
<p>然后我发现了zip4j生成文件有一个close方法。我之前是没有加上的。所以在此加上该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zipFile.close();</span><br></pre></td></tr></table></figure>
<p>应该就可行了。</p>
<p>但是结果还是被占用。</p>
<p>我点进了close方法内部，发现其实就是关闭所有的流，包括文件整体的，以及压缩文件内部的子文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Iterator var1 = <span class="keyword">this</span>.openInputStreams.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">        InputStream inputStream = (InputStream)var1.next();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.openInputStreams.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么理论上调用这个方法只要不抛出错误，那么流应该就被关闭完了。那就排除了库文件的占用问题。</p>
<h2 id="绝对不要使用匿名流"><a href="#绝对不要使用匿名流" class="headerlink" title="绝对不要使用匿名流"></a>绝对不要使用匿名流</h2><p>经过上面的过程，我就已经感觉可能不是压缩这一部分的问题了。然后就对着服务代码重新看了一会：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String basePath = FileUtils.generateAvailableFilePath(fileName, <span class="keyword">true</span>);</span><br><span class="line">        String path = basePath + fileName;</span><br><span class="line">        <span class="comment">// 压缩文件</span></span><br><span class="line">        CompressUtils.compressFiles(files, path, compressType, compressLevel, encrypt, password);</span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        String suffix = FileUtils.getSuffix(fileName);</span><br><span class="line">        String fileHash = FileUtils.generateAvailableHash(<span class="keyword">new</span> FileInputStream(path));</span><br><span class="line">        Integer integer = fileMapper.isFileExistsByHash(fileHash);</span><br><span class="line">        FileUtils.renameFile(path, fileHash + <span class="string">"."</span> +suffix);</span><br><span class="line">        <span class="keyword">if</span>(integer == <span class="number">0</span>)&#123;</span><br><span class="line">            XPanFile compressedFile = <span class="keyword">new</span> XPanFile();</span><br><span class="line">            compressedFile.setFile_name(fileHash + <span class="string">"."</span> + suffix);</span><br><span class="line">            compressedFile.setHash(fileHash);</span><br><span class="line">            compressedFile.setPid(pid);</span><br><span class="line">            compressedFile.setGmt_update(now);</span><br><span class="line">            compressedFile.setGmt_create(now);</span><br><span class="line">            String realRelativePath = FileUtils.getRelativePath(FileUtils.getFilePathWithoutName(path) + fileHash + <span class="string">"."</span> +suffix, <span class="keyword">true</span>);</span><br><span class="line">            compressedFile.setUrl(realRelativePath);</span><br><span class="line">            compressedFile.setType(FileUtils.getType(suffix));</span><br><span class="line">            fileMapper.createFile(compressedFile);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 链接用户文件表</span></span><br><span class="line">        fileMapper.createUserFile(fileName, userId, fileHash, pid, now, now);</span><br></pre></td></tr></table></figure>
<p>然后我就突然发现了问题所在（可能认真的话，一眼就看出来了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String fileHash = FileUtils.generateAvailableHash(<span class="keyword">new</span> FileInputStream(path));</span><br></pre></td></tr></table></figure>
<p>没错，这里使用了匿名流！</p>
<p>这里就是问题所在，由于计算hash就必须要读文件，所以我这里就直接传入了一个流。但这里传入的是一个匿名流，所以最后没有关闭。</p>
<h3 id="解决方法1-主动调用垃圾回收"><a href="#解决方法1-主动调用垃圾回收" class="headerlink" title="解决方法1-主动调用垃圾回收"></a>解决方法1-主动调用垃圾回收</h3><p>在找到这个问题之前，我寻找了很多资料，然后发现了一个解决办法：主动调用垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.gc();</span><br></pre></td></tr></table></figure>
<p>这样能解决问题也很容易理解，上面看到是一个匿名流问题，所以如果主动调用垃圾回收，那么这个匿名流就会被回收。当然文件的占用就会被解除了。</p>
<p>但这是著表不治本的方法。相当于是先产生问题，然后去修补它，而没有去找到生成问题的原因。</p>
<h3 id="解决方法1-主动调用垃圾回收-1"><a href="#解决方法1-主动调用垃圾回收-1" class="headerlink" title="解决方法1-主动调用垃圾回收"></a>解决方法1-主动调用垃圾回收</h3><p>因为产生问题的关键在匿名流，那么找到这个问题后，解决就很简单了。那就是将匿名流改成具名流，然后在完成hash计算后，将其关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">String fileHash = FileUtils.generateAvailableHash(fileInputStream);</span><br><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure>
<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>从这次问题中，收获主要有两点：</p>
<ul>
<li>永远不要使用匿名流，特别是文件流，因为不关的话，资源会一直被占用。</li>
<li>做事要仔细，其实如果早一点仔细看代码，可能就直接看出来问题所在了。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书总结3-线性模型</title>
    <url>/2021/09/02/%E8%A5%BF%E7%93%9C%E4%B9%A6%E6%80%BB%E7%BB%933-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h1><p>线性模型（linear model）顾名思义即通过线性函数来进行预测的模型。</p>
<div style="color: #CCCC99;font-size: 13px">大部分机器学习算法的本质都是寻找一个函数来将输入进行处理得到预测结果。这里最简单的线性模型是这样，最复杂的神经网络模型也是如此。</div>

<p>线性模型的一般形式为：</p>
<p>f(<b>x</b>) = w<sub>1</sub>x<sub>1</sub>+w<sub>1</sub>x<sub>1</sub>+…+w<sub>d</sub>x<sub>d</sub>+b</p>
<p>向量形式则为：</p>
<p>f(<b>x</b>) = <b>w</b><sup>T</sup><b>x</b> + b</p>
<p>其中<b>w</b> = (w<sub>1</sub>; w<sub>1</sub>; …;w<sub>d</sub>;)， w和b学得之后，模型就得以确定。</p>
<p>线性模型形式简单、易于构造，但却蕴含着机器学习中一些重要的思想。许多更为强大的非线性模型可在线性模型的基础上通过引入层级结构更高或高维映射而得。</p>
<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>西瓜书</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM1-1-自动内存管理-Java内存区域与内存溢出异常</title>
    <url>/2022/03/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM1-1-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把管理的内存划分为若干个不同的数据区域。</p>
<p>具体如下图。</p>
<p><img src="\images\深入理解JVM\Java虚拟机运行时数据区.png" alt="Java虚拟机运行时数据区"></p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时启动。此内存区域的唯一目的就是存放内存实例，Java世界里几乎所有的对象实例都在这里分配。</p>
<p>Java堆是垃圾收集器管理的内存区域，因此其也被称为GC堆。从内存回收的角度来看，由于现代垃圾收集器大部分都基于分代收集理论，所以Java堆中经常出现“新生代”，“老年代”，“永久代”，“Eden空间”，“From Survivor空间”，“To Survivor空间”等名词。</p>
<h3 id="方法区（非-堆）"><a href="#方法区（非-堆）" class="headerlink" title="方法区（非-堆）"></a>方法区（非-堆）</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做“非堆”（Non-Heap），目的是与Java堆区分开来。</p>
<h3 id="Java虚拟机栈（线程私有）"><a href="#Java虚拟机栈（线程私有）" class="headerlink" title="Java虚拟机栈（线程私有）"></a>Java虚拟机栈（线程私有）</h3><p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>而局部变量存放了编译器可知的各种Java虚拟机基本数据库类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等于对象本身，可能是一个指向内存起始地址的引用 指针，也可能是指向一个代码对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条 字节码指令的地址）</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用非常相似，且u别是虚拟机栈为悉尼及执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到本地（Native）方法服务。</p>
<h3 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h3><p>程序计数器（Program Counter Register）是一块较小的内存，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>值得注意的是：只有当线程执行的是Java方法的时候，这个计数器才记录正在执行的虚拟机字节码指令的地址；如果执行的是原生（Native）方法，这个计数器就为空。</p>
<h3 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h3><p>运行时常量池（Running Constant Pool）是方法区的一部分。class文件中除了有类的版本、字段、接口等描述信息外，还有一项信息是常量池表（Constant Pool Tables），用于存放编译期间生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入运行时常量池，运行期间也可以将新的常量放入池中。这种特性被开发人员用得最多的便是String类的<code>intern()</code>方法</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但也被频繁使用，而且也可能导致OutOfMemoryError异常。</p>
<p>在JDK1.4中新加入了NIO（New Input/Output）类，引用了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。这样能在一些场景中显著提升性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>直接内存不会受到Java堆大小的限制，但是也会受到物理机内存的限制。</p>
<h2 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h2><p>下面简单陈述一下HotSpot虚拟机在Java堆中对象分配、布局和访问的过程。</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当虚拟机遇到一条字节码new指令时，会经历一下步骤：</p>
<ul>
<li>检查这个指令的参数是否能在常量池定位到一个类的符号引用。<ul>
<li>如果能够定位到，则检查这个符号引用代表的类是否已被加载、解析和初始化过。</li>
<li>如果没有则必须先执行响应的类加载过程</li>
</ul>
</li>
<li>在类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可以完全确定。为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。<ul>
<li>一般在内存分配的时候可能会存在多种方案，例如，假如堆中所有被分配的内存都在一侧，而没分配的内存在另一侧，那分配的时候只需要将指针向空闲方向挪动一定距离，这种分配方式被称为指针碰撞。但如果不是分侧分开的，那就需要虚拟机维护一个列表，记录哪些内存是可用的，再分配的时候将对应的位置划分给实例对象，然后更新记录表。</li>
<li>另外在内存分配的时候还可能会遇到冲突的问题，如不同的线程对相同内存区域的划分问题。针对这种问题，一般有两种方案:<ul>
<li>对分配内存空间的动作同步处理-实际上虚拟机是采用CAS配上失败重试的方式更新线程操作的原子性。</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，ATLAB）哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁。</li>
</ul>
</li>
</ul>
</li>
<li>内存分配完之后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时新婚便进行。</li>
<li>接下来虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元信息、对象哈希码、对象的GC分代年龄等信息。这些信息会被存放在对象头（Object Header）中。</li>
<li>在上面的工作完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但从Java程序的视角来看，对象创建才刚刚开始-构造函数，即Class文件中的<code>&lt;init&gt;()</code>方法还没有执行。所有的字段都默认为零值，对象需要的其他资源和状态信息也还没按照预定的意图构造好。</li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充填充（padding）</li>
</ul>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HotSpot虚拟机对象的对象头部分包括两类信息。</p>
<p>第一类是用于存储对象自身的运行时数据，如哈希、GC分代年龄、所状态标志、线程持有的锁、偏向线程的ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中（未开启压缩指针）中分别为32比特和64比特，官方称之为“Mark Word”。由于对象需要存储的信息有很多，其已经超出了对应头部的长度，所以其还设置了标志位，用来标志相同位置可能存放的不同类型的信息。</p>
<p>另一类信息是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。但并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。此外如果对象是一个Java数据，那么在对象头重还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但数据的长度是不确定的，将无法通过元数据重的信息推断出数据的大小。</p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据部分是对象真正存储的有效信息。即程序中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在父类中定义的字段都必须记录起来。这部分的顺序会受到虚拟机分配策略参数（<code>-XX:FieldAllocationStyle</code>参数）和字段在源码中定义的顺序的影响。HotSpot虚拟机默认的分配顺序为<code>long/double</code>、<code>int</code>、<code>short/char</code>、<code>byte/boolean</code>、<code>oops(Ordinary Object Pointers)</code>。从上面默认的分配策略中可以看出，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>对象的第三部分是对其填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动对其内存管理系统要求对象的起始地址必须是8字节的整倍数，换句话说就是任何对象的大小都必须是8字节的整倍数。对象头已经被设计为8字节的倍数，因此，如果对象实例数据部分没有对其的话，就需要通过对其填充来补全。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>创建对象是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。由于《Java虚拟机规范》里面只规定了它是一个指向对象的引用，没有定义这个引用应该通过什么方式去定位、访问到堆中的对象的具体位置，所以对象访问方式也是由虚拟机实现的，主流的访问方式主要有使用句柄和直接指针两种：</p>
<ul>
<li>如果使用访问句柄的话，Java堆中将会划分出一部分内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自具体的地址信息（原理如图）。</li>
<li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销（原理如图）。</li>
</ul>
<p>这两种对象访问方式各有优势：</p>
<ul>
<li>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄，在对象被移动的时候（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄的实例数据指针，而reference本身不需要修改。</li>
<li>使用直接指针来访问最大好处就是更快，因为它节省了一次指针定位的时间开销。由于对象呢噶访问在Java虚拟机中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</li>
</ul>
<p><img src="\images\深入理解JVM\通过句柄访问对象.png" alt="通过句柄访问对象"></p>
<p><img src="\images\深入理解JVM\通过直接访问对象.png" alt="通过直接访问对象"></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本系列文章内容均来自于《深入理解Java虚拟机-JVM高级特征与最佳性能实践》</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>自动内存管理</tag>
        <tag>Java内存区域与内存溢出异常</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式1-单例模式</title>
    <url>/2021/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>最近在写Vue插件，发现自己通过直观想法写的东西总是与别人的插件有一定的差距。我也明白别人的库中用了一种或多种设计模式，使代码结构更加恰当等等。之前就说要学习一下设计模式，被搁置到现在，现在买了《JavaScript设计模式与开发实践》，后面会陆续将自己的学习过程通过博客记录。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的<code>window</code>对象。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="传统单例模式"><a href="#传统单例模式" class="headerlink" title="传统单例模式"></a>传统单例模式</h3><p>JavaScript语言原生设计的时候并没有设计类的概念，并且对象是可以直接通过字面量来新建对象，不一定需要通过类来实例化对象。所以在JavaScript中的单例模式与Java等面向对象语言稍有不同。下面通过传统的面向对象语言的方式来设计单例模式。</p>
<h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>要实现标准的单例模式，无非是要用一个变量来标志当前是否已经为某个类创建过对象，如果创建过，则在下一次创建的时候直接返回该对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.instance = <span class="literal">null</span></span><br><span class="line">Singleton.prototype.getName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">        <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = Singleton.getInstance(<span class="string">'name1'</span>)</span><br><span class="line"><span class="keyword">let</span> b = Singleton.getInstance(<span class="string">'name2'</span>)</span><br></pre></td></tr></table></figure>
<p>或者使用闭包将<code>instance</code>标志放在闭包中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们只能通过<code>getInstance</code>方法来获得该对象。这样增加了该方法的不透明性，不能通过<code>new</code>来创建对象，下面来编写一个头i摩纳哥的单例类。</p>
<h4 id="透明的单例类"><a href="#透明的单例类" class="headerlink" title="透明的单例类"></a>透明的单例类</h4><p>下面来实现一个透明类，来实现一个<code>CreateDiv</code>单例类，他的作用是是负责在页面中创建唯一的<code>div</code>节点，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateDiv =(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">let</span> CreateDiv =<span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.html = html</span><br><span class="line">        <span class="keyword">this</span>.init()</span><br><span class="line">        <span class="keyword">return</span> instance = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">        div.innerHTML = <span class="keyword">this</span>.html</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CreateDiv</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> CreateDiv(<span class="string">'name1'</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> CreateDiv(<span class="string">'name2'</span>)</span><br><span class="line"></span><br><span class="line">a === b		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>这个构造方法虽然完成了一个透明的单例类，但是它同样有一些缺点，即违背了“<strong>单一职责原理</strong>”</p>
<blockquote>
<p><strong>单一职责原则</strong>（SRP：Single responsibility principle）又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定一个类应该只有一个发生变化的原因。</p>
</blockquote>
<h4 id="用代理实现单例模式"><a href="#用代理实现单例模式" class="headerlink" title="用代理实现单例模式"></a>用代理实现单例模式</h4><p>为了实现<strong>单一职责原理</strong>，我们要引入代理类的方式，把负责管理单例的代码分离出去。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.html = html</span><br><span class="line">    <span class="keyword">this</span>.init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    div.innerHTML = <span class="keyword">this</span>.html</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类，可以处理各种类</span></span><br><span class="line"><span class="keyword">let</span> proxyCreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">fn, html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> fn(html)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> ProxySingletonCreateDiv(CreateDiv, <span class="string">'name1'</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> ProxySingletonCreateDiv(CreateDiv, <span class="string">'name2'</span>)</span><br><span class="line"></span><br><span class="line">a === b				<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们将业务代码与管理逻辑分开到两个类中，实现了<strong>单一职责原理</strong>。</p>
<h3 id="JavaScript中的单例模式"><a href="#JavaScript中的单例模式" class="headerlink" title="JavaScript中的单例模式"></a>JavaScript中的单例模式</h3><p>由于JavaScript是一门原生无类(class-free)语言，也是正因如此，生搬硬套单例模式的概念并无意义。</p>
<p>单例模式的核心是：<strong>确保只有一个实例，并提供全局访问。</strong></p>
<p>全局变量不是单例模式，但在JavaScript中，我们经常会把全局变量当成单例来使用。</p>
<p>当我们使用字面量对象在全局作用域下创建对象a时，对象a确实是独一无二的，并且也是可以在任意位置上访问。这样满足单例模式的两个条件。</p>
<p>但是这样会污染全局变量，我们可以使用两种方法：</p>
<ol>
<li>使用命名空间。</li>
<li>使用闭包封装私有变量。</li>
</ol>
<h4 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h4><p>所谓惰性单例就是在需要的时候才创建。实际上上面的单例模式就已经是惰性单例了，在为初始化之前都是<code>null</code>，只有在<code>new</code>的时候才进行创建。</p>
<p>下面用一个实际应用场景，就是登录框的设计：在用户未点击之前，登录框不会显示，点击时才会出现登录框。</p>
<p>这里有几种处理方式：</p>
<ol>
<li>提前将登录框插入到文档中，并将其<code>display</code>属性设置为<code>none</code>，在点击时将<code>display</code>属性设置为<code>block</code>。这样性能问题就是，这个登录框可能永远用不到，这样就浪费了性能。</li>
<li>在用户点击时，使用JavaScript将登录加入文档流；在用户登录成功或者<code>×</code>时，将其从文档流中删除。这样的性能问题也有，就是第一次生成的登陆框实际是可以保存，方便以后使用。</li>
<li>所以最佳方案就是最开始不生成登录框，等用户点击时生成，并且这之后将其<code>display</code>属性设为<code>none</code>，方便以后使用，这样也就是我们的<strong>单例模式</strong>。</li>
</ol>
<p>所以最后的代码如下（已经将业务代码与管理代码分离）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取对应对象单例</span></span><br><span class="line"><span class="keyword">let</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="comment">//使用一个闭包来保存result</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建登录框并返回</span></span><br><span class="line"><span class="keyword">let</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    div.innerHTML = <span class="string">'登录框'</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    <span class="keyword">return</span> div</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建函数的单例</span></span><br><span class="line"><span class="keyword">let</span> createSingleLoginLayer = getSingle(createLoginLayer)</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击事件监听</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'loginBtn'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> loginLayer = createSingleLoginLayer()</span><br><span class="line">    loginLayer.style.display = <span class="string">'block'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消事件监听</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'cancelBtn'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> loginLayer = createSingleLoginLayer()</span><br><span class="line">    loginLayer.style.display = <span class="string">'none1</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单例模式是一个比较重要的单例模式，在进行底层开发或者注重性能的任务中，单例模式可以节省很多消耗，提高性能。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《JavaScript设计模式与开发实践》</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式2-策略模式</title>
    <url>/2021/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一系列的算法，把它们一个个封装起来，并且使他们可以相互替换。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>在多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护的问题。</p>
<h2 id="奖金的例子"><a href="#奖金的例子" class="headerlink" title="奖金的例子"></a>奖金的例子</h2><p>很多公司的年终奖的是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为S的员工年终奖有4倍工资，绩效为A的员工年终奖有3倍工资，绩效为B的员工年终奖有2倍工资。假如需要一段代码来计算对应员工的年终奖。</p>
<h3 id="最基础写法"><a href="#最基础写法" class="headerlink" title="最基础写法"></a>最基础写法</h3><p>我们直观想到的就是用<code>if...else</code>或者<code>switch...case</code>的方法来写。如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params">performanceLevel, salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">'S'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(performanceLevel === <span class="string">'A'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(performanceLevel === <span class="string">'B'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然代码简单，但是这段代码有很多问题：</p>
<ul>
<li>过多的<code>if...else</code>语句，代码结构不好</li>
<li><code>calculateBonus</code>函数缺乏弹性，如果增加一种新的绩效<code>C</code>，或者修改现有等级的奖金逻辑，就必须深入函数内部进行修改，这违背了<strong>开放-封闭原则</strong></li>
<li>算法复用性差，如果需要在程序的其他地方重用这些算法就只能重新写（cpoy）一份相似的。</li>
</ul>
<p>所以我们现在尝试一步步重构代码。</p>
<h3 id="使用组合函数重构代码"><a href="#使用组合函数重构代码" class="headerlink" title="使用组合函数重构代码"></a>使用组合函数重构代码</h3><p>这里我们将不同的绩效的计算代码抽出来，形成对应的计算函数，在计算奖金里调用这些函数进行计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> performanceS = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> performanceB = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calcalateBonus = <span class="function"><span class="keyword">function</span>(<span class="params">perfomanceLevel, salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">'S'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> performanceS(salary)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(performanceLevel === <span class="string">'A'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> performanceA(salary)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(performanceLevel === <span class="string">'B'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> performanceB(salary)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这段代码对于最大的问题还没有解决：</p>
<ul>
<li>过多的<code>if...else</code>语句，代码结构不好</li>
<li><code>calculateBonus</code>函数缺乏弹性，如果增加一种新的绩效<code>C</code>，或者修改现有等级的奖金逻辑，就必须深入函数内部进行修改，这违背</li>
</ul>
<h3 id="使用策略模式重构代码"><a href="#使用策略模式重构代码" class="headerlink" title="使用策略模式重构代码"></a>使用策略模式重构代码</h3><p>一个策略模式的程序至少由两部分组成。</p>
<ul>
<li>第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。</li>
<li>第二部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这一点，说明Context中要维持对某个策略对象的引用。</li>
</ul>
<h4 id="使用传统面向对象语言的算法"><a href="#使用传统面向对象语言的算法" class="headerlink" title="使用传统面向对象语言的算法"></a>使用传统面向对象语言的算法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> performanceS = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">performanceS.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">performanceS.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> performanceB = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">performanceS.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Bonus =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.strategy = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bonus.prototype.setSalary = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bonus.prototype.setStrategy = <span class="function"><span class="keyword">function</span>(<span class="params">strategy</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bonus.prototype.getBonus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.strategy)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'未设置strategy属性'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.strategy.calculate(<span class="keyword">this</span>.salary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的模式，我们将计算具体奖金的方法封装。然后定义Bonus来调用封装的方法来计算具体的奖金。</p>
<p>但是对于JavaScript，我们的实现可以更简单一些。</p>
<h4 id="JavaScript版本的策略模式"><a href="#JavaScript版本的策略模式" class="headerlink" title="JavaScript版本的策略模式"></a>JavaScript版本的策略模式</h4><p>我们可以直接使用字面量对象来封装strategy。然后通过Context来计算奖金。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义策略</span></span><br><span class="line"><span class="keyword">let</span> strategy = &#123;</span><br><span class="line">    S: <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    A: <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    B: <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Context</span></span><br><span class="line"><span class="keyword">let</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params">level, salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> srtategy[level](salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calculateBonus(<span class="string">'S'</span>, <span class="number">20000</span>))			<span class="comment">//输出：80000</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateBonus(<span class="string">'A'</span>, <span class="number">10000</span>))			<span class="comment">//输出：30000</span></span><br></pre></td></tr></table></figure>
<h1 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h1><p>表单验证与上面计算奖金的算法类似，都是由多个相似的规则组成。加入现在有以下规则：</p>
<ul>
<li>用户名不能为空</li>
<li>密码长度不能少于6位</li>
<li>手机号码必须符合格式</li>
</ul>
<h2 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">'registerForm'</span>&gt;</span></span><br><span class="line">            请输入用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">name</span>=<span class="string">'userName'</span>/&gt;</span></span><br><span class="line">            请输入密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">name</span>=<span class="string">'password'</span>/&gt;</span></span><br><span class="line">            请输入手机号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">name</span>=<span class="string">'phoneNumber'</span>/&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">                提交</span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        	<span class="keyword">let</span> registerForm = <span class="built_in">document</span>.getElementBuId(<span class="string">'registerForm'</span>)</span></span><br><span class="line"><span class="actionscript">            registerForm.onsubmit = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(registerForm.userName.value === <span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    alter(<span class="string">'用户名不能为空'</span>)</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                if(registerForm.password.valu.length &lt; 6)&#123;</span><br><span class="line"><span class="actionscript">                    alter(<span class="string">'密码不能少于6位'</span>)</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(!<span class="regexp">/(!1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(registerForm.phoneNumber.value))&#123;</span></span><br><span class="line"><span class="actionscript">                    alert(<span class="string">'手机号码格式不正确'</span>)</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是最常见的编写方式，其缺点也与奖金计算的最初版本一样。</p>
<ul>
<li><code>registerForm.onsubmit</code>函数比较庞大，包含了很多<code>if...else</code>语句。</li>
<li><code>registerForm.onsubmit</code>缺乏弹性，如果增加校验规则必须深入函数内部进行修改，违背了<strong>开放-封闭原则</strong>。</li>
<li>算法复用性差，如果在程序中增加另外一个表单，我们仍然需要写完全相同的算法。</li>
</ul>
<h2 id="用策略模式重构表单校验"><a href="#用策略模式重构表单校验" class="headerlink" title="用策略模式重构表单校验"></a>用策略模式重构表单校验</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//校验规则</span></span><br><span class="line"><span class="keyword">let</span> stategies = &#123;</span><br><span class="line">    isNonEmpty: <span class="function"><span class="keyword">function</span>(<span class="params">value, errorMsg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value === <span class="string">''</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    minLength: <span class="function"><span class="keyword">function</span>(<span class="params">value, length, errorMsg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value.length &lt; length)&#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    isMobile: <span class="function"><span class="keyword">function</span>(<span class="params">value, errorMsg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/(!1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(registerForm.phoneNumber.value))&#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验类</span></span><br><span class="line"><span class="keyword">let</span> Validator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = []								<span class="comment">//保存校验规则</span></span><br><span class="line">&#125;</span><br><span class="line">Validator.prototype.add   = <span class="function"><span class="keyword">function</span>(<span class="params">dom, rule, errorMsg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ary = rule.split(<span class="string">':'</span>)					<span class="comment">//把strategies和参数分开</span></span><br><span class="line">    <span class="keyword">this</span>.cache.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;					<span class="comment">//把校验规的步骤用空函数包装起来，并且放入cache</span></span><br><span class="line">        <span class="keyword">let</span> strategy = ary.shift()				<span class="comment">//用户挑选的strategy</span></span><br><span class="line">        ary.unshift(dom.value)					<span class="comment">//把input的value添加进参数列表</span></span><br><span class="line">        ary.push(errorMsg)						<span class="comment">//把errorMsg添加进参数列表</span></span><br><span class="line">        <span class="keyword">return</span> strategies[strategy].aplly(dom, ary)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Validator.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; validatorFunc; validatorFunc = <span class="keyword">this</span>.cache[i++])&#123;</span><br><span class="line">        <span class="keyword">let</span> msg = validatorFunc()				<span class="comment">//开始校验，并取得校验后的返回值</span></span><br><span class="line">        <span class="keyword">if</span>(msg)&#123;								<span class="comment">//如果有确切的返回值，说明校验没有通过</span></span><br><span class="line">            <span class="keyword">return</span> msg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Context类</span></span><br><span class="line"><span class="keyword">let</span> validatorFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> validator = <span class="keyword">new</span> Validator()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加一些校验规则</span></span><br><span class="line">    validator.add(registerForm.userName, <span class="string">'isNonEmpty'</span>, <span class="string">'用户名不能为空'</span>)</span><br><span class="line">    validator.add(registerForm.password, <span class="string">'minLength:6'</span>, <span class="string">'密码长度不能少于6位'</span>)</span><br><span class="line">    validator.add(registerForm.phoneNumer, <span class="string">'isNonEmpty'</span>, <span class="string">'用户名不能为空'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> errorMsg = validator.start()			<span class="comment">//获得校验结果</span></span><br><span class="line">    <span class="keyword">return</span> errotMsg								<span class="comment">//返回校验结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> registerForm = <span class="built_in">document</span>.getElementById(<span class="string">'registerForm'</span>)</span><br><span class="line">registerForm.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> errorMsg = validatorFunc()				<span class="comment">//如果errorMsg有确切的返回值，说明未通过校验</span></span><br><span class="line">    <span class="keyword">if</span>(errorMsg)&#123;</span><br><span class="line">        alert(errorMsg)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>							<span class="comment">//🚫表单提交</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h1><p>优点：</p>
<ul>
<li>策略模式利用了组合、<strong>委托</strong>和多态的技术和思想，可以有效的避免多重条件选择语句。</li>
<li>策略模式提供了对<strong>开放-封闭原则</strong>的完美支持，将算法封装在独立的<code>strategy</code>中，使得他们易于切换，易于理解，易于扩展。</li>
<li>在策略模式的算法也可以服用在系统中的其他地方，从而有效的避免代码的冗余。</li>
<li>在策略模式中利用组合和委托来让<code>Context</code>拥有执行算法的能力，这也是继承的一种更轻便的替代方案。</li>
</ul>
<p>缺点：</p>
<ul>
<li>会增加许多的策略类或者策略对象。</li>
</ul>
<p>策略模式的最大特点就是将同类操作封装在一个对象中，然后再其他类中调用该对象中对应的操作。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《JavaScript设计模式与开发实践》</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式3-代理模式</title>
    <url>/2021/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当目标对象不方便直接访问或者访问者不满足要求的时候，提供一个代理对象来控制对目标对象的访问。访问者实际上访问的是代理对象。代理对象对请求做出一些处理之后，再把请求转交给目标对象。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>职责清晰。</li>
<li>高扩展性。 </li>
<li>智能化。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于在客户端和真实主体之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ul>
<h2 id="远程代理（主要针对Java）"><a href="#远程代理（主要针对Java）" class="headerlink" title="远程代理（主要针对Java）"></a>远程代理（主要针对Java）</h2><p><strong>远程代理可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。</strong></p>
<h2 id="Copy-on-Write-代理"><a href="#Copy-on-Write-代理" class="headerlink" title="Copy-on-Write 代理"></a>Copy-on-Write 代理</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Copy-on-write (CoW or COW), sometimes referred to as implicit sharing or shadowing, is a resource-management technique used in computer programming to efficiently implement a “duplicate” or “copy” operation on modifiable resources.</p>
</blockquote>
<p>写时复制（copy-on-write，简称 CoW 或 COW），也叫隐式共享（implicit sharing）或隐藏（shadowing），是计算机编程中的一种资源管理技术，用于高效地复制或拷贝可修改资源</p>
<blockquote>
<p>If a resource is duplicated but not modified, it is not necessary to create a new resource; the resource can be shared between the copy and the original. Modifications must still create a copy, hence the technique: the copy operation is deferred to the first write. By sharing resources in this way, it is possible to significantly reduce the resource consumption of unmodified copies, while adding a small overhead to resource-modifying operations.</p>
</blockquote>
<p>具体的，如果复制了一个资源但没有改动，就没必要创建这个新的资源，此时副本能够与原版共享同一资源，在修改时仍需要创建副本。因此，关键在于：<strong>将拷贝操作推迟到第一次写入的时候</strong>。通过这种方式来共享资源，能够显著减少无改动副本的资源消耗，而只是略微增加了资源修改操作的开销</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>但是在JavaScript中，以前还不好对这种代理进行很好的描述，因为以前JavaScript并没有对对象属性进行监听的方法（实际上也只有<code>obj.defineProperty</code>），在ES6引入了<code>Proxy</code>之后，我们可以很方便的实现<code>COW</code>代理。下面给出简单实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'tom'</span>,</span><br><span class="line">    num: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p_person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, proKey, receiver)&#123;</span><br><span class="line">        <span class="keyword">return</span> target[proKey]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(target, propKey, value, receiver)&#123;</span><br><span class="line">        <span class="comment">//深拷贝一个对象</span></span><br><span class="line">        <span class="keyword">let</span> newObj = deep_clone(target)</span><br><span class="line">        <span class="comment">//修改新对象的值</span></span><br><span class="line">        newObj[proKey] = value</span><br><span class="line">        <span class="comment">//替换proxy对象为新对象</span></span><br><span class="line">        p_preson = newObj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的例子中，充分利用了JavaScript弱类型语言的特征，在最开始时将<code>p_person</code>赋值为<code>Proxy</code>对象，在执行get操作时，直接返回被访问对象的值；在执行set操作时，在对被访问对象执行深拷贝，并把<code>p_person</code>赋值为新对象。</p>
<p>但是这样存在一些问题：</p>
<ul>
<li><code>Proxy</code>对象同样会占用空间，如果确定目标对象大概率会被改动，并且目标对象并不是很大，建议直接<code>deep_clone</code>。</li>
<li><code>Proxy</code>对象内部的定义比较复杂，每一个对象都要重复该过程。所以我们封装一个函数，来执行这个过程。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'tom'</span>,</span><br><span class="line">    num: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">produce_p</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> new_obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="keyword">get</span>: function (target, propKey, receiver) &#123;</span><br><span class="line">            <span class="keyword">return</span> target[propKey];</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (target, propKey, value, receiver) &#123;</span><br><span class="line">            <span class="comment">//深拷贝一个对象</span></span><br><span class="line">            <span class="keyword">let</span> newObj = deep_clone(target)</span><br><span class="line">            <span class="comment">//修改新对象的值</span></span><br><span class="line">            newObj[proKey] = value</span><br><span class="line">            <span class="comment">//替换proxy对象为新对象</span></span><br><span class="line">            new_obj = newObj</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> new_obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_p = produce_p(person) <span class="comment">//代理对象</span></span><br></pre></td></tr></table></figure>
<p>这样我们就解决了第二个问题，第一个问题是无法解决的，需要我们自行解决。</p>
<h2 id="保护（Protect-or-Access）代理"><a href="#保护（Protect-or-Access）代理" class="headerlink" title="保护（Protect or Access）代理"></a>保护（Protect or Access）代理</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>保护代理模式(Access Proxy), 也叫Protect Proxy. 这种代理用于对真实对象的功能做一些访问限制, 在代理层做身份验证. 通过了验证, 才调用真实的主体对象的相应方法。</p>
<p>这种限制，应该分为两种：</p>
<ul>
<li>对访问来源做限制</li>
<li>对访问内容做限制</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>但是JavaScript中目前不能对一种进行限制（使用透明代理），我们使用<code>Proxy</code>API来实现对访问内容进行限制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加入我们要对sex进行读限制，对person进行写限制</span></span><br><span class="line"><span class="keyword">let</span> content = &#123;</span><br><span class="line">    person: <span class="string">'tom'</span>,</span><br><span class="line">    place: <span class="string">'park'</span>,</span><br><span class="line">    sex: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> content_p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(content, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, propKey, receiver)&#123;</span><br><span class="line">        <span class="keyword">return</span> proKey === <span class="string">'sex'</span> ? <span class="literal">false</span> : target[proKey]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, propKey, value, receiver)&#123;</span><br><span class="line">        proKey === <span class="string">'person'</span> ? <span class="string">''</span> : target[proKey] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>同样的，我们也可以对<code>content_p</code>进行封装，创建一个工厂，以进行更好复用代码。</p>
<p>如果实际要对访问来源做限制，只能使用非透明的方式，即读写必须通过函数来进行操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> content = &#123;</span><br><span class="line">    person: <span class="string">'tom'</span>,</span><br><span class="line">    place: <span class="string">'park'</span>,</span><br><span class="line">    sex: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> source1 = &#123;</span><br><span class="line">    name: <span class="string">'source1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> source2 = &#123;</span><br><span class="line">    name: <span class="string">'source2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">obj, prop</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//限制来自于source1的访问</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.name === <span class="string">'source1'</span> || prop === <span class="string">'sex'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj[prop]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟从source1来源下访问content</span></span><br><span class="line"><span class="keyword">get</span>.call(source1, content, 'sex')</span><br><span class="line">//false</span><br></pre></td></tr></table></figure>
<h2 id="缓存-Cache-代理"><a href="#缓存-Cache-代理" class="headerlink" title="缓存(Cache)代理"></a>缓存(Cache)代理</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算的时候，如果传递进来的参数与之前的一致，则直接返回结果，减少运算。</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>下面是一个对乘积进行缓存的代理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mult = <span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++)&#123;</span><br><span class="line">        res *= <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy_mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>)</span><br><span class="line">       <span class="keyword">if</span>(args <span class="keyword">in</span>  cache)&#123;</span><br><span class="line">           <span class="keyword">return</span> cahe[args]</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cache[args] = mult.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>同样的，我们可以对<code>proxy_mult</code>进行封装，创建一个工厂，来生成函数工厂。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算乘积函数</span></span><br><span class="line"><span class="keyword">let</span> mult = <span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++)&#123;</span><br><span class="line">        res *= <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算加和函数</span></span><br><span class="line"><span class="keyword">let</span> plus = <span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++)&#123;</span><br><span class="line">        res += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxyProxy = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">in</span>  cache)&#123;</span><br><span class="line">            <span class="keyword">return</span> cahe[args]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[args] = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxyMult = proxyProxy(mult)</span><br><span class="line"><span class="keyword">let</span> proxyPlus = proxyProxy(plus)</span><br><span class="line"></span><br><span class="line">proxyMult(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)		<span class="comment">//24</span></span><br><span class="line">proxyPlus(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)		<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<h2 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>虚拟代理作为创建开销大的对象的代表，经常会<strong>直到我们真正需要一个对象的时候才创建它</strong>。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><h4 id="合并请求减少开销"><a href="#合并请求减少开销" class="headerlink" title="合并请求减少开销"></a>合并请求减少开销</h4><p>这个用法其实和函数的节流效果一致，将多次操作合并为一次，以减少消耗，特别是网络请求。</p>
<p>比如文件同步时，虽然我们和设计<code>checkbox</code>来合并请求，但是并不是每个用户都会按我们设计的逻辑来进行操作。他们可能仍然一个一个地同步，这样会加大服务器的负担。所以我们可以把一段时间内的请求存储下来，每隔一段时间进行同步。以减少服务器的负担。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> syncFile = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//同步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxySyncFile = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ids = []</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">        ids.push(id)</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            syncFile(ids.join())</span><br><span class="line">            claerTimeout(timer)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">            cache.length = <span class="number">0</span></span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h4 id="惰性加载"><a href="#惰性加载" class="headerlink" title="惰性加载"></a>惰性加载</h4><p>这个作用就是虚拟代理最初的用法。</p>
<p>比如我们有一个库名叫<code>composite</code>，其作用是</p>
<ul>
<li>查询页面内图片的的OCR文字(picOcr)</li>
<li>建立页面的虚拟DOM(virtualDOM)</li>
<li>进行大数计算(bigNumberCalc)</li>
<li>用webGL绘制一个游戏(webGLGame)</li>
</ul>
<p>可以想象，这个库的每个功能都是比较困难，所以其代码量都比较大，并且我们并不一定会使用到其所有功能，假如<code>picOcr</code>是最常用的模块，我们直接加载该模块。所以我们可以将其他的模块做成懒加载，需要使用时再加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> composite = &#123;</span><br><span class="line">    picOcr : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//直接加载</span></span><br><span class="line">    &#125;,</span><br><span class="line">    virtualDOM: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> vd = _load(<span class="string">'virtualDOM'</span>)</span><br><span class="line">        composite.virtualDOM = vd</span><br><span class="line">        composite.virtualDOM(<span class="built_in">arguments</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    bigNumberCalc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//逻辑相同</span></span><br><span class="line">    &#125;,</span><br><span class="line">    webGLGame: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//逻辑相同</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _load: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//加载模块</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="keyword">get</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，上面的设计是最简单的模块设计方式，有很多问题，但是这不是我们讨论的重点，我们这里讨论的重点是延迟加载部分，可以看到</p>
<p><code>virtualDOM</code>模块最初是没有被加载的，在调用的时候我们才通过网络加载，最后覆盖原始对象，下次调用时就是直接调用实际代码了。</p>
<p>但实际上这不是好的方案，好的延迟加载方案是：</p>
<p>在库被加载完成后，通过异步网络同时加载需要的模块，这样用户在调用其他模块时，也不会感觉到延迟，同时不会阻塞页面。</p>
<h2 id="其他代理"><a href="#其他代理" class="headerlink" title="其他代理"></a>其他代理</h2><p>在代理模式中，还有其他的模式，但是在JavaScript中并不是常用的，比如：</p>
<h3 id="防火墙代理"><a href="#防火墙代理" class="headerlink" title="防火墙代理"></a>防火墙代理</h3><p>控制网络资源的访问，保护服务器资源的安全。</p>
<h3 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h3><p>为一个对象在不同的地址空间提供局部代表。在JavaScript中，远程代理可以是另一个虚拟机中的对象。</p>
<h3 id="智能引用代理"><a href="#智能引用代理" class="headerlink" title="智能引用代理"></a>智能引用代理</h3><p>取代了简单的指针，它在访问对象的同时执行一些附加操作，比如计算一个对象被引用的次数。</p>
<h1 id="ES6的Proxy"><a href="#ES6的Proxy" class="headerlink" title="ES6的Proxy"></a>ES6的<code>Proxy</code></h1><p>在ES6之前，JavaScript只能通过<code>Object.defineProperty</code>来进行数据代理。并且还无法做到对对象属性的代理监听。以至于Vue不得不设计一个<code>Vue.prototype.set</code>来监听对象属性的修改。但是ES6的的<code>Proxy</code>API在编程语言的层面上提供了代理，这样使得我们这一章的代理模式的实现变得极其简单。下面简单介绍其用法。</p>
<p>ES6提供原生的<code>Proxy</code>构造函数，用来生成<code>Proxy</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>
<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，-</p>
<ul>
<li><code>target</code>参数表示所要拦截的目标对象。</li>
<li><code>handler</code>参数也是一个对象，用来定制拦截行为。</li>
</ul>
<p>如果<code>handler</code>没有做任何拦截为<code>{}</code>，则直接通向原对象。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stu = &#123;</span><br><span class="line">    name: <span class="string">'tom'</span>,</span><br><span class="line">    number: <span class="number">123</span>,</span><br><span class="line">    sex: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, propKey, receiver)&#123;</span><br><span class="line">        <span class="keyword">if</span>(propKey === <span class="string">'sex'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target[propKey]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(target, propKey, value, receiver)&#123;</span><br><span class="line">        <span class="keyword">if</span>(propKey === name)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        target[propKey] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stu_p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(stu, handler)</span><br></pre></td></tr></table></figure>
<p>上面代理拦截了<code>get</code>和<code>set</code>方法，拦截了获取<code>stu</code>对象的<code>sex</code>属性、设置<code>stu</code>的<code>name</code>属性。</p>
<p>其中handler中，支持的拦截属性有13种：</p>
<ul>
<li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>
<p>简单介绍上面的参数分别为：</p>
<ul>
<li>target：目标对象，即被代理的对象</li>
<li>propKey： 操作的属性键名</li>
<li>value：操作的属性值</li>
<li>receiver：代理对象</li>
<li>propKey：属性键名</li>
<li><p>propDesc：属性的描述，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a></p>
</li>
<li><p>proto：原型对象</p>
</li>
</ul>
<p>Vue3中的响应式完全依赖了这个API，所以其是非常有用的。用起来也简单。还是需要深入理解。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式4-迭代器模式</title>
    <url>/2021/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迭代器模式是指提供一种方法顺序访问一个集合对象中的各个元素，而不需要暴露该对象的内部表示。</p>
<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。<strong>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</strong></p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>不需要关心对象内部表示来遍历整个对象。</p>
<h2 id="内部迭代器"><a href="#内部迭代器" class="headerlink" title="内部迭代器"></a>内部迭代器</h2><p>内部迭代器是指事先定义好迭代器的迭代规则，他完全接受整个迭代过程，外部只需要一次初始调用。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们实现一个<code>each</code>内部迭代器，接受两个参数：</p>
<ul>
<li>arr：要被迭代的数组</li>
<li>fn：迭代规则函数</li>
</ul>
<p>fn在每一次数组循环时都会执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> each = <span class="function"><span class="keyword">function</span>(<span class="params">arr, fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">        fn(i, arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">index, item</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index, item)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*结果</span></span><br><span class="line"><span class="comment">*0 1</span></span><br><span class="line"><span class="comment">*1 2</span></span><br><span class="line"><span class="comment">*2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>内部迭代器的缺点就是无法很好的组合多个迭代，只有在一个迭代规则中嵌入另外一个迭代器，这样未必显得代码冗余，影响代码可读性。所以产生了外部迭代器。</p>
<h2 id="外部迭代器"><a href="#外部迭代器" class="headerlink" title="外部迭代器"></a>外部迭代器</h2><p>外部迭代器一般会提供一个<code>next</code>类似的函数，每调用一次，就会返回该次迭代的结果。我们可以在外部拿到结果，进行更多的操作。</p>
<p>下面我们简单实现一个外部迭代器的原型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Iterator = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> maxLen = obj.length</span><br><span class="line">    <span class="keyword">let</span> next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current &lt; maxLen)&#123;</span><br><span class="line">            current++</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                value: obj[current],</span><br><span class="line">                done: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                value: <span class="literal">undefined</span>,</span><br><span class="line">                done: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next,</span><br><span class="line">        len: maxLen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator_arr = Iterator(arr)</span><br><span class="line"></span><br><span class="line">iterator_arr.next()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*&#123;</span></span><br><span class="line"><span class="comment">*	value: 1,</span></span><br><span class="line"><span class="comment">*	done: false</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面的函数实现了ES6提供的<code>Iterator</code>接口最基本的部分。我们可以在外部拿到迭代结果，现在我们可以同时拿到两个迭代器的结果而不用嵌套迭代器。</p>
<p>见到那写一下两个迭代器元素的比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compare = <span class="function"><span class="keyword">function</span>(<span class="params">iterator1, iterator2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//比较元素长度</span></span><br><span class="line">    <span class="keyword">if</span>(iterator1.length !== iterator2.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!iterator1.next().done &amp;&amp; !iterator2.next().done &amp;&amp; iterator1.next().value !== iterator2.next().value)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript中遍历"><a href="#JavaScript中遍历" class="headerlink" title="JavaScript中遍历"></a>JavaScript中遍历</h1><p>迭代器说到底还是对某种数据结构进行遍历的的一个接口。在一般的高级语言中，对于特殊的数据结构，比如数组都会封装一个方法进行遍历。而在JavaScript中，表示集合类的数据结构中，包括ES6增加的<code>Map</code>和<code>Set</code>，一共就有4种：</p>
<ul>
<li><code>Object</code></li>
<li><code>Array</code></li>
<li><code>Set</code></li>
<li><code>Map</code></li>
</ul>
<p>对于数组和对象，我在<a href="https://michaelwang.top/2021/01/26/JavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">JavaScript中数组与对象的遍历方法</a>中，进行了详细的探讨。</p>
<p>在那篇文章中，实际上都是数组或对象的内部迭代器的实例，比如的数组的<code>forEach</code>等方法。</p>
<p>而在ES6中，提供了原生的<code>Iterator</code>接口来实现外部迭代器，而在Java等语言中，早就提供了该接口。</p>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a><code>Iterator</code></h2><h3 id="Iterator-1"><a href="#Iterator-1" class="headerlink" title="Iterator"></a>Iterator</h3><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>
<p>ES6 规定，</p>
<ul>
<li>默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。</li>
<li><code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</li>
<li>属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。</li>
</ul>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: <span class="number">1</span>,</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p>
<p>ES6中有一些对象已经原生实现了Iterator 接口：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>值得注意的是<code>Object</code>并没有原生实现<code>iterator</code>，原因是：</p>
<p>对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p>
<p>当我们对一个数组完成赋值，其<code>Symbol.iterator</code>属性就随之生成了。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">let</span> ite = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 'c', done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h3><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p>
<h4 id="（1）解构赋值"><a href="#（1）解构赋值" class="headerlink" title="（1）解构赋值"></a><strong>（1）解构赋值</strong></h4><p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c');</span><br><span class="line"></span><br><span class="line">let [x,y] = <span class="keyword">set</span>;</span><br><span class="line">// x='a'; y='b'</span><br><span class="line"></span><br><span class="line">let [first, ...rest] = <span class="keyword">set</span>;</span><br><span class="line">// first='a'; rest=['b','c'];</span><br></pre></td></tr></table></figure>
<p><strong>（2）扩展运算符</strong></p>
<p>扩展运算符（…）也会调用默认的 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str] <span class="comment">//  ['h','e','l','l','o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure>
<p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure>
<p><strong>（3）yield*</strong></p>
<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>（4）其他场合</strong></p>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h3 id="Iterator-接口与-Generator-函数"><a href="#Iterator-接口与-Generator-函数" class="headerlink" title="Iterator 接口与 Generator 函数"></a>Iterator 接口与 Generator 函数</h3><p><code>Symbol.iterator()</code>方法的最简单实现，还是使用Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "hello"</span></span><br><span class="line"><span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Symbol.iterator()</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p>
<h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p>
<p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>
<p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Set</span></span><br><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">es6.set(<span class="string">"edition"</span>, <span class="number">6</span>);</span><br><span class="line">es6.set(<span class="string">"committee"</span>, <span class="string">"TC39"</span>);</span><br><span class="line">es6.set(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">": "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure>
<h3 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h3><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p>
<ul>
<li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</li>
<li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li>
<li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《JavaScript设计模式与开发实践》</li>
<li><a href="https://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">Iterator 和 for…of 循环</a></li>
</ul>
]]></content>
      <categories>
        <category>迭代器模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式5-发布-订阅模式（观察者模式）</title>
    <url>/2021/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="发布-订阅模式（观察者模式）"><a href="#发布-订阅模式（观察者模式）" class="headerlink" title="发布-订阅模式（观察者模式）"></a>发布-订阅模式（观察者模式）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>其定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变的时候，所有依赖它的对象都会得到通知。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p>在JavaScript中，其主要有以下两个用处：</p>
<ul>
<li>可以广泛应用于异步编程之中，这是一种代替回调函数的方案。</li>
<li>发布-订阅模式可以取代对象之间的硬编码通知机制，一个对象不用再显示地调用另外一个对象的某个接口。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在web开发中，我们其实已经用到了发布-订阅模式，其就是DOM事件。</p>
<h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><p>例如我们给一个按钮绑定一个点击事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElmentById(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, click, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>实际上这个事件绑定的过程也是一个发布订阅模式。我们预先将依赖添加到发布者，当发布者事件变化，即点击事件发生的时候，我们再触发该依赖。这就是一个发布订阅模式的触发过程。</p>
<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>除了DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布-订阅者模式可以用于任何JavaScript代码中。</p>
<p>首先我们要明确三个部分</p>
<ul>
<li>指定发布者。</li>
<li>为发布者添加一个 缓存列表用于缓存回调函数，以用于通知订阅者。</li>
<li>最后发布消息的时候，发布者遍历整个缓存列表，依次触发里面存放的回调函数。</li>
</ul>
<p>下面来进行简单的开发</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> publisher = &#123;&#125;						<span class="comment">//发布者</span></span><br><span class="line"></span><br><span class="line">publisher.cacheList = []				<span class="comment">//缓存列表，存放订阅者的回调函数</span></span><br><span class="line"></span><br><span class="line">publisher.listen = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;		<span class="comment">//订阅消息</span></span><br><span class="line">    <span class="keyword">this</span>.cacheList.push(fn)				<span class="comment">//将订阅者函数添加进缓存列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">publisher.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;			<span class="comment">//发布消息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.cacheList.length; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">this</span>.[cacheList].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单测试</span></span><br><span class="line">publisher.listen(<span class="function"><span class="keyword">function</span>(<span class="params">time, msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(time+<span class="string">'的消息为'</span>+msg)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">publisher.trigger(<span class="number">1</span>, <span class="string">'你是猪'</span>)</span><br><span class="line">publisher.trigger(<span class="number">2</span>, <span class="string">'你是狗'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="发布订阅者-关键字"><a href="#发布订阅者-关键字" class="headerlink" title="发布订阅者+关键字"></a>发布订阅者+关键字</h3><p>在上面的例子中，虽然能够实现发布订阅这个功能，但是还有一个问题是不同的订阅者可能需要订阅对不同的消息，所以我们需要给消息加上一个<code>key</code>，以表示消息的类型。</p>
<p>实际上只是需要将消息队列定义为对象，以表示不同的<code>key</code>；在发布消息时，按照<code>key</code>来触发消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> publisher = &#123;&#125;							<span class="comment">//发布者</span></span><br><span class="line"></span><br><span class="line">publisher.cacheList = &#123;&#125;					<span class="comment">//缓存列表，存放回调函数</span></span><br><span class="line"></span><br><span class="line">publisher.listen = <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.cacheList[key])&#123;				<span class="comment">//如果还没有订阅过此类的消息，给该类消息创建一个缓存列表</span></span><br><span class="line">        <span class="keyword">this</span>.cacheList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cacheList[key].push(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">publisher.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)			<span class="comment">//发布消息</span></span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.cacheList[key]							<span class="comment">//取出对应的消息类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;							<span class="comment">//如果没有订阅该消息，则返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = fns.length; i &lt; len; i++)&#123;</span><br><span class="line">        fns[i].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)						<span class="comment">//arguments是发布消息时附送的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">publiser.listen(<span class="string">'消息类型1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'消息类型1：'</span>+msg)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">publiser.listen(<span class="string">'消息类型2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'消息类型2：'</span>+msg)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">publisher.trigger(<span class="string">'消息类型1'</span>, <span class="string">'你是猪'</span>)</span><br><span class="line"><span class="comment">//消息类型1：你是猪</span></span><br><span class="line"></span><br><span class="line">publisher.trigger(<span class="string">'消息类型2'</span>, <span class="string">'你是狗'</span>)</span><br><span class="line"><span class="comment">//消息类型2：你是狗</span></span><br></pre></td></tr></table></figure>
<h3 id="为任何对象添加发布订阅者"><a href="#为任何对象添加发布订阅者" class="headerlink" title="为任何对象添加发布订阅者"></a>为任何对象添加发布订阅者</h3><p>实际上发布者订阅者模式可以为任何对象添加，我们只需要将主要的三个属性添加到对象，即可使对象拥有发布订阅模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> installEvent = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.cacheList = &#123;&#125;</span><br><span class="line">    obj.listen = <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.cacheList[key])&#123;				<span class="comment">//如果还没有订阅过此类的消息，给该类消息创建一个缓存列表</span></span><br><span class="line">            <span class="keyword">this</span>.cacheList[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.cacheList[key].push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    obj.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)			<span class="comment">//发布消息</span></span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.cacheList[key]							<span class="comment">//取出对应的消息类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;							<span class="comment">//如果没有订阅该消息，则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = fns.length; i &lt; len; i++)&#123;</span><br><span class="line">            fns[i].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)						<span class="comment">//arguments是发布消息时附送的参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取消订阅的事件"><a href="#取消订阅的事件" class="headerlink" title="取消订阅的事件"></a>取消订阅的事件</h3><p>有时候我们需要取消订阅的事件，现在我们来实现这个功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> remove = <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.cacheList[key]</span><br><span class="line">    <span class="keyword">if</span>(!fns)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fn)&#123;</span><br><span class="line">        fns &amp;&amp; (fns.length = <span class="number">0</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i =fns.length; i &gt; <span class="number">0</span>; i--)&#123;				</span><br><span class="line">            <span class="keyword">let</span> _fn = fns[i]</span><br><span class="line">            <span class="keyword">if</span>(_fn === fn)&#123;</span><br><span class="line">                fns.splice(i, <span class="number">1</span>)									<span class="comment">//删除订阅者的回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全局的发布-订阅对象"><a href="#全局的发布-订阅对象" class="headerlink" title="全局的发布-订阅对象"></a>全局的发布-订阅对象</h3><p>对于每一个需要实现发布订阅模式的对象，都需要在对象上添加相同的四个属性，虽然理论上没有性能损失不大，但是我们还是可以建立一个全局的发布订阅对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Event = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cacheList = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> listen, trigger, remove</span><br><span class="line">    </span><br><span class="line">    listen = <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cacheList[key])&#123;</span><br><span class="line">            cacheList[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        cacheList[key].push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">let</span> fns = cacheList[key]</span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,fn; fn = fns[i++];)&#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    remove = <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> fns = cacheList[key]</span><br><span class="line">        <span class="keyword">if</span>(!fns)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fn)&#123;</span><br><span class="line">            fns &amp;&amp; (fns.length = <span class="number">0</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> l = fns.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--)&#123;</span><br><span class="line">                <span class="keyword">let</span> _fn = fns[l]</span><br><span class="line">                <span class="keyword">if</span>(_fn === fn)&#123;</span><br><span class="line">                    fns.splice(l, i)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        listen,</span><br><span class="line">        trigger,</span><br><span class="line">        remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">Event.listen(<span class="string">'类型1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'类型1：'</span>name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Event.trigger(<span class="string">'类型1'</span>, <span class="string">'垃圾'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型1：垃圾</span></span><br></pre></td></tr></table></figure>
<h4 id="全局事件的问题"><a href="#全局事件的问题" class="headerlink" title="全局事件的问题"></a>全局事件的问题</h4><p>全局事件虽然可以解决开销，但是却出现了其他问题：<strong>命名冲突</strong>。</p>
<p>越来越多的发布订阅的添加，极其可能出现命名冲突的问题，由此我们如果使用全局事件，则必须使用命名空间来解决问题。</p>
<h4 id="关于离线事件"><a href="#关于离线事件" class="headerlink" title="关于离线事件"></a>关于离线事件</h4><p>在异步事件中，极可能出现我们添加监订阅不够及时，使得事件已经触发了。这样就会出现预期之外的错误了。所以在这种需求中，我们需要实现离线事件。此种情况，我们可以建立一个离线事件的堆栈，当发布的时候还没有对象来订阅此事件，则暂时将其存放至离线栈，等有对象来订阅此对象的时候，我们将遍历堆栈并且依次执行这些函数。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>下面我们将上面两点结合起来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Event = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> global = sthi,</span><br><span class="line">        Event,</span><br><span class="line">        _default = <span class="string">'default'</span></span><br><span class="line"></span><br><span class="line">    Event = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _listen,</span><br><span class="line">            _trigger,</span><br><span class="line">            _remove,</span><br><span class="line">            _slice = <span class="built_in">Array</span>.prototype.slice,</span><br><span class="line">            _shift = <span class="built_in">Array</span>.prototype.shift,</span><br><span class="line">            _unshift = <span class="built_in">Array</span>.prototype.unshift,</span><br><span class="line">            namespaceCache = &#123;&#125;,</span><br><span class="line">            _create,</span><br><span class="line">            find,</span><br><span class="line">            each = <span class="function"><span class="keyword">function</span>(<span class="params">ary, fn</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> ret</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = ary.length; i &lt; len; i++)&#123;</span><br><span class="line">                    <span class="keyword">let</span> n = ary[i]</span><br><span class="line">                    ret = fn.call(n, i, n)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        _listen = <span class="function"><span class="keyword">function</span>(<span class="params">key, fn, cache</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cache[key])&#123;</span><br><span class="line">                cache[key] = []</span><br><span class="line">            &#125;</span><br><span class="line">            cache[key].push(fn)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _remove = <span class="function"><span class="keyword">function</span>(<span class="params">key, fn, cache</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cache[key])&#123;</span><br><span class="line">                <span class="keyword">if</span>(fn)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> i = cache[key].length; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(cache[key][i] === fn)&#123;</span><br><span class="line">                            cache[key].splice(i, <span class="number">1</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cache[key] = []</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> cache = _shift.call(<span class="built_in">arguments</span>),</span><br><span class="line">                key = _shift.call(<span class="built_in">arguments</span>),</span><br><span class="line">                args = <span class="built_in">arguments</span>,</span><br><span class="line">                _self = <span class="keyword">this</span>,</span><br><span class="line">                stack = cache[key]</span><br><span class="line">            <span class="keyword">if</span>(!stack || !stack.length)&#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> each(stack, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.apply(_self, args)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _create = <span class="function"><span class="keyword">function</span>(<span class="params">namespace</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> namespace = namespace || _default</span><br><span class="line">            <span class="keyword">let</span> cache = &#123;&#125;,</span><br><span class="line">                offlineStack = [],</span><br><span class="line">                ret = &#123;</span><br><span class="line">                    listen: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn, cache</span>)</span>&#123;</span><br><span class="line">                        _listen(key, fn, cache)</span><br><span class="line">                        <span class="keyword">if</span>(offlineStack == <span class="literal">null</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(last === <span class="string">'last'</span>)&#123;</span><br><span class="line">                            offlineStack.length &amp;&amp; offlineStack.pop()</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            each(offlineStack, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                                <span class="keyword">this</span>()</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                        offlienStack = <span class="literal">null</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    one: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn, last</span>)</span>&#123;</span><br><span class="line">                        _remove(key, cache)</span><br><span class="line">                        <span class="keyword">this</span>.listen(key, fn, last)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    remove: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">                        _remove(key, cache, fn)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    trigger: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                        <span class="keyword">let</span> fn,</span><br><span class="line">                            args,</span><br><span class="line">                            _self = <span class="keyword">this</span></span><br><span class="line">                        _unshift.call(<span class="built_in">arguments</span>, cache)</span><br><span class="line">                        args = <span class="built_in">arguments</span></span><br><span class="line">                        fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> _trigger.apply(_self, args)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(offlineStack)&#123;</span><br><span class="line">                            <span class="keyword">return</span> offlineStack.push(fn)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> fn()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> namespace ? (namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret) : ret</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            create: _create,</span><br><span class="line">            one: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn, last</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> event = <span class="keyword">this</span>.create()</span><br><span class="line">                event.one(key, fn, last)</span><br><span class="line">            &#125;,</span><br><span class="line">            remove: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> event = <span class="keyword">this</span>.create()</span><br><span class="line">                event.remove(key, fn)</span><br><span class="line">            &#125;,</span><br><span class="line">            list: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn, last</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> event = <span class="keyword">this</span>.create()</span><br><span class="line">                event.listen(key, fn, last)</span><br><span class="line">            &#125;,</span><br><span class="line">            trigger: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> event = <span class="keyword">this</span>.create()</span><br><span class="line">                event.trigger.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Event</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript中的发布订阅模式"><a href="#JavaScript中的发布订阅模式" class="headerlink" title="JavaScript中的发布订阅模式"></a>JavaScript中的发布订阅模式</h1><p>值得注意的是，之前我们编写的发布订阅模式，和一些其他的语言（比如Java）中的实现还是有区别的。在Java中实现一个自己的发布订阅模式，通常会把订阅者自身当作引用传入发布者对象中，同时订阅者对象还需提供一个名为诸如update的方法，供发布者对象在适合的时候调用。而在JavaScript中，我们用注册回调函数的形式来代替传统的发布订阅模式，更加方便。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《JavaScript设计模式与开发实践》</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>发布-订阅模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式6-命令模式与组合模式</title>
    <url>/2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以<strong>命令</strong>的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>在软件系统中，<strong>行为请求者</strong>与<strong>行为实现者</strong>通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>通过引入中间件（抽象接口）降低系统的耦合度。</li>
<li>扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。</li>
<li>可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。</li>
<li>命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h3><ol>
<li>抽象命令类（abstract command）：声明执行的接口，拥有执行命令的抽象方法execute()。</li>
<li>具体命令类（concrete command）：是抽象类的具体实现类，它拥有接收者对象，并通过调用接受者的功能来完成命令要执行的操作。</li>
<li>接收者（receiver）：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者（invoker）：是请求的发送者，他通常拥有很多的命令对象，并通过访问命令对象来执行相关操作，它不直接访问接收者。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里以一个</p>
<ol>
<li>抽象命令接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Order.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>具体命令类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BuyStock.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyStock</span> <span class="keyword">implements</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BuyStock</span><span class="params">(Stock abcStock)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      abcStock.buy();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BuyStock.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyStock</span> <span class="keyword">implements</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BuyStock</span><span class="params">(Stock abcStock)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      abcStock.buy();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>请求类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String name = <span class="string">"ABC"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> quantity = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Stock [ Name: "</span>+name+<span class="string">", </span></span><br><span class="line"><span class="string">         Quantity: "</span> + quantity +<span class="string">" ] bought"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Stock [ Name: "</span>+name+<span class="string">", </span></span><br><span class="line"><span class="string">         Quantity: "</span> + quantity +<span class="string">" ] sold"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>命令调用类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Broker.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broker</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;Order&gt;(); </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeOrder</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">      orderList.add(order);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">         order.execute();</span><br><span class="line">      &#125;</span><br><span class="line">      orderList.clear();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>使用 Broker 类来接受并执行命令。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Stock abcStock = <span class="keyword">new</span> Stock();</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//新建具体命令</span></span><br><span class="line">      BuyStock buyStockOrder = <span class="keyword">new</span> BuyStock(abcStock);</span><br><span class="line">      SellStock sellStockOrder = <span class="keyword">new</span> SellStock(abcStock);</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//创建执行类</span></span><br><span class="line">      Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">      broker.takeOrder(buyStockOrder);</span><br><span class="line">      broker.takeOrder(sellStockOrder);</span><br><span class="line"> 		</span><br><span class="line">       <span class="comment">//执行</span></span><br><span class="line">      broker.placeOrders();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="\images\设计模式\命令模式.png" alt="命令模式"></p>
<h2 id="JavaScript中的命令模式"><a href="#JavaScript中的命令模式" class="headerlink" title="JavaScript中的命令模式"></a>JavaScript中的命令模式</h2><p>在JavaScript中，我们无须那么麻烦的创建类。由于函数在JS中作为一等公民，本身就可以作为参数进行传递。所以不一定要将其封装在execute方法中，而是直接将其作为字面量对象的成员进行传递。</p>
<p>比如按钮点击事件的添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bindClick = <span class="function"><span class="keyword">function</span>(<span class="params">button, func</span>)</span>&#123;</span><br><span class="line">    button.onClick = func</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> MenuBar = &#123;</span><br><span class="line">    refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'刷新子菜单'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> SubMenu = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'添加子菜单'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    del: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        consle.log(<span class="string">'删除子菜单'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bindClick(button1, MenuBar.refresh)</span><br><span class="line">bindClick(button2, SubMenu.add)</span><br><span class="line">bindClick(button3, SubMenu.del)</span><br></pre></td></tr></table></figure>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<h2 id="主要解决-1"><a href="#主要解决-1" class="headerlink" title="主要解决"></a>主要解决</h2><p>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<h2 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h2><p>宏命令包含了一组具体的子命令对象，不管是宏命令，还是子命令，都有一个execute方法负责执行命令。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CloseDoorCommand = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'关门'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> openPCCommand = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        consoloe.log(<span class="string">'开电脑'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> openQQCommand = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'登录QQ'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        commandList : [],</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params">command</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.commandList.push(command)</span><br><span class="line">        &#125;,</span><br><span class="line">        execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> <span class="keyword">this</span>,commandList)&#123;</span><br><span class="line">                c.execute()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> macroCommand = MacroCommand()</span><br><span class="line">macroCommand.add(CloseDoorCommand)</span><br><span class="line">macroCommand.add(openPCCommand)</span><br><span class="line">macroCommand.add(openQQCommand)</span><br><span class="line"></span><br><span class="line">macroCommand.execute()</span><br></pre></td></tr></table></figure>
<p>在组合模式中，请求在树中传递总是遵循一种逻辑。</p>
<p>请求从树最顶端的对象向下传递，如果当前请求的对象是叶对象（普通子命令），也对象自身会对请求做出相应的处理；如果当前请求的对象是组合对象（宏命令），组合对象则会遍历它下属的子节点，将请求传递给这些子节点。</p>
<h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><p><img src="\images\设计模式\组合模式.jpg" alt="组合模式"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>命令模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title>项目实际问题一:对象深浅拷贝问题</title>
    <url>/2019/05/18/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E4%B8%80-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>第一次经手比较大型的项目，总结第一个问题：对象的深拷贝问题。之前没注意这个问题，写完代码发现总是与自己的想法不符合，经调试才发现是对象的深浅拷贝问题。</p>
<p>原理的话也很简单，对象作为基本类型之外的引用类型，在栈内存中保存着引用变量的名字，而这个变量保存的实际是一个地址，这个地址指向堆内存，实际这个变量的值是保存在堆内存中。</p>
<p>所以当我们直接用 “=” 进行变量copy时，实际copy的是对内存中的地址。copy之后改变原变量的值同样会使新变量的值进行改变。所以有时候我们需要进行深拷贝来在堆内存中开辟一个新的内存空间来放置副本，切断新旧变量之间的联系。</p>
<a id="more"></a>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="对象的深拷贝"><a href="#对象的深拷贝" class="headerlink" title="对象的深拷贝"></a>对象的深拷贝</h2><h3 id="适用于所有类型的对象（含数组）"><a href="#适用于所有类型的对象（含数组）" class="headerlink" title="适用于所有类型的对象（含数组）"></a>适用于所有类型的对象（含数组）</h3><ol>
<li>JSON.parse(JSON.stringfy(Object))</li>
</ol>
<p><strong>Point:</strong>这是最简单的进行深拷贝的方法，其原理是先将其转换为JSON字符串，此时就不在存在原变量的堆地址，而是以字符串-基本变量保存在栈地址中。再将其转换回对象，则是一个完全与原变量无关的新变量。但是该方法会丢失对象所有的函数属性，undefined，以及会重置原型对象为Object(),或Array(),如果没修改多原型对象，则没有影响。</p>
<ol start="2">
<li><p>递归遍历对象</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能clone Object和Array</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone1</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断obj是否是引用类型</span></span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">"object"</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> newObj = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            newObj[i] = deepClone1(obj[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newObj</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果不是引用类型则直接返回该值</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>}
</code></pre></li>
<li><p>使用lodash库中的cloneDeep()函数，其原理与上述原理一样，但健壮性更高。</p>
</li>
</ol>
<h3 id="适用于简单对象"><a href="#适用于简单对象" class="headerlink" title="适用于简单对象"></a>适用于简单对象</h3><ol>
<li>Object.assign()</li>
</ol>
<p>eg:</p>
<pre><code>const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
</code></pre><p><strong>Point:</strong>该方法只适用于由基本数据类型组成的对象，不能用于对象键或值包含引用类型，否则任然是浅拷贝。同时，该函数会忽略undefined与null值（可以用来过滤无效值）</p>
<h3 id="使用于简单数组"><a href="#使用于简单数组" class="headerlink" title="使用于简单数组"></a>使用于简单数组</h3><ol>
<li><code>Array.slice(startPositong,endPositon)</code></li>
<li><code>Array.contact(arr1,arr2)</code></li>
<li><code>array.splice(startPositon,delteteNum,addArr1,addArr2...)</code></li>
<li>数组的迭代方法：<code>Array.every(),Array.filter(),Array.map()</code></li>
</ol>
<p><strong>Point:</strong>使用以上方法，必须是由基本数据类型组成的数组，数组项不能包含引用类型，否则任然是浅拷贝！！！</p>
<h1 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h1><p>以上方法都只会转化可枚举项，对于不可枚举项，都是默认忽略的。</p>
<p>综上，<code>JSON.parse(JSON.stringfy(obj))</code>应该算是最简单且最易用的方法了，并且原生代码的效率相较于<code>JS</code>也会有优势，所以，如果仅仅为了深拷贝，没有其他需求，该方法是比较好的方法。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>项目部署引发的知识</title>
    <url>/2019/04/09/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%BC%95%E5%8F%91%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><p>之前一直在写东西，都没怎么部署过项目，特别是Linux系统下，本来之前买服务器是想买一个Linux的服务器的，然而，学生党只配用Windows，万恶的阿里云。现在又可以买Linux的了，然而我又不想重新布属我的项目。今天再部署Linux时，才发现完全不会。枯了~</p>
<h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><p><strong>开发最常用命令</strong></p>
<ol>
<li>git init //初始化一个git文件夹</li>
<li>git remote add origin <a href="https://gitee.com/mw530/xxx" target="_blank" rel="noopener">https://gitee.com/mw530/xxx</a>         //为本地仓库添加远程仓库</li>
<li>git status //查看项目状态</li>
<li>git add . //把所有修改文件推送到stage中</li>
<li>git commit -m des(描述) </li>
<li>git push //推送到默认分支</li>
<li>git push origin master(本地分支名) : master(远程仓库名)</li>
</ol>
<p><strong>常用命令</strong></p>
<ol>
<li>git config –global user.name “Tocy” //配置用户名</li>
<li>git config –global user.email <a href="mailto:zyvj@qq.com">zyvj@qq.com</a> //配置邮箱</li>
<li>git clone 仓库地址 //将远程仓库拉至本地</li>
<li>git add 文件名   //将某一文件提交至stage</li>
<li>git diff //查看当前目录的所有修改</li>
<li>git remote add [short_name] [url]  //添加远程仓库</li>
<li>git branch //列出所有分支 -* 本地 -r 远程 -a 本地与远程 </li>
<li>git branch [branch-name] //新建一个分支，但仍然留在当前分支</li>
<li>git branch -d [branch-name]   //删除该分支</li>
<li>git checkout -b [branch-name] //新建并切换到该分支</li>
<li>git checkout [branch-name]   //切换到该分支</li>
<li>git checkout [file]  //恢复暂存区的指定文件到工作区</li>
<li>git checkout .  //恢复暂存区的所有文件到工作区</li>
</ol>
<p><strong>分支管理</strong></p>
<ol>
<li><p>git merge –no-ff develop        //将develop合并到当前分支</p>
<p>–no-ff(no-fast forward)的含义：当两个分支之间存在先后关系时，若合并分支在当前分支之后，则git只会移动指针，使当前分支指向被合并分支，这个过程被称为快速合并。而禁止快速，即–no-ff则会在当前分支新建一个提交来存放这一次develop的提交。</p>
</li>
</ol>
<a id="more"></a>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><strong>安装node.js</strong></p>
<ol>
<li><p>到根目录</p>
<p> cd ~</p>
</li>
<li><p>建一个文件夹</p>
<p> mkdir deploy</p>
</li>
<li><p>下载node包</p>
<p> wget <a href="https://nodejs.org/dist/v10.11.0/node-v10.11.0-linux-x64.tar.xz" target="_blank" rel="noopener">https://nodejs.org/dist/v10.11.0/node-v10.11.0-linux-x64.tar.xz</a> </p>
</li>
<li><p>解压node包</p>
<p> tar zf node-v10.11.0-linux-x64.tar.xz </p>
</li>
<li><p>重命名包</p>
<p> cd node-v10.11.0-linux-x64.tar.xz/bin &amp;&amp; ls</p>
</li>
<li><p>查看node,npm的版本</p>
<p> ./node -v<br> ./npm -v</p>
</li>
<li><p>设置环境变量</p>
<p> vim ~/.bash_profile</p>
</li>
<li><p>在文件尾部添加以下内容</p>
<p> export NODE_HOME=/deploy/node-v8.11.3-linux-x64<br> export PATH=$PATH:$NODE_HOME/bin</p>
</li>
<li><p>退出vim:</p>
<p> 按 esc 输入:wq enter 退出</p>
</li>
<li><p>保存profile文件</p>
<p>source /etc/profile</p>
</li>
<li><p>将目录软链接到全局环境下（命令后面的/usr/local/bin/node是固定的）</p>
<p>ln -s /deploy/node-v8.11.3-linux-x64/bin/node /usr/local/bin/node</p>
<p>ln -s /deploy/node-v8.11.3-linux-x64/bin/npm /usr/local/bin/npm</p>
</li>
<li><p>检验安装是否成功</p>
<p>node -v<br>npm -v</p>
</li>
</ol>
<p><strong>安装Nginx</strong></p>
<ol>
<li><p>安装yum</p>
<p> npm install yum</p>
</li>
<li><p>安装依赖</p>
<p> yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</p>
</li>
<li><p>下载Nginx</p>
<p> //创建一个文件夹<br> cd /usr/local<br> mkdir nginx<br> cd nginx<br> //下载tar包<br> wget <a href="http://nginx.org/download/nginx-1.13.7.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.13.7.tar.gz</a><br> tar -xvf nginx-1.13.7.tar.g</p>
</li>
<li><p>安装Nginx</p>
<p> //进入nginx目录<br> cd /usr/local/nginx<br> //执行命令<br> ./configure<br> //执行make命令<br> make<br> //执行make install命令<br> make install</p>
</li>
<li><p>Nginx常用命令</p>
<p> //测试配置文件<br> 安装路径下的/nginx/sbin/nginx -t</p>
<p> //启动命令<br> 安装路径下的/nginx/sbin/nginx</p>
<p> //停止命令<br> 安装路径下的/nginx/sbin/nginx -s stop<br> 或者 : nginx -s quit</p>
<p> //重启命令<br> 安装路径下的/nginx/sbin/nginx -s reload</p>
<p> //查看进程命令<br> ps -ef | grep nginx</p>
</li>
<li><p>Nginx虚拟域名配置及测试验证</p>
<p> //编辑nginx.conf<br> sudo vim /usr/local/nginx/conf/nginx.conf</p>
<p> //增加行<br> include vhost/*.conf</p>
<p> //保存退出<br> ：wq enter</p>
<p> //在/usr/local/nginx/conf目录新建vhost文件夹<br> mkdir vhost</p>
<p> //创建每个域名的配置<br> sudo vim jimisun.com.conf</p>
<p> //节点中增加入响应的配置 端口转发  或者访问文件系统</p>
</li>
<li><p>Nginx启动</p>
<p> //进入nginx安装目录<br> cd sbin<br> sudo ./nginx<br> 测试访问<br> <a href="http://ip地址" target="_blank" rel="noopener">http://ip地址</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>node.js</tag>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM4-2-高效并发-线程安全与锁优化</title>
    <url>/2022/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM4-2-%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>线程安全在《Java并发编程实战（Java Concurrency In Practice）》中有一个比较恰当的定义：“当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下 的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。”</p>
<p>这个定义就很严谨而且有可操作性，它要求线程安全的代码都必须具备一个共同特征：<strong>代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。</strong></p>
<h2 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h2><p>接下来谈的线程安全，将以多个线程之间存在共享 数据访问为前提。因为如果根本不存在多线程，又或者一段代码根本不会与其他线程共享数据，那么从线程安全的角度上看，程序是串行执行还是多线程执行对它来说是没有什么区别的。</p>
<p>为了更深入地理解线程安全，在这里我们可以不把线程安全当作一个非真即假的二元排他选项来 看待，而是按照线程安全的“安全程度”由强至弱来排序，可以将Java语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<h3 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h3><p>在Java语言里面（特指JDK 5以后，即Java内存模型被修正之后的Java语言），不可变 （Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。比如final关键字修饰的变量，只要 一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都 不会改变，永远都不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。</p>
<p>Java语言中，<strong>如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰 它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的 支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。</strong>比如java.lang.String类的对象实例，它是一个典型的不可变对象，用户调用它的 substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。</p>
<p>保证对象行为不影响自己状态的途径有很多种，最简单的一种就是把对象里面带有状态的变量都 声明为final，这样在构造函数结束之后，它就是不可变的。</p>
<h3 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2. 绝对线程安全"></a>2. 绝对线程安全</h3><p>绝对的线程安全能够完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一 个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”可能需要付出非常高昂的，甚至不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。</p>
<p>比如常说的Vector类，它 的add()、get()和size()等方法都是被synchronized修饰的，尽管这样效率不高，但保证了具备原子性、可见性和有序性。不过，即使它所有的方法都被修饰成synchronized，也不意味着调用它的时候就永远 都不再需要同步手段了。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;Integer&gt;(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">		Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123; </span><br><span class="line">                    vector.remove(i);</span><br><span class="line"></span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123; </span><br><span class="line">                    System.out.println((vector.get(i)));</span><br><span class="line"></span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">	removeThread.start(); printThread.start();</span><br><span class="line"><span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死 while (Thread.activeCount() &gt; 20);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"Thread-132"</span> java.lang.ArrayIndexOutOfBoundsException:</span><br><span class="line">Array index out of range: <span class="number">17</span> </span><br><span class="line">    at java.util.Vector.remove(Vector.java:<span class="number">777</span>) </span><br><span class="line">    at org.fenixsoft.mulithread.VectorTest$<span class="number">1</span>.run(VectorTest.java:<span class="number">21</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">662</span>)</span><br></pre></td></tr></table></figure>
<p>很明显，尽管这里使用到的Vector的get()、remove()和size()方法都是同步的，但是在多线程的环境 中，如果不在方法调用端做额外的同步措施，使用这段代码仍然是不安全的。因为如果另一个线程恰 好在错误的时间里删除了一个元素，导致序号i已经不再可用，再用i访问数组就会抛出一个 ArrayIndexOutOfBoundsException异常。如果要保证这段代码能正确执行下去，我们不得不把removeThread和printThread的定义改成如下代码清单所示的这样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">synchronized</span> (vector) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123; </span><br><span class="line">                vector.remove(i);</span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line">Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">synchronized</span> (vector) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123; </span><br><span class="line">                System.out.println((vector.get(i)));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>假如Vector一定要做到绝对的线程安全，那就必须在它内部维护一组一致性的快照访问才行，每次 对其中元素进行改动都要产生新的快照，这样要付出的时间和空间成本都是非常大的。</p>
<h3 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3. 相对线程安全"></a>3. 相对线程安全</h3><p>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<p>在Java语言中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。</p>
<h3 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4. 线程兼容"></a>4. 线程兼容</h3><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，通常就是指这种情况。Java类库API中大部分的类都是线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。</p>
<h3 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5. 线程对立"></a>5. 线程对立</h3><p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于Java 语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p>
<p>一个线程对立的例子是Thread类的suspend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同 步，目标线程都存在死锁风险——假如suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是这个原因，suspend()和resume()方法都已经被声明废弃了。常见的线程对立的操作还有System.setIn()、Sytem.setOut()和System.runFinalizersOnExit()等。</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><p>这一部分描述了JVM虚拟机是如何实现同步与锁的。只要明白了Java虚拟机线程安全措施的原理与运作过程，自己再去思考代码如何编写就不是 一件困难的事情了。</p>
<h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>互斥同步（Mutual Exclusion &amp; Synchronization）是一种最常见也是最主要的并发正确性保障手 段。</p>
<ul>
<li>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些， 当使用信号量的时候）线程使用。</li>
<li>而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量 （Mutex）和信号量（Semaphore）都是常见的互斥实现方式。</li>
</ul>
<p>因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p>
<p>在Java里面，最基本的互斥同步手段就是synchronized关键字，这是一种块结构（Block Structured）的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。<strong>这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。</strong>（即锁定的实际上都是对象，而不是方法或其他）如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</p>
<p>根据《Java虚拟机规范》的要求，<strong>在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行 monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</strong></p>
<p>从功能上看，根据以上《Java虚拟机规范》对monitorenter和monitorexit的行为描述，我们可以得出 两个关于synchronized的直接推论，这是使用它时需特别注意的：</p>
<ul>
<li>被synchronized修饰的同步块对同一条线程来说是<strong>可重入</strong>的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li>
<li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。</li>
</ul>
<p>从执行成本的角度看，持有锁是一个<strong>重量级</strong>（Heavy-Weight）的操作。前面说过在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条 线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。尤其是对于代码特别简单的同步块（譬如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。因此才说， synchronized是Java语言中一个重量级的操作，有经验的程序员都只会在确实必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程， 以避免频繁地切入核心态之中。</p>
<p>从上面的介绍中我们可以看到synchronized的局限性，除了synchronized关键字以外，自JDK 5起 （实现了JSR 166），Java类库中新提供了java.util.concurrent包（下文称J.U.C包），其中的 java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够 以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面 去实现同步，这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔的空间。</p>
<p>重入锁（ReentrantLock）是Lock接口最常见的一种实现，顾名思义，它与synchronized一样是可 重入[3]的。在基本用法上，ReentrantLock也与synchronized很相似，只是代码写法上稍有区别而已。不 过，ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：等待可中断、可实现公平锁及锁可以绑定多个条件。</p>
<ul>
<li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改 为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平 锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非 公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。</li>
<li>锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized 中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一 个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。</li>
</ul>
<p>下面是一个这两种方式的性能对比：</p>
<p><img src="/images/深入理解JVM/JDK 5、单核处理器下两种锁的吞吐量对比.jpg" alt="JDK 5、单核处理器下两种锁的吞吐量对比"></p>
<p>从上图中可以看出，多线程环境下synchronized的吞吐量下降得非常严重，而 ReentrantLock则能基本保持在同一个相对稳定的水平上。但与其说ReentrantLock性能好，倒不如说当时的synchronized有非常大的优化余地。当JDK 6中加入了大量针对 synchronized锁的优化措施之后，相同的测试中就发现synchronized与ReentrantLock的性能基本上能够持平。</p>
<p>根据上面的讨论，ReentrantLock在功能上是synchronized的超集，在性能上又至少不会弱于 synchronized，那synchronized修饰符是否应该被直接抛弃，不再使用了呢？当然不是，基于以下理由，笔者仍然推荐在synchronized与ReentrantLock都可满足需要时优先使用synchronized：</p>
<ul>
<li>synchronized是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉 synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized。</li>
<li>Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放。</li>
<li>尽管在JDK 5时代ReentrantLock曾经在性能上领先过synchronized，但这已经是十多年之前的胜利了。从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li>
</ul>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步（Blocking Synchronization）。实际上互斥同步属于一种悲观的并发策略，其总是认为同步资源会被互斥使用。但实际上很多时候共享的数据并不总会被互斥使用。所以有另一种选择：<strong>基于冲突检测的乐观并发策略，通俗地说 就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数 据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。</strong>这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被 称为非阻塞同步（Non-Blocking Synchronization），使用这种措施的代码也常被称为无锁（Lock-Free）编程。</p>
<p>但乐观并发策略需要“硬件指令集的发展”。因为我们必须要求操作和冲突检测这 两个步骤具备原子性。此时就不能通过同步互斥来保证同步了。所 以我们只能靠硬件来实现这件事情，硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：</p>
<ul>
<li>测试并设置（Test-and-Set）；</li>
<li>获取并增加（Fetch-and-Increment）；</li>
<li>交换（Swap）；</li>
<li>比较并交换（Compare-and-Swap，下文称CAS）；</li>
<li>加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）。</li>
</ul>
<p>其中，前面的三条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能也是类似的。在IA64、x86指令集中有用cmpxchg指令完成的CAS功能，在SPARC-TSO中也有用casa指令实现的，而在ARM和PowerPC架构下，则需要使用一对 ldrex/strex指令来完成LL/SC的功能。因为Java里最终暴露出来的是CAS操作，所以我们以CAS指令为例进行讲解。</p>
<p>CAS指令需要有三个操作数，分别是<strong>内存位置</strong>（在Java中可以简单地理解为变量的内存地址，用V表示）、<strong>旧的预期值</strong>（用A表示）和<strong>准备设置的新值</strong>（用B表示）。<strong>CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。</strong></p>
<p>在JDK 5之后，Java类库中才开始使用CAS操作，该操作由sun.misc.Unsafe类里面的 compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供。但这几个都是内部类，只有启动类加载器（Bootstrap ClassLoader）加载的Class才能访问。因此在JDK 9之前只有Java类库可以使用CAS，譬如J.U.C包里面的整数原子类，其中的 compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作来实现。直到JDK 9之后，Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作。</p>
<p>之前说过volatile只能保证变量的可见性，但是如果操作不是原子性的，仍然会出现问题。例如经典的<code>i++</code>问题，之前的解决办法是使用同步块来包住<code>i++</code>。使该操作一个时间只有一个线程进入。这样的消耗无疑是比较大的，而此时就有另一种消耗更低的方法来解决。即使用J. U. C.里的原子操作方法<code>incrementAndGet()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * Atomic变量自增运算测试 * * <span class="doctag">@author</span> zzm */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger race = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        race.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123; </span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">                </span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123; </span><br><span class="line">                    increase();</span><br><span class="line"></span><br><span class="line">                &#125; </span><br><span class="line">             &#125;</span><br><span class="line">            &#125;); </span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) </span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(race); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>incrementAndGet()实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * Atomically increment by one the current value. * <span class="doctag">@return</span> the updated value */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        <span class="keyword">int</span> current = get(); </span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) </span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>incrementAndGet()方法在一个无限循环中，不断尝试将一个比当前值大一的新值赋值给自己。如果失败了，那说明在执行CAS操作的时候，旧值已经发生改变，于是再次循环进行下一次操作，直到设置成功为止。</p>
<p>尽管CAS看起来很美好，既简单又高效，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是真正完美的，它存在一个逻辑漏洞：如果一个变量V初次读取的时候是A 值，并且在准备赋值的时候检查到它仍然为A值，那就能说明它的值没有被其他线程改变过了吗？这是不能的，因为如果在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“<strong>ABA问题</strong>”。<em>J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。不过 目前来说这个类处于相当鸡肋的位置，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更为高效。</em></p>
<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，也并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必然的联系。 同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自 然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的，这里简单介绍其中的两类。</p>
<ul>
<li><p>可重入代码（Reentrant Code）：这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。</p>
<p>可重入代码有一些共同的特征，例如，<strong>不依赖全局变量、存储在堆上的数据和公用的系统资源， 用到的状态量都由参数中传入，不调用非可重入的方法等</strong>。我们可以通过一个比较简单的原则来判断代码是否具备可重入性：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p>
</li>
<li><p>线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就 看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
</li>
</ul>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>高效并发是从JDK 5升级到JDK 6后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花 费了大量的资源去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率。</p>
<h2 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h2><p>前面说过，由于Java线程是内核级，线程的阻塞，挂起线程和恢复线程都会切换到内核态，这是一个很影响性能的操作。但实际上共享数据的锁定状态可能只会持续一个很短的时间，这与切换内核带来的损失是得不尝试的。因此不如让该需要资源的线程等待一段时间。一段时间后如果还没有得到资源，就进入阻塞状态。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自 旋锁。</p>
<p>自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用<code>-XX：+UseSpinning</code>参数来开 启，在JDK 6中就已经改为默认开启了。<strong>自旋等待不能代替阻塞</strong>，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，<strong>所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源</strong>，而不会做任何有价值的工作，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限 度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认值是十次，用户也可以使用参数<code>-XX：PreBlockSpin</code>来自行更改。</p>
<p>但是在Java 6中对自旋锁的优化，引入了<strong>自适应的自旋</strong>。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可 以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p>
<p>这里的同步操作并不一定都是程序员自己加的，很大程度上是Java类库或第三方库为了保证安全而设计的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码看起来没有同步，但由于String是一个不变类，对字符串的连接操作总是通过生成新的String对象来 进行的，因此Javac编译器会对String连接做自动优化。JDK 5之前，字符串加法会转化为StringBuffer 对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。</p>
<p>所以以上代码可能会转变为一下的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123; </span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line">    sb.append(s1); </span><br><span class="line">    sb.append(s2); </span><br><span class="line">    sb.append(s3); </span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看源码可知，每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。</p>
<p>虚拟机观察变量sb，经过逃逸分析后会发现它的动态作用域被限制在concatString()方法内 部。也就是sb的所有引用都永远不会逃逸到concatString()方法之外，其他线程无法访问到它，所以这里虽然有锁，但是可以被安全地消除掉。<strong>在解释执行时这里仍然会加锁，但在经过服务端编译器的即时编译之后，这段代码就会忽略所有的同步措施而直接执行。</strong></p>
<blockquote>
<p>客观地说，既然谈到锁消除与逃逸分析，那虚拟机就不可能是JDK 5之前的版本，所以实际上会转 化为非线程安全的StringBuilder来完成字符串拼接，并不会加锁。但是这也不影响笔者用这个例子证明<br>Java对象中同步的普遍性。</p>
</blockquote>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。</p>
<p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>如上所示连续的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作 都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。此时就可以把锁扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是JDK 6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。不过，需要强调一点，<strong>轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</strong></p>
<p>要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须要对HotSpot虚拟机对象的内 存布局（尤其是对象头部分）有所了解。HotSpot虚拟机的对象头（Object Header）分为两部分：</p>
<ul>
<li>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age） 等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“Mark Word”。这部分是实现轻量级锁和偏向锁的关键。</li>
<li>另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。</li>
</ul>
<p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效 率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间。</p>
<p>其具体结构如下：</p>
<p><img src="/images/深入理解JVM/HotSpot虚拟机对象头Mark Word.jpg" alt="HotSpot虚拟机对象头Mark Word"></p>
<p>简单回顾了对象的内存布局后，接下来就可以介绍轻量级锁的工作过程了：在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在<strong>当前线程的栈帧</strong>中建立一个名为锁记录（Lock Record）的空间，<strong>用于存储锁对象目前的Mark Word的拷贝</strong>（即原来的对象哈希码和分代年龄，官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如下图所示。</p>
<p><img src="/images/深入理解JVM/轻量级锁CAS操作之前堆栈与对象的状态.jpg" alt="轻量级锁CAS操作之前堆栈与对象的状态"></p>
<p>然后，虚拟机将<strong>使用CAS操作</strong>尝试把对象的Mark Word更新为指向Lock Record的指针。<strong>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁</strong>，并且对象Mark Word的锁标志位（Mark Word的 最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如下图所示。</p>
<p><img src="/images/深入理解JVM/轻量级锁CAS操作之后堆栈与对象的状态.jpg" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p>
<p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志 的状态值变为“10”，此时Mark Word中存储的就是指向<strong>重量级锁（互斥量）的指针</strong>，后面等待锁的线程也必须进入阻塞状态。</p>
<p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争 的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。<strong>因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢</strong>。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语， 进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。</p>
<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线 程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>假设当前虚拟机启用了偏向锁（启用参数<code>-XX：+UseBiasedLocking</code>，这是自JDK 6 起HotSpot虚拟机的默认值），那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志 位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程 的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步。</p>
<p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是 否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位 为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示。</p>
<p><img src="/images/深入理解JVM/偏向锁、轻量级锁的状态转化及对象Mark Word的关系.jpg" alt="偏向锁、轻量级锁的状态转化及对象Mark Word的关系"></p>
<p>当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原 来对象的哈希码怎么办呢？</p>
<p>在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因 为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存 在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。</p>
<p>因此，<strong>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了</strong>；<strong>而当一个对象当前正处于偏向锁状态，又收到需要 计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁</strong>。在重量级锁 的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。</p>
<p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质 的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访 问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数<code>-XX：-UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>高效并发</tag>
        <tag>线程安全与锁优化</tag>
      </tags>
  </entry>
  <entry>
    <title>springMVC中404错误的拦截</title>
    <url>/2022/03/25/springMVC%E4%B8%AD404%E9%94%99%E8%AF%AF%E7%9A%84%E6%8B%A6%E6%88%AA/</url>
    <content><![CDATA[<h1 id="SpringMVC统一错误处理"><a href="#SpringMVC统一错误处理" class="headerlink" title="SpringMVC统一错误处理"></a>SpringMVC统一错误处理</h1><p>该功能可以直接通过SpringMVC的<code>@RestControllerAdvice</code>注解搭配<code>@ExceptionHandler</code>来处理。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionResponseAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(IndexOutOfBoundsException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Exception</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">exception</span>)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"数组越界错误！"</span>);</span><br><span class="line">        <span class="comment">//handle Exception</span></span><br><span class="line">        <span class="keyword">return</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ClassNotFoundException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Exception</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">exception</span>)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类未找到错判！"</span>);</span><br><span class="line">        <span class="comment">//handle Exception</span></span><br><span class="line">        <span class="keyword">return</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Throwable<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Exception</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">exception</span>)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"兜底所有错误！"</span>);</span><br><span class="line">        <span class="comment">//handle Exception</span></span><br><span class="line">        <span class="keyword">return</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="springMVC统一返回结构"><a href="#springMVC统一返回结构" class="headerlink" title="springMVC统一返回结构"></a>springMVC统一返回结构</h1><p>同样使用<code>@RestControllerAdvice</code>可以用来统一数据的返回结构。不过我们需要实现<code>ResponseBodyAdvice</code>接口。才能劫持方法返回的数据，然后进行重写其中的方法。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResponseBodyAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理返回值是String的状况</span></span><br><span class="line">        <span class="comment">//处理字符串类型数据</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsString(Result.data(o));</span><br><span class="line">           &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理错误</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span>  Exception)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.getResult((Exception) o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Result ? o : Result.data(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还有一个坑，就是json化和String类型的冲突，即如果Controller返回的是一个String。不加这一句的话会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class priv.mw.utils.Result cannot be cast to class java.lang.String (priv.mw.utils.Result is in unnamed module of loader org.apache.catalina.loader.ParallelWebappClassLoader @5049b1e5; java.lang.String is in module java.base of loader &#39;bootstrap&#39;)</span><br></pre></td></tr></table></figure>
<p>即没办法将<code>Result</code>类型转化为<code>String</code>。其本质原因在于由于返回的是<code>String</code>，所以会匹配到<code>StringHttpMessageConverter</code>，因为他在所有Converter的前面。但由于我们在切面中将类型改成了Result，所以就会报错。</p>
<p>但实际上我们需要的是<code>MappingJackson2HttpMessageConverter</code>。</p>
<p>所以目前的解决办法有两种：</p>
<ul>
<li>在转换之前就将String转化为JSON字符串。</li>
<li>将<code>MappingJackson2HttpMessageConverter</code> 放在所有converter的首位。</li>
</ul>
<p>第一种就是就是上面的写法。</p>
<p>第二种可以通过配置来实现：</p>
<ul>
<li><p>XML方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            将MappingJackson2HttpMessageConverter移到前面,处理ResponseBodyAdvice的String异常的问题--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultCharset"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Class方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        converters.add(<span class="number">0</span>, <span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>还有一点值得注意的是：实际上错误处理是在<code>ResponseBodyAdvice</code>中，即统一结构返回中来处理。因为实际上我们需要统一返回结构，对于错误，需要判断错误类型来返回对应的数据。所以在这里处理是更加方便的。</p>
<h1 id="漏掉的404"><a href="#漏掉的404" class="headerlink" title="漏掉的404"></a>漏掉的404</h1><p>虽然上面的做到了统一错误处理，但是404地址错误仍然没办法被劫持到。</p>
<p>目前的做法是，实现一个能够劫持所有请求地址的controller，因为其在springMVC中，泛匹配优先级最低。所以可以这样实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/**"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">NotFound</span><span class="params">()</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClientException(<span class="string">"请求地址出错！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后期看能不能有更优的处理方法。</p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM3-1-程序编译与代码优化-前端编译与优化</title>
    <url>/2022/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM3-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Java技术下谈“编译期”而没有具体上下文语境的话，其实是一句很含糊的表述，因为它可能是 指一个前端编译器（叫“编译器的前端”更准确一些）把*.java文件转变成*.class文件的过程；也可能是 指Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程；还可能是指使用静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接把程序编译成与目标机器指令集相关的二进制代码的过程。</p>
<p>这3类编译过程里一些比较有代 表性的编译器产品：</p>
<ul>
<li>前端编译器：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）。</li>
<li>即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器。</li>
<li>提前编译器：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET。</li>
</ul>
<p>后面的讨论都限于第一类，即这种由前端编译器完成的编译行为。</p>
<p>但这类编译器实际上并不会做太多优化操作，主要的优化操作都放在虚拟机中。其原因在于JVM还可以运行由其他语言产生的Class文件（如JRuby，Groovy等），将优化操作放到虚拟机中可以使这些语言产生的Class文件也被优化。</p>
<p>但是，如果把“优化”的定义放宽，把对开 发阶段的优化也计算进来的话，Javac确实是做了许多针对Java语言编码过程的优化措施来降低程序员 的编码复杂度、提高编码效率。相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者Java虚拟机的底层改进来支持。</p>
<h1 id="javac编译器"><a href="#javac编译器" class="headerlink" title="javac编译器"></a>javac编译器</h1><p>Javac编译器不像HotSpot虚拟机那样使用 C++语言（包含少量C语言）实现，它本身就是一个由Java语言编写的程序。</p>
<h2 id="javac的源码和调试"><a href="#javac的源码和调试" class="headerlink" title="javac的源码和调试"></a>javac的源码和调试</h2><p>从Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程，它们分别如下：</p>
<ol>
<li>准备过程：初始化插入式注解处理器。</li>
<li>解析与填充符号表过程<ol>
<li>词法、语法分析：将源代码的字符流转变为标记集合，构造出抽象语法树。</li>
<li>填充符号表：产生符号地址和符号信息。</li>
</ol>
</li>
<li>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段。</li>
<li>分析与字节码生成过程<ol>
<li>标注检查：对语法的静态信息进行检查。</li>
<li>数据流及控制流分析：对程序动态运行过程进行检查。</li>
<li>解语法糖：将简化代码编写的语法糖还原为原有的形式。</li>
<li>字节码生成：将前面各个步骤所生成的信息转化成字节码。</li>
</ol>
</li>
</ol>
<p>上述3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转 回到之前的解析、填充符号表的过程中重新处理这些新符号，从总体来看，三者之间的关系与交互顺序如下图所示。</p>
<p><img src="/images/深入理解JVM/Javac的编译过程.png" alt="Javac的编译过程"></p>
<p>我们可以把上述处理过程对应到代码中，Javac编译动作的入口是 <code>com.sun.tools.javac.main.JavaCompiler</code>类，上述3个过程的代码逻辑集中在这个类的<code>compile()</code>和<code>compile2()</code>方法里，其中主体代码如下图所示，整个编译过程主要的处理由图中标注的8个方法来完成。</p>
<p><img src="/images/深入理解JVM/Javac编译过程的主体代码.jpg" alt="Javac编译过程的主体代码"></p>
<h2 id="解析和填充符号表"><a href="#解析和填充符号表" class="headerlink" title="解析和填充符号表"></a>解析和填充符号表</h2><p>解析过程由上图中的<code>parseFiles()</code>方法来完成，解析过程包括了经典程序编译原理中的词法分析和语法分析两个步骤。</p>
<h3 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h3><p><strong>词法分析</strong>是将源代码的字符流转变为标记（Token）集合的过程。</p>
<p><strong>语法分析</strong>是根据标记序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一 种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个 语法结构（Syntax Construct），例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。</p>
<p>经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，后续的操作都 建立在抽象语法树之上。</p>
<h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><p>完成了语法分析和词法分析之后，下一个阶段是对符号表进行填充的过程。</p>
<p>符号表（Symbol Table）是由一组<strong>符号地址</strong>和<strong>符号信息</strong>构成的数据结构。可以把它类比想象成哈希表中键值对的存储形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等各种形式）。</p>
<p>符号表中所登记的 信息在编译的不同阶段都要被用到。譬如在语义分析的过程中，符号表所登记的内容将用于语义检查 （如检查一个名字的使用和原先的声明是否一致）和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</p>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>JDK 5之后，Java语言提供了对注解（Annotations）的支持，注解在设计上原本是与普通的Java代码一样，都只会在程序运行期间发挥作用的。</p>
<p>但在JDK 6中又提出并通过了JSR-269提案，该提案设计了一组被称为“<strong>插入式注解处理器</strong>”的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。可以提前至编译期对代码中的特定注解进行处理， 从而影响到前端编译器的工作过程。</p>
<p>我们可以把插入式注解处理器看作是一组<strong>编译器的插件</strong>，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次（Round）。</p>
<p>在Javac源码中，插入式注解处理器的初始化过程是在<code>initPorcessAnnotations()</code>方法中完成的，而它 的执行过程则是在<code>processAnnotations()</code>方法中完成。这个方法会判断是否还有新的注解处理器需要执 行，如果有的话，通过<code>com.sun.tools.javac.processing.JavacProcessing-Environment</code>类的<code>doProcessing()</code>方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。</p>
<h2 id="语法分析与字节码生成"><a href="#语法分析与字节码生成" class="headerlink" title="语法分析与字节码生成"></a>语法分析与字节码生成</h2><p>经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正 确的源程序，但无法保证源程序的语义是符合逻辑的。而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查，譬如进行类型检查、控制流检查、数据流检查，等等。</p>
<h3 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h3><p>Javac在编译过程中，语义分析过程可分为<strong>标注检查</strong>和<strong>数据及控制流</strong>分析两个步骤。</p>
<p>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等，刚才3个变量定义的例子就属于标注检查的处理范畴。（所谓标注，可以理解为变量的相关检查）</p>
<p>在标注检查中，还会顺便进行 一个称为常量折叠（Constant Folding）的代码优化，这是Javac编译器会对源代码做的极少量优化措施之一（代码优化几乎都在即时编译器中进行）。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>+<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>折叠后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>（Java代码只是示例，实际上javac处理的使抽象语法树节点）</p>
<h3 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h3><p>数据流分析和控制流分析是对程序<strong>上下文逻辑</strong>更进一步的验证，它可以检查出<em>诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题</em>。</p>
<p>编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上可以看作是一致的，但校验范围会有所区别，有一些校验项只有在编译期或运行期才能进行。</p>
<h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机科学家Peter J.Landin发明的一种编程 术语，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言。</p>
<p>Java在现代编程语言之中已经属于“低糖语言”，“低糖”的语法让Java程序实现相同功能的代码量往往高于其他语言。</p>
<p>Java中最常见的语法糖包括了前面提到过的泛型（其他语言中泛型并不一定都是语法糖实现，如 C#的泛型就是直接由CLR支持的）、变长参数、自动装箱拆箱，等等，Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为解语法糖。</p>
<h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由<code>com.sun.tools.javac.jvm.Gen</code>类来 完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p>
<p>例如前文多次登场的实例构造器<code>&lt;init&gt;()</code>方法和类构造器<code>&lt;clinit&gt;()</code>方法就是在这个阶段被添加到语 法树之中的。</p>
<h1 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型的本质是参数化类型（Parameterized Type）或者参数化多态（Parametric Polymorphism）的 应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。</p>
<h3 id="Java与C-的泛型"><a href="#Java与C-的泛型" class="headerlink" title="Java与C#的泛型"></a>Java与C#的泛型</h3><p>Java选择的泛型实现方式叫作“<strong>类型擦除式泛型</strong>”（Type Erasure Generics），而C#选择的泛型实现 方式是“<strong>具现化式泛型</strong>”（Reified Generics）。</p>
<p>在Java中，泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type），并且在相应的地方插入了强制 转型代码。例如，对于运行期的Java语言来说，<code>ArrayList&lt;int&gt;</code>与<code>ArrayList&lt;String&gt;</code>其实是同一个类型。</p>
<p>而在C#中，泛型是实际存在于编译和运行期间的，即<code>List&lt;int&gt;</code>与 <code>List&lt;string&gt;</code>就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。</p>
<p>Java的泛型 确实在实际使用中会有一些限制，如果读者是一名C#开发人员，可能很难想象下面的代码清单中的Java代码都是不合法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeErasureGenerics</span>&lt;<span class="title">E</span>&gt; </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Object item)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123;<span class="comment">// 不合法，无法对泛型进行实例判断 </span></span><br><span class="line">            ...</span><br><span class="line">		&#125; </span><br><span class="line">        E newItem = <span class="keyword">new</span> E();<span class="comment">// 不合法，无法使用泛型创建对象 </span></span><br><span class="line">        E[] itemArray = <span class="keyword">new</span> E[<span class="number">10</span>]; <span class="comment">// 不合法，无法使用泛型创建数组 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这些是Java泛型在编码阶段产生的不良影响。并且由于Java中的泛型可能需要频繁装箱拆箱，所以在性能上也比C#的泛型设计更加差。</p>
<p>而Java之所以如此设计泛型，实际原因在于兼容。擦除式泛型的实现几乎只需要在Javac编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机，也保证了以前没有使用泛型的库可以直接运行在Java 5.0之上。</p>
<h3 id="泛型的历史背景"><a href="#泛型的历史背景" class="headerlink" title="泛型的历史背景"></a>泛型的历史背景</h3><p>泛型思想早在C++语言的模板（Template）功能中就开始生根发芽。其由Martin Odersky着手开发。</p>
<p>Martin Odersky自己在采访自述中提到，进行Generic Java项目的过程中他受到了重 重约束，甚至多次让他感到沮丧，最紧、最难的约束来源于被迫要完全向后兼容无泛型Java，即保 证“二进制向后兼容性”（Binary Backwards Compatibility）。二进制向后兼容性是明确写入《Java语言 规范》中的对Java使用者的严肃承诺，譬如一个在JDK 1.2中编译出来的Class文件，必须保证能够在JDK 12乃至以后的版本中也能够正常运行。</p>
<p>这是Java泛型设计为这种模式的一个重要原因：兼容性。</p>
<p>为了保证这些编译出来的Class文件可以在Java 5.0引入泛型之后继续运行，设计者面前大体上有两 条路可以选择：</p>
<ul>
<li>需要泛型化的类型（主要是容器类型），以前有的就保持不变，然后平行地加一套泛型化版本 的新类型。</li>
<li>直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于 已有类型的泛型版。</li>
</ul>
<p>在这个分叉路口，C#走了第一条路，添加了一组System.Collections.Generic的新容器，以前的 System.Collections以及System.Collections.Specialized容器类型继续存在。</p>
<p>但如果相同的选择出现在Java中就很可能不会是相同的结果了。Java并不是没有做过第一条路那样的技术决策，在JDK 1.2时，遗留代码规模 尚小，Java就引入过新的集合类，并且保留了旧集合类不动。这导致了直到现在标准类库中还有 <code>Vector</code>（老）和<code>ArrayList</code>（新）、有<code>Hashtable</code>（老）和<code>HashMap</code>（新）等两套容器代码并存，如果当 时再摆弄出像<code>Vector</code>（老）、<code>ArrayList</code>（新）、<code>Vector&lt;T&gt;</code>（老但有泛型）、<code>ArrayList&lt;T&gt;</code>（新且有泛型）这样的容器集合，可能叫骂声会比今天听到的更响更大。</p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>由于Java选择了第二条 路，直接把已有的类型泛型化。</p>
<p>要让所有需要泛型化的已有类型，譬如<code>ArrayList</code>，原地泛型化后变成 了<code>ArrayList&lt;T&gt;</code>，而且保证以前直接用<code>ArrayList</code>的代码在泛型新版本里必须还能继续用这同一个容 器，这就必须让所有泛型化的实例类型，譬如<code>ArrayList&lt;Integer&gt;</code>、<code>ArrayList&lt;String&gt;</code>这些全部自动成为<code>ArrayList</code>的子类型才能可以，否则类型转换就是不安全的。</p>
<p>由此就引出了“裸类型”（Raw Type）的概 念，<strong>裸类型应被视为所有该类型泛型化实例的共同父类型</strong>（Super Type），只有这样，像代码清单中的赋值才是被系统允许的从子类到父类的安全转型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rrayList&lt;Integer&gt; ilist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">ArrayList&lt;String&gt; slist = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">ArrayList list; <span class="comment">// 裸类型 </span></span><br><span class="line">list = ilist;</span><br><span class="line">list = slist;</span><br></pre></td></tr></table></figure>
<p>对于如何实现裸类型，有两种选择：</p>
<ul>
<li>在运行期由Java虚拟机来自动 地、真实地构造出<code>ArrayList&lt;Integer&gt;</code>这样的类型，并且自动实现从<code>ArrayList&lt;Integer&gt;</code>派生自ArrayList的继承关系来满足裸类型的定义；</li>
<li>索性简单粗暴地直接在编译时把<code>ArrayList&lt;Integer&gt;</code>还原回<code>ArrayList</code>，只在元素访问、修改时自动插入一些强制类型转换和检查指令。</li>
</ul>
<p>显然Java采用后一种方式。</p>
<p>其结果就如下：</p>
<p>泛型擦除前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>); map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">"hello"</span>)); </span><br><span class="line">    System.out.println(map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型擦除后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap(); </span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>); </span><br><span class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>); </span><br><span class="line">    System.out.println((String) map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，Java的这种设计模式还产生了如下问题：</p>
<h4 id="不支持原始类型的泛型"><a href="#不支持原始类型的泛型" class="headerlink" title="不支持原始类型的泛型"></a>不支持原始类型的泛型</h4><p>一旦把泛型信息擦除后，到要插入强制转型代码的地方就没办法往下做了，因为不支持int、long与Object之间的强制转型。</p>
<p>当时Java给出的解决方案一如既往的简单粗暴：既然没法转换 那就索性别支持原生类型的泛型了。你们都用<code>ArrayList&lt;Integer&gt;</code>、<code>ArrayList&lt;Long&gt;</code>，反正都做了自动的强制类型转换，遇到原生类型时把装箱、拆箱也自动做了得了。这个决定后面导致了无数构造包 装类和装箱、拆箱的开销，<strong>成为Java泛型慢的重要原因</strong>，也成为今天Valhalla项目要重点解决的问题之一。</p>
<p>如下代码就是不支持的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; ilist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;(); </span><br><span class="line">ArrayList&lt;<span class="keyword">long</span>&gt; llist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">long</span>&gt;(); </span><br><span class="line">ArrayList list; </span><br><span class="line">list = ilist;</span><br><span class="line">list = llist;</span><br></pre></td></tr></table></figure>
<h4 id="运行期无法取到泛型类型信息"><a href="#运行期无法取到泛型类型信息" class="headerlink" title="运行期无法取到泛型类型信息"></a>运行期无法取到泛型类型信息</h4><p>这也是很大的一个问题，由于在运行时无法获取到泛型类型。那么就无法通过泛型类型来实例化变量。</p>
<p>对此，不得不采用更加复杂的方法，再将一个对应类型的对象作为形参传入。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType) &#123; </span><br><span class="line">    T[] array = (T[])Array.newInstance(componentType, list.size()); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无法对带泛型的类型做重载"><a href="#无法对带泛型的类型做重载" class="headerlink" title="无法对带泛型的类型做重载"></a>无法对带泛型的类型做重载</h4><p>由于变量擦除。则<code>List&lt;T&gt;</code>与<code>List&lt;M&gt;</code>在擦除后后都变成了<code>List</code>。那么<code>List&lt;T&gt;</code>与<code>List&lt;M&gt;</code>在运行时就是同一种类型，也就无法对其进行重载。</p>
<p>例如下面的代码就是错误的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型对重载规则的影响"><a href="#泛型对重载规则的影响" class="headerlink" title="泛型对重载规则的影响"></a>泛型对重载规则的影响</h4><p>思考以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>); <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="keyword">new</span> ArrayList&lt;String&gt;()); </span><br><span class="line">        method(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考上面的代码，我们说到<code>List&lt;T&gt;</code>与<code>List&lt;M&gt;</code>在运行时就是同一种类型。那么上面的代码实际上在类型擦除后变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">(List list)</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>); <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List list)</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由重载的规则，方法是由方法签名来识别的。而方法签名是由方法名和方法参数构成。</p>
<p>所以上面的方法理论上是无法被重载的，因为这两个方法的方法签名是完全一样的。</p>
<p>但实际测试却是可以执行的。</p>
<p>这又是为什么呢？</p>
<p>其原因在于：方法重载要求方法具备不同的特征签名，返回值并不包含 在方法的特征签名中，所以返回值不参与重载选择，但是在Class文件格式之中，只要描述符不是完全 一致的两个方法就可以共存。也就是说两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存于一个Class文件中的。</p>
<p>即方法签名的限制，仅仅对Java程序有限制，而在指令中，并不受此限制。</p>
<p>JCP组织对《Java虚拟机规 范》做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而 来的参数类型的识别问题，Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。</p>
<p>另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的<strong>Code属性中的字节码进行擦除</strong>，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段取得参数化类型的根本依据。</p>
<h2 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h2><p>纯技术的角度而论，自动装箱、自动拆箱与遍历循环（for-each循环）这些语法糖，无论是实现 复杂度上还是其中蕴含的思想上都不能和泛型相提并论，两者涉及的难度和深度都有很大差距。</p>
<p>其原理就是在字节码中加入对应的操作，如<code>valueOf</code>等。</p>
<p>例如：</p>
<p>原代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123; </span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动装箱、拆箱与遍历循环编译之后（编译后Class文件的反编译结果：）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    List list = Arrays.asList( <span class="keyword">new</span> Integer[] &#123; </span><br><span class="line">        Integer.valueOf(<span class="number">1</span>), </span><br><span class="line">        Integer.valueOf(<span class="number">2</span>), </span><br><span class="line">        Integer.valueOf(<span class="number">3</span>), </span><br><span class="line">        Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue(); </span><br><span class="line">        sum += i;</span><br><span class="line">	&#125; </span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，自动装箱、拆箱在编译之后被转化 成了对应的包装和还原方法，如本例中的Integer.valueOf()与Integer.intValue()方法，而遍历循环则是把代 码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因。最后再看看 变长参数，它在调用的时候变成了一个数组类型的参数，在变长参数出现之前，程序员的确也就是使用数组来完成类似功能的。</p>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>许多程序设计语言都提供了条件编译的途径，如C、C++中使用预处理器指示符（#ifdef）来完成条件编译。</p>
<p>Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。</p>
<p>如下代码清单所示， 该代码中的if语句不同于其他Java代码，它在编译阶段就会被“运行”，生成的字节码之中只包 括“System.out.println(“block 1”)；”一条语句，并不会包含if语句及另外一个分子中的“System.out.println(“block 2”)；”</p>
<p>原码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">        System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后Class文件的反编译结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能力的语句 搭配，则可能在控制流分析中提示错误，被拒绝编译，如下代码清单所示的代码就会被编译器拒绝编译。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 编译器将会提示“Unreachable code” </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">false</span>) &#123; </span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编译器将会把 分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段（com.sun.tools.javac.comp.Lower 类中）完成。由于这种条件编译的实现方式使用了if语句，所以它必须遵循最基本的Java语法，只能写在方法体内部，因此它只能实现语句基本块（Block）级别的条件编译，而没有办法实现根据条件调整整个Java类的结构。</p>
<h1 id="实战：实现Lombok-插入时注解处理器的应用"><a href="#实战：实现Lombok-插入时注解处理器的应用" class="headerlink" title="实战：实现Lombok-插入时注解处理器的应用"></a>实战：实现Lombok-插入时注解处理器的应用</h1><h2 id="插入时注解处理器的应用"><a href="#插入时注解处理器的应用" class="headerlink" title="插入时注解处理器的应用"></a>插入时注解处理器的应用</h2><h3 id="引例1-在编译时打印字符"><a href="#引例1-在编译时打印字符" class="headerlink" title="引例1-在编译时打印字符"></a>引例1-在编译时打印字符</h3><h4 id="注解处理器类"><a href="#注解处理器类" class="headerlink" title="注解处理器类"></a>注解处理器类</h4><p>注解处理器类需要继承自AbstractProcessor，并且实现process方法。init方法相当于构造方法，可以用于初始化对象等。也可以不重写。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_16)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoProc</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">		System.out.println(<span class="string">"init----mw"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"process---mw"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编写一个测试类"><a href="#编写一个测试类" class="headerlink" title="编写一个测试类"></a>编写一个测试类</h4><p>由于是注解处理器，所以我们在测试类上加上注解，自定义的注解处理器才能扫描到。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> Anno &#123; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Anno</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"23"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命令行调用javac"><a href="#命令行调用javac" class="headerlink" title="命令行调用javac"></a>命令行调用javac</h4><ol>
<li><p>编译注释处理器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac AnnoProc.java</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用javac并使用<code>-processor</code>来使用注释处理起来编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac  -processor  AnnoProc TestClass.java</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init----mw</span><br><span class="line">process---mw</span><br><span class="line">process---mw</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>有几点值得注意：</p>
<ul>
<li><p>注解的位置如果不指定，就只会在当前目录下搜索，并且不能通过类路径名来进入下一级目录来查找，比如：<code>processors/AProcessor</code>。如果有package，那么应该使用<code>packege.Processor</code>来指定类，例如<code>priv.mw.ToStringProcessor</code>。如果注解class文件在另外的目录，有两种方法：</p>
<ul>
<li>通过<code>-cp path</code>指定所有类路径，则指定时会从该目录去搜索。</li>
<li>通过<code>-processorpath path</code>指定注释类的路径，则会首先从该目录去搜索（优先级比上面高）。</li>
</ul>
</li>
<li><p><code>@SupportedAnnotationTypes</code>注解确定了当前注释处理器支持的注解类型，按照类名进行匹配。如果使用通配符<code>*</code>，则代表支持所有的注解（包括没有注解的类）。</p>
</li>
</ul>
<h3 id="引例2-检查类中变量的命名规范"><a href="#引例2-检查类中变量的命名规范" class="headerlink" title="引例2-检查类中变量的命名规范"></a>引例2-检查类中变量的命名规范</h3><p>首先明确其命名规范如下：</p>
<ul>
<li>类（或接口）：符合驼式命名法，首字母大写。</li>
<li>方法：符合驼式命名法，首字母小写。</li>
<li>字段：<ul>
<li>类或实例变量。符合驼式命名法，首字母小写。</li>
<li>常量。要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。</li>
</ul>
</li>
</ul>
<p>这里需要介绍一个新的类：<code>javax.lang.model.util.ElementScanner6的NameCheckScanner</code>。其可以减少我们遍历的操作，它会自动帮助我们遍历抽象语法树，然后调用对应的树节点类型的钩子函数。就不用我们再去写逻辑遍历判断了。</p>
<p>代码如下：</p>
<h4 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h4><p>这里也是继承了AbstractProcessor，然后<code>@SupportedAnnotationTypes(&quot;*&quot;)</code>表示支持所有的注解（包括不含注解的类）。然后在里面调用工具类来进行变量合法性判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_16)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoProc</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> NameCheckHandle nameCheckHandle;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">		nameCheckHandle = <span class="keyword">new</span> NameCheckHandle(processingEnv);</span><br><span class="line">		System.out.println(<span class="string">"init----mw"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"process---mw"</span>);</span><br><span class="line">		<span class="keyword">for</span>(Element element : roundEnv.getRootElements())&#123;</span><br><span class="line">			nameCheckHandle.nameCheck(element);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><p>这里主要是继承了<code>ElementScanner14</code>。进行循环的扫描节点，然后调用函数进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.Messager;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementScanner14;</span><br><span class="line"><span class="keyword">import</span> javax.tools.Diagnostic.Kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckHandle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NameCheckScanner nameCheckScanner;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NameCheckHandle</span><span class="params">(ProcessingEnvironment processsingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messager = processsingEnv.getMessager();</span><br><span class="line">        <span class="keyword">this</span>.nameCheckScanner = <span class="keyword">new</span> NameCheckScanner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nameCheck</span><span class="params">(Element element)</span></span>&#123;</span><br><span class="line">        nameCheckScanner.scan(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckScanner</span> <span class="keyword">extends</span> <span class="title">ElementScanner14</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            camelCheck(e, <span class="keyword">false</span>, <span class="string">"方法"</span>);</span><br><span class="line">            <span class="keyword">super</span>.visitExecutable(e, p); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitType</span><span class="params">(TypeElement e, Void p)</span> </span>&#123;</span><br><span class="line">            scan(e.getTypeParameters(), p);</span><br><span class="line">            camelCheck(e, <span class="keyword">true</span>, <span class="string">"类"</span>);</span><br><span class="line">            <span class="keyword">super</span>.visitType(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitVariable</span><span class="params">(VariableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != <span class="keyword">null</span> ||heuristicallyConstant(e))&#123;</span><br><span class="line">                allUpperCheck(e, <span class="string">"常量"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                camelCheck(e, <span class="keyword">false</span>, <span class="string">"变量"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">heuristicallyConstant</span><span class="params">(VariableElement e)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (e.getEnclosingElement().getKind() == ElementKind.INTERFACE) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e.getKind() == ElementKind.FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL))) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">camelCheck</span><span class="params">(Element element, <span class="keyword">boolean</span> upper, String type)</span></span>&#123;</span><br><span class="line">            String name = element.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">char</span> firstChar = name.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(upper)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!Character.isUpperCase(firstChar))&#123;</span><br><span class="line">                    messager.printMessage(Kind.WARNING, type + <span class="string">"名称"</span> + name + <span class="string">"应当以大写字母开头"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!Character.isLowerCase(firstChar))&#123;</span><br><span class="line">                    messager.printMessage(Kind.WARNING, type + <span class="string">"名称"</span> + name + <span class="string">"应当以小写字母开头"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allUpperCheck</span><span class="params">(Element element, String type)</span></span>&#123;</span><br><span class="line">            String name = element.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> child : name.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!Character.isUpperCase(child))&#123;</span><br><span class="line">                    messager.printMessage(Kind.WARNING, type + <span class="string">"名称"</span> + name + <span class="string">"应当全部采用大写"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一点值得注意的是：这里中文容易乱码。</p>
<p>其中有两点：</p>
<ul>
<li><p>在编译是需要加上encoding参数utf-8（如果有中文的话）。</p>
<p>第二次编译的时候就不需要加参数了。</p>
</li>
<li><p>如果电脑是英文，则可能自动将windows区域改为非中文区域。此时需要将区域改回来，否则还是会显示问号’???’。（其路径为控制面板-&gt;时钟和区域-&gt;区域）</p>
</li>
</ul>
<h4 id="附加-ELement子类"><a href="#附加-ELement子类" class="headerlink" title="附加-ELement子类"></a>附加-ELement子类</h4><table border="1" width="100%" cellpadding="3" cellspacing="0" summary=""><br><tbody><tr class="TableSubHeadingColor"><br><th align="left" colspan="2">javax.lang.model.element 中 Element 的子接口</th><br></tr><br><tr class="TableRowColor"><br><td align="right" valign="top" width="1%"><font size="-1"><br><code>&nbsp;interface</code></font></td><br><td><code><b>ExecutableElement</b></code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。</td><br></tr><br><tr class="TableRowColor"><br><td align="right" valign="top" width="1%"><font size="-1"><br><code>&nbsp;interface</code></font></td><br><td><code><b>PackageElement</b></code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示一个包程序元素。</td><br></tr><br><tr class="TableRowColor"><br><td align="right" valign="top" width="1%"><font size="-1"><br><code>&nbsp;interface</code></font></td><br><td><code><b>TypeElement</b></code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示一个类或接口程序元素。</td><br></tr><br><tr class="TableRowColor"><br><td align="right" valign="top" width="1%"><font size="-1"><br><code>&nbsp;interface</code></font></td><br><td><code><b>TypeParameterElement</b></code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示一般类、接口、方法或构造方法元素的形式类型参数。</td><br></tr><br><tr class="TableRowColor"><br><td align="right" valign="top" width="1%"><font size="-1"><br><code>&nbsp;interface</code></font></td><br><td><code><b>VariableElement</b></code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示一个字段、<code>enum</code> 常量、方法或构造方法参数、局部变量或异常参数。</td><br></tr><br></tbody></table>

<h3 id="引例3-生成toString方法"><a href="#引例3-生成toString方法" class="headerlink" title="引例3-生成toString方法"></a>引例3-生成toString方法</h3><p>注意实现要了解下JCTree和TreeMakerAPI。见该文章。</p>
<h4 id="ToStringProcessor"><a href="#ToStringProcessor" class="headerlink" title="ToStringProcessor"></a>ToStringProcessor</h4><p>核心文件：用来生成ToString函数的注解处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.tree.Tree;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.Flags;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.Type;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.processing.JavacProcessingEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> javax.tools.Diagnostic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.api.JavacTrees;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeTranslator;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Context;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.List;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.ListBuffer;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Names;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleToString</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Messager messager;</span><br><span class="line"></span><br><span class="line">    JavacTrees rootTree;</span><br><span class="line"></span><br><span class="line">    TreeMaker treeMaker;</span><br><span class="line"></span><br><span class="line">    Names names;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messager = processingEnv.getMessager();</span><br><span class="line">        <span class="keyword">this</span>.rootTree = JavacTrees.instance(processingEnv);</span><br><span class="line">        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();</span><br><span class="line">        <span class="keyword">this</span>.treeMaker = TreeMaker.instance(context);</span><br><span class="line">        <span class="keyword">this</span>.names = Names.instance(context);</span><br><span class="line">        System.out.println(treeMaker);</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">"ToString！！"</span>);</span><br><span class="line">        Set&lt;? extends Element&gt; rootElements = roundEnv.getRootElements();</span><br><span class="line">        <span class="keyword">for</span> (Element toStringElement : rootElements) &#123;</span><br><span class="line">            JCTree curTree = rootTree.getTree(toStringElement);</span><br><span class="line">            curTree.accept(<span class="keyword">new</span> TreeTranslator()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitClassDef</span><span class="params">(JCTree.JCClassDecl JCClassDeclTree)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isAnnotation(JCClassDeclTree)) <span class="keyword">return</span>;</span><br><span class="line">                    String className = JCClassDeclTree.name.toString();</span><br><span class="line">                    messager.printMessage(Diagnostic.Kind.NOTE, className +<span class="string">"@ToString generate begin!"</span>);</span><br><span class="line">                    <span class="keyword">if</span>(!existToString(JCClassDeclTree))&#123;</span><br><span class="line">                        System.out.println(<span class="string">"不存在ToString"</span>);</span><br><span class="line">                        ListBuffer&lt;JCTree.JCVariableDecl&gt; varsList = <span class="keyword">new</span> ListBuffer();</span><br><span class="line">                        JCClassDeclTree.accept(<span class="keyword">new</span> TreeTranslator() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitVarDef</span><span class="params">(JCTree.JCVariableDecl variableDecl)</span> </span>&#123;</span><br><span class="line">                                System.out.println(variableDecl.getName());</span><br><span class="line">                                varsList.add(variableDecl);</span><br><span class="line">                                <span class="keyword">super</span>.visitVarDef(variableDecl);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        JCTree.JCMethodDecl toStringMethod = createToString(varsList, className);</span><br><span class="line">                        JCClassDeclTree.defs = JCClassDeclTree.defs.append(toStringMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JCTree.<span class="function">JCMethodDecl <span class="title">createToString</span><span class="params">(ListBuffer&lt;JCTree.JCVariableDecl&gt; varsList, String className)</span></span>&#123;</span><br><span class="line">        JCTree.JCBinary content = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (JCTree.JCVariableDecl jcVariableDecl : varsList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(content == <span class="keyword">null</span>)&#123;</span><br><span class="line">                content = treeMaker.Binary(JCTree.Tag.PLUS, treeMaker.Literal(className + <span class="string">"["</span> + jcVariableDecl.getName().toString() +<span class="string">"="</span>), treeMaker.Ident(names.fromString(jcVariableDecl.getName().toString())));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                JCTree.JCBinary temp = treeMaker.Binary(JCTree.Tag.PLUS, treeMaker.Literal(<span class="string">", "</span>+ jcVariableDecl.getName().toString()+<span class="string">"="</span>), treeMaker.Ident(names.fromString(jcVariableDecl.getName().toString())));</span><br><span class="line">                content = treeMaker.Binary(JCTree.Tag.PLUS, content, temp);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        content = treeMaker.Binary(JCTree.Tag.PLUS, content, treeMaker.Literal(<span class="string">"]"</span>));</span><br><span class="line">        JCTree.JCReturn aReturn = treeMaker.Return(content);</span><br><span class="line">        JCTree.JCBlock jcBlock = treeMaker.Block(<span class="number">0</span>, <span class="keyword">new</span> ListBuffer&lt;JCTree.JCStatement&gt;()&#123;&#123;append(aReturn);&#125;&#125;.toList());</span><br><span class="line">        <span class="keyword">return</span> treeMaker.MethodDef(</span><br><span class="line">                treeMaker.Modifiers(Flags.PUBLIC),</span><br><span class="line">                names.fromString(<span class="string">"toString"</span>),</span><br><span class="line">                treeMaker.Ident(names.fromString(<span class="string">"String"</span>)),</span><br><span class="line">                List.nil(),</span><br><span class="line">                List.nil(),</span><br><span class="line">                List.nil(),</span><br><span class="line">                jcBlock,</span><br><span class="line">                <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">existToString</span><span class="params">(JCTree.JCClassDecl classDecl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (JCTree jcTree : classDecl.defs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(jcTree.getKind().equals(Tree.Kind.METHOD))&#123;</span><br><span class="line">                JCTree.JCMethodDecl methodDecl = (JCTree.JCMethodDecl)jcTree;</span><br><span class="line">                <span class="keyword">if</span> (methodDecl.name.equals(<span class="string">"toString"</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnnotation</span><span class="params">(JCTree.JCClassDecl classDecl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(classDecl.getKind().equals(Tree.Kind.ANNOTATION_TYPE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> AString&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">POJO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h4><p>值得注意的是，由于<code>com.sun.*</code>并不是公开API。所以需要手动引入该包，方法是使用<code>-cp</code>加上tools.jar文件。</p>
<p>目前文件结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">processor</span><br><span class="line">		SingleToString.java</span><br><span class="line">POJO.java</span><br></pre></td></tr></table></figure>
<p>在该目录下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译processor</span></span><br><span class="line">C:/Users/MW/.jdks/corretto-1.8.0_312/bin/javac.exe -cp C:/Users/MW/.jdks/corretto-1.8.0_312/lib/tools.jar  -encoding UTF-8 processors/SingleToString.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译POJO文件</span></span><br><span class="line">C:/Users/MW/.jdks/corretto-1.8.0_312/bin/javac.exe -Xlint -cp C:/Users/MW/.jdks/corretto-1.8.0_312/lib/tools.jar  -encoding UTF-8 -processorpath processors -processor SingleToString POJO.java</span><br></pre></td></tr></table></figure>
<p>其中的变量需要根据不同的环境而改变，由于电脑的默认javac是16，所以需要指定绝对地址。其中各个参数解释：</p>
<ul>
<li><code>-cp C:/Users/MW/.jdks/corretto-1.8.0_312/lib/tools.jar</code>：指定tools.jar文件。</li>
<li><code>-encoding UTF-8</code>：指定编码，使之可以显示中文。</li>
<li><code>-processorpath processors</code>：指定processor的路径。</li>
<li><code>-processor SingleToString</code>：指定processor。可以用分号分隔。</li>
</ul>
<h3 id="整体完成"><a href="#整体完成" class="headerlink" title="整体完成"></a>整体完成</h3><p>这里完成了四个基本注解：</p>
<ol>
<li>Getters-注解在类上，为所有字段产生getter方法。</li>
<li>Setters-注解在类上，为所有字段产生setter方法。</li>
<li>ToString-注解在类上，为类产生toString方法。</li>
<li>AllArgsConstructor-注解在类上，为类产生全参构造器方法。</li>
</ol>
<p>整体设计的比较简单，文件架构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priv.mw</span><br><span class="line">		annotaions</span><br><span class="line">				AllArgsConstructor.java</span><br><span class="line">				Getters.java</span><br><span class="line">				Setters.java</span><br><span class="line">				ToString.java</span><br><span class="line">         processors</span><br><span class="line">         		AllArgsConstructorProcessor.java</span><br><span class="line">         		BaseProcessor.java</span><br><span class="line">         		GettersProcessor.java</span><br><span class="line">         		SettersProcessor.java</span><br><span class="line">         		ToStringProcessor.java</span><br><span class="line">         utils</span><br><span class="line">         		TreeUtils.java</span><br><span class="line">         User.java</span><br></pre></td></tr></table></figure>
<p>其中值得注意的点有以下几个点：</p>
<ul>
<li><p><strong>context的获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Context context = ((JavacProcessingEnvironment) processingEnv).getContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>treeMaker的获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">treeMaker = TreeMaker.instance(context);</span><br></pre></td></tr></table></figure>
</li>
<li><p>rootTrees的获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rootTrees = JavacTrees.instance(processingEnv);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造赋值语句（assign）的时候，要想将其加入到block中，必须要使用exec来包装一层。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JCTree.JCAssign assignment = treeMaker.Assign(</span><br><span class="line">                treeMaker.Select(treeMaker.Ident(names.fromString(<span class="string">"this"</span>)), variableDecl.name),</span><br><span class="line">                treeMaker.Ident(variableDecl.name));</span><br><span class="line">ListBuffer&lt;JCTree.JCStatement&gt; jcStatements = <span class="keyword">new</span> ListBuffer&lt;&gt;();</span><br><span class="line">jcStatements.add(treeMaker.Exec(assignment));</span><br><span class="line">JCTree.JCBlock block = treeMaker.Block(<span class="number">0</span>, jcStatements.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于修饰符这块也比较讲究，其构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">treeMaker.Modifiers(Flags.PUBLIC);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>值得注意的是，方法入参的构造：实际上也是一个<code>JCTree.JCVariableDecl</code>，但是比较特别的是此时修饰符应当使用<strong><code>Flags.PARAMETER</code></strong>，所以一个完整的例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JCTree.JCVariableDecl paramVar = treeMaker.VarDef(treeMaker.Modifiers(Flags.PARAMETER), variableDecl.name, variableDecl.vartype, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>javac编译时的问题，见<a href="https://www.mw530.cn/2022/04/28/javac%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E5%8F%82%E8%80%83/" target="_blank" rel="noopener">javac命令参数参考</a>。</p>
</li>
</ul>
<p>源代码见这里：这里</p>
<ul>
<li><a href="https://github.com/MW530/MLombok" target="_blank" rel="noopener">github</a></li>
<li><a href="https://gitee.com/mw530/mlombok" target="_blank" rel="noopener">gitee</a></li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>程序编译与代码优化</tag>
        <tag>前端编译与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云数据库开发规范</title>
    <url>/2022/05/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><p>1.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循:</p>
<ul>
<li>不是频繁修改的字段。</li>
<li>不是 varchar 超长字段，更不能是 text 字段。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">正例:商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。</span><br></pre></td></tr></table></figure>
<p>2.【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明:如果预计2年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
<p>3.【推荐】id必须是主键，每个表必须有主键，且保持增长趋势的， 小型系统可以依赖于 MySQL 的自增主键，大型系统或者需要分库分表时才使用内置的 ID 生成器</p>
<p>4.【强制】id类型没有特殊要求，必须使用bigint unsigned，禁止使用int，即使现在的数据量很小。id如果是数字类型的话，必须是8个字节。参见最后例子</p>
<ul>
<li>方便对接外部系统，还有可能产生很多废数据</li>
<li>避免废弃数据对系统id的影响</li>
<li>未来分库分表，自动生成id，一般也是8个字节</li>
</ul>
<p>5.【推荐】字段尽量设置为 NOT NULL， 为字段提供默认值。 如字符型的默认值为一个空字符值串’’;数值型默认值为数值 0;逻辑型的默认值为数值 0;</p>
<p>6.【推荐】每个字段和表必须提供清晰的注释</p>
<p>7.【推荐】时间统一格式:<code>YYYY-MM-DD HH:MM:SS</code></p>
<p>8.【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间</p>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint ( 1表示是，0表示否)。<br>说明:任何字段如果为非负数，必须是 unsigned。<br>正例:表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。<br>2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明:MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库 名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例:health_user，rdc_config，level3_name 反例:HealthUser，rdcConfig，level_3_name<br>3.【强制】表名不使用复数名词。 说明:表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数 形式，符合表达习惯。<br>4.【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。<br>5.【强制】主键索引名为 pk_字段名;唯一索引名为 uk_字段名;普通索引名则为 idx_字段名。<br>说明:pk_ 即 primary key;uk_ 即 unique key;idx_ 即 index 的简称。<br>6.【强制】小数类型为 decimal，禁止使用 float 和 double。<br>说明:float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。<br>7.【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。<br>8.【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。<br>9.【强制】表必备三字段:id, is_delete,gmt_create, gmt_modified。 说明:其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create, gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被 动更新。<br>10.【强制】所有命名必须使用全名，有默认约定的除外，如果超过 30 个字符，使用缩写，请尽量名字易懂简短，如 description –&gt; desc;information –&gt; info;address –&gt; addr 等<br>11.【推荐】表的命名最好是加上“业务名称_表的作用”。 正例:health_user / trade_config<br>12.【推荐】库名与应用名称尽量一致。如health<br>13.【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释<br>14.【推荐】所有时间字段，都以 gmt_开始，后面加上动词的过去式，最后不要加上 time 单词，例如 gmt_create</p>
<h2 id="类型规范"><a href="#类型规范" class="headerlink" title="类型规范"></a>类型规范</h2><p>1.表示状态字段(0-255)的使用 TINYINT UNSINGED，禁止使用枚举 类型，注释必须清晰地说明每个枚举的含义，以及是否多选等</p>
<p>2.表示boolean类型的都使用TINYINT(1),因为mysql本身是没有boolean类型的，在自动生成代码的时候，DO对象的字段就是boolean类型，例如 is_delete;其余所有时候都使用TINYINT(4)</p>
<blockquote>
<p>TINYINT(4),这个括号里面的数值并不是表示使用多大空间存储，而是最大显示宽度，并且只有字段指定zerofill时有用，没有zerofill，(m)就是无用的,例如id BIGINT ZEROFILL NOT NULL,所以建表时就使用默认就好了，不需要加括号了，除非有特殊需求，例如TINYINT(1)代表boolean类型。</p>
</blockquote>
<blockquote>
<p>TINYINT(1)，TINYINT(4)都是存储一个字节，并不会因为括号里的数字改变。例如TINYINT(4)存储22则会显示0022，因为最大宽度为4，达不到的情况下用0来补充。</p>
</blockquote>
<p>3.【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>表示范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>tinyint</td>
<td>1</td>
<td>无符号值: 0～255;有符号值： -128~127</td>
</tr>
<tr>
<td>smallint</td>
<td>2</td>
<td>无符号值: 0～65536;有符号值： -32768~32767</td>
</tr>
<tr>
<td>mediumint</td>
<td>3</td>
<td>无符号值: 0～16777215;有符号值： -8388608~8388607</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>无符号值: 0~4294967295;有符号值： -2147483648~2147483647</td>
</tr>
<tr>
<td>bigint</td>
<td>8</td>
<td>无符号值: 0~((2³²×²)-1);有符号值： -(2³²×²)/2 ~ (2³²×²)/2-1</td>
</tr>
</tbody>
</table>
<p>4.非负的数字类型字段，都添加上 UNSINGED, 如可以使用 INT UNSINGED 字段存 IPV4</p>
<p>5.时间字段使用时间日期类型，不要使用字符串类型存储，日期使用DATE类型，年使用YEAR类型，日期时间使用DATETIME</p>
<p>6.字符串VARCHAR(N), 其中 N表示字符个数，请尽量减少 N 的大小，参考：code VARCHAR(32)；name VARCHAR(32)；memo VARCHAR(512)；</p>
<p>7.Blob 和 Text 类型所存储的数据量大，删除和修改操作容易在数 据表里产生大量的碎片，避免使用 Blob 或 Text 类型</p>
<h2 id="索引规范"><a href="#索引规范" class="headerlink" title="索引规范"></a>索引规范</h2><p>1.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</p>
<blockquote>
<p>不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的;另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。</p>
</blockquote>
<p>2.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致;多表关联查询时， 保证被关联的字段需要有索引。</p>
<blockquote>
<p>即使双表 join 也要注意表索引、SQL 性能。</p>
</blockquote>
<p>3.【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。 说明:索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>
<p>4.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
<blockquote>
<p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</blockquote>
<p>5.【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。</p>
<blockquote>
<p>正例:where a=? and b=? order by c; 索引:a_b_c 反例:索引中有范围查找，那么索引有序性无法利用，如:WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p>
</blockquote>
<p>6.【推荐】利用覆盖索引来进行查询操作，避免回表。<br>说明:如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗?目录浏览一下就好，这个目录就是起到覆盖索引的作用。</p>
<blockquote>
<p>正例:能够建立索引的种类:主键索引、唯一索引、普通索引，而覆盖索引是一种查询的效果，用explain的结果，extra列会出现:using index。</p>
</blockquote>
<p>7.【推荐】利用延迟关联或者子查询优化超多分页场景。<br>说明:MySQL并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p>
<blockquote>
<p>正例:先快速定位需要获取的 id 段，然后再关联:</p>
</blockquote>
<p>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p>
<p>8.【推荐】SQL 性能优化的目标:至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。</p>
<p>说明:</p>
<ul>
<li>consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。</li>
<li>ref 指的是使用普通的索引(normal index)。</li>
<li>range 对索引进行范围检索。<br>反例:explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级 别比较 range 还低，与全表扫描是小巫见大巫。</li>
</ul>
<p>9.【推荐】建组合索引的时候，区分度最高的在最左边。<br>正例:如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即 可。</p>
<blockquote>
<p>说明:存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如:where a&gt;? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。</p>
</blockquote>
<p>10【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。</p>
<p>11.【参考】创建索引时避免有如下极端误解</p>
<ul>
<li>宁滥勿缺。认为一个查询就需要建一个索引。</li>
<li>宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。</li>
<li>抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</li>
</ul>
<ol start="12">
<li>总结</li>
</ol>
<ul>
<li>索引占磁盘空间，不要重复的索引，尽量短  </li>
<li>只给常用的查询条件加索引  </li>
<li>过滤性高的列建索引，取值范围固定的列不建索引 </li>
<li>唯一的记录添加唯一索引  </li>
<li>频繁更新的列不要建索引  </li>
<li>不要对索引列运算  </li>
<li>同样过滤效果下，保持索引长度最小  </li>
<li>合理利用组合索引，注意索引字段先后顺序  </li>
<li>多列组合索引，过滤性高的字段最前  </li>
<li>order by 字段建立索引，避免 filesort  </li>
<li>组合索引，不同的排序顺序不能使用索引  </li>
<li>&lt;&gt;!=无法使用索引</li>
</ul>
<h2 id="SQL规范"><a href="#SQL规范" class="headerlink" title="SQL规范"></a>SQL规范</h2><p>1.【强制】不要使用 count(列名)或 count(常量)来替代 count()，count()是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p>
<blockquote>
<p>count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
</blockquote>
<p>2.【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，</p>
<blockquote>
<p>count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</p>
</blockquote>
<p>3.【强制】当某一列col的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。</p>
<blockquote>
<p>正例:可以使用如下方式来避免sum的NPE问题:SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</p>
</blockquote>
<p>4.【强制】使用 ISNULL()来判断是否为 NULL 值。 说明:NULL 与任何值的直接比较都为 NULL。</p>
<ul>
<li>NULL&lt;&gt;NULL的返回结果是NULL，而不是false。</li>
<li>NULL=NULL的返回结果是NULL，而不是true。</li>
<li>NULL&lt;&gt;1的返回结果是NULL，而不是true。</li>
</ul>
<p>5.【强制】 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p>
<p>6.【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明:以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为 级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻 塞，存在数据库更新风暴的风险;外键影响数据库的插入速度。</p>
<p>7.【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
<p>8.【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p>
<p>9.【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控<br>制在 1000 个之内。</p>
<p>10.【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数 的区别。</p>
<p>SELECT LENGTH(“轻松工作”); 返回为12<br>SELECT CHARACTER_LENGTH(“轻松工作”); 返回为4 如果需要存储表情，那么选择 utfmb4 来进行存储，注意它与 utf-8 编码的区别。</p>
<p>11.【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。 说明:TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
<p>12.【推荐】不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字 段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错;二是效率低;三是增加 binlog 存储。</p>
<p>13.总结</p>
<ul>
<li>能够快速缩小结果集的 WHERE 条件写在前面，如果有恒量条 件，也尽量放在前面 ，例如 where 1=1  </li>
<li>避免使用 GROUP BY、DISTINCT 等语句的使用，避免联表查 询和子查询 </li>
<li>能够使用索引的字段尽量进行有效的合理排列  </li>
<li>针对索引字段使用 &gt;, &gt;=, =, &lt;, &lt;=, IF NULL 和 BETWEEN 将会 使用索引，如果对某个索引字段进行 LIKE 查询，使用 LIKE   ‘%abc%’ 不能使用索引，使用 LIKE ‘abc%’ 将能够使用索引  </li>
<li>如果在 SQL 里使用了 MySQL部分自带函数，索引将失效</li>
<li>避免直接使用 select *,只取需要的字段，增加使用覆盖索引使用的可能  </li>
<li>对于大数据量的查询，尽量避免在 SQL 语句中使用 order by 字句 </li>
<li>连表查询的情况下，要确保关联条件的数据类型一致，避免嵌套子查询  </li>
<li>对于连续的数值，使用 between 代替 in  </li>
<li>where 语句中尽量不要使用 CASE 条件  </li>
<li>当只要一行数据时使用 LIMIT 1</li>
</ul>
<h2 id="ORM映射"><a href="#ORM映射" class="headerlink" title="ORM映射"></a>ORM映射</h2><p>1.【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。<br>   说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap配置不一致。<br>2.【强制】POJO类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap中进行字段与属性之间的映射。<br>   说明：参见定义 POJO类以及数据库字段定义规定，在<resultMap>中增加映射，是必须的。在 MyBatis Generator生成的代码中，需要进行对应的修改。<br>3.【强制】不要用 resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。<br>   说明：配置映射关系，使字段与 DO类解耦，方便维护。<br>4.【强制】sql.xml配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL注入。<br>5.【强制】iBATIS自带的 queryForList(String statementName,int start,int size)不推荐使用。<br>   说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取 start,size的子集合。<br>   正例：Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();<br>        map.put(“start”, start);<br>        map.put(“size”, size);<br>6.【强制】不允许直接拿 HashMap与 Hashtable作为查询结果集的输出。<br>   说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。<br>7.【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified字段值为当前时间。<br>8.【推荐】不要写一个大而全的数据更新接口传入为 POJO类，不管是不是自己的目标更新字段，都进行  update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog存储。</p>
<p>9.【参考】@Transactional事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。<br>10.【参考】<isEqual>中的 compareValue是与属性值对比的常量，一般是数字，表示相等时带 上此条件；<isNotEmpty>表示不为空且不为 null时执行；<isNotNull>表示不为 null值时执行。*</p>
<p>*</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`health_package`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'序号'</span>,</span><br><span class="line">  <span class="string">`package_id`</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'套系 id'</span>,</span><br><span class="line">  <span class="string">`module_id`</span>  <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'模块 id'</span>,</span><br><span class="line">  <span class="string">`is_delete`</span> <span class="built_in">tinyint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'是否删除，0-未删除，1-删除，默认为0'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'Create time, common column by DB rules'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'Modified time,common column by DB rules '</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">COMMENT</span>=<span class="string">'This table stores module and package of health for ...'</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>阿里云</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM2-1-虚拟机执行子系统-类文件结构</title>
    <url>/2022/04/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM2-1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="类无关性的基石"><a href="#类无关性的基石" class="headerlink" title="类无关性的基石"></a>类无关性的基石</h1><p>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不与包括Java语言在内的任何 程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。</p>
<p>作为一个通用的、与机器无关的执行平 台，任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础，以Class文件作为他们产品 的交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他 语言的编译器一样可以把它们的源程序代码编译成Class文件。虚拟机丝毫不关心Class的来源是什么语<br>言，它与程序语言之间的关系如图所示。</p>
<p><img src="/images/深入理解JVM/Java虚拟机提供的语言无关性.jpg" alt="Java虚拟机提供的语言无关性"></p>
<h1 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h1><p>Java技术能够一直保持着非常良好的向后兼容性，Class文件结构的稳定功不可没。</p>
<blockquote>
<p>注意：任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不需要以磁盘文件的形式存在。</p>
</blockquote>
<p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数 据，这种伪结构中只有两种数据类型：“无符号数”和“表”。后面的解析都要以这两种数据类型为基础，所以这里笔者必须先解释清楚这两个概念。</p>
<p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由表6-1所示的数据项按严格顺序排列构成。</p>
<p><img src="/images/深入理解JVM/Class结构.jpg" alt="Class结构"></p>
<p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。 </p>
<p><strong>Class的结构不像XML等描述语言，由于它没有任何分隔符 号，所以在表6-1中的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class 文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变。</strong></p>
<h2 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h2><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为 一个能被虚拟机接受的Class文件。</p>
<p>不仅是Class文件，很多文件格式标准中都有使用魔数来进行身份识 别的习惯，譬如图片格式，如GIF或者JPEG等在文件头中都存有魔数。使用魔数而不是扩展名来进行 识别主要是基于安全考虑，因为文件扩展名可以随意改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆。</p>
<p>Class文件的魔数取得很有“浪漫气息”， 值为0xCAFEBABE（咖啡宝贝？）。</p>
<h3 id="Class文件的版本"><a href="#Class文件的版本" class="headerlink" title="Class文件的版本"></a>Class文件的版本</h3><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。</p>
<p>Java的版本号是从45开始的，JDK 1.1之后 的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能 向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文 件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class<br>文件。</p>
<p>例如，JDK 1.1能支持版本号为45.0～45.65535的Class文件，无法执行版本号为46.0以上的Class文 件，而JDK 1.2则能支持45.0～46.65535的Class文件。目前最新的JDK版本为13，可生成的Class文件主<br>版本号最大值为57.0。</p>
<p>下面是部分版本对应</p>
<p><img src="/images/深入理解JVM/class部分版本对应.jpg" alt="class部分版本对应"></p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class 文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</p>
<p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常 量池容量计数值（constant_pool_count）（即在常量池表之前会有一个u2的constant_pool_count的变量表示常量池的中常量的个数）。</p>
<p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p>
<p>字面量比 较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译<br>原理方面的概念，主要包括下面几类常量：</p>
<ul>
<li>被模块导出或者开放的包（Package） </li>
<li>类和接口的全限定名（Fully Qualified Name） </li>
<li>字段的名称和描述符（Descriptor） </li>
<li>方法的名称和描述符 </li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
<p>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class 文件的时候进行动态连接（具体见第7章）。也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号 引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
<p>常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，后来为了 更好地支持动态语言调用，额外增加了4种动态语言相关的常量。</p>
<p>这17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位（tag，取值见表6-3中标 志列），代表着当前常量属于哪种常量类型。17种常量类型所代表的具体含义如下表所示。</p>
<p><img src="/images/深入理解JVM/常量池的项目类型.jpg" alt="常量池的项目类型"></p>
<p>之所以说常量池是最烦琐的数据，是因为这17种常量类型各自有着完全独立的数据结构，两两之间并没有什么共性和联系，因此只能逐项进行讲解。</p>
<p>例如：CONSTANT_Class_info</p>
<p><img src="/images/深入理解JVM/CONSTANT_Class_info.jpg" alt="CONSTANT_Class_info"></p>
<p>tag是标志位，它用于区分常量类型；name_index是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名，本例中的 name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量。继续从图63中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个CONSTANT_Utf8_info类型的常量。CONSTANT_Utf8_info类型的结构如表所示。</p>
<p><img src="/images/深入理解JVM/CONSTANT_Utf8_info.jpg" alt="CONSTANT_Utf8_info"></p>
<p>length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连 续数据是一个使用UTF-8缩略编码表示的字符串。UTF-8缩略编码与普通UTF-8编码的区别是： 从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示， 从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’开始到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</p>
<p>其所有类型结构如下：</p>
<p><img src="/images/深入理解JVM/常量池1.jpg" alt="常量池1"></p>
<p><img src="/images/深入理解JVM/常量池2.jpg" alt="常量池2"></p>
<p><img src="/images/深入理解JVM/常量池3.jpg" alt="常量池3"></p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或 者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。</p>
<p><img src="/images/深入理解JVM/访问标志.jpg" alt="访问标志"></p>
<p>access_flags中一共有16个标志位可以使用，当前只定义了其中9个，没有使用到的标志位要求一 律为零。</p>
<h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合 （interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。</p>
<p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>
<p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>
<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类 型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过 CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p>
<p>下面展示了类索引查找过程：</p>
<p><img src="/images/深入理解JVM/类索引过程.jpg" alt="类索引过程"></p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表（field_info）用于描述接口或者类中声明的变量。</p>
<p>Java语言中的“字段”（Field）包括类级变 量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<p>字段可以包括的修饰符有字段的作用域（public、private、protected修饰 符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否 强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。</p>
<p>字段表结构如下：</p>
<p><img src="/images/深入理解JVM/字段表结构.jpg" alt="字段表结构"></p>
<p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数 据类型，其中可以设置的标志位和含义如表所示。</p>
<p><img src="/images/深入理解JVM/字段访问标志.jpg" alt="字段访问标志"></p>
<p>很明显，由于语法规则的约束，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最 多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所导致的。</p>
<p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引 用，分别代表着字段的简单名称以及字段和方法的描述符。</p>
<p>根据描述符规则，基本数据类 型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示</p>
<p><img src="/images/深入理解JVM/描述符标识字符含义.jpg" alt="描述符标识字符含义"></p>
<p>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型 的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。</p>
<p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序 放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符 为“()Ljava/lang/String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>Class文件存储 格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依 次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表<br>集合（attributes）几项，如表所示。</p>
<p><img src="/images/深入理解JVM/方法表结构.jpg" alt="方法表结构"></p>
<p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了 ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract 关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、 ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。对于方法表，所有标志位及其取值可参见下表。</p>
<p><img src="/images/深入理解JVM/方法访问标志.jpg" alt="方法访问标志"></p>
<p>方法里的Java代码，经过Javac编译器编译成字节码指令之 后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目。</p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以 携带自己的属性表集合，以描述某些场景专有的信息。</p>
<p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一 些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任 何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识 的属性。为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29。</p>
<p><img src="/images/深入理解JVM/虚拟机规范预定义的属性1.jpg" alt="虚拟机规范预定义的属性1"></p>
<p><img src="/images/深入理解JVM/虚拟机规范预定义的属性2.jpg" alt="虚拟机规范预定义的属性2"></p>
<p>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示， 而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足表6-14中所定义的结构。</p>
<p><img src="/images/深入理解JVM/属性表结构.jpg" alt="属性表结构"></p>
<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。 Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如下表所示。</p>
<p><img src="/images/深入理解JVM/Code属性表的结构.jpg" alt="Code属性表的结构"></p>
<p>其结构如下：</p>
<ul>
<li><p>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它 代表了该属性的属性名称。</p>
</li>
<li><p>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为 6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。</p>
</li>
<li><p>max_stack代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都 不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。</p>
</li>
<li><p>max_locals代表了局部变量表所需的存储空间。</p>
<p>变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和 returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。方法参数（包括实例方法中的隐藏参数“this”）、显式异常处 理程序的参数（Exception Handler Parameter，就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。</p>
</li>
</ul>
<p>关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达 到2的32次幂，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译。</p>
<h3 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h3><p>这里的Exceptions属性是在方法表中与Code属性平级的一项属性，不要与前面刚刚讲解完的异 常表产生混淆。Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。</p>
<p>其结构如下：</p>
<p><img src="/images/深入理解JVM/Exception属性结构.jpg" alt="Exception属性结构"></p>
<p>其他结构省略。</p>
<h1 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h1><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode） 以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。</p>
<p>由于Java虚拟机采用<strong>面向操作数栈</strong>而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。</p>
<p>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了Java虚 拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条；</p>
<p>又由于 Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构，譬如要将一个16位长度的无符号整数使用两个无符号字节存储起来（假设将它们命名为byte1和byte2）。</p>
<h2 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h2><p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。举个例子，iload指 令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两 条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为 哪种数据类型服务：</p>
<ul>
<li>i代表对int类型的数据操作，</li>
<li>l代表long，</li>
<li>s代表short，</li>
<li>b代表byte，</li>
<li>c代表char，</li>
<li>f代表 float，</li>
<li>d代表double，</li>
<li>a代表reference。</li>
</ul>
<p>也有一些指令的助记符中没有明确指明操作类型的字母，例如 arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，例如无条件跳转指令goto则是与数据类型无关的指令。</p>
<p>因为Java虚拟机的操作码长度只有一字节，所以包含了数据类型的操作码就为指令集的设计带来 了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那么 指令的数量恐怕就会超出一字节所能表示的数量范围了。因此，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会被故意设计成非完全独立的。</p>
<p>其字节和操作对应如下：</p>
<p><img src="/images/深入理解JVM/Java虚拟机指令集所支持的数据类型1.jpg" alt="Java虚拟机指令集所支持的数据类型1"></p>
<p><img src="/images/深入理解JVM/Java虚拟机指令集所支持的数据类型2.jpg" alt="Java虚拟机指令集所支持的数据类型2"></p>
<p>请注意，从表6-40中看来，大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令 支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为 相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来 处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。</p>
<h2 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h2><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之 间来回传输，这类指令包括：</p>
<ul>
<li>将一个局部变量加载到操作栈：<code>iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、 dload_&lt;n&gt;、aload、aload_&lt;n&gt;</code></li>
<li>将一个数值从操作数栈存储到局部变量表：<code>istore、istore_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、 fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt;</code></li>
<li>将一个常量加载到操作数栈：<code>bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</code></li>
<li>扩充局部变量表的访问索引的指令：<code>wide</code></li>
</ul>
<p>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令， 如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p>
<h2 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h2><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上 运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。整数与浮点数 的算术指令在溢出和被零除的时候也有各自不同的行为表现。无论是哪种算术指令，均是使用Java虚 拟机的算术类型来进行计算的，换句话说是不存在直接支持byte、short、char和boolean类型的算术指令，对于上述几种数据的运算，应使用操作int类型的指令代替。所有的算术指令包括：</p>
<ul>
<li>加法指令：<code>add、ladd、fadd、dadd</code></li>
<li>减法指令：<code>isub、lsub、fsub、dsub</code></li>
<li>乘法指令：<code>imul、lmul、fmul、dmul</code></li>
<li>除法指令：<code>idiv、ldiv、fdiv、ddiv</code></li>
<li>求余指令：<code>irem、lrem、frem、drem</code></li>
<li>取反指令：<code>ineg、lneg、fneg、dneg</code></li>
<li>位移指令：<code>ishl、ishr、iushr、lshl、lshr、lushr</code></li>
<li>按位或指令：<code>ior、lor</code></li>
<li>按位与指令：<code>iand、land</code></li>
<li>按位异或指令：<code>ixor、lxor</code></li>
<li>局部变量自增指令：<code>iinc</code></li>
<li>比较指令：<code>dcmpg、dcmpl、fcmpg、fcmpl、lcmp</code></li>
</ul>
<h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显 式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
<p>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）：</p>
<ul>
<li>int类型到long、float或者double类型 </li>
<li>long类型到float、double类型</li>
<li>float类型到double类型</li>
</ul>
<p>与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指 令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p>
<p>在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的 内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。</p>
<p>Java虚拟机将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，必须遵循以 下转换规则： </p>
<ul>
<li>如果浮点值是NaN，那转换结果就是int或long类型的0。 </li>
<li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v。如果v在<br>目标类型T（int或long）的表示范围之类，那转换结果就是v；否则，将根据v的符号，转换为T所能表<br>示的最大或者最小正数。</li>
</ul>
<h2 id="对象创建于访问指令"><a href="#对象创建于访问指令" class="headerlink" title="对象创建于访问指令"></a>对象创建于访问指令</h2><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p>
<ul>
<li>创建类实例的指令：new </li>
<li>创建数组的指令：newarray、anewarray、multianewarray </li>
<li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的<br>指令：getfield、putfield、getstatic、putstatic </li>
<li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、<br>daload、aaload </li>
<li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、<br>dastore、aastore </li>
<li>取数组长度的指令：arraylength</li>
<li>检查类实例类型的指令：instanceof、checkcast</li>
</ul>
<h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指 令，包括：</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2 </li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、<br>dup2_x1、dup_x2、dup2_x2</li>
<li>将栈最顶端的两个数值互换：swap</li>
</ul>
<h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下 一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令包括：</p>
<ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne </li>
<li>复合条件分支：tableswitch、lookupswitch</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li>
</ul>
<p>在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明 显标识一个数据的值是否null，也有专门的指令用来检测null值。</p>
<h2 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h2><p>方法调用（分派、执行过程）将在第8章具体讲解，这里仅列举以下五条指令用于方法调用：</p>
<ul>
<li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）， 这也是Java语言中最常见的方法分派方式。 </li>
<li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找<br>出适合的方法进行调用。 </li>
<li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和<br>父类方法。 ·invokestatic指令：用于调用类静态方法（static方法）。 </li>
<li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面<br>四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑<br>是由用户所设定的引导方法决定的。</li>
</ul>
<p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返 回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。</p>
<h2 id="异步处理指令"><a href="#异步处理指令" class="headerlink" title="异步处理指令"></a>异步处理指令</h2><p>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛 出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常 状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出 ArithmeticException异常。</p>
<p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成。</p>
<h2 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h2><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p>
<p>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。</p>
<p>虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。</p>
<p>当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成 还是非正常完成）时释放管程。</p>
<p>在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p>
<p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中 有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机执行子系统</tag>
        <tag>类文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM4-1-高效并发-Java内存模型与线程</title>
    <url>/2022/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM4-1-%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="硬件和效率一致性"><a href="#硬件和效率一致性" class="headerlink" title="硬件和效率一致性"></a>硬件和效率一致性</h1><p>由于CPU的的运算是需要存储空间的，光是寄存器肯定是远远不够的。但是内存的传递速度远远比CPU的运算速度慢，则需要一个比内存快一些的空间作为CPU运行时数据的临时存储空间。而这个空间就是所谓的高速缓存（Cache）来作为内存与处理器之间的缓冲：将内存需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。</p>
<p>基于高速缓存的存储交互虽然很好的解决了处理器与内存之间的矛盾，但是也为计算机系统带来了另外一个问题：缓存一致性（Cache Coherence）。</p>
<p>在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享统一主内存（Main Memory）。这种系统称为共享内存多核系统。所以在多个处理器的运算任务都涉及同一块主存区域时，将可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协 议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p>
<p>下面是一个基本示意图：</p>
<p><img src="/images/深入理解JVM/处理器、高速缓存、主内存间的交互关系.jpg" alt="处理器、高速缓存、主内存间的交互关系"></p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>《Java虚拟机规范》中曾试图定义一种“Java内存模型”（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效 果。在此之前，主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，所以在某些场景下必须针对不同的平台来编写程序。</p>
<h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到 内存和从内存中取出变量值这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区 别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p>
<p>Java内存模型规定了所有的变量都存储在<strong>主内存</strong>（Main Memory）中（此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）。<strong>每条线程还有自己的工作内存</strong>（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示，注意与上图进行对比。</p>
<p><img src="/images/深入理解JVM/线程、主内存、工作内存三者的交互关系-Java.jpg" alt="线程、主内存、工作内存三者的交互关系-Java"></p>
<p>这里所讲的主内存、工作内存与之前所讲的Java内存区域中的Java堆、栈、方法区等并不是同一 个层次的对内存的划分，这两者基本上是没有任何关系的。如果两者一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于<strong>Java堆</strong>中的对象实例数据部分，而工作内存则对应于<strong>虚拟机栈</strong>中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了 获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。</p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从 工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实 现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）：</p>
<ul>
<li>lock（锁定）：<strong>作用于主内存的变量</strong>，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：<strong>作用于主内存的变量</strong>，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：<strong>作用于主内存的变量</strong>，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：<strong>作用于工作内存的变量</strong>，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：<strong>作用于工作内存的变量</strong>，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：<strong>作用于工作内存的变量</strong>，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：<strong>作用于工作内存的变量</strong>，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：<strong>作用于主内存的变量</strong>，它把store操作从工作内存中得到的变量的值放入主内存的 变量中。</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存：那就要按顺序执行read和load操作。</p>
<p>如果要把变量从 工作内存同步回主内存：就要按顺序执行store和write操作。</p>
<p>注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。</p>
<p>除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li><strong>一个新的变量只能在主内存中“诞生”</strong>，不允许在工作内存中直接使用一个未被初始化（load或 assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li><strong>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值</strong>。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
<p>本质上Java底层对多线程变量的共享有以上规则，如果所有开发人员按照上面的逻辑来开发，那可能过于复杂了。因此Java团队将Java内存模型的操作简化为read、write、lock和unlock四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变，即使是这四操作种，对于普通用户来说阅读使用起来仍然并不方便。</p>
<h2 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h2><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易被正确、完整地理解，以至于许多程序员都习惯去避免使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。</p>
<p>当一个变量被定义成volatile之后，它将具备两项特性：</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><strong>保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong>而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。</p>
<p>值得注意的是：volatile变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题）。<em>但是Java里面的运算操作符并非原子操作， 这导致volatile变量的运算在并发下一样是不安全的。</em></p>
<p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁 （使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<h3 id="禁止重排"><a href="#禁止重排" class="headerlink" title="禁止重排"></a>禁止重排</h3><p>使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions; </span><br><span class="line"><span class="keyword">char</span>[] configText; <span class="comment">// 此变量必须定义为volatile </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行 </span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后 </span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用 </span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap(); </span><br><span class="line">configText = readConfigFile(fileName); </span><br><span class="line">processConfigOptions(configText, configOptions); </span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行 </span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成 </span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125; <span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>
<p>代码清单12-4中所示的程序是一段伪代码，其中描述的场景是开发中常见配置读取过程，只是我们在处理配置文件时一般不会出现并发，所以没有察觉这会有问题。试想一下，如果定义 initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一条 代码“initialized=true”被提前执行（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这条语句对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>在某些情况下，volatile的同步机制的性能确实要优于锁 （使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和 优化，使得我们很难确切地说volatile就会比synchronized快上多少。如果让volatile自己与自己比较，那 可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
<p>最后看一下Java内存模型中对volatile变量定义的特殊规则的定义。假定T表示 一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：</p>
<ul>
<li><p>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且， 只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联的，<strong>必须连续且一起出现</strong>。</p>
<p><strong>这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改。</strong></p>
</li>
<li><p>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现。</p>
<p><strong>这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中</strong>，用于保证其他线程可以 看到自己对变量V所做的修改。</p>
</li>
<li><p>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动 作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W 实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q。</p>
<p><strong>这条规则要求volatile修饰的变量不会被指令重排序优化</strong>，从而保证代码的执行顺序与程序的顺序相同。</p>
</li>
</ul>
<h2 id="针对long和double型变量的特殊规则"><a href="#针对long和double型变量的特殊规则" class="headerlink" title="针对long和double型变量的特殊规则"></a>针对long和double型变量的特殊规则</h2><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write这八种操作都具有原子性， 但是对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：允许虚拟机将没有 被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否 要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的<strong>“long和double的非原子性协定”</strong>（Non-Atomic Treatment of double and long Variables）。</p>
<p>如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了“半个变量”的数值。</p>
<p>从JDK 9起， HotSpot增加了一个实验性的参数-XX：+AlwaysAtomicAccesses（这是JEP 188对Java内存模型更新的<br>一部分内容）来约束虚拟机对所有数据类型进行原子性的访问。</p>
<h2 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h2><p>介绍完Java内存模型的相关操作和规则后，我们再整体回顾一下这个模型的特征。Java内存模型是 围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的，我们逐个来看一下<strong>哪些操作实现了这三个特性</strong>。</p>
<h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个， 我们大致可以认为，<strong>基本数据类型</strong>的访问、读写都是具备原子性的。</p>
<p>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和 unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更 高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p>
<h3 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h3><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</p>
<p>Java内存模型中的volatile关键词是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是 普通变量还是volatile变量都是如此。普通变量与volatile变量的区别是，volatile的特殊规则保证了新值 能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
<p>除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。</p>
<ul>
<li>同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。</li>
<li>而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完 成，并且构造器没有把“this”的引用传递出去，那么在其他线程中就能看见final字段的值。</li>
</ul>
<h3 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h3><p>Java程序中天然的有序性可以总结为一句话：<strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的</strong>。</p>
<p>前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
<p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性：</p>
<ul>
<li>volatile关键字本身就包含了禁止指令重排序的语义。</li>
<li>而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</li>
</ul>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点，这是因为Java语言中有一个“先行发生”（Happens-Before）的原则。</p>
<p>这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。</p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。 </p>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已 经存在，可以在编码中直接使用。</p>
<ul>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这 里必须强调的是“同一个锁”，而“后面”是指时间上的先后。</li>
<li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</li>
<li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程 的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出 操作A先行发生于操作C的结论。</li>
</ul>
<h1 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h1><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>我们知道，线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度。目前线程是Java里面进行处理器资源调度的最基本单位，不过如果日后Loom项目能成功为Java引入纤程（Fiber）的话，可能就会改变这一点。</p>
<p>主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作 的统一处理，每个已经调用过start()方法且还未结束的java.lang.Thread类的实例就代表着一个线程。我 们注意到Thread类与大部分的Java类库API有着显著差别，它的所有关键方法都被声明为Native。在Java类库API中，一个Native方法往往就意味着这个方法没有使用或无法使用平台无关的手段来实现。</p>
<p>实现线程主要有三种方式：</p>
<ul>
<li>使用内核线程实现（1：1实现）。</li>
<li>使用用户线程实现（1：N实现）。</li>
<li>使用用户线程加轻量级进程混合实现（N：M实现）。</li>
</ul>
<h3 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h3><p>使用内核线程实现的方式也被称为1：1实现。内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核（Multi-Threads Kernel）。</p>
<p>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型，如图所示。</p>
<p><img src="/images/深入理解JVM/轻量级进程与内核线程之间1：1的关系.jpg" alt="轻量级进程与内核线程之间1：1的关系"></p>
<p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程 在系统调用中被阻塞了，也不会影响整个进程继续工作。轻量级进程也具有它的局限性：</p>
<ul>
<li>由于 是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调<br>用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。</li>
<li>每个 轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈<br>空间），因此一个系统支持轻量级进程的数量是有限的。</li>
</ul>
<h3 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h3><p>使用用户线程实现的方式被称为1：N实现。广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程（User Thread，UT）的一种，因此从这个定义上看，轻量级进程也属于用户线程，但轻 量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，因此效率会受到限制，并不具备通常意义上的用户线程的优点。</p>
<p>而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。其模型如图：</p>
<p><img src="/images/深入理解JVM/进程与用户线程之间1：N的关系.jpg" alt="进程与用户线程之间1：N的关系"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>因此其消耗也是非常低的，也能够支持 规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>劣势也在于没有系统内核的支援，所有的线程操作都 需要由用户程序自己去处理。</p>
<h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为N：M实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。 <strong>用户线程还是完全建立在用户空间中</strong>，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁， 这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。其模型如图：</p>
<p><img src="/images/深入理解JVM/用户线程与轻量级进程之间M：N的关系.jpg" alt="用户线程与轻量级进程之间M：N的关系"></p>
<h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>Java线程如何实现并不受Java虚拟机规范的约束，这是一个与具体虚拟机相关的话题。Java线程在 早期的Classic虚拟机上（JDK 1.2以前），是基于一种被称为“绿色线程”（Green Threads）的用户线程 实现的，但从JDK 1.3起，“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1：1的线程模型。</p>
<p>以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间 没有额外的间接结构，所以HotSpot自己是不会去干涉线程调度的（可以设置线程优先级给操作系统提供调度建议），全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理 器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</p>
<p>当然也有例外的情况，如用 于Java ME的CLDC HotSpot Implementation，它同时支持两种线程模 型，默认使用1：N由用户线程实现的线程模型，所有Java线程都映射到一个内核线程上；不过它也可 以使用另一种特殊的混合模型，Java线程仍然全部映射到一个内核线程上，但当Java线程要执行一个阻 塞调用时，CLDC-HI会为该调用单独开一个内核线程，并且调度执行其他Java线程，等到那个阻塞调用完成之后再重新调度之前的Java线程继续执行。</p>
<p>另外一个例子是在Solaris平台的HotSpot虚拟机，由于操作系统的线程特性本来就可以同时支持 1：1（通过Bound Threads或Alternate Libthread实现）及N：M（通过LWP/Thread Based Synchronization 实现）的线程模型，因此Solaris版的HotSpot也对应提供了两个平台专有的虚拟机参数，即-XX： +UseLWPSynchronization（默认值）和-XX：+UseBoundThreads来明确指定虚拟机使用哪种线程模型。</p>
<h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是：</p>
<ul>
<li>协同式 （Cooperative Threads-Scheduling）线程调度。</li>
<li>抢占式（Preemptive Threads-Scheduling）线程调度。</li>
</ul>
<p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行 完了之后，要主动通知系统切换到另外一个线程上去。优点就是实现简单，什么都由自己控制；缺点也很明显，线程执行时间不可控 制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</p>
<p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线 程本身来决定。优点就是线程的执行时间是系统可控的，不会有一个线程导致整个进程甚至整个系统阻塞的问题。</p>
<p>虽然说Java线程调度是系统自动完成的，但是我们仍然可以“建议”操作系统给某些线程多分配一 点执行时间，另外的一些线程则可以少分配一点——这项操作是通过设置线程优先级来完成的。Java 语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）。在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p>
<p>但线程优先级并不是一项稳定的调节手段，很显然因为主流虚拟机上的Java线程是被映射到 系统的原生线程上来实现的，所以线程调度最终还是由操作系统说了算。尽管现代的操作系统基本都 提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应，如Solaris中线程有2147483648（2的31次幂）种优先级，但Windows中就只有七种优先级。如果操作系统的优先级比Java 线程优先级更多，那问题还比较好处理，中间留出一点空位就是了，但对于比Java线程优先级少的系统，就不得不出现几个线程优先级对应到同一个操作系统优先级的情况了。例如，在Windows下，设置线程优先级为1和2、3 和4、6和7、8和9的效果是完全相同的。</p>
<p><img src="/images/深入理解JVM/Java线程优先级与Windows线程优先级之间的对应关系.jpg" alt="Java线程优先级与Windows线程优先级之间的对应关系"></p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并 且可以通过特定的方法在不同状态之间转换。这6种状态分别是：</p>
<ul>
<li>新建（New）：创建后尚未启动的线程处于这种状态。</li>
<li>运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可 能正在执行，也有可能正在等待着操作系统为它分配执行时间。</li>
<li>无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线 程显式唤醒。以下方法会让线程陷入无限期的等待状态：<ul>
<li>没有设置Timeout参数的Object::wait()方法；</li>
<li>没有设置Timeout参数的Thread::join()方法；</li>
<li>LockSupport::park()方法。</li>
</ul>
</li>
<li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待 被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状<br>态：<ul>
<li>Thread::sleep()方法；</li>
<li>设置了Timeout参数的Object::wait()方法；</li>
<li>设置了Timeout参数的Thread::join()方法；</li>
<li>LockSupport::parkNanos()方法；</li>
<li>LockSupport::parkUntil()方法。</li>
</ul>
</li>
<li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到 一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
<li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li>
</ul>
<p>其转换关系如图：</p>
<p><img src="/images/深入理解JVM/线程状态转换关系.jpg" alt="线程状态转换关系"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>高效并发</tag>
        <tag>Java内存模型与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习1-PCANet.A Simple Deep Learning Baseline for Image Classification</title>
    <url>/2022/09/23/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A01-PCANet-A-Simple-Deep-Learning-Baseline-for-Image-Classification/</url>
    <content><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="../images/PCANet/PCANet结构.jpg" alt="PCANet结构"></p>
<ol>
<li><p>在每张图片中选取patch，对patch去除均值。</p>
</li>
<li><p>对这个图片中的patch，进行PCA滤波。</p>
</li>
<li><p>同样再进行一轮PCA滤波。</p>
</li>
<li><p>输出层：对第二层得到图像进行二值化哈希编码，编码位数与第二层的滤波器个数相同。</p>
<p>公式为：</p>
<p>　<img src="https://oscimg.oschina.net/oscnet/a09edd1c97914ae779cb9dd1cbe20fe1eac.png" alt="img"></p>
<p>　　把原来的图像映射成，0-255，此处<img src="https://oscimg.oschina.net/oscnet/2496685a5ad48f84771ebc512018bcb55ee.png" alt="img">一般设置成 8, 函数 H 是一个阶跃函数。<img src="https://oscimg.oschina.net/oscnet/3409b16f0a537cc85d3688065a004602317.png" alt="img">, 表示第二层的滤波器个数。</p>
<p>　　对于第一层的每个输出矩阵，将其分为 B 块，计算统计每个块的直方图信息，然后在将各个块的直方图特征进行级联，最终得到块扩展直方图特征：</p>
<p>　　<img src="https://oscimg.oschina.net/oscnet/385bacdb5a846911e45bdf1f53bcc8d999c.png" alt="img"></p>
<p>　　在进行直方图分块时同样可以采用重叠分块和非重叠分块模式，需要视情况而定。实验表明非重叠分块适用于人脸识别，重叠分块模式使用于手写数字识别、文本识别、目标识别等等。此外直方图特征还为 PCANet 提取到的特征添加了一些变换上的稳定性（例如尺度不变形）。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>PCANet</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>卷积神经网络</tag>
        <tag>PCANet</tag>
      </tags>
  </entry>
</search>
