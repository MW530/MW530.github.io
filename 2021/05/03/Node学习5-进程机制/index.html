<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>node学习5-进程机制 | My Wonderland</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Node.js进程机制" />
  
  
  
  
  <meta name="description" content="服务端模型得变迁Web服务器的架构已经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。 石器时代：同步最早的服务器，其执行模型是同步的，它的服务模式是一次只为一次请求服务，所有的请求都得按次序等待服务。这意味着除了当前的请求被处理外，其余请求都处于等待被处理的状态。其处理性能相当低下，假设每次响应服务耗时为N秒，则这类服务的QPS为1&#x2F;N。 这种架构如今已基本被淘汰，只在一些无并">
<meta property="og:type" content="article">
<meta property="og:title" content="Node学习5-进程机制">
<meta property="og:url" content="http://yoursite.com/2021/05/03/Node%E5%AD%A6%E4%B9%A05-%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="My Wonderland">
<meta property="og:description" content="服务端模型得变迁Web服务器的架构已经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。 石器时代：同步最早的服务器，其执行模型是同步的，它的服务模式是一次只为一次请求服务，所有的请求都得按次序等待服务。这意味着除了当前的请求被处理外，其余请求都处于等待被处理的状态。其处理性能相当低下，假设每次响应服务耗时为N秒，则这类服务的QPS为1&#x2F;N。 这种架构如今已基本被淘汰，只在一些无并">
<meta property="og:image" content="d:/myblog/myblog/source/images/Node-JS的进程/IPC.png">
<meta property="og:image" content="d:/myblog/myblog/source/images/Node-JS的进程/分布式.png">
<meta property="og:image" content="d:/myblog/myblog/source/images/Node-JS的进程/句柄发送还原.png">
<meta property="article:published_time" content="2021-05-03T03:06:49.000Z">
<meta property="article:modified_time" content="2021-05-23T05:56:09.775Z">
<meta property="article:author" content="Michael Wang">
<meta property="article:tag" content="Node.js">
<meta property="article:tag" content="进程机制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/myblog/myblog/source/images/Node-JS的进程/IPC.png">
  
    <link rel="alternate" href="/atom.xml" title="My Wonderland" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>

  
<script src="/js/bootstrap.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    
<link rel="stylesheet" href="/css/dialog.css">

  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

<meta name="generator" content="Hexo 4.2.1"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Home</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">Categories</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Node学习5-进程机制" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Node学习5-进程机制
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2021/05/03/Node%E5%AD%A6%E4%B9%A05-%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6/" class="article-date">
	  <time datetime="2021-05-03T03:06:49.000Z" itemprop="datePublished">2021-05-03</time>
	</a>

      
    <a class="article-category-link" href="/categories/Node-js/">Node.js</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="服务端模型得变迁"><a href="#服务端模型得变迁" class="headerlink" title="服务端模型得变迁"></a><code>服务端模型得变迁</code></h1><p>Web服务器的架构已经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。</p>
<h2 id="石器时代：同步"><a href="#石器时代：同步" class="headerlink" title="石器时代：同步"></a>石器时代：同步</h2><p>最早的服务器，其执行模型是同步的，它的服务模式是一次只为一次请求服务，所有的请求都得按次序等待服务。这意味着除了当前的请求被处理外，其余请求都处于等待被处理的状态。其处理性能相当低下，假设每次响应服务耗时为N秒，则这类服务的QPS为1/N。</p>
<p>这种架构如今已基本被淘汰，只在一些无并发需要的应用中存在。</p>
<h2 id="青铜时代：复制进程"><a href="#青铜时代：复制进程" class="headerlink" title="青铜时代：复制进程"></a>青铜时代：复制进程</h2><p>为了解决同步架构的并发问题，衍生出了复制多个进程以提高并发量的模式。每个进程为一个连接服务。但这种模式的消耗非常高，因为新建进程的代价是很高的，包括内存上下文的分配。因为再复制进程的同时也会复制进程内部的状态，也就是说同样的状态会在内存中存储多份，造成来个浪费。</p>
<p>假设通过进程复制和预复制的方式搭建的服务器有资源的限制，且进程的上限为M，那么这一类服务的QPS为M/N。</p>
<h2 id="白银时代：多线程"><a href="#白银时代：多线程" class="headerlink" title="白银时代：多线程"></a>白银时代：多线程</h2><p>为了解决创建进程代价过大的问题，多线程的概念被引入，线程相当于一个简化版的进程，其没有自己的系统资源，所以在创建，废除时，其代价都比进程小的多。但是值得注意的是，不同进程的线程切换会造成上下文的切换，当过多的不同进程的线程进行切换时，消耗仍然很大。虽然其有缺点，但线程仍然是当代操作系统的重要组成部分。</p>
<p>如果忽略多线程上下问切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为N*L/N。</p>
<h2 id="黄金时代：事件驱动"><a href="#黄金时代：事件驱动" class="headerlink" title="黄金时代：事件驱动"></a>黄金时代：事件驱动</h2><p>多线程的服务模型服役了很长一段时间，Apache就是采用多线程/多进程模式来实现的，当并发量增长到上万时，内存耗用的问题就会暴露出来，即为著名的C10k问题。</p>
<p>为了解决高并发的问题，基于事件驱动的服务模型出现了，像Node和Nginx均是基于事件驱动的方式实现的：即一个线程为所有请求服务，请求到来时触发事件，这与每个请求由一个线程服务的模式完全不同。采用单线程避免了不必要的内存开销和上下文切换问题。</p>
<p>但是这种基于单线程的模式虽然解决了上面的问题，但是其无法高效的利用多核CPU的问题，则为这个模式的问题之所在。所以当我们解决掉这个问题时，那么性能的提升是相当可观的。</p>
<h2 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h2><p>面对单线程对多核利用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程的各自利用一个CPU，以此实现多核CPU的利用。基于Node提供的<code>child_process</code>模块可以实现多进程的调用。我们创建一个简单的服务端代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">5000</span> + <span class="built_in">Math</span>.round(<span class="number">1</span> + <span class="built_in">Math</span>.random() * <span class="number">1000</span>)</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">    res.end(<span class="string">"Hello World\n"</span>)</span><br><span class="line">&#125;).listen(port, <span class="string">'127.0.0.1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server on 127.0.0.1:'</span>+port)</span><br></pre></td></tr></table></figure>
<p>通过<code>node work.js</code>启动它，它会见监听5000到6000之间的一个随机端口。将下面的代码保存为<code>master.js</code>，并通过<code>node master.js</code>启动它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork</span><br><span class="line"><span class="keyword">let</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span>  i = <span class="number">0</span>; i &lt; cpus.length; i++)&#123;</span><br><span class="line">    fork(<span class="string">'./work.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会根据当前机器上的CPU的数量复制出当前Node进程数。</p>
<p>会得到如下的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server on 127.0.0.1:5123</span><br><span class="line">server on 127.0.0.1:5481</span><br><span class="line">server on 127.0.0.1:5065</span><br><span class="line">server on 127.0.0.1:5516</span><br></pre></td></tr></table></figure>
<p>如下图即为典型的Master-Work模式，又称为主从模式，其广泛用于并行处理业务的模式，具备较好的可伸缩性和稳定性。图中的进程分为两类：主进程和工作进程。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它趋向于稳定。工作进程负责具体的业务处理。</p>
<p>注意通过<code>fork()</code>复制的进程都是一个独立的进程，每个进程都是一个独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10MB的内存。</p>
<h1 id="child-process模块"><a href="#child-process模块" class="headerlink" title="child_process模块"></a><code>child_process</code>模块</h1><h2 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h2><h3 id="异步创建子进程"><a href="#异步创建子进程" class="headerlink" title="异步创建子进程"></a>异步创建子进程</h3><h4 id="child-process-exec-command-options-callback"><a href="#child-process-exec-command-options-callback" class="headerlink" title="child_process.exec(command[, options][, callback])"></a><code>child_process.exec(command[, options][, callback])</code></h4><p>该方法可以直接异步执行<strong>命令</strong>（不是JavaScript代码，而是shell命令），<code>options</code>参数可以控制各种条件，比如工作目录，编码等；第三个参数用于设置失败的回调。</p>
<p>该命令衍生shell，然后在shell中执行<code>command</code>，并缓冲任何产生的输出。穿给<code>command</code>字符串会被shell直接处理，特殊字符串（因shell而异）需要被相应地处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">'"/目录/空 格/文件.sh" 参数1 参数2'</span>);</span><br><span class="line"><span class="comment">// 使用双引号，使路径中的空格不会被解释为多个参数的分隔符。</span></span><br><span class="line"></span><br><span class="line">exec(<span class="string">'echo "\\$HOME 变量为 $HOME"'</span>);</span><br><span class="line"><span class="comment">// $HOME 变量在第一个实例中会被转义，但是第二个则不会。</span></span><br></pre></td></tr></table></figure>
<p>所以对于用户的输入，一定要经过无害化处理才能使用这个函数，因为其可以触发任何命令，很危险!</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> process = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cmd = <span class="string">'console.log(123456)'</span></span><br><span class="line"></span><br><span class="line">process.exec(<span class="string">'echo 132'</span>,&#123;<span class="attr">encoding</span>: <span class="string">'GBK'</span>&#125;, (error, stdout, stderr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`执行的错误: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`stdout: <span class="subst">$&#123;stdout&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`stderr: <span class="subst">$&#123;stderr&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>值得注意的是：标准输出是在回调的<code>stdout</code>参数中，而不会直接打印在当前控制台中。</p>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><p>我们简单看一下其源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">command, options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> opts = normalizeExecArgs(command, options, callback);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports.execFile(opts.file,</span><br><span class="line">                                 opts.options,</span><br><span class="line">                                 opts.callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其首先是调用了<code>normalizeExecArgs()</code>这个函数，我们再看一下内部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeExecArgs</span>(<span class="params">command, options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &#123;</span><br><span class="line">    callback = options;</span><br><span class="line">    options = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a shallow copy so we don't clobber the user's options object.</span></span><br><span class="line">  options = &#123; ...options &#125;;</span><br><span class="line">  options.shell = <span class="keyword">typeof</span> options.shell === <span class="string">'string'</span> ? options.shell : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    file: command,</span><br><span class="line">    options: options,</span><br><span class="line">    callback: callback</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以可能首先是做了一个判断，即忽略<code>options</code>功能的实现。</p>
<p>然后是对<code>options</code>做了浅拷贝防止修改用户的<code>options</code>对象。因为后面需要对<code>options.shell</code>进行处理，即是否使用默认的<code>shell.exe</code>。详见下面：</p>
<blockquote>
<h2 id="shell-的要求"><a href="#shell-的要求" class="headerlink" title="shell 的要求"></a>shell 的要求</h2><p>Shell 需要能理解 <code>-c</code> 开关。 如果 shell 是 <code>&#39;cmd.exe&#39;</code>，则它需要能理解 <code>/d /s /c</code> 开关，且命令行解析需要能兼容。</p>
<h2 id="默认的-Windows-shell"><a href="#默认的-Windows-shell" class="headerlink" title="默认的 Windows shell"></a>默认的 Windows shell</h2><p>尽管微软指定在根环境中 <code>%COMSPEC%</code> 必须包含 <code>&#39;cmd.exe&#39;</code> 的路径，但子进程并不总是遵循相同的要求。 因此，在可以衍生 shell 的 <code>child_process</code> 函数中，如果 <code>process.env.ComSpec</code> 不可以，则使用 <code>&#39;cmd.exe&#39;</code> 作为后备。</p>
</blockquote>
<p>然后直接返回了一个对象，并且将<code>command</code>重命名为<code>file</code>（这里我没有看到哪里将<code>command</code>转换为<code>file</code>，但是<code>exeFile</code>确实只接受File，疑惑）</p>
<p>跳出这个函数，看<code>exe()</code>函数，可以发现其仍然是调用了<code>exeFile()</code>函数，我们下面再来看这个函数的源码。</p>
<h4 id="child-process-execFile-file-args-options-callback"><a href="#child-process-execFile-file-args-options-callback" class="headerlink" title="child_process.execFile(file[, args][, options][, callback])"></a><code>child_process.execFile(file[, args][, options][, callback])</code></h4><p>该函数预<code>child_process.exe()</code>相似，都是执行命令。但仍然有些许不同。</p>
<ul>
<li>该方法第一个参数接受一个命令文件（名字或路径），而不是命令的字符串。</li>
<li><code>child_process.execFile()</code> 函数类似于 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback" target="_blank" rel="noopener"><code>child_process.exec()</code></a>，但默认情况下不会衍生 shell。 指定的可执行文件 <code>file</code> 会被直接衍生作为新的进程，使其比 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback" target="_blank" rel="noopener"><code>child_process.exec()</code></a> 稍微更高效。</li>
<li>由于没有衍生 shell，因此不支持 I/O 重定向和文件通配等行为。</li>
</ul>
<h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execFile</span>(<span class="params">file <span class="regexp">/* , args, options, callback */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = [];</span><br><span class="line">  <span class="keyword">let</span> callback;</span><br><span class="line">  <span class="keyword">let</span> options;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the optional positional parameters.解析参数</span></span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; ArrayIsArray(<span class="built_in">arguments</span>[pos])) &#123;</span><br><span class="line">    args = <span class="built_in">arguments</span>[pos++];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="built_in">arguments</span>[pos] == <span class="literal">null</span>) &#123;</span><br><span class="line">    pos++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[pos] === <span class="string">'object'</span>) &#123;</span><br><span class="line">    options = <span class="built_in">arguments</span>[pos++];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="built_in">arguments</span>[pos] == <span class="literal">null</span>) &#123;</span><br><span class="line">    pos++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[pos] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    callback = <span class="built_in">arguments</span>[pos++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!callback &amp;&amp; pos &lt; <span class="built_in">arguments</span>.length &amp;&amp; <span class="built_in">arguments</span>[pos] != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_ARG_VALUE(<span class="string">'args'</span>, <span class="built_in">arguments</span>[pos]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  options = &#123;</span><br><span class="line">    encoding: <span class="string">'utf8'</span>,</span><br><span class="line">    timeout: <span class="number">0</span>,</span><br><span class="line">    maxBuffer: MAX_BUFFER,</span><br><span class="line">    killSignal: <span class="string">'SIGTERM'</span>,</span><br><span class="line">    cwd: <span class="literal">null</span>,</span><br><span class="line">    env: <span class="literal">null</span>,</span><br><span class="line">    shell: <span class="literal">false</span>,</span><br><span class="line">    ...options</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate the timeout, if present.验证参数</span></span><br><span class="line">  validateTimeout(options.timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate maxBuffer, if present.</span></span><br><span class="line">  validateMaxBuffer(options.maxBuffer);</span><br><span class="line"></span><br><span class="line">  options.killSignal = sanitizeKillSignal(options.killSignal);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关键-产生子进程</span></span><br><span class="line">  <span class="keyword">const</span> child = spawn(file, args, &#123;</span><br><span class="line">    cwd: options.cwd,</span><br><span class="line">    env: options.env,</span><br><span class="line">    gid: options.gid,</span><br><span class="line">    shell: options.shell,</span><br><span class="line">    signal: options.signal,</span><br><span class="line">    uid: options.uid,</span><br><span class="line">    windowsHide: !!options.windowsHide,</span><br><span class="line">    windowsVerbatimArguments: !!options.windowsVerbatimArguments</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> encoding;</span><br><span class="line">  <span class="keyword">const</span> _stdout = [];</span><br><span class="line">  <span class="keyword">const</span> _stderr = [];</span><br><span class="line">  <span class="keyword">if</span> (options.encoding !== <span class="string">'buffer'</span> &amp;&amp; Buffer.isEncoding(options.encoding)) &#123;</span><br><span class="line">    encoding = options.encoding;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    encoding = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> stdoutLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> stderrLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> killed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> exited = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ex = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cmd = file;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">exithandler</span>(<span class="params">code, signal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exited) <span class="keyword">return</span>;</span><br><span class="line">    exited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">      clearTimeout(timeoutId);</span><br><span class="line">      timeoutId = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!callback) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge chunks</span></span><br><span class="line">    <span class="keyword">let</span> stdout;</span><br><span class="line">    <span class="keyword">let</span> stderr;</span><br><span class="line">    <span class="keyword">if</span> (encoding ||</span><br><span class="line">      (</span><br><span class="line">        child.stdout &amp;&amp;</span><br><span class="line">        child.stdout.readableEncoding</span><br><span class="line">      )) &#123;</span><br><span class="line">      stdout = ArrayPrototypeJoin(_stdout, <span class="string">''</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stdout = Buffer.concat(_stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (encoding ||</span><br><span class="line">      (</span><br><span class="line">        child.stderr &amp;&amp;</span><br><span class="line">        child.stderr.readableEncoding</span><br><span class="line">      )) &#123;</span><br><span class="line">      stderr = ArrayPrototypeJoin(_stderr, <span class="string">''</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stderr = Buffer.concat(_stderr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ex &amp;&amp; code === <span class="number">0</span> &amp;&amp; signal === <span class="literal">null</span>) &#123;</span><br><span class="line">      callback(<span class="literal">null</span>, stdout, stderr);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length !== <span class="number">0</span>)</span><br><span class="line">      cmd += <span class="string">` <span class="subst">$&#123;ArrayPrototypeJoin(args, <span class="string">' '</span>)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ex) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-restricted-syntax</span></span><br><span class="line">      ex = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Command failed: '</span> + cmd + <span class="string">'\n'</span> + stderr);</span><br><span class="line">      ex.killed = child.killed || killed;</span><br><span class="line">      ex.code = code &lt; <span class="number">0</span> ? getSystemErrorName(code) : code;</span><br><span class="line">      ex.signal = signal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ex.cmd = cmd;</span><br><span class="line">    callback(ex, stdout, stderr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">errorhandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    ex = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child.stdout)</span><br><span class="line">      child.stdout.destroy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child.stderr)</span><br><span class="line">      child.stderr.destroy();</span><br><span class="line"></span><br><span class="line">    exithandler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child.stdout)</span><br><span class="line">      child.stdout.destroy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child.stderr)</span><br><span class="line">      child.stderr.destroy();</span><br><span class="line"></span><br><span class="line">    killed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      child.kill(options.killSignal);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      ex = e;</span><br><span class="line">      exithandler();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    timeoutId = setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">delayedKill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      kill();</span><br><span class="line">      timeoutId = <span class="literal">null</span>;</span><br><span class="line">    &#125;, options.timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child.stdout) &#123;</span><br><span class="line">    <span class="keyword">if</span> (encoding)</span><br><span class="line">      child.stdout.setEncoding(encoding);</span><br><span class="line"></span><br><span class="line">    child.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onChildStdout</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> encoding = child.stdout.readableEncoding;</span><br><span class="line">      <span class="keyword">const</span> length = encoding ?</span><br><span class="line">        Buffer.byteLength(chunk, encoding) :</span><br><span class="line">        chunk.length;</span><br><span class="line">      <span class="keyword">const</span> slice = encoding ? StringPrototypeSlice :</span><br><span class="line">        (buf, ...args) =&gt; buf.slice(...args);</span><br><span class="line">      stdoutLen += length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stdoutLen &gt; options.maxBuffer) &#123;</span><br><span class="line">        <span class="keyword">const</span> truncatedLen = options.maxBuffer - (stdoutLen - length);</span><br><span class="line">        ArrayPrototypePush(_stdout, slice(chunk, <span class="number">0</span>, truncatedLen));</span><br><span class="line"></span><br><span class="line">        ex = <span class="keyword">new</span> ERR_CHILD_PROCESS_STDIO_MAXBUFFER(<span class="string">'stdout'</span>);</span><br><span class="line">        kill();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ArrayPrototypePush(_stdout, chunk);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child.stderr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (encoding)</span><br><span class="line">      child.stderr.setEncoding(encoding);</span><br><span class="line"></span><br><span class="line">    child.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onChildStderr</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> encoding = child.stderr.readableEncoding;</span><br><span class="line">      <span class="keyword">const</span> length = encoding ?</span><br><span class="line">        Buffer.byteLength(chunk, encoding) :</span><br><span class="line">        chunk.length;</span><br><span class="line">      stderrLen += length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stderrLen &gt; options.maxBuffer) &#123;</span><br><span class="line">        <span class="keyword">const</span> truncatedLen = options.maxBuffer - (stderrLen - length);</span><br><span class="line">        ArrayPrototypePush(_stderr,</span><br><span class="line">                           chunk.slice(<span class="number">0</span>, truncatedLen));</span><br><span class="line"></span><br><span class="line">        ex = <span class="keyword">new</span> ERR_CHILD_PROCESS_STDIO_MAXBUFFER(<span class="string">'stderr'</span>);</span><br><span class="line">        kill();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _stderr.push(chunk);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  child.addListener(<span class="string">'close'</span>, exithandler);</span><br><span class="line">  child.addListener(<span class="string">'error'</span>, errorhandler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数相对还是比较长，有217行。但是结构相当清晰：</p>
<ul>
<li>L 2-4：定义参数变量</li>
<li>L 7-26：解析参数（由于定义了可选参数，所以需要这样解析）</li>
<li>L 28-46：定义<code>options</code>并验证参数合法性</li>
<li>L 48-57（关键）：调用<code>spawn()</code>函数产生子进程</li>
<li>Rest：剩下的代码都是为child添加<code>close</code>和<code>error</code>事件和其准备工作</li>
<li>Last：返回child。</li>
</ul>
<h4 id="在-Windows-上衍生-bat-和-cmd-文件"><a href="#在-Windows-上衍生-bat-和-cmd-文件" class="headerlink" title="在 Windows 上衍生 .bat 和 .cmd 文件"></a>在 Windows 上衍生 <code>.bat</code> 和 <code>.cmd</code> 文件</h4><p><code>child_process.exec()</code> 和 <code>child_process.execFile()</code>之间区别的重要性可能因平台而异。 在 Unix 类型的操作系统（Unix、Linux、macOS）上，<code>child_process.execFile()</code>可以更高效，因为默认情况下不会衍生 shell。 但是在 Windows 上， <code>.bat</code> 和 <code>.cmd</code> 文件在没有终端的情况下不能自行执行，因此无法使用 <code>child_process.execFile()</code>启动。 当在 Windows 上运行时，要调用 <code>.bat</code> 和 <code>.cmd</code> 文件，可以使用设置了 <code>shell</code> 选项的 <code>child_process.spawn()</code>、或 <code>child_process.exec()</code>、或衍生 <code>cmd.exe</code> 并将 <code>.bat</code> 或 <code>.cmd</code> 文件作为参数传入（也就是 <code>shell</code> 选项和 <code>child_process.exec()</code>所做的）。 在任何情况下，如果脚本的文件名包含空格，则需要加上引号。</p>
<h4 id="child-process-spawn-command-args-options"><a href="#child-process-spawn-command-args-options" class="headerlink" title="child_process.spawn(command[, args][, options])"></a><code>child_process.spawn(command[, args][, options])</code></h4><p>可以看到，最后创建进程的工作，都是由这个方法实现的，但是其与<code>exec()</code>有较大的不同，否则也不会设计两个API，一直存在这么久。</p>
<h5 id="spawn-与exec-的不同："><a href="#spawn-与exec-的不同：" class="headerlink" title="spawn()与exec()的不同："></a><code>spawn()</code>与<code>exec()</code>的不同：</h5><ul>
<li><code>exec()</code>的<code>command</code>是包含参数的，而<code>spawn</code>命令的参数是作为函数的第二个参数传入的。</li>
<li><code>exec()</code>是将处理函数作为回调传入内部，而<code>spawn</code>实现了<code>emitter</code>，可以直接在外部监听事件。还可以准确的监听<code>close</code>等事件，<code>exec()</code>则只能统一监听<code>error</code>事件。</li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> ls = spawn(<span class="string">'ls'</span>, [<span class="string">'-lh'</span>, <span class="string">'/usr'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要显式的监听</span></span><br><span class="line">ls.stdout.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.stderr.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.on(<span class="string">'close'</span>, (code) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`子进程退出，退出码 <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">file, args, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//解析参数</span></span><br><span class="line">  options = normalizeSpawnArguments(file, args, options);</span><br><span class="line">  <span class="comment">//验证timeout</span></span><br><span class="line">  validateTimeout(options.timeout);</span><br><span class="line">    <span class="comment">//验证signal</span></span><br><span class="line">  validateAbortSignal(options.signal, <span class="string">'options.signal'</span>);</span><br><span class="line">    <span class="comment">//验证并转换killSignal信号，这里嵌套太深而且不重要，就不再深究</span></span><br><span class="line">  <span class="keyword">const</span> killSignal = sanitizeKillSignal(options.killSignal);</span><br><span class="line">    <span class="comment">//新建子进程，重要</span></span><br><span class="line">  <span class="keyword">const</span> child = <span class="keyword">new</span> ChildProcess();</span><br><span class="line">    <span class="comment">//这里实际是记录log，而不是debug</span></span><br><span class="line">  debug(<span class="string">'spawn'</span>, options);</span><br><span class="line">    <span class="comment">//初始化子进程参数</span></span><br><span class="line">  child.spawn(options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子进程超时的操作</span></span><br><span class="line">  <span class="keyword">if</span> (options.timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          child.kill(killSignal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          child.emit(<span class="string">'error'</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        timeoutId = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, options.timeout);</span><br><span class="line"></span><br><span class="line">    child.once(<span class="string">'exit'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">        clearTimeout(timeoutId);</span><br><span class="line">        timeoutId = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否有killSignal参数，即终止进程的信号值，有的话添加abort事件</span></span><br><span class="line">  <span class="keyword">if</span> (options.signal) &#123;</span><br><span class="line">    <span class="keyword">const</span> signal = options.signal;</span><br><span class="line">    <span class="keyword">if</span> (signal.aborted) &#123;</span><br><span class="line">      process.nextTick(onAbortListener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      signal.addEventListener(<span class="string">'abort'</span>, onAbortListener, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      child.once(<span class="string">'exit'</span>,</span><br><span class="line">                 () =&gt; signal.removeEventListener(<span class="string">'abort'</span>, onAbortListener));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onAbortListener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      abortChildProcess(child, killSignal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//返回子进程</span></span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数中最重要的就是<code>const child = new ChildProcess();</code>这一部分，我们再看一下这个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildProcess</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  FunctionPrototypeCall(EventEmitter, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._closesNeeded = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>._closesGot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.connected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.signalCode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.exitCode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.killed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.spawnfile = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重要，新建进程</span></span><br><span class="line">  <span class="keyword">this</span>._handle = <span class="keyword">new</span> Process();</span><br><span class="line">  <span class="keyword">this</span>._handle[owner_symbol] = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._handle.onexit = <span class="function">(<span class="params">exitCode, signalCode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signalCode) &#123;</span><br><span class="line">      <span class="keyword">this</span>.signalCode = signalCode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.exitCode = exitCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.stdin) &#123;</span><br><span class="line">      <span class="keyword">this</span>.stdin.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._handle.close();</span><br><span class="line">    <span class="keyword">this</span>._handle = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exitCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> syscall = <span class="keyword">this</span>.spawnfile ? <span class="string">'spawn '</span> + <span class="keyword">this</span>.spawnfile : <span class="string">'spawn'</span>;</span><br><span class="line">      <span class="keyword">const</span> err = errnoException(exitCode, syscall);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.spawnfile)</span><br><span class="line">        err.path = <span class="keyword">this</span>.spawnfile;</span><br><span class="line"></span><br><span class="line">      err.spawnargs = ArrayPrototypeSlice(<span class="keyword">this</span>.spawnargs, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'exit'</span>, <span class="keyword">this</span>.exitCode, <span class="keyword">this</span>.signalCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If any of the stdio streams have not been touched,</span></span><br><span class="line">    <span class="comment">// then pull all the data through so that it can get the</span></span><br><span class="line">    <span class="comment">// eof and emit a 'close' event.</span></span><br><span class="line">    <span class="comment">// Do it on nextTick so that the user has one last chance</span></span><br><span class="line">    <span class="comment">// to consume the output, if for example they only want to</span></span><br><span class="line">    <span class="comment">// start reading the data once the process exits.</span></span><br><span class="line">    process.nextTick(flushStdio, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    maybeClose(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ObjectSetPrototypeOf(ChildProcess.prototype, EventEmitter.prototype);</span><br><span class="line">ObjectSetPrototypeOf(ChildProcess, EventEmitter);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ChildProcess.prototype.spawn = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ChildProcess.prototype.kill = <span class="function"><span class="keyword">function</span>(<span class="params">sig</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ChildProcess.prototype.ref = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._handle) <span class="keyword">this</span>._handle.ref();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ChildProcess.prototype.unref = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._handle) <span class="keyword">this</span>._handle.unref();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>可以看到这实际上就是一个原生的JS类，其在构造函数中定义了很多内部变量，其中最重要的是<code>this._handle = new Process();</code>来真实的新建一个进程。而这个类则是从C++底层导出的，所以我们不再向下深入。</p>
<p>在定义完类之后，Node立即为其添加了<code>event</code>模块，用于用户对其进行操作。</p>
<p>其中<code>spawn()</code>也很重要，注意每层的对象都有<code>spawn()</code>函数，其用来得到最后的输出结果。</p>
<h4 id="child-process-fork-modulePath-args-options"><a href="#child-process-fork-modulePath-args-options" class="headerlink" title="child_process.fork(modulePath[, args][, options])"></a><code>child_process.fork(modulePath[, args][, options])</code></h4><p><code>child_process.fork()</code> 方法是 <code>child_process.spawn()</code>的特例，专门用于衍生新的 Node.js 进程。 与 <code>child_process.spawn()</code> 一样返回 <code>ChildProcess对象</code>。 返回的 <code>ChildProcess</code>会内置额外的通信通道，允许消息在父进程和子进程之间来回传递。 详见 <code>subprocess.send()</code>。</p>
<p>记住，衍生的 Node.js 子进程独立于父进程，但两者之间建立的 IPC 通信通道除外。 每个进程都有自己的内存，带有自己的 V8 实例。 由于需要额外的资源分配，因此不建议衍生大量的 Node.js 子进程。</p>
<p>默认情况下， <code>child_process.fork()</code> 会使用父进程的 <code>process.execPath</code>来衍生新的 Node.js 实例。</p>
<p>该方法应该比较常用的，因为我们在做web的负载均衡或者多核CPU利用时，一般其他的server也是Node，所以通过该API可以直接生成新的进程。</p>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面的主从的例子</span></span><br><span class="line"><span class="keyword">let</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork</span><br><span class="line"><span class="keyword">let</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span>  i = <span class="number">0</span>; i &lt; cpus.length; i++)&#123;</span><br><span class="line">    fork(<span class="string">'./work.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步创建子进程"><a href="#同步创建子进程" class="headerlink" title="同步创建子进程"></a>同步创建子进程</h3><p>下面的函数会同步创建，执行进程，并且将会阻塞 Node.js 事件循环、暂停任何其他代码的执行，直到衍生的进程退出。阻塞这些调用对于简化通用的脚本任务和简化应用程序配置在启动时的加载或处理都非常有用。</p>
<h4 id="child-process-execFileSync-file-args-options"><a href="#child-process-execFileSync-file-args-options" class="headerlink" title="child_process.execFileSync(file[, args][, options])"></a><code>child_process.execFileSync(file[, args][, options])</code></h4><p><code>child_process.execFileSync()</code> 方法通常与 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback" target="_blank" rel="noopener"><code>child_process.execFile()</code></a> 相同，但该方法在子进程完全关闭之前不会返回。 当遇到超时并且已发送 <code>killSignal</code> 时，该方法也需等到进程完全退出后才返回。</p>
<p>如果子进程拦截并处理了 <code>SIGTERM</code> 信号但未退出，则父进程仍将等待子进程退出。</p>
<p>这个函数也是和<code>execFile()</code>的调用栈差不多。</p>
<p><code>exeFilr()</code>-&gt;<code>spawnSync</code>（lib）-&gt;<code>spawnSync()</code>(internal)-&gt;<code>spawn_sync.spawn(options)</code>(C++内建模块)</p>
<h4 id="child-process-execSync-command-options"><a href="#child-process-execSync-command-options" class="headerlink" title="child_process.execSync(command[, options])"></a><code>child_process.execSync(command[, options])</code></h4><p><code>child_process.execSync()</code> 方法通常与 <code>child_process.exec()</code> 相同，但该方法在子进程完全关闭之前不会返回。 当遇到超时并且已发送 <code>killSignal</code> 时，该方法也需等到进程完全退出后才返回。 如果子进程拦截并处理了 <code>SIGTERM</code> 信号但未退出，则父进程会等待直到子进程退出。</p>
<h5 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execSync</span>(<span class="params">command, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> opts = normalizeExecArgs(command, options, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> inheritStderr = !opts.options.stdio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ret = spawnSync(opts.file, opts.options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inheritStderr &amp;&amp; ret.stderr)</span><br><span class="line">    process.stderr.write(ret.stderr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> err = checkExecSyncError(ret, opts.args, command);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret.stdout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个函数就没有调用<code>exeFileSync()</code>，而是直接调用的<code>spawnSync()</code>函数。下面我们再看<code>spawnSync()</code></p>
<h4 id="child-process-spawnSync-command-args-options"><a href="#child-process-spawnSync-command-args-options" class="headerlink" title="child_process.spawnSync(command[, args][, options])"></a><code>child_process.spawnSync(command[, args][, options])</code></h4><p><code>child_process.spawnSync()</code> 方法通常与 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options" target="_blank" rel="noopener"><code>child_process.spawn()</code></a> 相同，但在子进程完全关闭之前该函数不会返回。 当遇到超时并且已发送 <code>killSignal</code> 时，该方法也需等到进程完全退出后才返回。 如果进程拦截并处理了 <code>SIGTERM</code> 信号但未退出，则父进程会等待直到子进程退出。</p>
<h5 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawnSync</span>(<span class="params">file, args, options</span>) </span>&#123;</span><br><span class="line">  options = &#123;</span><br><span class="line">    maxBuffer: MAX_BUFFER,</span><br><span class="line">    ...normalizeSpawnArguments(file, args, options)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  debug(<span class="string">'spawnSync'</span>, options);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate the timeout, if present.</span></span><br><span class="line">  validateTimeout(options.timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate maxBuffer, if present.</span></span><br><span class="line">  validateMaxBuffer(options.maxBuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate and translate the kill signal, if present.</span></span><br><span class="line">  options.killSignal = sanitizeKillSignal(options.killSignal);</span><br><span class="line"></span><br><span class="line">  options.stdio = getValidStdio(options.stdio || <span class="string">'pipe'</span>, <span class="literal">true</span>).stdio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.input) &#123;</span><br><span class="line">    <span class="keyword">const</span> stdin = options.stdio[<span class="number">0</span>] = &#123; ...options.stdio[<span class="number">0</span>] &#125;;</span><br><span class="line">    stdin.input = options.input;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We may want to pass data in on any given fd, ensure it is a valid buffer</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; options.stdio.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> input = options.stdio[i] &amp;&amp; options.stdio[i].input;</span><br><span class="line">    <span class="keyword">if</span> (input != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> pipe = options.stdio[i] = &#123; ...options.stdio[i] &#125;;</span><br><span class="line">      <span class="keyword">if</span> (isArrayBufferView(input)) &#123;</span><br><span class="line">        pipe.input = input;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">'string'</span>) &#123;</span><br><span class="line">        pipe.input = Buffer.from(input, options.encoding);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_ARG_TYPE(<span class="string">`options.stdio[<span class="subst">$&#123;i&#125;</span>]`</span>,</span><br><span class="line">                                       [<span class="string">'Buffer'</span>,</span><br><span class="line">                                        <span class="string">'TypedArray'</span>,</span><br><span class="line">                                        <span class="string">'DataView'</span>,</span><br><span class="line">                                        <span class="string">'string'</span>],</span><br><span class="line">                                       input);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要，调用internal的spawnSync的函数</span></span><br><span class="line">  <span class="keyword">return</span> child_process.spawnSync(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面都是对参数进行验证和处理。最后只是调用了<code>child_process.spawnSync(options)</code>函数，我们再看一下这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawnSync</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = spawn_sync.spawn(options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result.output &amp;&amp; options.encoding &amp;&amp; options.encoding !== <span class="string">'buffer'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; result.output.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!result.output[i])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      result.output[i] = result.output[i].toString(options.encoding);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result.stdout = result.output &amp;&amp; result.output[<span class="number">1</span>];</span><br><span class="line">  result.stderr = result.output &amp;&amp; result.output[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result.error) &#123;</span><br><span class="line">    result.error = errnoException(result.error, <span class="string">'spawnSync '</span> + options.file);</span><br><span class="line">    result.error.path = options.file;</span><br><span class="line">    result.error.spawnargs = ArrayPrototypeSlice(options.args, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最重要的就是第一条语句，即调用了<code>spawn_sync.spawn(options)</code>函数，这个函数也是从C++导入的内部模块。</p>
<p>所以对于Process模块，JavaScript层面只做了参数的验证，处理，以及返回数据。（因为JavaScript的能力就止于此了），其内部具体的逻辑，都是在C++平台来处理的。而这一部分，是由libuv进行处理的，因为涉及到跨平台处理不同。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>名称</th>
<th>执行类型</th>
<th>同步/异步</th>
<th>事件处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>exec</td>
<td>命令</td>
<td>异步</td>
<td>callback回调/event监听</td>
</tr>
<tr>
<td>execFile</td>
<td>命令（文件）</td>
<td>异步</td>
<td>callback回调/event监听</td>
</tr>
<tr>
<td>Fork</td>
<td>JavaScript模块</td>
<td>异步</td>
<td>event监听</td>
</tr>
<tr>
<td>execSync</td>
<td>命令</td>
<td>同步</td>
<td>/</td>
</tr>
<tr>
<td>execFileSync</td>
<td>命令（文件）</td>
<td>同步</td>
<td>/</td>
</tr>
</tbody>
</table>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>再Master-Work中模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。对于<code>child_process</code>模块，创建好了子进程，然后与父子进程间通信是十分容易的。</p>
<p>由于Node中的进程模块实现了<code>EventEmitter</code>，所以可以直接使用事件监听的方式来进行通信。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>对应的子进程有5个事件，其中包括通信的<code>message</code>事件。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时间</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td>close</td>
<td>进程关闭</td>
<td>1.  <code>code</code> 子进程自行退出时的退出码。<br />2. <code>signal</code>子进程被终止的信号。</td>
</tr>
<tr>
<td>disconnect</td>
<td>调用父进程中的 <code>subprocess.disconnect()</code>或子进程中的 <code>process.disconnect()</code> 后会触发 <code>&#39;disconnect&#39;</code> 事件。</td>
<td>/</td>
</tr>
<tr>
<td>error</td>
<td>1. 无法衍生进程；<br /> 2. 无法杀死进程；<br /> 3. 向子进程发送消息失败。</td>
<td><code>err</code> 错误</td>
</tr>
<tr>
<td>exit</td>
<td>当子进程结束后时会触发 <code>&#39;exit&#39;</code> 事件。</td>
<td>1.   <code>code</code>子进程自行退出时的退出码。<br /> 2. <code>signal</code> 子进程被终止的信号。</td>
</tr>
<tr>
<td>message</td>
<td>当子进程使用 <code>process.send()</code>发送消息时会触发 <code>&#39;message&#39;</code> 事件。</td>
<td>1.  <code>message</code>  一个已解析的 JSON 对象或原始值。<br /> 2. <code>sendHandle</code>一个 <code>net.Socket</code>或 <a href="http://nodejs.cn/api/net.html#net_class_net_server" target="_blank" rel="noopener"><code>net.Server</code></a> 对象，或 <code>undefined</code>。</td>
</tr>
</tbody>
</table>
<p>通过<code>Process.end()</code>方法，可以向子进程发送消息，而主进程可以通过<code>message</code>事件监听子进程的消息。</p>
<p>而子进程可以通过内置对象<code>process</code>的<code>send()</code>方法，和同样的事件监听来与父进程通信。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//master.js</span></span><br><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"><span class="keyword">const</span> n = cp.fork(__dirname + <span class="string">'/sub.js'</span>)</span><br><span class="line"></span><br><span class="line">n.on(<span class="string">'message'</span>, (m) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`进程消息：<span class="subst">$&#123;m&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    work.send(<span class="string">'父进程发送消息来了'</span>)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//work.js</span></span><br><span class="line">process.on(<span class="string">'message'</span>, (m) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`进程消息：<span class="subst">$&#123;m&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    process.send(<span class="string">'子进程发送消息来了'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过<code>message</code>和<code>send()</code>传递消息。</p>
<p>IPC的全程时Inter-Process-Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间的通信技术有很多，如管道通信、共享存储、消息传递、socket等。Node中实现IPC通信的是管道（pipe）技术。但这个管道与传统的管道有一些不同，在Node中管道是一个抽象层的称呼，具体实现细节由libuv提供，在Windows下由命名管道（named pipe）实现，*nix下则采用Unix Domain Socket。表现在应用层上的进程通信只有简单的<code>message</code>事件和<code>send()</code>方法，接口十分简洁。</p>
<p><img src="D:\myblog\myblog\source\images\Node-JS的进程\IPC.png" alt="IPC"></p>
<h3 id="句柄传递"><a href="#句柄传递" class="headerlink" title="句柄传递"></a>句柄传递</h3><p>一般来说，NodeJS用于后端服务器的开发，所以多进程一般用于调动多核CPU来提高并发，那么不同的进程能否监听同一个端口来实现提高并发的目的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//work.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/pain'</span>&#125;)</span><br><span class="line">    res.end(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;).listen(<span class="number">8888</span>, <span class="string">'127.0.0.1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = requrie(<span class="string">'child_process'</span>).fork</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="string">'./work.js'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">得到的错误如下：</span><br><span class="line"></span><br><span class="line">​<span class="string">``</span><span class="string">`bash</span></span><br><span class="line"><span class="string">events.js:187</span></span><br><span class="line"><span class="string">      throw er; // Unhandled 'error' event</span></span><br><span class="line"><span class="string">      ^</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Error: listen EADDRINUSE: address already in use 127.0.0.1:8888</span></span><br></pre></td></tr></table></figure>
<p>很明显，不同的进程启动同一个端口的server，肯定会引起端口占用的问题。</p>
<p>最开始为了解决这个问题，我们的想法是代理。即主进程对外接受所有的网络请求，再将这些请求分别代理到不同端口的进程上。</p>
<p>通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。但是由于进程每接受到一个连接，将会用掉一个我呢见描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程地过程就会用掉两个文件描述符。操作系统地文件描述符是有限的，代理方案浪费掉一倍地文件描述符地做法影响了系统地扩展能力。</p>
<p>为了解决上述问题，Node在V0.5.9加入了进程间发送句柄地功能。<code>sned()</code>方法除了能通过IPC发送数据外，还能够发送句柄，第二个可选参数即为句柄。</p>
<p>句柄即一种用来标识资源地引用，它地内部包含了指向对象地文件描述符。比如句柄可以来吧标识一个socket对象，一个UDP套接字，一个管道等。因此，我们可以通过发送句柄来达到更高地多核利用效率。下面是一个例子（传递一个HTTP句柄）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//master.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = os.cpus().length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> worker = fork(<span class="string">'./work.js'</span>);</span><br><span class="line">  workers.push(worker);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'创建新进程：'</span>+worker.pid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line">server.listen(<span class="number">9527</span>, () =&gt; &#123;</span><br><span class="line">  workers.forEach(<span class="function"><span class="params">worker</span> =&gt;</span> &#123;</span><br><span class="line">    worker.send(<span class="string">'SERVER'</span>, server);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//关闭主服务器</span></span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//work.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建每个协助进程的 http 服务器，不监听任何端口号</span></span><br><span class="line"><span class="keyword">const</span> httpServer = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">`Hello world by <span class="subst">$&#123;process.pid&#125;</span>\n`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'message'</span>, (msg, tcpServer) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果是 master 传递来的 tcp server</span></span><br><span class="line">  <span class="keyword">if</span> (msg === <span class="string">'SERVER'</span>) &#123;</span><br><span class="line">    <span class="comment">// 新连接建立的时候触发</span></span><br><span class="line">    tcpServer.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">      <span class="comment">// 把 tcp server 的连接转给 http server 处理</span></span><br><span class="line">      httpServer.emit(<span class="string">'connection'</span>, socket);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在主进程发送完句柄之后，即关闭监听，也就是说，将所有的请求处理都交给子进程，这样可以做到权责分明。结构图如下：</p>
<p><img src="D:\myblog\myblog\source\images\Node-JS的进程\分布式.png" alt="分布式"></p>
<h4 id="同端口监听的原理"><a href="#同端口监听的原理" class="headerlink" title="同端口监听的原理"></a>同端口监听的原理</h4><h5 id="句柄的发送与还原"><a href="#句柄的发送与还原" class="headerlink" title="句柄的发送与还原"></a>句柄的发送与还原</h5><p>目前子进程对象的<code>send()</code>方法可以发送的句柄类型包括如下几种：</p>
<ul>
<li><code>net.Socket</code>：TCP套接字。</li>
<li><code>net.Server</code>：TCP服务器，任意建立在TCP服务上的应用层服务都可以进行传递。</li>
<li><code>net.Native</code>：C++层面的TCP套接字或IPC管道。</li>
<li><code>dgram.Socket</code>：UDP套接字。</li>
<li><code>dgram.Native</code>：C++层面的UDP套接字。</li>
</ul>
<p><code>send()</code>方法在将消息发送到IPC管道之前，会将消息组装称为两个对象，一个参数是<code>handle</code>，另一个是<code>message</code>。</p>
<p>我们简单看一下其源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴露用于调用的API，主要用来解析参数，后面调用_send()来进行发送</span></span><br><span class="line">target.send = <span class="function"><span class="keyword">function</span>(<span class="params">message, handle, options, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle === <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = handle;</span><br><span class="line">      handle = <span class="literal">undefined</span>;</span><br><span class="line">      options = <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = options;</span><br><span class="line">      options = <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      validateObject(options, <span class="string">'options'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options = &#123; <span class="attr">swallowErrors</span>: <span class="literal">false</span>, ...options &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connected) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._send(message, handle, options, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> ex = <span class="keyword">new</span> ERR_IPC_CHANNEL_CLOSED();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">      process.nextTick(callback, ex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际调用的API</span></span><br><span class="line">  target._send = <span class="function"><span class="keyword">function</span>(<span class="params">message, handle, options, callback</span>) </span>&#123;</span><br><span class="line">    assert(<span class="keyword">this</span>.connected || <span class="keyword">this</span>.channel);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//消息为空</span></span><br><span class="line">    <span class="keyword">if</span> (message === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ERR_MISSING_ARGS(<span class="string">'message'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Non-serializable messages should not reach the remote</span></span><br><span class="line">    <span class="comment">// end point; as any failure in the stringification there</span></span><br><span class="line">    <span class="comment">// will result in error message that is weakly consumable.</span></span><br><span class="line">    <span class="comment">// So perform a final check on message prior to sending.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> message !== <span class="string">'string'</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> message !== <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> message !== <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> message !== <span class="string">'boolean'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_ARG_TYPE(</span><br><span class="line">        <span class="string">'message'</span>, [<span class="string">'string'</span>, <span class="string">'object'</span>, <span class="string">'number'</span>, <span class="string">'boolean'</span>], message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Support legacy function signature</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">      options = &#123; <span class="attr">swallowErrors</span>: options &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Package messages with a handle object</span></span><br><span class="line">      <span class="comment">//注意：这里处理含有handle参数的情况</span></span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">      <span class="comment">// This message will be handled by an internalMessage event handler</span></span><br><span class="line">       <span class="comment">//新的message将会含有一个type属性用来标识handle的类型</span></span><br><span class="line">      message = &#123;</span><br><span class="line">        cmd: <span class="string">'NODE_HANDLE'</span>,</span><br><span class="line">        type: <span class="literal">null</span>,</span><br><span class="line">        msg: message</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断handle种类</span></span><br><span class="line">      <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> net.Socket) &#123;</span><br><span class="line">        message.type = <span class="string">'net.Socket'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> net.Server) &#123;</span><br><span class="line">        message.type = <span class="string">'net.Server'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> TCP || handle <span class="keyword">instanceof</span> Pipe) &#123;</span><br><span class="line">        message.type = <span class="string">'net.Native'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> dgram.Socket) &#123;</span><br><span class="line">        message.type = <span class="string">'dgram.Socket'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handle <span class="keyword">instanceof</span> UDP) &#123;</span><br><span class="line">        message.type = <span class="string">'dgram.Native'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_HANDLE_TYPE();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Queue-up message and handle if we haven't received ACK yet.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._handleQueue) &#123;</span><br><span class="line">        ArrayPrototypePush(<span class="keyword">this</span>._handleQueue, &#123;</span><br><span class="line">          callback: callback,</span><br><span class="line">          handle: handle,</span><br><span class="line">          options: options,</span><br><span class="line">          message: message.msg,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._handleQueue.length === <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      obj = handleConversion[message.type];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// convert TCP object to native handle object</span></span><br><span class="line">      handle = ReflectApply(handleConversion[message.type].send,</span><br><span class="line">                            target, [message, handle, options]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If handle was sent twice, or it is impossible to get native handle</span></span><br><span class="line">      <span class="comment">// out of it - just send a text without the handle.</span></span><br><span class="line">      <span class="keyword">if</span> (!handle)</span><br><span class="line">        message = message.msg;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Update simultaneous accepts on Windows</span></span><br><span class="line">      <span class="keyword">if</span> (obj.simultaneousAccepts &amp;&amp; process.platform === <span class="string">'win32'</span>) &#123;</span><br><span class="line">        handle.setSimultaneousAccepts(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._handleQueue &amp;&amp;</span><br><span class="line">               !(message &amp;&amp; (message.cmd === <span class="string">'NODE_HANDLE_ACK'</span> ||</span><br><span class="line">                             message.cmd === <span class="string">'NODE_HANDLE_NACK'</span>))) &#123;</span><br><span class="line">      <span class="comment">// Queue request anyway to avoid out-of-order messages.</span></span><br><span class="line">      ArrayPrototypePush(<span class="keyword">this</span>._handleQueue, &#123;</span><br><span class="line">        callback: callback,</span><br><span class="line">        handle: <span class="literal">null</span>,</span><br><span class="line">        options: options,</span><br><span class="line">        message: message,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._handleQueue.length === <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里在接收到参数之后，会构建一个新的<code>message</code>对象，其中含有<code>handle</code>的类型。然后将其推入<code>_handleQueue</code>中，后面由Node进行发送。</p>
<p>实际上发送到IPC管道中的是该句柄的文件描述符，文件描述符实际上是一个整数值。这个<code>message</code>对象在写入到IPC管道时会通过<code>JSON.stringify()</code>进行序列化。所以最终发送到IPC管道中的信息都是字符串。<code>send()</code>能发送消息和句柄不代表它能够发送任意对象。</p>
<p>连接了IPC管道的子进程可以读取到父进程发来的消息，将字符串通过<code>JSON.parse()</code>解析还原为对象后，才出发<code>message</code>事件将消息作为消息体传递给应用层。在这个过程中，消息对象还要被过滤处理，<code>message.cmd</code>的值如果以<code>NODE_</code>为前缀，它将响应一个内部事件<code>interalMessage</code>。如果<code>message.cmd</code>值为<code>NODE_HANDLE</code>，它将取出<code>message.type</code>值和得到的为文件描述符一起还原出一个对应的对象。这个过程如图。</p>
<p><img src="D:\myblog\myblog\source\images\Node-JS的进程\句柄发送还原.png" alt="句柄发送还原"></p>
<h5 id="端口的共同监听"><a href="#端口的共同监听" class="headerlink" title="端口的共同监听"></a>端口的共同监听</h5><p>在了解句柄传递背后的原理之后，我们继续探索为何发送句柄后，多个进程可以监听到同一个端口。其原因就在于：我们启动独立的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。</p>
<p>Node底层对每个端口监听都设置了<code>SO_REUSEADDR</code>选项，这个选项的含义是不同的进程可以就相同的网卡和端口进行监听，这个服务器套接字可以被不同的进程复用。</p>
<p>但是由于独立启动的进程互相之间不知道文件描述符，所以监听相同的端口时就会失败。但对于<code>send()</code>发送的句柄还原出来的服务而言，他们的文件描述符时相同的，所以可以监听到相同的端口不会引发异常。</p>
<p>多个应用监听同一个端口时，文件描述符同一时间智能被某一个进程所用。也就是说一个连接只能由一个进程处理，这些进程服务是抢占式的。</p>
<h2 id="集群稳定之路"><a href="#集群稳定之路" class="headerlink" title="集群稳定之路"></a>集群稳定之路</h2><h3 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h3><p>在进程除了<code>message</code>事件外，Node还定义了以下事件：</p>
<ul>
<li>error：当子进程无法被创建或无法被杀死或无法发送消息时会触发该事件。</li>
<li>exit：子进程退出时触发该事件，如果是正常退出，整个事件的第一个参数为推出码，否则为null。如果是通过<code>kill()</code>方法杀死的，会得到第二个参数，它标识杀死进程时的信号。</li>
<li>close：在子进程的标准输入输出流终止时触发该事件，参数与exit相同。</li>
<li>disconnect：在父进程或子进程中调用<code>disconnect()</code>方法时触发该事件，在调用该方法时将关闭监听IPC通道。</li>
</ul>
<h3 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h3><p>有了父子进程之间的相关事件之后，就可以在这些关系之间创建出需要的机制。至少我们嫩巩固通过子进程的exit事件来获知其退出的消息。同时利用这个事件，当一个子进程退出时，可以重新启动一个进程来继续服务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork</span><br><span class="line"><span class="keyword">let</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer()</span><br><span class="line">server.listen(<span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> works = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> createWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> worker = fork(__dirname + <span class="string">'/worker.js'</span>)</span><br><span class="line">    worker.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'work'</span> + worker.pid + <span class="string">'exited.'</span>)</span><br><span class="line">        <span class="keyword">delete</span> workers[worker.pid]</span><br><span class="line">        createWork()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//句柄转发</span></span><br><span class="line">    worker.send(<span class="string">'server'</span>, server)</span><br><span class="line">    workers[worker.pid] = worker</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Create worker. pid:'</span>+worker.pid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpus.length; i++)&#123;</span><br><span class="line">        createServer()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> pid <span class="keyword">in</span> workers)&#123;</span><br><span class="line">            workers[pid].kill()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Test\Node&gt; node reStart.js</span><br><span class="line">Create worker. pid:11436</span><br><span class="line">Create worker. pid:14868</span><br><span class="line">Create worker. pid:16240</span><br><span class="line">Create worker. pid:11044</span><br><span class="line"></span><br><span class="line">//杀死11436</span><br><span class="line">C:\Users\Administrator&gt;taskkill -F /pid 11436</span><br><span class="line">成功: 已终止 PID 为 11436 的进程。</span><br><span class="line"></span><br><span class="line">//自动新增进程</span><br><span class="line">work11436exited.</span><br><span class="line">Create worker. pid:15608</span><br></pre></td></tr></table></figure>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>多个进程的同时服务一个工作时，必须要保证每个进程都得到适量的工作，这种保证多个单元工作量公平的策略叫做负载均衡。</p>
<p>Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一顿工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。</p>
<p>这种机制一般来说是公平的，但是需要明白的是，一个进程的繁忙分为CPU繁忙和I/O繁忙两个部分构成。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够能够抢到较多的进程，形成负载不均衡的情况。</p>
<p>在此Node在v0.11中提供了一种的新的策略使得负载均衡更加合理，即轮转调度算法。轮转调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) % n 个进程来发送连接。在cluster模块中启用它。</p>
<h1 id="Cluster模块"><a href="#Cluster模块" class="headerlink" title="Cluster模块"></a>Cluster模块</h1><p>前面介绍的<code>child_process</code>模块，如果完全使用该模块来完成一个集群，那么还是有一定的难度，所以Node提供了<code>cluster</code>模块用于更方便的实现集群。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>工作进程由 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options" target="_blank" rel="noopener"><code>child_process.fork()</code></a> 方法创建，因此它们可以使用 IPC 和父进程通信，从而使各进程交替处理连接服务。</p>
<p>cluster 模块支持两种分发连接的方法。</p>
<p>第一种方法（也是除 Windows 外所有平台的默认方法）是循环法，由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程，在分发中使用了一些内置技巧防止工作进程任务过载。</p>
<p>第二种方法是，主进程创建监听 socket 后发送给感兴趣的工作进程，由工作进程负责直接接收连接。</p>
<p>理论上第二种方法应该是效率最佳的。 但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。 可能会出现八个进程中有两个分担了 70% 的负载。</p>
<p>因为 <code>server.listen()</code> 将大部分工作交给主进程完成，因此导致普通 Node.js 进程与 cluster 工作进程差异的情况有三种：</p>
<ol>
<li><code>server.listen({fd: 7})</code> 因为消息会被传给主进程，所以父进程中的文件描述符 7 将会被监听并将句柄传给工作进程，而不是监听文件描述符 7 指向的工作进程。</li>
<li><code>server.listen(handle)</code> 显式地监听句柄，会导致工作进程直接使用该句柄，而不是和主进程通信。</li>
<li><code>server.listen(0)</code> 正常情况下，这种调用会导致 server 在随机端口上监听。</li>
</ol>
<p>但在 cluster 模式中，所有工作进程每次调用 <code>listen(0)</code> 时会收到相同的“随机”端口。 实质上，这种端口只在第一次分配时随机，之后就变得可预料。 如果要使用独立端口的话，应该根据工作进程的 ID 来生成端口号。</p>
<p>Node.js 不支持路由逻辑。 因此在设计应用时，不应该过分依赖内存数据对象，例如 session 和登陆等。</p>
<p>由于各工作进程是独立的进程，它们可以根据需要随时关闭或重新生成，而不影响其他进程的正常运行。 只要有存活的工作进程，服务器就可以继续处理连接。 如果没有存活的工作进程，现有连接会丢失，新的连接也会被拒绝。 Node.js 不会自动管理工作进程的数量，而应该由具体的应用根据实际需要来管理进程池。</p>
<p>虽然 <code>cluster</code> 模块主要用于网络相关的情况，但同样可以用于其他需要工作进程的情况。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将上面的代码改写为cluster的方式：</p>
<p>这里的<code>setupMaster</code>方法：</p>
<ol>
<li><p><code>setupMaster</code> 用于修改默认的 ‘fork’ 行为。 一旦调用，将会按照 <code>cluster.settings</code> 进行设置。</p>
</li>
<li><p>所有的设置只对后来的 <a href="http://nodejs.cn/api/cluster.html#cluster_cluster_fork_env" target="_blank" rel="noopener"><code>.fork()</code></a> 调用有效，对之前的工作进程无影响。</p>
</li>
<li><p>唯一无法通过 <code>.setupMaster()</code> 设置的属性是传给 <a href="http://nodejs.cn/api/cluster.html#cluster_cluster_fork_env" target="_blank" rel="noopener"><code>.fork()</code></a> 的 <code>env</code> 属性。</p>
</li>
</ol>
<p>其接受的参数为<code>cluster.settings</code>对象：</p>
<ol>
<li>execArgv &lt;string[]&gt; 传给 Node.js 可执行文件的字符串参数列表。默认值: process.execArgv。</li>
<li>exec <string> 工作进程的文件路径。默认值: process.argv[1]。</li>
<li>args &lt;string[]&gt; 传给工作进程的字符串参数。默认值: process.argv.slice(2)。</li>
<li>cwd <string> 工作进程的当前工作目录。默认值: undefined（从父进程继承）。</li>
<li>serialization <string> 指定用于在进程之间发送消息的序列化类型。可能的值为 ‘json’ 和 ‘advanced’。有关更多详细信息，请参见child_process 的高级序列化。默认值: false。</li>
<li>silent <boolean> 是否需要发送输出到父进程的 stdio。默认值: false。</li>
<li>stdio <Array> 配置衍生的进程的 stdio。 由于 cluster 模块运行依赖于 IPC，这个配置必须包含 ‘ipc’。如果提供了这个选项，则覆盖 silent。</li>
<li>uid <number> 设置进程的用户标识符。参见 setuid(2)。</li>
<li>gid <number> 设置进程的群组标识符。参见 setgid(2)。<br>inspectPort <number> | <Function> 设置工作进程的检查端口。这可以是一个数字、或不带参数并返回数字的函数。默认情况下，每个工作进程都有自己的端口，从主进程的 process.debugPort 开始递增。<br>windowsHide <boolean> 隐藏衍生的进程的控制台窗口（通常在 Windows 系统上会创建）。默认值: false。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>)</span><br><span class="line"></span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">    exec: <span class="string">'worker.js'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpus.length; i++)&#123;</span><br><span class="line">    cluster.fork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>同样，cluster模块提供了一些事件监听：</p>
<ol>
<li><code>disconnect</code>事件</li>
<li><code>exit</code>事件</li>
<li><code>fork</code>事件</li>
<li><code>listening</code>事件</li>
<li><code>message</code>事件</li>
<li><code>online</code>事件：当衍生一个新的工作进程后，工作进程应当响应一个上线消息。 </li>
<li><code>setup</code>事件：每当 <a href="http://nodejs.cn/api/cluster.html#cluster_cluster_setupmaster_settings" target="_blank" rel="noopener"><code>.setupMaster()</code></a> 被调用时触发。</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本文大部分参考《深入浅出nodejs》以及<a href="https://nodejs.org/" target="_blank" rel="noopener">Node</a>官网</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>


<script src="/js/vdonate.js"></script>

<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'http://39.106.203.62:7777/mm_facetoface_collect_qrcode_1532532148519.png',
  alipayImage: 'http://39.106.203.62:7777/1532532158487.jpg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>Post author:  </strong>Michael Wang</a>
          </li>
          <li class="post-copyright-link">
          <strong>Post link:  </strong>
          <a href="/2021/05/03/Node学习5-进程机制/" target="_blank" title="Node学习5-进程机制">http://yoursite.com/2021/05/03/Node学习5-进程机制/</a>
          </li>
          <li class="post-copyright-license">
            <strong>Copyright Notice:   </strong>
            All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            unless stating additionally.
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          机器学习1-决策树算法
        
      </div>
    </a>
  
  
    <a href="/2021/04/28/VSCODE-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">VSCODE-插件开发1</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#服务端模型得变迁"><span class="nav-number">1.</span> <span class="nav-text">服务端模型得变迁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#石器时代：同步"><span class="nav-number">1.1.</span> <span class="nav-text">石器时代：同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#青铜时代：复制进程"><span class="nav-number">1.2.</span> <span class="nav-text">青铜时代：复制进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#白银时代：多线程"><span class="nav-number">1.3.</span> <span class="nav-text">白银时代：多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#黄金时代：事件驱动"><span class="nav-number">1.4.</span> <span class="nav-text">黄金时代：事件驱动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多进程架构"><span class="nav-number">1.5.</span> <span class="nav-text">多进程架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#child-process模块"><span class="nav-number">2.</span> <span class="nav-text">child_process模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建子进程"><span class="nav-number">2.1.</span> <span class="nav-text">创建子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异步创建子进程"><span class="nav-number">2.1.1.</span> <span class="nav-text">异步创建子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#child-process-exec-command-options-callback"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">child_process.exec(command[, options][, callback])</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#示例"><span class="nav-number">2.1.1.1.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#源码"><span class="nav-number">2.1.1.1.2.</span> <span class="nav-text">源码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell-的要求"><span class="nav-number">2.2.</span> <span class="nav-text">shell 的要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认的-Windows-shell"><span class="nav-number">2.3.</span> <span class="nav-text">默认的 Windows shell</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#child-process-execFile-file-args-options-callback"><span class="nav-number">2.3.0.1.</span> <span class="nav-text">child_process.execFile(file[, args][, options][, callback])</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#源码-1"><span class="nav-number">2.3.0.1.1.</span> <span class="nav-text">源码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在-Windows-上衍生-bat-和-cmd-文件"><span class="nav-number">2.3.0.2.</span> <span class="nav-text">在 Windows 上衍生 .bat 和 .cmd 文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#child-process-spawn-command-args-options"><span class="nav-number">2.3.0.3.</span> <span class="nav-text">child_process.spawn(command[, args][, options])</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#spawn-与exec-的不同："><span class="nav-number">2.3.0.3.1.</span> <span class="nav-text">spawn()与exec()的不同：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#示例-1"><span class="nav-number">2.3.0.3.2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#源码-2"><span class="nav-number">2.3.0.3.3.</span> <span class="nav-text">源码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#child-process-fork-modulePath-args-options"><span class="nav-number">2.3.0.4.</span> <span class="nav-text">child_process.fork(modulePath[, args][, options])</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#示例-2"><span class="nav-number">2.3.0.4.1.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步创建子进程"><span class="nav-number">2.3.1.</span> <span class="nav-text">同步创建子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#child-process-execFileSync-file-args-options"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">child_process.execFileSync(file[, args][, options])</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#child-process-execSync-command-options"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">child_process.execSync(command[, options])</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#源码-3"><span class="nav-number">2.3.1.2.1.</span> <span class="nav-text">源码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#child-process-spawnSync-command-args-options"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">child_process.spawnSync(command[, args][, options])</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#源码-4"><span class="nav-number">2.3.1.3.1.</span> <span class="nav-text">源码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信"><span class="nav-number">2.5.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用法"><span class="nav-number">2.5.1.</span> <span class="nav-text">用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例-3"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">2.5.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#句柄传递"><span class="nav-number">2.5.3.</span> <span class="nav-text">句柄传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同端口监听的原理"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">同端口监听的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#句柄的发送与还原"><span class="nav-number">2.5.3.1.1.</span> <span class="nav-text">句柄的发送与还原</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#端口的共同监听"><span class="nav-number">2.5.3.1.2.</span> <span class="nav-text">端口的共同监听</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群稳定之路"><span class="nav-number">2.6.</span> <span class="nav-text">集群稳定之路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程事件"><span class="nav-number">2.6.1.</span> <span class="nav-text">进程事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动重启"><span class="nav-number">2.6.2.</span> <span class="nav-text">自动重启</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡"><span class="nav-number">2.6.3.</span> <span class="nav-text">负载均衡</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cluster模块"><span class="nav-number">3.</span> <span class="nav-text">Cluster模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#工作原理"><span class="nav-number">3.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用"><span class="nav-number">3.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件"><span class="nav-number">3.3.</span> <span class="nav-text">事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#引用"><span class="nav-number">4.</span> <span class="nav-text">引用</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2021 My Wonderland All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/scripts.js"></script>





  
<script src="/js/dialog.js"></script>










	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            My Wonderland
          </div>
          <div class="panel-body">
            Copyright © 2021 Michael Wang All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>