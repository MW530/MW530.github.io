{"meta":{"title":"My Wonderland","subtitle":"This is it!","description":"Something is going happen if you try to fight for it!","author":"Michael Wang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"目录","date":"2018-07-19T16:19:34.000Z","updated":"2018-07-19T16:23:27.276Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-19T16:19:53.000Z","updated":"2018-07-19T16:22:20.068Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-07-19T16:20:13.000Z","updated":"2018-07-20T16:11:53.116Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"简介Michael Wang 目前在学习前端知识，一只想变成大佬的菜鸡。赏一首诗盖说夫妻之缘，伉俪情深，恩深义重。论谈共被之因，幽怀合卺之欢。 凡为夫妻之因，前世三生结缘，始配今生夫妇。夫妻相对，恰似鸳鸯，双飞并膝，花颜共坐；两德之美，恩爱极重，二体一心。 三载结缘，则夫妇相和；三年有怨，则来仇隙。若结缘不合，想是前世怨家。反目生怨，故来相对。妻则一言数口，夫则反目生嫌。似猫鼠相憎，如狼羊一处。 既以二心不同，难归一意，快会及诸亲，以求一别，物色书之，各还本道。愿妻娘子相离之后，重梳蝉鬓，美扫娥眉，巧逞窈窕之姿，选聘高官之主，弄影庭前，美效琴瑟合韵之态。 解怨释结，更莫相憎；一别两宽，各生欢喜。三年衣粮，便献柔仪。伏愿娘子千秋万岁。 听一首歌"}],"posts":[{"title":"Java多线程编程核心技术-1-多线程技术基础","slug":"Java多线程编程核心技术-1-多线程技术基础","date":"2022-03-29T04:06:39.000Z","updated":"2022-03-29T13:30:03.126Z","comments":true,"path":"2022/03/29/Java多线程编程核心技术-1-多线程技术基础/","link":"","permalink":"http://yoursite.com/2022/03/29/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/","excerpt":"","text":"使用多线程Java的JDK实现多线程编程主要有两种方式：一种是继承Thread类，另一种是实现Runnable接口。 继承Thread类直接继承Thread类，然后重写其run方法就可以得到一个新的线程类。 12345678public class MyThread extends Thread&#123; @override public void run()&#123; super.run(); System.out.println(\"MyThread\"); &#125;&#125; 主方法中启动线程： 1234567public class Main&#123; public static void main(String[] args)&#123; MyThread mythread = new MyThread(); mythread.start(); System.out.println(\"main\"); &#125;&#125; 结果： 12mainMyThread 由于新线程的启动需要更多时间，所以main被先打印出来。 实现Runnable接口由于Java不支持多继承，使用继承就会造成问题，如果本来还需要继承其他的父类，那么为了实现多线程来占用一个继承就得不尝试了，因此使用Runnable接口更加合理。实际上Thread也是实现了Runable接口的类。 1public class Thread implements Runnable 创建新的线程类同样的，实现该接口后重写其中的run方法，即可实现一个线程。 12345678package myrunnable;public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"MyRunnable运行中!\"); &#125;&#125; 运行该线程12345678public class Run &#123; public static void main(String[] args) &#123; Runnable runnable=new MyRunnable(); Thread thread=new Thread(runnable); thread.start(); System.out.println(\"运行结束!\"); &#125;&#125; 实例变量共享造成的非线程安全问题与解决方案每个线程类可以有多个实体对象。 每个实体对象都可以单独调用start方法来运行， 或者通过Thread类来构造多个新的线程对象。 此时前一种情况，每个实体对象的属性是独立的，即每个线程都拥有一份独立的属性。 例如： 独立变量线程类1234567891011121314public class MyThread extends Thread &#123; private int count=5; @Override public void run() &#123; super.run(); count--; //此示例不要用while语句，会造成其他线程得不到运行的机会 //因为第一个执行while语句的线程会将count值减到0 //一直由一个线程进行减法运算 System.out.println(\"由 \"+this.currentThread().getName()+\" 计算，count=\"+count); &#125;&#125; 执行类12345678910public class Run &#123; public static void main(String[] args) &#123; MyThread a=new MyThread(\"A\"); MyThread b=new MyThread(\"B\"); MyThread c=new MyThread(\"C\"); a.start(); b.start(); c.start(); &#125;&#125; 结果：123456789101112131415由A计算，count&#x3D;4由B计算，count&#x3D;4由c计算，count&#x3D;4由B计算，count&#x3D;3由A计算，count&#x3D;3由A计算，count&#x3D;2由A计算，count&#x3D;1由A计算，count&#x3D;O由B计算，count&#x3D;2由c计算，count&#x3D;3由B计算，count&#x3D;1由c计算，count&#x3D;2由B计算，count&#x3D;O由c计算，count&#x3D;1由c计算，count&#x3D;o 由于每个线程独立享有属性变量，在这里即为count属性，所以每个线程都会独立操作对应count，从头5减到0。 共享变量线程类1234567891011121314public class MyThread extends Thread &#123; private int count=5; @Override public void run() &#123; super.run(); count--; //此示例不要用while语句，会造成其他线程得不到运行的机会 //因为第一个执行while语句的线程会将count值减到0 //一直由一个线程进行减法运算 System.out.println(\"由 \"+this.currentThread().getName()+\" 计算，count=\"+count); &#125;&#125; 执行类12345678910111213141516public class Run &#123; public static void main(String[] args) &#123; MyThread mythread=new MyThread(); Thread a=new Thread(mythread,\"A\"); Thread b=new Thread(mythread,\"B\"); Thread c=new Thread(mythread,\"C\"); Thread d=new Thread(mythread,\"D\"); Thread e=new Thread(mythread,\"E\"); a.start(); b.start(); c.start(); d.start(); e.start(); &#125;&#125; 结果：12345由A计算，count&#x3D;3由B计算，count&#x3D;3由c计算，count&#x3D;2由D计算，count&#x3D;1由E计算，count&#x3D;0 此时由于这5个线程是由一个实体创建而来，所以其变量是私有的，所以每个线程都是访问的同一个变量。这样大概率会出现线程安全问题，比如上面的A, B。共享变量的值都为3，说明A, B同时对count进行了处理。 出现这个问题的原因主要是在JVM中，count++会被分成三步： 取得原有的count值， 计算count-1， 对count进行赋值。 其解决方法由几种，后面文章会详细介绍，首先这里可以使用synchronized关键字。 1234567891011121314public class MyThread extends Thread &#123; private int count=5; @Override synchronized public void run() &#123; super.run(); count--; //此示例不要用while语句，会造成其他线程得不到运行的机会 //因为第一个执行while语句的线程会将count值减到0 //一直由一个线程进行减法运算 System.out.println(\"由 \"+this.currentThread().getName()+\" 计算，count=\"+count); &#125;&#125; 简单来说就是：被synchronized关键字标记的方法，不同线程会同步进入，所以不会出现线程安全问题。 这里要理解的应该是共享变量的概念，而不是如何解决同步问题，这里也是多线程的核心问题之一。 start方法与run方法start方法start方法并不保证其会按照启动顺序来执行，会由JVM来为其创建新的线程，因为其会启动新的线程，不是一个立即执行操作，而不同的线程启动时间可能随系统的状态不同而改变，因此后面的线程是有可能比前面的线程更先执行。 run方法run方法一般不直接调用，因为如果直接调用，就会在当前线程直接执行。而并不是创建新线程，然后执行。 相关方法currentThread()方法currentThread()方法可返回代码段正在被哪个线程调用。 例如12345public class Run1 &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 结果1main 在新建的线程中，可以使用this来替代Thread，因为其本身就是Runnable， 如： 1234567891011public class CountOperate extends Thread &#123; @Override public void run() &#123; System.out.println(\"run---begin\"); System.out.println(\"Thread.currentThread().getName()=\" + Thread.currentThread().getName()); System.out.println(\"this.getName()=\" + this.getName()); System.out.println(\"run---end\"); &#125;&#125; isAlive()方法isAlive()方法的功能是判断当前的线程是否存活。 该方法同样是Thread类的静态方法。 例如： 非线程类中 12345public class Run1 &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 线程类中 123456public class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"run=\" + this.isAlive()); &#125;&#125; 这里的活动状态是指处于正在运行或准备开始运行的状态。 sleep()方法sleep(long millis)方法sleep()方法的作用是在指定的时间（毫秒）内让当前“正在执行的线程”休眠（暂停执行），这个“正在执行的线程”是指this.currentThread()返回的线程。 例如： 线程类 1234567891011121314151617public class MyThread2 extends Thread &#123; @Override public void run() &#123; try &#123; System.out.println(\"run threadName=\" + this.currentThread().getName() + \" begin =\" + System.currentTimeMillis()); Thread.sleep(2000); System.out.println(\"run threadName=\" + this.currentThread().getName() + \" end =\" + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 执行类 12345678public class Run2 &#123; public static void main(String[] args) &#123; MyThread2 mythread = new MyThread2(); System.out.println(\"begin =\" + System.currentTimeMillis()); mythread.start(); System.out.println(\"end =\" + System.currentTimeMillis()); &#125;&#125; 结果： 123456begin &#x3D;1396255271828end&#x3D;1396255271828run threacNarne&#x3D;Thread-0 begin &#x3D;1396255271828run threadName&#x3D;Thread-O end &#x3D;1396255273828 值得注意的是sleep方法并不会释放其持有的锁。 sleep(long millis, int nanos)方法sleep（long millis，int nanos）方法的作用是在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序的精度和准确性的影响。 StackTraceElement[] getStackTrace()方法StackTraceElement[]getStackTrace()方法的作用是返回一个表示该线程堆栈跟踪元素数组。 注意该方法是Thread.currentThread()的方法。 例如： 12345678910111213141516171819202122232425262728293031323334public class Test1 &#123; public void a() &#123; b(); &#125; public void b() &#123; c(); &#125; public void c() &#123; d(); &#125; public void d() &#123; e(); &#125; public void e() &#123; StackTraceElement[] array = Thread.currentThread().getStackTrace(); if (array != null) &#123; for (int i = 0; i &lt; array.length; i++) &#123; StackTraceElement eachElement = array[i]; System.out.println(\"className=\" + eachElement.getClassName() + \" methodName=\" + eachElement.getMethodName() + \" fileName=\" + eachElement.getFileName() + \" lineNumber=\"+ eachElement.getLineNumber()); &#125; &#125; &#125; public static void main(String[] args) &#123; Test1 test1 = new Test1(); test1.a(); &#125;&#125; 结果 1234567className&#x3D;java.lang.Thread methodName&#x3D;getStackTrace fileName&#x3D;Thread.java lineNumber&#x3D;1559className&#x3D;test1.Test1 methodName&#x3D;e fileName&#x3D;Test1.java lineNumber&#x3D;22className&#x3D;test1.Test1 methodName&#x3D;d fileName&#x3D;Test1.java lineNumber&#x3D;18className&#x3D;test1.Test1 methodName&#x3D;c fileName&#x3D;Test1.java lineNumber&#x3D;14className&#x3D;test1.Test1 methodName&#x3D;b fileName&#x3D;Test1.java lineNumber&#x3D;10className&#x3D;test1.Test1 methodName&#x3D;a fileName&#x3D;Test1.java lineNumber&#x3D;6className&#x3D;test1.Test1 methodName&#x3D;main fileName&#x3D;Test1.java lineNumber&#x3D;36 dumpStack()方法static void dumpStack()方法的作用是将当前线程的堆栈跟踪信息输出至标准错误流。 例如： 12345678910111213141516171819202122232425262728293031public class Test1 &#123; public void a() &#123; b(); &#125; public void b() &#123; c(); &#125; public void c() &#123; d(); &#125; public void d() &#123; e(); &#125; public void e() &#123; int age = 0; age = 100; if (age == 100) &#123; Thread.dumpStack(); &#125; &#125; public static void main(String[] args) &#123; Test1 test1 = new Test1(); test1.a(); &#125;&#125; 结果 1234java.lang.Exception: Stack traceat java.lang.Thread.dumpStack(Thread.java :1336)at test6.Test1.e(Test1.java: 25)at test6.Test1.d(Test1.java: 18)at test6.Test1.c(Test1.java: 14)at test6.Test1.b(Test1.java:10)at test6.Test1.a(Test1.java:6)at test6.Test1.main(Test1.java: 31) getId方法getId()方法用于取得线程的唯一标识。 例如 123456public class Test &#123; public static void main(String[] args) &#123; Thread runThread = Thread.currentThread(); System.out.println(runThread.getName() + \" \" + runThread.getId()); &#125;&#125; 结果 1main 1 从运行结果来看，当前执行代码的线程名称为main，线程id值为1。 停止线程停止线程是多线程开发的一个很重要的技术点，停止线程在Java语言中并不像break语句那样干脆，还需要一些技巧性的处理。 在Java中有3种方法可以使正在运行的线程终止运行： 使用退出标志使线程正常退出。 使用stop()方法强行终止线程，但是这个方法不推荐使用，因为stop()和suspend()、resume()一样，都是作废过期的方法，使用它们可能发生不可预料的结果。 使用interrupt()方法中断线程。 interrupt()interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt()方法仅仅是在当前线程中做了一个停止的标记，并不是真正停止线程。 interrupt()并不会停止线程类： 123456789public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(\"i=\" + (i + 1)); &#125; &#125;&#125; 执行类： 12345678910111213package test;import exthread.MyThread;public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; MyThread thread = new MyThread(); thread.start(); Thread.sleep(2000); thread.interrupt(); System.out.println(\"zzzzzzzz\"); &#125;&#125; 结果： 12345i&#x3D;0i&#x3D;1i&#x3D;2i&#x3D;3i&#x3D;4 可以看到线程并没有停止。 实际上我们需要自己判断interrupt状态，然后自己来推出线程。 使用interrupt()，interrupted()，this.isInterrupted()来停止线程 interrupted()：测试currentThread()是否已经中断。执行后具有清除状态标志值为false的功能。 this.isInterrupted()：测试this关键字所在类的对象是否已经中断。不清除状态标志。 示例 线程类 123456789101112public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); int i = 0; while(!this.isInterrupted())&#123; i++; System.out.println(\"i=\" + i); &#125; System.out.println(\"结束！线程中断！\"); &#125;&#125; 执行类 12345678910111213package test;import exthread.MyThread;public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; MyThread thread = new MyThread(); thread.start(); Thread.sleep(1000); thread.interrupt(); System.out.println(\"zzzzzzzz\"); &#125;&#125; 结果： 123456i &#x3D; 82345i &#x3D; 82345i &#x3D; 82345i &#x3D; 82345zzzzzzzz结束！线程中断！ 这里我们每一次都检测interrupt状态，如果中断了就不进行循环了。 异常法上面我们是直接循环判断，出错就跳出循环。而如果使用异常，则可以直接跳出该线程。 例如 线程类 12345678910111213141516171819public class MyThread extends Thread &#123;@Override public void run() &#123; super.run(); try &#123; for (int i = 0; i &lt; 500000; i++) &#123; if (this.interrupted()) &#123; System.out.println(\"已经是停止状态了!我要退出了!\"); throw new InterruptedException(); &#125; System.out.println(\"i=\" + (i + 1)); &#125; System.out.println(\"我在for下面\"); &#125; catch (InterruptedException e) &#123; System.out.println(\"进MyThread.java类run方法中的catch了！\"); e.printStackTrace(); &#125; &#125;&#125; 运行类 123456789101112131415161718import exthread.MyThread;public class Run &#123; public static void main(String[] args) &#123; try &#123; MyThread thread = new MyThread(); thread.start(); Thread.sleep(2000); thread.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println(\"main catch\"); e.printStackTrace(); &#125; System.out.println(\"end!\"); &#125;&#125; 结果： 12345678910i&#x3D;183973i&#x3D;183974i&#x3D;183975i&#x3D;183976i&#x3D;183977i&#x3D;183978己经是停止状态了!我要退出了!end !进MyThread.java类run方法中的catch了!java. lang . InterruptedExceptionat exthread. MyThread.run ( MyThread.java:11) 这里就是检测到外部传入中断信息就直接抛出错误。不再运行下面的程序。 在sleep中使用interrupt()首先明确：在sleep中使用interrupt()会直接报出InterruptedException错误。 例如： 线程类： 1234567891011121314151617public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for(int i=0;i&lt;100000;i++)&#123; System.out.println(\"i=\"+(i+1)); &#125; System.out.println(\"run begin\"); Thread.sleep(200000); System.out.println(\"run end\"); &#125; catch (InterruptedException e) &#123; System.out.println(\"先停止，再遇到了sleep!进入catch!\"); e.printStackTrace(); &#125; &#125;&#125; 运行类： 12345678public class Run &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); thread.interrupt(); System.out.println(\"end!\"); &#125;&#125; 结果： 1234end!i&#x3D;1i&#x3D;2i&#x3D;3 stop强制停止线程使用stop()方法可以强行停止线程，即暴力停止线程。并且会释放该线程所持有的所有锁。并且会抛出java.lang.ThreadDeath。 例如： 线程类： 123456789101112131415161718public class MyThread extends Thread &#123; private int i = 0; @Override public void run() &#123; try &#123; while (true) &#123; i++; System.out.println(\"i=\" + i); Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行类： 1234567891011121314151617import testpackage.MyThread;public class Run &#123; public static void main(String[] args) &#123; try &#123; MyThread thread = new MyThread(); thread.start(); Thread.sleep(4000); thread.stop(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 结果： 1234i&#x3D;1i&#x3D;2i&#x3D;3i&#x3D;4 由运行结果可以看出，线程被暴力停止了 注意：stop()方法已经是作废的方法，因为如果暴力性地强制让线程停止，则一些清理性的工作可能得不到完成，或者数据添加不完整。 例如，由于直接杀死线程并且释放锁，但是如果被锁的变量正被操作了一半，此时释放锁，其他线程得到的就是一个不完整的脏数据。所以该方法会被废除。 暂停线程暂停线程意味着此线程还可以恢复运行，在Java多线程中，可以使用suspend()方法暂停线程，使用resume()方法来恢复线程的执行。 不过这两个方法实际上也是被废除了。所以一般也并不这么用。 suspend()方法与resume()方法使用调用suspend()方法会离级停止该线程。但不会释放所持有的锁。 示例 线程类： 123456789101112public class MyThread extends Thread &#123; @Override public void run() &#123; int i = 0; while (true) &#123; i++; System.out.println(i); &#125; &#125;&#125; 执行类： 123456789101112import mythread.MyThread;public class Run &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); Thread.sleep(2000); thread.suspend(); Thread.sleep(5000); thread.resume(); &#125;&#125; 结果：执行后会立即执行，然后在主线程sleep的2s内，thread会一直i++。然后在2s后停止，随后主线程sleep5s，即thread暂停5s，接下来线程继续运行。 缺点独占如果suspend()方法与resume()方法使用不当，极易造成公共同步对象被独占，其他线程无法访问公共同步对象的结果。 例如：线程A持有了Lock1锁，线程B在等待Lock1，但线程A被意外永久suspend了。那么线程B就陷入了死锁。 数据不完整在使用suspend()方法与resume()方法时也容易出现线程暂停，进而导致数据不完整的情况。 这种立即停止，不考虑线程的状态，一般都会面临该问题。比如赋值操作进行到一半，一部分变量被赋值了，另一部分没有被赋值。那取出的数据就会出现不统一的情况。 yield()方法yield()方法的作用是放弃当前的CPU资源，让其他任务去占用CPU执行时间，放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。 yield()做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 注意：该方法应该直接通过Thread静态调用，而不能通过this来调用。 线程优先级在操作系统中，线程可以划分优先级，优先级较高的线程得到CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务，其实就是让高优先级的线程获得更多的CPU时间片。 在jdk中使用3个常量来预置定义优先级的值。分别是： 123public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 优先级的继承特征在Java中，线程的优先级具有继承性，例如，A线程启动B线程，则B线程的优先级与A线程是一样的。 优先级的规律性高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部先执行完。 优先级的随机性优先级高的线程往往优先执行完，但这个结果不是绝对的，因为线程的优先级还具有“随机性”，即优先级较高的线程不一定每一次都先执行完。 守护线程Java中有两种线程： 用户线程，也称非守护线程； 另一种是守护线程。 守护线程是一种特殊的线程，当进程中不存在非守护线程了，则守护线程自动销毁。 典型的守护线程是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。 创建一个守护线程的方法是使用thread1.setDaemon()，调用这个方法的线程就是thread1的守护线程。 例如：在main方法中执行以下代码： 1234567891011121314public class Run &#123; public static void main(String[] args) &#123; try &#123; MyThread thread = new MyThread(); thread.setDaemon(true); thread.start(); Thread.sleep(5000); System.out.println(\"我离开thread对象也不再打印了，也就是停止了！\"); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 则main方法主线程即为thread的守护线程。","categories":[{"name":"Java多线程编程核心技术","slug":"Java多线程编程核心技术","permalink":"http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java多线程编程核心技术","slug":"Java多线程编程核心技术","permalink":"http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"多线程技术基础","slug":"多线程技术基础","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"hibernate validator基本使用","slug":"hibernate-validator基本使用","date":"2022-03-28T09:57:42.000Z","updated":"2022-03-28T13:05:25.974Z","comments":true,"path":"2022/03/28/hibernate-validator基本使用/","link":"","permalink":"http://yoursite.com/2022/03/28/hibernate-validator%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"引入Spring-bootspring-boot-starter-web就包含了hibernate validator。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring MVC12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.17.Final&lt;/version&gt;&lt;/dependency&gt; 验证beanvalidator的基本用法和lombok一样。添加到实体类的属性上。如果不符合属性的要求就会抛出错误。 例如： 12345678910111213141516171819202122@Data@AllArgsConstructorpublic class User &#123; @NotNull private String id; @NotBlank @Size(max = 20) private String name; @NotNull @Pattern(regexp = \"[A-Z][a-z][0-9]\") private String password; @NotNull private Integer age; @Max(10) @Min(1) private Integer level;&#125; 验证如果不通过spring，validator是无法直接劫持实例化的过程。只能通过对应的validator对象的方法来验证对应的对象。 如： 1234567891011121314User user = new User(null, \"\", \"123\", null, 0); ValidatorFactory factory = Validation.buildDefaultValidatorFactory();validator = factory.getValidator(); // 验证所有bean的所有约束 Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations = validator.validate(user); // 验证单个属性 Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations2 = validator.validateProperty(user, \"name\"); // 检查给定类的单个属性是否可以成功验证 Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations3 = validator.validateValue(User.class, \"password\", \"sa!\"); constraintViolations.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage())); constraintViolations2.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage())); constraintViolations3.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage())); 结果 1234不能为Null不能为空需要匹配正则表达式\"[A-Z][a-z][0-9]\"最小为1 验证方法验证方法可以通过将注解加到对应的位置来验证参数或者返回值。 验证参数可以通过将注解加到参数前面，然后通过验证器来验证某个方法是是否合法。 例如： 12345678package org.hibernate.validator.referenceguide.chapter03.parameter; public class RentalStation &#123; public RentalStation(@NotNull String name) &#123; //... &#125; public void rentCar( @NotNull Customer customer, @NotNull @Future Date startDate, @Min(1) int durationInDays) &#123; //... &#125;&#125; 验证构造方法的参数不能为空， rentCar方法的第一个参数不为空， 第二个参数必须为当前时间的位来， 第三个参数最小只能为1。 验证返回值同样的，将注解加到对应的方法上可以验证返回值是否合法。 例如： 123456789101112package org.hibernate.validator.referenceguide.chapter03.returnvalue; public class RentalStation &#123; @ValidRentalStation public RentalStation() &#123; //... &#125; @NotNull @Size(min = 1) public List&lt;@NotNull Customer&gt; getCustomers() &#123; //... return null; &#125;&#125; 这里确保了： 任何新创建的RentalStation对象都必须满足@ValidRentalStation约束 getCustomers()返回的客户列表不能为空，并且必须至少包含1个元素 getCustomers()返回的客户列表不能包含空对象。 验证方法约束的验证是使用ExecutableValidator接口完成的。 示例如下： 12345678910111213141516171819Car object = new Car( \"Morris\" ); Method method = Car.class.getMethod( \"drive\", int.class );// 1. 获取executableValidator对象ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); ExecutableValidator executableValidator = factory.getValidator().forExecutables();// 2. 验证方法参数Car object = new Car( \"Morris\" ); Method method = Car.class.getMethod( \"drive\", int.class );Object[] parameterValues = &#123; 80 &#125;; Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateParameters( object, method, parameterValues);Class&lt;? extends Annotation&gt; constraintType = violations.iterator() .next() .getConstraintDescriptor() .getAnnotation().annotationType();// 3. 验证返回值Constructor&lt;Car&gt; constructor = Car.class.getConstructor( String.class, String.class ); Car createdObject = new Car( \"Morris\", null ); Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator .validateConstructorReturnValue( constructor, createdObject);Class&lt;? extends Annotation&gt; constraintType = violations.iterator() .next() .getConstraintDescriptor() .getAnnotation().annotationType(); 注意：ExecutableValidator接口总共提供了四个方法: validateParameters()：用来验证方法参数。 validateReturnValue()：用来验证方法返回值。 validateConstructorParameters()：用来验证构造器参数。 validateConstructorReturnValue()：用来验证构造器返回值。 spring结合可以看到，上面的验证非常复杂，但是有了spring的aop帮助，我们只需要配置以下，就可以让spring自动为我们进行验证。我们只需要在方法或者参数上添加约束注解即可。 class方式基本配置如果只需要验证实体类的约束，则只需要配置一个validator即可。 12345678910111213141516171819@Configurationpublic class ValidatorConfig &#123; /** * 配置验证器 * * @return validator */ @Bean public Validator validator() &#123; ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class) .configure() // 快速失败模式 .failFast(true) // .addProperty( \"hibernate.validator.fail_fast\", \"true\" ) .buildValidatorFactory(); return validatorFactory.getValidator(); &#125;&#125; 可以通过方法 failFast(true)或 addProperty(&quot;hibernate.validator.fail_fast&quot;, &quot;true&quot;)设置为快速失败模式，快速失败模式在校验过程中，当遇到第一个不满足条件的参数时就立即返回，不再继续后面参数的校验。否则会一次性校验所有参数，并返回所有不符合要求的错误信息 方法验证配置如果需要验证方法参数和返回值，则还需要配置另一个对象。 12345678910/** * 设置方法参数验证器 */@Beanpublic MethodValidationPostProcessor methodValidationPostProcessor() &#123; MethodValidationPostProcessor postProcessor = new MethodValidationPostProcessor(); // 设置validator模式为快速失败返回 postProcessor.setValidator(validator()); return postProcessor;&#125; XML方式同样的，在XML中也只需要配置这两个对象即可完成配置。 基本配置12345678&lt;!-- validator基本配置 --&gt;&lt;bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"&gt; &lt;property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\"/&gt; &lt;!-- 映射资源文件 --&gt; &lt;property name=\"validationMessageSource\" ref=\"messageSource\"/&gt;&lt;/bean&gt;&lt;mvc:annotation-driven validator=\"validator\"/&gt; 方法验证配置1234&lt;!-- 设置方法参数验证器 --&gt;&lt;bean id=\"methodValidationPostProcessor\" class=\"org.springframework.validation.beanvalidation.MethodValidationPostProcessor\"&gt; &lt;property name=\"validator\" ref=\"validator\"/&gt;&lt;/bean&gt; 使用在配置好之后，只要是在spring容器中的对象，都可以让spring自动完成验证。 请求接口验证对象123456789101112131415161718@RestControllerpublic class UserController &#123; @PostMapping(\"/login1\") public void login1(@Valid @RequestBody User user)&#123; //如果有错误会直接抛出。 //... &#125; @PostMapping(\"/login2\") public void login1(@Valid @RequestBody User user, BindingResult result)&#123; // 在控制器内本地处理验证错误 if (result.hasErrors()) &#123; result.getAllErrors().forEach(s -&gt; System.out.println(s.getDefaultMessage())); return R.fail(result.getAllErrors().get(0).getDefaultMessage()); &#125; //... &#125;&#125; 一般都是使用第一种方式，然后通过springMVC全局处理异常。 请求验证简单类型这里必须有两步： 必须要配置methodValidationPostProcessor。 必须在类上加@Validated注解。 例： 123456789@Validated@RestControllerpublic class UserController &#123; @PostMapping(\"/login2\") public void checkEmail(@Email String email)&#123; //... &#125;&#125; 注解分类validator-api-2.0的约束注解有22个，具体我们看下面表格 空与非空检查 注解 支持Java类型 说明 @Null Object 为null @NotNull Object 不为null @NotBlank CharSequence 不为null，且必须有一个非空格字符 @NotEmpty CharSequence、Collection、Map、Array 不为null，且不为空（length/size&gt;0） Boolean值检查 注解 支持Java类型 说明 备注 @AssertTrue boolean、Boolean 为true 为null有效 @AssertFalse boolean、Boolean 为false 为null有效 日期检查 注解 支持Java类型 说明 备注 @Future Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate 验证日期为当前时间之后 为null有效 @FutureOrPresent Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate 验证日期为当前时间或之后 为null有效 @Past Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate 验证日期为当前时间之前 为null有效 @PastOrPresent Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate 验证日期为当前时间或之前 为null有效 数值检查 注解 支持Java类型 说明 备注 @Max BigDecimal、BigInteger，byte、short、int、long以及包装类 小于或等于 为null有效 @Min BigDecimal、BigInteger，byte、short、int、long以及包装类 大于或等于 为null有效 @DecimalMax BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类 小于或等于 为null有效 @DecimalMin BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类 大于或等于 为null有效 @Negative BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类 负数 为null有效，0无效 @NegativeOrZero BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类 负数或零 为null有效 @Positive BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类 正数 为null有效，0无效 @PositiveOrZero BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类 正数或零 为null有效 @Digits(integer = 3, fraction = 2) BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类 整数位数和小数位数上限 为null有效 其他 注解 支持Java类型 说明 备注 @Pattern CharSequence 匹配指定的正则表达式 为null有效 @Email CharSequence 邮箱地址 为null有效，默认正则 &#39;.*&#39; @Size CharSequence、Collection、Map、Array 大小范围（length/size&gt;0） 为null有效 hibernate-validator扩展约束（部分） 注解 支持Java类型 说明 @Length String 字符串长度范围 @Range 数值类型和String 指定范围 @URL URL地址验证 另外还可以自定义约束注解，此处为简单介绍，就不再赘述。","categories":[{"name":"hibernate validator","slug":"hibernate-validator","permalink":"http://yoursite.com/categories/hibernate-validator/"}],"tags":[{"name":"hibernate validator","slug":"hibernate-validator","permalink":"http://yoursite.com/tags/hibernate-validator/"},{"name":"validator","slug":"validator","permalink":"http://yoursite.com/tags/validator/"}]},{"title":"git常见场景与冲突处理","slug":"git常见场景与冲突处理","date":"2022-03-27T07:51:19.000Z","updated":"2022-03-29T03:38:38.378Z","comments":true,"path":"2022/03/27/git常见场景与冲突处理/","link":"","permalink":"http://yoursite.com/2022/03/27/git%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/","excerpt":"","text":"常见场景暂存区确认暂存区1234// 增加所有文件到暂存区$ git add .// 增加指定文件到暂存区$ git add [filename] 撤销暂存区12345// 取消所有最新的暂存区文件$ git reset HEAD .// 取消缓存区最新的指定文件$ git reset HEAD REAMDME.md 注意该命令的参数HEAD是要被恢复的版本, 一般选择HEAD, 即恢复到最新的HEAD。 下面撤销commit也使用该命令。 提交确认提交12// 进行一次提交并附加消息'message'$ git commit -m 'message' 撤销提交git revetgit revert进行一个新提交（commit）来恢复其他提交所做的更改。 123$ git revert HEAD 撤销前一次 commit$ git revert HEAD^ 撤销前前一次 commit$ git revert commit （比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。 git reset [version]该命令会将头部指到指定的版本位置。 例如: 123$ git reset HEAD^ # 回退所有内容到上一个版本 $ git reset HEAD^ hello.php # 回退 hello.php 文件的版本到上一个版本 $ git reset 052e # 回退到指定版本 –hard会强制删除之前所有的信息提交. 慎用. 例如 123$ git reset –hard HEAD~3 # 回退上上上一个版本 $ git reset –hard bae128 # 回退到某个版本回退点之前的所有信息。 $ git reset --hard origin/master # 将本地的状态回退到和远程的一样 但是仍然可以恢复. git log -g 全局找到我们 commit 1 IDgit branch recover_bracch commit 1, 创建一个新的分支，git merge recover_bracch 然后合并回来， 补充：git restore命令 修改错误的提交这种情况可能是提交的文件错误或者message写错了. 此时可以使用git commit --amend来修改. 1$ git commit --amend 接下来会弹出文本编辑器来修改对应信息, 不同系统不同,可以设置. 其信息大致如下: 123456789101112131415new repaired message# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.## Date: Mon Mar 28 21:37:11 2022 +0800## On branch main# Changes to be committed:# new file: a.txt# deleted: &quot;\\346\\226\\260\\345\\273\\272\\346\\226\\207\\346\\234\\254\\346\\226\\207\\346\\241\\243 (2).txt&quot;## Untracked files:# a# 第一行就是message, 后面还包含新增或删除的文件 切换到制定提交位置移动HEAD, 一般使用checkout命令. 格式: 123$ git checkout &lt;SHA-1&gt;$ git checkout HEAD[^/~&lt;num&gt;/^&lt;num&gt;]$ git checkout 分支[^/~&lt;num&gt;/^&lt;num&gt;] 示例 123$ git checkout ea321 // 切换到ea321版本$ git checkout HEAD^ // 切换到上一个HEAD位置$ git checkout develop~3 // 切换到develop分支的前三个分支上 提交合并使用git rebase命令可以合并commit. 格式 1$ git rebase -i [startpoint] [endpoint] [startpoint] [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。 比如: 123// 效果一致$ git rebase -i HEAD HEAD~3$ git rebase -i HEAD~3 然后会弹出编辑器. 1234567891011121314pick b4d576b add b.phppick 90bc004 add c.phppick 45edfda add d.php#Rebase 36224db..45edfda onto 36224db (3 command(s))## Commands:#p, pick &#x3D; use commit#r, reword &#x3D; use commit, but edit the commit message#e, edit &#x3D; use commit,but stop for amending#s, squash &#x3D; use commit, but meld into previous commit# f，fixup&#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message#x,exec &#x3D; run command (the rest of the line)using shell# d,drop &#x3D; remove commit## These lines can be re-ordered; they are executed from top to bottom.# If you remove a line here THAT COMMIT WILL BE LOST.# However, if you remove everything,the rebase will be aborted.##Note that empty commits are commented out 然后根据命令修改. 接下来还需要reset一下,才能完rebase. 不同分支合并还可以将不同的分支合并到到一起,比如将develop分支的前3个提交合并到master上. 使用以下命令: 1$ git rebase [startpoint] [endpoint] --onto [branchName] 例如: 12$ git rebase ab123 ab124 --onto master$ git rebase HEAD~3 --onto master 远程仓库同步设置远程仓库可以通过git remote或者通过git branch命令来配置远程仓库。 格式 12$ git remote add [name] [url]$ git branch --set-upstream-to = &lt;upstream&gt; 例如 12345// 新增远程仓库$ git remote add dev https://github.com/vuejs/core.git// 为当前分支增加上游$ git branch --set-upstream-to = https://github.com/vuejs/core.git 确认推送使用git push命令可以使用本地引用更新远程引用，同时发送完成给定引用所必需的对象。 例如 12345678// 如果配置了远程仓库，则直接git push$ git push// 将匹配得分支推送到远程的origin仓库$ git push origin// 将匹配得分支推送到远程的origin仓库master分支$ git push origin master 撤销推送 本地回退版本 先使用git reset回退版本 1$ git reset --soft aa909cff2239536df14820fe086d96305b24e9f1 通过强制push，将旧版本推送到远程仓库 1$ git push origin master --force 注意必须添加--force，因为版本是落后的。 分支新增分支示例 12345// 切换到newBranch分支，如果不存在则创建后再求切换$ git branch newBranch// 切换到newBranch分支，如果不存在则创建后再求切换$ git checkout newBranch branch，switch命令本就是为了减轻checkout命令而生，所以方法基本一致。 删除分支同样的可以使用git branch来删除分支。 12345// 删除本地分支$ git branch -d dev1// 删除一个正打开的分支$ git branch -D dev1 恢复分支格式 1git branch &lt;branch_name&gt; &lt;hash_val&gt; 示例 1git branch dev1 123d Git会自行负责分支的管理，所以当我们删除一个分支时，Git只是删除了指向相关提交的指针，但该提交对象依然会留在版本库中。 因此，如果我们知道删除分支时的散列值，就可以将某个删除的分支恢复过来。在已知提交的散列值的情况下恢复某个分支。 可以通过查看本地文件的log文件或者reflog命令来查找。 合并分支git merge通过git merge命令，可以将分支合并到一起。 例如 12// 假设当前在matser，且落后dev1一个版本$ git merger dev 注意这里还有fast-forward和--no-ff的区别， fast-forward即直接移动当前分支的头指针到对应的合并位置。条件是两个分支不存在冲突。 --no-ff是新建一个提交，然后将merger两个位置的下一次都指向这个新的提交。 如果条件满足时，merge 默认采用的 fast-forward 方式进行合并，除非你显示的加上 --no-ff 选项；而条件不满足时，merge 也是无法使用 fast-forward 合并成功的！ git rebase正如前面介绍的, git rebase实际上也可以做类似的工作。git rebase可以将对应分支的基（即出发位置）合并到当前分支。（或者自己指定两个分支）。 例如： 123// 假设当前在matser，且落后dev两个版本$ git rebase dev// 或者 git rebase master dev 则dev的指针指向了master的分支上，如下图： stash暂存一个不需要立即操作的文件树版本，将版本恢复到上一个commit。 示例 1234567891011121314// 缓存一个版本$ git stash push -m '第一个版本'// 从stash列表中移除单个stash状态，并将其应用到当前工作树状态的顶部。当发生冲突的时候，该命令会失败，但该stash不会从stash列表中移除。此时可以手动解决冲突，然后使用git stash drop来移除。$ git stash pop// 使用一个stash状态，但不会将其从stash列表中移除$ git stash appy// 显示所有的stash记录$ git stash list// 展示在stash中的记录和当前文件内容的不同$ git stash show 冲突处理避免冲突首先应当是避免冲突，每个人应该负责不同的模块，然后只修改对应的文件。过多的冲突应当是分工存在问题。 经常commit减少冲突的另一个方面是经常push，将自己的代码提交到仓库，尽量避免一次提交过多的文件。其次应当保证commit的原子性，即一个commit只做一件事情。 写代码之前同步在写代码之前，先pull一下，保证自己本地的代码已经同步了远程仓库，以减少可能发生的冲突。 手动处理当前git已经很智能，只要存在冲突，就无法提交，或者merge。并且git会提示那些文件存在冲突，然后在文件中通过一定格式来标记，来让我们手动处理冲突。 例如： 123456士大夫第卅方4时5撒发射点发生&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD发士大夫的-这是另外的冲突&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;发士大夫的-deawdaewea冲突&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev &lt;&lt;&lt; 到 ||| 显示的是当前 master 分支上修改后的内容 ||| 到 ---- 向您显示 master 分支与 dev 分支修改前共同的内容是什么 --- 到 &gt;&gt;&gt; 显示的是 dev 分支上修改后的内容，也就是要合并分支的内容 =======用于分割不同的冲突点。 此时我们只需要删除不需要的代码（包括git的提示信息），然后将修改添加到暂存区，并进行提交更改。 最后再次进行提交或合并即可。","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"冲突处理","slug":"冲突处理","permalink":"http://yoursite.com/tags/%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/"}]},{"title":"shiro、spring和JWT的集成","slug":"shiro与spring的集成","date":"2022-03-25T06:44:44.000Z","updated":"2022-03-25T12:15:51.946Z","comments":true,"path":"2022/03/25/shiro与spring的集成/","link":"","permalink":"http://yoursite.com/2022/03/25/shiro%E4%B8%8Espring%E7%9A%84%E9%9B%86%E6%88%90/","excerpt":"","text":"XML配置1. 配置web.xml 配置springShiro.xml文件读取 1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml classpath:springShiro.xml&lt;/param-value&gt;&lt;/context-param&gt; 可以和applicationContext.xml一起写。 配置过滤器 12345678910111213&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注意这里filter的名字必须为：shiroFilter。因为Shiro内部是直接读取名字的。 配置springShiro.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!-- proxy-target-class=\"true\"强制使用CGLib代理，为false则spring会自动选择，否则事务不生效 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\" /&gt; &lt;!-- 配置relam --&gt; &lt;bean id=\"tidyRealm\" class=\"priv.mw.shiro.TidyRealm\"&gt;&lt;/bean&gt; &lt;!-- 配置权限管理器 --&gt; &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt; &lt;property name=\"realms\" ref=\"tidyRealm\" /&gt; &lt;property name=\"cacheManager\" ref=\"cacheManager\" /&gt; &lt;/bean&gt; &lt;bean id=\"cacheManager\" class=\"org.apache.shiro.cache.MemoryConstrainedCacheManager\" /&gt; &lt;bean id=\"tidyFilter\" class=\"priv.mw.filter.JWTFilter\"/&gt; &lt;!-- 配置shiro的过滤器工厂类，id- shiroFilter要和我们在web.xml中配置的过滤器一致 --&gt; &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt; &lt;!-- 调用我们配置的权限管理器 --&gt; &lt;property name=\"securityManager\" ref=\"securityManager\" /&gt; &lt;property name=\"filters\"&gt; &lt;map&gt; &lt;entry key=\"tidyFilter\" value-ref=\"tidyFilter\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"filterChainDefinitions\"&gt; &lt;value&gt; /login/**=anon /register/**=anon /**=tidyFilter &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置shiro bean生命周期管理类 --&gt; &lt;bean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\" /&gt;&lt;/beans&gt; 其中最主要的是filter的配置，因为这里结合的是JWT，并不是基于session，所以并不需要shiro来帮助我们保存用户信息。 然后就是ShiroFilterFactoryBean的配置。 其中会配置securityManager和filters，其中filterChainDefinitions是用来进行url权限地址认证： 其中有几个点： url中的*表示任意一级url匹配。比如：/url/*可以匹配/url/a或者/url/aaa，但不能匹配/url/a/aa因为产生2级目录了。 url中的**表示任意多级的url匹配。比如/url/**既可以匹配/url/a又可以匹配/url/a/aa =后是需要的权限，可以是shiro定义的Filter，也可以是我们自己定义的Filter。其内置的有filter，并且有简写 anon—————org.apache.shiro.web.filter.authc.AnonymousFilter authc————–org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic———org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter logout————-org.apache.shiro.web.filter.authc.LogoutFilter noSessionCreation–org.apache.shiro.web.filter.session.NoSessionCreationFilter perms————–org.apache.shiro.web.filter.authz.PermissionAuthorizationFilter port—————org.apache.shiro.web.filter.authz.PortFilter rest—————org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter roles————–org.apache.shiro.web.filter.authz.RolesAuthorizationFilter ssl—————-org.apache.shiro.web.filter.authz.SslFilter user—————org.apache.shiro.web.filter.authz.UserFilter 这里还没有做授权，所以Realm并没有贴出来，本来应该是从token中拿出id，然后去查询数据库，看权限是否合法。 可以在FormAuthenticationFilter中通过getSubject(servletRequest, servletResponse)获取subject来进行登录。 tidyFilter 下面是tidyFilter的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class JWTFilter extends FormAuthenticationFilter &#123; ObjectMapper mapper = new ObjectMapper(); @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; HttpServletRequest req = (HttpServletRequest) request; String rawToken = req.getHeader(\"Authorization\"); response.setContentType(\"text/json;charset=utf-8\"); if(rawToken == null || \"\".equals(rawToken))&#123; try &#123; response.getWriter().println(mapper.writeValueAsString(Result.data(\"\").msg(\"未认证，请先认证！\").code(401))); return false; &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; &#125;else &#123; String token = rawToken.substring(7); boolean tokenValid = JWTUtils.checkToken(token); if(!tokenValid)&#123; try &#123; response.getWriter().println(mapper.writeValueAsString(Result.data(\"\").msg(\"认证已过期，请重新登录！\").code(401))); return false; &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; &#125;else &#123; return true; &#125; &#125; &#125; @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123; HttpServletRequest req = (HttpServletRequest) request; String token = req.getHeader(\"Authorization\"); response.setContentType(\"text/json;charset=utf-8\"); if(token == null || \"\".equals(token))&#123; return false; &#125;else &#123; boolean tokenValid = JWTUtils.checkToken(token); if(!tokenValid)&#123; return false; &#125;else&#123; return true; &#125; &#125; &#125; @Override protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception &#123; return super.executeLogin(request, response); &#125;&#125; 这个类就是用来验证header中携带的token信息，由于其是无状态的。所以直接通过工具类验证就行了。 这个类继承了FormAuthenticationFilter，其两个方法： isAccessAllowed：判断这个请求是否允许。 onAccessDenied：如果不允许，则引导用户进行认证。（此处是直接返回false，并返回未认证的JSON） 下面是一个简单的JWTUtils，有待加强： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class JWTUtils &#123; private static String key = \"secret\"; private static int aliveDay = 1; public static boolean checkToken(String token)&#123; try&#123; JWT.decode(token).getPayload(); return true; &#125;catch (Exception e)&#123; return false; &#125; &#125; public static String generateToken(HashMap&lt;String, Object&gt; map)&#123; LocalDate localDate = LocalDate.now(); localDate.plusDays(aliveDay); Algorithm algorithm = Algorithm.HMAC256(key); String token = JWT.create() .withPayload(map) .withJWTId(UUID.randomUUID().toString()) .withExpiresAt(Date.from(localDate.atStartOfDay(ZoneOffset.ofHours(8)).toInstant())) .sign(algorithm); return token; &#125; public static String parseTokenToName(String token)&#123; if(checkToken(token))&#123; return JWT.decode(token).getClaim(\"name\").asString(); &#125;else&#123; return null; &#125; &#125; public static Integer parseTokenToId(String token)&#123; if(checkToken(token))&#123; return JWT.decode(token).getClaim(\"id\").asInt(); &#125;else&#123; return null; &#125; &#125;&#125; class配置（待完成）","categories":[{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"JWT","slug":"JWT","permalink":"http://yoursite.com/tags/JWT/"}]},{"title":"springMVC中404错误的拦截","slug":"springMVC中404错误的拦截","date":"2022-03-25T06:44:24.000Z","updated":"2022-03-25T13:46:15.089Z","comments":true,"path":"2022/03/25/springMVC中404错误的拦截/","link":"","permalink":"http://yoursite.com/2022/03/25/springMVC%E4%B8%AD404%E9%94%99%E8%AF%AF%E7%9A%84%E6%8B%A6%E6%88%AA/","excerpt":"","text":"SpringMVC统一错误处理该功能可以直接通过SpringMVC的@RestControllerAdvice注解搭配@ExceptionHandler来处理。 例如： 123456789101112131415161718192021222324@RestControllerAdvicepublic class ExceptionResponseAdvice &#123; @ExceptionHandler(IndexOutOfBoundsException.class) public Exception handleException(Exception exception)&#123; System.out.println(\"数组越界错误！\"); //handle Exception return exception; &#125; @ExceptionHandler(ClassNotFoundException.class) public Exception handleException(Exception exception)&#123; System.out.println(\"类未找到错判！\"); //handle Exception return exception; &#125; @ExceptionHandler(Throwable.class) public Exception handleException(Exception exception)&#123; System.out.println(\"兜底所有错误！\"); //handle Exception return exception; &#125;&#125; springMVC统一返回结构同样使用@RestControllerAdvice可以用来统一数据的返回结构。不过我们需要实现ResponseBodyAdvice接口。才能劫持方法返回的数据，然后进行重写其中的方法。 例如： 123456789101112131415161718192021222324252627282930@RestControllerAdvicepublic class MyResponseBodyAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123; ObjectMapper mapper = new ObjectMapper(); @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) &#123; return true; &#125; @Override public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) &#123; //处理返回值是String的状况 //处理字符串类型数据 if(o instanceof String)&#123; try &#123; return mapper.writeValueAsString(Result.data(o)); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; &#125; // 处理错误 if(o instanceof Exception)&#123; return Result.getResult((Exception) o); &#125; return o instanceof Result ? o : Result.data(o); &#125;&#125; 这里还有一个坑，就是json化和String类型的冲突，即如果Controller返回的是一个String。不加这一句的话会报错： 1class priv.mw.utils.Result cannot be cast to class java.lang.String (priv.mw.utils.Result is in unnamed module of loader org.apache.catalina.loader.ParallelWebappClassLoader @5049b1e5; java.lang.String is in module java.base of loader &#39;bootstrap&#39;) 即没办法将Result类型转化为String。其本质原因在于由于返回的是String，所以会匹配到StringHttpMessageConverter，因为他在所有Converter的前面。但由于我们在切面中将类型改成了Result，所以就会报错。 但实际上我们需要的是MappingJackson2HttpMessageConverter。 所以目前的解决办法有两种： 在转换之前就将String转化为JSON字符串。 将MappingJackson2HttpMessageConverter 放在所有converter的首位。 第一种就是就是上面的写法。 第二种可以通过配置来实现： XML方式： 123456789&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt;&lt;!-- 将MappingJackson2HttpMessageConverter移到前面,处理ResponseBodyAdvice的String异常的问题--&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"defaultCharset\" value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; Class方式 123456789101112131415import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.List;@Configurationpublic class WebConfiguration implements WebMvcConfigurer &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; converters.add(0, new MappingJackson2HttpMessageConverter()); &#125;&#125; 还有一点值得注意的是：实际上错误处理是在ResponseBodyAdvice中，即统一结构返回中来处理。因为实际上我们需要统一返回结构，对于错误，需要判断错误类型来返回对应的数据。所以在这里处理是更加方便的。 漏掉的404虽然上面的做到了统一错误处理，但是404地址错误仍然没办法被劫持到。 目前的做法是，实现一个能够劫持所有请求地址的controller，因为其在springMVC中，泛匹配优先级最低。所以可以这样实现。 1234567@RestControllerpublic class Error &#123; @RequestMapping(\"/**\") public String NotFound() throws ClientException &#123; throw new ClientException(\"请求地址出错！\"); &#125;&#125; 后期看能不能有更优的处理方法。","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/categories/SpringMVC/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"MySQL与Java中的日期API","slug":"MySQL与Java中的日期API","date":"2022-03-25T06:42:31.000Z","updated":"2022-03-25T09:24:32.030Z","comments":true,"path":"2022/03/25/MySQL与Java中的日期API/","link":"","permalink":"http://yoursite.com/2022/03/25/MySQL%E4%B8%8EJava%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9FAPI/","excerpt":"","text":"相关问题：问题：Java系统中采用了localDateTime类型的数据，MySQL数据库中采用了DateTime类型。但是存储之后再取出来发现数据不一致，即秒之后的毫秒部分变成了000000。 原因：MySQL的DateTime没有设置长度，则默认为不包含小数部分。即只存储’YYYY-MM-DD hh:mm:ss’，小数部分是不会被存储的，小数部分会被丢弃。但原始的localDateTime是包含小数部分的，即到微秒部分：10^-6s。所以存储后取出来的数据就损失了小于秒部分，所以小数点后都为0，与原来的不相等。 解决办法： 只对比秒之前的部分，即无视损失的部分。 将MySQL数据库的DateTime的长度设置为6（最长），则不会造成损失。 MySQLMySQL有5种日期类型： DATE TIME DATETIME TIMESTAMP YEAR 但是在介绍具体的类型之前，需要先看MySQL官方的几条关于日期的提醒： MySQL会尝试各种格式来解析传入的值，但最好是按照标准的格式来进行传递，否则可能会有不可预知的行为出现。 其具体格式简单介绍在后文附加。 虽然MySQL会尝试各种格式，但是date部分总是应该按照year-month-day的顺序来传递。 并不推荐用两个字表示的年份，起具有歧义，但MySQL仍然是接受的。其解析行为如下： 如果是70-99则解析为1970-1999 如果是00-69则解析为2000-2069 默认情况下，当MySQL遇到一个超出date或者time类型范围的值时，会默认将其转换为该类型的”0“值。 MySQL允许存储“0”值0000-00-00作为填充值，有时这比null更方便。可以通过开启NO_ZERO_IN_DATE来禁止零值。 下面的表展示了各种类型的零值： Data Type “Zero” Value DATE ‘0000-00-00’ TIME ‘00:00:00’ DATETIME ‘0000-00-00 00:00:00’ TIMESTAMP ‘0000-00-00 00:00:00’ YEAR 0000 DATE, DATETIME, TIMESTAMPDATE类型用来存储不含时间的日期值。MySQL以’YYYY-MM-DD’格式检索和显示DATE值。支持的范围是’1000-01-01’到’9999-12-31’。 DATETIME类型用来存储包含时间的日期值。MySQL以’YYYY-MM-DD hh:mm:ss’的格式检索和显示DATETIME值。支持的范围为’1000-01-01 00:00:00”到“9999-12-31 23:59:59’。 TIMESTAMP也用于存储包含时间的日期值。TIMESTAMP的范围是’1970-01-01 00:00:01’ UTC到’2038-01-19 03:14:07’ UTC。 DATETIME或TIMESTAMP值可以包含尾随的小数秒部分，精度最高可达微秒(6位)。 （注意默认是没有小数部分，需要将长度改为6才有所有的小数部分） 而DATETIME包含小数的范围为：’1000-01-01 00:00:00.000000’to‘9999-12-31 23:59:59.999999’ TIMESTAMP包含小数的范围为： &#39;1970-01-01 00:00:01.000000&#39; to &#39;2038-01-19 03:14:07.999999&#39; MySQL将TIMESTAMP值从当前时区转换为UTC来存储，然后从UTC转换回当前时区以进行检索。(这不会发生在其他类型，如DATETIME。) 默认情况下，每个连接的当前时区都是服务器的时间。 时区可以在每个连接的基础上设置（通过time_zone=xxx）。只要时区设置保持不变，就会得到存储的相同值。如果存储了一个TIMESTAMP值，然后更改时区并检索该值，则检索到的值与存储的值不同。这是因为在两个方向上的转换没有使用相同的时区。 无效值得处理： 非严格模式下，无效的DATE、DATETIME或TIMESTAMP值将被转换为适当类型的“零”值，例如10:45:15会被转化为0000-00-00，因为’45’不是一个合法的月份。 严格模式下，不仅仅只限制月份在1-12之间、天在1-31之间，而是会限制大月小月的区别，如’4-32’就不合法，因为4越没有31号。 （这里的严格模式是指启用STRICT_TRANS_TABLES或STRICT_ALL_TABLES中的一个或两个模式。） TIMEMySQL以’hh:mm:ss’的格式检索和显示时间值。其范围从’-838:59:59’ 到’838:59:59’。 小时的部分可能是如此之大,因为可以使用时间类型不仅代表一个时间点(必须小于24小时),也可以代表运行时间或两个事件之间的时间间隔(可能是远远大于24小时,甚至负)。 TIME也可以包含小数部分来表示更小的时间单位，最小可以到达小数点后6位，即微秒。此时其范围为：&#39;-838:59:59.000000&#39; to &#39;838:59:59.000000&#39;。 对于简写，其规则如下： 如果包含冒号，如’11:12’，则按从小时开始解析，即’11:12’被解析为’11:12:00’。 如果不含冒号，如’1112’，则按从秒开始解析，即’1112’被解析为’00:11:12’，’12’被解析为’00:00:12’。 注意：TIME的零值’00:00:00’本身也是一个合法的TIME值，所以如果数据库里存储的是’00:00:00’，则并不能识别其到底是零值还是正确的值。 YEARYEAR类型是一种1字节类型，用于表示年份值。 注意 从MySQL 8.0.19开始，带有显式显示宽度的YEAR(4)数据类型已经被弃用，MySQL在未来版本中将会将其移除。直接使用YEAR而不使用显示宽度，其具有相同的含义。 MySQL 8.0不再支持2位YEAR(2)数据类型。 MySQL以YYYY格式显示YEAR值，取值范围为1901 ~ 2155和0000。 YEAR字段接受以下格式的值： 四个数字的字符串，范围在’1901’到’2155’之间。 四个数字的数字类型，范围在1901-2155之间。 两个数字的字符串，与前面DATE一样，范围在’0’-‘99’之间，’0’-‘69’表示2000-1069年。’70’-‘99’表示1970到1999年。 两个数字的数字类型，遇上面一样，只是传递的是数字。 作为返回在YEAR上下文中可接受的值的函数的结果，例如NOW()。 JavaJava的日期API可以看另一篇专门介绍的文章。java核心技术-II-6-日期和时间API 只能说Java的日期API设计经过了这么多轮的迭代，比较混乱，要想完全掌握，还确实需要时间。","categories":[{"name":"日期API","slug":"日期API","permalink":"http://yoursite.com/categories/%E6%97%A5%E6%9C%9FAPI/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"日期API","slug":"日期API","permalink":"http://yoursite.com/tags/%E6%97%A5%E6%9C%9FAPI/"}]},{"title":"深入理解JVM1-2.2-自动内存管理-垃圾收集器与内存分配策略（垃圾收集器及其选择）","slug":"深入理解JVM1-2.2-自动内存管理-垃圾收集器与内存分配策略（垃圾收集器及其选择）","date":"2022-03-16T01:47:27.000Z","updated":"2022-03-16T11:34:42.945Z","comments":true,"path":"2022/03/16/深入理解JVM1-2.2-自动内存管理-垃圾收集器与内存分配策略（垃圾收集器及其选择）/","link":"","permalink":"http://yoursite.com/2022/03/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM1-2.2-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%89%E6%8B%A9%EF%BC%89/","excerpt":"","text":"经典垃圾收集器垃圾收集器是对垃圾收集算法的实现，由于《Java虚拟机规范》中并没有明确垃圾收集器的实现细节。所以不同的厂商对于垃圾收集器都有不同的实现。而这里的经典垃圾收集器主要针对的是JDK 7 Update 4 之后JDK11正式发布之前，Oracle JDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。下图是各款经典垃圾收集器之间的关系： 这里的垃圾收集器都有各自不同的优缺点，还没有出现一个没有短板的收集器，因此后续的工作实际上是根据工作场景选择合适的垃圾收集器。（希望以后能有一个完美的垃圾收集器）。 （注意：Serial+CMS与ParNew+Serial Old的组合在JDK9中已经被废除） Serial收集器Serial是最基础、存在时间最长的收集器，在JDK1.31之前，其是HotSpot虚拟机新生代唯一的收集器。 其特点是单线程，其中的含义包括两层： 只会启动一个线程进行垃圾收集。 当Serial运行的时候，用户线程必须停止。 其原理如图： 就大多数场景来说，可能这种完全停止用户的场景并不是理想的行为。例如堆过大的时候，那么用户线程需要停顿的时间就会加长。例如对于一个C端应用，停顿几秒甚至十几秒的时间是非常致命的。 也因为如此，HotSpot团队也一直在研究新的收集器来缓解这种情况。从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）和Garbage First（G1）收集器，最终至现在垃圾收集器的最前沿成果Shenandoah和ZGC等。 但实际上其也有优点和缺点： 优点 简单、高效，Serial收集器由于没有线程交互的开销。对于Java堆较小的环境中，其停顿时间并不会很长，其专一性也可以提升效率（比如最近流行的微服务或者桌面端程序）。 缺点 收集时需要停止用户线程，对于大的Java堆，停顿时间会非常长，很致命。 ParNew收集器（新生代-多线程）ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之 外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX： PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。 其（搭配Serial Old）原理如图： ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处。但由于目前除Serial之外，仅有该收集器可以与CMS收集器搭配使用，所以其仍然是不少服务端HotSpot虚拟机的新生代收集器。 CMS是HotSpot在JDK5推出的一个跨时代的老年代收集器，其意义在于可以使垃圾收集与用户线程并行执行。遗憾的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。 但是随着G1收集器的登场，CMS也不再是官方的推荐老年代收集器。G1作为全堆收集器，不再需要其他收集器配合，因此ParNew收集器也不再被广泛使用。 值得注意的是：ParNew收集器并不一定就比Serial收集器性能更好，特别是在单线程，单核的情况下。甚至由于线程间交互的开销，在使用超线程实现的多线程环境下的表现可能比Serial更差。 Parallel Scavenge收集器（吞吐量）Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器。其主要特点是：Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。 Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。这两个参数实际上互斥的，一个优秀就会牺牲另一个的性能。 -XX：MaxGCPauseMillis：允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的 时间不超过用户设定值。当把这个值设的很低时，即停顿的时间很低，那么相应停顿次数就会增加，那么吞吐量就会减少。 XX：GCTimeRatio：允许的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的 比率，相当于吞吐量的倒数。 由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。 该收集器还提供了一个-XX：+UseAdaptiveSizePolicy参数，其作为一个开关属性，可以设定是否让Parallel Scavenge自己决定新生区的大小（-Xmn）、Eden、Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适设定的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）。 Serial Old收集器Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收 集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用 途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。 原理图如下： 需要说明一下，Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集，并非 直接调用Serial Old收集器，但是这个PS MarkSweep收集器与Serial Old的实现几乎是一样的，所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解。 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。 这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相 当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PSMarkSweep）收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。但是由于Serial Old单线程的性能问题，其吞吐量能甚至不如ParNew加CMS。 直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。 其原理如图： CMS收集器（停顿时间）CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。其基于标记-清除算法实现。 它的运作 过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括： 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。 并发标记（CMS concurrent mark）：从GC Roots的直接关联对象开始遍历整个对 象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。 重新标记（CMS remark）：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。 并发清除（CMS concurrent sweep）：清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。 所以其中初始标记、重新标记这两个步骤仍然需要“Stop The World”，其他两个阶段是可以并发的。 但由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 其原理如图： CMS从初创性来说是很优秀的，基本实现了与用户进程并发的要求。但其仍然存在以下问题： CMS收集器对处理器资源非常敏感：由于并发，所以收集器本身也需要占用一定的处理器资源，所以如果处理器性能不行，相反回拖慢程序的运行。CMS默认启动的回收线程数是（处理器核心数量 +3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的 处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时， CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。 CMS收集器无法处理“浮动垃圾”（Floating Garbage）：有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数-XX：CMSInitiatingOccu-pancyFraction的值 来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动 阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满 足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不 得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。 CMS无法很好处理内存碎片的问题：CMS是一款基于“标记-清除”算法实现的收集器，其基本原理就决定了回产生内存碎片，并且在碎片过多，导致无法分配大对象的时候，就不得不启动一次Full GC。因此其后提供了-XX：+UseCMS-CompactAtFullCollection参数用来在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程。-XX：CMSFullGCsBeforeCompaction参数用来要求CMS收集器在执行过若干次（数量 由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理。 Garbage First收集器Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集 器面向局部收集的设计思路和基于Region的内存布局形式。 G1是一款主要面向服务端应用的垃圾收集器。HotSpot开发团队最初赋予它的期望是（在比较长 期的）未来可以替换掉JDK 5中发布的CMS收集器。JDK 9发布之 日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。 G1的设计思路与之前的收集器都不相同，其面向整个Java堆，而不仅仅是新生代或者老年代，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。 G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。 虽然G1也仍是遵循分代收集理 论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。 Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设 定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。 虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作 为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免 在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃 圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。 其分区示意图如下： 如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的 运作过程大致可划分为以下四个步骤： 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。 从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的， 换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才能担当起“全功能收集器”的重任与期望。 其原理图如下： 与CMS 的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region 之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。 不过，G1相对于CMS仍然不是占全方位、压倒性优势的，其仍然具有以下缺点： 就内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间。 在执行负载的角度上，同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会 有不同，譬如它们都使用到写屏障，CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行 同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。 低延迟垃圾收集器HotSpot的垃圾收集器从Serial发展到CMS再到G1，经历了逾二十年时间，经过了数百上千万台服 务器上的应用实践，已经被淬炼得相当成熟了，不过它们距离“完美”还是很遥远。 衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟 （Latency），三者共同构成了一个“不可能三角”。三者总体的表现会随技术进步而越来越好，但是 要在这三个方面同时具有卓越表现的“完美”收集器是极其困难甚至是不可能的，一款优秀的收集器通常最多可以同时达成其中的两项。 图3-14中浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的。由图 3-14可见，在CMS和G1之前的全部收集器，其工作的所有步骤都会产生“Stop The World”式的停顿； CMS和G1分别使用增量更新和原始快照（见3.4.6节）技术，实现了标记阶段的并发，不会因管理的堆 内存变大，要标记的对象变多而导致停顿时间随之增长。但是对于标记阶段之后的处理，仍未得到妥 善解决。CMS使用标记-清除算法，虽然避免了整理阶段收集器带来的停顿，但是清除算法不论如何优 化改进，在设计原理上避免不了空间碎片的产生，随着空间碎片不断淤积最终依然逃不过“Stop The World”的命运。G1虽然可以按更小的粒度进行回收，从而抑制整理阶段出现时间过长的停顿，但毕竟也还是要暂停的。 最后的两款收集器，Shenandoah和ZGC，几乎整个工作过程全 部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上是固定 的，与堆的容量、堆中对象的数量没有正比例关系。实际上，它们都可以在任意可管理的（譬如现在 ZGC只能管理4TB以内的堆）堆容量下，实现垃圾收集的停顿都不超过十毫秒这种以前听起来是天方 夜谭、匪夷所思的目标。这两款目前仍处于实验状态的收集器，被官方命名为“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time Garbage Collector）。 Shenandoah收集器Shenandoah收集器由于并不是Oracle公司开发的垃圾收集器，不可避免地会受到一些来自“官方”的排挤。Oracle仍明确拒绝在OracleJDK 12中支持Shenandoah收集器，并执意在打包 OracleJDK时通过条件编译完全排除掉了Shenandoah的代码，换句话说，Shenandoah是一款只有OpenJDK才会包含，而OracleJDK里反而不存在的收集器。 最初Shenandoah是由RedHat公司独立发展的新型收集器项目，在2014年RedHat把Shenandoah贡献 给了OpenJDK，并推动它成为OpenJDK 12的正式特性之一。这个项目的目标 是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器，该 目标意味着相比CMS和G1，Shenandoah不仅要进行并发的垃圾标记，还要并发地进行对象清理后的整理动作。 Shenandoah收集器与G1有很多相同的特点： 基于Region的堆内存布局。 存在存放大对象的Humongous Region。 默认的回收策略也同样是优先处理回收价值最大的 Region。 但在管理堆内存方面，其与G1至少有三个明显的不同之处： 最重要的当然是支持并发的整理算法，G1的回收阶段是可以多线程并行的，但却不能与用户线程并发。而Shenandoah收集器可以与用户线程并发。 Shenandoah（目前）是默认不使用分代收集的，换言之，不会有 专门的新生代Region或者老年代Region的存在，没有实现分代，并不是说分代对Shenandoah没有价值，这更多是出于性价比的权衡，基于工作量上的考虑而将其放到优先级较低的位置上。 Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率（连接矩阵可以简单理解为一张二维表格，如果Region N有 对象指向Region M，就在表格的N行M列中打上一个标记）。 例如下面的对象引用和连接矩阵的关系： Shenandoah收集器的工作过程大致可以划分为以下九个阶段： 初始标记（Initial Marking）：与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍 是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。 并发标记（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，这个阶段 是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。 最终标记（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。 并发清理（Concurrent Cleanup）：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。 并发回收（Concurrent Evacuation）：并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之 中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进 行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通 过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。 初始引用更新（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未 做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收 集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。 并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，这个阶段是与用户 线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它 不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。 最终引用更新（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GC Roots 中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。 并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已 再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。 其中最主要的有3个阶段：并发标记、并发回收、并发引用更新。 下图中展示了Shenandoah三个并发阶 段的工作过程，还能形象地表示出并发标记阶段如何找出回收对象确定回收集，并发回收阶段如何移 动回收集中的存活对象，并发引用更新阶段如何将指向回收集中存活对象的所有引用全部修正，此后回收集便不存在任何引用可达的存活对象了。 还有一个关键的概念-Brooks Pointer。“Brooks”是一个人的名字，由他提出了Forwarding Pointer的概念。 Brooks提出的新方案不需要用到内存保护陷阱，而是在原有对象布局结构的最前面统一增加一个 新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。 有了转发指针之后，有何收益暂且不论，所有间接对象访问技术的缺点都是相同的，也是非常显 著的——每次对象访问会带来一次额外的转向开销，尽管这个开销已经被优化到只有一行汇编指令的程度。 转发指针加入后带来的收益自然是当对象拥有了一份新的副本时，只需要修 改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转 发到新的副本上。这样只要旧对象的内存仍然存在，未被清理掉，虚拟机内存中所有通过旧引用地址访问的代码便仍然可用，都会被自动转发到新对象上继续工作。 需要注意，Brooks形式的转发指针在设计上决定了它是必然会出现多线程竞争问题的，如果收集 器线程与用户线程发生的只是并发读取，那无论读到旧对象还是新对象上的字段，返回的结果都应该 是一样的，这个场景还可以有一些“偷懒”的处理余地；但如果发生的是并发写入，就一定必须保证写操作只能发生在新复制的对象上，而不是写入旧对象的内存中。 不妨设想以下三件事情并发进行 时的场景： 收集器线程复制了新的对象副本； 用户线程更新对象的某个字段； 收集器线程更新转发指针的引用值为新副本地址。 如果不做任何保护措施，让事件2在事件1、事件3之间发生的话，将导致的结果就是用户线程对对 象的变更发生在旧对象上，所以这里必须针对转发指针的访问操作采取同步措施，让收集器线程或者用户线程对转发指针的访问只有其中之一能够成功，另外一个必须等待，避免两者交替进行。实际上 Shenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性的。 代码里对象读取的出现频率要比对象写入的频率高出很多，读屏障数量自然也要比写屏障多得多，所以读屏障的使用必须更加谨慎，不允许任何的重量级操作。 其开发者也意识到数量庞大的读屏障带来的性 能开销会是Shenandoah被诟病的关键点之一，所以计划在JDK 13中将Shenandoah的内存屏障模型改 进为基于引用访问屏障（Load Reference Barrier）的实现，所谓“引用访问屏障”是指内存屏障只拦 截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写，这能够省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的消耗。 ZGC收集器ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现 在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。但其实现思路与Shenandoah完全不一样，Shenandoah更像是G1的模式，而ZGC更像是Azul System公司的PGC个C4的继承者。 而ZGC的特点在于以下： 基于Region内存布局的。 不设分代的。 使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法。 以低延迟为首要目标。 Region与Shenandoah和G1一样，ZGC也采用基于Region的堆内存布局，但 与它们不同的是，ZGC的Region（在一些官方资料中将它称为Page或者ZPage）具有动态性——动态创建和销毁，以及动态的区域容量大小。 在x64硬件平台下，ZGC的 Region可以具有如图3-19所示的大、中、小三类容量： 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对 象。 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置 4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型 Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配。 并发整理算法的实现ZGC收集器有一个标志性的设计是它采用的染色指针技术（Colored Pointer，其他类似的技术中可 能将它称为Tag Pointer或者Version Pointer）。 以前对象的一些只供虚拟机访问的属性（如，对象的哈希码、分代年龄、锁记录等）一般存放再对象头中，但如果对象发生移动，即不能保证对象访问能够成功或者有一些根本就不会去访问对象，但又希望得知该对象的某些信息的应用场景。 HotSpot虚拟机的几种收集器有不同的标记实现方案，有的把标记直接记录在 对象头上（如Serial收集器），有的把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使 用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息），而ZGC的染色指针是最直接的、最纯粹的，它直接把标记信息记在引用对象的指针上。 在不同的平台，内存地址的长度是不一样的，而ZGC想在牺牲一定可管理内存空间的情况下，来使用内存地址中的几位来存储信息。 例如Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64TB内存在今天仍然能够充分满足大型服务器的需要。ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对 象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。如下图，当然，由于这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致 ZGC能够管理的内存不可以超过4TB（JDK13目前已经扩展到16TB）（2的42次幂）： 而染色指针具有以下优点： 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用 掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。实际上，到目前为止ZGC都并未使用任何写屏障，只使用了读屏障（一部分是染色指针的功劳，一部分是ZGC现在还不支持分代收集，天然就没有跨代引用的问题）。 染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。 （现在Linux下的64位指针还有前18位并未使用，它们虽然不能用来寻址，却可 以通过其他手段用于信息记录。如果开发了这18位，既可以腾出已用的4个标志位，将ZGC可支持的 最大堆内存从4TB拓展到64TB，也可以利用其余位置再存储更多的标志，譬如存储一些追踪信息来让垃圾收集器在移动对象时能将低频次使用的对象移动到不常访问的内存区域。） ZGC的工作流程ZGC的运作过程大致可划分为以下四个大的阶 段。全部四个阶段都是可以并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段，这些小阶段，譬如初始化GC Root直接关联对象的Mark Start。 并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的 阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记（尽管ZGC中的名字不叫这些）的 短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。与G1、Shenandoah不同的是，ZGC 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。 并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。重分配集与G1收集器 的回收集（Collection Set）还是有区别的，ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收。相反，ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的 维护成本。因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面 的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的。此外，在JDK 12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。 并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分 配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。 得益于染色指针的支持，ZGC收集器能仅从引用上就明 确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次 访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象 上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。其有两点好处： 只有第一次访问旧对象会陷入转发，也就是只慢一次，对比 Shenandoah的Brooks转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢，因此ZGC对用户程序的运行时负载要比Shenandoah来得更低一些。 由于染 色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于 新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都是可以自愈的。 并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的，但是ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第 一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。因此，ZGC很巧妙地把并发重映射 阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所 有对象的，这样合并就节省了一次遍历对象图[9]的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。 ZGC的设计理念与Azul System公司的PGC和C4收集器一脉相承，是迄今垃圾收集器研究的最 前沿成果，它与Shenandoah一样做到了几乎整个收集过程都全程可并发，短暂停顿也只与GC Roots大小相关而与堆内存大小无关，因而同样实现了任何堆上停顿都小于十毫秒的目标。 但是由于其不存在分代的概念，也为其带来了优点和缺点： 优点：ZGC就完全没有使 用记忆集，它甚至连分代都没有，连像CMS中那样只记录新生代和老年代间引用的卡表也不需要，因而完全没有用到写屏障，所以给用户线程带来的运行负担也要小得多。 缺点：ZGC的这种选择也限制了它能承受的对象分配速率不会太高。假设其全过程要持续十分钟以 上（切勿混淆并发时间与停顿时间，ZGC立的Flag是停顿时间不超过十毫秒），在这段时间里 面，由于应用的对象分配速率很高，将创造大量的新对象，这些新对象很难进入当次收集的标记范 围，通常就只能全部当作存活对象来看待——尽管其中绝大部分对象都是朝生夕灭的，这就产生了大 量的浮动垃圾。如果这种高速分配持续维持的话，每一次完整的并发收集周期都会很长，回收到的内存空间持续小于期间并发产生的浮动垃圾所占的空间，堆中剩余可腾挪的空间就越来越小了。目前唯一的办法就是尽可能地增加堆容量大小，获得更多喘息的时间。 Epsilon收集器Epsilon收集器并不会真正的进行垃圾收集工作。 从JDK 10开始，为了隔离垃圾收集器与Java虚拟机解释、编译、监 控等子系统的关系，RedHat提出了垃圾收集器的统一接口，即JEP 304提案，Epsilon是这个接口的有效性验证和参考实现。 其主要作用在于剥离垃圾收集器影响的性能测试和压力测试。 传统Java有着内存占用较大，在容器中启动时间 长，即时编译需要缓慢优化等特点，这对大型应用来说并不是什么太大的问题，但对短时间、小规模的服务形式就有诸多不适。为了应对新的技术潮流，最近几个版本的JDK逐渐加入了提前编译、面向应用的类数据共享等支持。Epsilon也是有着类似的目标，如果读者的应用只要运行数分钟甚至数秒， 只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。 收集器的权衡对于不同的场景应该具体权衡，如： 收集器特点。 硬件条件。 服务场景。 最好还是经过测试，来选择确定的收集器。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"垃圾收集器与内存分配策略","slug":"垃圾收集器与内存分配策略","permalink":"http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"},{"name":"垃圾收集器及其选择","slug":"垃圾收集器及其选择","permalink":"http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%89%E6%8B%A9/"}]},{"title":"深入理解JVM1-2.1-自动内存管理-垃圾收集器与内存分配策略（垃圾收集算法和HostSpot算法细节）","slug":"深入理解JVM1-2.1-自动内存管理-垃圾收集器与内存分配策略（垃圾收集算法和HostSpot算法细节）","date":"2022-03-14T04:27:04.000Z","updated":"2022-03-16T11:35:11.415Z","comments":true,"path":"2022/03/14/深入理解JVM1-2.1-自动内存管理-垃圾收集器与内存分配策略（垃圾收集算法和HostSpot算法细节）/","link":"","permalink":"http://yoursite.com/2022/03/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM1-2.1-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8CHostSpot%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%EF%BC%89/","excerpt":"","text":"垃圾收集器与内存分配策略对象死亡判定在堆里存放着几乎所有的Java对象，垃圾收集器在对堆进行回收的前，必须先对堆中的对象进行判定，哪些对象是活的，哪些对象是死的。 引用计数算法引用计数法是一种很经典的计数算法，即为每个对象添加一个引用计数器，当有一个地方引用它时，计数器的值就加一；当引用失效的时候，计数器的值就减一。任何时刻计数器为零的对象就是不可能再被使用的对象。 优点 原理简单。 判定效率高。 缺点 单纯的引用技术很难解决循环引用的问题。即A-&gt;B，B-&gt;A。则A，B对象循环计数器都为1，但没有其他对象引用他们。则系统也无法对其进行回收。 可达性分析算法当前主流的商用程序语言（Java，C#等）的内存管理系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存货。其算法的基本思路就是通过一系列的根对象，被称为GC Roots，作为起始节点集，然后从这些节点开始，根据对象引用关系向下搜索，搜索过程中走过的路径被称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达的时候，则证明这个对象是不可能再被使用的。 例如，下图中对象object5、object6、object7虽然互有相关联，但是他们到GC Roots是不可达的，因此他们将会被判定为可回收的对象。 在Java技术体系中，固定可作为FC Roots的对象包括以下几种： 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用的参数、局部变量、临时变量等。 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 在方法区中常量引用的对象，譬如字符串常量（String Table）引用的对象。 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象，如（NullPointException、OutOfMemoryError等），还有系统类加载器。 所有被同步锁（synchronized关键字）持有的对象。 反应虚拟机内部情况的XMLBean、JVMTI中注册回调、本地代码缓存等。 除了这些固定的GC Roots集合以外，根据对象所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”的加入，共同构成完整GC Roots集合。 引用的分类在JDK1.2之前，Java里的引用都是很传统的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块的内存、某对象的引用。这种定义有时候不能满足一些特殊的对象，比如一些可有可无的对象，在内存空间足够的时候，保留其可能会增加好处，但是当内存不足的时候，将其丢弃也不会有太大影响的对象。 因此在JDK1.2之后，Java对应用进行了扩充，将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度一次逐渐减弱。 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似Object obj = new Object()这种引用关系。无论在任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉引用的对象。 软引用是用来描述一些还有用，但非必须的对象。制备软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出溢出异常。在JDK1.2半之后提供了SoftReference类来实现软引用。 弱引用也是用来描述哪些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存道下一次来及收集发生为止。在垃圾收集器开始工作，无论当前内存是否足够，都会回收掉制备弱引用关联的对象。在JDK1.2版之后提供了WeakReference类来实现弱引用。 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存实践构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后提供了PhantomReference类来实现虚引用。 finalize()方法当一个对象在可达性分析算法中被判定为不可达对象，也不是一定就会被回收，要真正宣布一个对象死亡，至少需要经历两次标记过程： 通过从GC Roots出发，发现该对象没有于其相连接的引用链，此时它会被第一次标记。随后会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者其finalize()方法已经被执行过了，那么虚拟机将这两种情况都被视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么该对象将会被放置在一个F-Queue队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程区执行它们的finalize()方法。这里的执行并不会承诺其会执行结束，因为如果某一个finalize()方法执行很缓慢，或者陷入了死循环，将会导致F-Queue队列队中的其他对象永久处于等待、导致整个内存回收子系统的崩溃。 finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将会对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()对象中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可。比如将自己（this关键字）赋值给某个类或者对象的成员变量。那么在第二次标记时它将被移出“即将回收”的集合。如果对象这时候还没有逃脱，那么基本它就真的要被回收了。 值得注意的是：任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。 回收方法区对于方法区，《Java虚拟机规范》中提到可以不要求在虚拟机在方法区中实现垃圾回收，实际上也有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类型卸载）。方法区的垃圾回收条件比较苛刻，并且回收效率也比较低，所以其性价比比较低。 方法区的垃圾收集主要回收两部分内容： 废弃的常量：如&quot;java&quot;曾经被一个变量引用，但现在已经不存在任何一个变量引用该字符串，那么其就应该被移除出常量池。 不再使用的类型 而判断一个类是否需要回收就更加复杂了，一般需要同时满足下面3个条件： 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的来类加载器已经被回收了，整个条件除非是经过精心设计的可替代类加载器的场景，如OSGi，JSP等的重加载。否则通常很难达到。 该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类。 Java虚拟机被允许对满足了上述3个条件的无用类进行回收，这里仅仅说的是“被允许”，而并不是和对象一样，没有引用了就必然会被回收。 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类卸载的能力，以保证不会堆方法区造成太大的内存压力。 垃圾回收算法垃圾收集算法的实现设计大量的程序细节，且各个平台的虚拟机操作内存的方法都有差异，在本节中只介绍分代收集理论和几种算法思想及其法阵过程。从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracaing GC），这两类也经常被称为“直接垃圾收集”和“间接垃圾收集”。由于引用式垃圾收集算法在主流的Java虚拟机中均未涉及，所以这里介绍的所有算法均属于追踪式垃圾收集的范畴。 分代收集理论当前商业虚拟机的垃圾收集器，大多都遵循了“分代收集”（Generation Collection）的理论进行设计，分代收集名为理论，实际上是一套符合大多数程序运行情况的经验法则，其建立在两个分代假说之上： 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以灭亡。 这两个假说奠定了多款常用垃圾收集器的一致设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象按照年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。 在Java堆划分出不同区域之后，垃圾收集器才可以每次回收其中某一个特定的区域，因此产生了 “Minor GC”，“Major GC”和“Full GC”这样回收类型的划分。 针对不同区域的的收集算法，比如“标记-复制算法”，“标记-清除算法”，“标记-整理算法”等。 在一般的商用Java虚拟机中，设计者一般至少会把Java堆分为新生代（Young Generation）和老年代（Old Generation）两个区域。 还需要思考的一个问题，就是不同代际对象之间的引用问题，例如要对新生代区域进行收集（Minor GC），但新生代中的对象完全可能被老年代引用，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中的对象来确保可达性分析结果的正确性，反过来也一样。遍历整个老年代所有对象的方案理论上可行，但无疑会为内存回收带来很大的负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则： 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。 这其实是可根据前两条假说逻辑推理得出的隐含推论：存在相互引用关系的两个对象应该更倾向于同时生存或者同时消亡。 名词解释： 部分收集（Partial GC）：值目标不是完全收集整个Java堆的垃圾收集，其中又分为： 新生代收集（Minor GC/Young GC）：指目标指示新生代的垃圾收集。 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集器。目前只有G1收集器会有这种行为。 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。 标记-清除算法最早出现的也是最基础的垃圾收集算法即为“标记-清除（Mark-Sweep）算法”，其主要分为两部分： 首先标记处所有需要回收的对象。 在标记完成后，统一回收掉所有被标记的对象。 缺点标记-清除算法是最基础的算法，因为其后续的算法大多都是以标记-清除算法为基础，对其缺点改进而得。其主要有以下两个缺点： 执行效率不稳定，如果Java堆包含大量标记对象，而其中大部分是需要被回收的，这是必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随着对象数量增长而降低。 内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后再程序运行过程中需要分配较打对象时产生不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 其原理如图： 标记-复制算法标记-复制算法常被称简称为复制算法，其是为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。最原始的思路主要为：将可用内存划分为容量大小相等的两部分，每次只是用其中一块。其中一块使用完后，就将其该块中存活的对象复制到另外一块中去，然后再把已使用的内存空间一次性清除掉。 优点 在多数对象都是可回收时，需要复制的对象很少，效率高。 每次复制时，都是针对整个半区，进而可以避免内存碎片化的问题。 缺点 在只有少数对象是可回收时，需要复制大量的对象，此时就会产生大量的内存复制开销。 将可用内存缩小为原来的一般，空间浪费有点多。 其原理如图： 后期IBM公司一项研究证明-新生代对象有98%熬不过第一轮收集。因此不必要按照1：1的比例来划分新生代的内存空间。 1989年Andrew Appel又提出了新的划分思路：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只是用Eden和其中一块Survivor空间。发生垃圾收集时，将Eden和该Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已经使用过的那块Survivor。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。当然不可能确保每次以使用的内存都小于一块Survivor空间的大小。所以Appel式回收还有一个充当汉奸情况的“逃生门”的安全设计：当Survivor空间不足以容纳一次Minor GC之后存货的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。 标记-整理算法由于老年代中的对象普遍存活率较高，所以标记-复制算法不再适用。 所以针对老年代对象的死亡特征，1974年Edward Lueders提出了另外一种针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程依然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清除，而是让所有存货的对象都向内存空间的一端移动，然后直接清理边界意外的内存，其主要思路如图： 该算法也存在缺点：即移动对象的收，必须暂停用户进程。（又被称为Stop the World）。 HotSpot虚拟机的算法细节实现根节点枚举由之前的介绍可知，GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（如栈帧中本地变量表），虽然明确，但是随着应用体积的正大，这也是一项很大的工作。 且迄今为止，所有的垃圾收集器在根节点枚举这一步骤中，都是必须暂停用户线程的。 当前主流的Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停下来后，起始并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机会从某个位置直接获得相应的信息。在HotSpot虚拟机的解决方案中，是使用一组称为OopMap的数据结构来达到整个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定位置记录下栈里和寄存器里哪些位置是引用。这样收集器就可以直接得知这些信息了，而不需要真正的从GC Roots开始遍历。 安全点为了节省空间，HotSpot并没有为所有的指令都生成OopMap。只是在特定的位置记录这些信息，这些位置被称为安全点（SafePoint）。即只有当用户程序执行到安全点才能停顿，而不是在任意位置停下来都会开始垃圾收集。因此安全的选定既不能太少一直收集器等待时间太长，也不能太多以至于过分增加垃圾收集带来的性能损失。 所以安全点的选取基本上是以“是否具有让程序长时间执行的特征”为标准来选定的。长时间执行的最明显特征就是指令序列的复用，例如方法的调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。 对于安全点，还有一个需要思考的问题是，如何在垃圾收集发生时让所有线程都跑到最近的安全点，然后停顿下来。其主要有两种方案： 抢先式中断（Preemptive Suspension）：不需要线程的执行代码主动配合，在垃圾收集发生时，系统首先把所有的用户现场全部中断，如果发现有用户线程中断的位置不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程相应GC事件。 主动式中断（Voluntary Suspension）：当垃圾收集需要中断的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动轮询这个标志，一旦发现中断标志为真时就自己在最近地安全点上主动终端挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要套在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够的内存分配新对象。 安全区域安全点机制在保证了程序在执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序在不执行时，比如Sleep或者Blocked状态。此时就无法走到安全点去中断挂起自己。此时就引入了安全区域（Safe Region）来解决。 安全区域是指能够确保在某一段代码片段中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。可以将其看作是扩展拉伸了的安全点。 当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点的枚举，如果完成了，那么线程就会离开安全区域，继续执行。否则它就必须一直等待，直到收到可以离开安全区域的信号为止。 记忆集和卡表为了解决对象跨代引用带来的问题，垃圾收集器在新生代建立了名为记忆集（Remember Set）的数据结构，用来避免把整个老年代加入Roots GC扫描范围。事实上不仅是新生代、老年代之间会存在跨代引用的问题，所有的部分区域收集（Partial GC）行为的垃圾收集器都会存在跨代引用的问题。 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。 在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。那么设计者在实现记忆集的时候，便可以选择更加粗犷的记录颗粒来节省记忆集的存储和维护成本，下面列举了一些可供选择的记录精度： 字长精度：每个记录精确到一个机器字长，该字节包含跨代指针。 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 卡精度：每个记录精确到一块内存区域，该区域内有独享含有跨代指针。 其中第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记录集，这也是目前最常用的一种记忆集实现形式。 但其与记忆集是完全不同的概念。记忆集是一个抽象的数据结构，即之定义了行为意图，并没有定义其具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这么做的。 字节数组CARD_TABLE中的每个元素都对应整个表示的内存区域中一块特定大小的内存块，这个内存块被称为“卡页”（Card Page）。 一个卡页的内存通常包含不止一个对象，只要卡页内有一个（或多个）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标记为1，称这个元素变脏（Dirty），没有则为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。 写屏障前面已经解决了如何使用记忆集来所见GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。 针对第一个问题，答案是很明显的-有其他分代区域中对象引用本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。 对于第二个问题，由于虚拟机负责每条字节码的执行，可以由其进行处理。但在编译执行的场景中，就必须找到一个在机器码层面，把维护卡表的动作放到每一个赋值操作之中。 在HotSpot虚拟机中是通过写屏障（Write Barrier）技术维护卡表状态的。写屏障可以看作是虚拟机层面对“引用类型字段赋值”这个动作的AOP切面。在引用对象赋值时会产生一个环行（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫做写前屏障（pre-Write Barrier），在赋值后的则叫做写后屏障（Post-Write Barrier）。 例如下面的一段代码： 123456void oop_field store (oop* field,oop new_value) &#123; // 引用字段赋值操作 *field = new_value; //写后屏障，在这里完成卡表状态更新 post_write_barrier (field,new_value) ;&#125; 应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新 卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。 除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。 并发的可达性分析可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析， 这意味着必须全程冻结用户线程的运行。 对于GC Roots的遍历，由于其很少，而且通过OopMap等优化技术，停顿时间已经非常短了。但是对于堆的遍历，由于堆的大小就和停顿时间成正比了。堆越大，停顿时间就越长了。 想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进 行对象图的遍历？为了能解释清楚这个问题，我们引入三色标记（Tri-color Marking）[1]作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色： 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对 象不可能直接（不经过灰色对象）指向某个白色对象。 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。 收集器在对象图上标记颜色，同时用户线程在修改引用 关系——即修改对象图的结构，这样可能出现两种后果。一种是把原本消亡的对象错误标记为存活， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理 掉就好。另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误，下面表演示了这样的致命错误具体是如何产生的。 Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问 题，即原本应该是黑色的对象被误标为白色： 赋值器插入了一条或多条从黑色对象到白色对象的新引用； 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。 因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别 产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。 增量更新：要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新 插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫 描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。 原始快照：要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删 除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。 以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"垃圾收集器与内存分配策略","slug":"垃圾收集器与内存分配策略","permalink":"http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"},{"name":"垃圾收集算法和HostSpot算法细节","slug":"垃圾收集算法和HostSpot算法细节","permalink":"http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8CHostSpot%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82/"}]},{"title":"深入理解JVM1-1-自动内存管理-Java内存区域与内存溢出异常","slug":"深入理解JVM1-1-自动内存管理-Java内存区域与内存溢出异常","date":"2022-03-11T06:32:20.000Z","updated":"2022-03-11T09:00:19.687Z","comments":true,"path":"2022/03/11/深入理解JVM1-1-自动内存管理-Java内存区域与内存溢出异常/","link":"","permalink":"http://yoursite.com/2022/03/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM1-1-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","excerpt":"","text":"Java内存区域与内存溢出异常运行时数据区域Java虚拟机在执行Java程序的过程中会把它说管理的内存划分为若干个不同的数据区域。 具体如下图。 程序计数器（线程私有）程序计数器（Program Counter Register）是一块较小的内存，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 值得注意的是：只有当线程执行的是Java方法的时候，这个计数器才记录正在执行的虚拟机字节码指令的地址；如果执行的是原生（Native）方法，这个计数器就为空。 Java虚拟机栈（线程私有）Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 而局部变量存放了编译器可知的各种Java虚拟机基本数据库类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等于对象本身，可能是一个指向内存起始地址的引用 指针，也可能是指向一个代码对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条 字节码指令的地址） 本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用非常相似，且u别是虚拟机栈为悉尼及执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到本地（Native）方法服务。 Java堆Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时启动。此内存区域的唯一目的就是存放内存实例，Java世界里几乎所有的对象实例都在这里分配。 Java堆是垃圾收集器管理的内存区域，因此其也被称为GC堆。从内存回收的角度来看，由于现代垃圾收集器大部分都基于分代收集理论，所以Java堆中经常出现“新生代”，“老年代”，“永久代”，“Eden空间”，“From Survivor空间”，“To Survivor空间”等名词。 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做“非堆”（Non-Heap），目的是与Java堆区分开来。 运行常量池运行时常量池（Running Constant Pool）是方法区的一部分。class文件中除了有类的版本、字段、接口等描述信息外，还有一项信息是常量池表（Constant Pool Tables），用于存放编译期间生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入运行时常量池，运行期间也可以将新的常量放入池中。这种特性被开发人员用得最多的便是String类的intern()方法 直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但也被频繁使用，而且也可能导致OutOfMemoryError异常。 在JDK1.4中新加入了NIO（New Input/Output）类，引用了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提升性能，因为避免了在Java堆和Native堆中来回复制数据。 直接内存不会受到Java堆大小的限制，但是也会受到物理机内存的限制。 HotSpot虚拟机下面简单陈述一下HotSpot虚拟机在Java堆中对象分配、布局和访问的过程。 对象的创建当虚拟机遇到一条字节码new指令时，会经历一下步骤： 检查这个指令的参数是否能在常量池定位到一个类的符号引用。 如果能够定位到，则检查这个符号引用代表的类是否已被加载、解析和初始化过。 如果没有则必须先执行响应的类加载过程 在类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可以完全确定。为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。 一般在内存分配的时候可能会存在多种方案，例如，假如堆中所有被分配的内存都在一侧，而没分配的内存在另一侧，那分配的时候只需要将指针向空闲方向挪动一定距离，这种分配方式被称为指针碰撞。但如果不是分侧分开的，那就需要虚拟机维护一个列表，记录哪些内存是可用的，再分配的时候将对应的位置划分给实例对象，然后更新记录表。 另外在内存分配的时候还可能会遇到冲突的问题，如不同的线程对相同内存区域的划分问题。针对这种问题，一般有两种方案: 对分配内存空间的动作同步处理-实际上虚拟机是采用CAS配上失败重试的方式更新线程操作的原子性。 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，ATLAB）哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁。 内存分配完之后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时新婚便进行。 接下来虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元信息、对象哈希码、对象的GC分代年龄等信息。这些信息会被存放在对象头（Object Header）中。 在上面的工作完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但从Java程序的视角来看，对象创建才刚刚开始-构造函数，即Class文件中的&lt;init&gt;()方法还没有执行。所有的字段都默认为零值，对象需要的其他资源和状态信息也还没按照预定的意图构造好。 对象的内存布局在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分： 对象头（Header） 实例数据（Instance Data） 对齐填充填充（padding） 对象头HotSpot虚拟机对象的对象头部分包括两类信息。 第一类是用于存储对象自身的运行时数据，如哈希、GC分代年龄、所状态标志、线程持有的锁、偏向线程的ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中（未开启压缩指针）中分别为32比特和64比特，官方称之为“Mark Word”。由于对象需要存储的信息有很多，其已经超出了对应头部的长度，所以其还设置了标志位，用来标志相同位置可能存放的不同类型的信息。 另一类信息是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。但并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。此外如果对象是一个Java数据，那么在对象头重还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但数据的长度是不确定的，将无法通过元数据重的信息推断出数据的大小。 实例数据实例数据部分是对象真正存储的有效信息。即程序中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在父类中定义的字段都必须记录起来。这部分的顺序会受到虚拟机分配策略参数（-XX:FieldAllocationStyle参数）和字段在源码中定义的顺序的影响。HotSpot虚拟机默认的分配顺序为long/double、int、short/char、byte/boolean、oops(Ordinary Object Pointers)。从上面默认的分配策略中可以看出，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。 对齐填充对象的第三部分是对其填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动对其内存管理系统要求对象的起始地址必须是8字节的整倍数，换句话说就是任何对象的大小都必须是8字节的整倍数。对象头已经被设计为8字节的倍数，因此，如果对象实例数据部分没有对其的话，就需要通过对其填充来补全。 对象的访问定位创建对象是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。由于《Java虚拟机规范》里面只规定了它是一个指向对象的引用，没有定义这个引用应该通过什么方式去定位、访问到堆中的对象的具体位置，所以对象访问方式也是由虚拟机实现的，主流的访问方式主要有使用句柄和直接指针两种： 如果使用访问句柄的话，Java堆中将会划分出一部分内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自具体的地址信息（原理如图）。 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销（原理如图）。 这两种对象访问方式各有优势： 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄，在对象被移动的时候（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄的实例数据指针，而reference本身不需要修改。 使用直接指针来访问最大好处就是更快，因为它节省了一次指针定位的时间开销。由于对象呢噶访问在Java虚拟机中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。 引用本系列文章内容均来自于《深入理解Java虚拟机-JVM高级特征与最佳性能实践》","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"自动内存管理","slug":"自动内存管理","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"git学习5-补丁","slug":"git学习5-补丁","date":"2022-02-27T12:40:33.000Z","updated":"2022-02-27T12:44:28.526Z","comments":true,"path":"2022/02/27/git学习5-补丁/","link":"","permalink":"http://yoursite.com/2022/02/27/git%E5%AD%A6%E4%B9%A05-%E8%A1%A5%E4%B8%81/","excerpt":"","text":"补丁apply12345678git apply [--stat] [--numstat] [--summary] [--check] [--index | --intent-to-add] [--3way] [--apply] [--no-add] [--build-fake-ancestor=&lt;file&gt;] [-R | --reverse] [--allow-binary-replacement | --binary] [--reject] [-z] [-p&lt;n&gt;] [-C&lt;n&gt;] [--inaccurate-eof] [--recount] [--cached] [--ignore-space-change | --ignore-whitespace] [--whitespace=(nowarn|warn|fix|error|error-all)] [--exclude=&lt;path&gt;] [--include=&lt;path&gt;] [--directory=&lt;root&gt;] [--verbose | --quiet] [--unsafe-paths] [--allow-empty] [&lt;patch&gt;…] 将补丁应用于文件和/或索引。 读取提供的diff输出并将其应用到文件中。当从存储库中的子目录运行时，将忽略该目录外已修补的路径。 使用--index选项，补丁也会应用到索引。 而使用--cached选项，补丁只会应用到索引。 如果没有这些选项，该命令只将补丁应用于文件，而不要求它们存在于Git存储库中。 选项 &lt;patch&gt;…：要读取补丁的文件。-可用于从标准输入读取。 --stat：不应用补丁，而从输入中输出diffstat。。 --summary：不应用补丁，而是输出从git diff扩展头中获得的信息的压缩摘要，例如创建、重命名和模式更改。 --check：应用补丁，而是查看补丁是否适用于当前的工作树和/或索引文件，并检测错误。 --index：将补丁应用到索引和工作树中(或者只是检查它是否会干净地应用到这两个树中，如果--check有效的话)。注意,树副本--index预计索引条目和工作相关的路径是相同的(其内容和元数据等文件模式必须匹配),并将提高一个错误如果他们不是,即使补丁对双方都应用干净指数和隔离工作树。 --cached：只对索引应用补丁，而不触及工作树。如果--check生效，只需要检查它是否完全适用于索引项。 --allow-empty：可以应用空的补丁或者只含提交文本的补丁。 cherry-pick123git cherry-pick [--edit] [-n] [-m &lt;parent-number&gt;] [-s] [-x] [--ff] [-S[&lt;keyid&gt;]] &lt;commit&gt;…git cherry-pick (--continue | --skip | --abort | --quit) 给定一个或多个现有提交，应用每个提交引入的更改，为每个提交记录一个新提交。这需要你的工作树是干净的（没有来自HEAD提交的修改）。 选项 &lt;commit&gt;…：要提交给cherry-pick的提交。 e; --edit：通过这个选项，git cherry-pick将允许你在提交之前编辑提交消息。 例子 git cherry-pick master：在主分支的顶端应用提交引入的更改，并使用此更改创建一个新的提交。 `bashgit cherry-pick ..mastergit cherry-pick ^HEAD master 123456 应用由master的祖先(而不是HEAD的祖先)的所有提交引入的更改来产生新的提交。- &#96;&#96;&#96;bash git cherry-pick maint next ^master git cherry-pick maint master..next 应用所有提交引入的更改，这些提交是维护或下一个的祖先，而不是master或它的任何祖先。 git cherry-pick master~4 master~2 应用由master指向的第五次和第三次提交所引入的更改，并使用这些更改创建2个新的提交。 git cherry-pick (commitid1..commitid100])：commitid1为想复制的最老提交(不包括),commitid100为想复制的最新提交(包括)。 git cherry-pick [commitid1^..commitid100]：commitid1为想复制的最老提交(包括),commitid100为想复制的最新提交(包括)。 git rev-list --reverse master -- README | git cherry-pick -n --stdin：将涉及到README的主分支上的所有提交所引入的更改应用到工作树和索引中，这样就可以检查结果，并在合适的情况下将其转换为单个新提交。 diff123456git diff [&lt;options&gt;] [&lt;commit&gt;] [--] [&lt;path&gt;…]git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…]git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; [&lt;commit&gt;…] &lt;commit&gt; [--] [&lt;path&gt;…]git diff [&lt;options&gt;] &lt;commit&gt;…&lt;commit&gt; [--] [&lt;path&gt;…]git diff [&lt;options&gt;] &lt;blob&gt; &lt;blob&gt;git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt; 显示工作树和索引或树之间的更改、索引和树之间的更改、两棵树之间的更改、合并导致的更改、两个blob对象之间的更改或磁盘上两个文件之间的更改。 git diff [&lt;options&gt;] [--] [&lt;path&gt;…]该形式用于查看相对于索引(下一次提交的暂存区域)所做的更改。换句话说，区别在于您可以告诉Git进一步添加到索引中的内容，但仍然还没有添加。 git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;该形式用于比较文件系统中给定的两条路径。当在一个由Git控制的工作树中运行命令，并且至少有一个路径点在工作树之外时，或者当在一个由Git控制的工作树之外运行命令时，可以省略--no-index选项。 git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…]该形式用于查看您为下一次提交而进行的相对于命名的&lt;commit&gt;的更改。通常，您希望与最近的提交进行比较，因此，如果您没有给出&lt;commit&gt;，则默认为HEAD。如果HEAD不存在(例如未出生的分支)，并且&lt;commit&gt;没有给出，它会显示所有的分段更改。--staging是--cached的同义词。 git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; [--] [&lt;path&gt;…]该形式用于查看工作树中相对于命名的&lt;commit&gt;的更改。您可以使用HEAD将其与最近的提交进行比较，或者使用分支名称将其与不同分支的尖端进行比较。 git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…]该形式用于查看两个任意&lt;commit&gt;之间的更改。 git diff [&lt;options&gt;] &lt;commit&gt; &lt;commit&gt;… &lt;commit&gt; [--] [&lt;path&gt;…]该形式用于查看合并提交的结果。列出的第一个&lt;commit&gt;必须是merge本身;剩下的两个或更多的提交应该是它的父节点。生成所需修订集的一种方便的方法是使用^@后缀。例如，如果master命名了一个合并提交，git diff master master^@将给出与git show master相同的diff组合。 git diff [&lt;options&gt;] &lt;commit&gt;..&lt;commit&gt; [--] [&lt;path&gt;…]这与前面的形式(没有..)是同义的，用于查看两个任意&lt;commit&gt;之间的更改。如果在一边省略&lt;commit&gt;，它将具有与使用HEAD相同的效果。 git diff [&lt;options&gt;] &lt;commit&gt;...&lt;commit&gt; [--] [&lt;path&gt;…]该形式用于查看包含第二个&lt;commit&gt;的分支上的更改，从两个&lt;commit&gt;的共同祖先开始。 选项 -p; -u; --patch：生成补丁文件。这是默认值。 -s; --no-patch：禁止diff输出。对于git show这样的命令很有用，可以默认显示补丁，或者取消--patch的效果。 --output=&lt;file&gt;：输出到特定的文件，而不是标准输出。 --raw：以原始格式生成diff。 --name-only：只显示更改文件的名称。文件名通常用UTF-8编码。 --name-status：只显示更改文件的名称和状态。 rebase12345git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt; [&lt;branch&gt;]]git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;] --root [&lt;branch&gt;]git rebase (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch) 在另一个基地址的顶端应用提交。 如果指定了&lt;branch&gt;， git rebase会在做其他事情之前自动切换&lt;branch&gt;。否则，它将保持在当前分支上。 当前分支中由提交所做的、但不在&lt;upstream&gt;中的所有更改都被保存到一个临时区域。通过git log &lt;upstream&gt;..HEAD命令可以进行显示。 如果提供了--onto选项，则当前分支被重置为&lt;upstream&gt;，或者&lt;newbase&gt;。这与git reset --hard &lt;upstream&gt;(或&lt;newbase&gt;)有完全相同的效果。在重置之前，ORIG_HEAD被设置为指向分支的顶端。 之前保存到临时区域的提交将依次重新应用到当前分支。请注意，在HEAD中任何提交都会引入与在HEAD中提交相同的文本更改。&lt;upstream&gt;都省略了。 选项 --onto &lt;newbase&gt;：创建新提交的起始点。 --keep-base：设置将新提交到&lt;upstream&gt; &lt;branch&gt;的合并基的起点。这个选项在上游分支上开发特性的情况下非常有用。当这个特性正在开发的时候，上游分支可能会向前推进，而保持在上游的顶部重基可能不是最好的主意，而是保持基本的提交。 &lt;upstream&gt;：进行比较的上游分支。可以是任何有效的提交，而不仅仅是现有的分支名称。默认为当前分支配置的上游。 &lt;branch&gt;：工作分支；默认为HEAD。 --continue：在解决合并冲突后重新启动重基流程。 --abort：中止重基操作并将HEAD重置到原始分支。如果在rebase操作开始时提供了&lt;branch&gt;，那么HEAD将被重置为&lt;branch&gt;。否则，HEAD将被重置到重基操作开始时的位置。 --quit：中止重基操作，但不会将HEAD重置回原始分支。因此，索引和工作树也保持不变。如果使用--autostash创建了一个临时存储条目，那么它将被保存到stash列表中。 --apply：使用应用策略来重基(在内部调用git-am)。一旦合并后端处理了应用程序所做的所有事情，这个选项可能在将来不会发生任何操作。 --empty={drop,keep,ask}：如何处理那些在启动时不是空的、也不是任何上游提交的干净的、但在重基之后变成空的提交(因为它们包含已经上游更改的子集)。 例子 假设存在以下历史记录，并且当前分支为“topic”: A---B---C topic / D---E---F---G master 从这里开始，以下任意一个命令的结果: 12git rebase mastergit rebase master topic 其结构将会变为如下： 123 A&#39;--B&#39;--C&#39; topic &#x2F;D---E---F---G master 注意：后一种形式只是简单的git checkout topic后面跟着git rebase master。当rebase退出时，主题将仍然是签出的分支。 如果是下面的结构 12345 G---H---I dev1 &#x2F; A---B---C dev &#x2F;D---E---A&#39;---F master 那么执行git rebase --onto master dev dev1 将会得到结果 12345 A---B---C dev &#x2F; D---E---A&#39;---F master \\ G---H---I dev1 此时dev1线上就包括master的最新代码。 去除分支中的一些提交。 1A---B---C---D---E dev1 执行以下命令后，B和C将会从dev1分支的提交记录中去除。 1git rebase --onto dev1~4 dev1~1 dev1 其结构如下 1A---D---E dev1 如果发生冲突，git rebase会在第一个有问题的提交时停止，并在树中留下冲突标记。您可以使用git diff来定位标记(&lt;&lt;&lt;&lt;&lt;&lt;)并进行编辑以解决冲突。 revert12git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…git revert (--continue | --skip | --abort | --quit) 给定一个或多个现有提交，恢复相关补丁引入的更改，并记录一些记录这些更改的新提交。这需要您的工作树是干净的(没有来自HEAD提交的修改)。 注意：git revert用来记录一些新的提交，以逆转之前的一些提交的效果(通常是一个错误的提交)。如果希望丢弃工作目录中所有未提交的更改，应该看到git-reset，特别是--hard选项。如果您想提取在另一个提交中的特定文件，您应该看到git-restore，特别是--source选项。要注意这些选项，因为它们都会丢弃工作目录中未提交的更改。 选项 &lt;commit&gt;…：要逆转的提交。 -e; --edit：有了这个选项，git revert将允许你在提交恢复之前编辑提交消息。默认是从命令行读取。 -m parent-number;--mainline parent-number：通常您不能恢复合并，因为您不知道合并的哪一边应该被视为主线。此选项指定主线的父节点号(从1开始)，并允许恢复到反转相对于指定父节点的更改。 -n; --no-commit：通常，该命令会自动创建一些提交，并使用提交日志消息来说明哪些提交被还原。此标志应用将命名提交恢复到工作树和索引所需的更改，但不进行提交。此外，当使用这个选项时，您的索引不必与HEAD提交匹配。恢复是针对索引的开始状态进行的。 例子 git revert HEAD~3：恢复HEAD中第四次提交所指定的更改，并使用恢复的更改创建一个新提交。 git revert -n master~5..master~2：将主系统中最后一次提交(包括)的第五次提交的修改恢复到主系统中最后一次提交(包括)的第三次提交，但不要使用恢复后的修改创建任何提交。恢复操作只修改工作树和索引。","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"补丁","slug":"补丁","permalink":"http://yoursite.com/tags/%E8%A1%A5%E4%B8%81/"}]},{"title":"git学习4-共享和更新项目","slug":"git学习4-共享和更新项目","date":"2022-02-27T12:39:49.000Z","updated":"2022-02-27T12:44:00.872Z","comments":true,"path":"2022/02/27/git学习4-共享和更新项目/","link":"","permalink":"http://yoursite.com/2022/02/27/git%E5%AD%A6%E4%B9%A04-%E5%85%B1%E4%BA%AB%E5%92%8C%E6%9B%B4%E6%96%B0%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"共享和更新项目fetch从一个或多个存储库中获取分支和/或标记(统称为“refs”)，以及完成其历史记录所需的对象。关联远程仓库的分支将会被更新。（即将远程仓库的文件同步到本地） 默认情况下，任何指向历史记录的标签也会被获取;其效果是获取指向您感兴趣的分支的标记。此默认行为可以通过使用--tags或--no-tags选项或配置remote.&lt;name&gt;. tagopt。通过使用显式获取标记的refspec，也可以获取不指向您感兴趣的分支的标记。 git fetch可以从单个指定的存储库或URL获取数据，也可以从多个存储库同时获取数据(如果给定&lt;group&gt;并且有远程服务)。 选项 --all：获取所有的远程仓库。 -a; --append：在.git/FETCH_HEAD的现有内容中添加引用的ref名称和对象名称。如果没有这个选项，.git/FETCH_HEAD中的旧数据将被覆盖。 --atomic：使用原子事务更新本地引用。要么更新所有引用，要么在错误时，不更新引用。 --depth=&lt;depth&gt;：限制从每个远程分支历史记录尖端获取指定数量的提交（commit）。 --shallow-since=&lt;date&gt;：深化或缩短浅层存储库的历史，以包括&lt;date&gt;之后的所有可达提交。 --shallow-exclude=&lt;revision&gt;：深化或缩短浅层存储库的历史，以排除从指定的远程分支或标记可到达的提交。此选项可指定多次。 --unshallow：如果原仓库是完整的，则将一个缩短的仓库转变为一个完整的仓库，并且会移除所有加在该仓库上的缩短限制。 -p; --prune：在获取之前，删除在远程上已经不再存在的任何远程跟踪引用。如果只是因为默认的标签自动跟踪或--tags选项而获取标签，那么标签就不会被删除。然而，如果获取标签是由于一个显式的refspec。 -n; --no-tags：默认情况下，指向从远程存储库下载的对象的标记将被获取并存储在本地。此选项禁用自动下载标记。 repository&gt;：“远程”存储库，它是获取或拉取操作的源。这个参数可以是一个URL，也可以是远程服务器的名称。 pull1git pull [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…]] 将远程存储库中的更改合并到当前分支中。如果当前分支位于远程的版本之后，那么默认情况下，它将快进当前分支以匹配远程分支。如果当前分支和远程分支已经偏离，用户需要指定如何使用--rebase或--no-rebase协调偏离的分支。 更准确地说，git pull运行带有给定参数的git fetch，然后根据配置选项或命令行标志调用git rebase或git merge来协调分支。 &lt;repository&gt;应该是传递给git-fetch的远程存储库的名称。&lt;refspec&gt;可以命名任意的远程引用(例如，标记的名称)，甚至可以命名具有相应远程跟踪分支的引用集合(例如，refs/heads/*:refs/remotes/origin/*)，但通常它是远程存储库中的一个分支的名称。 &lt;repository&gt;和&lt;branch&gt;的默认值从当前分支的“remote”和“merge”配置中读取，由git-branch --track设置。 与merge相关的选项 --commit; --no-commit：执行合并并提交结果。这个选项可以用来覆盖--no-commit。只有在合并时才有用。 使用--no-commit，执行合并并在创建合并提交之前停止，给用户一个机会在提交之前检查和进一步调整合并结果。 --edit; -e; --no-edit：在提交成功机械性合并前，打开编辑器来编辑自动生成的合并信息。 --squash; --no-squash：生成工作树和索引状态，就像发生了一个真正的合并(除了合并信息)，但不实际做一个提交，移动HEAD，或记录$GIT_DIR/MERGE_HEAD(导致下一个git commit命令创建一个合并提交)。这允许你在当前的分支上创建一个单独的提交，它的效果与合并另一个分支相同。 --autostash; --no-autostash：在操作开始之前自动创建一个临时stash条目，将其记录在特殊的ref MERGE_AUTOSTASH中，并在操作结束后应用它。这意味着您可以在脏工作树上运行操作。但是，使用时要小心:成功合并后的最终隐藏应用程序可能会导致重要的冲突。 -r; --rebase[=false|true|merges|interactive]：当为true时，在获取后将当前分支重设为上游分支的顶部。如果有一个与上游分支对应的远程跟踪分支，并且上游分支在上次获取后被重置基点，则rebase将使用该信息来避免重基非本地更改。 当设置为merge时，使用git rebase --rebase-merge进行rebase，这样本地合并提交就包含在rebase中。 false时，将上游分支合并到当前分支。 interactive时，启用rebase的交互模式。 push 123456git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;] [--repo=&lt;repository&gt;] [-f | --force] [-d | --delete] [--prune] [-v | --verbose] [-u | --set-upstream] [-o &lt;string&gt; | --push-option=&lt;string&gt;] [--[no-]signed|--signed=(true|false|if-asked)] [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]] [--force-if-includes]] [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…]] 使用本地引用更新远程引用，同时发送完成给定引用所必需的对象。 当命令行没有指定使用&lt;repository&gt;参数推送的位置时，使用branch.*。参考当前分支的远程配置，以确定在何处推送。如果缺少配置，则默认为origin。 当命令行没有指定使用&lt;refspec&gt;…参数或--all，--mirror，--tags选项，命令通过查找remote.*找到默认的&lt;refspec&gt;push配置，如果没有找到，则使用push .default配置来决定推送什么 当命令行和配置文件中都没有指出推送到哪里，默认行为就会被执行，其流程为：当前分支被推送到对应上游分支，但是作为安全保障，如果上游分支不存在与本地同名的分支，则推送会被打断。 选项 &lt;repository&gt;：：“远程”仓库，它是push操作的目的地。这个参数可以是一个URL，也可以是远程服务器的名称。 &lt;refspec&gt;…：指定要用什么源对象更新什么目标引用。&lt;refspec&gt;参数的格式是一个可选的加号+，后面跟着源对象&lt;src&gt;，后面跟着一个冒号:，后面跟着目标ref &lt;dst&gt;。 &lt;src&gt;通常是你想推送的分支的名称，但它可以是任意的“SHA-1表达式”，例如master~4或HEAD。 --all：推送所有分支(即refs/heads/下的refs);不能与其他&lt;refspec&gt;一起使用。 --prune：删除没有本地对应的远程分支。例如，如果本地分支tmp不再存在，则远程分支tmp将被删除。 --mirror：为当前仓库添加一个镜像仓库，即本地仓库所作的任何行为都会被同步到镜像仓库，如创建、更新、删除等。也可以在remote.&lt;remote&gt;.mirror中配置。 -d; --delete：从远程存储库中删除所有列出的参考文献。这与在所有引用前面加上冒号是一样的。 --[no-]atomic：如果可用，在远程端使用原子事务。要么更新所有引用，要么在错误时，不更新引用。如果服务器不支持原子推送，推送将失败。 --[no-]force-with-lease; --force-with-lease=&lt;refname&gt;; --force-with-lease=&lt;refname&gt;:&lt;expect&gt;：通常，如果远程仓库不是本地仓库的祖先，则git push会拒绝执行。 如果远程ref的当前值与配置值匹配，则此选项将覆盖此限制。即可以向非祖先仓库推送。 -f; --force：通常，该命令拒绝更新不是用于覆盖它的本地ref的祖先的远程ref。此外，当使用--force with-lease选项时，该命令拒绝更新当前值不符合预期值的远程ref。 此标志禁用这些检查，并可能导致远程存储库丢失提交;小心使用。 请注意--force适用于所有被推送的引用，因此将它与push.default设置为匹配或多个推送目的地配置为remote.*一起使用。push可以覆盖当前分支以外的引用。 --[no-]force-if-includes：只有当远程跟踪ref的尖端已在本地集成时，才强制更新。 --repo=&lt;repository&gt;：这个选项相当于&lt;repository&gt;参数。如果这两个参数都指定了，命令行参数优先。 -u; --set-upstream：对于每个最新或成功推送的分支，添加upstream (tracking)引用，该引用由无参数的git-pull和其他命令使用。 例子 git push：类似于git push &lt;remote&gt;，其中&lt;remote&gt;是当前分支的远端(或当如果没有为当前分支配置远端，即指origin)。 git push origin：在不进行其他配置的情况下，将当前分支推送到已配置的上游(branch.&lt;name&gt;)。合并配置变量)，如果它与当前分支有相同的名称，并且错误输出而不推其他。 git push origin :：将匹配的分支推到origin。 git push origin master：在源库中找到一个与master匹配的ref(最有可能的是，它会找到ref /heads/master)，然后用它更新源库中相同的ref(例如ref /heads/master)。如果master远程不存在，则会创建它。 git push origin HEAD：将当前分支推到远程上相同名称的方便方法。 git push origin HEAD:master：将当前分支推到origin仓库中匹配master的远程ref。这种形式可以方便地推送当前的分支，而无需考虑它的本地名称。 git push origin :experimental：在origin仓库中找到一个匹配experimental的引用(例如refs/heads/experimental)，并删除它。 git push origin +dev:master：使用dev分支更新origin仓库的master分支，允许非快进更新。这可能会在origin仓库中留下未引用的提交。 remote12345678910111213git remote [-v | --verbose]git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=(fetch|push)] &lt;name&gt; &lt;URL&gt;git remote rename &lt;old&gt; &lt;new&gt;git remote remove &lt;name&gt;git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…git remote get-url [--push] [--all] &lt;name&gt;git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;git remote set-url --delete [--push] &lt;name&gt; &lt;URL&gt;git remote [-v | --verbose] show [-n] &lt;name&gt;…git remote prune [-n | --dry-run] &lt;name&gt;…git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…] 管理当前分支追踪的远程仓库。 命令 add：为&lt;URL&gt;的存储库添加一个名为&lt;name&gt;的远程服务器。然后，命令git fetch &lt;name&gt;可以用来创建和更新远程跟踪分支&lt;name&gt;/&lt;branch&gt;。 使用-f选项，git fetch &lt;name&gt;将在远程信息建立之后立即运行。 使用--tags选项，git fetch &lt;name&gt;从远程仓库导入每个标签。 使用--no-tags选项，git fetch &lt;name&gt;不从远程仓库导入标签。 rename：将远程仓库的名字从&lt;old&gt;更改到&lt;new&gt;。所有远程跟踪分支和远程的配置设置都会被更新。 remove; rm：移除名为&lt;name&gt;的远程仓库。移除所有远程跟踪分支和远程配置设置。 set-head：设置或删除指定远程的默认分支(即-ref refs/remotes/&lt;name&gt;/HEAD的目标)。不需要为远程设置默认分支，但允许指定远程的名称来代替特定的分支。例如，如果origin的默认分支设置为master，那么origin可以在你通常指定origin/master的任何地方指定。 set-branches：更改指定远程跟踪的分支列表。这可用于在远程的初始设置之后跟踪可用远程分支的子集。命名分支将被解释为git remote add命令行上指定的-t选项。 get-url：检索远程服务器的url。insteadOf和pushInsteadOf的配置在这里展开。默认情况下，只列出第一个URL。 set-url：更改远程的url。为匹配regex &lt;oldurl&gt;的remote &lt;name&gt;设置第一个URL(如果没有给出&lt;oldurl&gt;的第一个URL)为&lt;newurl&gt;。如果&lt;oldurl&gt;不匹配任何URL，则会发生错误，不做任何更改。 show：提供有关远程仓库&lt;name&gt;的一些信息。 prune：删除与&lt;name&gt;关联的过时引用。默认情况下，删除&lt;name&gt;下陈旧的远程跟踪分支，但根据全局配置和远程的配置，我们甚至可能删除尚未推送到那里的本地标记。等价于git fetch --prune &lt;name&gt;，除非不会获取新的引用。 update：在存储库中获取由remotes定义的远程或远程组的更新。&lt;group&gt;。如果在命令行上既没有指定group，也没有指定remote，则使用配置参数remots .default;如果没有定义remotes.default，则所有没有配置参数remote.&lt;name&gt;。skipDefaultUpdate设置为true将被更新。","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"共享和更新项目","slug":"共享和更新项目","permalink":"http://yoursite.com/tags/%E5%85%B1%E4%BA%AB%E5%92%8C%E6%9B%B4%E6%96%B0%E9%A1%B9%E7%9B%AE/"}]},{"title":"git学习3-分支与合并","slug":"git学习3-分支与合并","date":"2022-02-27T12:39:21.000Z","updated":"2022-02-27T12:43:27.505Z","comments":true,"path":"2022/02/27/git学习3-分支与合并/","link":"","permalink":"http://yoursite.com/2022/02/27/git%E5%AD%A6%E4%B9%A03-%E5%88%86%E6%94%AF%E4%B8%8E%E5%90%88%E5%B9%B6/","excerpt":"","text":"分支与合并branch123456789101112131415git branch [--color[=&lt;when&gt;] | --no-color] [--show-current] [-v [--abbrev=&lt;n&gt; | --no-abbrev]] [--column[=&lt;options&gt;] | --no-column] [--sort=&lt;key&gt;] [--merged [&lt;commit&gt;]] [--no-merged [&lt;commit&gt;]] [--contains [&lt;commit&gt;]] [--no-contains [&lt;commit&gt;]] [--points-at &lt;object&gt;] [--format=&lt;format&gt;] [(-r | --remotes) | (-a | --all)] [--list] [&lt;pattern&gt;…]git branch [--track[=(direct|inherit)] | --no-track] [-f] &lt;branchname&gt; [&lt;start-point&gt;]git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]git branch --unset-upstream [&lt;branchname&gt;]git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt;git branch (-c | -C) [&lt;oldbranch&gt;] &lt;newbranch&gt;git branch (-d | -D) [-r] &lt;branchname&gt;…git branch --edit-description [&lt;branchname&gt;] branch用于列出、创建或者删除分支。 如果只给出了--list，则列出所有的分支。当前的分支将以绿色高亮显示，并用星号标记。在链接的工作树中签出的任何分支都将以青色突出显示，并用加号标记。 选项-r将列出远程跟踪分支，选项-a将同时显示本地和远程分支。 可以用通过添加&lt;pattern&gt;来筛选符合该模式的分支。（要使用&lt;patterin&gt;，则必须使用--list）。 使用--contains则表示仅显示那些包含&lt;commit&gt;的分支（&lt;commit&gt;的后代）。--no-contains 与其相反，即不包含。 使用--mergerd则表示仅显示那些合并到&lt;commit&gt;的分支。--no-merged相反，即没有合并到&lt;commit&gt;的分支。 第二种形式将创建一个新的名叫&lt;branchname&gt;的分支，其指向当前的HEAD，如果给出&lt;start-point&gt;，则指向给定的位置。一种特殊情况是，可以使用A...B来表示A和B合并的基点的快捷写法（A和B存在一个合并基点）。 注意这种形式会创建一个新的分支，但不会切换到它，可以使用git switch &lt;newBranch&gt;来切换到对应的分支。 一旦一个本地分支是从一个远程追踪分支启动的，那么Git就会自动配置该分支（主要是branch.&lt;name&gt;.remote和branch.&lt;name&gt;.merge配置对），以便后面git pull可以从remote-tracking分支适当地合并。 这个设置可以通过使用--track和--no-track选项来覆盖，或者使用git branch --set-upstream-to来更改。 使用-m或-M（move）选项，&lt;oldbranch&gt;将被重命名为&lt;newbranch&gt;。如果&lt;oldbranch&gt;有一个相应的reflog，它将被重命名以匹配&lt;newbranch&gt;，并且创建一个reflog条目来记住分支的重命名。如果存在&lt;newbranch&gt;，则必须使用-M来强制执行重命名。 -c和-C（copy）选项具有与-m和-M完全相同的语义，只是分支不会被重命名，而是会被复制到一个新名称，连同它的config和reflog。 使用-d或-D选项，&lt;branchname&gt;将被删除。您可以指定多个用于删除的分支。如果分支当前有一个reflog，那么这个reflog也将被删除。 使用-r和-d来删除远程跟踪分支（注意不是删除远程仓库本身，而是删除跟踪）。注意，只有当远程跟踪分支不再存在于远程存储库中时，或者当git fetch被配置为不再获取它们时，才有意义删除它们。 选项 -d; --delete：删除一个分支。该分支必须在其上游分支中完全合并，或者在HEAD中(如果没有使用--track或--set-upstream-to设置upstream)。 -D：--delete --force的简写。 --create-reflog：创建分支的reflog。这激活了对分支ref所做的所有更改的记录，允许使用基于日期的sha1表达式，如&lt;branchname&gt;@{yesterday}。 -f; --force：将&lt;branchname&gt;重置为&lt;startpoint&gt;，即使&lt;branchname&gt;已经存在。如果没有-f, git branch拒绝改变一个已经存在的分支。与-d(或--delete)组合，允许删除分支，而不管它的合并状态，或者它是否指向一个有效的提交。与-m(或--move)组合，允许重命名分支，即使新的分支名称已经存在，同样适用于-c(或--copy)。 -m; --move：移动/重命名一个分支，以及它的配置和reflog。 -M：--move --force的简写。 -c; --copy：复制一个分支，连同它的配置和reflog。 -C：--copy --force的简写。 --color[=&lt;when&gt;]：为分支设置颜色，以突出显示当前、本地和远程跟踪分支。该值必须为always(默认值)、never或auto。 --no-color：关闭分支颜色，即使配置文件给出了默认的颜色输出。--color=never。 -i; --ignore-case：排序和过滤分支不区分大小写。 --column[=&lt;options&gt;]; --no-column：以列（不以列）显示分支列表。 r; --remotes：列出或删除(如果与-d一起使用)远程跟踪分支。结合--list来匹配可选的模式。 -a; --all：同时列出远程跟踪分支和本地分支。结合--list来匹配可选的模式。 -l; --list：列出分支。带有可选&lt;pattern&gt;，例如，git branch --list &#39;maint-*，只列出匹配模式的分支。 --show-current：打印当前分支的名称。在分离的HEAD状态下，不打印任何东西。 -t; --track：当创建一个新的分支时，设置branch.&lt;name&gt;.remote和branch.&lt;name&gt;.merge以设置新分支的”upstream”跟踪配置。配置会告诉git以git status和git branch -v显示两个分支之间的关系。此外，当新分支被指出时，它可以不带参数地执行git pull操作。 --no-track：不设置”upstream”配置，即使分支。设置auto.SetupMerge配置变量。 -u &lt;upstream&gt;; --set-upstream-to=&lt;upstream&gt;：设置&lt;branchname&gt;的跟踪信息，使&lt;upstream&gt;被认为是&lt;branchname&gt;的上游分支。如果没有指定&lt;branchname&gt;，则默认为当前分支。 --edit-description：打开一个编辑器并编辑文本，以解释分支的用途，以及各种其他命令所使用的功能。可以使用多行解释。 contains [commit]：仅列出包含指定提交的分支(如未指定则为HEAD)。 --no-contains [&lt;commit&gt;]：只列出不包含指定提交的分支(如果没有指定，则为HEAD)。 --merged [&lt;commit&gt;]：仅列出从指定的提交(如果没有指定为HEAD)中可获得提示的分支。 --no-merged [&lt;commit&gt;]：仅列出从指定的提交(如果没有指定为HEAD)中无法获得提示的分支。 &lt;branchname&gt;：要创建或删除的分支的名称。 &lt;start-point&gt;：新的分支头将指向这个提交。它可以是一个分支名、一个commit-id或者一个标签。如果这个选项被省略，则将使用当前的HEAD。 &lt;oldbranch&gt;：要重命名的现有分支的名称。 &lt;newbranch&gt;：现有分支的新名称。应用与&lt;branchname&gt;相同的限制。 --sort=&lt;key&gt;：根据给定的键进行排序。前缀-按值的降序排序。您可以多次使用--sort=&lt;key&gt;选项，在这种情况下，最后一个键成为主键。 --points-at &lt;object&gt;：只列出给定对象的分支。 值得注意的是：如果关联的远程分支与本地分支名字不一样，那么git push时git会提醒fatal: The upstream branch of yourcurrent branch does not matchthe name of your current branch.然后回给出其他更复杂的提交方式，最好还是把名字统一为一样。 checkout git checkout 这个命令承担了太多职责，既被用来切换分支，又被用来恢复工作区文件，对用户造成了很大的认知负担。 Git社区发布了Git的新版本2.23。在该版本中，有一个特性非常引人瞩目，就是新版本的Git引入了两个新命令 git switch 和 git restore，用以替代现在的 git checkout。换言之，git checkout 将逐渐退出历史舞台。 Git社区决定这样做，是因为目前 git checkout 命令承载了太多的功能，这让新手们感到困惑。git checkout 的核心功能包括两个方面，一个是分支的管理，一个是文件的恢复。这两个核心功能，未来将由 git switch 和 git restore 分别负责。 1234567git checkout [-q] [-f] [-m] [&lt;branch&gt;]git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;]git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt;git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new-branch&gt;] [&lt;start-point&gt;]git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] --pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]git checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;…] 更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出pathspec, git checkout也会更新HEAD，将指定的分支设置为当前分支。 git checkout [&lt;branch&gt;]切换分支到到&lt;branch&gt;。 git checkout -b|-B &lt;new-branch&gt; [&lt;start-point&gt;]指定-b会导致创建一个新分支，就好像调用了git-branch，然后切换到它。并且可以指出新分支的起始点&lt;start-point&gt; 如果指定-B，那么如果&lt;new-branch&gt;不存在则创建，否则就重置该分支。这相当于： 12$ git branch -f &lt;branch&gt; [&lt;start-point&gt;]$ git checkout &lt;branch&gt; git checkout --detach [&lt;branch&gt;]；git checkout [--detach] &lt;commit&gt;将HEAD指向&lt;commit&gt;，如果提供的是&lt;branch&gt;，则将HEAD切换到&lt;branch&gt;的最新commit。同时更新工作树中的索引和文件。工作树中文件的本地修改将被保留，因此最终的工作树将是提交中记录的状态加上本地修改。 省略&lt;branch&gt;将会将HEAD切换到当前分支的顶端。 选项 -f; --force：当切换分支时，即使索引或工作树与HEAD不同，即使在切换过程中存在未跟踪的文件，也要继续进行。这用于丢弃本地更改和任何未跟踪的文件或目录。 --ours; --theirs：当发生冲突的时候，决定是从#2 (ours) or #3 (theirs)中的哪一个。注意在使用git rebase和git pull --rebase时，ours和theirs可能会交换。--ours是选择保留本地代码。--theirs是选择保留合并分支代码。 -b &lt;new-branch&gt;：创建一个名为&lt;new-branch&gt;的新分支，并在&lt;start-point&gt;处启动它。 -B &lt;new-branch&gt;：创建分支&lt;new-branch&gt;，并在&lt;start-point&gt;处启动它;如果它已经存在，则将其重置为&lt;start-point&gt;。这相当于运行git branch with -f。 -t; --track：当创建一个新的分支时，设置upstream配置。 --bo-track：不要设置“upstream”配置，即使分支。autoSetupMerge配置变量为true。 --guess; --no-guess：如果没有找到&lt;branch&gt;，但是在一个远程(调用它&lt;remote&gt;)中确实存在一个跟踪分支，并具有匹配的名称。其与下面语句一样： 1git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt; 如果分支存在于多个远程中，并且其中一个分支由checkout.defaultRemote配置变量命名，我们将使用该分支来消除歧异，即使&lt;branch&gt;在所有远程中不是唯一的。 --guess是默认行为。用--no-guess来禁用它。 -l：创建新分支的reflog; -d; --detach：切换到一个commit用来检查或者可放弃的实验（而不是切换到一个分支），当&lt;commit&gt;不是分支名时，git checkout &lt;commit&gt;的默认行为。 --orphan &lt;new-branch&gt; [&lt;start-point&gt;]：创建一个新的孤立分支，命名为&lt;new-branch&gt;，从&lt;start-point&gt;开始，并切换到它。在这个新分支上进行的第一次提交将没有父节点，它将是一个新历史的根节点，与所有其他分支完全断开连接并进行提交。 索引和工作树将被调整，就像以前运行过git checkout &lt;start-point&gt;一样。这允许开始一个新的历史记录，记录一组类似于&lt;start-point&gt;的路径，通过简单地运行git commit -a来进行根提交。 -m; --merge：在切换分支时，如果您对当前分支和要切换的分支之间的一个或多个文件进行了本地修改，则该命令将拒绝切换分支，以便在上下文中保留您的修改。但是，使用这个选项，当前分支、工作树内容和新分支之间的三方合并就完成了，您将位于新分支上。当合并冲突发生时，冲突路径的索引条目将保持未合并状态，您需要解决冲突并使用git add标记已解决的路径。 --overwrite-ignore; --no-overwrite-ignore：切换分支时，静默地覆盖被忽略的文件，这是默认行为。当新分支包含被忽略的文件时，使用--no-overwrite-ignore中止操作。 &lt;branch&gt;：要切换得到分支。 &lt;new-branch&gt;：新建分支的名字。 &lt;start-point&gt;：用于启动新分支的提交的名称，默认是HEAD。 &lt;tree-ish&gt;：被切换的树。如果没有指定，默认指定索引。 switch1234git switch [&lt;options&gt;] [--no-guess] &lt;branch&gt;git switch [&lt;options&gt;] --detach [&lt;start-point&gt;]git switch [&lt;options&gt;] (-c|-C) &lt;new-branch&gt; [&lt;start-point&gt;]git switch [&lt;options&gt;] --orphan &lt;new-branch&gt; 切换到特定分支。工作树和索引也会更新。 注意，当使用git switch branchName时，如果branchName不存在，则自动创建一个新的分支然后切换到该分支（行为与checkout一致）。 可以通过添加-c，-C，自动的从一个远程仓库的同名分支创建一个新的分支。或者使用--detach来从一个分支分离出工作树，然后切换到该分支。 交换分支不需要干净的索引和工作树，也就是说允许存在未索引和未提交的文件。但是如果操作将导致本地变更的丢失，则会打断操作。（使用--discard-changes或者--merge可以用来在这种情况下抛弃改变或者合并） 选项 &lt;branch&gt;：要切换到的分支。 &lt;new-branch&gt;：新分支的名字。 &lt;start-point&gt;：新分支的起始点。指定&lt;start-point&gt;允许根据历史上的其他点(而不是HEAD当前点)创建一个分支。 -c &lt;new-branch&gt;; --create &lt;new-branch&gt;：在切换到分支之前，从&lt;start-point&gt;开始创建一个名为&lt;new-branch&gt;的新分支。下面两种写法是相同的： 12$ git branch &lt;new-branch&gt;$ git switch &lt;new-branch&gt; -C &lt;new-branch&gt;; --force-create &lt;new-branch&gt;：类似于--create，只是如果&lt;new-branch&gt;已经存在，它将被重置为&lt;start-point&gt;。下面两种写法是相同的： 12$ git branch -f &lt;new-branch&gt;$ git switch &lt;new-branch&gt; -d; -detach：切换到一个commit点，以进行检查或者可放弃的实验。 --guess; --no-guess：如果没有找到&lt;branch&gt;，但在一个具有匹配名称的远程(称为&lt;remote&gt;)中确实存在一个跟踪分支，则将其视为等效的： 1$ git switch -c &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt; 即如果本地不存在&lt;branch&gt;，但在远程分支中存在同名的分支，则直接将其clone到本地，并且将其upstream设置为远程分支。 如果分支存在于多个远程仓库中，并且其中一个分支由checkout.defaultRemote配置变量命名，我们将使用该分支来消除歧异，即使&lt;branch&gt;在所有远程中不是唯一的。 -f; --force：–discard-changes`的别名。 --discard-changes：即使索引或工作树与HEAD不同，也要继续执行命令。索引和工作树都被恢复以匹配交换目标。如果指定了--recursed -submodules，子模块内容也会被恢复以匹配切换目标。这个操作用于丢弃本地的变更。 -m; --merge：如果有一个或多个文件在当前分支和要切换到的分支不同。switch命令将会终止，但是加上了--merge后，被当前分支将会合到将要被切换的分支，您将位于新分支上。 -t; --track [direct | inheret]：当创建一个新的分支时，设置“upstream”配置。 --orphan &lt;new-branch&gt;：创建一个新的孤立分支，名为&lt;new-branch&gt;。所有跟踪文件都将被被删除。 --ignore-other-worktrees：当需要的ref已经被另一个工作树检出时，git switch将会拒绝执行。这个选项可以强行使其签出到该ref上。换句话说，ref可以被多个工作树持有。 --recurse-submodules; --no-recurse-submodules：使用--recurse-submodules将根据superproject中记录的提交更新所有活动子模块的内容。如果什么都没有使用(或者--no- recursive -submodules)，子模块工作树将不会被更新。就像git-submodule[1]一样，这将分离子模块的HEAD。 log用于展示commit日志。 该命令从给出的提交通过parent链列出所有可达的commit，并且不包含那些以^开头的可达的commits。在默认情况下,输出以反向时间顺序给出。 比如，以下的命令： 1git log foo bar ^baz 意味着-列出所有从foo或bar可到达，但从baz不能到达的提交。 选项 --follow：继续列出重命名以外的文件历史记录(仅适用于单个文件)。 --no-decorate; --decorate[=short|full|auto|no]：打印显示的任何提交的ref名称。如果指定了short，则不会打印refs/heads/、refs/tags/和refs/remotes/的前缀。如果指定了full，则打印完整的引用名称(包括前缀)。如果指定了auto，那么如果输出到终端，则ref名称将显示为short，否则不显示任何ref名称。选项--decorate是--decorate=short的简写。如果配置了，默认为log. decorator的配置值，否则为auto。 --source：打印出在命令行中给出的每个提交的引用名称。 stash123456789101112git stash list [&lt;log-options&gt;]git stash show [-u|--include-untracked|--only-untracked] [&lt;diff-options&gt;] [&lt;stash&gt;]git stash drop [-q|--quiet] [&lt;stash&gt;]git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]git stash branch &lt;branchname&gt; [&lt;stash&gt;]git stash [push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-q|--quiet] [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]] [--] [&lt;pathspec&gt;…]]git stash cleargit stash create [&lt;message&gt;]git stash store [-m|--message &lt;message&gt;] [-q|--quiet] &lt;commit&gt; 回想之前介绍的switch和checkout，当工作树或者索引有修改的时候，是无法切换分支的。而stash就是为了解决这个问题出现的。其可以将工作树或索引的文件保存在本地。之后便可以切换分支。 当你想要记录工作目录和索引的当前状态，但又想要回到一个干净的工作目录时，使用git stash。该命令保存本地修改，然后可以切换到其他分支，在其他分支操作完切换回来之后，再恢复文件。 通过这个命令隐藏的修改可以进行以下操作： git stash list：列举修改。 git stash show：检查修改。 git stash apply：恢复修改。 git stash; git stash push：隐藏当前状态。一个隐藏在默认情况下被命名为WIP on branchname …，但是当创建一个隐藏时，也可以在命令行上给出一个更描述性的消息。 创建的最新隐藏内容存储在refs/stash中;旧的堆栈可以在此引用的reflog中找到，可以使用通常的reflog语法命名。 命令push1push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [-m|--message &lt;message&gt;] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]] [--] [&lt;pathspec&gt;…] 存储当前本地修改为一个stash。 &lt;message&gt;是可选的，其给出了描述和隐藏状态。 其中push关键可以省略，在此模式下，不允许使用非选项参数，以防止拼写错误的子命令生成不需要的隐藏条目。这其中的两个例外是stash -p，它作为stash push -p的别名和pathspec元素，它允许在双连字符之后--以消除歧义。 list1list [&lt;log-options&gt;] 列出你现在的储藏条目。每个储藏条目都列有它的名字、当条目被创建时当前的分支的名称以及条目所基于的提交的简短描述。 该命令采用适用于git log命令的选项来控制显示的内容以及如何显示。 show1show [-u|--include-untracked|--only-untracked] [&lt;diff-options&gt;] [&lt;stash&gt;] 展示在stash中的记录和当前文件内容的不同。 pop1pop [--index] [-q|--quiet] [&lt;stash&gt;] 从stash列表中移除单个stash状态，并将其应用到当前工作树状态的顶部。工作目录必须与索引匹配。 当发生冲突的时候，该命令会失败，但该stash不会从stash列表中移除。此时可以手动解决冲突，然后使用git stash drop来移除。 apply1apply [--index] [-q|--quiet] [&lt;stash&gt;] 与pop类似，但其不会将当前stash从stash列表中移除。 branch1branch &lt;branchname&gt; [&lt;stash&gt;] 从最初创建&lt;stash&gt;的提交开始，创建并切换到一个名为&lt;branchname&gt;的新分支，将&lt;stash&gt;中记录的更改应用到新的工作树和索引。如果成功，并且&lt;stash&gt;是形式stash@{&lt;revision&gt;}的引用，那么它将删除&lt;stash&gt;。 如果你运行git stash push的分支发生了足够大的变化，以至于git stash apply由于冲突而失败，那么这是非常有用的。因为这个隐藏条目应用于在git隐藏运行时是HEAD的提交上，所以它会恢复原来的隐藏状态而不产生冲突。 clear删除所有的stash条目。请注意，这些条目随后将被删除，并且可能无法恢复（谨慎）。 drop1drop [-q|--quiet] [&lt;stash&gt;] 从stash条目列表中删除单个stash条目。（不加参数则删除最近的一条） create创建一个stash条目(这是一个常规提交对象)并返回它的对象名称，而不将其存储在ref名称空间的任何地方。这对脚本很有用。 store 将通过git stash create(一个悬空的合并提交)创建的stash存储在stash ref中，更新stash reflog。这对脚本很有用。这可能不是你想要使用的命令。 选项 -a; --all：此选项仅对push和save命令有效。所有被忽略和未跟踪的文件也被隐藏，然后用git clean清理。 -u; --include-untracked; --no-include-untracked：当使用push和save命令时，所有未跟踪的文件也会被隐藏，然后用git clean清理。当与show命令一起使用时，将隐藏条目中的未跟踪文件显示为diff的一部分。 --only-untracked：（该选项仅对show命令有效）只显示隐藏条目中未跟踪的文件作为差异的一部分。 --index：（此选项仅对pop和apply命令有效）尝试不仅恢复工作树的更改，而且恢复索引的更改。然而，当有冲突时，可能会失败。 -k; --keep-index; --no-keep-index：（此选项仅对push和save命令有效）已经添加到索引中的所有更改都保持不变。 -S; --staged：（此选项仅对push和save命令有效）只隐藏当前进行的更改。这类似于基本的git提交，除了状态被提交到stash而不是当前的分支。(patch选项比该命令优先级高) --pathspec-from-file=&lt;file&gt;：（此选项仅对push命令有效）从文件中读取pathspec。 &lt;pathspec&gt;…：（此选项仅对push命令有效）新的存放条目只记录匹配路径规范的文件的修改状态。在随后的恢复时，索引项和工作树文件也会被回滚到这些文件在HEAD中的状态，而不匹配路径规范的文件则会保持不变。 workwtree12345678git worktree add [-f] [--detach] [--checkout] [--lock [--reason &lt;string&gt;]] [-b &lt;new-branch&gt;] &lt;path&gt; [&lt;commit-ish&gt;]git worktree list [-v | --porcelain]git worktree lock [--reason &lt;string&gt;] &lt;worktree&gt;git worktree move &lt;worktree&gt; &lt;new-path&gt;git worktree prune [-n] [-v] [--expire &lt;expire&gt;]git worktree remove [-f] &lt;worktree&gt;git worktree repair [&lt;path&gt;…]git worktree unlock &lt;worktree&gt; 工作树可以允许将一个仓库的不同分支分别存储到不同的文件目录。而免去了反复切换分支的麻烦（特别是对于很大的项目）。 可以通过git worktree add创建一个新的与该仓库联系的工作树。这个新的工作树被称为为“链接工作树”，而原本的工作树被称为“主工作树”。一个仓库可以有一个主工作树和多个链接工作树。可以使用git worktree remove来移除已存在的工作树。 通过git worktree add &lt;path&gt;，Git会自动创建一个新的分支（其名字是该路径的最后一个文件夹名字），然后将该目录作为该分支的工作树。 也可以通过git worktree add &lt;path&gt; &lt;branch&gt;来将现有的分支和目录链接起来。另一方面，如果您只是计划进行一些实验性的更改或进行测试，而不影响现有的开发，那么创建一个与任何分支都不相关的一次性工作树通常是很方便的。例如，git worktree add -d &lt;path&gt;将在当前分支的同一个提交中创建一个新的工作树，该树带有一个分离的HEAD。 如果一个工作树在没有使用git worktree remove的情况下被删除（即手动删除），那么它所关联的管理文件(驻留在存储库中)最终将被自动删除，或者你可以在主目录或者任何链接的工作树中运行git worktree prune命令来清理任何过期的管理文件。 如果一个链接的工作树存储在一个不总是挂载的便携设备或网络共享中，你可以通过发出git worktree lock命令来防止它的管理文件被删除，还可以指定--reason来解释为什么工作树被锁定。 命令add &lt;path&gt; [&lt;commit-ish&gt;]创建&lt;path&gt;并切换&lt;commit-ish&gt;到其中。新的工作目录链接到当前的存储库，共享除工作目录特定文件(如HEAD、index等)外的所有内容。 如果&lt;commit-ish&gt;是一个分支名称(叫它&lt;branch&gt;)，并且没有找到它，而且-B、-b和--detach都没有使用，但是在一个远程(叫它&lt;remote&gt;)中确实存在一个跟踪分支，具有匹配的名称，则将其视为等价的: 1git worktree add --track -b &lt;branch&gt; &lt;path&gt; &lt;remote&gt;/&lt;branch&gt; 如果分支存在于多个远程中，并且其中一个分支由checkout.defaultRemote配置变量命名，我们将使用该分支来消除歧异，即使&lt;branch&gt;在所有远程中不是唯一的。 如果省略了&lt;commit-ish&gt;并且没有使用-B、-b和--detach，那么，为了方便起见，新的工作树与一个以$(basename &lt;path&gt;)命名的分支(称为&lt;branch&gt;)相关联。如果&lt;branch&gt;不存在，将自动创建一个基于HEAD的新分支，就像给出了-b &lt;branch&gt;一样。如果&lt;branch&gt;确实存在，它将在新的工作树中检出，如果没有在其他地方检出，否则命令将拒绝创建工作树。 list列出每个工作树的详细信息。首先列出主工作树，然后是每个链接的工作树。输出细节包括工作树是否空白，当前签出的修订，当前签出的分支(如果没有，则为“detached HEAD”)。如果工作树被锁定，则显示“locked”，如果工作树可以通过prune命令进行修剪，则显示“prunable”。 lock如果工作树位于不总是挂载的便携设备或网络共享上，锁定它，以防止其管理文件被自动删除。这也可以防止它被移动或删除。可以使用--reason指定锁的原因。 move将一棵工作树移动到一个新的位置。请注意，不能使用此命令移动包含子模块的主工作树或链接工作树。 prune删除$GIT_DIR/worktrees中的工作树信息。 remove移除一个工作树。只有无污染的工作树(没有未被跟踪的文件和在被跟踪的文件中没有修改)可以被删除。不干净的工作树或有子模块的工作树可以用--force移除。主工作树不能被移除。 repair [&lt;path&gt;…]如果可能，修复工作树管理文件，如果它们由于外部因素而损坏或过时。 例如，如果主工作树(或裸存储库)被移动，链接的工作树将无法找到它。在主工作树中运行修复将重新建立连接的工作树到主工作树的连接。 类似地，如果一个链接的工作树在没有使用git worktree move的情况下被移动，那么主工作树(或者裸存储库)将无法找到它。在最近移动的工作树中运行修复将重新建立连接。如果移动了多个链接的工作树，则使用每个工作树的新&lt;path&gt;作为参数从任何工作树运行修复，将重新建立到所有指定路径的连接。 如果手动移动了主工作树和链接工作树，则在主工作树中运行修复并指定每个链接工作树的新将重新建立两个方向上的所有连接。 unlock解锁工作树，允许对其进行修剪、移动或删除。 选项 -f; --force：默认情况下，如果&lt;commit-ish&gt;是一个分支名并且已经被另一个工作树检出，或者&lt;path&gt;已经被分配到某个工作树但现在丢失了(例如，如果手动删除了&lt;path&gt;)， add拒绝创建新的工作树。这个选项覆盖了这些保护措施。要添加一个缺失但锁定的工作树路径，请指定两次--force。 move拒绝移动锁定的工作树，除非指定两次-force。如果目的地已经被分配给其他工作树，但是现在丢失了(例如，如果手动删除了&lt;new-path&gt;)，那么--force允许移动继续;如果目的地被锁定，使用——force两次。 remove拒绝移除不干净的工作树，除非使用--force。要移除锁定的工作树，指定两次--force。 -b &lt;new-branch&gt;; -B &lt;new-branch&gt;：使用add命令时，从&lt;commit-ish&gt;开始创建一个名为&lt;new-branch&gt;的新分支，并将&lt;new-branch&gt;检出到新的工作树中。如果省略&lt;commit-ish&gt;，则默认为HEAD。默认情况下，-b拒绝创建一个已经存在的新分支。-B覆盖这个安全措施，将&lt;new-branch&gt;重置为&lt;commit-ish&gt;。 -d; --detach：使用add命令时，在新的工作树中分离HEAD。 --[no-]checkout：默认情况下，添加检出&lt;commit-ish&gt;，但是--no-checkout可以用来禁止检出。 --[no-]guess-remote：使用worktree add &lt;path&gt;，并没有&lt;commit-ish&gt;时，并不从头创建一个新的分支,如果存在一个远程仓库的分支匹配&lt;path&gt;的基地址名，则基于该远程分支来新建分支，并将其upstram为该远程分支。 --[no-]track：当创建一个新分支时，如果&lt;commit-ish&gt;是一个分支，则将其标记为来自新分支的“upstream”。如果&lt;commit-ish&gt;是一个远程跟踪分支，这是默认值。 --reason &lt;string&gt;：使用lock或add --lock，解释为什么工作树被锁定。","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"分支与合并","slug":"分支与合并","permalink":"http://yoursite.com/tags/%E5%88%86%E6%94%AF%E4%B8%8E%E5%90%88%E5%B9%B6/"}]},{"title":"git学习2-基本快照","slug":"git学习2-基本快照","date":"2022-02-27T12:38:56.000Z","updated":"2022-02-27T12:42:15.064Z","comments":true,"path":"2022/02/27/git学习2-基本快照/","link":"","permalink":"http://yoursite.com/2022/02/27/git%E5%AD%A6%E4%B9%A02-%E5%9F%BA%E6%9C%AC%E5%BF%AB%E7%85%A7/","excerpt":"","text":"基本快照addadd命令用于使用在工作树中找到的当前内容来更新索引，其为下一次提交（commit）准备阶段性的内容。通常将现有路径的当前内容作为一个整体添加，但通过一些选项，它也可以用于添加只应用了部分工作树文件更改的内容，或者删除工作树中不再存在的路径。 git status命令可用于获取一个摘要，其中哪些文件有更改，将在下次提交时暂存。 默认情况下，git add命令不会添加被忽略的文件。如果在命令行中显式地指定了任何被忽略的文件，git add将失败，并显示一列被忽略的文件。git add命令可以使用-f (force)选项添加被忽略的文件。 选项： &lt;pathspec&gt;…：要添加的文件。其规则很简单，主要是通配符*和?可以匹配目录分隔符。例如：Documentation/*.jpg将匹配Documentation子树中的所有.jpg文件，包括Documentation/chapter_1/figure_1.jpg。 -f：允许添加被忽略的文件。 通常用法：1git add . 用来将所有以改变的文件都更新索引。 status该命令展示当前索引文件和当前HEAD提交的不同，工作树与索引文件存在差异的路径，以及工作树中未被Git跟踪的路径。 参数 -s：以短格式化来给出输出。 -l：以长格式来给出输出。 -b; --branch：给出分支和追踪信息（可以以短格式）。 -v：除了已更改的文件的名称外，还显示要提交的暂存文本的更改。 --ignored [=&lt;mode&gt;]：也显示被忽略的文件。mode参数用于指定对被忽略文件的处理。它是可选的:默认traditional。 通常用法1git status 查看当前的文件状态。 diff该命令用于显示工作树和索引树之间的更改、索引和树之间的更改、两棵树之间的更改、合并导致的更改、两个blob对象之间的更改或磁盘上两个文件之间的更改。 git diff [&lt;options&gt;] [--] [&lt;path&gt;…]用于查看相对于索引(下一次提交的暂存区域)所做的更改。您可以通过使用git-add来逐步执行这些更改。 git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;用于比较给定的文件系统上的两条路径。当运行命令在一个Git控制的工作树并且至少其中一个路径指向Git工作目录时，可以省略--no-index。 git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…]用于查看下一个提交相对于其他一次\\&lt;commit>的更改。如果不给出\\&lt;commit>，则默认是HEAD位置。如果没有HEAD并且\\&lt;commit>也没有给出，则显示了所有的staged变化。--staged与--cached一样。 如果使用--merge-base来替换&lt;commit&gt;，则使用使用&lt;commit&gt;和HEAD得合并基点（merge base）来和path进行比较。而不是直接用&lt;commmit&gt;比较。 git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…]用来查看任意两个commit之间的改变。 如果给出了--merge-base选项，就是用两个commit的合并基点（merge base）作为前测，与后面的commit进行对比。 git diff [&lt;options&gt;] &lt;commit&gt; &lt;commit&gt;… &lt;commit&gt; [--] [&lt;path&gt;…]用于查看合并提交的结果。列出的第一个&lt;commit&gt;必须是merge本身;剩下的两个或更多的提交应该是它的父节点。生成所需修订集的一种方便的方法是使用^@后缀。 commit创建一个新的提交（commit），包含索引的当前内容和描述更改的给定日志消息。新的提交是HEAD的直接子节点，通常是当前分支的顶端，并且该分支被更新为指向它(除非没有分支与工作树相关联，在这种情况下，如git-checkout中所述，HEAD被“分离”)。 要提交的内容可以通过以下几种方式指定: 通过使用git-add，在使用commit命令之前，递增地“添加”对索引的更改。 在使用commit命令之前，使用git-rm从工作树和索引中删除文件。 通过列出文件作为提交命令的参数(没有--interactive或--patch switch)，在这种情况下，提交将忽略索引中的更改，而是记录列出文件的当前内容(这必须是Git已经知道的); 通过使用-a参数和commit命令自动“添加”所有已知文件(即所有已经在索引中列出的文件)的更改，并自动“rm”索引中已经从工作树中删除的文件，然后执行实际的提交;-可以省略add步骤（如果全部提交）。 通过使用--interactive或--patch开关和commit命令来逐个决定除了索引中的内容之外，哪些文件或块应该作为提交的一部分，然后再完成操作。 选项 -a;--all：告诉命令自动处理已经被修改和删除的文件（也相当于自动add），但是没有告诉Git的新文件不受影响。 -p;--patch：使用交互式补丁选择接口来选择要提交的更改。 -C &lt;commit&gt;; --reuse-message=&lt;commit&gt;：获取一个现有的提交对象，并在创建提交时重用日志消息和作者信息(包括时间戳)。 -c &lt;commit&gt;; --reedit-message=&lt;commit&gt;：与-C类似，但使用-C会调用编辑器，以便用户可以进一步编辑提交消息。 --reset-author：当与-C/ -c/--amend选项一起使用时，或者在发生冲突的选择之后提交时，声明结果提交的作者现在属于提交者。这也会更新作者的时间戳。 --short：使用短格式来输出。 --long：使用长格式来输出。 --branch：显示分支和跟踪信息。 -F &lt;file&gt;; --file=&lt;file&gt;：从给定的文件中获取提交消息。 --author=&lt;author&gt;：覆盖全局得提交作者。 --date=&lt;date&gt;：覆盖提交中使用的作者日期。 -m &lt;msg&gt;; --message &lt;msg&gt;：使用给定的&lt;msg&gt;作为提交消息。如果给出了多个-m选项，它们的值将连接成单独的段落。注意：-m与-c、-c、-F互斥。 -s; --signoff; --no-signoff：在提交日志消息的末尾添加一个由提交者签名的拖尾。终止的意义取决于你所提交的项目。例如，它可以证明提交者有权在项目许可下提交作品，或者同意一些贡献者的代表，例如开发者原产地证书。参考您正在参与的项目的文档或领导，以理解在该项目中如何使用结束。 --allow-empty：允许提交与上一次commit完全相同的文件内容，其他信息都可以修改，如&lt;msg&gt;。 --allow-empty-message：允许提交一次不包含&lt;msg&gt;的commit。 -e; --edit：打开编辑器（系统设定的默认文本编辑器）来修改来自-F或者-m的消息。 --no-edit：默认，直接提交来自-F或者-m的消息。 --amend：直接替换上一次commit记录（慎重），上一次的commit信息都没了。 note添加、删除或读取附加到对象的注释，而不接触对象本身。默认情况下，注释被保存到refs/notes/commits中并从refs/notes/commits中读取，但是这个默认值可以被覆盖。请参阅下面的选项、配置和环境部分。如果这个ref不存在，它将在第一次需要存储笔记时被静默创建。 注释的典型用法是补充提交消息，而不更改提交本身。可以通过git log显示注释和原始的提交消息。为了区分这些注释和存储在提交对象中的消息，注释像消息一样被缩进，在一个未缩进的行notes (&lt;refname&gt;):(或notes:对于refs/notes/commits)之后。 Notes也可以通过使用--Notes选项添加到使用git format-patch准备的补丁中。这样的注释作为补丁注释添加在三个破折号分隔线之后。 子命令 list：列出给定对象的notes对象。如果没有给出对象，则显示所有注释对象及其注释对象的列表(格式为&lt;注释对象&gt; &lt;注释对象&gt;)。如果没有给出子命令，这是默认的子命令。 add：为给定对象添加notes(默认为HEAD)。如果对象已经有注释则中止(使用-f覆盖现有的注释)。但是，如果您是交互式地使用add(使用编辑器提供注释内容)，那么现有的注释将在编辑器中打开而不是终止(就像编辑子命令)。 copy：复制第一个对象的notes到第二个对象（默认是HEAD）。如果第二个对象已经有note或者第一个对象没有note，则终止。 append：向一个已经存在note的对象追加note（默认HEAD）。如果不存在就创建一个note。 edit：编辑给定对象的notes（默认HEAD）。 show：展示给定对象的notes（默认HEAD）。 merge：合并给定的note引用到当前的note引用。这将尝试将给定notes ref(称为remote)所做的更改合并到当前notes ref(称为local)，因为merge-base(如果有的话)。 remove：移除给定对象的notes（默认HEAD）。当从命令行给出零个或一个对象时，这相当于向编辑子命令指定一个空的注释消息。 get-ref：打印当前的notes引用。这提供了一个简单的方法来检索当前的notes引用(可用于merger子命令)。 选项 -f; --force：当向已经有notes的对象添加注释时，覆盖现有的notes(而不是中止)。 -m &lt;msg&gt;; --message=&lt;msg&gt;：使用给定的注释消息(而不是prompting)。如果给出了多个-m选项，它们的值将连接成单独的段落。以#开头的行和段落之间除了一行以外的空行将被删除。 -F &lt;file&gt;; --file=&lt;file&gt;：从给定的文件中获取笔记消息。以#开头的行和段落之间除了一行以外的空行将被删除。 -C &lt;object&gt;; --reedit-message=&lt;object&gt;：将给定的blob对象(例如，另一个注释)作为注释消息。(使用git notes copy &lt;object&gt;代替在对象之间复制notes。) -c &lt;object&gt;; --reedit-message=&lt;object&gt;：与-C类似，但使用-C会调用编辑器，以便用户可以进一步编辑注释消息。 --allow-empty：允许存储一个空的笔记对象。默认的行为是自动删除空注释。 --commit：完成正在进行的git注释合并。被合并后会自动更新并提交。 restore这里现列举出以下三个命令的区别： reset restore revert 主要区别有 git-revert：进行一个新提交（commit）来恢复其他提交所做的更改。 git-restore：从索引或其他提交中恢复工作树中的文件。这个命令不会更新你的分支。该命令还可以用于从另一个提交恢复索引中的文件。 git-reset：更新你的分支，移动分支的顶端，以便添加或删除分支提交。该操作将更改提交历史记录。 该命令可以从一个还原源中来还原指定工作树中的特定目录或文件。如果一个路径被跟踪，但是在恢复源中不存在，那么它将被删除以匹配源。 该命令还可以用于： --staged恢复索引中的内容，（即撤销上一次add操作）。 --staged --worktree恢复工作树和索引（即撤销add操作并恢复文件内容）。 默认情况下，如果给出--staged，则从HEAD恢复内容，否则从索引恢复内容。使用--source从不同的提交恢复。 选项 -s &lt;tree&gt;; --source=&lt;tree&gt;：使用给定树中的内容恢复工作树文件。通常通过命名提交、分支或与之关联的标记来指定源树。如果没有指定，则从HEAD中恢复，否则从从给出的索引恢复。 -p; --patch：交互式地根据恢复源和恢复位置之间的差异选择块。 -W; --worktree;; -S; --staged：指定恢复位置。如果没有指定任何选项，默认情况下将恢复工作树。指定--staging只会恢复索引。两个都指定则索引和文件都会被恢复。 -q: --quiet：静默，压制反馈信息。 --progress：默认信息，将会报告所有信息。 -m; --merge：当从索引中恢复工作树中的文件时，在未合并的路径中重新创建冲突的合并。 --overlay; --no-overlay：在overlay模式下，该命令在恢复时永远不会删除文件。在no-overlay模式下，不出现在--source树中的跟踪文件将被删除，以使它们完全匹配&lt;tree&gt;。默认为无覆盖模式。 reset该命令用于重置当前的HEAD到指定的状态。 其有以下使用格式： git reset [-q] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…；git reset [-q] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]] [&lt;tree-ish&gt;]这两种格式将重置所有匹配&lt;pathspec&gt;的目录索引到他们在&lt;tree-ish&gt;的状态。(它不影响工作树或当前分支。) 这就意味着git reset &lt;pathspec&gt;与git add &lt;pathspec&gt;是完全相反的操作。并且这条命令也是和git restore [--source=&lt;tree-ish&gt;] --staged &lt;pathspec&gt;...是相等的。 运行git reset &lt;pathspec&gt;命令更新索引项后，可以使用git-restore命令查看工作树索引的内容。或者，使用git-restore并使用--source指定提交，您可以将提交中的路径内容一次性复制到索引和工作树中。 git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;…]交互式地选择索引和&lt;树状&gt;之间的差异的块(默认为HEAD)。所选的块以相反的方式应用于索引。 这意味着，git reset -p是与git add -p相反的，也就是说，你可以使用它来选择性地重置大块数据。 git reset [&lt;mode&gt;] [&lt;commit&gt;]这种格式将当前分支的HEAD重置为&lt;head&gt;并且可能更新索引（将其重置为&lt;commit&gt;的状态）和工作树。其工作模式依赖于&lt;mode&gt;参数。默认为--mixed。所有模式如下： --soft：完全不碰索引文件或工作树(但将头部重置为&lt;commit&gt;，就像所有模式那样)。这使得所有你更改的文件都是Changes to be committed，就像git状态显示的那样。 --mixed：重置索引，但不重置工作树(即，更改的文件保留，但不标记为提交（commit）)，并报告未更新的内容。这是默认操作。如果指定了-N，删除的路径将被标记为意图添加。 --hard：重置索引和工作树。自&lt;commit&gt;以来对工作树中跟踪文件的任何更改都将被丢弃。任何在恢复阶段没有被追踪，而当前阶段跟踪的文件或目录被简单地删除（慎用）。 --merge：重置索引并更新工作树中与&lt;commit&gt;和HEAD不同的文件，但保留索引和工作树中与之不同的文件(即有更改但未添加（add）的文件)。如果一个文件在&lt;commit&gt;和索引之间不一致，则会中止重置。换句话说，--merge的作用类似于git read-tree -u -m &lt;commit&gt;，但它会将未合并的索引项带向前。 keep：重置工作树中&lt;commit&gt;和HEAD之间不一致的索引项，并更新文件。如果一个文件在&lt;commit&gt;和HEAD之间有不同的本地更改，reset将被中止。 --[no-]recurse-submodules：当工作树被更新时，使用--recursive -submodules也会根据父项目中记录的提交，递归地重置所有活动子模块的工作树，并在提交时将子模块的HEAD设置为分离。 选项 -q; --quiet;; --no-quiet：静默/不静默（默认）。 rm从索引中删除匹配pathspec的文件，或者从工作树和索引中删除。git rm不会从你的工作目录中删除文件。被删除的文件必须与分支的顶端相同，并且不能在索引中显示对其内容的更新，尽管可以使用-f选项重写默认行为。当给出--cached时，暂存的内容必须匹配分支的尖端或磁盘上的文件，从而允许仅从索引中删除文件。当使用 sparse-checkouts 模式时，git rm将只删除稀疏签出模式中的路径。 选项： &lt;pathspec&gt;…：要被移除的文件。可以指定前置目录名(例如，dir用于删除dir/file1和dir/file2)来删除目录中的所有文件，并递归地删除所有子目录，但这需要显式地指定-r选项。该命令只删除git已知的路径。（也可以使用通配符*来移除） -f; --force：强制性的移除（当被删除的文件不与分支的顶端相同时也可以被移除）（慎用）。 -n; --dry-run：不要实际删除任何文件。相反，只需显示它们是否存在于索引中，否则将被命令删除。 -r：当给出前导目录名时，允许递归删除。 --cached：此选项把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除 --ignore-unmatch：即使没有匹配的文件，也将以零状态退出。 mv移动或重命名一个文件、目录或符号链接。 格式 12git mv [-v] [-f] [-n] [-k] &lt;source&gt; &lt;destination&gt;git mv [-v] [-f] [-n] [-k] &lt;source&gt; ... &lt;destination directory&gt; 在第一种形式中，它将&lt;source&gt;重命名为&lt;destination&gt;，它必须存在并且是一个文件、符号链接或目录。 在第二种形式中，最后一个参数必须是一个已存在的目录;给定的源代码将被移动到这个目录中。 索引在成功完成后更新，但更改仍然必须提交。 选项 f; --force：强制重命名或移动文件，即使目标存在。 -k：跳过移动或重命名操作，这将可能导致错误情况。当源文件既不存在也不受git控制时，或者除非指定-f，否则它将覆盖现有文件时，就会发生错误。 -v; --verbose：在移动文件时报告文件的名称。","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"基本快照","slug":"基本快照","permalink":"http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E5%BF%AB%E7%85%A7/"}]},{"title":"git学习1-创建和获得项目","slug":"git学习1-创建和获得项目","date":"2022-02-27T12:38:40.000Z","updated":"2022-02-27T12:41:12.932Z","comments":true,"path":"2022/02/27/git学习1-创建和获得项目/","link":"","permalink":"http://yoursite.com/2022/02/27/git%E5%AD%A6%E4%B9%A01-%E5%88%9B%E5%BB%BA%E5%92%8C%E8%8E%B7%E5%BE%97%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"获得和创建项目 pre： 索引（index）就是指添加（add）后的文件记录。 工作树（working tree）指当前的目录树及其文件。 init该命令用于创建一个空的仓库或者初始化一个已经存在的仓库。 其会创建一个.git文件夹，其内部会创建以下子文件： objects refs/heads refs/tags 选项： -q；--quite：只打印错误和警告信息；其他的输出都不会被输出。 --bare：创建一个空仓库，如果GIT_DIR环境变量没有设置，就其将当前工作目录设置。 --template=&lt;template-directory&gt;：指定模板被使用的目录。 -b &lt;branch-name&gt;;--initial-branch=&lt;branch-name&gt;：为新创建的仓库的初始化分支指定指定的名字。（如果没有指定，目前即为master，后期可能会改变。 通常用法：1git init clone克隆一个仓库到一个新的目录。 将一个存储库克隆到一个新创建的目录中，为克隆存储库中的每个分支创建远程跟踪分支(使用git branch——remotes可见)，并创建并签出一个从克隆存储库的当前活动分支分离出来的初始分支。 在克隆之后，没有参数的git fetch命令将会更新所有的远程分支。没有参数的git pull将会额外将远程仓库的master分支合并到当前本地的master分支。 这个默认配置是通过创建对下面的远程分支头的引用来实现的，refs/remotes/origin和初始化remote.origin.url和remote.origin.fetch。 选项： -l; --local：当要被克隆的仓库是一个本地机器，这个标志绕过了正常的“Git感知”传输机制，通过复制objects和refs目录下的HEAD和所有东西来克隆存储库。将创建.git/objects/目录下的文件硬链接，以尽可能节省空间。 --no-hardlinks：强制克隆过程从本地文件系统的存储库中复制.git/objects目录下的文件，而不是使用硬链接。 -q;--quiet：静默地运作。进度不会报告给标准错误流。 --progress：默认状态，除非使用了-q。即所有的状态报告都会被打印出来。 -o &lt;name&gt;; --origin &lt;name&gt;：使用自定义的\\&lt;name>名字作为远程仓库名字，而不是origin。本质是重写了配置文件中的clone.defaultRemoteName项。 -b &lt;name&gt;; --branch &lt;name&gt;：并不是从远程克隆仓库的HEAD所指向的分支来创建新的本地分支的HEAD，而是从\\&lt;name>分支的HEAD来创建。 --depth &lt;depth&gt;：创建一个浅克隆，其历史截断为指定的提交数量。--single-branch和--no-single-branch可以用来获取是否是仓库的所有分支。 --shallow-since=&lt;date&gt;：在指定的时间之后创建具有历史记录的浅拷贝。 --shallow-exclude=&lt;revision&gt;：创建一个具有历史记录的浅克隆，排除从指定的远程分支或标记可到达的提交。此选项可指定多次。 &lt;repository&gt;：要克隆的仓库地址，如：git://git.host.xz/ &lt;directory&gt;：要克隆到的新目录的位置。 通常用法：1git clone git://git.host.xz/","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"创建和获得项目","slug":"创建和获得项目","permalink":"http://yoursite.com/tags/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%8E%B7%E5%BE%97%E9%A1%B9%E7%9B%AE/"}]},{"title":"MySQL必知必会22-30-MySQL高级特征","slug":"MySQL必知必会22-30-MySQL高级特征","date":"2022-02-24T01:54:46.000Z","updated":"2022-02-25T14:44:24.720Z","comments":true,"path":"2022/02/24/MySQL必知必会22-30-MySQL高级特征/","link":"","permalink":"http://yoursite.com/2022/02/24/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A22-30-MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E5%BE%81/","excerpt":"","text":"使用视图视图视图是虚拟的表。与包含数据的表不同，视图只包含使用时动态检索数据的查询。 例如： 12345SELECT cust_name, cust_contact FROM custmers, orders, orderitems WHERE customers.cust_id = orders.cust_id AND orderitems.order_num = orders.order_num AND prod_id = 'TNT2'; 此查询用来检索订购了某个特定产品的客户。任何需要这个数据的 人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。 为了检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。 现在，假如可以把整个查询包装成一个名为productcustomers的虚 拟表，则可以如下轻松地检索出相同的数据： 1SELECT cust_name, cust_contact FROM productcustomers WHERE prod_id = 'TNT2'; 这就是视图的作用。productcustomers是一个视图，作为视图，它 不包含表中应该有的任何列或数据，它包含的是一个SQL查询（与上面用以正确联结表的相同的查询）。 为什么使用视图下面是视图的一些常见应用。 重用SQL语句。 简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必指导它的基本查询细节。 使用表的组成部分而不是整个表。 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 在视图创建之后，可以用与表基本相同的方式利用它们。可以对视 图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据。 重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。 视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。 视图的规则和限制 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相 同的名字）。 对于可以创建的视图数目没有限制。 为了创建视图，必须具有足够的访问权限。这些限制通常由数据 库管理人员授予。 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造 一个视图。 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也 含有ORDER BY，那么该视图中的ORDER BY将被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。 使用视图创建视图使用CREATE VIEW关键词来创建视图。 例如： 12345CREATE VIEW productscustomer AS SELECT cust_name, cust_contact prod_idFROM customers, orders, ordertimesWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_num; 这条语句创建一个名为productcustomers的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。 使用视图如果执行SELECT * FROM productcustomers，将列出订购了任意产品的客户。 如果检索订购了TNT2的客户，可如下进行： 1SELECT cust_name, cust_contact FROM productcustomers WHERE prod_id = 'TNT2'; cust_name cust_contact Coyote Inc. Y Lee Yosemite Place Y Sam 这条语句通过WHERE子句从视图中检索特定数据。在MySQL处 理此查询时，它将指定的WHERE子句添加到视图查询中的已有WHERE子句中，以便正确过滤数据。 创建可重用的视图：创建不受特定数据限制的视图是一种好办法。例如，上面创建的视图返回生产所有产品的客户而 不仅仅是生产TNT2的客户。扩展视图的范围不仅使得它能被 重用，而且甚至更有用。这样做不需要创建和维护多个类似视图。 使用视图重新格式化检索出的数据例如之前提到的在单个组合计算列中返回供应商名和位置： 1234SELECT Concat(RTrim(vend_name),' ('，RTrim(vend_country)，')')As vend_titleFROMvendorsORDER BY vend_name; 现在，假如经常需要这个格式的结果。不必在每次需要时执行联结， 创建一个视图，每次需要时使用它即可。为把此语句转换为视图，可按如下进行： 1234CREATE VIEW vendorlocation AS SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')') AS vend_titleFROM vendorsORDER BY vend_name; 这条语句使用与以前的SELECT语句相同的查询创建视图。为了 检索出以创建所有邮件标签的数据，可如下进行： 1SELECT * FROM vendorlocation; vend_title ACME (USA) Anvils R Us (USA) Furball Inc. (USA) 用视图过滤不想要的数据视图对于应用普通的WHERE子句也很有用。例如，可以定义 customeremaillist视图，它过滤没有电子邮件地址的客户。为此目的，可使用下面的语句： 1234CREATE VIEW customeremiallist ASSELECT cust_id, cust_name, cust_emailFROM customersWHERE cust_email IS NOT NULL; 显然，在发送电子邮件到邮件列表时，需要排除没有电子邮件 地址的用户。这里的WHERE子句过滤了cust_email列中具有NULL值的那些行，使他们不被检索出来。 现在，可以像使用其他表一样使用视图customeremaillist。 1SELECT * FROM customeremiallist； cust_id cust_name cust_email 10001 Coyote Inc. ylee@coyote.com 10003 Wascals rabbit@wascally.com 10004 Yosemite Plca sam@yosemite.com 使用视图与计算字段视图对于简化计算字段的使用特别有用。下面是前面提到的一 条SELECT语句。它检索某个特定订单中的物品，计算每种物品的总价格： 12345SELECT prod_id，quantity ,item _price,quantity=item_price As expanded_ priceFROM orderitemswHERE order_num = 20005; prod_id quantity item_price expanded_price ANV01 10 5.99 59.90 ANV02 3 9.99 29.97 TNT2 5 10.00 50.00 为将其转换为一个视图，如下进行： 123CREATE VIEW orderitemsexpanded ASSELECT order_num, prod_id, quantity, item_price quantity * item_price AS expanded_priceDEOM orderitems; 为检索订单20005的详细内容（上面的输出），如下进行： 1SELECT * FROM orderitemsexpanded WHERE order_num = 20005; odre_num prod_id quantity item_price expanded_price 20005 ANV01 10 5.99 59.90 20005 ANV02 3 9.99 29.97 20005 TNT2 5 10.00 50.00 更新视图通常，视图是可更新的（即，可以对它们使用INSERT、UPDATE和 DELETE）。更新一个视图将更新其基表（视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。 但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不 能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新： 分组（使用GROUP BY和HAVING）； 联结； 子查询； 并； 聚集函数； DISTINCT； 导出（计算）列。 换句话说，本章许多例子中的视图都是不可更新的。这听上去好像 是一个严重的限制，但实际上不是，因为视图主要用于数据检索。 一般，应该将视图用于检索（SELECT语句） 而不用于更新（INSERT、UPDATE和DELETE）。 TIP：视图从MySQL5开始支持。 存储过程存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合，并且可以在调用时传入参数。传统来说，MySQL的存储过程就是MySQL中的函数，其组成函数的语句就是MySQL语句。 使用存储过程创建存储过程简单定义可以通过CREATE PROCEDURE来创建存储过程。其格式与函数定义类似。 例如1：计算平均价格： 12345CREATE PROCEDURE productpricing()BEGIN SELECT Avg(pro_price) AS priceaverage FROM products;END; 如上，与VBS类型，需要声明BEGIN和END。 带参数的定义与函数类似，存储过程是可以带参数的。 如： 12345678910CREATE PROCEDURE productpricing( OUT pl DECIMAL(8, 2), OUT ph DECIMAL(8, 2), OUT pa DECIMAL(8, 2))BEGIN SELECT Min(prod_price) INTO pl FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products;END 此存储过程接受3个参数：pl存储产品最低价格，ph存储产品 最高价格，pa存储产品平均价格。 每个参数必须具有指定的类型，这里使用十进制值。存储过程的参数允许的数据类型与表中使用的数据类型相同。 关键字OUT指出相应的参数用来从存储过程传出 一个值（返回给调用者）。MySQL支持 IN（传递给存储过程）、 OUT（从存 储过程传出，如这里所用） INOUT（对存储过程传入和传出）类型的参 数。 存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列 SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。 这里的参数也是和函数不同的地方，存储过程的参数可以是传入（形参传递），也可以是传出（类似于指针实参，将数据放入内存指定位置，则函数外也可以读取到）。 建立智能存储过程所谓的智能存储过程，就是结合业务，编写结构更明确的存储结构。 其中包含这些前提知识： 存储过程的变量声明： 12SET 变量名 = 表达式值 [,variable_name = expression ...]；SET @l_int = 1; 注意：使用set声明变量，所有MySQL变量都必须以@开始。以@开头的是自定义的，否则其被视为系统变量。 IF语句： 12345IF condition THEN do something;ELSE do otherthing;END IF; CASE语句： 12345678CASE var WHEN condition1 THEN do thing1; WHEN condition2 THEN do thing2; ELSE do surplus things; END CASE 循环语句1（while…do）： 123WHILE condition DO do thingsEND WHILE; 循环语句2（repeat）： 1234REPEAT do things; UNTIL condition;END REPEAT; 循环语句3（loop）： 123456LOOP_LABLE:LOOP do thinngs IF v &gt;=5 THEN LEAVE LOOP_LABLE; END IF;END LOOP; 注释语句： 1-- 使用“--”来表示注释，注意--后的空格 标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。 内置函数： 字符类： CHARSET(str) ：返回字串字符集 CONCAT (string2 [,... ])：连接字串 INSTR (string ,substring ) ：返回substring首次在string中出现的位置,不存在返回0 LCASE (string2 )：转换成小写 LEFT (string2 ,length )：从string2中的左边起取length个字符 LENGTH (string )：string长度 LOAD_FILE (file_name )：从文件读取内容 LOCATE (substring , string [,start_position ] )： 同INSTR,但可指定开始位置 LPAD (string2 ,length ,pad )：重复用pad加在string开头,直到字串长度为length LTRIM (string2 ) ：去除前端空格 REPEAT (string2 ,count ) ：重复count次 REPLACE (str ,search_str ,replace_str ) ：在str中用replace_str替换search_str RPAD (string2 ,length ,pad) ：在str后用pad补充,直到长度为length RTRIM (string2 ) ：去除后端空格 STRCMP (string1 ,string2 ) ：逐字符比较两字串大小, SUBSTRING (str , position [,length ]) ：从str的position开始,取length个字符, 数字类： ABS (number2 )：绝对值 BIN (decimal_number ) ：十进制转二进制 CEILING (number2 ) ：向上取整 CONV(number2,from_base,to_base) ：进制转换 FLOOR (number2 ) ：向下取整 FORMAT (number,decimal_places ) ：保留小数位数 HEX (DecimalNumber )：转十六进制注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(‘DEF’)返回4142143也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19 LEAST (number , number2 [,..]) ：求最小值 MOD (numerator ,denominator ) ：求余 POWER (number ,power ) ：求指数 RAND([seed])：随机数 ROUND (number [,decimals ]) ：四舍五入,decimals为小数位数] 注：返回类型并非均为整数，如： 相当于一门新的语言，使用这门语言来编写一个存储过程（函数）来得到确定的值。 变量作用域内部的变量在其作用域范围内享有更高的优先权，当执行到 end。变量时，内部变量消失，此时已经在其作用域外，变量不再可见了，应为在存储过程外再也不能找到这个申明的变量，但是你可以通过 out 参数或者将其值指派给会话变量来保存其值。 123456789CREATE PROCEDURE proc3() BEGIN SET x1 = 'outer'; BEGIN SET x1 = 'inner'; SELECT x1; END; SELECT x1; END; 调用存储过程与函数一样，存储过程也是通过CALL关键词来调用，参数通过括号内来传递。 如： 1234SET @pricelow = 0;SET @pricehigh = 0;SET @priceaverage = 0;CALL productpricing(@pricelow, @pricehigh, @priceaverage); 检查存储过程为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE PROCEDURE语句： 1SHOW CREATE PROCEDURE ordertotal; 为了获得包括何时、由谁创建等详细信息的存储过程列表，使用SHOW PROCEDURE STATUS。 注意：MySQL从5开始支持存储过程。 游标游标即可以在检索出的数据中，选择对应的行的一个标记，可以游动游标来获得新的数据。 值得注意的是：MySQL的游标只能在存储过程中使用。 使用游标步骤 在能够使用游标前，必须声明（定义）它。这个过程实际上没有 检索数据，它只是定义要使用的SELECT语句。 一旦声明后，必须打开游标以供使用。这个过程用前面定义的 SELECT语句把数据实际检索出来。 对于填有数据的游标，根据需要取出（检索）各行。 在结束游标使用时，必须关闭游标。 在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后， 可根据需要频繁地执行取操作。 创建游标游标用DECLARE语句创建。DECLARE命名游标，并定义 相应的SELECT语句，根据需要带WHERE和其他子句。例如，下面的语句定 义了名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句。 123456CREATE PROCEDURE processorders()BEGIN DECLARE ordernums CURSOR FOR SELECT order_num FROM orders;END; 这里仅仅是声明，并没有进行查询。在定义后才可以进行剩下的操作。 打开和关闭游标打开游标通过OPEN关键字来打开游标。并且在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚 动。 如： 1OPEN ordernums; 关闭游标通过CLOSE语句来关闭游标。CLOSE释放游标使用的所有内部内存和资源，因此在每个游标 不再需要时都应该关闭。 如： 1CLOSE ordernums; 在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使 233 用声明过的游标不需要再次声明，用OPEN语句打开它就可以了。 整合过后就是： 12345678910111213CREATE PROCEDURE processorders()BEGIN -- Declare cursor DECLARE ordernums CURSOR FOR SELECT order_num FROM orders; -- Open the cursor OPEN ordernums； -- Close the curor CLOSE ordernums；END; 使用游标数据在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。 使下一条FETCH语句检索下一行（不 重复读取同一行）。 例1：从游标中检索单个行（第一行） 1234567891011121314151617181920CREATE PROCEDURE processorders()BEGIN -- Declare cursor DECLARE ordernums CURSOR -- Declare local variables DECLARE o INT; FOR SELECT order_num FROM orders; -- Open the cursor OPEN ordernums； -- Get order number FETCH ordernumbers INTO o; -- Close the curor CLOSE ordernums；END; 其中FETCH用来检索当前行的order_num列（将自动从第一行开 始）到一个名为o的局部声明的变量中。对检索出的数据不做任何处理。 例2：循环检索数据，从第一行到最后一行： 123456789101112131415161718192021222324252627282930CREATE PROCEDURE processorders()BEGIN -- Declare cursor DECLARE ordernums CURSOR -- Declare local variables DECLARE o INT; DECLARE done BOOLEAN DEFAULT 0; FOR SELECT order_num FROM orders; -- Declare continue handler DECLARE CONTINUE HANDLER FOR SQLSSTATE '02000' SET done = 1; -- Open the cursor OPEN ordernums； -- Loop through all rows REPEAT -- Get order number FETCH ordernumbers INTO o; -- End of loop UNTIL done END REPEAT; -- Close the curor CLOSE ordernums；END; 与前一个例子一样，这个例子使用FETCH检索当前order_num 到声明的名为o的变量中。但与前一个例子不一样的是，这个例子中的FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTIL done END REPEAT;规定）。为使它起作用，用一个DEFAULT 0（假，不结束）定义变量done。 而DECLARE CONTINUE HANDLER FOR SQLSSTATE &#39;02000&#39; SET done = 1;指定了SQLSTATE &#39;02000&#39;出现时，SET done=1。 例3：整合上面的例子 12345678910111213141516171819202122232425262728293031323334353637-- Declare local variablesDECLARE done BOOLEAN DEFAULT 0;DECLARE o INT;DECLARE t DECIMAL(8,2);-- Declare the cursorDECLARE ordernumbers CURSORFORSELECT order_num FRON orders ;-- Declare continue handlerDECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;-- Create a table to store the resultsCREATE TABLE IF NOT EXISTS ordertotals(order_num INT, total DECIMAL(8,2));-- open the cursorOPEN ordernumbers;-- Loop through all rowsREPEAT -- Get order number FETCH ordernumbers INTO o; -- Get the total for this order CALL ordertotal(o，1，t); -- Insert order and total into ordertotals INSERT INTO ordertotals(order_num，tota1) VALUES(o，t); -- End of loop UNTIL done END REPEAT; -- Close the cursor CLOSE ordernumbers;END 这个例子中，我们增加了另一个名为t的变量（存储每个订 单的合计）。此存储过程还在运行中创建了一个新表（如果它不存在的话），名为ordertotals。这个表将保存存储过程生成的结果。FETCH 像以前一样取每个order_num，然后用CALL执行另一个存储过程（我们在 前一章中创建）来计算每个订单的带税的合计（结果存储到t）。最后，用INSERT保存每个订单的订单号和合计。 TIP：MySQL从5开始支持游标。 触发器所谓触发器，就是在某个操作发生时由MySQL自发的执行其他另外的操作。 例如： 每当增加一个顾客到某个数据库表时，都检查其电话号码格式是 否正确，州的缩写是否为大写； 每当订购一个产品时，都从库存数量中减去订购的数量； 无论何时删除一行，都在某个存档表中保留一个副本。 所有这些例子的共同之处是它们都需要在某个表发生更改时自动 处理。这确切地说就是触发器。触发器是MySQL响应以下任意语句而 自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）： DELETE INSERT UPDATE 其他MySQL语句不支持触发器。 创建触发器在创建触发器时，需要给出4条信息： 唯一的触发器名； 触发器关联的表； 触发器应该响应的活动（DELETE、INSERT或UPDATE）； 触发器何时执行（处理之前或之后）。 保持每个数据库的触发器名唯一：在MySQL 5中，触发器名必 须在每个表中唯一，但不是在每个数据库中唯一。这表示同一 数据库中的两个表可具有相同名字的触发器。这在其他每个数 据库触发器名必须唯一的DBMS中是不允许的，而且以后的 MySQL版本很可能会使命名规则更为严格。因此，现在最好是在数据库范围内使用唯一的触发器名。 可以使用CREATE TRIGGER语句创建。 例如： 1CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'Product added'; CREATE TRIGGER用来创建名为newproduct的新触发器。 AFTER INSERT指定了触发器响应的活动。 ON products指示了在哪张表格触发。 FOR EACH ROW指示了每一次插入都会触发。 SELECT &#39;Product added&#39;指示了触发器触发的操作。 为了测试这个触发器，使用INSERT语句添加一行或多行到products 中，你将看到对每个成功的插入，显示Product added消息。 仅支持表：只有表才支持触发器，视图不支持（临时表也不 支持）。 注意： 触发器按每个表每个事件每次地定义，每个表每个事件可以允许多个触发器。比如，可以定义一张表上两个BEFORE UPDATE触发器，默认会按照定义的顺序触发，想要改变顺序，可以通过指定 FOLLOWS | PRECEDES [trigger name]来调整顺序。 单一触发器不能与多个事件或多个表关联，所 以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。 级联外键操作不会激活触发器。 删除触发器删除触发器只需要用DROP TRIGGER即可。 例如： 1DROP TRIGGER newproduct; 触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。 使用触发器INSERT触发器INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几 点： 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被 插入的行； 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改 被插入的值）； 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值。 例如： 12CREATE TRIGGER neworder ALTER INSERT ON ordersFOR EACH ROW SELECT NEW.order.num; 此代码创建一个名为neworder的触发器，它按照AFTER INSERT ON orders执行。在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW. order_num取得 这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。 测试： 1INSERT INTO orders(order_date, cust_id) VALUES (Now(), 10001); order_num 20010 orders包含3个列。order_date 和 cust_id必须给出， order_num由MySQL自动生成，而现在order_num还自动被返回。 DELETE触发器DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两 点： 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行； OLD中的值全都是只读的，不能更新。 例如： 123456CREATE TRIGGER deleteorder BEFORE DELETE ON ordersFOR EACH ROWBEGIN INSERT INTO archive_orders(order_num. order_date, cust_id) VALUE(OLD.order_num, OLD.order_date, OLD.cust_id);END 在任意订单被删除前将执行此触发器。它使用一条INSERT语句 将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）。 使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器 来说）为，如果由于某种原因，订单不能存档，DELETE本身将被放弃。 多语句触发器：正如所见，触发器deleteorder使用BEGIN和 END语句标记触发器体。这在此例子中并不是必需的，不过也 没有害处。使用BEGIN END块的好处是触发器能容纳多条SQL语句（在BEGIN END块中一条挨着一条）。 UPDATEUPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几 点： 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问 以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值； 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）；在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）； OLD中的值全都是只读的，不能更新。 例如： 12CREATE TRIGGER updatevndor BEFORE UPDATE ON vendors FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state); 何数据净化都需要在UPDATE语句之前进行，就像这个例子中一样。每次更新一个行时，NEW.vend_state中的值（将用来更新表行的值）都用Upper(NEW.vend_state)替换。 事务事务处理（transaction processing）可以用来维护数据库的完整性，它 保证成批的MySQL操作要么完全执行，要么完全不执行。 下面是一些事务的关键词： 事务（transaction）：指一组SQL语句； 回退（rollback）：指撤销指定SQL语句的过程； 提交（commit）：指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）：指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 控制事务处理管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数 据何时应该回退，何时不应该回退。 开始事务可以通过以下语句来标识一个事务的开始： 1START TRANSACTION; 使用回滚（ROLLBACK）MySQL的ROLLBACK命令用来回退（撤销）MySQL语句。 例如： 123456SELECT * FROM ordertaotal;START TRANSACTION;DELETE FROM ordertotals;DELETE * FROM ordertotals;ROLLBACK;SELECT * FROM ordertotals; 这个例子从显示ordertotals表（此表在第24章中填充）的内 容开始。首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条 SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句回退 START TRANSACTION之后的所有语句，最后一条SELECT语句显示该表不为空。 显然，ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）。 事务处理用来管理INSERT、UPDATE和 DELETE语句。你不能回退SELECT语句。（这样做也没有什么意 义。）你不能回退CREATE或DROP操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。 提交事务（COMMIT）一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。 对于多条语句，要想组成一个事务，可以手动开始事务和提交，例如： 1234START TRANSACTION;DELETE FROM orderitems WHERE order_num = 20010;DELETE FROM orders WHERE order_num = 20010;COMMIT; 在这个例子中，从系统中完全删除订单20010。因为涉及更新 两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如 果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。 隐含事务关闭：当COMMIT或ROLLBACK语句执行后，事务会自 动关闭（将来的更改会隐含提交）。 使用保留点简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但 是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。 在事务中，通过以下语句来标记保留点： 1SAVEPOINT pointName; 而在使用回滚时，则不是简单的ROLLBACK，而是使用以下的语句： 1ROLLBACK TO pointName; 保留点越多越好：可以在MySQL代码中设置任意多的保留 点，越多越好。保留点越多，你就越能按自己的意愿灵活地进行回退。 释放保留点：保留点在事务处理完成（执行一条ROLLBACK或 COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。 更改默认的提交行为正如所述，默认的MySQL行为是自动提交所有更改。换句话说，任何 时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句： 1SET autocommit=0; autocommit标志决定是否自动提交更改，不管有没有COMMIT 语句。设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）。 全球化和本地化数据库表被用来存储和检索数据。不同的语言和字符集需要以不同 的方式存储和检索。因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。 在讨论多种语言和字符集时，将会遇到以下重要术语： 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对为规定字符如何比较的指令。 使用字符集和校对顺序MySQL支持众多的字符集。为查看所支持的字符集完整列表，使用 以下语句： 1SHOW CHARACTER SET; 这条语句显示所有可用的字符集以及每个字符集的描述和默认 校对。 为了查看所支持校对的完整列表，使用以下语句： 1SHOW COLLATION; 此语句显示所有可用的校对，以及它们适用的字符集。 为了给表指定字符集和校对，可使用带子句的CREATE TABLE： 12345CREATE TABLE mytable( column1 INT, column2 VARCAHR(100))DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_cli; 此语句创建一个包含两列的表，并且指定一个字符集和一个校对顺序。 一般，MySQL使用以下规则来确定表格的字符集和校对顺序。 如果指定CHARACTER SET和COLLATE两者，则使用这些值。 如果只指定CHARACTER SET，则使用此字符集及其默认的校对（如 SHOW CHARACTER SET的结果中所示）。 如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库 默认。 除了能指定字符集和校对的表范围外，MySQL还允许对每个列设置 它们，如下所示： 12345CREATE TABLE mytablecolumnn1 INT,columnn2 VARCHAR(10),column3VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ciDEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci ; 这里对整个表以及一个特定的列指定了CHARACTER SET和 COLLATE。 如前所述，校对在对用ORDER BY子句检索出来的数据排序时起重要 的作用。如果你需要用与创建表时不同的校对顺序排序特定的SELECT语句，可以在SELECT语句自身中进行： 12SELECT FROM customersORDER BY lastname，firstname COLLATE latin1_general_cs; 此SELECT使用COLLATE指定一个备用的校对顺序（在这个例子 中，为区分大小写的校对）。这显然将会影响到结果排序的次序。 安全管理访问控制MySQL服务器的安全基础是：用户应该对他们需要的数据具有适当 的访问权，既不能多也不能少。换句话说，用户不能对过多的数据具有过多的访问权。 MySQL创建一个名为root的用户账号，它对整个MySQL服务 器具有完全的控制。你可能已经在本书各章的学习中使用root进行过登 录，在对非现实的数据库试验MySQL时，这样做很好。不过在现实世界 的日常工作中，决不能使用root。应该创建一系列的账号，有的用于管理，有的供用户使用，有的供开发人员使用，等等。 管理用户MySQL用户账号和信息存储在名为mysql的MySQL数据库中。一般不需要直接访问mysql数据库和表（你稍后会明白这一点），但有时需要 直接访问。需要直接访问它的时机之一是在需要获得所有用户账号列表时。为此，可使用以下代码： 12USE mysql;SELECT user FROM user; user root 创建账号可以使用CREATE USER语句来创建账号， 例： 1CREATE USER ben IDENTIFIED BY 'p@ssw0rd'; CREATE USER创建一个新用户账号。在创建用户账号时不一定需 要口令，不过这个例子用IDENTIFIED BY &#39;p@$$wOrd&#39;给出了一个口令。 重命名账户可以通过RENAME USER a TO b来进行用户重命名。 如： 1RENAME USER ben TO bforta; 删除账户可以通过DROP USER xxx来删除账户。 如： 1DROP USER bforta; 设置访问权限在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访 问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。 查看权限为看到赋予用户账号的权限，使用SHOW GRANTS FOR，如： 1SHOW GRANTS FOR bforta; Grants for bforta@% CRANT USAGE ON *.* TO “bforta ‘@”%* 输出结果显示用户bforta有一个权限USAGE ON .。USAGE表 示根本没有权限（我知道，这不很直观），所以，此结果表示在任意数据库和任意表上对任何东西没有权限。 授予权限为设置权限，使用GRANT语句。GRANT要求你至少给出以下信息： 要授予的权限； 被授予访问权限的数据库或表； 用户名。 例如： 1GRANT SELECT ON crashcource.* TO bforta; 此GRANT允许用户在crashcourse.*（crashcourse数据库的所 有表）上使用SELECT。通过只授予SELECT访问权限，用户bforta对crashcourse数据库中的所有数据具有只读访问权限。 SHOW GRANTS反映这个更改： 1SHOW GRANTS FOR bforta; Grants for bforta@% GRANT USAGE ON *.* TO “bforta‘@’%’ GRANT SELECT ON ‘crashcourse’ .* TO ‘bforta‘@’%’ 每个GRANT添加（或更新）用户的一个权限。MySQL读取所有 授权，并根据它们确定权限。 撤销权限GRANT的反操作为REVOKE，用它来撤销特定的权限。 例如： 1REVOKE SELECT ON crashcourse。* FROM bforta; 这条REVOKE语句取消刚赋予用户bforta的SELECT访问权限。被 撤销的访问权限必须存在，否则会出错。 GRANT和REVOKE可在几个层次上控制访问权限： 整个服务器，使用GRANT ALL和REVOKE ALL； 整个数据库，使用ON database.*； 特定的表，使用ON database.table； 特定的列； 特定的存储过程。 下面时所有的权限。 更改口令为了更改用户口令，可使用SET PASSWORD语句。新口令必须如下加密： 1SET PASSWORD FOR bforta = Password('n3w p@$$w0rd'); SET PASSWORD还可以用来设置你自己的口令： 1SET PASSWORD = Password('n3w p@$$w0rd'); 数据库维护像所有数据一样，MySQL的数据也必须经常备份。由于MySQL数据 库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。 但是，由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。 下面列出这个问题的可能解决方案。 使用命令行实用程序mysqldump转储所有数据库内容到某个外部 文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。 可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。 可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所 有数据到某个外部文件。这两条语句都接受将要创建的系统文件 名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。 查看日志文件MySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下 几种。 错误日志。它包含启动和关闭问题以及任意关键错误的细节。此 日志通常名为hostname.err，位于data目录中。此日志名可用--log-error命令行选项更改。 查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此 日志文件可能会很快地变得非常大，因此不应该长期使用它。此 日志通常名为hostname.log，位于data目录中。此名字可以用--log命令行选项更改。 二进制日志。它记录更新过数据（或者可能更新过数据）的所有 语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用--log-bin命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前的MySQL版本中使用的是更新日志。 缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这 个日志在确定数据库何处需要优化很有用。此日志通常名为 hostname-slow.log ，位于 data 目录中。此名字可以用--log-slow-queries命令行选项更改。 在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。 改善性能下面是一些简单的可能改善MySQL性能的方法： MySQL是用一系列的默认设置预先配置的，从这些设置开始通常 是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大 小等。（为查看当前设置，可使用SHOW VARIABLES;和SHOW STATUS;。） MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多 个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执 行缓慢。如果你遇到显著的性能不良，可使用SHOW PROCESS LIST显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。 总是有不止一种方法编写同一条SELECT语句。应该试验联结、并、子查询等，找出最佳的方法。 使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。 一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快。 应该总是使用正确的数据类型。 决不要检索比需求还要多的数据。换言之，不要用SELECT *（除 非你真正需要每个列）。 有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果 使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。 在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT索引），然后在导入完成后再重建它们。 必须索引数据库表以改善数据检索的性能。确定索引什么不是一 件微不足道的任务，需要分析使用的SELECT语句以找出重复的 WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花 的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。 使用UNION来替代一条包含多个OR的SELECT语句可以显著改善性能。 LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。 数据库是不断变化的实体。一组优化良好的表一会儿后可能就面 目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。 最重要的规则就是，每条规则在某些条件下都会被打破。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"MySQL高级特征","slug":"MySQL高级特征","permalink":"http://yoursite.com/tags/MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E5%BE%81/"}]},{"title":"MySQL必知必会19-21-数据和表的操作","slug":"MySQL必知必会19-21-数据和表的操作","date":"2022-02-23T07:28:43.000Z","updated":"2022-02-24T08:59:32.590Z","comments":true,"path":"2022/02/23/MySQL必知必会19-21-数据和表的操作/","link":"","permalink":"http://yoursite.com/2022/02/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A19-21-%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"数据插入INSET可以用来插入数据，其可以用以下几种方式使用： 插入完整的行； 插入行的一部分； 插入多行； 插入某些查询的结果。 插入及系统安全机制：可针对每个表或 每个用户，利用MySQL的安全机制禁止使用INSET语句。 插入完整的行可以直接按照表中的字段顺序来使用INSERT插入数据。 例如表Customers的结果为： id name location birthday hobby 则可以通过下面的方式来插入数据： 1INSERT INTO Customers VALUES(NULL, 'mw', 'China', '1999-1-1', 'hike'); 但这种方式并不安全，因为其依赖于表中字段的顺序。还可以按照给出的字段顺序来插入数据： 1INSERT INTO Customers(id, name, location, birthday, hobby) VALUES(NULL, 'mw', 'China', '1999-1-1', 'hike'); 此例子完成与前一个INSERT语句完全相同的工作，但在表名后 的括号里明确地给出了列名。则其后VALUES中的数据就是与前面给出的顺序相同。 因为提供了列名，VALUES必须以其指定的次序匹配指定的列名，不 一定按各个列出现在实际表中的次序。其优点是，即使表的结构改变， 此INSERT语句仍然能正确工作。 总是使用列的列表 一般不要使用没有明确给出列的列表的 INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。 省略列：如果表的定义允许，则可以在INSERT操作中省略某 些列。省略的列必须满足以下某个条件。 该列定义为允许NULL值（无值或空值）。 在表定义中给出默认值。这表示如果不给出值，将使用默认值。 如果数据检索是最重要的（通常是这样），则你可以通过在 INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL 降低INSERT语句的优先级，如下所示：顺便说一下，这也适用于下一章介绍的UPDATE和DELETE语句。 插入多行INSERT也支持一条语句插入多条数据。 例如： 1234INSERT INTO Customers(id, name, location, birthday, hobby) VALUES(NULL, 'mw', 'China', '1999-1-1', 'hike'),(NULL, 'tom', 'America', '1999-1-1', 'basketball'),(NULL, 'jimmy', 'France', '1999-1-1', 'drink'); 其中单条INSERT语句有多组值，每组值用一对圆括号括起来， 用逗号分隔。 提高INSERT的性能 此技术可以提高数据库处理的性能，因 为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快。 插入检索的数据INSERT一般用来给表插入一个指定列值的行。但是，INSERT还存在 另一种形式，可以利用它将一条SELECT语句的结果插入表中。这就是所 谓的INSERT SELECT，顾名思义，它是由一条INSERT语句和一条SELECT语句组成的。 假如你想从另一表中合并客户列表到你的customers表。不需要每次 读取一行，然后再将它用INSERT插入，可以如下进行： 例如，将Customers中的数据插入到新的CustomersNew表中。 123INSERT INTO CustomersNew(id, name, location, birthday, hobby)SELECT id, name, location, birthday, hobbyFROM customers; 这个例子使用INSERT SELECT从中将customers所有数据导入 CustomersNew。 这条语句将插入多少行有赖于customers表中有多少行。 这个例子导入了cust_id（假设你能够确保cust_id的值不重复）。你 也可以简单地省略这列（从INSERT和SELECT中），这样MySQL就会生成新值。 INSERT SELECT中的列名：为简单起见，这个例子在INSERT和 SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。 事实上，MySQL甚至不关心SELECT返回的列名。它使用的是 列的位置，因此SELECT中的第一列（不管其列名）将用来填充 表列中指定的第一个列，第二列将用来填充表列中指定的第二 个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的。 INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据。 更新和删除数据为了更新数据，需要使用UPDATE语句，可以采用两种方式使用UPDATE： 更新表中特定行。 更新表中的所有的行。 确定要更新行的过滤条件。 更新单列例如：客户10005现在有了电子邮件地址，因此他的记录 需要更新，语句如下： 1UPDATE customers SET cust_email = 'elmer@fudd.com' WHERE cust_id = 10005; UPDATE语句总是以要更新的表的名字开始。在此例子中，要更新的 表的名字为customers。SET命令用来将新值赋给被更新的列。如这里所示，SET子句设置cust_email列为指定的值。 UPDATE语句以WHERE子句结束，它告诉MySQL更新哪一行。没有 WHERE子句，MySQL将会用这个电子邮件地址更新customers表中所有行，这不是我们所希望的。 更新多列更新多列时，需要在SET放置多个更新项，用逗号隔开。 1UPDATE customers SET cust_name = 'The Fudds', cust_email = 'elmer@fudd.com' WHERE cust_id = 10005; IGNORE关键字：如果用UPDATE语句更新多行，并且在更新这些 行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新可使用IGNORE关键字，如下所示：UPDATE IGNORE customers…。 删除某个值为了删除某一列的的值，可以设置它为NULL（假定表设定为允许NULL）。 如： 1UPDATE customers SET cust_email = NULL WHERE cust_id = 10005; 其中NULL用来去除cust_email列中的值。 删除数据可以通过DELETE关键值来删除数据。其有两种方式： 从表中删除特定的行。 从表中删除所有的行。 例如： 1：删除特定行 1DELETE FROM customers WHERE cust_id = 10006; DELETE FROM要求指定从中删除数据的表名。 WHERE子句过滤要删除的行。在这个例子中，只删除客户10006。 2：删除所有的行 1DELETE FROM customers; 即去掉WHERE限制条件。就会删除表中的所有数据。 更快的删除：如果想从表中删除所有行，不要使用DELETE。 可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更 快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。 更新和删除指导 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE 子句的UPDATE或DELETE语句。 保证每个表都有主键，尽可能 像WHERE子句那样使用它。 在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进 行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 使用强制实施引用完整性的数据库。 创建和操纵表这里仅讨论通过MySQL命令来创建和操作表，如果使用GUI工具会更加简单。 表的创建为利用CREATE TABLE创建表，必须给出下列信息： 新表的名字，在关键字CREATE TABLE之后给出； 表列的名字和定义，用逗号分隔。 CREATE TABLE语句也可能会包括其他关键字或选项，但至少要包括表的 名字和列的细节。 表创建基础例如，创建customers表： 12345678910111213CREATE TABLE customers(cust_id int NOT NULL AUTO_INCREMENT,cust_name char(50) NOT NULL,cust_address char(50) NULL,cust_city char(50) NULL,cust_state char(5) NULL,cust_zip char(10) NULL,cust_country char(50) NULL,cust_contact char(50) NULL,cust_emai1 char(255) NULL,PRIMARY KEY (cust_id)) ENGINE-InnoDB; 从上面的例子中可以看到，表名紧跟在CREATE TABLE关键字后 面。实际的表定义（所有列）括在圆括号之中。各列之间用逗号分隔。这个表由9列组成。每列的定义以列名（它在表中必须是唯一的）开始，后跟列的数据类型。表的主键可以在创建表时用 PRIMARY KEY关键字指定。这里，列cust_id指定作为主键列。整条语句由右圆括号后的分号结束。 处理现有的表 在创建新表时，指定的表名必须不存在，否则 将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删 除该表，然后再重建它，而不是简单地用创建表语句覆盖它。 使用NULL值允许NULL的字段，则允许在插入或更新的时候空缺其值或者赋予NULL值。 MySQL可以在指定字段时指定NULL或NOT NULL来确定允许空缺或不允许空缺。 使用AUTO_INCREMENT被AUTO_INCREMENT标记得的字段会在数据增加的时候自动增加（一般将其赋NULL，让其自增）。但是其有以下规范： `AUTO_INCREMENT·是数据列的一种属性，只适用于整数类型数据列。 设置AUTO_INCREMENT属性的数据列应该是一个正数序列，所以应该把该数据列声明为UNSIGNED，这样序列的编号个可增加一倍。 AUTO_INCREMENT数据列必须有唯一索引，以避免序号重复(即是主键或者主键的一部分)。 AUTO_INCREMENT数据列必须具备NOT NULL属性。 AUTO_INCREMENT数据列序号的最大值受该列的数据类型约束，如TINYINT数据列的最大编号是127,如加上UNSIGNED，则最大为255。一旦达到上限，AUTO_INCREMENT就会失效。 当进行全表删除时，MySQL AUTO_INCREMENT会从1重新开始编号。全表删除的意思是发出以下两条语句时： delete from table_name;或者truncate table table_name。 指定默认值如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。 其通过DEFAULT关键字来指定。 例如： 123456789CREATE TABLE orderitems( order_numint NOT NULL, order_item int NOT NULL , prod_idchar(10) NOT NULL, quantity intNOT NULL DEFAULT 1, item _price decima1(8,2) NOT NULL, PRIMARY KEY (order_num，order_item))ENGINE=InnoDB; quantity列包含订单中每项物品的数 量。在此例子中，给该列的描述添加文本DEFAULT 1指示MySQL，在未给出数量的情况下使用数量1。 引擎类型MySQL有一个具体管理和处理数据的内部引擎。 在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT 语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候，此引擎都隐藏在DBMS内，不需要过多关注它。 但MySQL与其他DBMS不一样，它具有多种引擎。它打包多个引擎， 这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT等命令。 当然，你完全可以忽略这些数据库引擎。如果省略ENGINE=语句，则 使用默认引擎。多数SQL语句都会默认使用它。但并 不是所有语句都默认使用它，这就是为什么ENGINE=语句很重要的原因。 下面是几个引擎： InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文 本搜索； MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘） 中，速度很快（特别适合于临时表）； MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章）， 但不支持事务处理。 更新表为更新表定义，可使用ALTER TABLE语句。但是，理想状态下，当表 中存储数据以后，该表就不应该再被更新。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。 为了使用ALTER TABLE更改表结构，必须给出下面的信息： 在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将 出错）； 所做更改的列表。 例如: 1：给表添加一个字段： 1ALTER TABLE vendors ADD vend_phone CHAR(20); 2：删除表的一个字段： 1ALTER TABLE DROP COLUMN vend_phone; 3：定义外键： 12345678910111213ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY (order_num) REFERENCES orders (order_num);ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id)REFERENCES products (prod_id);ALTER TABLE ordersADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id)REFERENCES customers (cust_id);ALTER TABLE productsADD CONSTRAINT fk_products_vendorsFOREIGN KEY (vend_id)REFERENCES vendors (vend_id); 这里，由于要更改4个不同的表，使用了4条ALTER TABLE语句。为了 对单个表进行多个更改，可以使用单条ALTER TABLE语句，每个更改用逗号分隔。 删除表使用DROP关键字来删除整个表。 例如： 1DROP TABLE customers; 这条语句删除customers表（假设它存在）。删除表没有确认， 也不能撤销，执行这条语句将永久删除该表。 重命名表使用RENAME TABLE关键字来对表进行重命名。 例如： 1RENAME TABLE customers TO customersNew; 还可以对表进行批量重命名： 123RENAME TABLE backup_customers To customers, backup_vendors To vendors, backup_products TO products;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"数据和表的操作","slug":"数据和表的操作","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"}]},{"title":"MySQL必知必会13-18-高级检索知识","slug":"MySQL必知必会13-18-高级检索知识","date":"2022-02-23T07:08:21.000Z","updated":"2022-02-23T07:09:17.412Z","comments":true,"path":"2022/02/23/MySQL必知必会13-18-高级检索知识/","link":"","permalink":"http://yoursite.com/2022/02/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A13-18-%E9%AB%98%E7%BA%A7%E6%A3%80%E7%B4%A2%E7%9F%A5%E8%AF%86/","excerpt":"","text":"分组数据分组数据可以用于按照某一列数据作为分类标准来统计数据。所以其一般与聚集函数一起用。 创建分组分组是使用SELECT子句和GROUP BY子句建立。 例如：统计每个vend_id的数据数量： 1SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id; 将语句分为两部分， SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id 可以看作是先统计了总数，然后将总数按照vend_id分类。其结果可能如下： vend_id num_prods 1001 3 1002 2 1003 7 因为使用了GROUP BY，就不必指定要计算和估值的每个组了。系统会自动完成。GROUP BY子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。 在具体使用GROUP BY子句前，需要知道一些重要的规定。 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更加细致的控制。 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总，换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能时聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。 如果分组列中具有NULL值，则NULL值将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 过滤分组分组过滤允许GROUP BY得出的分组进行过滤，规定得到哪些分组，排除哪些分组。 WHERE子句不能对其进行过滤，因为分组是针对行的，而不是针对分组的。事实上，WHERE没有分组的概念。 MySQL提供了HAVING子句，HAVING非常类似于WHERE。只不过WHERE过滤行，HAVING过滤分组。 HAVING和WHERE 实际上有关WHERE的所有这些技术和选项都适用于HAVING。它们的句法是相同的，只是关键字有差别。 另一种理解方式是WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。 基于上面一条，可以得：WHERE用于筛选数据表中的字段，而HAVING用于筛选前面确定的字段（临时表的一部分）。 分组过滤例子 单使用HAVING 1SELECT cust_id, COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2; 该语句增加了一个HAVING COUNT(*) &gt;= 2子句。所以其意义是按照cust_id分组然后筛选分组中总数COUNT(*)大于等于2的分组。 同时使用WHERE和HAVING 1SELECT vend_id, COUNT(*) AS num_prods FROM products WHERE prod_price &gt;= 10 GROUP BY vend_id HAVING COUNT(*) &gt; 2; 这里在前面加了WHERE prod_price &gt;= 10子句，如上所说，WHERE在分组统计之前进行计算，所以后面的统计中就不再包含prod_price &lt; 10的数据。然后将统计出的数据按照COUNT(*) &gt; 2进行分组过滤。 分组和排序GROUP BY和ORDERED BY子句的区别： OEDERED BY GROUP BY 排序产生的输出 分组行。但输出可能不是分组的顺序 任意行都可以使用（甚至非选择的列也可以使用） 只可能使用选择列或表达式列，而且必须使用每个选择列表达式 不一定需要 如果于聚集函数一起使用列（或表达式），则必须使用 GROUP BY和ORDERED BY可以一起使用，可以先将数据筛选出来，然后按某列数据（可能是聚集的那列数据）对筛选的数据进行排序。 例如： 1SELECT order_num, SUM(quantity * itenm_price) AS ordertotal FROM orderitems GROUP BY order_num HAVING SUM(quantity * itenm_price) &gt;= 50 ORDER BY ordertotal; SELECT子句顺序下表中从上到小是SELECT中子句的出现顺序。 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 使用子查询MySQL在4.1版本引入了子查询功能。 SELECT语句是单个SQL的查询。迄今为止我们看到的SELECT语句都是简单查询，即从单个数据表中检索数据的单条语句。 SQL还允许创建子查询，即嵌套在其他查询中的查询。 使用子查询进行过滤本书所有章中使用的数据库表都是关系表（关于每个表及关系的描述，请参阅附录B)。订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。 现在，假如需要列出订购物品TNT2的所有客户，应该怎样检索?下面列出具体的步骤。 (1)检索包含物品TNT2的所有订单的编号。 (2)检索具有前一步骤列出的订单编号的所有客户的ID。 (3)检索前一步骤返回的所有客户ID的客户信息。 上述每个步骤都可以单独作为一个查询来执行。可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。 SELECT order_num FROM orderitems WHERE prod_id = &#39;TNT2&#39; | order_num || ——— || 20005 || 20007 | SELECT cust_id FROM orders WHERE order_num IN (20005, 20007) | cust_id || ——- || 10001 || 10004 | SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001, 10004) | cust_name | cust_contact || ————– | ———— || Coyote Inc. | Y Lee || Yosemite Plcae | Y sam | 合并子句 合并子句1和子句2得到子句4 现在考虑合并第一个第二个子句。实际上就是将第二个子句中的数据用第一个子句来替换，并且用括号使之先进行计算。如下： 12SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2') | cust_id || ——- || 10001 || 10004 | 合并子句4和子句3 用同样的方法得到合并子句4和子句3： 1234SELECT cust_name, cust_contact FROM customers WHERE cust_id IN ( SELECT cust_id FROM orders WHERE order_num IN( SELECT order_num FROM orderitems WHERE prod_id = 'TNT2' )); 为了执行上面的语句，MySQL实际上必须执行3条SELECT语句。最里面返回订单号列表，此列表用于最外面的子查询的WHERE子句。次外面的子查询返回客户ID列表。此客户ID列表用于最外层查询的WHERE子句。最外层查询才返回所需的数据。 可见，在WHERE子句中使用子查询能够编写出功能强大并且很灵活的SQL语句。对于嵌套子查询的数目没有限制，不过在实际使用时由于性能的限制，最好不要嵌套太多的子查询。 注意：在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回当单个列并且与单个列匹配，但如果需要也可以使用多个列。 虽然子查询一般与IN操作符相结合，但也可以用于测试等于（=）、不等于（&lt;&gt;）等。 作为计算字段使用子查询使用子查询的另一方法是创建计算字段。假设需要显示customers表中的每个客户的订单总数。订单与相应的客户ID存储在orders表中。 为了执行整个操作，遵循下面的步骤： 从costumers表中检测客户列表。 对于检索出的每个客户，统计其在orders表中的订单数目。 同样写出如果分开查询的步骤： SELECT COUNT(*) AS orders FROM orders WHERE cust_id = 10001 | orders || —— || 2 | SELECT cust_name, cust_state FROM customers ORDER BY cust_name | cust_name | cust_status || ———– | ———– || Coyote Inc. | MI || E fudd | IL || Mouse House | IN | 合并子句现在将1，2合并，与上面不同，子句不作为筛选条件，而是一个计算属性。 1SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders FROM customers ORDER BY cust_name; cust_name cust_status oders Coyote Inc. MI 2 E fudd IL 1 Mouse House IN 0 注意这里的第三个属性是通过一个子查询得到的一个计算属性，注意这里子查询中的WHERE语句的条件，其会自动判断当前外层筛选出oders表中的行的cust_id，然后和customers表的cust_id进行比较。且必须加上限定名，如果不加上限定名，MySQL就会假设是将oders表中的cust_id进行自身匹配。 所以注意：虽然子查询在构造SELECT语句时极其有用，但必须注意限制有歧义性的列名。 技巧：对于子查询这种技术，可以嵌套很多层进行很强大的查询。但是为了在很多嵌套时其仍然保持正确，可以按照从内向外的调试技巧，即先从内部查询开始调试，一层层的增加，可以有效减少错误率。 联结表SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。 为什么要联结表分解数据为多个表能够有效地存储、更方便地处理，并且具有更加强大的可伸缩性。但是分解后数据也随之分解，为检索制造了很多麻烦。 而使用联结可以将多个表结合在一起。可以在一条SELECT语句中关联表。 创建联结联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。 例如： 1SELECT vend_name, prod_name, prod_price FROM vendors, products WHERE venders.vend_id = products.vend_id ORDER BY vend_name, prod_name; vend_name prod_name prod_price ACME Bird seed 10.00 ACME Carrots 2.50 ACME Detonator 13.00 这条语句的关键是WHERE子句，其指定了联立表的条件。 注意要匹配的两个列以venders.vend_id和products.vend_id来指定。这里需要这种完全限定名，因为如果只给出vend_id，则MySQL不知道指定的是两张表中的哪一个。 在列可能出现二义性的时候，必须使用完全限定名。如果引用一个没有用表名限定的具有二义性的列名，则MySQL经返回错误结果。 WHERE子句的重要性利用WHERE子句建立联结关系似乎有点奇怪，但实际上，有一个很充分的理由。请记住，在一条SELECT语句中联结几个表时，相应的关系是 在运行中构造的。在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。你必须自己做这件事情。在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管 它们逻辑上是否可以配在一起。 笛卡尔积：由没有联结条件的表返回的结果为笛卡尔积。检索出的行数将是第一个表中的行数乘以第二个表中的行数（即将第一张表中的所有数据与第二张表中所有数据进行组合，因为没有限定条件指定两张表中的哪些数据应该被指定）。 内部联结目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的 相等测试。这种联结也称为内部联结。其实，对于这种联结可以使用稍 微不同的语法来明确指定联结的类型。下面的SELECT语句返回与前面例子完全相同的数据： 12SELECT vend_name，prod_name，prod_price FROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id; 这种语法将联结条件通过ON关键词来指定，并且由INNER JOIN给出要联立的两张表。 联结多个表SQL对一条SELECT语句可以联结的表的数目没有限制。创建多张表联结的规则基本相同：首先列出所有的表，然后定义表的关系，例如： 1SELECT prod_name, vend_name, prod_price, quantity FROM orderitems, products, vendors WHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.pord_id AND order_num =20005; 此语句联立了3张表，orderitems、products和vendors。并且通过WHERE指定了两个联立条件和一个值限定条件。 性能考虑：MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常消耗资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。 考虑子查询中的例子： 1SELECT cust_name, cust_contact FROM customers WHERE cust_id IN ( SELECT cust_id FROM orders WHERE order_num IN( SELECT order_num FROM orderitems WHERE prod_id = 'TNT2' )); 此时就可以用联立表来进行查询，而不需要进行子查询，子查询消耗的性能往往比联立更高： 1SELECT cust_name, cust_contact FROM customers. orders, orderitems WHERE customers.cust_id = orders.cust_id AND orderitems.order_num = orders.order_num AND pord_id = 'TNT2'; 通过两个限定条件来联立三张表，然后通过一个值限定来确定返回的是要求的产品。 创建高级联结还有其他类型的表联结方式，也可以对被联结的表使用别名和聚集函数。 使用表别名SQL中不仅允许给列起别名，还允许给表取别名。这样做主要有以下两个理由： 缩短SQL语句。 允许在单挑SELECT语句中多次使用相同的表。 比如下面的语句使用别名来替代表名来缩短SQL语句： 1SELECT cust_name, cust_contact FROM customers AS c, orders AS o, orderitems AS oi WHERE c.cust_id = o.cust_id AND oi.order_num = o.order_num AND prod_id = 'TNT2'; 可以看到这里使用别名简化了后面的全限定名的写法。 使用不同类型的联结前面只看到了内部连接（等价联结）的简单联结。实际上一共有4中联结方式： 自联结 自然联结 内部连接 外部联结 自联结所谓子查询就是表自己和自己联立，一般是为了通过表中的某一个信息来查询该表中的其他信息。 假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。下面是通过子查询解决此问题的一种方法: 1SELECT pord_id, pord_name FROM products WHERE vend_id = (SELECT vend_id FROM products WHERE prod_id = 'DTNTR'); 同样，其可以用联结来重写子查询的语句。而这时我们是通过一张表得到的信息来查询这张表中的信息，此时就该使用自联结： 1SELECT p1.prod_id, p1.prod_name FROM products AS p1, products AS p2 WHERE p1.vend_id = p2.vend_id AND p2.prod_id = 'DTNTR'; 此查询中需要的两个表实际上是相同的表，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有二义性，因此MySQL不知道你引用的products表中的哪个实例。 为解决此问题，使用了表别名。products的第一次出现为别名p1，第二次出现为别名p2。现在可以将这些别名用作表名。例如，SELECT语句使用p1前缀明确地给出所需列的全名。如果不这样，MySQL将返回错误，因为分别存在两个名为prod_id、prod_name的列。MySQL不知道想要的是哪一个列（即使它们事实上是同一个列)。WHERE（通过匹配p1中的vend_id和p2中的vend_id）首先联结两个表，然后按第二个表中的prod_id过滤数据，返回所需的数据。 自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是 相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。 自然联结标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。 自然联结是这样一种联结，其中你只能选择那些唯一的列。这一 般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。下面举一个例子： 1234SELECT c.*, o.order_num，o.order_date,oi.prod_id，oi.quantity ，o1.item_priceFROM customers AS c,orders As o，orderitems As oilwHERE c.cust_id = o.cust_idAND oi.order_num = o.order_numANDprod_id = 'FB' ; 1、自然连接是特殊的内联结（等值联结），自然联结不能有where和on去限制筛选2、等值连接要求相等的分量，不一定是公共属性（即相同的列名）；而自然连接要求相等的公共属性（列名）。 外部联结联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。 下面的SELECT语句给出一个简单的内部联结。它检索所有客户及其 订单： 1SELECT customers.cust_id, orders.order_num FROM customers LEFT OUTER JOIN orders ON customer.cust_id = orders.cust_id; 类似于上一章中所看到的内部联结，这条SELECT语句使用了关 键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没 有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM 子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN，如下例所示： 1SELECT customers.cust_id, orders.order_num FROM customers RIGHT JOIN orders ON orders.cust_id = customers.cust_id; 外部联结的类型 存在两种基本的外部联结形式：左外部联结 和右外部联结。它们之间的唯一差别是所关联的表的顺序不同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中。 使用聚集函数聚集函数也可以用于联结表的聚集。 例如：如果要检索所有客户及每个客户所下的订单数，下面使用了COUNT()函数的代码可完成此工作： 1SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON costomers.cust_id = orders.cust_id GROUP BY customers.cust_id; 此SELECT语句使用INNER JOIN将customers和orders表互相关联。 GROUP BY子句按客户分组数据，因此，函数调用COUNT(orders.order_num)对每个客户的订单计数，将它作为num_ord返回。 使用联结的条件 注意使用联结的类型，根据不同情况选择内还是外。 应该提供联结条件，否则将返回笛卡尔积。 在一个联结中，可以包含多个表，并且不同的表也可以使用不同的联结方式，但是应该先单个测试，防止混乱出错。 组合查询MySQL允许执行多个查询操作（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常被称为并（union）或复合查询（compound query）。 有两种基本情况，其中需要使用组合查询： 在单个查询中从不同的表返回类似结构的数据。 对单个表执行多个查询，按单个查询返回数据。 组合查询和多个WHERE条件：多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出，在以下段落中可以看到这一点。 这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。 创建组合查询可用UNION操作符来组合数条SQL查询。 使用UNIONUNION的使用很简单。所需做的只是给出每条SELECT语句，在各条语句之间放上关键字UNION。 举一个例子，假如需要价格小于等于5的所有物品的一个列表，而且 还想包括供应商1001和1002生产的所有物品（不考虑价格）。当然，可以利用WHERE子句来完成此工作，不过这次我们将使用UNION。 语句1： 1SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5; vend_id prod_id prod_price 1003 FC 2.50 1002 FUI 3.42 1003 SLING 4.49 语句2： 1SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002); vend_id prod_id prod_price 1001 ANV01 5.99 1001 ANV02 9.99 1001 ANV03 14.99 组合查询现在将两条语句组合起来 123SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5UNIONSELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002); vend_id prod_id prod_price 1003 FC 2.50 1002 FUI 3.42 1003 SLING 4.49 1001 ANV01 5.99 1001 ANV02 9.99 1001 ANV03 14.99 WHERE方式前面提到，一般从同一个表中进行联合查询，也可以用WHERE来替代： 1SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5 AND vend_id IN (1001, 1002); vend_id prod_id prod_price 1003 FC 2.50 1002 FUI 3.42 1003 SLING 4.49 1001 ANV01 5.99 1001 ANV02 9.99 1001 ANV03 14.99 这两种方式获得的结果一致。 UNION规则 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关 键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。 UNION中的每个查询必须包含相同的列、表达式和聚集函数（不过各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以 隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。 如果遵守了这些基本规则或限制，则可以将并用于任何数据检索任务。 包含或取消重复的列UNION会从查询结果集中自动去除了重复的行（换句话说，它的行为与 单条SELECT语句中使用多个WHERE子句条件一样）。 这是UNION的默认行为，但是如果需要，可以改变它。事实上，如果 想返回所有匹配行，可使用UNION ALL而不是UNION。 例如: 123SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5UNION ALLSELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002); 此时就会将重复的行保存下来，不会被移除。 对组合查询结果进行排序SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只 能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY子句。 例如: 1234SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5UNIONSELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002)ORDER BY vend_id, prod_price; 这条UNION在最后一条SELECT语句后使用了ORDER BY子句。虽 然ORDER BY子句似乎只是最后一条SELECT语句的组成部分，但实际上MySQL将用它来排序所有SELECT语句返回的所有结果。 全文本搜索并非所有引擎都支持全文本搜索：MySQL 支持几种基本的数据库引擎。并非所有的引擎都支持本全文本搜索。两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。 前文介绍了LIKE关键词和正则表达式，都可以达到检索的目的。但是其有以下的问题： 性能：通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行 数不断增加，这些搜索可能非常耗时。 明确控制：使用通配符和正则表达式匹配，很难（而且并不总 是能）明确地控制匹配什么和不匹配什么。 智能化的结果：虽然基于通配符和正则表达式的搜索提供了非 常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。 所有这些限制以及更多的限制都可以用全文本搜索来解决。在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理 每个词。MySQL创建指定列中各词的一个索引，搜索可以针对这些词进 行。这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率，等等。 使用全文搜索使用全文搜索，包含以下两步： 索引要被搜索的列，而且要随着数据的改变不断地重新索引（MySQL自动完成）。 使用SELECT子句地Match()和Against()来进行全文搜索。 启用全文搜索支持启用全文搜索支持，需要在创建表地时候使用FULLTEXT子句来确定要被索引的列，如： 123456789CREATE TABLE productnotes( node_id int NOT NULL AUTO_INCREMENT, prod_id char(10) NOT NULL, note_date datetime NOT NULL, note_text text NULL, PRIMARY KEEY(note_id), FULLTEXT(note_text))ENGINE=MyISAM; 如上，FULLTEXT(note_text)，使用FULLTEXT指定了note_text为要被检索的列。 不要在导入数据时使用FULLTEXT： 更新索引要花时间，虽然 不是很多，但毕竟要花时间。如果正在导入数据到一个新表， 此时不应该启用FULLTEXT索引。应该首先导入所有数据，然 后再修改表，定义FULLTEXT。这样有助于更快地导入数据（而 且使索引数据的总时间小于在导入每行时分别进行索引所需的总时间） 进行全文搜索在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。 例如: 1SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit'); note_text Customer complaint: rabbit has been able to detect trap，foodapparently less effective now .Quantity varies，sold by the sack load. A11 guaranteed to bebright and orange，and suitable for use as rabbit bait. 此SELECT语句检索单个列note_text。由于WHERE子句，一个全 文本搜索被执行。Match(note_text)指示MySQL针对指定的列进行搜索，Against(&#39;rabbit&#39;)指定词rabbit作为搜索文本。由于有 两行包含词rabbit，这两个行被返回。 实际上刚才的搜索也可以使用LIKE关键字来解决： 1SELECT note_text FROM produscts WHERE note_text LIKE '%rabbit%'; note_text Quantity varies， sold by the sack load. A11 guaranteed to bebright and orange，and suitable for use as rabbit bait.Customer complaint: rabbit has been able to detect trap，foodapparently less effective now . 这条SELECT语句同样检索出两行，但次序不同（虽然并不总是这种情况）。 其原因在于全文搜索会将具有较高等级的行先返回。而LIKE则是按照数据库中的顺序来进行返回。 这里的优先级一般是目标词越靠前，目标词越多，优先级越高。 比较全文搜索的优点在于： 其按照优先级排序 检索速度更快 使用查询扩展查询扩展用来设法放宽所返回的全文本搜索结果的范围。考虑下面 的情况。你想找出所有提到anvils的注释。只有一个注释包含词anvils，但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。 这也是查询扩展的一项任务。在使用查询扩展时，MySQL对数据和 索引进行两遍扫描来完成搜索： 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有 行； 其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简 要地解释MySQL如何断定什么有用，什么无用）。 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件， 而且还使用所有有用的词。 例如，首先进行一个简单的全文本搜索，没有查询扩展： 1SELECT note_text FROM productsnotes WHERE Match(note_text) Aganinst(\"anvils\"); note_text Multiple customer returns，anvils failing to drop fast enough orfa1ling backwards on purchaser. Recommend that customer considersusing heavier anvils. 有一行包含词anvils，因此只返回一行。 现在使用查询扩展： 1SELECT note_text FROM productsnotes WHERE Match(note_text) Aganinst(\"anvils\" WITH QUERY EXPANSION); note_text Multiple customer returns，anvils failing to drop fast enough orfa1ling backwards on purchaser. Recommend that customer considersusing heavier anvils.Customer complaint: Sticks not individua1ly wrapped，too easy tomistakenly detonate all at once. Recommend individual wrapping.Customer complaint: Not heavy enough to generate flying starsaround headof victim. If being purchased for dropping，recommendANV02 or ANV03 instead Please note that no returns wil1 be accepted if safe opened usingexplosives .Customer complaint: rabbit has been able to detect trap，foodapparently less effective now .Customer complaint: Circular hole in safe floor can apparently beeasily cut with handsaw.Matches not included，recommend purchase of matches or detonator(item DTNTR) . 这次返回了7行。第一行包含词anvils，因此等级最高。第二行与anvils无关，但因为它包含第一行中的两个词（customer和recommend），所以也被检索出来。第3行也包含这两个相同的词，但它 们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名）。 布尔文本搜索MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean 170mode）。以布尔方式，可以提供关于如下内容的细节： 要匹配的词 拍排斥的词（如果某行包含这个词，则不返回改行，即使它包含其他指定的词也是如此） 排列提示 表达式分组 其他内容 即使没有FULLTEXT索引也可以使用 布尔方式不同于迄今为 止使用的全文本搜索语法的地方在于，即使没有定义 FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。 例1：检索包含heavy的句。 12SELECT note_textFROMproductnoteswHERE Match(note_text) Against( 'heavy' IN BOOLEAN MODE); note_text Item is extremely heavy. Designed for dropping，not recommendedfor use with slings，ropes，pulleys， or tightropes.Customer complaint: Not heavy enough to generate flying starsaround head of victim. If being purchased for dropping，recommendANV02 or ANV03 instead. 此全文本搜索检索包含词heavy的所有行（有两行）。其中使用 了关键字IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同。 例2：检索包含heavy但不包含任何以rope开头的行： 1SELECT note_text FROM productsnotes WHERE Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE); note_text Customer complaint: Not heavy enough to generate flying stars around head of victim. If being purchased for dropping，recommend ANVO2 or ANV03 instead. 这次只返回一行。这一次仍然匹配词heavy，但-rope*明确地 指示MySQL排除包含rope*（任何以rope开始的词，包括ropes）的行，这就是为什么上一个例子中的第一行被排除的原因。 下面是所有的全文布尔操作符 布尔操作符 说明 + 包含，词必须存在 - 排除，词必须不出现 &gt; 包含，而且增加等级值 &lt; 包含，且减少等级值 () 把词组成子表达式（允许这些表达式作为一个组被包含、排除、排列等） ~ 取消一个词的排序值 * 词尾的通配符 “” 定义一个短语（与单个词的列表不一样，它匹配整个短语以便排除整个短语） 例如 1：搜索包含词rabbit和bait的行。 1SELECT note_text FROM productnotes WHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE); 2：搜索匹配包含rabbit和bait中的至少一 个词的行。 1SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE); 3：搜索匹配短语rabbit bait而不是匹配两个词rabbit和 bait。 1SELECT note_text FROM productnotes WHERE Match(note_text) Against('\"rabbit bait\"' IN BOOLEAN MODE); 4：匹配rabbit和carrot，增加前者的等级，降低后者的等级。 1SELECT note_text FROM productnotes WHERE Match(note_text) Against('&gt;rabbit &lt;bait' IN BOOLEAN MODE); 全文搜索的使用说明 在索引全文本数据时，短词被忽略且从索引中排除。短词定义为 那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。 MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参 阅MySQL文档以了解如何完成此工作）。 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。 因此，MySQL规定了一条50%规则，如果一个词出现在50%以上 的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEANMODE。 如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词 或者不出现，或者至少出现在50%的行中）。 忽略词中的单引号。例如，don’t索引为dont。 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文 本搜索结果。 如前所述，仅在MyISAM数据库引擎中支持全文本搜索。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"高级检索知识","slug":"高级检索知识","permalink":"http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%A3%80%E7%B4%A2%E7%9F%A5%E8%AF%86/"}]},{"title":"MySQL必知必会1-12-基础知识","slug":"MySQL必知必会1-12-基础知识","date":"2022-02-20T05:38:59.000Z","updated":"2022-02-23T07:08:51.010Z","comments":true,"path":"2022/02/20/MySQL必知必会1-12-基础知识/","link":"","permalink":"http://yoursite.com/2022/02/20/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A1-12-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"数据库基础主键主键每一行都应该可以唯一标识自己的一列。没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行。 表中的任意行都可以作为主键，只要它满足以下条件： 任意两行不具有相同的主键值。 每个行都必须具有一个主键（主键不允许为NULL）。 主键通常是定义在表的一个列中，但并不是只能一列，也可以多个列一起使用作为主键。当使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须时唯一的（但单个列的值可以不唯一）。 主键的好习惯： 不更新主键列中的值。 不重用主键列中的值。 不再主键列中使用可能会更改的值。 MySQLMySQL是一种DBMS，即它是一种数据库软件。 数据库分类DBMS可分为两类： 基于共享文件系统的DBMS 基于客户机-服务器的DBMS 客户机是与用户打交道的软件。 服务器部分是负责所有数据访问和处理的一个软件。 数据库命令USE命令USE可以用于选择数据库。 例如选择数据库HRDB 1USE HRDB; SHOW命令SHOW命令可以用来展示数据，例如表、服务器状态，用户等。 例如： 展示表-applicant2022 1SHOW applicant2022; 展示服务器状态 1SHOW STATUS; 展示创建的数据库 12SHOW CREATE DATABASE;SHOW CREATE TABLE; 检索数据SELECT from 语句可以用来检索数据。 其基本结构为 SELECT col1, col2, ..., coln from table 例如： 从表products中选择一列prod_name 1SELECT prod_name FROM products; 从表products中选择两列prod_name, prod_price 1SELECT prod_name, prod_price from products; 从表products中检索所有的列可以通过通配符*来匹配所有列 1SELECT * FROM products 检索不同的列上面返回数据的列是包含重复元素的。而可以使用DISTINCT关键词来去掉列中的重复值。 例如： 1SELECT DISTINCT vend_id FROM products; 注意：DISTINCT关键词会应用于所有列而不仅前置它的列。例如SELECT vend_id, prod_price from products，除非两个列都不同，否则所有的列都将被检索出来。 限制结果SEELCT语句返回匹配的所有行，而LIMIT关键词可以指定返回的行数。 例如：从products中选择products的前5行。 1SELECT prod_name FROM products LIMIT 5; 也可以指定返回行数的位置。其格式有以下两种： LIMIT start, count:包含start，第一列为0。 LIMIT start OFFSET count:与上面代码意义一样。 例如：从products中选择products的从第3列开始的前5行。 12SELECT prod_name FROM products LIMIT 3, 5;SELECT prod_name FROM products LIMIT 3 OFFSET 5; 使用完全限定的表明所谓的完全限定名，对于字段来说就是表名+列名，而对于表名来说就是数据库+表名。 例如： 1SELECT products.prod_name FROM HRDB.products; 排序检索数据可以使用ORDER BY子句，来对筛选出的数据进行排序。 单例排序简单按照一列排序。 例： 1SELECT prod_name FROM products ORDER BY prod_name; 多列排序有时需要按照多列排序，即第一列相同，则按照第二列来排序。 例如： 1SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price, prod_name; 指定排序方向默认排序的方向为升序（关键词为ASC），而可以使用DESC来指定为降序。 例如： 升序 12SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price;SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price ASC; //前后等价 降序 1SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price DESC; 过滤数据WHERE语句可以用来指定过滤的条件。WHERE后接条件相等，不等，大于或小于等。 普通筛选从products表中选出prod_price等于2.5的列。 1SELECT prod_name, prod_price FROM products WHERE prod_price = 2.50; 注意：在同hi使用ORDER BY语句和WHERE时，应该让ORDER BY语句位于WHERE之后。 下面是WHERE子句操作符 检查单个值可以使用=来检查单个值： 1SELECT prod_name, prod_price FROM products WHERE prod_name = 'fuses'; 注意MySQL来执行匹配的时默认不区分大小写。 不匹配检查可以使用&lt;&gt;来进行不等于匹配。 1SELECT vend_id, prod_name FROM products WHERE vend_id &lt;&gt; 1003; 范围检查为了检查某个列的范围可以用BETWEEN关键词。 例如检索价格在5-10美元之间的商品： 1SELECT prod_name, prod_price FROM products WHERE prod_price BETWEEN 5 AND 10; 注意：两个值必须用AND关键词分隔。 BETWEEN匹配范围内的所有的值，包括开始值和结束值。 空值判断对于NULL的判断，有一个特殊的子句-IS NULL。 例如： 1SELECT prod_name FROM products WHERE prod_price IS NULL; 数据过滤组合WHERE子句MySQL允许给出多个WHERE子句。这些子句有两种组合方式： AND关键词：并，都要满足，优先级最高。 OR关键词：或，只满足一个即可。 AND子句例如： 1SELECT prod_id,prod_price,prod_name FROM products WHERE vend_id = 1003 AND prod_price &lt;= 10; 该语句表示，既要vend_id等于1003，又要prod_price小于等于10. OR子句例如： 1SELECT prod_id,prod_price,prod_name FROM products WHERE vend_id = 1003 OR prod_price &lt;= 10; 计算次序WHERE可以包含任意数目的AND和OR操作符。并允许两者以任意的顺序结合来进行组合为更加复杂的过滤句子。但是注意AND有更高的优先级。如果想要改变，则需要括号()。 例如： 12SELECT prod_name，prod_price FROM productsWHERE vend_id = 1002 OR vend_id = 1003 AND prod_price &gt;= 10; 所实际的顺序是先计算后面的AND，再计算前面的OR。 如果要改变顺序，可以通过一下格式： 12SELECT prod_name，prod_price FROM productsWHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10; IN操作符圆括号在WHERE子句中还有另一种用法。IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN合法值为由逗号分隔的多个值。 例如：取vend_id的值在1002,1003,1004中的任意一个： 12SELECT prod_name，prod_price FROM productsWHERE vend_id IN (1002,1003,1004) ORDER BY prod_name; 使用IN操作符的优点为： 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。 在使用IN时，计算的次序更容易管理。 IN操作符一般比OR操作符清单执行更快。 IN操作符的最大优点是可以包含其他SELECT语句，使得能够动态地建立WHERE语句。 NOT操作符WHERE子句中地NOT操作符有且只有一个功能，那就是否定它之后所跟地任意条件。 例如vend_id不在1002,1003,1004之中： 123SELECT prod_name，prod_priceFROM productsWHERE vend_id NOT IN (1002,1003,1004)ORDER BY prod_name; 注意： MySQL中地NOT支持对IN、BETWEEN和EXISTS子句进行取反。 用通配符进行过滤LIKE操作符LIKE操作符用于与后面的搜索模式组合进行过滤。 百分号（%）通配符%表示任何字符出现任意次数（0-∞）。 例如：匹配prod_name为以jet开头地所有内容： 12SELECT prod_id，prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 注意：根据MySQL地配置方式，搜索可以是区分大小写的。如果区分大小写jet%与Jetpack 1000将不匹配。 注意通配符可以出现在字段的任意位置，例如： 12SELECT prod_id，prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 表示任意内容，只要包含anvil就可以匹配到。如1anvil、anval1q、qanval0`。 下划线（_）通配符另一个通配符（_）只匹配单个字符。 如： 12SELECT prod_id，prod_nameFROM productsWHERE prod_name LIKE '_ ton anvi7'; 只匹配第一开头包含一个单词，后面为ton anvi7的单词。如1 ton anvi7，q ton anvi7等。 使用通配符的技巧使用通配符应当记住以下技巧： 不要过度使用通配符。其它操作符能够达到相同效果的目的，应该使用其他操作符。 在确定需要使用通配符时，除非绝对必要，否则不要把它们放在搜索模式的开始处。因为这会使检索速度慢很多。 用正则表达式进行搜索由于前面的通配符能实现的通配模式有限，所以引入了正则表达式来进行匹配。 其基本语句是REGEXP关键词。其后接的字符串即为正则表达式。 例如表示name为1000的列： 1SELECT * FROM table1 WHERE name REGEXP '1000'; 进行OR匹配可以通过|来间隔两个串，并且匹配这来给你个串中的一个。 例如：匹配prod_name为1000或2000： 12SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000 | 2000'ORDER BY prod_name; 可以给出两个以上的OR条件，用于匹配多个可能的情况。 匹配多字符中的一个可以通过[xyz]来匹配z, y, z中的任意一个字母。 例如： 12SELECT prod_nameFROM productsWHERE prod_name REGEXP '[123] Ton' ORDER BY prod_name; 匹配1tom、2tom或者3tom。 匹配范围可以结合[]和-来表示范围。如，[a-z]来匹配a到z的任意一个字母；[1-10]来匹配1到10的任意一个数字。 例如：匹配1 Ton到5 Ton： 12SELECT prod_nameFROM productsWHERE prod_name REGEXP '[1-5] Ton' ORDER BY prod_name ; 而为了方便，MySQL定义了特定范围的串。具体如下表： 匹配特殊字符对于MySQL定义的正则表达式特殊字符，如%, _等，可以通过转义来进行。 如：\\\\.匹配.，\\\\%匹配%。具体如下表。 匹配出现次数有时候需要匹配的模式出现多次，则需要量词。两次直接跟在模式的后面。如a{5}匹配aaaaa，a出现5次。而所有的两次如下： 例如：匹配id为一个或多个1的值： 1SELECT * FROM table1 WHERE id REGEX '1+'; 定位符没有定位词时，正则表达式总是匹配所有的内容，而通过定位符可以匹配开头或者结尾。具体所有的定位符如下： 例如匹配数字开头的id： 1SELECT * FROM table1 WHERE id REGEX '^[0-9]'; 创建计算字段计算字段可以重新组合、计算原有表中的数据。 拼接字段利用Concat(..args)函数可以用来拼接字段。这其中参数不仅可以是表中字段，也可以是自定义字符，其间用逗号,分割。 例如：其中有表的字段vend_name、vend_country，也有(、)： 12SELECT Concat(vend_name，' ( ', vend_country，')')FROM vendorsORDER BY vend_name ; 别名刚才创建的新字段实际上是没有名字的，而需要给他给一个名字，即别名（不止新字段可以指定别名，存在于表中的字段也可以指定别名）。其采用关键字AS来指定。 如：给新字段指定了别名vend_title 123SELECT Concat(RTrim(vend_name)，'('，RTrim(vend_country)，')') AS vend_titleFROM vendorsORDER BY vend_name; 执行算术计算不仅可以用Concat(...)来拼接字段，还可以使用算数运算符来获得新的数字字段。 例如：利用乘法计算新字段 12345SELECT prod_id，quantity,item_price，quantity*item_price As expanded_priceFROM orderitemsWHERE order_num = 20005; 下面是具体所有的操作符： 使用数据处理函数MySQL包含了很多处理函数。 文本处理函数字符处理函数包含以下： 其中Soundex()是读音类似的一个处理函数。这个一般是用于英语。 日期和时间处理函数对于日期和时间，MySQL也内置了一些函数。所有的函数如下： 值得注意的是：无论什么时候指定一个日期，不管插入或更新表值还是用WHERE语句进行过滤，日期必须为格式yyyy-mm-dd。 因此，基本的日期比较简单： 12SELECT cust_id，order_numFROM ordersWHERE order_date = '2005-09-01'; 利用Datr()函数可以创建一个日期时间的日期部分。如一个值dt在表中为一个DateTime类型，假设其为2022-02-02 08:08:08。则Date(dt)就为2022-02-02 而日期之间可以用BETWEEN AND来筛选确定日期范围内的列。 如：筛选生日在2001年2月1日到2002年2月4日之间的列： 1SELECT * FROM table1 WHERE birthday BETWEEN '2001-2-1' AND '2002-2-4' 数字处理函数下面是所有的处理函数： 汇总数据又是仅仅需要获得数据的一些汇总，而并不是数据本身，如数量等。 MySQL也涉及相关的函数，具体如下： 汇聚不同值对于所有的聚集函数，可以指定两个参数来表示计算的值： ALL（默认）：所有的值都将被计算。 DISTINCT：只计算不同的值。 例如：表示统计不同name的所有列： 1SELECT COUNT(DISTINCT name) FROM table1; 多个汇集函数汇集函数就可以多个同时使用。 如：同时使用了4个汇聚函数： 123SELECT COUNT(*) AS num_items,MIN(prod_price) As price_min,MAX(prod_price) AS price_max,AVG(prod_price) As price_avgFROM products; 组合汇聚函数还可以嵌套组合汇聚函数： 1SELECT AVG(COUNT(car1), COUNT(car2), COUNT(car3), COUNT(car4)) FROM sales; 汇聚函数可以嵌套组合，如上，先统计每种车类型的数量，然后统计其平均数（虽然一般不会这些设计表，只是示例用法）。 使用别名可以更清晰一些。 如： 1SELECT COUNT(car1) AS c1, COUNT(car2) AS c2, COUNT(car3) AS c3, COUNT(car4) AS c4, AVG(c1, c2, c3, c4) AS carAvg FROM sales;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"java核心技术-II-9-Java平台模块系统","slug":"java核心技术-II-9-Java平台模块系统","date":"2022-02-18T05:08:24.000Z","updated":"2022-02-18T09:14:00.586Z","comments":true,"path":"2022/02/18/java核心技术-II-9-Java平台模块系统/","link":"","permalink":"http://yoursite.com/2022/02/18/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-9-Java%E5%B9%B3%E5%8F%B0%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"模块的概念在Java系统中，提供了多种封装的层级。 在面向对象编程中，基础的构建要素就是类。类提供了封装，私有特征只能被具有明确访问权限的代码访问。 包提供了更高一级的组织方式，包是类的集合。包也提供了一种封装级别，具有包访问权限的所有特征（无论是公有还是私有）都只能被同一个包中的方法访问。 但是在大型系统中，这些控制级别还是显得不够，所以设计了模块的概念。 一般来说，一个Java平台模块包含以下部分： 一个包集合。 可选地包含资源文件和像本地库这样的其他文件。 一个有关模块中可访问的包的列表。 一个有关这个模块依赖的所有其他模块的列表。 对模块命名模块是包的集合。模块中的包名无需彼此相关。并且模块名和包名是可以完全相同的。 模块名是由字母、数字、下划线和句点构成的。而且，和路径名一样，模块之间没有任何层次关系。如priv.mw与priv.mw.dao是完全不同的两个模块。 一般来说模块的名字与包名类似，都遵循“反向域名”惯例，就像和包名一样。命名模块最简单的方式就是按照模块提供的顶级包来命名。这个惯例可以防止模块中产生报名冲突，因为任何给定的模块都只能被放到一个模块中。 一个例子：模块化的”Hello World!”程序我们要将一个普通程序改为模块化，可以按照以下步骤： 类必须放置在一个具名的包中（不具名包是不能包含在模块中的），代码如下： 1234567package priv.mw.hello;public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(\"Hello world!\"); &#125;&#125; 创建一个module-info.java模块声明文件，用于存储模块的信息。该文件位于基目录中（即，与包含com目录的目录相同）。按照惯例，基目录的名字与模块名相同，目录结构如下： 123456mymudule.hellomod/ module-info.java priv/ mw/ hello/ HelloWorld.java module-info.java文件包含模块声明： 123module mymudule.hellomod&#123; &#125; 这个模块声明之所以为空，是因为该模块没有任何可以向其他人提供的内容，也不需要依赖任何其他模块。 module-info.java这个文件与一般的Java资源文件不同。从名字上也能看出来。因为类名不能包含连字符。在该文件中，用require和exports等”限定关键词（仅在模块声明中具有特殊意义）“来确定导入和导出的关键词。 对模块的需求 在Java9之后，jdk就被模块化了，其被分成了多个模块。每个模块都有一个module-info.java用于确定导入导出的模块。由于java.base包含的是Java最基础的类，所以这个模块是默认加载的，而其他的一些类别，如前面提到的ScriptEngineManager都需要自己在module-info.java文件中自己导入。 而模块中的还可能会依赖其他的模块，就会形成一个依赖链。例如下面的依赖链： 注意在模块依赖中不能有环，即，一个模块不能直接或间接地对自己产生依赖。 导出/导入包到处包在模块系统中，可以在module-info.java使用关键字export来指定导出的模块。例如，下面是java.xml模块地模块声明中地一部分： 12345678module java.xml&#123; exports javax.xml; export javax.xml.dataType; export javax.xml.namespace; export javax.xml.parsers; ...&#125; 值得注意的是： 只有导出了的类才能被外部使用，也就是说可以隐藏内部地部分类。 导入包同样地，可以使用requires关键字来导入需要使用的模块。例如： 12345module priv.mw&#123; requires java.scripting; requires java.desktop;&#125; 注意exports到处的是包，而requires引用的是模块。 模块化的JAR模块可以通过将其所有的类都置于一个JAR文件中而得已部署，其中module-info.class在JAR文件的根部。这样的JAR文件被称为模块的JAR。 要想创建JAR文件，只需要以通常的方式使用jar工具。如果有多个包，那么最好使用-d选项来编译，这样可以将类文件置于单独的目录中，如果目录不存在，那么会创建该目录。然后，在收集这些类文件时使用-C选项的jar命令来修改该目录。 例如： 12javac -d modules/com.horstman.greet $(find com.horstman.greet -name *.java)jar -cvf com.horstman.greet.jar -C modules/com.horstman.greet . 如果使用Maven, Gradle这样的构建工具，那么只需要按照管用的方式来构建jar。只要module-info.class包含在内，就可以得到该模块的JAR文件。 然后，在模块路径中包含该模块化的JAR，该模块就会被加载。 也可以指定模块化的JAR中的主类： 12javac -p com.horstman.greet.jar -d modules/v2ch09.exportedpkg $(find v2ch09.exportedpkg -name *.java)jar -c -v -f v2ch09.exportedpkg.jar -e com.horstman.hello.hello.HelloWorld -C modules/v2ch09.exportedpkg . 当启动该程序时，可以指定包含主类的模块： 1java -o com.horstman.greet.jar:v2ch09.exportedpkg.jar -m v2ch09.exportedpkg 模块和反射式访问对于类，可以通过反射来克服其权限问题，但是在模块中，则不能再这样吧访问了。即：如果一个类位于某个模块中，那么非公有成员的反射式访问将失败。 理论上来讲，这种破坏封装的特性是不合理的，但是由于长期的存在和使用，Java为其设计了open关键字。只要将某个模块的导出设定为open，则其内部的变量都是可以通过反射来访问的，无论是公开还是私有。也可以单独确定模块中的某个包为开放的。例如： 模块开放 123open module xxx&#123; ...&#125; 模块中的包开放 123module xxx&#123; opens yyy;&#125; 值得注意的是：模块采用的是open，而包采用的opens关键字。 自动模块和不具名模块为了过度（即Java9之前的应用都是没有模块系统的），Java设计了两个机制来缓解模块化前后的不兼容： 自动化模块 不具名模块 自动模块如果是为了迁移，我们可以通过把任何JAR文件置于模块路径的目录而不是类路径的目录中，实现将其转换为一个模块。模块路径上没有module-info.class文件的JAR被称为自动模块。自动模块具有下面的属性: 模块隐式的包含对其他所有模块的requires子句。 其所有包都被导出，且是开放的（open）。 如果在JAR清单META-INF/MANIFEST.MF中具有键为Automatic-Module-Name的项，那么它的值会变为模块名。 否则，模块名将从JAR文件名中获得，具体为：将文件名中尾部的版本号删除，并将非字母数字的字符替换为句点。 前两条规则表明自动模块中的包的行为和在类路径上一样。使用模块路径的原因是为u了让其他模块受益，使得它们可以表示对这个模块的依赖关系。 不具名模块任何不在模块路径中的类都是不具名模块的一部分。从技术上讲，可能会有多个不具名模块，但是它们合起来看就像是单个不具名的模块。与自动模块一样，不具名模块可以访问所有其他的模块，它的所有包都会被导出，并且都是开放的。 但是，没有任何明确模块可以访问不具名的模块。（明确模块是既不是自动模块也不是不具名模块，即，module-info.java在模块路径上的模块。） 传递需求和静态的需求传递需求前面提到，模块的需求是不会传递的，即A需要B，B需要C，则A并不会直接需要C。但是有时候这种需求又是存在的，比如一些列的包都是需要底层的一个包，可以使用requires transitive来满这个需求。 例如，JavaFX用户界面元素的javafx.controls模块。javafx.controls模块需要javafx.base模块，因此每个使用javafx.controls的程序都需要javafx.base模块。因此javafx.controls模块声明需要使用transitive修饰符： 1234module javafx.controls&#123; requires transitive javafx.base;&#125; 任何声明需要javafx.controls的模块现在都自动需要javafx.base。 requires transitive语句的一种很有吸引力的用法是聚集模块，即导入一个模块，自动导入可能需要的所有模块，无需再手动导入。 java.se模块就是这样的模块，它被声明为下面的样子： 1234567891011module java.se&#123; requires transitive java.compiler; requires transitive java.datatransfer; requires transitive java.desktop; ...; requires transitive java.sql; requires transitive java.sql.rowset; requires transitive java.xml; requires transitive java.xml.crypto;&#125; 对细颗粒度模块依赖不感兴趣的程序员可以直接声明需要java.se，然后获取Java SE平台的所有模块。 静态需求requires static声明了一种需求，它声明一个模块必须再编译时出现，而在运行时是可选的。下面是两个用例： 当问再编译时进行处理的注解，而该注解是在不同的模块中声明的。 对于位于不同模块中的类，如果它可用，就是用它，否则就执行其他操作。例如： 123456try&#123; new oracle.jdbc.driver.OracleDriver(); ...;&#125;catch(NoClassDefFoundError err)&#123; Do something else;&#125; 限定导出和开放exports和open有一种变体用于将模块导出或开放给指定的模块，而不是所有的模块都可以访问。 格式如下： exports ... to ... opens ... to ... 如： 限定导出exports ... to ... 1exports com.sun.java.javafx.collections to javafx.controls, javafx.graphics, javafx.fxml, javafx.swing; 则com.sun.java.javafx.collections包只能被javafx.controls, javafx.graphics, javafx.fxml, javafx.swing访问。 限定开放opens ... to ... 12345module priv.mw&#123; requires com.xxx.yyy; opens priv.mw.utils to priv.jack;&#125; 则priv.mw.utils就只对priv.jack模块开放。 服务加载ServiceLoader类提供了一种轻量级机制，用于将服务接口与现实匹配起来。下面是对服务加载的一个快速回顾。服务拥有一个接口和多个可能的接口。下面是一个简单的接口示例： 1234public interface GreeterService&#123; String greet(String subject); Locale getLocale();&#125; 有一个或多个模块提供了实现，例如： 1234public class FrenchGreeter implements GreeterService&#123; public String greet(String subject)&#123;return \"Bonjour \" + subject;&#125; public Locale getLocale()&#123;return Locale.FRENCH;&#125;&#125; 服务消费者必须基于其认为合适的标准在提供的所有实现中选择一个： 1234567ServiceLoader&lt;GreeterService&gt; greeterLoader = ServiceLoader.load(GreeterService.class);GreeterService chosenGreeter;for(GreeterService greeter : greeterLoader)&#123; if(...)&#123; chosenGreeter = greeter; &#125;&#125; 在过去，实现是通过将文本放置到包含实现类的JAR文件的META-INF/services目录中而提供给服务消费者。模块系统提供了一种更好的方式，与提供文本不同，可以添加语句刀到模块描述符中。 提供服务服务提供者可以使用provides...with...关键字，他列出了服务接口（可能定义在任何模块中），以及实现类（必须是该模块的一部分）。下面是jdk.security.auth模块的一个例子： 1234567891011module jdk.security.auth&#123; ...; provides javax.security.auth.spi.LoginModule with com. sun . security.auth.module.Krb5LoginModule, com. sun . security.auth.module.UnixLoginModule, com . sun . security.auth.module.JndiLoginModule, com . sun. security.auth.module.KeyStoreLoginModule, com. sun . security.auth.module.LdapLoginModule, com. sun . security.auth.module.NTLoginModule;&#125; 这与META-INF/service问价等价。 消费服务服务使用者需要使用uses关键词来使用服务，如： 12345module java.base&#123; ...; uses javax.security.auth.api.LoginModule;&#125; 当消费模块中的代码调用ServiceLoader.load(ServiceInterface.class)时，匹配的提供者类将被加载。 例如：将上面的GreeterService提供了不地区的实现。 实现： 12345678moudle com.horstman.greetsvc&#123; export com.horstman.greetsvc; provides com.hosrtman.greetsvc.GreeterService with com.hosrtman.greetsvc.internal.FrechGreeter, com.hosrtman.greetsvc.internal.GermanGreeter,&#125; 消费模块声明消费该模块： 1234module priv.mw &#123; uses com.hosrtman.greetsvc.GreeterService;&#125; 调用： 123456789101112131415161718package priv.mw;import java.util.*;import com.hosrtman.greetsvc.*;public class void main(String[] args)&#123; ServiceLoader&lt;GreeterService&gt; greeterLoader = ServiceLoader.load(GreeterService.class); String desiredlanguage = args.length &gt; 0 ? args[0] : \"de\"; GreeterService chosenGreeter = null; for(GreeterService greeter : greeterLoader)&#123; if(greeter.getLocale().getLanguage().equals(desiredlanguage)) chosenGreeter = greeter; &#125; if(greeter == null)&#123; System.out.println(\"No suitable greeter.\"); &#125;else&#123; System.out.printlm(chosenGreeter.greet(\"Modular world\")); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"[object Object]","slug":"object-Object","permalink":"http://yoursite.com/tags/object-Object/"}]},{"title":"java核心技术-II-8-脚本、编译和注解处理","slug":"java核心技术-II-8-脚本、编译和注解处理","date":"2022-02-17T05:16:48.000Z","updated":"2022-02-17T16:09:40.376Z","comments":true,"path":"2022/02/17/java核心技术-II-8-脚本、编译和注解处理/","link":"","permalink":"http://yoursite.com/2022/02/17/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-8-%E8%84%9A%E6%9C%AC%E3%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86/","excerpt":"","text":"Java平台的脚本机制Java平台的脚本API可以使之运行诸如JavaScript和Groovy这样的脚本语言代码。 脚本语言是一种在运行时解释程序文本，从而避免了编译、链接等步骤。其具有以下优势： 便于快速变更，鼓励不断实验。 可以修改运行着的程序的行为。 支持程序用户的定制化。 获取脚本引擎脚本引擎是一个可以执行特定语言编写的脚本的类库。当虚拟机启动的时候，它会发现可以用的脚本引擎。为了枚举这些引擎，需要构造一个ScriptEngineManager，并调用getEngineFactories方法。可以向每个引擎工厂询问它们所支持的引擎名、MIME类型和文件扩展名。 下表显示对应的典型值的表格。 引擎 名字 MIME类型 文件扩展 Nashorm（包含在JDK中，从jdk6开始，jdk11开始标记将要移除，jdk17已移除） narsh，Nashorn，js，JS，JavaScript，javascript，ECMAScript，ecmascript application/javascript, application/ecmascript, text/javascript, text/ecmascript js Groovy groovy 无 groovy Renjin Renjin text/x-R R, r, S, s 通常，你可以所需要的引擎，因此可以直接通过名字、MIME类型或文件扩展来请求它。 12ScriptEngineManager manager = new ScriptEngineManager();ScriptEngine engine = manager.getEngineByName(\"nashron\"); Java8引入了Nashorn，这是由Oracle开发的一个JavaScript解释器。可以通过在类路径中提供必要的JAR文件来添加更多语言的支持。 脚本计算和绑定执行脚本可以分别从字符串或者文件中执行脚本。 从字符串执行脚本1Object result = engine.eval(scriptString); 从文件执行脚本首先要从文件中获得一个Reader。 1Object result = engine.eval(reader); 上下文值得的注意的是，大部分引擎的上下文都是同一个。即多次执行是在同一个上下文中进行的，所以其变量也会被共享。 例如： 12engine.eval(\"n = 1728\");Object result = engien.eval(\"n + 1\"); //1729 与上下文变量交换添加变量不光可以使用脚本语法申明变量，也可以通过Java的API来为其添加变量。 如: 1engine.pus(\"k\", 1728); 取变量可以从脚本上下文取变量 如： 1Object result = engine.get(\"k\"); 注意：如果需要自定义作用域，可以自定义一个实现了ScriptContext接口，并管理一个作用域集合。每个作用域都是由一个整数标识的，而且数字越小应该越先被搜索到。（标准库提供了SimpleScriptConext类，但是它只能持有全局作用域和引擎作用域） 重定向输入和输出可以通过调用脚本上下文的setReader和setWriter方法来重定向脚本的标准输入和输出。 例如： 12var writer = new StringWriter();engine.getContext().setWriter(new PrintWriter(writer, true)); 在上例中，JavaScript的console.log产生的输出都将被发送到writer。 Nashorn引擎没有标准输入源的概念，因此调用setReader没有任何效果。 调用脚本的函数和方法有两个方法用于触发脚本语言的方法。 invokeFunction：面向函数式编程。 invokeMethod：面向对象编程，可以调用某个对象上的方法。 如： 例1：invokeFcuntion 12engine.eval(\"function greet(how, whom)&#123;return how + ', ' + whom + '!'&#125;\");Invocable res = ((Invocable)engine).invokeFunction(\"greet\", \"hello\", \"world\"); 例2：invokeMethod 1234engine.eval(\"function Greeter(how)&#123;this.how = how&#125;\");engine.eval(\"Greeter.prototype.welcome = function(whom)&#123;return this.how + ', ' + whom + '!'&#125;\");Object yo = engine.eval(\"new Greeter('Yo')\");res = ((Invocable) engine).invokeMethod(yo, \"welcome\", \"world\"); 并且还可以用脚本引擎来实现Java的接口，然后调用其方法。 如下接口： 123public interface Greeter&#123; String welcome(String whom);&#125; 实现： 123engine.eval(\"function welcome(whom)&#123;return 'Hello, ' + whom + '!'&#125;\");Greeter g = ((Invocable)engine).getInterface(Greeter.class); Object res = g.welcome(\"world\"); 编译脚本某些脚本引擎处于对执行效率的考虑，可以将脚本代码编译为某种中间格式。这些引擎实现了Compilable接口。 如： 12345var reder = new FileReader(\"script.js\");CompiledScript script = null;if(engine implements Compilable)&#123; script = ((Compilable)engine).compile(reader);&#125; 一旦该脚本被编译，就可以执行它。例如下面的代码展示了如果可以编译就执行编译后的结果，否则执行原始脚本： 12345if(script != null)&#123; script.eval();&#125;else&#123; engine.eval(reder);&#125; 编译器API可以在Java代码中编译Java代码。 调用编译器调用编译器API非常简单，例如： 1234JavaScompiler compiler = ToolProvider.getSystemJavaCompiler();OutputStream outStream = ...;OutputStream errStream = ...;int result = compiler.run(null, outStream, errStream, \"-sourcepath\", \"src\", \"Test.java\"); 返回值为0则表示成功。 注解Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。 使用注解 在Java中，注解是当作修饰符来使用的。他被置于被备注项之前，中间没有分号（修饰符就是诸如public和static之类的关键词）。每个注解的名称前面都加上了@符号。这有点类似于Javadoc注释出现在/**...*/之间定界符的内部，而注解是代码的一部分。 注解可以定位包含元素的形式。 12@Test(timeout = 1000)public void testMethod()&#123;&#125;; 这些元素可以被读取这些注解的工具去处理。 注解语法注解接口-注解定义注解是由注解接口来定义的： 1234modifiers @interface AnnotationName&#123; elementDeclatarion1; elementDeclatarion2;&#125; 每个元素申明都具有下面的形式： 1type elementName(); 或者附带默认值： 1type elementName() default value; 例如，下面的注解具有两个元素：assignedTo和severity。 1234public @interface BugReport&#123; String assignedTo() default \"[none]\"; int severity();&#125; 所有的注解接口都隐式的扩展自java.lang.annotation.Annotation接口。这个接口是一个常规接口，不是一个注解接口。 不必要为注解接口提供实现类。 注解元素的类型为下列之一“ 基本类型（int、short、long、byte、char、double、float或者boolean）。 String。 Class（具有一个可选的类型参数，如Class&lt;? extends MyClass&gt;）。 enum类型。 由前面提到的类型构成的数组。 如： 1234567public @interface BugReport&#123; enum Status &#123;UNCONFIRMED, CONFIMED, FIXED, NOTABUG&#125;; boolean showStopper() default false; String assignedTo default \"[none]\"; Status status() default Status.UNCONFIRMED; String[] reportedBy();&#125; 定义注解位置注解可以出现在很多地方，这些地方可以分为两类：声明和类型用法声明注解可以出现在下列声明处： 包 类（包括enum） 接口（包括注解接口） 方法 构造器 实例域（包含num常量） 局部变量 参数变量 类型参数 对于类和接口，需要将注解放置在class和interface关键词的前面： 1@Entity public class User&#123;&#125; 对于变量，需要将其放置在类型的前面： 12@SuppressWarnings(\"unchecked\") List&lt;User&gt; user = ...;public User getUser(@Param(\"id\") String userId;) 泛型类或方法中的类型参数可以像下面这样被注解： 1public class Cache&lt;@Immutable V&gt;&#123;...&#125; 包是在文件packge-info.java中注解的，该文件中只包含注解先导的包语句， 123456/** Packge-level javadoc*/@GPL(version = \"3\")package priv.xxx.xxx;import org.gun.GPL; 注解使用每个注解都具有下面的格式： 1@annotationName(elementName1 = value1, elementName2 = value2) 例如： 1@BugReported(assignedTo=\"Harry\", severity=\"10\") 参数元素的顺序无关紧要。 如果某个值没有指定，就是用默认值。如@BugReported(severity=&quot;10&quot;)中assignedTo元素默认值为&quot;[none]&quot;。 注意：默认值并不是和注解存储在一起的。相反地，它们是动态计算而来得到。例如，如果将assignedTo的默认值改为[]，那么不仅后面声明的为[]，之前申明的也为[]了。 注解有两种特殊形式： @annotation：（标记注解）表示所有元素都用默认参数。 @annotation(value)：（单值注解）如果一个元素名字为value，那么可以直接在括号中进行赋值。 还有两点值得注意： 数组的赋值：对于数组的赋值可以采用以下格式： 12@BugReported(..., repotedBy=&#123;\"Harry\", \"Carl\"&#125;) //多值数组@BugReported(..., repotedBy=\"Harry\") //单值数组 注解的嵌套 由于一个注解元素可以是另一个注解，那么可以创建出任意复杂的注解，例如： 1@BugReported(ref=@Reference(id=\"213213\"), ...) 标准注解Java SE在java.lang、java.lang.annotation和javax.annotation包中定义了大量的注解接口。其中四个是元注解，用于描述注解接口的行为属性，其他的三个是规则接口，可以用它们来注解你的源代码中的项。 注 解 接 口应 用 场 景目 的Deprecated全部将项标记为过时的SuppressWarnings除了包和注解之外的所有情况阻止某个给定类型的警告信息Override方法检查该方法是否覆盖了某一个超类方法PostConstruct方法被标记的方法应该在构造之后立即被调用PreDestroy被标记的方法应该在移除之前立即被调用Resource类、接口、方法、域在类或者接口上：标记为在其他地方要用到的资源在方法或者域上 ：为 “注入” &nbsp;而标记Resources类、接口一个资源组Grenerated全部&nbsp;Target注解指明可以应用这个注解的那些项Retention注解指明这个注解可以保留多久Documented注解指明这个注解应该包含在注解项的文档中Inherited注解指明当这个注解应用于一个类的时候，能够在被他的子类继承 用于编译的注解 @Deprecated注解可以被添加到任何不再鼓励使用的项上。这个注解与JavaDoc的@deprecated效果相同。 @SuppressWarning注解会告知编译器阻止特定类型的警告信息。 @Override用于方法上，编译器会检查具有这种注解的方式是否真的覆盖了一个来自超类的方法。 @Generated注解的目的是共提供代码生成的工具来使用。任何生成的源代码都可以被注解，从而与程序员提供的代码区分开。例如，代码编辑器可以隐藏生成的代码，或者代码生成器可以移除生成代码的旧版本。 用于管理资源注解 @PostConstruct和@PreDestroy注解用于控制对象生命周期的环境中。 @Resource注解用于资源的注入。 元注解@Target 表示该注解用于什么地方，可能的值在枚举类 ElemenetType 中，包括： ElemenetType.CONSTRUCTOR—————————–构造器声明 ElemenetType.FIELD ———————————-域声明（包括 enum 实例） ElemenetType.LOCAL_VARIABLE————————- 局部变量声明 ElemenetType.METHOD ———————————方法声明 ElemenetType.PACKAGE ——————————–包声明 ElemenetType.PARAMETER ——————————参数声明 ElemenetType.TYPE ———————————– 类，接口（包括注解类型）或enum声明 @Retention 表示在什么级别保存该注解信息。可选的参数值在枚举类型 RetentionPolicy 中，包括： RetentionPolicy.SOURCE————-注解将被编译器丢弃 RetentionPolicy.CLASS ————-注解在class文件中可用，但会被VM丢弃 RetentionPolicy.RUNTIME ———VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 @Documented 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。 @Inherited 允许子类继承父类中的注解。即如果一个类具有继承注解，那么它的子类都自动具有同样的注解。 获取注解信息在定义和使用注解后，我们需要考虑如何去读取传入注解的信息。 一般来说，我们使用反射来获取注解列表和注解中的信息。 但是要注意，要使用反射来获取注解，则必须将注解标记为RetentionPolicy.RUNTIME，这样其生命周期才会到达虚拟机可到达位置，即： 123456789package mw;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface Annotaiaon1 &#123; String value();&#125; 然后我们可以通过以下API获取注解： Annotation[] getAnnotations() Annotation getAnnotation(Class&lt;A&gt; annotationClass) Annotation getDeclaredAnnotation(Class&lt;A&gt; annotationClass) Annotation getDeclaredAnnotationsByType(Class&lt;A&gt;) Annotation[] getDeclaredAnnotations() 通过这些API我们可以获得Annotation对象。注意这里赋值就直接赋值给我们自定义的注解类型了。在此之前，我们可以通过以下API来判断是否存在对应的注解： public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果存在，则使用上面的2来获取对应的注解，然后通过注解定义的域来获取传入的值。 例如： Annotation1.java 123456789package mw;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface Annotaiaon1 &#123; String value();&#125; Dog.java-使用注解的类： 123456789101112131415161718package mw;@Annotaiaon1(\"123\")@Annotation2(\"000\")public class Dog &#123; public Integer idInteger; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 测试： 12345678Class dog = Class.forName(\"mw.Dog\");if(dog.isAnnotationPresent(Annotaiaon1.class)) &#123; Annotaiaon1 anno = (Annotaiaon1) dog.getAnnotation(Annotaiaon1.class); String value = anno.value(); System.out.println(\"存在annotation1注解，value= \" + value);&#125;else &#123; System.out.println(\"不存在annotation1注解\");&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"脚本、编译和注解处理","slug":"脚本、编译和注解处理","permalink":"http://yoursite.com/tags/%E8%84%9A%E6%9C%AC%E3%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86/"}]},{"title":"java核心技术-II-6-日期和时间API","slug":"java核心技术-II-6-日期和时间API","date":"2022-02-16T04:21:08.000Z","updated":"2022-02-16T08:49:15.214Z","comments":true,"path":"2022/02/16/java核心技术-II-6-日期和时间API/","link":"","permalink":"http://yoursite.com/2022/02/16/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-6-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/","excerpt":"","text":"简介Java1.0有一个Date类，事后证明其太过简单了，当Java1.1引入Calendar之后，Date类中的大部分方法就被其弃用了。但是Calendar的API还是有缺陷，它的实例是可以修改的，并且它没有处理诸如闰秒这样的问题。 第三次在Java SE 8中引入了java.timeAPI，它修正了过去的错误。并且应该会服役相当长一段时间。 时间线Java的Date和Time API规范要求Java使用的时间尺度为： 每天86400秒。 每天正午与官方时间精确匹配。 在其他时间点上，以精确定义的方式与官方时间接近匹配。 在Java中，Instance类表示时间线上的某个点。被称为“新纪元”的时间线远点被设置为穿过伦敦格林尼治皇家天文台的本初子午线所处时区的1970年1月1日的午夜。这与UNIX/POSIX时间使用的惯例相同。从该原点开始，时间按照每天86400秒向前或向回度量，精确到纳秒。其有以下API： Instance.MIN()：最小值，表示10亿年前。 Instance.MAX()：最大值，是公元1000 000 000年的12月21日。 Instance.now()：给出当前的时刻。 Instance.between(start, end)：表示两个时间点的差距。返回的是一个Duriation对象，可以对其调用toNanos、toMills、getSeconds、toMinutes，toHours和toDays来获取Duration按照传统单位度量的时间长度。（值得注意的是，转换为纳秒时，long类型只能存储大约300年的长度。） TIP：Instance和Duration类都是不可修改的类，所以诸如multipliedBy和minus这样的方法都会返回一个新的实例。 本地日期在Java API中有两种人类时间，本地日期/时间和时区时间。本地日期/时间包含日期和当天的时间。但是与时区信息没有和关系。例如2021年1月1日就是一个本地日期，因为整个日期既没有当天的时间，也没有时区信息，因此它不对应精确的时刻。与之对应的是，2021年1月1日 06:11:11 UTC+8 是一个时区日期/时间，表示的是时间线上的一个精确的时刻。 LocalDate对象是带有年月日的日期，用于表示本地日期。 创建LocalDate可以使用以下两个API构建LocalDate对象 public static LocalDate now()：获取当前的本地日期对象。 public static LocalDate of(int year, int month, int dayOfMonth)：获取指定日期的本地日期对象。 改变LocalDateLocalDate有众多的方法用来通过一个LocalDate构建新的LocalDate对象。（注意LocalDate是不可修改，所以以下方法都是返回新的类。） public LocalDate plus(TemporalAmount amountToAdd)：产生一个新对象，在原来对象上加一个Peroid对象，参数一般是一个Period对象（Period实现了TemporalAmount接口）。 public LocalDate minus(TemporalAmount amountToAdd)：产生一个新对象，在原来对象上减一个Peroid对象，参数一般是一个Period对象（Period实现了TemporalAmount接口）。 public LocalDate (plus|minus)(Days|Weeks|Months|Years)(long number)：产生一个新对象，在原来对象上加或减指定的时间单位获得。 public LocalDate with(TemporalAdjuster adjuster)：产生一个新对象，按照Peroid对象修改原对象中的数据。 with(Year|Month|DayOfMonth|DayOfYear)(int xxx)：产生一个新对象，修改原对象中的数据，注意DayOfMonth表示月份日期（如2022年6月6日），DayOfYear表示年日期（如2022年第5天）。 get(Year|Month|MonthValue|DayOfMonth|DayOfYear)()：获取当前对象的对应数据。注意getMonth返回的是Month对象，而getMonthValue返回的是月份的数字（1-12）。getDayOfMonth和getDayOfYear表示分别返回月份日（1-31）和年日期（1-366）。 public String format(DateTimeFormatter formatter)：返回格式化的日期。 间隔本地日期的时长间隔为Period对象（与Instance对象的Duration对象相似）。可以通过以下API创建Prroid对象： public static Period of(int years, int months, int days) public static Period of(Year|Month|Weeks|Days)(int xxx) 并且其也有withXXX来修改数据，plusXXX方法来加数据，minusXXX方法来减数据。 然后可以使用LocalDate的重载方法来使用这个Peroid来改变原数据。 日期调整期有些时候需要计算例如“每月的第一个周二”这样的日期。TemporalAdjusters类提供了一些方法来用于计算，具体API如下： public static TemporalAdjuster firstDayOfMonth() public static TemporalAdjuster lastDayOfMonth() public static TemporalAdjuster firstDayOfNextMonth() public static TemporalAdjuster firstDayOfYear() public static TemporalAdjuster lastDayOfYear() public static TemporalAdjuster firstDayOfNextYear() public static TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek) public static TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek) public static TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek) public static TemporalAdjuster next(DayOfWeek dayOfWeek) public static TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek) public static TemporalAdjuster previous(DayOfWeek dayOfWeek) public static TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek) （这些方法看名字就可以很明显的看出其功能，就不再介绍） 注意这些方法都返回了一个TemporalAdjuster方法，我们需要将其传递给LocalDate.with方法以获得一个新的LocalDate对象。 例如： 1234LocalDate nowDate = LocalDate.of(2000, 1, 1);TemporalAdjuster a = TemporalAdjusters.firstDayOfNextMonth();LocalDate newDate = nowDate.with(a);System.out.println(newDate); //2000-02-01 创建自定义调整器还可以通过实现TemporalAdjuster接口来创建自定义的调整器。 例如： 12345678TempoalAdjuster NEXT_WEORKDAY = w -&gt; &#123; LocalDate res = w; do&#123; res = res.plusDays(1); &#125; while(res.getDayOfWeek().getValue() &gt;= 6); return res;&#125; 值得注意的是w原本是一个Temporal类型，我们需要将其转为LocalDate对象（LocalDate也实现了Temporal接口）。 本地时间LocalTime表示当前时刻。如：15:30:00。 创建LocalTime可以使用of和now来创建LocalTime对象。 public static LocalTime now() public static LocalTime of(int hour, int minute) public static LocalTime of(int hour, int minute, int second) public static LocalTime of(int hour, int minute, int second, int nanoOfSecond) 用法基本与LocalDate一致，只是参数不同。 操作LocalTime也是拥有with、minus、plus、get、to系列方法。 值得注意的是get和to系列方法的设计。 get()可以传入TemporalField对象来获取对应域（如时分秒）的值。也可以用get(Hour|Minutes|Second|Nano)方法来获取对应域的值。 to方法有两个方法: public int toSecondOfDay()：获取当前对应于一天中的多少秒。 public long toNanoOfDay()：获取当前对应于一天中的多少纳秒 时区时间在Java中，用ZonedDateTime来表示时区日期。其大部分方法都与LocalDateTime（相当于LocalDate与LocalTime的结合）的方法相同。不同的是必须传入一个时区ID。这个ID可以从ZonedId对象中获取。 例如： 12345ZonedDateTime skipped = ZonedDateTime.of( LocalDate.of(2013, 3, 31), LocalTime.of(2, 30), ZonedId.of(\"Europe/Berlin\")); 时区转换一个时区的时间与另外时区的时间是不同的，而且设计夏令时问题。所以一般使用withZoneSameLocal(ZoneId)方法来进行转换。 例如： 123456// 以中国时区获取当前时间:ZonedDateTime Shanghai = ZonedDateTime.now(ZoneId.of(\"Asia/Shanghai\"));// 转换为纽约时间:ZonedDateTime NewYork = Shanghai.withZoneSameInstant(ZoneId.of(\"America/New_York\"));System.out.println(Shanghai);System.out.println(NewYork); 格式化和解析日期时间的格式化采用的是DateTimeFormatter类。 DateTimeFormatter类提供了是三种用于打印日期/时间值的格式器： 预定义的格式。 locale相关的格式器。 带有定制模式的格式器。 预定义的格式下面是预定义的格式器 要使用标准的格式，可以世界调用其format方法： 12LocalDateTime localDateTime = LocalDateTime.now();String formatted = DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(localDateTime); //20220216 标准格式器主要是为了机器可读的时间戳而设计的。 locale相关的格式器对于日期和时间而言，有4种locale相关的格式化风格，即SHORT、MEDIUM、LONG和FULL。见下表： 使用ofLocalizedDate、ofLocalizedTime和ofLocalizedDateTime可以创建这种格式。如： 123DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG);String reString1 = formatter.format(localDateTime);System.out.println(reString1); //February 16, 2022 这里使用了默认的locale，为了切换locale，可以直接使用withLocale方法。 如： 12String reString2 = formatter.withLocale(Locale.CHINA).format(localDateTime);//2002年2月16日 定制日期格式在自定义格式中，规定了特定字母表达的日期中的部分，例如yyyy表示2000年这种格式。 所以，一个经典的例子如下： 1formatter = DateTimeFormatter.ofPattern(\"E yyyy-MM--dd HH:mm\"); 具体所有格式化符号如下表。 解析字符串可以利用日期格式来解析对应的字符串。 如： 12LocalDate churchsBirthday = LocalDate.parse(\"1903-06-14\");ZonedDateTime apollolllauch = ZonedDateTime.parse(\"1969-07-16 03:32:00-0400\", DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ssxx\")); 第一个例子使用了标准的ISO_LOCAL_DATE格式器，而第二个调用了一个自定义的格式器。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"日期和时间API","slug":"日期和时间API","permalink":"http://yoursite.com/tags/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/"}]},{"title":"java核心技术-II-2-输入与输出","slug":"java核心技术-II-2-输入与输出","date":"2022-02-15T05:24:38.000Z","updated":"2022-02-16T15:14:43.324Z","comments":true,"path":"2022/02/15/java核心技术-II-2-输入与输出/","link":"","permalink":"http://yoursite.com/2022/02/15/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","excerpt":"","text":"输入与输出流在Java API中，输入流是一个可以读入字节的对象；输出流是一个可以写如字节的对象。这些字节的来源和目的地可以是文件、网络甚至是内存块。 抽象类InputStream和OutputStream构成了输入/输出类层次结构的基础。（注意与上一节的流操作完全不同） InputStreamInputStream是输入流，即通过文件等获取一个InputStream的子类。然后通过其API获得输入流中的内容。其主要API如下： abstract int read()：从数组中读取一个字节，并返回该字节。结尾时返回-1。 int read(byte[] b)：读入一个字节数组，并返回实际读入的字节数，结尾时返回-1。其最多读入b.length个字节。 int read(byte[] b, int off, int len)：读取len个字节存入b数组，而且从b数组的第off个位置开始写入。 byte[] readNBytes(int len)：与2相同，不过该API只有在读取到len个字节、流结束或发生错误时才会返回。否则会一直阻塞。 int readNBytes(byte[] b, int off, int len)：3+4. byte[] readAllBytes()：读取流中所有的字节到一个数组。本质是调用return readNBytes(Integer.MAX_VALUE); long transferTo(OutputStream out)：将当前输入流中的所有字节传送到给定的输出流，返回传递的字节数。这两个流都不应该处于关闭状态。 long skip(long n)：在输入流中跳过n个字节，返回实际跳过的字节数（遇到输入流的结尾，则可能小于n）。 int available()：返回在不阻塞的情况下可获取的字节数。 void close()：关闭这个输入流。 void mark(int readlimit)：在输入流的当前位置打一个标记（并非所有的流都支持整个标记）。如果从输入流中已经读入的字节多余readlimit个，则这个流允许忽略整个标记。 void reset()：返回到最后一个标记，随后对read的调用将重新读入这些字节。如果当前没有任何标记，则这个流不被重置。 void markSupported()：检测当前流是否支持打标记。 OutputStream abstract void write(int n)：写出一个字节的数据。 void write(byte[] b)：将b中的字节写入到输出流中。 void write(byte[] b, int off, int len)：与2相同，不过是从b的off位置开始，写出len个字节。 void close()：冲刷并关闭输出流。 void flush()：冲刷输出流，即将所有缓冲的数据发送到目的地。 Reader/WriterJava Stream相关类是用来处理字节流的,但不适合用来字符流.因为一个字节是8bit,而一个字符是16bit.字符串是由字符组成,字符串类型天然处理的是字符而不是字节.更重要的是,字节流无法知道字符集及其字符编码.Java中可以用Reader/Writer相关类来处理字符. 而Reader/Writer类的基本方法与InputStream/OutputStream基本一致。 如： 12abstract int read();abstract void wirite(int c); read方法将返回一个Unicode码元（一个在0-65535之间的整数），或者在碰到文件结尾的时返回-1。write方法在被调用时，需要传递一个Unicode码元。 所有输入输出流及其关系 组合输入/输出流过滤器在Java中，不同的输入输出类有自己的职能。 例如， FileInputStream和FileOutputStream可以提供一个磁盘文件上的输入输出流，并且只需要想起构造器提供文件名或晚间的完整路径名。如： 1var fin = new FileInputStream(\"employee.dat\"); 但是两个类与抽象类InputStream/OutputStream一样，这些类只支持在字节级别上的读写。即只能从fin对象读入字节或字节数组： 1byte b = (byte) fin.read(); DataInputStream和DataoutputStream能够读入数字，如： 12DataInputStream din = ...;double x = din.readDouble(); 但是DataInputStream和DataoutputStream却没有任何能够读取文件的方法。 这正是Java的流的设计机制，即一个流只负责对应的单一功能。需要复合功能时（如：从文件中读取数字），则将负责不同职能的流组合起来已到达效果。 例如：从文件中读取一个数字： 123FileInputStream fin = new FileInputStream(\"employee.dat\");DataInputStream din = new DataInputStream(fin);double x = din.readDouble(); 这样的流可以多层嵌套来实现更多的效果。 例如：输入流在默认情况下是不被缓冲区缓存的，也就是说，每个对read的调用都会请求操作系统再分发一个字节。而BufferedInputStream可以为输入流提供一个缓冲区，则读取会更加高效。则代码如下： 12345DataInputStream din = new DataInputStream( new BufferedInputStream( new FileInputStream(\"employee.data\") )); 注意，我们把DataInputStream置于构造器链的最后，这是因为我们希望使用DataInputStream的方法，并且希望它们能够使用带缓冲区机制的read方法。 当我们需要调用中间输入流的方法时，我们可以在传递参数时对外部引用进行赋值。如： 123456BufferedInputStream bbin = null;var din = new DataInputStream( bbin = new BufferedInputStream( new FileInputStream(\"data\") )); 一般来说输入输出流的顺序并不是特别重要，主要是最外层和最内层的输入输出流，因为需要调用这两个的API和构造器 读写文本文件在保存数据时，可以选择二进制格式或文本格式。 如，整数1234存储为二进制时，会被写为由字节00 00 04 D2构成的格式（十六进制表示法）。而被存储为文本格式时，则会被写入字符串”1234“。 二进制格式的I/O高速且高效，但是并不适合人类阅读。 写出文本输出对于文本的输出，可以使用PrintWriter。这个类拥有以文本格式打印字符串和数字的方法。 为了输出到打印写出器，需要使用与System.out时相同的print、println和printf方法。可以用其来打印各种数据结构。 例如： 123456PrintWriter out = new PrinterWriter(\"employee.txt\", StandardCharsets.UTF_8);String name = \"Harry Hacker\";int salary = 75000;out.print(name);out.print(\" \");out.print(salary) 其将会把字符Harry Hacker 75000.0输出到写出器out，之后这些字符将会被转换为字节并最终写入employee.txt 与System.out一样，println在行中添加了对目标系统的来说恰当行结束符（Windows系统是&quot;\\r\\n&quot;，UNIX系统是&quot;\\n&quot;）。 PrinterWriter第二个参数是确定是否为自动冲刷模式，如果为true，则打开自动冲刷模式。那么只要println被调用，缓冲区中的所有字符都会被发送到目的地。默认是false。 读取文本输入通过Files类一般现在使用Java7引入的Files类来读取文本内容。 例如： 读取小文件直接到String： 123Path path = Path.of(\"./a.txt\");Charset charset = StandardCharsets.UTF_8;String content = Files.readString(path, charset); 按行读取文件 1List&lt;String&gt; lines = Files.readAllLines(path, charset); 如果文件过大，还可以处理为Stream对象 123try(Stream&lt;String&gt; lines = Files.lines(path, charset))&#123; ...&#125; 通过Scanner来实现也可以通过Scanner类来读取文件，虽然现在主要通过new Scanner(System.in)来读取控制台输入。 Scanner类有多种重载： private Scanner(Readable source, Pattern pattern) public Scanner(Readable source) public Scanner(InputStream source) public Scanner(InputStream source, String charsetName) public Scanner(InputStream source, Charset charset) public Scanner(File source) public Scanner(File source, String charsetName) public Scanner(File source, Charset charset) private Scanner(File source, CharsetDecoder dec) public Scanner(Path source) public Scanner(Path source, String charsetName) public Scanner(Path source, Charset charset) public Scanner(String source) public Scanner(ReadableByteChannel source) public Scanner(ReadableByteChannel source, String charsetName) public Scanner(ReadableByteChannel source, Charset charset) 可以看出，其可以从实现了Readable接口的对象、InputStream、File、Path、String或者实现了ReadableByteChannel接口的对象来读取文本。 下面演示从Path和File中读取 例如： 123456789101112131415Path path = Path.of(\"a.txt\");File file = new File(\"a.txt\");Charset charset = StandardCharsets.UTF_8;ArrayList&lt;String&gt; conents = new ArrayList&lt;&gt;();try &#123; Scanner pathScanner = new Scanner(path, charset); //从Path读取 Scanner pathScanner = new Scanner(file, charset); //从File读取 while(pathScanner.hasNextLine()) &#123; String aString = pathScanner.nextLine(); conents.add(aString); &#125;&#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; 通过BufferedReader在早期的Java版本中，处理文本输入的唯一方式就是通过BufferedReader类。它的readLine方法方法将产生一行文本，在没有更多输出时，返回null。 例如代码如下： 1234567InputStream inputStream = ...;try(var in = new BufferedReader(new InputStreamReader(inputstream, charset)))&#123; String line; while((line = in.readLine() != null)&#123; //... &#125;&#125; 读写二进制文件DataInput和DataOutput接口DataOutput接口定义了下面用于以二进制格式写数组、字符、Boolean值和字符串的方法： writeChars writeByte writeInt writeShort writeLong writeFloat writeDouble writeChar writeBoolean writeUTF 如，writeInt总是将一个整数写出为4字节的二进制数量值，而不管它有多少位。writeDouble总是将一个double值写出为8字节的二进制值（取决与处理器类型）。 这样产生的结果并非人可阅读的，但是对于给定类型的每个值，使用的空间都是相同的，而且将其都会也比解析文本要更快。 writeUTF方法使用修订版的8位Unicode转换格式写出字符串。这中方式与直接使用标准的UTF-8编码不一样，其中，Unicode码元序列首先用UTF-8表示，其结果之后使用UTF-8规则进行编码。修订后的编码方式对于编码大于OXFFFF的字符的处理有所不同，这是为了向后兼容在Unicode还没有超过16位时构建的虚拟机。这种编码应该在只用于Java虚拟机的字符串时使用。 为了读回数据，可以使用在DataInput接口中定义的下列方法： readInt readShort readLong readFloat readDouble readChar readBoolean readUTF 具体来说，可以使用实现了DataInput和DataOutput接口的DataInputStream和DataOutputStream类。 其分别继承了FilterInputStream和FilterOutputStream类。 所以也分别实现了其中的read和write方法。 例如： 12345678910try &#123; Path path = Path.of(\"e:\\\\a.data\"); Files.createFile(path); FileOutputStream fStream = new FileOutputStream(\"e:\\\\a.data\"); DataOutputStream oStream = new DataOutputStream(fStream); oStream.writeChars(\"ssss\");&#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; 随机访问文件RandomAccessFile类可以在文件中的任何位置读取或写入文件。磁盘文件都是随机访问的，但网阔套接字的输入/输出流却不是。 可以直接通过构造器来获得一个文件的RandomAccessFile引用。而第二个参数为模式。具体如下： 值 解释 r 只能读文件，写时会抛出IOException。 rw 可读可写，如果不存在将会尝试创建。 rws 可读可写，并且每次更新文件时都将内容和元信息同步更新到文件中。 rwd 可读可写，并且每次更新文件时都将内容同步更新到文件中。 随机访问我呢见有一个表示下一个将被读入或写入的字节所处位置的文件指针， seek方法可以用来将这个文件指针设置到文件中的任意字节位置。seek接受一个long整型数。 getFilePointer方法将返回文件指针的当前位置。 RandomAccessFile类同时实现了DataInput和DataOutput接口。因此可以调用之前提到的readInt/writeInt或readChar/writeChar。 例如，我们要存储一个对象为二进制，我们可以分别确定对象的每个成员变量字节数进而确定每个对象的字节数。 整数和浮点数在二进制格式中都具有固定的尺寸。对于字符串，可以固定长度，不够的话填0来解决。对于含有以下成员的对象： 1String-40字符, 80个字节。用于名词。 1double=8字节。用于薪水。 3 int=12字节。用于日期。 则整体包含100个字节。 则插入一个对象为： 123456789int n = 3;final int RECORD_SIZE = 100;in.seek((n-1) * RECORD_SIZE);var e = new Employee();in.write(FixString(e.getName())); //FixString为填充字符串固定长度的函数in.write(e.getSalary());in.write(e.getYear());in.write(e.getMonth());in.write(e.getDay()); //下面操作封装为一个函数比较好 ZIP文档ZIP文档（通常）以压缩格式存储了一个或多个文件，每个ZIP文件都有一个头。包含注入每个文件名字和所使用的压缩方法等信息。在Java中，可以使用ZipInputStream来读入ZIP文档。 读取ZIP文档而getNextEntry方法就可以返回一个描述这些项的ZipEntry对象。在获得一个ZipEntry对象后，需要调用closeEntry来关闭当前的ZipEntry对象。以便访问下一个ZipEntry对象。 如： 123456var zin = new ZipInputStream(new FileInputStream(zipname));ZipEntry entry;while((entry = zin.getNextEntry()) != null)&#123; byte[] contents = entry.getExtra(); //read the content of zin zin.closeEntry();&#125; 写入ZIP文档在写如ZIP文档时，大致步骤如下： 获得一个ZipOutputStream。其构造器接受一个OutputStream对象。可以用FileOutputStream对象。 新建ZipEntry对象。构造器为ZIP项的名字，其他信息将自动设置，也可以自己手动调用setXXX方法覆盖。 调用ZipOutoutStream的putNextEntry方法来写出新文件，并将文件数据发送到ZIP输出流中。 完成后调用closeEntry。 如： 123456var fout = new FileOutputStream(\"test.zip\");var zout = new ZipOutputStream(fout);var ze = new ZipEntry(filename);zout.putNextEntry(ze);zout.closeEntry();zout.close(); ZipFile另外还有一个ZipFile，用于创建Zip文件。其有以下ZPI： ZipFile(String name, Charset charset) ZipFile(File file, Charset charset)：创建一个ZipFile，用于从给定的字符串或File对象读入文件。其中编码用于文件的名字和注释。 Enumeration entries()：返回一个Enumeration对象，他枚举描述了这个ZipFile中各个项中的ZipEntry对象。 ZipEntry getEntry(String name)：返回给定名字所对应的项。不存在的时候返回null。 InputStream getInputStream(ZipEntry ze)：返回用于给定项的InputStream。 String getName()：返回这个ZIP文件的路径。 对象输入/输出流与序列化上面简单演示了如何将一个对象存储到文件系统，但是其具有很多缺点，例如多态的问题。而Java语言支持一种称为对象序列化（object serialization）的非常通用的机制，它可以将任何对象写出到输出流中，并在之后将其读回。 保存和加载序列化对象保存序列化对象步骤如下： 获得一个ObjectOutputStream对象out和目标对象obj。 调用out.write(obj)来写入对象。 例如： 12345ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.dat\"));var harry = new Employee(\"Harry\", 50000, 1989, 10, 1);var boss = new Manager(\"Tom\", 100000, 1900, 1, 1);out.writeObject(harry);out.writeObject(boss); 加载序列化对象步骤如下： 获得一个ObjectInputStream对象in。 调用in.readObject()按照写入的顺序来获取对象。 例如： 123ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"employee.dat\"));var harry = (Employee)in.readObject();var boss = (Manager)in.readObject(); Note：这里只能按照写入时的顺序来读取。 前提和原理前提要进行序列化的对象必须要实现了Serializable接口，该接口没有任何方法。 原理之所以叫序列化，是因为每个序列化的对象都用一个序列号（serial number）来保存的。所以对于嵌套的对象，其算法如下： 对遇到的每个对象引用都关联一个序列号。 对于每个对象，当第一次遇到时，保存期对象数据到输出流中。 如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”。 而读回对象时，整个过程是反过来的。 对于对象输入流中的对象，第一次遇到其序列号时，构建它，并使用流中的数据来初始化它，然后记录这个序列号和新对象之间的关联。 当遇到“与之前保存过的序列号为x的对象相同”这一标记时，获取这个序列号相关联的对象引用。 修改默认的序列化机制序列化有其默认的逻辑，但实际上有时候我们需要自定义某个域的存储逻辑。这个时候就可以修改其默认的序列化机制。 跳过数据域使用transient修饰符可以跳过指定数据域的序列化。 如： 12345678public class User implements Serializable&#123; private static final long serialVersionUID = 1580502463316993420L; private Integer id; private String name; private transient ProcessHandle handle;&#125;///... 此时handle将不会被序列化，（一般进程序列化之后，下一次读取就并不具有时效性了）。 自定义内部序列化方法通过重写目标对象的writeObject和readObject方法可以实现自定义序列化对象。 例如： 12345678910111213141516171819202122232425262728package mw;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class User implements Serializable&#123; /** * */ private static final long serialVersionUID = 1580502463316993420L; private Integer id; private String name; private String position; //x-y private transient ProcessHandle handle; private void writeObject(ObjectOutputStream out) throws IOException &#123; out.writeInt(id); out.writeInt(Integer.parseInt(position.split(\"-\")[0])); out.writeInt(Integer.parseInt(position.split(\"-\")[1])); &#125; private void readObject(ObjectInputStream in) throws IOException &#123; id = in.readInt(); position = String.valueOf(in.readInt()) + \"-\" + String.valueOf(in.readInt()); &#125;&#125; 值得注意的是： 字符串的长度仍然需要我们自定义（数据库的中varchar需要定义长度可能也是这个原因吧），所以这里只展示了存储Integer，然后将其转化格式后存储到数据域中。 一旦对象中出现这两个方法，那么序列化时只会调用这两个方法，默认方法将不会起作用。 这两个方法是私有的 这两个方法仅仅为对象自己的数据与加载和保存对象，而不必去关系父类和其他任何信息。 自定义外部序列化方法对于整体的对象的数据域（包括父类和其他）恢复和加载，则需要实现Externalizable接口。其定义了两个方法readExternal和writeExternal方法，目标对象必须重写这两个方法。即可以在内部为父类和其他的数据域进行赋值。 例如： 1234567891011public void readExternal(ObjectInput s) throws IOException&#123; name = s.readUTF(); salary = s. readDouble(); hireDay = LocalDate.ofEpochDay(s.readLont());&#125;public void writeExternal(ObjectOutput s) throws IOException&#123; s.writeUTF(name); s.writeDouble(salary); s.writeLong(hireDay.toEpochDay());&#125; 注意： 这两个方法是public的。因此也可以从外部访问。 readExternal还潜在地允许修改现有对象的状态。 序列化单例和类型安全的枚举在序列化和反序列化时，如果目标对象是唯一的，那么必须小心，因为在序列化和反序列化后，对象的地址往往发生了变化，那么在Java虚拟机中，两者就不相等了。这种情况往往发生在自定义的枚举类型 例如： 12345678910public class Orientation&#123; public static final Orientation HORIZONTAL = new Orientation(1); public static final Orientation VERTICAL = new Orientation(1); private int value; private Orientation(int v)&#123; value = v; &#125;&#125; 注意构造器是私有的，所以不能构造出HORIZONTAL和VERTICAL之外的对象。 那么此时，如果对HORIZONTAL，VERTICAL进行序列化和反序列化之后。得到新的NEW_HORIZONTAL,NEW_VERTICAL. 则极大概率HORIZONTAL != NEW_HORIZONTAL，VERTICAL != NEW_VERTICAL。 因为经过序列化和反序列化之后，得到的对象就是完全新的两个对象，与之前的对象都不同。 为克隆使用序列化序列化往往可以用在深拷贝中，如JS中常用的 12let a = &#123;&#125;;let new_a = JSON.pasrse(JSON.stringify(a)); 而在Java中，也可以这样使用。原理也参见上一节的为什么不能对单例进行序列化，因为其本质就是另外的对象了，所以肯定就是深拷贝了。 操作文件PathPath在JDK7引入，其表示一个目录名序列，其后还可以跟着一个文件名。 Path对象使用Path.of()来创建。其有两个重载： public static Path of(String first, String... more) public static Path of(URI uri) 一般使用第一个方法，而其第一个参数是根目录。后面接层级的目录名字。实际也可以直接赋值目录到第一个参数。而分开的好处是Java会自动选择对应系统的分隔符来组成目录。（如UNIX文件系统时/，而Windows时\\）。 相对路径和绝对路径可以通过Path对象提供的方法来获取一个相对目录。即在Path.of的第一个参数使用&quot;path&quot;而不是&quot;\\path&quot;的方式。 Path.resolve(basePath, dir)使用Path.resolve(basePath, dir)可以查找basePath中的dir目录，并返回该目录的Path对象。 path.relative(q)path.relative(q)可以返回相对于q相对于path的相对路劲。如path = /home/harry，而q = /home/fred/input.txt。则会返回../fred/input的Path路径。 Path.resolveSibling(basePath, siblingDir)Path.resolveSibling(basePath, siblingDir)可以获取与basePath同级的siblingDir目录的Path对象。 path.normaliza()path.normaliza()将移除多余的.和..部件。如，/home/harry/../fred/./input.txt规范化后将返回home/fred/input.txt。 path.toAbsolutePath()path.toAbsolutePath()方法将返回路径的绝对地址，该绝对地址从根部件开始。如/home/fred/input.txt或c:\\User\\fred\\input.txt。 读写文件JDK7引入的Files类可以使读写普通文件更加简单。前面简单介绍了读操作 ，下面详细介绍其写API。 读文件见前文 写文件写文件主要使用以下两个API： public static Path write(...) public static Path writeString(...) 如，写一个字符串到文件： 1Files.writeString(path, content, charset); 而追加内容时，可以添加第三个参数： 1Files.write(path, content.getBytes(charset), StandardOption.APPEND); 如果内容过长的话，就该使用流的方式来处理： 12345InputStream in = Files.newInputStream(path);OutputStream out = Files.newOutputStream(path);Reader in = Files.newBufferedReader(path, charset);Writer out = Files.new BufferedWriter(path, charset);//操作流 创建文件和目录创建目录可以使用Files.createDirectory(path)来创建新目录。 如果需要创建一个嵌套目录，即自动创建中间目录，则需要使用Files.createDirectories(path)。如：要创建dir/dir1/dir2目录，但dir1并不存在，则第二个API会自动创建dir1，而第一个会报错。 创建文件可以使用Files.createFile(path)来创建一个新文件。如果文件存在则报异常。检查文件存在和创建文件是原子操作，如果文件不存在，那么文件会被创建，并且其他程序在此过程中是无法执行文件创建操作的。 创建临时目录、文件还可以使用以下API在执行位置或者系统执行位置来创建临时目和文件 public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute&lt;?&gt;... attrs) public static Path createTempFile(String prefix, String suffix, FileAttribute&lt;?&gt;... attrs) public static Path createTempDirectory(Path dir, String prefix, FileAttribute&lt;?&gt;... attrs) public static Path createTempDirectory(String prefix, FileAttribute&lt;?&gt;... attrs) 注意文件名是由系统命名的，而我们只提供前后缀。如：createTempFile(null, &quot;.txt&quot;)将在系统指定的临时文件目录创建一个诸如12231434456235423321.txt的文件。 复制、移动和删除文件复制文件可以用Files.copy(fromPath, toPath)来复制文件。 移动文件可以使用Files.move(fromPath, toPath)来移动文件。 如果目标路径已存在，那么复制或移动将会失败。如果想要覆盖已有的目标路径，可以使用REPLACE_EXISTING选项。 如果想要复制所有的文件属性，可以使用COPY_ATTRIBUTES选项。 如： 1Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING,StandardCopyOption.COPY_ATTRIBUTES); 如果要将移动定义为为原子性的，要么移动成功，要么原来的文件不变。可以使用ATOM_MOVE. 1Files.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE); 还可以价格你一个流复制到Path中，这表示想要将改输入流存储到硬盘上。类似地，还可以将一个Path复制到输出流中。可以使用以下的调用： Files.copy(inputStream, toPath) Files.copy(fromPath, outputStream) 删除文件可以使用Files.delete(path)。 但是这个API在文件不存在的时候会抛出异常。而以下方法不会存在这个问题： 1boolean deleted = Files.deleteIfExist(path); 该方法还可以用来删除空目录。 下面是一些选项 StandardOpenOption 选项描述READ用于读取而打开WRITE用于写入而打开APPEND写入时在文件末尾追加TRUNCATE_EXISTING写入时移除文件已有内容CREATE自动在文件不存在的情况下创建文件CREATE_NEW创建文件时如果文件存在则创建失败DELETE_ON_CLOSE当文件被关闭时尽“可能”的删除该文件SPARSE给文件系统一个提示，表示文件是稀疏的SYNC对数据和元数据的每次更新都必须同步的写入到存储设备中DSYNC对文件数据每次更新都必须同步的写入到存储设备中 StandardCopyOption 选项描述REPLACE_EXISTING如果目标已存在，则替换他COPY_ATTRIBUTES复制文件的所有属性ATOMIC_MOVE原子性的移动文件 获取文件信息下面的静态方法都会返回一个boolean值，表示检查路径的某个属性的结果： exists isHidden isReadable，isWritable，isExecutable isRegularFile，isDirectory，is SymbolicLink size方法会返回文件的字节数。 getOwner方法将文件的拥有者返回。（UserPrincipal对象） 用法如下： 1Files.exists(path); 而其他的基本属性将会被封装在一个BasicFileAttributes接口中。可以通过以下方式获取： 1BasicFileAttributes attributes = Files.readAttributes(path, BasicFileAttributes.class); 获取目录中的项静态的Files.list方法将会返回可以读取目录中各个项的Stream&lt;Path&gt;对象。注意该方法不会列出深层目录内容，即只列出次级目录的项。如果要看到深层的目录内容，需要使用Files.walk方法来遍历。如： 123try(Stream&lt;Path&gt; entries = Files.walk(pathRoot))&#123; //...&#125; 此外，还可以调用Files.walk(pathRoot, depth)来限制想要访问的树的深度。（默认是全部遍历） 使用目录流还有一个DirectrotyStream对象（与IntegerStream等相似），所以使用这个对象更加合理。而不是泛型的流。可以使用Files.newDirectoryStream来获取该对象。例如： 12345try(DirectrotyStream&lt;Path&gt; entries = Files.newDirectoryStream(dir))&#123; for(Path entry: entries)&#123; //... &#125;&#125; 还可以使用glob模式来过滤文件，如： 1DirectrotyStream&lt;Path&gt; entries = Files.newDirectoryStream(dir, \"*.java\") 下面是所有的glob模式 模式描述示例匹配路径组成部分中0个或多个字符（不含子目录）.java匹配跨目录边界的0个或多个字符（含子目录）.java？匹配一个字符demo?.java[…]匹配一个字符集（[0-9]、[A-F]、[!0-9]）demo[0-9].java{…}匹配由逗号隔开的多个可选项之一*.{java, class}\\转译上述任意模式中的字符以及\\字符 ZIP文件系统Path类会在默认文件系统中查找路径，即在用户本地磁盘中的文件。而还有别的文件系统，例如ZIP文件系统。例如： 1FileSystem fs = FileSystem.newFileSystem(Path.of(zipname), nmull); //zipname为默认文件系统中的zip文件名 接下来需要获取ZIP文件系统中的Path则可以使用fs.getPath(sourceName)的方式，如下是一个复制操作。 1Files.copy(fs.getPath(sourceName), targetPath); 而fs.getPath就与默认文件系统中的Path.of类似。 内存映射文件大多数操作系统都可以利用虚拟内存实现将一个文件或者文件得到一部分“映射”到内存中。然后这个文件就可以被当成内存数组的一部分来访问，这比传统的文件操作要块很多。 其主要是FileChannel类。基本操作如下： 1FileChannel channel = FileChannel.open(path, options); 然后通过调用FileChannel类的map方法熊这个通道中获得一个ByteBuffer。 我们可以指定映射文件区域与映射模式。支持的模式有3种： FileChannel.MapMode.READ_ONLY：所产生的缓冲区是只读的，任何对该缓冲区写入的尝试都会导致ReadOnlyBufferException。 FileChannel.MapMode.READ_WRITE：所产生的缓冲区可读可写，任何修改都会在某个时刻写入到问家中。（注意，这个修改并不是即时的） FileChannel.MapMode.PRIVATE：所产生的缓冲区可读可写，但是任何的修改都不会传播到文件中，其是私有的。 一旦拥有了缓冲区，就可以使用ByteBuffer类和Buffer超类的方法来读写数据了。 如： 123456789Path path = Path.of(\"E:\\\\a.txt\");try &#123; FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.CREATE_NEW); MappedByteBuffer buffer = fileChannel.map(MapMode.PRIVATE, 100, 0); //buffer has gotten&#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; 缓冲区支持顺序和随机数据访问，可以通过get和put来操作数据。例如： 123while(buffer.hasRemaining())&#123; byte b = buffer.get();&#125; 123for(int i = ol i &lt; buffer.limit(); i++)&#123; byte b = buffer.get(i);&#125; 此外，buffer还提供了 get(Int|Long|Short|Char|Float|Double) put(Int|Long|Short|Char|Float|Double) 来进行确定的操作。 在恰当的时机、通道关闭或者调用force方法的时候，会将这些修改回写到文件中。 文件加锁机制当多个进程同时要修改一个文件的时候，则两个进程之间必须存在交互来确保文件不随意被修改。所以为文件提供了加锁的机制。有以下几个API可供使用： FileChannel.lock()：会阻塞调用，知道获得锁。 FileChannel.tryLock()：将立即返回，要么返回锁；要么在锁不可获得情况下返回null。 FileChannel.lock(long start, long size, boolean shared)：与1一致，不过是锁定文件的一部分。 FileChannel.tryLock(long start, long size, boolean shared)：与2一致，不过是锁定文件的一部分。 shared参数表示是否是一个共享锁。如果为false，则表示是一个独占锁。而如果是true，则是一个共享锁，允许多个进程从文件中读入，并阻止任何进程获得独占的锁。单并非所有的操作系统都支持共享锁，因此可能获得的是独占锁。此时可以调用FileLock类的isShared方法来确定是否支持共享锁。 这个文件将保持锁定状态，直到通道关闭或者在锁上调用release方法。 文件共享锁可以使用try...Resource语句。 如： 123try(FileLock lock = channel.lock())&#123; //access the locked file or segment&#125; 注意 在某些操作系统中，文件加锁仅仅是建议性的，如果一个应用未获得锁，它依旧可以被另外一个应用并发锁定的文件执行写操作。 在某些操作系统中，不能在锁定一个文件的同时将其映射到内存中。 文件锁是由整个Java虚拟机持有的。如果两个应用由同一个虚拟机启动，那么他们不可能每一个都获得一个在同一个文件上的锁。当调用lock和tryLock方法，如果虚拟机已经在同一个文件上持有了另外一个重叠锁，那么这两个方法将会抛出OverlappingFileLockException。 在一些系统中，关闭一个通道会释放由Java虚拟机持有的底层文件上的所有的锁。因此，在同一个锁定文件上应避免使用多个通道。 在网络文件系统上锁定文件高度依赖于系统的，因此应该尽量避免。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"输入与输出","slug":"输入与输出","permalink":"http://yoursite.com/tags/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"}]},{"title":"java核心技术-II-1-Java8的流库","slug":"java核心技术-II-1-Java8的流库","date":"2022-02-14T15:22:15.000Z","updated":"2022-02-14T03:55:00.833Z","comments":true,"path":"2022/02/14/java核心技术-II-1-Java8的流库/","link":"","permalink":"http://yoursite.com/2022/02/14/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-1-Java8%E7%9A%84%E6%B5%81%E5%BA%93/","excerpt":"","text":"迭代与流与集合相比，流提供了一种可以让我们在更高的概念级别上指定任务的数据视图。 流提供了几种操作函数，其调用要比一般的迭代更加简洁。并且其可以链式调用，每一次调用都返回一个新的流对象。 如：统计一个List中长度大于12的单词数量。 迭代123456int count = 0;for(String w : words)&#123; if(w.length() &gt; 12)&#123; count++; &#125;&#125; 流1long count = words.stream().filter(w -&gt; w.length() &gt; 12).count(); 流与集合的差异 流并不存储其元素。这些元素可能存储在底层的集合中，或者是按需生成的。 流的操作并不会修改其数据源。如filter方法不会从流中移除元素，二十会生成一个新的流，其中不包含过滤掉的元素。 流的操作是尽可能惰性执行的。这意味着直至需要其结果时，操作才会执行。例如，如果只是想查找前5个单词而不是所有的单词，那么filter方法会在匹配到第5个单词后就停止过滤。因此，我们甚至可以操作无限流。 流的创建从集合Collections接口创建流对于实现了Collection接口的类。可以使用Stream.of方法来获得一个接口。详见java核心技术-I-9-集合 如： 12345ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();arrayList.add(\"apple\");arrayList.add(\"banana\");arrayList.add(\"pear\");Stream stream = arrayList.stream(); 从数组生成Stream用所有元素生成Stream如果要用所有的数组元素来生成一个Stream，则可以使用Stream.of 如： 12String[] arr = &#123;\"apple\", \"banana\", \"pear\"&#125;; Stream stream1 = Stream.of(arr); 用部分数组元素（连续）生成Stream如果只需要数组的一部分元素（连续）生成Stream，则可以使用Array.stream(array, from, to)。 如： 12String[] arr = &#123;\"apple\", \"banana\", \"pear\"&#125;; Stream stream2 = Arrays.stream(arr, 0, 1); 直接从基本元素生成Stream可以通过Stream.of来将基本元素转变为Stream。 如： 1Stream stream2 = Stream.of(\"apple\", \"banana\"); 创建一个空流可以通过Stream.empty()来生成一个不包含任何元素的流。 如： 1Stream&lt;String&gt; silence = Stream.empty(); 创建一个无限流可以通过Stream.generate(FunctionInterface)来获取一个无线流，其来源是参数中的函数式接口。 如-通过一个字符串创建流： 1Stream&lt;String&gt; echos = Stream.generate(() -&gt; \"Echo\"); 如-通过随机函数来获取一个包含无限随机数的流： 1Stream&lt;Double&gt; echos = Stream.generate(Math::random); 创建一个无线的序列流可以通过Stream.iterate(Iterable)来通过迭代器创建一个指定的序列流。 如： 1Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE)); 创建一个长度仅为0或1的流通过Stream.ofNullable(T t)方法可以创建一个长度仅为0或1的流。当参数t为null时，则长度为0，否则长度为1，即是包含该对象。 注意值得注意的是，在执行流的操作的时候，我们并没有修改流背后的集合。但是如果手动修改了流的集合（指在流操作外部修改，在流操作，比如forEach中，则会报错），那么流的操作就会变成不可预知的。JDK文档称之为不干涉性。 操作filter(Predicate&lt;T&gt;)filter函数会按照参数中的函数式接口来过滤所有元素。然后将符合条件的元素组合为新的流返回。 如-过滤所有长度大于12的单词： 12List&lt;String&gt; words = ...;Stream&lt;String&gt; longWords = words.stream().filter(w -&gt; w.length() &gt; 12); 注意filter的参数为一个Predicate&lt;T&gt;函数式接口。即从T到Boolean的函数。 map(FunctionInterface)map(FunctionInterface)会对流中的每个元素应用参数的函数式接口。并且将所有的结果组合为一个新的流返回。 如-截取所有单词的首字母： 12List&lt;String&gt; words = ...;Stream&lt;String&gt; firstLetter = words.stream().map(s -&gt; s.substring(0, 1)); flatMap(FunctionInterface)flatMap(FunctionInterface)是对流中的每个元素应用参数的函数式接口（其都返回一个流），然后将每个参数的返回值组合为一个流。 如codePoints(&quot;boat&quot;)返回的流是[&quot;b&quot;, &quot;o&quot;, &quot;a&quot;, &quot;t&quot;] 所以Stream&lt;Stream&lt;String&gt;&gt; result = words.stream().map(w -&gt; codePoints(w))会返回一个流的嵌套。[...[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]] 而使用Stream&lt;Stream&lt;String&gt;&gt; result = words.stream().flatMap(w -&gt; codePoints(w))会返回一个所有子流的组合流，即[..., &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] stream.limit(n)stream.limit(n)会截取流中的前n个元素（如果其长度小于n，则会返回流中的全部元素组成的新流）。 这个方法可以用于裁剪无限流。 如-获取100个随机数的流 1Stream&lt;Double&gt; randoms = Streams.generate(Math::random).limit(100); stream.skip(n)stream.skip(n)方法正好相反，其会丢弃前n个元素。 如-跳过单词表中的前5个元素 1Stream&lt;String&gt; newWords = words.stream().skip(5); stream.takeWhile(predicate)stream.takeWhile(predicate)会在谓词为真时获取该元素。 如-收集分割字符串中的所有数字元素 1Stream&lt;String&gt; initialDigits = codePoints(str).takeWhile(s -&gt; \"0123456789\".contains(s)); stream.takeWhile(predicate)takeWhile方法正好相反，他会在条件为真的时候丢弃元素。 如-收集分割字符串中的所有非数字元素 1Stream&lt;String&gt; initialDigits = codePoints(str).dropWhile(s -&gt; \"0123456789\".contains(s)); Stream.concat(Stream stream1, Stream stream1)与字符串一样，conact方法可以将两个流的元素连接在一起。 1Stream&lt;String&gt; s = Stream.concat(codePoints(\"hello\"), codeoPints(\"world\")); stream.disinct()stream.disinct()会将原流中的重复元素剔除之后，返回一个新的无重复元素的流。 如：剔除重复字母 12Stream&lt;String&gt; s = Stream.of(\"a\", \"b\", \"c\", \"b\", \"a\").disinct();//[\"a\", \"b\", \"c\"] stream.sorted(comparator)与其他集合排序一样，流的排序也是接受一个comparator。其会根据这个comparator，返回排序后的元素。 如-将最长的字符串排在前面 1Stream&lt;String&gt; longsFirst = words.stream().sorted(Comparator.comparing(String::length).reverse()); stream.peek(FunctionInterface)stream.peek(FunctionInterface)的即预览这个流的元素，但是并不会将其取出。（其本质是生成一个新的流，然后获取新流中的元素，所以原来的流并无变化）然后对这个元素应用参数的函数式接口。 如-打印流中的元素 1Stream&lt;String&gt; s = Stream.of(\"a\", \"b\", \"c\", \"b\", \"a\").peek(e -&gt; System.out.println(\"item-\" + e)); 简单约简（注意以前方法均返回Option对象，将在下一章介绍）通过约简可以获得通过前面处理的流的指定结果。约简是一种终结操作，他们会将流约简为可以在程序中使用的非流值。 其有以下API： stream.max(comparator)通过比较器返回流中最大的元素。 stream.min(comparator)通过比较器返回流中最小的元素。 stream.findFirst()返回流中的第一个元素。如果流为空，则返回空的Option对象。 stream.findAny()返回流中的任意一个元素。如果流为空，则返回空的Option对象。 stream.anyMatch(predicate)流中的是否存在一个元素满足给定谓词。 stream.allMatch(predicate)流中是否所有元素是否都满足给定谓词。 stream.noneMatch(predicate)流中是否没有元素满足给定谓词。 Optional类型Optional&lt;T&gt;对象是一种包装器对象，其可能包装了T对象或者没有包装任意对象。其被视为更安全的方式，用来替代类型T的引用。 获取Optional值其有3个方法来获取Opitons的值。 Opions.orElse(T t)该方法会在options存在值的时候返回该值，否则返回传递的t。 Options.orElseGet(FunctionInterface)该方法会在options存在值的时候返回该值，否则返回传递的函数参数调用的结果。 Options.orElseThrow(exceptionSupplier)该方法会在options存在值的时候返回该值，否则抛出传递参数的异常。 消费Optional值除了直接获取optional包装的值，还可以接受一个函数接口，让函数接口直接处理该函数。 optional.ifPresent(Consumer action) 该方法会在值存在的情况下，将其传递给参数函数。否则不会有任何效果。 optional.ifPresentOrElse(Consumer action, Runnable emptyAction)该方法会在值存在的情况下，将其传递给第一个参数函数；否则会调用第二个空的处理方法。 管道化Optional值管道化即获取optional的值，但不消费。可以使用与管道相似的方法来操作Optional对象，同时返回一个新的0ptional对象。此时可以将Optional对象看为一个长度为0或1的流。 其有以下3个API： optional.map(FunctionInterface)通过参数函数处理原optional对象的值。然后返回新的Oprtional对象。 optional.filter(predicate)若原Optional的值满足给定谓词，就返回一个新的一样值的Optional对象，否则，返回一个空的Optional对象。 Optional.or(supplier)如果当前Optional对象不为空，则产生当前的Optional，否则由supplier产生一个Optional。 用flatMap构建Optional值的函数flatMap会在Optional包装部位空时，产生将mapper应用于当前Optional值所产生的结果，或者在当前Optional为空时，返回一个空Optional。 由于Opional&lt;T&gt;是一个包装类型，所以无法直接调用T的相关方法。而可以使用flatMap来直接获取到包装类内部的值。并且调用其方法，然后返回。 如： 类型S有一个f方法来产生一个Optional&lt;T&gt;对象。 类型T有一个g方法来产生一个Optional&lt;U&gt;对象。 为我们无法使用s.f().g()来获得Optional&lt;U&gt;对象。 但是我们可以使用下面的方式来获取该对象： 1Optional&lt;U&gt; res = s.f().flatMap(T::g); 将Optional转换为流通过optional.stream()可以将Optional值转变为一个长度为0或1的流。 TIPS Optional类型的便利永远都不应该为null； 不要使用Optional类型的域。因为其代价是额外多出来一个对象。在累的内部，使用null表示缺失的域更易于操作。 不要在集合中放置Optional对象，并且不要将他们作为map的key。应该直接收集其中的值。 收集结果当处理完流之后，通常需要查看其结果。则可以通过以下方法来查看内部元素。 stream.iterator可以使用stream.iterator来生成一个迭代器，则可以按照普通的迭代器方法来查看内部元素。 stream.forEach(Comsumer action)可以通过stream.forEach来直接遍历流中的元素。 stream.forEachOrdered(Comsumer action)使用该方法遍历时，此时会完全按照流中的顺序。但会丧失并行处理的部分甚至全部优势。 stream.toArray(Constructor)调用此方法会返回一个数组，如果不传递参数，则返回Object[]，需要强转。其参数为对应类型的构造函数，此时可以返回对应类型的数组。 如： 123Stream&lt;Integer&gt; s = Stream.of(1, 2, 3, 4);Object[] objArr = s.toArray();Integer[] intArr = s.toArray(Ingeter::new); stream.toList()此方法会返回一个List用于查看内容。 如： 12Stream&lt;Integer&gt; s = Stream.of(1, 2, 3, 4);List&lt;Integer&gt; strings = stream1.toList(); stream.collect(Collector collector)可以通过该方法将流中的元素收集到指定的集合中。其中Collector collector一般是通过Collectors.toXXX()或者Collectors.toCollection(XXX:new)来获取。 如： 1-收集到List（与上面的API作用相同） 1List&lt;String&gt; res = stream.collect(Collections.toList()); 2-收集到Set 1Set&lt;String&gt; res = stream.collect(Collectors.toSet()); 3-收集到指定的集合 1TreeSet&lt;String&gt; res = stream.collect(Collectors.toCollection(TreeSet::new)); 收集到字符串还可以通过stream.collect收集到一个字符串。关键是collector必须是一个Collectors.join()产生的。 例如： 12String res = stream.collect(Collectors.join()); //不加间隔符String res = stream.collect(Collectors.join(\",\")); //间隔符为, 如果流中除字符串外还包含其他对象，那么我们需要先将其转化为字符串。 如： 1String res = stream.map(Object::toString).collect(Collectors.join(\", \")); 收集到映射表假设流中的对象是一个Person对象，而我们要将其收集到映射表中，key为Person.id；value为Person.name。 则可以使用Collectors.toMap()方法。该方法接受两个参数，用来产生映射表的键和值。 如： 1Map&lt;Integer, String&gt; idToName = people.collect(Collectors.toMap(Person::getId, Person::getName)); 如果需要获取对象本身，则使用Funciton.identity()。即返回的是流中的类型元素T。 如： 1Map&lt;Integer, Person&gt; idToPerson = people.collect(Collectors,toMap(Person::getId, Function.identity)); 嵌套集合假如要收集每个国家支持的语言。则我们需要一个Map&lt;String, Set&lt;String&gt;&gt;，此时我们由该如何直接从流中获取呢。 此时的Collectors.map需要3个参数： key值。 指定value的值。 组合set的函数 例如： 1234567891011Map&lt;String, Set&lt;String&gt;&gt; countryLang = locales.collect( Collecotors.toMap( locale::getDisplayCountry, l -&gt; Collectors.singleton(l.getDisplayLanguage()), (a, b) -&gt; &#123; var union = new HasSet&lt;String&gt;(a); union.addAll(b); return union; &#125; )); 如果需要使用TreeMap，则需要将其构造器TreeMap::new指定为第4个参数。 组群和分组上面嵌套集合的方式可以使用组群和分区更简洁的解决。 Collectors.groupingBy()如： 123Map&lt;String, List&lt;Locale&gt;&gt; countryToLocales = locales.collect( Collectors.groupingBy(Locale::getCountry)); 其中函数Locale::getCountry是组群的分类函数。 Collectors.partitioningBy()当分类函数是一个断言函数（即返回Boolean值的函数），流的元素可能分为两个列表。该函数返回true的元素和其他元素。 如：将locale分成了使用英语和使用其他所有语言的两类： 1234Map&lt;Boolean, List&lt;Locale&gt;&gt; englishAndOther = locales.collect( Collectors.partitioningBy(l -&gt; l.getLanguage().equals(\"en\")));List&lt;Locale&gt; englishLocales = englishAndOther.get(true); 下游收集器groupingBy方法会产生一个映射表，其每个值都是一个列表。如果想要以某种方式来处理这些列表，则需要下游收集器。 Collectors.counting()Collectors.counting()会产生收集到的元素的个数。 如： 1Map&lt;String, lOng&gt; countryToLocaleCounts = locales.collect(groupBy(Locale::getCountry, Collectors.counting())); 可以对每个国家有多少个local进行计数。 Collectors.summing(Int|Long|Double)()上面的方法会返回收集到的数据的和。 如： 123Map&lt;String, Integer&gt; stateToPopulation = cities.collect( groupingBy(City::getState, Collectors.summingInt(city::getPopulation));) 可以计算城市流中每个州的人口总和。 Collectors.maxBy&amp;&amp;Collectors.minBy以上两个方法会接受一个比较器，并分别产生下游元素中的最大值和最小值。 如： 123456Map&lt;String, Optional&lt;City&gt;&gt; stateToLargestCity = cities.collect( groupingBy( City::getState, Collectors.maxBy(Comparator.comparing(City::getPopulation)) )); Collectors.collectAndThen该收集器会在收集器后面添加一个最终处理步骤。例如，我们想要知道有多少种不同的结果，那么就可以将他们收集到一个集合中，然后计算其尺寸： 12345Map&lt;Character, Integer&gt; stringCountByStartingLetter = strings.collect( groupingBy(s -&gt; s.charAt(0), Collectors.collectAndThen(toSet(), Set::size) )); Collectors.mappingCollectors.mapping与Collectors.collectAndThen相反，他会将参数函数应用于收集到的每个元素，并将其结果传递给下游收集器。 如：按照首字母进行收集，咋子每个分组内部，计算字符串的长度并将其传递给下游收集器： 123456Map&lt;Character, Set&lt;Integer&gt;&gt; stringLengthByStartingLetter = strings.collect( groupingBy( s -&gt; s.charAt(0), Collectors.mapping(String::length, toSet()) )); Collectors.flatMap此处作用也是一致，可以将每个组结果返回的结果进行铺平。 Collectors.filteringCollectors.filtering会将过滤器应用到每个组上的元素中，如： 123456Map&lt;String, Set&lt;City&gt;&gt; largeCitiesByState = cities.collect( groupingBy(City::getState, filtering(c -&gt; c.getPopulation() &gt; 5000000), toSet() )) TIPS将收集器组合起来是一种很强大的方式，但是它也可能会导致产生非常复杂的表达式。最佳用法是与groupingBy和partitioningBy一起处理下游的映射表中的值。否则，应该直接在流上应用诸如map、reduce、count、max和min这样的方式。 约简操作reduce方法是一种用于从流中计算某个值的通用机制。其有3个重载。 Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);其接受一个二元表达式，其第一个操作符为上一次调用该表达式的返回值（首次为第一个元素）。 如：对一个流求和： 123List&lt;Integer&gt; values = ...;Options&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y); //v1 + v2 + v3+...Options&lt;Integer&gt; sum = values.reduce(Intger::sum); //效果一样 T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);与上面用法相同，只是首次的元素会被替换为identity。 12List&lt;Integer&gt; values = ...;Options&lt;Integer&gt; sum = values.reduce(1, (x, y) -&gt; x + y); //1 + v1 + v2 + v3 +... &lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);这种形式用于当我们需要统计流中元素的某个属性进行约简操作时。其中BiFunction用于累加操作，而accumulator用于合并并行处理的结果。 如： 1234int res = words.reduce(0, (total, word) -&gt; total + word.length, (total1, total2) -&gt; total1 + total2 ); 基本类型流与基本类型的包装类相似，流对于基本类型也有对应的基本类型流： IntStream：Integer, Short, Char, Byte, Boolean LongStream：Long DoubleStream：Double, Float 与对象流一样，我们还可以使用静态的generate和iterate方法。 此外，IntStream和LongStream有静态方法range和rangeClosed，可以生成步长为1的整数范围（后者包含上限）。 如： 12IntStream zeroToNinetyNine = IntStream.range(0, 100); //0-99IntStream zeroToHundred = IntStream.range(0, 100); //0-100 基本流与对象流的转化对象流转基本流可以使用stream的mapToInt，mapToLong，mapToDouble来将其转换为基本流，可以将原流中的属性转化为新的基本流。 如：将单词的长度转化为新的IntStream 12Stream&lt;String&gt; words = ...;IntStream lengths = words.mapToInt(String::length); 基本流转对象流可以使用boxed方法转化为对象流。 如： 1Stream&lt;Integer&gt; integers = IntStream.range(0, 100).boxed(); 特点 toArray方法会返回对应的基本类型数组。（注意：虽然上面提到IntStream可以存储Integer, Short, Char, Byte, Boolean，但是仍然返回的是intt[]）。 产生可选结果的方法会返回一个OptionalInt、OptionalLong或OptionalDouble。这些方法与Optional相似，但是具有getAsInt，getAsLong、getAsDouble方法，而不是get方法。 具有分别返回总和、平均值、最大值和最小值的sum、max和min方法。对象流没有定义这些方法。 summaryStatistics方法会产生一个类型为IntSummaryStatistics、LongSummaryStatistics和DoubleSummaryStatistics的对象，他们可以同hi报告流的总和、数量、平均值、最大值和最小值。 并行流流时并行处理块操作变的容易。整个过程几乎是自动的。 创建并行流Collection.parallelStream()可以使用Collection.parallelStream()方法从任何集合中获取一个并行流。 如： 1Stream&lt;String&gt; parallelWords = words.parallelStream(); stream.parallel()对于现有的流，可以通过stream.parallel()来获取一个并行流。 如： 1Stream&lt;String&gt; parallelWords = Stream.of(wordArray).parallel(); 相关注意点只要在终结方法执行时流处于并行模式，所有的中间流操作都将被并行化。 只要是并行就会存在竞态的问题。 如下面的例子就是有问题的： 123456var shortWords = new int[12];words.parallelStream().forEach( s -&gt; &#123; if(s.length() &lt; 12) shortWords[s.length()]++; &#125;); 因为shortWords会被传递到多个线程中，这就会存在竞态的问题，所以不能得到预期的结果。 排序并不排斥高效的并行处理。例如，当计算Stream.map(fun)时，流可以被划分为n部分，它们会被并行的处理。然后结果会按照顺序重新组装起来。 stream.unordered当然，如果不需要排序的需求，并行操作的性能将会得到很大的提升。此时可以通过stream.unordered方法来标记对顺序没有要求。 例如stream.instinct就会从中获得更高效率，原因是不用考虑哪一个相同的元素将会被保留。 TIPS 并行化会导致大量的开销，只有面对非常大的数据集才划算。 只有在底层的数据源可以被有效地分割为多个部分时，将流并行化才有意义。 并行流使用的线程池可能会因诸如文件I/O或者网络访问这样的操作被阻塞而饿死。 只有面对海量的内存数据和运算密集处理，并行流才会工作最佳。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"Java8的流库","slug":"Java8的流库","permalink":"http://yoursite.com/tags/Java8%E7%9A%84%E6%B5%81%E5%BA%93/"}]},{"title":"java核心技术-I-12-并发","slug":"java核心技术-I-12-并发","date":"2022-01-24T05:51:06.000Z","updated":"2022-01-26T05:51:52.308Z","comments":true,"path":"2022/01/24/java核心技术-I-12-并发/","link":"","permalink":"http://yoursite.com/2022/01/24/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-12-%E5%B9%B6%E5%8F%91/","excerpt":"","text":"线程的概念 在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。 后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。 下面是一个Java中创建线程的代码： 将执行这个代码的任务放在一个类的run 方法中。注意这个类必须实现Runnable接口： 123public interface Runnable&#123; void run();&#125; 由于Runnable是一个函数式接口，因此可以用一个lambda表达式创建一个类： 1Runnable r = () -&gt; &#123;task code&#125;; 从这个Runnable构造一个Thread对象。 1var t = new Thread(r); 启动线程 1t.start(); 注意：不要直接调用Thread或者Runnable对象的run方法。否则其只会在同一个线程中执行这个任务，而没有启动新的线程。 例如：银行转账的例子： 1234567891011121314Runnable r = () -&gt; &#123; try&#123; for(int i = 0; i &lt; STEPS; i++)&#123; double amount = MAX_AMOUNT * Math.random(); bank.tanfor(0, 2, amount); Thread.sleep((int) (DELAY * Math.random())); &#125; &#125;catch(Interruption e)&#123; &#125;&#125;var t = new Thread(r);t.start(); 对于给定的步骤数，这个线程会转账一个随机金额，然后休眠一个随机时常。 线程状态Java中的线程有以下6种状态： New-新建 Runnable-可运行 Blocked-阻塞 Waiting-等待 Timed waiting-计时等待 Terminated-终止 要确定当前进程的状态，只需调用getState方法。 新建线程当使用new操作符创建一个新线程时，如new Thread(r)，这个线程哈没有开始要运行。此时其状态就是新建new。 可运行线程一旦调用start操作，线程就处于可运行（runnbale）状态。但是一个可运行的线程可能正在运行，也可能没有运行。要由操作系统为线程提供具体的运行时间。 一个线程开始运行，它不一定始终保持运行。因为可能不同的操作紫铜调度机制不一样，可能存在抢占式。 阻塞和等待线程当线程处于阻塞或等待状态时，他暂时是不活动的。期间不运行任何代码，而且消耗最少资源。要由线程调度器重新激活这个线程。 当一个线程试图获取一个内部的对象锁，而这个锁母亲被其他线程占有，该线程就会被阻塞。当其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，它将变成非阻塞的。 当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。实际上，阻塞状态和等待状态并没有很大区别。 有几个方法有超时参数，调用这写方法时会让线程进入计时等待（timed waiting）状态，这一状态会一直保持到超时期满或者接收到适当的通知时。 下面时各种状态的转换图： 终止线程线程会由于以下两个原因之一而终止： run方法正常退出，线程自然终止。 因为一个没有捕获的异常终止了run方法，使线程意外终止。 另外线程的stop方法也可以手动杀死一个线程。但是该方法已经被废除，最好不要使用。 线程的属性线程的各种属性包括中断的状态、守护线程、未捕获异常的处理器以及不应使用的一些遗留特征。 终端线程如上终止线程所说，只有run方法自然退出，或因为异常不正常退出才能终止线程。 除了已经废除的stop方法，没有办法可以强制线程终止。 不过，interrupt方法可以用来请求终止一个线程。 当对一个线程调用interrupt方法时，就会设置线程的中断状态。这是每个线程都有的boolean状态。每个线程都应该不是地检查这个标志，以判断这个线程是否被中断。 但是当线程处于阻塞时，无法检测中断状态。 没有任何语言要求被中断地线程应该被终止。中断一个线程只是要引起它地注意。被中断的线程可以决定如何响应中断。某些线程非常重要，所以应当处理这个异常，然后在继续执行下去。但是，更普遍的情况时，线程只希望将中断解释为一个中断请求。其格式如下： 1234567891011121314Runnable r = () -&gt; &#123; try&#123; //... while(!Thread.currentThread().isInterrupeted() &amp;&amp; more works to do)&#123; //do more work &#125; &#125; catch(InterrutedException e)&#123; //thread was interrupted during sleep or wait &#125;finally&#123; //clean up if required &#125; // existing the run method terminated the thread.&#125; 线程名默认情况下，线程有容易记的名字，如Thread-2。 可以用setName方法为线程设置任何名字： 12var t = new Thread(runnable);t.setName(\"Web crawler\"); 未捕获异常的处理器现场的run方法不能抛出任何检查型异常，但是，非检查型异常可能会导致线程终止。这种情况下，线程会死亡。 不过，对于可传播的异常，并没有任何catch子句。实际上，在线程死亡之前，异常会传递到一个用于处理未捕获异常的处理器。 这个处理器必须属于一个实现了Thread.UncaughtExceptionHandler接口的类。这个接口只有一个方法： 1void uncaughtException(Thread t, Throwable e); 可以用setUncatchExceptionHandler方法为任何线程安装一个处理器。 也可以用Thread类的静态方法serDefaultsetUncatchExceptionHandler为所有线程安装一个默认的处理器。（这些处理器可以将异常信息保存到文件中。） 如果没有安装默认处理器，默认处理器则为null。但是，如果没有为单个线程安装处理器，那么处理器就是该线程的ThreadGroup对象。 线程组（ThreadGroup）是可以一起管理的线程的集合。默认情况下，所有的线程都属于同一个线程组，但是也可以建立其他的组。由于现在引入了更好的特性来处理线程集合，所以不建议再使用线程组。 ThreadGroup类实现了Thread.UncaughtExceptionHandler接口。它的uncatchException方法执行一下操作： 如果该线程组有父线程组，那么调用父线程组的uncatchException方法。 否则，如果Thread.getDefaultExceptionHandler方法返回一个非nul的处理器，则调用该处理器。 否则，如果Throwable是ThreadDeath的一个实例，什么也不做。 否则，将线程的名字以及Throwable的轨迹输出到System.err。 线程优先级在Java程序设计语言中，每个线程都有一个优先级。其优先级有10级，从1（MIN_PRIORITY）到10(max_priority)。其默认为5（NORM_PRIORITY）。 每当线程调度器有机会选择新线程时，它会首先选择具有较高优先级的线程。但实际的线程优先级会根据操作系统的优先级。比如Windows有7个优先级。而Linux的线程则所有线程优先级都一样，所以会忽略线程优先级。 同步在大多数实际的多线程应用中，两个或两个以上的新线程需要共同修改同一数据。而不同的调用顺序会导致不同的结果。这种情况通常被称为竞态条件（race condition）。 锁对象有两种机制可以防止并发的访问代码块。 使用synchronized关键字：会自动提供一个锁以及相关的“条件”。 使用Java5引入的ReentrantLock类。 使用ReentrantLock保护代码块的基本结构如下： 1234567var mylock = new ReentrantLock(); //新建锁对象，一般在其他位置myBlock.lock(); //a ReentrantLock objecttry&#123; //critical section&#125;finally&#123; mylock.unlock();&#125; 这个结构确保任何时候只有一个线程进入临界区。一旦一个线程锁定了锁对象，其他任何线程都无法通过lock语句。 要把unlock语句操作包括在finally语句中，这一点很关键。如果在临界区的代码抛出一个异常，锁必须释放。否则，其他线程将永远阻塞。 值得注意的是： 锁不能使用try-with-resources语句。其原因在于： 解锁方法不是close。 try-with-resources期望的是一个新变量且在首部声明，而锁变量不是。 重入锁（reentrant lock），每个对象都拥有唯一的锁。并且每个线程可以反复获得已拥有的锁。锁有一个持有计数（hold count）来跟踪对lock方法的嵌套调用。线程每调用一次lock后都要调用unlock来释放锁。 条件对象通常，线程进入临界区后却发现只有满足了某个条件之后它才能执行。可以使用一个条件对象来管理那些已经获得一个锁却不能做有用工作的线程。在Java中，条件对象被称为条件变量（conditional variable）。 即当一个线程拥有锁，但是却仍然不能运行（可能缺少其它资源），那么此时这个线程应当放弃这个锁。其实就是防止产生死锁。 例如转账中，当发现账户余额不足的时候，应当放弃这个账户的锁。代码如： 12345678class Bank&#123; private Condition stuffcientFunds; //... public Bank()&#123; //... sufficientFunds = bankLock.newCondition(); //关键 &#125;&#125; 此时如果transfer方法发现资金不足，他会调用： stuffcientFunds.await(); 当前线程现在暂停，并放弃锁。这就允许另一个线程来拥有这个锁，从而防止死锁。 一旦一个线程调用了await方法，他就进入这个条件的等待集（wait set）。当锁可用时，该线程也不会立即变为可运行状态。实际上，他仍然保持非活动状态，知道另一个线程在同一条件上调用signalAll方法。 即，当另外一个线程完成转账时，它应该调用 1stuffcientFunds.signalAll(); 这个调用会重新激活等待这个条件的所有线程。 此时，线程应当再次测试。不能保证现在一定满足条件-signalAll方法仅仅是通知等待的线程：现在有可能满足条件，值得再次检查条件。 通常，await调用应该放在如下形式的循环中： 12while(!(process is ok)) condition.await(); 注意signalAll调用不会立即激活一个等待的线程，它只是接触等待线程的阻塞，是这些线程可以在当前线程释放锁之后竞争访问对象。 另一个signal只是随机选择等待集合中的一个线程，并且解决这个线程的阻塞状态。这个方法虽然高效，但也是危险的，因为可能释放的那个线程可能仍然是不能运行的。 注意：只有当线程拥有一个条件的锁时，它才能在这个条件上调用await，signalAll和signal方法。 synchronized关键字在了解synchronized关键字之前，先对锁和条件的要点做一个总结： 锁用来保护代码片段，一次只能有一个线程执行被保护的代码。 锁可以管理试图进入被保护代码段的线程。 一个锁可以有一个或多个相关联的条件对象。 每个条件对象管理那些已经进入被保护代码段但还不能运行的线程。 Lock和Conditon接口允许程序员充分控制锁定。不过，在大多数情况下，你并不需要那样控制，玩去哪可以使用Java语言内置的一种机制。从1.0开始，Java中的每个对象都有一个内部锁。如果一个方法声明时有synchronized方法修饰符，那么对象的锁将保护整个对象。也就是说，要调用这个方法，线程必须获得内部对象锁。 换句话说： 123public synchronized void method()&#123; //method body&#125; 等于 12345678public void method()&#123; this.intrinsicLock.lock(); try&#123; //method body &#125;finally&#123; this.intrnsicLock.unlock(); &#125;&#125; 内部对象锁只有一个关联条件。wait方法将一个线程增加到等待集中，notifyAll/notify方法可以解除等待线程的阻塞。换句话说，调用wait或notifyAll等价于： 12intrinsicCondition.await();intrinsicCondition.signalAll(); 注释：wait，notifyAll以及notify方法是Object类的final方法。Condition方法必须命名为await、signalAll和signal，从而不会与那些方法发生冲突。 例如，可以用Java如下实现Bank类： 1234567891011class Bank&#123; private double[] accounts; public synchronized void transfer(int from, int to, int amount) throws InterruptedException&#123; while(accounts[from] &lt; amount) wait(); //wait on intrinsic object lock`s single condition accounts[from] -= amount; accounts[to] += amount; notifyAll(); //notify all the threads waiting on the condition &#125;&#125; 可以看到，使用synchronized关键字可以得到更为简洁的代码。 要理解这段代码，必须明白每个对象都有一个内部锁，并且这个锁有一个内部条件。这个锁管理试图进入synchronzed方法的线程，这个条件可以管理调用了wait的线程。 将静态方法声明为同步也可以是合法的。如果调用这样的方法，它会获得相关类对象的内部锁。并且其内置锁会被锁定。因此，没有其他线程可以调用这个类的该方法或任何其他同步静态方法。 内部锁和条件存在一些限制： 不能中断一个正在尝试获得锁的线程。 不能指定尝试获得锁时的超时时间。 每个锁仅有一个条件可能是不够的。 那么在代码中应该使用哪种方式呢，Lock和Condition对象还是synchronized关键字呢？建议如下： 最好既不是用Lock和Condition对象，也不是使用synchronized关键字。在多数情况下，可以使用java.util.concurrent包中的某种机制，他会自动处理所有的锁定。（在卷II第I章介绍） 如果synchronized关键字可以满足需求，则使用synchronized关键字，这样可以减少代码量也可以减少错误。 如果特别需要Lock和Condition结构提供的额外能力，则使用Lock/Condtion。 同步块正如前面说的，每一个Java都有一个锁。线程可以通过调用同步方法获得锁。还有另外一种方式获得锁：即进入一个同步块。 形式如下： 123synchronized (obj)&#123; //critical section&#125; 其内部的代码就会获得obj的锁。 监视器概念锁和条件是实现线程同步的强大工具。但其严格的讲，并不是面向对象的。而监视器就是为解决这一点诞生的。 从Java的术语来说，监视器具有如下特征（Java中并没有如此实现）： 监视器是只包含私有字段的类。 监视器类的每个对象有一个关联的锁。 所有方法由这个锁锁定。也就是说，当调用obj.method()时，那么obj对象的锁在方法调用开始时自动获得，并且当方法调用自动释放该锁。并且由于所有字段都是私有的，就可以保证当一个线程处理一个字段时，其他的字段无法访问该字段。 锁可以有任意多个相关联的条件。 Java设计者以不太严格的方式实现了监视器概念。其有3处不同于监视器概念: 字段不要求是private。 方法不要求是synchronized。 内部锁对客户端是可用的。 volatile字段volatile关键字为实例字段的同步访问提供了一种免锁机制。如果一个字段声明为volatile，那么编译器和虚拟机就知道该字段可能被另一个线程并发更新。 例如，假设一个对象有一个boolean标记为done，它的值由一个线程设置，而由另外一个线程查询，如同我们讨论的那样，可以用锁： 123private boolean done;public synchronized boolean isDone()&#123;return done;&#125;public synchronized void setDone()&#123;done = true;&#125; 在这种情况下，将字段声明为volatile就很合适： 123private volatile boolean done;public boolean isDone()&#123;return done;&#125;public void setDone()&#123;done = true;&#125; 编译器会插入适当的代码，以确保如果一个线程对done变量做了修改，这个修改对读取这个变量的所有其他线程都可见。 注意：volatile变量不能提供原子性。如： 1public void flipDone()&#123;done = !done;&#125; //not atomic 不能确保反转字段中的值。不能保证读取、翻转和写入不被中断。 final变量当然也可以使用final来确保读取，因为其只有初始化时可以赋值。 原子性java.util.concurrent.atomic包中有很多类使用了很高效的机器级指令（没有使用锁）来保证其他操作的原子性。 例如，AtomicInteger类使用了方法incrementAndGet和decrementAntGet，它们分别以源自方式将一个整数进行自增或自减。 实例： 123public static AtomicLong nextNumber = new AtomicLong();//in some methodlong id = nextNumber.incrementAndGet(); decrementAntGet方法以原子方式将AtomicLong自增，并返回自增后的值。也就是说：获得值，增加1，然后生产新的值的操作不会中断。所以也可以保证多个线程访问时不会出错。 这个包中有更多的方法（可以用名字看出其功能） AtomicBoolean.classAtomicInteger.class AtomicIntegerArray.class AtomicIntegerFieldUpdater classAtomicLong.class AtomicLongArray.class AtomicLongFieldUpdater.class AtomicMarkableReference.class AtomicReference.class AtomicReferenceArray.class AtomicReferenceFieldUpdater.class。 AtomicStampedReference.class DoubleAccumulator.class DoubleAdder.class LongAccumulator.class LongAdder.class Striped64.class 值得注意的是，如果有大量的线程要访问相同的原子值，性能就会大幅度下降，因为乐观锁更新需要太多次重试。 LongAdder和LongAccumulator类解决了这个问题。LongAdder包含多个变量（加数），其总和值为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，只有当所有工作完成后才需要总和的值，这个时候用LongAdder效果就会很好。 所以，当预计会有很多线程竞争的时候，用LongAdder更高效。 而自增的时候，需要调用add方法，只有调=用sum方法时，才会获得其值。 如： 123456789var adder = new LongAdder();for(...)&#123; pool.submit(() -&gt; &#123; while(...)&#123; if(...) adder.increment(); &#125; &#125;)&#125;long total = adder.sum(); 同样也有DoubleAdder和DoubleAccumulator来完成浮点数的操作。 线程局部变量可以通过ThreadLocal来为每个线程都单独提供一个变量，这个变量就不支持共享，也不会存在同步的问题。 如： 1234public static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormate = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(\"yyyy-MM-dd\"));//...codeString dateStamp = dateFormat.get().format(new Date()); 线程安全的集合Java提供了一些线程安全的集合。用来对应常规的集合。 阻塞线程接口（BlockingQueue interface）阻塞线程用来对应常规的队列。其提供了两套API，可以在有问题的时候阻塞或者抛出错误。工作线程可以周期性的将中间结果存储在阻塞队列之中。其他工作线程移除中间结果，并进一步进行性修改。队列会自动地平衡负载。下表是阻塞队列地方法： 方法 正常动 特殊情况下地动作 add 添加一个元素 若队满，则抛出IllegalStateException异常 element 返回队头元素 若队空，则抛出NoSuchElementException异常 offer 添加一个元素并返回true 若队满，则返回false peek 返回队头元素 若队空，则返回null poll 移除并返回队头元素 若队空，则返回null put 添加一个元素 若队满，则阻塞 remove 移除并返回队头元素 若队空，则抛出NoSuchElementException异常 take 移除并返回队头元素 若队空，则阻塞 阻塞队列方法分为3类（取决于队满或队空时的动作）： 如果使用队列作为线程管理工具，将要使用put和take方法，这两个方法将阻塞进程。 当试图向满队添加元素或向从空队中获取元素时，add、remove和element操作将会抛出异常。 offer、poll和peek方法将会给出提示而不是错误。而offer和poll还支持超时参数。 数组阻塞队列（ArrayBlockingQueue），数组阻塞队列继承自AbstractQueue并且实现了BlockingQueue。 其基本实现还是数组，并且方法都是BlockingQueue接口中地方法。 同样地，与常规对应，还存在 LinkedBlockingQueue，其内部实现为链表，同样AbstractQueue并且实现了BlockingQueue。 PriorityBlockingQueue和PriorityQueue特性一致，不过是实现了同步。 高效地映射、集和队列java.util.concurrent包中还提供了映射、有序集合和队列地高效实现： ConcurrentHashMap ConcurrentSkipListMap ConcurrentSkipListSet ConcurrentLinkedQueue 这些集合使用复杂地算法，通过允许并发地访问数据结构地不同部分尽可能减少竞争。 注意这些集合返回地size并不一定能在常量时间内完成操作。确认这些集合地大小通常需要遍历。 并发散列集可以高效地支持大量地getter和一定数量地setter。一般认为其支持至多16个setter。当多于16个时，其他地将会被暂时阻塞。 并发散列集地批量操作批量操作即提供方法来遍历散列集并执行一些操作。具体有3种不同的操作： search（搜索）：为每个键或值应用一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函数的结果。 reduce（规约）：组合所有建或值，这里要使用所提供的一个累加函数。 forEach（遍历）：为所有的键或值应用一个函数。 每个操作有4个版本： operationKeys: 处理键。 operationValues: 处理值。 operation: 处理键和值。 operationEntries: 处理Mpap.Entry对象。 对于上述操作，需要指定一个参数化阈值（parallesion threshold）。如果映射包含的元素多于这个阈值，就会并行完成批操作。 如果希望批操作在一个线程中运行，可以使用阈值Long.MAX_VALUE。 如果希望批操作就能够可能快的完成，可以使用阈值1。 例如search方法，有以下版本： U searchKeys(long threshold, BiFunction&lt;? super K, ? extends U&gt; f) U searchValues(long threshold, BiFunction&lt;? super K, ? extends U&gt; f) U search(long threshold, BiFunction&lt;? super K, ? extends U&gt; f) U searchEntries(long threshold, BiFunction&lt;? super K, ? extends U&gt; f) 例，假设我们希望找出第一个出现次数超过1000次的单词。则需要搜索键和值： 12//map:&#123;key: word, value: appearTimes&#125;String result = map.search(threshold, (k, v) -&gt; v &gt; 1000 ? k: null); 并发集视图并发集中并没有提供ConcurrentHashSet，但是可以用newKeySet方法会生成一个Set&lt;k&gt;，这实际上concurrentHasMap&lt;K, Boolean&gt;的一个包装类（所有的映射值都为TRUE，只不过将其视为一个Set，所以不关系其值）。 写入数组的拷贝copyOnWriteArrayList和copyOnWriteArraySet是线程安全集合，其中所有更改器都会建立底层数组的一个副本。 并行数组算法Arrays类提供了大量并行化运算。 Arrays.parallelSort方法可以对一个基本类型值或对象的数组排序。其用法于基本sort一致。 Arrays.paralleSetAll方法会由一个函数计算得到的值填充一个数组。 Arrays.parallelPrefix会使用提供的函数，并行地累积给定数组中的每个元素。 遗留的线程安全集合从Java最开始的版本中,Vector和Hashtable就提供了动态数组和散列表的线程安全。不过这些类已经被认为是过时的，不应当再使用。 实际上，任何集合类都可以通过使用同步包装器（synchronized wapper）来变成线程安全的。 12List&lt;E&gt; synchArray = Collections.synchronizedList(new ArrayList&lt;E&gt;());Map&lt;K, V&gt; synchHashMap = Collections.synchronizedMap(new HashMap&lt;K, V&gt;()); 结果集的方法应当使用锁加以保护，则可以提供线程安全的访问。并且确保没有任何线程通过原始的非同步方法访问数据结构。（其解决办法一般就是像代码中那样直接传入新建的集合） 不过最好通常使用java.util.concurrent包中定义的集合，而不是同步包装器。 特别的，concurrenthashMap经过了精心实现，假设多个线程访问的是不同的位置，则不会发生阻塞。 经常更改的数组列表是个例外。这种情况下，同步的ArrayLst要胜过CopyOnWriterArrayList。 任务和线程池线程池其实就是一组线程的集合，不过其调用是由其本身来决定的。如果程序中创建了大量的生命周期很短的线程，那么不应该把每个任务映射到一个单独的线程中，而应该使用线程池（Thread pool）。 Callable和Future Runnable封装一个异步运行的任务，可以将其想象成一个没有参数和返回值的异步方法。 Callable与Runnale类似，但是有返回值。 Callable接口是一个参数化的类型，只有一个方法call。 123public interface Callable&lt;V&gt;&#123; V call() throws Exception; &#125; 类型参数是返回值的类型。例如Callable&lt;Integer&gt;表示将返回Integer对象的异步方法。 Future保存异步计算的结果。 Future&lt;V&gt;接口有下面的方法： V get()：调用后会阻塞，直到计算完成。 V get(long timeout, TimeUnit unit)：调用后也会阻塞，但是超时之后，会抛出一个TimeoutException。 void cancel(boolean mayInterrupt)：取消任务，如果计算任务还没开始，则不会再开始。如果已经开始，那么如果mayInterrupt为true，其将会被中断。 boolean isDone()：查询任务是否完成。 执行Callable的一种方法是使用FutureTask，它实现了Future和Runnable接口。 例： 123456Callable&lt;Integer&gt; task = ...;var futureTask = new FutureTask&lt;Integer&gt;(task);var t = new Thread(futureTask);t.start();...;Integer result = task.get(); //It`s a future 执行器执行器（Executors）类有很多静态工厂方法，用来构造线程池。下表是一些方法： 方法 描述 newCachedThreadPool 必要时创建新线程，空闲线程会保留60秒。 newFixedThreadPool 池中包含固定数目的线程，空闲线程会一直保留。 newWorkStealingPool 一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会“密取”较简单的任务。 newStringThreadExecutor 只有一个线程的池，会顺序地执行所提交的任务。 newScheduledThreadPool 用于调度执行的固定线程池。 newSingleThreadScheduledEcecutor 用户调度执行的单线程池。 newCachedThreadPool 方法会在线程池有线程的时候直接使用线程，没有的时候新建。 如果线程的生命周期很短，或者大量时间都在阻塞，那么可以使用一个缓存线程池。 为了得到最优的运行速度，并发线程数等于处理器内核数。 可以用以下方法将Runnable或Callable对象提交给ExecutroService： Future&lt;T&gt; submit(Callable&lt;T&gt; task) Future&lt;?&gt; submit(Runnable task) Future&lt;T&gt; submit(Runnable task, T result) 线程池会在方便的时候尽早提交执行提交的任务。并且会返回一个Future对象，可以用来得到结果或者取消任务。 Future对象有两个方法来种植线程池中的所有任务： shutdown：这个方法会停止线程池接受新任务，当线程池中的任务都完成时，线程池就会死亡。 shutdownNow：线程池会取消所有尚未开始的任务。 控制任务组执行器方法有两个执行方法： invokeAny：接受一个Callable对象集合，并返回最先完成的那个任务的结果。 invokeAll：接受一个Callable对象集合，这个方法会阻塞，直到所有任务都完成，然后返回所有的结果集合。（这里的结果顺序是按提交的顺序） 但是当我们需要按计算结果的顺序得到结果，就可以使用ExecutorCompletionService。 如： 123var service = new ExecutorCompletionService&lt;T&gt;(executor);for(Callable&lt;T&gt; task: tasks) service.submit(task);processFurther(service.take().get()); fork-joinJava7引入了fork-join框架哦那个与计算密集型任务，其原理是通过递归将大任务分解为小任务到不同的线程。 其需要扩展RecursiveTask&lt;T&gt;类，结果会返回T类型的值。 例如： 1234567891011121314class Counter extends RecursiveTask&lt;Integer&gt;&#123; //... protected Integer compute()&#123; if(to - from &lt; THRESHOLD)&#123; //solve problem directly &#125;else&#123; int mid = (from + to) / 2; var first = new Counter(values, from, mid, filter); var first = new Counter(values, mid, to, filter); invokeAll(first, second); return first.join() + second.join(); &#125; &#125;&#125; 可以看到整体就是个二分的思路，当小于阈值时直接计算，否则就二分。 异步计算这里的异步计算，实际上是一种回调机制。 CompletableFuture传统的Future对象，要获得其结果时，必须等待阻塞，直到计算完成。 而CompletableFuture类实现了Future，它提供了一个回调的参数，允许将回调先传入，再结果可用时将自动调用。 如： 12CompletableFuture&lt;String&gt; f = ...;f.thenAccept(s -&gt; Process the result string s); 通过这种回调的方式可以无需阻塞获得结果。 completableFuture的所有方法如下表（其用法与上述相同）： 方法 参数 描述 thenApply T-&gt;U 对结果应用一个函数 thenAccept T-&gt;void 类似于thenApply，不过结果为void thenCompose T-&gt;CompletableFuture 对结果调用函数并执行返回的future handle (T, Throwable)-&gt;U 处理结果或错误，生成一个新结果 whenComplete (T, Throwable)-&gt;void 类似于handle，不过结果为void exceptionally Throwable-&gt;T 从错误计算一个结果 completeOnTimeout T, long, TimeUnit 如果超时，生成给定值作为结果 orTimeout long, TimeUnit 如果超时，生成一个一个TimeoutException异常 thenRun Runnable 执行Runnable，结果为void 下面还有一些方法来组个多个future。 方法 参数 描述 thenCombine CompletableFuture, (T, U)-&gt;V 执行两个动作并给定函数的组合结果 thenAcceptBoth CompletableFuture, (T, U)-&gt;void 与thenCombine类似，不过结果为void runAfterBoth CompletableFuture&lt;?&gt;, Runnable 两个都完成后执行runnable applyToEdither CompletableFuture, T-&gt;V 得到其中一个的结果时，传递给定的函数 acceptEither CompletableFuture, T-&gt;void 与applyToEither类似，不过结果为void runAfterEither CompletableFuture&lt;?&gt;, Runnable 其中一个完成后执行runnable static allOf CompletableFuture&lt;?&gt;… 所有给定的future都完成后完成，结果为void static anyOf CompletableFuture&lt;?&gt;… 任意给定的future完成后则完成，结果为void 前三个方法并发运行两个泛型类型不同的CompletableFuture，并组合结果。 后三个方法并发运行两个泛型类型相同的CompletableFuture。一旦一个完成，则传递它的结果，并忽略另外的。 后面的静态方法allOf和anyOf取一组CompletableFuture，并生成CompletableFuture&lt;Void&gt;，然后分别在全部完成时任意一个完成时结束。但不会返回任何结果。 进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 建立一个进程建立进程必须要指定要执行的命令，可以用List&lt;String&gt;，或者直接提供命令字符串。 如： 1var builder = new ProcessBulder(\"gcc\", \"myapp.c\"); 工作目录每个进程都有一个工作目录，用来解析相对的目录名。默认情况下，进程的工作与虚拟机相同，通常是启动Java程序的那个目的。也可以使用dictionary方法来 改变工作目录。 1budiler = budiler.dictionary(path.toFile()); 输入输出流默认情况下，输入输出流可以用以下方法访问： 123OutputStream processOut = p.getOutputStream();InputStream processIn = p.getInputStream();InputStream processErr = p.getErrorStream(); 注意：进程的输入流是JVM的一个输出流。我们会写入这个流，而我们写的内容会成为进程的输入。即一个中继的概念。 可以指定新进程的输入、输出和错误流与JVM相同。如果在控制台运行JVM，则所有用户的输入会转发到进程。 1builder.redirectIO(); 环境变量可以使用以下格式来设置环境变量： 1234Map&lt;String, String&gt; env = builder.environment();env.put(\"LANG\", \"Fr_FR\");env.remove(\"JAVA_HOME\");Process p = builder.start(); 运行一个进程要等待进程完成，可以调用： 1int result =process.waitFor(); 或者，如果不想无限等待，可以这样做： 123456long delay = ...;if(process.waitFor(delay, TimeUnit.SECONDS))&#123; int result = process.exitValue();&#125;else&#123; process.detroyForcibly();&#125; 进程句柄可以通过进程句柄来获得进程的更多信息。有以下4中方式： 给定一个Process对象p，使用p.toHandle()方法获得其句柄。 给定一个long类型的操作系统进程ID，ProcessHandle.of(id)获得其句柄。 Process.current()是运行这个Java的虚拟机的进程句柄。 Process.allprocess()可以生成对当前进程可见的所有操作系统进程的Stream&lt;ProcessHandle&gt; 给定进程句柄，可以获得其id，父进程，子进程和后代进程： long id = handle.pid(); Optional&lt;ProcessHandle&gt; parent = handle.parent(); Stream&lt;ProcessHandle&gt; children = handle.childrean(); Stream&lt;ProcessHandle&gt; descendants = handle.descendants(); 还可以通过ProcessHandle.info来获取其他的信息。 也可以通过进程句柄来监视或终止进程。PorcessHandle接口有isAlive、supportsNormTermination、destroy、destroyForcibly和onEixt()方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"java核心技术-I-12-并发","slug":"java核心技术-I-12-并发","permalink":"http://yoursite.com/tags/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-12-%E5%B9%B6%E5%8F%91/"}]},{"title":"java核心技术-I-9-集合","slug":"java核心技术-I-9-集合","date":"2022-01-24T03:12:49.000Z","updated":"2022-01-24T05:52:24.225Z","comments":true,"path":"2022/01/24/java核心技术-I-9-集合/","link":"","permalink":"http://yoursite.com/2022/01/24/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-9-%E9%9B%86%E5%90%88/","excerpt":"","text":"Java集合框架集合接口与实现分离Java集合类库也将接口与实现分离。 Collection接口在Java类库中，集合类的基本接口是Collection接口。这个接口有两个基本方法： boolean add(E element); Iterator&lt;E&gt; ietrator(); 迭代器Iterator接口包含4个方法： 123456public interface Interface&lt;E&gt;&#123; E next(); boolean hasNext(); void remove(); default void forEachRemaining(Cusumer&lt;? super E&gt; action);&#125; 可以通过反复调用next方法，可以逐个访问集合中的每个元素。 但是如果达到了集合的末尾，next方法将抛出一个NoSuchElementException。所以可以在调用next方法之前调用hasNext方法来判定是否有一下个元素。 如： 123456Collection&lt;String&gt; c = ...;Iterator&lt;String&gt; iter = c.iterator();while(iter.hasNext())&#123; String element = iter.next(); //code&#125; 但是在jdk5中引入了增强for循环： 12345Collection&lt;String&gt; c = ...;Iterator&lt;String&gt; iter = c.iterator();for(String element : c)&#123; //code&#125; 编译器简单地将for each循环转换为带有迭代器的循环。增强for循环可以处理任何带有低迭代器的循环。 使用forEachRemaining来便利。 123Collection&lt;String&gt; c = ...;Iterator&lt;String&gt; iter = c.iterator();iter.forEachRemaining(ele -&gt; do something); Iteratot的next方法和hasNext方法与Enumeration接口的nextElement和hasMoreElements方法的作用一样。而Iterator接口的设计初衷就是为了用更短的名称代替它。 其实迭代器的方式与流的读取类似。每用一次都会消耗掉一个元素。 泛型使用方法由于Collection与Iterator都是泛型接口，这意味着可以编写处理任何集合类型的使用方法。 Collection接口内部定义很多实用的方法。如： int size(); boolean isEmpty(); blooean contains(); boolean equals(); … 但是由于每个子类都要实现这些方法，所以又定义了AbstractCollection抽象类。其保持了那些基础的方法，比如size和Iterator。但是实现了其他的例行方法。 如： 12 这样具体类可以扩展AbstractCollection类。 集合框架中的接口Java集合框架为不同类型的集合定义了大量接口。如下如 其主要有两个基本接口，Collection和Map。其子结构的介绍如下 Collection：表示单个值得集合。 List： 是一个有序集合。元素会增加到指定的特定位置。 Set： 其内部元素不允许重复。 Map ：表示键值对的集合。 具体集合下面的表格简单介绍了Java库的一部分具体集合 接口类型 描述 ArrayList 可以动态增加和缩减的一个索引序列。 LinkedList 可以在任何位置高效插入和删除的一个有序序列。 ArrayDeque 实现为循环数组的一个双端队列。 HashSet 没有重复元素的一个无序集合。 TreeSet 一个有序树集。 EnumSet 一个包含枚举类型值的集合。 LinkedHaashSet 一个可以记住元素插入次序的集合。 PriorityQueue 允许高效删除最小元素的一个集合。 HashMap 存储键/值对的一个数据结构。 TreeMap 键有序的一个映射。 EnumMap 键属于枚举类型的一个映射。 LinkedHashMap 可以记住键值对添加次序的一个映射。 WeakHashMap 值不在别处使用时就可以被垃圾回收的一个映射。 IdentityHashMap 用==而不是equls比较键的一个映射。 链表（LinkedList）链表的实现与ArrayList 不同，其是由节点一个个连接起来的链。所以其特点也与数组列表不同。 具体链表和数组的为什么会出现这些特点不再赘述，基本知识。其知识如下： 链表插入和删除更快。 链表不能直接按下标查找值，需要遍历。 数组列表（ArrayList）这个类的底层是用数组实现的，因此可以直接实现按下表查找值。 注意：vector也可以实现动态数组，但是vector是同步的，所以在不需要多线程访问的时候，即不需要同步的时候，选择ArrayList 效率更高。因为其不需要同步。 散列集（HashSet）HashSet 是利用了hash table的原理，具体原理也是基础知识，不再赘述。 其主要特点是： 没有顺序。 不会存在重复的值。 树集（TreeSet）TreeSet类与散列集十分相似，元素不允许重复。 不过，它比散列集有所改进。树集是一个有序集合（sorted collection）。 可以将任意顺序的元素插入到集合中。在对集合进行遍历的时候，值将自动按照排序后的顺序呈现。 其底层实现是红黑树。 每将一个元素添加到树中时，都会将其放置到正确的位置。因此迭代器总会以有序的访问每个元素。 将一个元素添加到树中总要比添加到散列表中慢。 所以到底是选用散列表还是树集要根据需求，如果不要求数据有序，则选用散列表。但是如果元素过多，则速度会很慢。 队列（Queue）队列是一个先进先出的集合。其本身是一个接口。定义了需要的方法。 123456boolean add(E e);boolean offer(E e);E remove();E poll();E element();E peek(); 双端队列双端队列（即Deuqe）允许在头部和尾部都高效地添加或删除元素。Java6引入了Deque接口。 其中一部分接口： void addFirst(E e); void addLast(E e); void addLast(E e); boolean offerFirst(E e); boolean offerLast(E e); E removeFirst(); E removeLast(); E pollFirst(); E pollLast(); E getLast(); E peekFirst(); E peekLast(); int size(); Iterator&lt;E&gt; iterator(); ArrayDeque和LinkedList 类实现了这个接口。 数组双端队列（ArrayDeque）在import java.util.ArrayDeque; 中定义了ArrayDeque 。 ArrayDeque 实现了Deque 中的所有方法。并且其内部是一个数组来存储数据： 1transient Object[] elements; 由于数组不能增加长度的问题，其内部又定义了一些方法来实现动态增加长度： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Increases the capacity of this deque by at least the given amount. * * @param needed the required minimum extra capacity; must be positive */ private void grow(int needed) &#123; // overflow-conscious code final int oldCapacity = elements.length; int newCapacity; // Double capacity if small; else grow by 50% int jump = (oldCapacity &lt; 64) ? (oldCapacity + 2) : (oldCapacity &gt;&gt; 1); if (jump &lt; needed || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE &gt; 0) newCapacity = newCapacity(needed, jump); final Object[] es = elements = Arrays.copyOf(elements, newCapacity); // Exceptionally, here tail == head needs to be disambiguated if (tail &lt; head || (tail == head &amp;&amp; es[head] != null)) &#123; // wrap around; slide first leg forward to end of array int newSpace = newCapacity - oldCapacity; System.arraycopy(es, head, es, head + newSpace, oldCapacity - head); for (int i = head, to = (head += newSpace); i &lt; to; i++) es[i] = null; &#125; &#125; /** Capacity calculation for edge conditions, especially overflow. */ private int newCapacity(int needed, int jump) &#123; final int oldCapacity = elements.length, minCapacity; if ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE &gt; 0) &#123; if (minCapacity &lt; 0) throw new IllegalStateException(\"Sorry, deque too big\"); return Integer.MAX_VALUE; &#125; if (needed &gt; jump) return minCapacity; return (oldCapacity + jump - MAX_ARRAY_SIZE &lt; 0) ? oldCapacity + jump : MAX_ARRAY_SIZE; &#125; 优先队列优先队列（priority queue）中的元素可以按照任意的顺序插入，但会按照有序的顺序进行检索。且特点就是： 无论何时调用remove() 方法，总会获得当前优先队列中最小的元素。 优先队列其内部是采用了堆来获取最小值。其原理是DS基础，不再赘述。 这个方法也实现了Comparable接口，方便在堆中比较大小。 其也是采用了数组存储： 1transient Object[] queue; // non-private to simplify nested class access 整个remove()的调用栈如下： remove()-Abstract-&gt;pool()-PriorityQueue-&gt;siftDownUsingComparator()-PriorityQueue 其中pool是移除队列顶的元素，siftDownUsingComparator是将x插入后排好顺序。 值得注意的是：优先队列也支持特点元素出队列。即remove(E e)方法。 映射映射map数据结构是为了存储键值对。可以通过键来查找值。 其特点就是键不能重复，值可以重复。 Java底层定义了Map接口用于统一映射的操作，抽象类AbstractMap是一个实现了Map接口的抽象类。 而HashMap和TreeMap都实现了 Map接口并且继承了AbstractMap类。 映射MapMap提供了一下方法定义： int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); V get(Object key); V put(K key, V value); V remove(Object key); void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); 而其中又定义了 Entry这种数据接口用于保存单个键值对的子接口，其内部又定义了一些方法： K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); … 顺序映射SortedMapSortedMap是一个继承了Map的接口。其主要目的是提供一个根据key排序的映射。其内部仅仅提供了一些函数定义（如获取key的Set，获取value的集合），并没有给出默认实现。 导航映射NavigableMapNavigableMap是一个继承了SortedMap的接口。这个抽象类的目的是提供一些方法来获取key或value的最大/最小值。 比如: Map.Entry&lt;K,V&gt; lowerEntry(K key);：返回按照key排序的最大的那个小于给定key的Entry。 K lowerKey(K key);：返回按照key排序的最大的那个最小于给定key的key。 Map.Entry&lt;K,V&gt; floorEntry(K key);：返回按照key排序的最大的那个小于或等于给定key的Entry。 K floorKey(K key);：返回按照key排序的最大的那个小于或等于给定key的 key。 Map.Entry&lt;K,V&gt; ceilingEntry(K key);：返回按照key排序的最小的那个大于给定key的Entry。 K ceilingKey(K key);： … Map.Entry&lt;K,V&gt; higherEntry(K key);： 返回按照key排序的最小的那个大于给定key的Entry。 举个例子： 12345678&#123; 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6&#125; 当给点key为-4时： lowerEntry: {3: 3} floorEntry: {4: 4} ceilingEntry: {4, 4} higherEntry: {5: 5} 返回key的规则也一样。 抽象映射AbstractMap与Set类似，Map也定义了一个实现了Map接口的抽象类AbstractMap。 其内部为Map的方法提供了一些默认实现，比如get方法 1234567891011121314151617public V get(Object key) &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (key==null) &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (e.getKey()==null) return e.getValue(); &#125; &#125; else &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (key.equals(e.getKey())) return e.getValue(); &#125; &#125; return null;&#125; 其利用了Iterator和Entry来为其提供了一个通用的实现。因为Map的数据总会为元素提供这两个实现。 而一些方法则没有实现，需要具体类自己去实现，比如put。 123public V put(K key, V value) &#123; throw new UnsupportedOperationException();&#125; 散列映射HashMap其内部定义了Node实现了原Map中的Entry子接口。 其基本实现如下： 123456789101112131415161718192021222324252627282930313233343536static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; return o instanceof Map.Entry&lt;?, ?&gt; e &amp;&amp; Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue()); &#125; &#125; 也就是说HashMap实际上也是由一个个的Node类的实例数组组成的。 其存储在table中，其初始化函数如下： 123456789101112/** * Reset to initial default state. Called by clone and readObject. */void reinitialize() &#123; table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0;&#125; 而HashMap的默认表长为： 1static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 装填因子为： 1234/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f; 树映射TreeMapTreeMap 实现了AbstractMap，并且实现了NavigableMap。 所以也实现了上面NavigableMap的所有方法，例如： 123456789101112131415161718192021222324252627282930/** * Returns the entry for the greatest key less than the specified key; if * no such entry exists (i.e., the least key in the Tree is greater than * the specified key), returns &#123;@code null&#125;. */ final Entry&lt;K,V&gt; getLowerEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &gt; 0) &#123; if (p.right != null) p = p.right; else return p; &#125; else &#123; if (p.left != null) &#123; p = p.left; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; &#125; return null; &#125; 可以看到这里采用了中序递归遍历的方式来查找等于这个值得node，然后返回其parent（这里有个判定其左子树是否存在过程）。 注意这里TreeMap中，重写了Entry： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK; /** * Make a new cell with given key, value, and parent, and with * &#123;@code null&#125; child links, and BLACK color. */ Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; /** * Returns the key. * * @return the key */ public K getKey() &#123; return key; &#125; /** * Returns the value associated with the key. * * @return the value associated with the key */ public V getValue() &#123; return value; &#125; /** * Replaces the value currently associated with the key with the given * value. * * @return the value associated with the key before this method was * called */ public V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; public boolean equals(Object o) &#123; //... &#125; public int hashCode() &#123; //... &#125; public String toString() &#123; //... &#125;&#125; 即这里除了定义了k,v还定义了left和right来作为树节点的左右节点。 而这里的树是一种特殊的平衡二叉树-红黑树。DS基础不再赘述。 映射集合集合框架不认为映射映射本身是一个集合。不过，可以得到得映射的视图。 有3中视图：键集、值集合（不是一个集）以及键/值对集。键和键/值可以构成一个集合，因为映射中一个键只能有一个副本。下面是方法： Set&lt;K&gt;KeySet() Collection&lt;V&gt; values() Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 需要说明的是，KeySet 不是HashSet 或 TreeSet，而是实现了Set 的另外某个类的对象。 tips：可以用var 来代替Map.Entry 这种复杂的声明方式。（尤其在增强for循环中） 弱散列映射弱散列映射意在解决这样一个问题：如果一个散列映射中，如果一个键已经不在任何地方引用，那么理论上来说，这个映射就无法被任何地方获取，那么它仍然会在jvm中存在，并且不会被垃圾回收。这样显然是内存浪费。 而WeakHashMap 的设计就是为了解决这个问题，通过WeakHashMap 定义的键值对，只要键不在任何地方引用，则一定时间后，这个键值对就会被垃圾回收。 WeakHashMap 使用的是弱引用(weak reference)保存键。WeakReference对象将包含另一个对象的引用，此处就是一个散列表键。 对于这种类型的对象，垃圾回收器采用了一种特殊的方式进行处理。正常情况下，如果垃圾回收器发现某个特点的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器也会将其回收。 这个回收过程是现将这个对象的弱引用放入一个队列。WeakHashMap将周期性地检查队列，以便赵处新添加的弱引用。 一个弱引用进入队列意味着这个键不再被他人使用，并且已经回收。于是，WeakHashMap将删除相关联的映射条目。 链接散列集与映射LinkedHashSet 、LinkedHashMap 与HashSet 、HashMap 基本操作一样，只是其实现用了链表的方式。 所以在需要频繁增删元素时选用链表比较合适，否则直接使用数组形式更加方法。 枚举集与映射EnumSet 是一个枚举类型元素集的高效实现。 由于枚举类型只有有限个实例，所以EnumSet 内部用位序列实现。如果对应的值在集中， EnumSet没有公共的构造器。要使用静态工厂方法构造这个集： 12345enum WeekDay&#123;MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SAUNDAY&#125;;EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FEIDAY);EnumSet&lt;Weekday&gt; someday = EnumSet.of(Weekday.MONDAY, Weekday.THURSDAY); EnumMap 是一个键类型为枚举类型的映射。其可以直接且高效地实现为一个值数组。 需要在构造器中指定键类型： 1var personIncharge = new EnumMap&lt;Weekday, Employee&gt;(Weekday.class); 标识散列映射（IdentityHahMap）IdentityHahMap 有特殊的用途。在这个类中，键的散列值不是用hashCode 函数计算的，而是用System.identityHashCode 方法计算。这是Object.hashCode 根据对象的内存地址计算散列码时所使用的的方法。而且，在对两个对象进行比较时，IdentityHahMap 类使用==， 而不使用equals。 也就是说，不同的键对象即使内容相同，也被视为不同的对象。在实现对象遍历算法（如对象串行化）时，这个类非常有用，可以用来跟踪哪些对象已经遍历过。 视图和包装器视图就是集合或者映射中某一部分或者某一类数据的再映射得到的结果集，这个结果集一般不允许更新(有些视图允许更新某个元素，但是不允许新增或者删除元素)，只允许读取，结果集中的数据使用的还是原来集合或者映射中的数据的引用。 小集合Java9引入了一些静态方法，可以生成给定元素的集或列表，以及给定键/值对的映射。 如： 12List&lt;String&gt; names = List.of(\"Perter\", \"Paul\", \"Mary\");Set&lt;Integer&gt; numbers = Set.of(2, 3, 4); 会生成包含3个元素的一个列表和一个集。 123456Map&lt;String, Integer&gt; sources = Map.of(\"Peter\", 2, \"Paul\", 3, \"Mary\", 4);Map&lt;String, Integer&gt; sources1 = Map.ofEntries( entry(\"Peter\", 2), entry(\"Paul\", 3), entry(\"Mary\", 4),) 元素、键或值不能为null。 这些方法返回的视图都为ImmutableCollections 的相关子类： static abstract class AbstractImmutableCollection&lt;E&gt; extends AbstractCollection&lt;E&gt; ：所有内部类的父类。 static final class List12&lt;E&gt; extends AbstractImmutableList&lt;E&gt;： 含有一个或多个的List。 static final class ListN&lt;E&gt; extends AbstractImmutableList&lt;E&gt;：含有多个元素的List。 static abstract class AbstractImmutableSet&lt;E&gt; extends AbstractImmutableCollection&lt;E&gt;： 所有内部Set的父类。 static final class Set12&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;： 含有一个或两个元素的Set。 static final class SetN&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;： 含有多个元素的Set。 abstract static class AbstractImmutableMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Serializable ：所有内部Map类的父类。 static final class Map1&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt;： 含有一个或多个的Map。 static final class MapN&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt;： 含有多个元素的Map。 值得注意的是： 这些内部类的实例无法改变。（尝试改变会抛出一个UnsupportedOperation Exception）。 Collection 类包含很多实用方法，这些方法的参数和返回值都是集合。不要将它与Collection 接口混淆。 子范围可以为很多集合建立子范围（subrange）视图。比如 List 的subList 方法。 SortedSet&lt;E&gt; subSet(E from, E to); SortedSet&lt;E&gt; headSet&lt;E to&gt;; SortedSet&lt;E&gt; tailSet(E from ); SortedMap&lt;K, V&gt; subSet(K from, K to); SortedMap&lt;K, V&gt; headSet&lt;K to&gt;; SortedMap&lt;K, V&gt; tailSet(K from ); NavigableSet&lt;E&gt; subSet(E from, boolean fromInclusive, E to, boolean toInclusive); NavigableSet&lt;E&gt; headSet&lt;E to, boolean toInclusive&gt;; NavigableSet&lt;E&gt; tailSet(E from, blooean fromInclusive); 以上方法返回截取确定的集合，然后返回对应内容。 不可修改视图Colelctions 类还有几个方法，可以生成集合的不可修改视图（unmodifiable view）。这些视图对现有集合增加了一个运行时检查。试图对其进行修改时会抛出错误，且集合不会改变。 以下8个方法可以获得不修改的视图： Collections.unmodifiable CollectionCollections.unmodifiableList Collections.unmodifiableSet Collections.unmodifiable SortedSetCollections. unmodifiableNavigable SetCollections.unmodifiableMap Collections.unmodifiableSortedMap Collections.unmodifiableNavigableMap 每个方法都定义处理一个接口。如： CollectionCollections.unmodifiableList 处理ArrayList、LinkedList或者任何实现了List 接口的类。 同步视图如果从多个线程访问集合，就必须保证集合不会被意外破坏。例如散列表不是同步的，多个线程同时访问会出现错误。这就是灾难性的。所以，同步中设计了很多线程安全集合。例如Collections.synchronizedMap就是一个线程安全的Map，使用方法相同，具体详见以后的多线程介绍。 检查性视图“检查型”视图是用来对泛型可能出现的问题提供调试支持。例如： 123var strings = new ArrayList&lt;String&gt;();ArrayList rawList = strings;rawList.add(new Date()); 这个错误的命令在运行时检测不到。实际上，只有当另一部分代码调用get方法，并且将这个结果强制转换为String时，才会出现一个类的强制转换异常。 而检查型视图可以探测这个问题。如： 1List&lt;Strting&gt; safeStrings = Collections.checkedList(strings, String.class); 这个视图的add方法将检查插入的对象是否属于给定的类。如果不是，就会抛出转换错误。如： 12ArrayList rawList = safeStrings;rawList.add(new Date()); //ClassCastException 算法泛型的优点泛型集合接口有一个很大的优点，即算法只需实现一次。 排序和混排 Arrays.sort 采用的是快排的方式。 而对于链表的排序，Java采用的是先将其复制到一个数组中，经过排序再复制回链表中。 二分查找Collections.binarySearch是一个二分查找的实现。 集合与数组的转换由于Java平台API的大部分内容都是在集合框架创建之前设计的，所以，有时候需要在传统的数组和更加现代的集合之间进行转换。 数组转集合list.of 包装器可以达到这个目的。 12String[] values = ...;var staff = new HashSet&lt;&gt;(List.of(values)); 集合转数组可以使用toArray 方法。 1Object[] values = staff.toArray(); 但是注意这个方法只能返回Object[]，并且不能强制转换。 遗留的集合从Java第一版本以来，在集合框架中已经存在大量的“遗留的”容器类。 Hashtable 类经典的Hashtable类与HashMap 类作用一样。实际上接口也基本相同。与Vector 类的方法一样，Hashtable方法也是同步的。如果对遗留代码的兼容性没有需求，则应当使用HashMap 。 如果对并发有需求，则应当使用ConcurrentHashMap 。 枚举遗留的集合使用Enumeration接口遍历元素序列。其hasMoreElements 和nextElement 与Iterator 接口的hasNext 和next 方法作用一致。以后应该都使用Iterator 。 属性映射属性映射（property map）是一个特殊类型的映射结构。其有以下特点： 键和值都是字符串。 这个映射可以很容易地保存到文件以及从文件中加载。 有一个二级表存放默认值。 在Java平台中类名为properties。 一般可以用于加载xxx.proprties 文件。 位集Java平台的BitSet 类主要存储一个未序列（它不是数学上的集，如果称为位向量或位组更为合适）。如果需要高效的存储位序列（例如，标志），就可以使用位集。由于位集合包装在字节里，因此位集要比使用boolean对象的ArrayList高效很多。 例如： 123BitSet bSet = new BitSet();bSet.set(0);bSet.get(0); 可以对第n位调用set方法。此时第n位状态就为 “开”。 这时再调用get方法就会返回true，否则返回false。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"java核心技术-I-9-集合","slug":"java核心技术-I-9-集合","permalink":"http://yoursite.com/tags/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-9-%E9%9B%86%E5%90%88/"}]},{"title":"java核心技术-I-8-泛型程序设计","slug":"java核心技术-I-8-泛型程序设计","date":"2022-01-21T10:43:21.000Z","updated":"2022-01-22T16:52:31.628Z","comments":true,"path":"2022/01/21/java核心技术-I-8-泛型程序设计/","link":"","permalink":"http://yoursite.com/2022/01/21/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-8-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"泛型简介泛型实际上就是类型参数。即事先不确定参数类型，而在调用时传入对应参数类型才确定其类型。 在泛型出现之前，一般是使用多态来实现，即使用Object来接受所有参数，确定就是接收到参数后需要强转。 定义泛型类泛型类（generic type）就是一个或多个类型变量的类。 例如： 1234567891011121314151617181920212223242526272829303132package test.mw.ExceptionTest;public class Pair&lt;T&gt; &#123; private T first; private T second; public Pair() &#123; &#125; public Pair(T first, T second) &#123; this.first = first; this.second = second; &#125; public T getFirst() &#123; return first; &#125; public void setFirst(T first) &#123; this.first = first; &#125; public T getSecond() &#123; return second; &#125; public void setSecond(T second) &#123; this.second = second; &#125; &#125; 在Pair类中引入了一个参数类型T。这里用尖括号&lt;&gt;进行定义。可以按如下格式进行实例化。 1Pair pair1 = new Pair&lt;String&gt;(\"1\", \"2\"); 同样的，我们可以，通过 123public class Pair&lt;T, U&gt;&#123; //...&#125; 来定义多个类型泛型。 泛型方法同样的，我们可以定义带有泛型的方法。例如： 12345class ArrayAlg&#123; public staic &lt;T&gt; T getMid(T... a)&#123; return a[a / length / 2]; &#125;&#125; 调用 123String[] arr = new String[]&#123;\"1\", \"2\", \"3\", \"4\", \"5\"&#125;;ArrayAlg.getMid&lt;String&gt;(arr); 注意这里的格式于类中稍有不同，需要按： 123[限定符] [修饰符...] [&lt;泛型,...&gt;] [name]([parameters ...])&#123; //code&#125; 类型变量的限定我们可以通过以下格式来限定泛型继承了某个类或者实现了某个接口。 1public class Pair&lt;T extends Class1&gt; &#123;&#125; 也可以通过以下格式来限定继承了多个父类或者实现了多个接口。 1public class Pair&lt;T extends Class1 &amp; Interface1&gt; &#123;&#125; 泛型代码和虚拟机虚拟机中并没有泛型对象-所有的对象都是普通类。其最主要的特点在于类型擦除。 类型擦除在Java编译器中，所有的泛型都将被擦除为最低限定类。最低限定类指符合上述限定规则的类型。 例1： 12345678910111213public class Pair&lt;T&gt; &#123; private T first; private T second; public Pair() &#123; &#125; public Pair(T first, T second) &#123; this.first = first; this.second = second; &#125; &#125; 会被擦除为： 12345678910111213public class Pair&#123; private Object first; private Object second; public Pair() &#123; &#125; public Pair(Object first, Object second) &#123; this.first = first; this.second = second; &#125; &#125; 这是因为T没有限制。 例2： 12345678910111213public class Pair&lt;T extends Float&gt; &#123; private T first; private T second; public Pair() &#123; &#125; public Pair(T first, T second) &#123; this.first = first; this.second = second; &#125; &#125; 会被擦除为： 12345678910111213public class Pair&#123; private Float first; private Float second; public Pair() &#123; &#125; public Pair(Float first, Float second) &#123; this.first = first; this.second = second; &#125; &#125; 这是因为T被限定为继承了Float的类。所以被擦除为Float。 例3： 12345678910111213public class Pair&lt;T extends Serializable &amp; Comparable&gt; &#123; private T first; private T second; public Pair() &#123; &#125; public Pair(T first, T second) &#123; this.first = first; this.second = second; &#125; &#125; 会被擦除为 12345678910111213public class Pair&#123; private Serializable first; private Serializable second; public Pair() &#123; &#125; public Pair(Serializable first, Serializable second) &#123; this.first = first; this.second = second; &#125; &#125; 当有多个限定时规则如下： 将类型转换为第一个超类（接口）。 在必要时需要向Comparable接口插入强制类型转换。 所以应该尽量把包含方法的接口方法在第一个，可以减少强制转换。提高效率。 转换泛型表达式由于编译器对泛型做了擦除。所以实际上编译器在接受到泛型的位置加上了强制类型转换。如： 12Pair&lt;Integer, Integer&gt; pair = new Pair(1, 2);Integer f = pair.getFirst(); 实际上会被转化为 12Pair pair = new Pair(1, 2);Integer f = (Integer)pair.getFirst(); 因为这里pair.getFirst()返回的实际上是Object。 泛型方法与桥方法泛型方法也一样会被擦除类型，与类一样的规则。如： 123public staic &lt;T&gt; T getMid(T... a)&#123; return a[a / length / 2];&#125; 会被擦除为： 123public staic Object getMid(Object... a)&#123; return a[a / length / 2];&#125; 一般来说是不会存在问题，但是如果出现以下情况： 12345public class DateInterval extends Piar&lt;LocalDate&gt;&#123; public void setSecond(LocalDate second)&#123; //... &#125;&#125; 在类型擦除之后，会编为如下代码： 12345public class DateInterval extends Piar&#123; public void setSecond(LocalDate second)&#123; //... &#125;&#125; 但是由于父类原始的setSecond参数类型为T，则会被擦除为Object，所以实际上这个类中会包含两个setSecond方法 public void setSecond(Object second)：来自擦除后的父类。 public void setSecond(LocalDate second)：来自擦除后的本身类。 那么考虑如下代码： 123var interval = new DateInterval(...);Pair&lt;LocalDate&gt; pair = interval;pair.setSecond(aDate); 这里我们将子类赋值给父类。而父类由于是个泛型类，所以其setSecond(T second)会被擦除为setSecond(Object second)。 我们实际上是想调用子类的public void setSecond(LocalDate second)方法。但是由于父类并没有这个重载方法，所以会调用public void setSecond(LocalDate second)方法。这样就不符合我们的预期了。 所以编译器创建了所谓的桥方法。这个桥方法会去调用子类的的方法DataInterval.setSecond(LocalData);。 但是考虑如下情况： 当子类重载了父类的方法。 123class DateInterval extends Pair&lt;LocalDate&gt;&#123; public LocalDate getSecond()&#123;return (LocalDate)super.getSecond()&#125;;&#125; 那么在子类中，经过擦除之后，会有以下这个两个方法： LocalDate getSecond() Object getSecond() 虽然我们在编写代码时并允许这样的情况存在，因为方法名和参数共同构成了方法的方法签名用于识别这个方法。 但由于这是编译器生成的，所以虚拟机能够正确处理这种情况。 所以实际需要记住以下的特点： 虚拟机中没有泛型，只有普通的累和方法。 所有的类型参数都会被替换为它们的限定类型。 会合成桥方法来保持多态。 为保持类型安全性，必要时会插入强制类型转换。 限制与局限性1. 不能用基本类型实例化类型参数不能用基本类型实例化类型参数。即没有Pair&lt;double&gt;，只有Pair&lt;Double&gt;。其主要原因还是在于类型擦除。擦除之后，Pair类含有Object类型的字段，而Object不能存储基本类型。但是也并会有很大的影响，因为每种基本类型都有其包装类型。 2. 类型查询不能检查出同一类别泛型的不同即类型查询只产生原始类型。 所以，instanceof不能用于检查泛型类型，如： 1if(pair1 instanceof Pair&lt;String&gt;)&#123;&#125;; //Cannot perform instanceof check against parameterized type Pair&lt;String&gt;. Use the form Pair&lt;?&gt; instead since further generic type information will be erased at runtime 3. 不能创建参数化类型的数组以下代码会报错 1var table = new Pair&lt;String&gt;[10]; //Cannot create a generic array of Pair&lt;String&gt; 其原因也在于类型擦除，如果允许这种机制的存在，那么擦除后table将是一个Object[]，但我们期望的时Pair&lt;String&gt;类型，则类型检查失效，因此禁用这样的声明。 注意：声明这种类型时允许的，但是使用其初始化是不允许的。 要想存储泛型数组有以下两种方法： 先使用通配类型来初始化，在强转为对应类型： 1var table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10]; 但这样并不安全，因为这样同样会失去对泛型的类型检查。 使用ArrayList来存储泛型对象：ArrayList&lt;Pair&lt;String&gt;&gt; 4. Varargs警告上面提到了不能创建泛型类数组，但是当我们向方法中传递可变长参数时，方法内部实际得到的是一个对应参数类型的数组。那么如果传递的是泛型类的对象，则违背了第3条规定。此时虚拟机是允许这种方式的存在，但是会产生一个Varargs警告。 Type safety: Potential heap pollution via varargs parameter pairs 有两种方法可以来抑制这个错误： 增加注解@SuppressWarning(&quot;unchecked&quot;) 增加注解@SafeVarargs 5. 不能实例化类型变量不能在类似new T(...)的表达式中使用类型变量。 在Java8之后，最好的解决办法是让调用者提供一个构造器表达式。如： 1Pair&lt;String&gt; p = Pair.makePair(String::new); makePair接受一个Supplier&lt;T&gt;，这是一个函数式接口，表示一个无参数而且返回类型为T 的函数： 123public static &lt;T&gt; Pair&lt;T&gt; makePair(Supplier&lt;T&gt; constr)&#123; return new Pair&lt;&gt;(constr.get(), constr.get());&#125; 在Java8之前，一般是通过反射Constructor.new Instance来实现。 但是不能通过T.class.getConstructor().newInstance()来构建，因为T会被擦除为Object。 一个示例的函数应当如下所示： 1234567public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)&#123; try&#123; return new Pair&lt;&gt;(cl.getConstructor().newInstance(), cl.getConstructor().newInstance()); &#125;catch(Exception e)&#123; // handle Exception &#125;&#125; 可以这样调用： 1Pair&lt;String&gt; p = Pair.makePair(String.class); 6. 不能构造泛型数组不能实例化泛型变量，则同样的，也不能构造泛型数组。 即T[] mm = new T[2];这样是不合法的。 类型擦除会使其总构造出Object[]。 这里同样可以 使用提供构造器Stringp[]::new。 使用反射Array.newInstance来实现。 7. 泛型类的静态上下文中类型变量无效即不能在静态字段或方法中引用类型变量。即 123public class C1&lt;T&gt;&#123; private static T var1; //Cannot make a static reference to the non-static type T&#125; 8. 不能抛出或捕获泛型类的实例既不能抛出也不能捕获泛型类的对现象。实际上，泛型类扩展Throwable甚至都是不合法的。 如扩展Throwable： 1public class Problem&lt;T&gt; extends Exception&#123;&#125; //ERROR--can`t extend Throwable 抛出含有泛型的Throwable 1234567public static &lt;T extends Throwable&gt; void doWork(Class&lt;T&gt; t)&#123; try&#123; //code &#125;catch(T e)&#123; // ERROR--can`t catch type variable //code &#125;&#125; 不过，在异常规范中使用类型变量是允许的。即以下方法是合理得： 1234567public static &lt;T extends Throwable&gt; void d&#123; try&#123; //code &#125;catch(Throwable e)&#123; //code &#125;&#125; 9. 可以取消对检查型异常的检查Java异常处理的一个基本原则是，必须为所有检查型异常提供一个处理器。不过可以利用泛型取消这个机制。 10. 注意擦除后的冲突当泛型类型被擦除后，不允许创建引发冲突的条件。 假定Piar类增加一个equals方法，如下： 12345public class Pair&lt;T&gt;&#123; public blooean equals()&#123; //code &#125;&#125; 当T为String时，则在类型擦除之前，其会有两个equals方法： boolean equals(String)：定义在Pair中 blooean equals(Object)：从Object中继承 但是在擦除之后就会有两个相同的blooean equals(Object)方法，这就产生了冲突。 所以，泛型还增加了另外一个原则：如果两个接口类型是同一接口的不同参数化，一个类或类型变量就不能同时作为这两个接口类型的子类。即如下代码就是错误的： 12class Employee implements Comparable&lt;Employee&gt;&#123;...&#125;;class Manager extends Employee implements Comparable&lt;Manager&gt;&#123;...&#125; //ERROR 其原因在于，又可能会与合成的桥方法产生冲突。 实现Comparable的类将会获得一个桥方法： 1public int comparaTo(Object other)&#123;return compareTo((X) other);&#125; 不能对不同的类型x有两个这样的方法。 泛型类型的继承规则泛型中的继承规则很简单，就是类型参数完全与继承链无关。 例如，ArrayList&lt;Double&gt;与ArrayList&lt;Number&gt;完全没有关系。 而ArrayList&lt;Double&gt;是AbstractList&lt;Double&gt;的一个子类。（ArrayList&lt;E&gt;是AbstractList&lt;E&gt;的子类） ArrayList&lt;Double&gt;是对原ArrayList&lt;E&gt;的一个继承。 通配符类型概念由于Java中的泛型规定的很严格，所以设计了“通配符类型”来缓解。 子类型限定在通配符类型中，允许类型参数发生变化，比如： 1Pair&lt;? extends Employee&gt; pair1 = new Pair&lt;Employee&gt;(); 表示任何泛型Pair类型，只要其为Employee或者其子类即可。如Pair&lt;Manager&gt;。 记得前面说的，泛型参数中不允许其子类多态存在。即： 123public class Pair&lt;Employee&gt;&#123; ...&#125; 我们不能这么定义Pair 1Pair&lt;Employee&gt; pair1 = new Pair&lt;Manager&gt;(); 但是现在可以使用通配符来实现该功能： 1Pair&lt;? extends Employee&gt; = new Pair&lt;Manager&gt;(); 所以从继承的角度来说， Pair&lt;Manager&gt;和Pair&lt;Employee&gt;继承自Pair&lt;? extends Employee&gt;； Pair&lt;? extends Employee&gt;继承自Pair&lt;T&gt;； 但是其缺点在于其不能调用含通配类型的参数的方法，如： 12Pair&lt;? extends Employee&gt; pari1= new Pair&lt;Manager&gt;();pair1.setFirst(employee1); //compile error 这是因为在编译器中，setFirst接受的参数是一个继承自Employee，但不知道具体是什么类型。所以它拒绝接受任何特定的类型。毕竟?不能匹配。（也就是说：编译器并不知道具体代码中的继承链，？仅仅是占位） 但是getFirst是可以执行的，因为其将getFirst的返回值赋值给一个Employee是完全合法的。 超类型限定超类型限定限定指限定?必须为某一个类的父类。如： 1? super Manager 指定?必须为Sub的父类。 则这里的行为与子类限定相反，?不能作为方法的返回值，但是可以作为方法的参数。其道理也恰好相反。 setFirst方法中，编译器无法知道其具体类型，所以不能接受参数类型为Employee或者Object的方法调用。只能传递Manager类的对象，或者某个子类型。另外，如果调用getFirst方法，不能保证返回对象的类型。只能将其赋值给一个Object。 总结带有子类型限定符的泛型通配符允许你获取一个泛型对象；而带有超类型限定符的泛型通配符允许你写入一个对象。 其主要原因我们需要理解一个点就是：？仅仅是一个类的限定代指，他不会翻译为任何具体的类，也就是说编译器不会判断你传入的这个类是否是XXX的子类或者父类，其只会按照可以安全转换的方式来执行。 比如子类限定，? extends Employee，这里的？仅仅是限定一个Employee子类的代指。而且编译器不会判定我们传入的类型是否是其子类。所以即使我们传入Manager，也不会被接受，因为根本不会判断。但是get方法返回的?可以确定为Employee的子类，所以可以在在外部被接收到。 父类限定也是一样，记住?不代表任何具体的类，其只是一个限定的代指，编译器不会为其做任意判定。 无限定通配符除了上面的限定通配符，无限定通配符也是存在的：Pair&lt;?&gt;。其可以看成Pair&lt;? extends Object&gt;。因为所有的对象都是基于Object，所以也相当于无限定。 这相当于是子类限定，所以其set方法仍然是无法调用的。而get方法会返回一个Object对象。 所以虽然无限定通配符Pair&lt;?&gt;与泛型类型Pair&lt;T&gt;形式上相似，但实际上是不相同的。 通配符捕获所谓通配符捕获，即解决无法在方法中获取含有通配符的类的通配符类型的问题，具体例子： 1234567public void swap(Pair&lt;? extends Employee&gt; p)&#123; //不能拿到?的类型 ? temp = p.getFirst(); //ERROR p.setFirst(p.getSecond()); p.setSecond(temp);&#125; 上面的代码是错误的，因为?不能用来声明变量。（就像之前说的，它不代表任何一个具体的类，其只是一个限定） 但是我们要实现这样功能又该怎么做呢？ 可以用一个辅助类 12345public static &lt;T&gt; void swapHelper(Paor&lt;T&gt; p)&#123; T temp = p.getFirst(); //ERROR p.setFirst(p.getSecond()); p.setSecond(temp);&#125; 然后再swap中调用helper类： 1234public void swap(Pair&lt;? extends Employee&gt; p)&#123; wapHelper(p);&#125; 因为我们将p传入helper中，而helper是一个普通泛型类，所以其可以捕捉T的类型。 当然这个例子看起来有点蠢，但只是一个例子。 反射和泛型如果通过反射去分析泛型参数，那么将不会得到太多信息，因为其已经被编译器擦除了，而反射是工作在虚拟机中的。 泛型Class类Class类实际是一个泛型类。如：String.class实际上是一个Class&lt;String&gt;类的对象。（也是唯一的对象） 使用Class\\&lt;T>参数进行类型匹配匹配泛型方法中Class&lt;T&gt;参数的类型变量有时会很有用。比如下面的例子： 123public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; c) throws InstantiataionException, IllegalAccesssException&#123; return new Pair&lt;&gt;(c.newInstance(), c.newInstance());&#125; 在外部，我们就可以这样调用： 1makePair(Empployee.class); 即通过Class&lt;T&gt;反射来新建特定类的对象。 虚拟机中的泛型类型信息Java泛型的突出特点之一是在虚拟机中擦除泛型类型。但实际上，在擦除过后，其类型仍然保留对泛型的微弱信息。例如，原始的Pair类知道其是源于泛型类Pair&lt;T&gt;，对然并不知道T具体为什么类型。 我们可以通过反射java.lang.reflect包中的接口Type来查看一些信息： Class类：描述具体类型。 TypeVariable接口：描述类型变量（如T extends Comparable&lt;? super T&gt;） WildcardType接口：描述通配符（如? super T） ParameteriszedType接口：描述泛型类或接口类型（如Comparable&lt;? super T&gt;） GenericArrayType接口：描述泛型数组（如T[]） 以上的接口都继承自Type接口，而Class&lt;T&gt;是Type的实现。 类型字面量如上一节介绍的，我们可以通过反射来获取泛型的相关信息，因此，我们也可以通过这种方式来捕获泛型类型，假设定义了一个泛型类\\&lt;T>，我们可以通过以下示例的方式来捕获其类型接口Type来进行判断和处理。 123456789101112class TypeLiteral&lt;T&gt;&#123; Type type; public TypeLiteral()&#123; Type parentType = getClass().getGenericSuperClass(); if(parentType instanceof ParameterizedType)&#123; type = ((ParameterizedType) parentType).getActualTypeArguments()[0]; &#125;else&#123;&#123; throw new UnsupportedOperationException(\"Construct as new TypeLiteral&lt;...&gt;()&#123;&#125;\") &#125;&#125; &#125; //other methods&#125; 注意在调用时需要这么调用： 1var type = new TypeLiteral&lt;ArrayList&lt;Integer&gt;&gt;()&#123;&#125;; 注意这里的格式是在new之后加了一个大括号，这种格式有以下几种类型： 创建其匿名内部类，如new Parent(){}实际上创建了一个Parent的子类。{}内部可以重写其方法。值得注意的是，我们可以用来表示初始化块。实际之前也介绍过，其等价于： 12345public class XXX extends Parent&#123; &#123; //init &#125;&#125; 在实际中我们可以通过继承ArrayList或者HashMap然后用初始化块的方式来快速为其赋值(但注意，这里实际用的就是对应类型的子类，而不是其本身，虽然方法都继承了过来)。如： 12345678910Map&lt;String,Object&gt; study = new HashMap&lt;String,Object&gt;()&#123;&#123; put(\"name\",\"java\"); put(\"id\",\"1\");&#125;&#125;;List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;()&#123;&#123; add(1); add(2); add(3);&#125;&#125;; 实例化接口，同样的，我们可以通过这种方式来实现一个接口，比如最常见的，Runable接口： 1234567//直接开启一个线程new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"线程开启！\"); &#125;&#125;).start(); 这里有一篇关于这种写法的 文章，其内容大致是正确的，但是有些表述不太准确。供参考。","categories":[{"name":"Jav","slug":"Jav","permalink":"http://yoursite.com/categories/Jav/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"java核心技术-I-8-泛型程序设计","slug":"java核心技术-I-8-泛型程序设计","permalink":"http://yoursite.com/tags/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-8-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"java核心技术-I-7-异常、断言和日志","slug":"java核心技术-I-7-异常、断言和日志","date":"2022-01-21T03:36:02.000Z","updated":"2022-01-21T10:38:30.878Z","comments":true,"path":"2022/01/21/java核心技术-I-7-异常、断言和日志/","link":"","permalink":"http://yoursite.com/2022/01/21/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-7-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/","excerpt":"","text":"异常分类在Java程序设计语言中，所有异常对象都是派生于Throwable类的一个类示例。 继承关系图如下： ![错误类继承]images\\java核心技术\\错误类继承.jpg) 可以看到Throwable异常被分为两大类： Error：表示Java运行时系统的内部错误和资源耗尽错误。 Exception：程序运行的异常，一般我们能操作的都是这种错误。 RuntimeException 一般是编程错误导致的。 派生于RuntimeException的异常包括以下问题： 错误的强制转换 数组访问越界 访问null指针 IOException的异常包括以下问题： 试图超越文件末尾继续读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在 如果出现RuntimeException，那么就一定是你的问题。 所以这句话有一定的根据（当然错误也可能出现在你引用的库中） Java语言规范将派生于Error类或RuntimeException类的所有异常称为非检查型（unchecked）异常，所有其他的异常称为检查型（check）异常。 抛出异常可以通过throw关键字来抛出异常。 Java在库中定义了很多错误类型，我们可以通过查阅文档来获得相应的错误类型。（当然我们也可以定义自己的错误类型） 示例如下： 1234public void method1()&#123; ///do something throw new EOFExcepiton();&#125; 创建异常类我们可以通过继承Exception类或者其子类来创建单独的异常类。 基本示例如下： 123public class MyException extends Exception&#123; &#125; Throwable类中定义了很多成员，其中主要有message:String和cause:Throwable。而Exception也根据其提供了4个构造方法。 无参构造器 只含message的构造器 只含cause的构造器 包含message和cause的构造器 所以我们也可以这样定义 12345678910111213141516171819202122232425package test.mw.ExceptionTest;public class MyException extends Exception&#123; public MyException() &#123; super(); // TODO Auto-generated constructor stub &#125; public MyException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public MyException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125; public MyException(Throwable cause) &#123; super(cause); // TODO Auto-generated constructor stub &#125; &#125; 捕获异常如果发生了某个异常，但没有任何地方捕获这个异常，程序就会停止，并且惠子啊控制面板上打印一个消息：包括这个异常的信息和调用堆栈。 捕获异常可以通过 1234567try&#123; // normal code&#125;catch(Exception e)&#123; // code for handling the exception&#125;finaly&#123; // code need to be execeuted anyway&#125; 来捕获异常，其含义如下： 如果normal code发生错误，则错误后的代码都不会被执行。 将错误传递到catch块中进行处理 finally中的代码无论如何都会执行（normal code发生错误或不发生错误都会执行） 如果normal code中可能发生的错误不只一个。我们可以通过以下两种方式来进行处理： 添加多个catch块来分别处理 使用catch(Exception1 | Exception2 | Exception3 e)的格式来捕获多个错误。 使用catch(Exception e)来通过多态来捕获所有可能的异常。（这里即使发生错误，也会在控制台打印出具体的类名，而不是Exception）。 再次抛出异常一般来说，我们可以再次抛出异常。而在最外围来捕获所有的异常。其有两种形式： 在catch中捕获到后再次抛出。 12345try&#123; // code&#125;catch(Exception e)&#123; throw e;&#125; 直接在方法上抛出错误。 123public void String save() throws Exception&#123; // code&#125; try…with-Resource语句有时我们需要在try语句中打开一些资源，并且最后必须关闭，我们通常会使用finally语句来实现。如： 1234567try&#123; source.open();&#125;catch(Exception e)&#123; ///handle&#125;finally&#123; source.close();&#125; 在Java7之后，可以用try...with-Resource语句来关闭资源，前提是这个资源实现了AutoCloseable接口。格式如下： 123try(Resource res = ...)&#123; //res is include in the scope&#125; 在try语句退出之后，会自动调用res.close()。 也可以指定多个资源： 12345try(Resource res1 = new Resource(); Resource res2 = new Resource(); )&#123; //res1 and res2 is include in the scope&#125; 使用异常的技巧 异常处理不能代替简单的判断：即能用if判断是否出现异常的，就不直接用异常。 不要过分的细化异常。 不要只捕获Exception或者Throwable，因为这对代码阅读并不友好，无法直接判断可能出现的错误。 不要对异常进行静默处理。即catch必须做点什么，而不是仅捕获，什么都不做。 并不一定要捕获所有异常，有时候抛出到外层是更好的选择（可以在外层做统一处理）。 断言有时候我们需要在测试期间加入一些判断，如果条件不成立，则退出程序。但是在正式版本中，将会删除这部分代码，这是很麻烦的。 所以引入了断言机制，其格式如下： assert conditon;：如果condition为false，则退出程序，并抛出AssertionError。 assert condition : expresssion：如果condition为false，则退出程序，并抛出AssertionError，并且信息为expression。 启用断言断言默认是被禁用的。。 启用断言需要加上vm关键字：-ea或者-enableassertions。 也可以使用-desableassertions或-da来禁止断言。 idea或eclipse中可以在环境参数中配置。 启用或禁用断言是类加载器的功能。断言被禁用时，类加载器会去除断言代码，因此不会降低陈旭运行时的代码。 日志在Java程序中，我们经常需要打印中间信息。 我们通常使用System.out.print来进行打印。 但是其具有很多缺点。相较于直接输出，日志API有以下 优点： 日志分级。并且可以分级打印特定日志级别下的信息。 可以很简单的禁止日志记录。 可以将日志信息打印到控制台或保存在文件中。 可以对所有日志进行过滤。 可以单独的格式化日志信息。 可以单独的配置日志设置。 Java从1.5开始，在java.util下增加了Logger类。但是这个类已经很少有人使用。使用Log4j的更多，所以这里不详细介绍。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"异常、断言和日志","slug":"异常、断言和日志","permalink":"http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/"}]},{"title":"java核心技术-I-6-接口、lambda表达式与内部类","slug":"java核心技术-I-6-接口、lambda表达式与内部类","date":"2022-01-20T02:33:47.000Z","updated":"2022-01-20T09:05:56.067Z","comments":true,"path":"2022/01/20/java核心技术-I-6-接口、lambda表达式与内部类/","link":"","permalink":"http://yoursite.com/2022/01/20/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-6-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"接口接口的概念接口不是类，而是希望符合这个接口的类的一组需求。接口不能实例化。 注意： 接口中方法会默认指定为public abstract。 接口中的方法可以有实现，需加default关键字，使其作为该方法的默认实现（jdk1.8）。 接口中有静态方法和方法体（jdk1.8）。 接口中允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。（jdk1.9）。 接口中的变量会被默认指定为public static final。（且只能为public，private会报错）。 例如： 12345678910111213141516public interface Minterface &#123; int mm = 123; int description(); default void id() &#123; &#125; public static void name() &#123; &#125; private int phone() &#123; return 0; &#125;&#125; 接口的属性 尽管不能构造接口的对象，确能声明接口的变量。且接口的变量必须引用实现了这个接口的类对象。（这也是实现解耦的关键） 接口也允许扩展，通过extends关键词来实现扩展（其中的静态变量也会被继承）。 123public interface A&#123;&#125;public interface B extends A&#123;&#125; 一个类可以实现多个接口（而一个类只能继承一个超类）。 接口与抽象类 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 在一些编程语言中允许一个类继承多个类，如C++，这个特性被称为多继承（multiple inheritance）。Java的设计者选择了不支持多继承，其主要原因是多继承会让语言变得非常复杂，或者效率会降低。 默认方法冲突接口与超类的冲突当接口中的默认方法与超类中的方法冲突时，按超类优先的规则来调用方法，即同名的接口中的方法都会被忽略。（注意，只有方法名和参数都相同才会被认为是同一个方法，即函数名和参数类型二者被称为方法签名） 接口冲突当两个接口都实现了getName方法，则编译器会报错，并且要求开发者自己决定选择哪个方法。 可以用以下方式来二选一方法： 12345class A implements Inter1, Inter2&#123; public String getName()&#123; return Inter1.super.getName(); &#125;&#125; lambda表达式lambda表达式时一个可传递的代码块，可以执行多次或一次。 （实际上我觉得这是面向对象的函数式编程的补充，比如回调场景要传递一个函数，这时候在Java中，就必须新建一个对象，内部包含一个函数。这明显是浪费的。不如直接传递一个函数，这也是lambda表达式出现的原因吧） 语法123(String i, String j) -&gt; &#123; return i.length - j.length;&#125; 注意点如下： 把这些代码放在{}中，并包含显式的return 语句。 123(String first, String second) -&gt; &#123; return first.length() - second-length();&#125;; 即使lambda表达式没有参数，也必须要写括号。 123() -&gt; &#123; return 0;&#125;; 如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。 123Comparator&lt;String&gt; comp = (first, second) -&gt; &#123; return first.length() - second.length();&#125;; 如果该方法只有一个参数，而且这个参数的类型可以推导出，那么可以省略小括号。 1ActionListener listen = event -&gt; System.out.print(event); 无需指定lambda表达式的返回类型。lambda表达式的返回值类型总是由上下文推到得出。 当lambda表达式只包含一条语句且其就是返回值，则可以不用加return和花括号，直接写该句即可。 1Comparator&lt;String&gt; comp = (first, second) -&gt; first.length - seconde.length; 函数式接口函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。 Java中有很多封装代码的接口，如ActionListener或Comparator。lambda表达式与这些接口兼容。 对于需要这些接口的位置，提供一个lambda表达式即可达到同等的效果。 如，（Arrays.sort方法第二个参数需要一个Comparator实例，而Comparator就是一个函数式接口）： 1Arrays.sort(words, (first, second) -&gt; first.length() - second.length()); 在底层，Arrays.sort方法会接受实现了Comparator&lt;String&gt;的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。 实际上，对lambda表达式所能做的也只是转换为函数式接口。 方法引用有时需要直接调用一个定义好的函数作为lambda表达式体。可以通过以下格式 object.instanceMethod：等价于向方法中传递参数的lambda表达式。 Class.instanceMethod：第一个参数会成为方法的隐式参数，如，String::comparaToIgnoreCase等同于(x, y) -&gt; x.comparaToIgnoreCase(y)。 Class.staticMethod：所有参数都传递到静态方法，如：Math::pow等价于(x, y) -&gt; Math.pow(x, y)。 来作为该方法的引用。例如： 1var time = new Time(1000, event -&gt; System.out::println) 同样的，方法引用也不是一个对象。不过，为一个类型为函数式接口的变量赋值时会生成一个对应的对象。 注意： 只有当lambda表达式的体只有调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用。 也可以在方法引用中使用this参数。如this::equals等同于x-&gt;this.equals(x)。 也可以使用super表达式来引用super中的方法，，如super.equals。 构造器引用构造器引用与方法引用很类似，只不过方法名为new。如，Person::new是Person构造器的一个引用。具体选择哪一个引用取决上下文。 例如： 123ArrayList&lt;String&gt; names = ...;Stream&lt;Person&gt; stream = names.stream().map(Person::new);List&lt;Person&gt; people = stream.collect(Collectors.toList()); Java有一个限制，无法构造泛型类型T的数组。数组构造器引用对于克服这个限制很有用。如：new T[n]会产生错误，因为这会改为new Object[n]。 但是我们可以使用Stream.roArray()来获得一个数组，如果不传参，则默认返回Object[]。 但是可以如果传入对象的构造器引用，则可以获得对应的数组。 1Person[] people = stream.toArray(Person[]::new); 变量作用域在lambda表达式中，可以引用lambda表达式外部的变量。从而形成闭包（enclosure）。但是其由如下特点： 引用的外部变量只能读取，不能改变。 在lambda表达式中引用的变量，在外部也不能别改变。 简而言之，lambda表达式中捕获的变量必须实际上最终变量（effective final）。即这个变量初始化之后就不会再为它赋新值。 其还有如下特点： lambda表达式中声明的变量名不能为外部已经声明的变量名。 lambda表达式中的this，指向创建这个表达式的方法的this参数。 java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的部分函数式接口有： 序号 接口 &amp; 描述 1 BiConsumer&lt;T,U&gt;代表了一个接受两个输入参数的操作，并且不返回任何结果 2 BiFunction&lt;T,U,R&gt;代表了一个接受两个输入参数的方法，并且返回一个结果 3 BinaryOperator&lt;T&gt;代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果 4 BiPredicate&lt;T,U&gt;代表了一个两个参数的boolean值方法 5 BooleanSupplier代表了boolean值结果的提供方 6 Consumer&lt;T&gt;代表了接受一个输入参数并且无返回的操作 7 DoubleBinaryOperator代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。 8 DoubleConsumer代表一个接受double值参数的操作，并且不返回结果。 9 DoubleFunction&lt;R&gt;代表接受一个double值参数的方法，并且返回结果 内部类内部类（inner class）是定义再另一个类中的类。其存在原因主要有以下： 内部类可以对同一个包中的其他类隐藏。 内部类的方法可以访问这个类的作用域中的数据，包括原本私有的数据。 内部类原来是用来简洁的实现回调，但现在lambda表达式是更好的选择。 内部类的特殊语法规则我们可以通过OuterClass.this的语法来引用外部对象。如： 12345678910111213141516171819public class Outer&#123; private int id; public class Inner&#123; pirvate String name; public int getId()&#123; return Outer.this.id; //这样引用外部类 &#125; &#125; public Inner getInner()&#123; return new Inner(); &#125;&#125;Outer o = new Outer();Outer.Inner i = o.getInner(); //这样引用内部类i.getId(); //null 同样的，可以像上面代码中的Outer.Inner来从外部引用内部类。 内部类的底层内部类实际上是编译器的工作，而不是虚拟机的工作。所以实际上编译器会把内部类转换为常规的类文件，用$分隔外部类名与内部类名，而虚拟机并不知晓。 例如，Outer$Inner表示器内部类。 实际上在内部类中，会生成一个this$0来表示外部引用。 而既然在虚拟机中内部类被分为两个类，又是如何做到访问外部类的私有成员呢。 其原因在于，编译器向外围类中添加了静态方法access$0之类的方法。它将返回作为参数传递的那个对象的字段。（具体名字取决于编译器。） 此时在内部类中调用外部的成员时。如： 1if(id) 会被翻译为： 1if(Outer.access$0(outer)) 局部内部类局部内部类是指在一个方法中局部的定义这个类。如： 123456789public int sum(int a, int b)&#123; class BiSUM&#123; public int sum(int newA, int newB)&#123; return newA + newB; &#125; &#125; BiSUM bs = new BiSUM(); return bs.sum(a, b);&#125; 注意： 局部类时不能由访问符（即public和private） 局部类的作用域仅限于在声明这个类的块中。 局部类可以做到完全隐藏，除了方法，连兄弟内部类都不知道。 局部内部类不仅可以访问外部类的字段，还可以访问方法的局部变量。但是，于lambda表达式类似，这些局部变量必须使事实最终变量。即，他们一旦赋值就绝不会改变。 同样的，编译器会在内部类中定义引用的局部变量的复制。如： 1234567891011public int sum(int a, int b)&#123; String name = \"123\"; class BiSUM&#123; public int sum(int newA, int newB)&#123; System.out.print(name); return newA + newB; &#125; &#125; BiSUM bs = new BiSUM(); return bs.sum(a, b);&#125; 会被翻译为如下： 1234public Outer$Inner&#123; final Outer this$0; final val$name;&#125; 匿名内部类使用局部内部类时，通常还可以省略类名。这样的类被称为内部匿名类。 语法如下： 123new SuperType(construction parameters)&#123; inner class method and data&#125; superType可以时接口，如ActionListener，这样就是扩展这个接口。 也可以是类，如果是这样，内部类就要扩展这个类。 由于匿名内部类没有名字，所以也没有构造器。如果需要初始化，则可以加一个对象初始化块： 123var count = new Person(\"Tim\")&#123; &#123;initialization&#125;&#125; 静态内部类有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类有外围类对象的一个引用。为此，可以将内部类声明为static，这样就不会生成那个引用。 注意： 并且只有内部类可以声明为static。 于常规类不同，静态内部类可以有静态字段和方法。 示例： 1234567891011121314151617public class Draw&#123; public static class Pair&#123; private int x; private int y; public void Pair(int x, int y)&#123; this.x = x; this.y = y; &#125; &#125; public static Pair getPair(int x, int y)&#123; return new Pair(x, y); &#125;&#125;Draw.Euclidean euclidean = Math.getPair(1, 2); 这种形式其实更像是类的命名空间，相当于一个类的集合。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"接口、lambda表达式与内部类","slug":"接口、lambda表达式与内部类","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"}]},{"title":"Java核心技术-I-5-继承","slug":"java核心技术-I-5-继承","date":"2022-01-19T02:20:34.000Z","updated":"2022-02-17T15:40:53.535Z","comments":true,"path":"2022/01/19/java核心技术-I-5-继承/","link":"","permalink":"http://yoursite.com/2022/01/19/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-5-%E7%BB%A7%E6%89%BF/","excerpt":"","text":"类，超类和子类定义子类使用以下格式表示继承。 123public class A&#123;&#125;public class B extends A&#123;&#125; 即，使用关键字extends表示继承关系。 A被被称为超类（super class）、父类（parent class）或基类（base class）。 B被称为子类（subclass）、派生类（derived class）和孩子类（child class）。 由于子类继承并父类且可以扩展，所以子类一般比父类有更多的功能。 注意：子类中会继承父类的所有属性和方法，但私有属性和方法并不能直接访问。如： 123456789101112131415161718192021222324252627282930313233343536373839public class A&#123; private int id; public int getId()&#123; return this.id; &#125; public void setId(int id)&#123; this.id = id; &#125;&#125;public class B extends A&#123; private String name; public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int newGetId0()&#123; return this.id; //editor will report error &#125; public int newGetId1()&#123; return getName(); &#125;&#125;B b = new B();b.setId(1); //correctb.getId(); //correctb.newGetId1(); //coorectb.newGetId0(); //incorrectb.id; //incorrect 即从上面的代码可以看出，在子类的实例中，父类的私有属性会被初始化，只是子类无权限访问，只能通过getter来间接访问。 覆盖方法（重写）重写是指在子类中重新定义父类的方法来实现不同的功能。 pre： this关键字用于访问当前类的作用域 super关键字用于访问父类的作用域 当不加前缀时代表从子类开始向父类的作用域中进行搜索。而加了上述关键字则只从特定的作用域中搜索。 示例： 12345678910111213141516171819202122232425262728public class A&#123; private int id; public int getId()&#123; return this.id; &#125; public void setId(int id)&#123; this.id = id; &#125;&#125;public class B extends A&#123; private String name; public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name = name; &#125; @Override public int getId()&#123; return 'id='+super.getId(); &#125;&#125; 注意上述B类中的getId方法。其内部为了调用父类的getId方法，加了前缀super关键字。（前面的例子之所以可以不加关键字调用父类的getId方法，是子类中不存在getId方法，按照作用域链搜索上去就能找到父类的方法，而此时子类定义了getId方法，如果不加前缀，就会搜索到子类的方法，造成递归调用，显然这不是我们的本意。） 注意： 这里的super并不指向某一特定对象，而是指示编译器调用父类方法的关键字。 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同。 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)。 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。 子类构造器在子类构造器中，我们可以使用super关键字来调用父类的构造器。且必须位子构造器的第一局。如： 123456789public class Sub extends Parent&#123; private String name; public void Sub(int id, String name)&#123; super(id); this.name = name; &#125;&#125; 注意： this有两个含义： 指隐式参数的调用：this.id = id 该类的其他构造器：this() super也有两个含义： 调用超类的方法：super.getId() 调用超类的构造器：super(id) 多态（继承的角度）多态是同一个行为具有多个不同表现形式或形态的能力。 is-a规则的另一种表述是“替换规则”。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。如，可以将子类的对象赋值给超类变量。 1Sub b = new Parent(); 但注意，替换后的类为父类，也就是说如果子类的扩展了新方法，就无法调用。但是调用旧的方法返回的是子类重写的方法。 方法调用流程 编译器会一一列举子类和超类中（可访问）的名为xxx的方法。 编译器确定方法调用中提供的参数类型。如果存在名字相同且参数也完全相同的方法，则选择该方法执行。该过程被称为重载解析（overloading resolution）。如果没找到，则尝试将调用参数进行类型转化，比如继承中父子类的转化。 如果是private方法、static方法、final方法或者构造器，那么编译器知道该从哪个作用域中调用该方法（即这些修饰符修饰的方法只能定义在该对象上，不可能去向上查找父类）。这被称为静态绑定（static binding）。于此对应的是，如果要调用的方法依赖于调用的参数类型，那么其被称为动态绑定（dynamic binding）。 动态绑定时，假设变量b声明为A类型，实际是B类型，则编译器先在B类中查找对应方法，否则在B中查找（若B有超类，也会向上查找）。 实际上为了改善性能，虚拟机为每个类定义了一个方法表，其中列出了所有方法的签名和要调用的实际方法。当要调用时，只需查表即可。 被声明为final的类和方法不能被继承 被声明为final的类和方法不能被继承 final字段在构造对象之后就不允许改变他们的值了。 如果一个类被声明为final，则其中的方法自动声明为final，而不包括字段。 强制类型转换 只能在继承的层次内，将父类转换为子类（父类的变量可以接受子类的值-多态）。 在转换之前，应该使用instanceof进行检查。 抽象类抽象类一般指更加抽象，上层的类定义。其有如下特点： 不可被实例化，只有继承它的子类可以被实例化。 任何包含抽象方法（即通过abstract声明）的方法类都必须声明为抽象（abstract），反之不成立，抽象类中可以包含非抽象的方法，并且可以提供实现。 受保护访问protected关键字定义的属性和方法可以在子类和同包中可以访问。例如： 1234567891011121314151617181920212223242526272829303132public class A&#123; private int id; protected int groupId; public int getId()&#123; return this.id; &#125; public void setId(int id)&#123; this.id = id; &#125;&#125;public class B extends A&#123; private String name; public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name = name; &#125; public void setGroupId(int groupId)&#123; super.groupId = groupId; //correct &#125; public void setId0(int id)&#123; super.id = id; //incorrect &#125;&#125; 上述例子中可以看到，protected声明的属性子类可以访问，而private声明的属性子类无法访问。 扩展：Java中4个访问控制符的权限： private-仅对本类可见。 public-对所有外部类可见。 protected-对本包和子类可见。 默认（无修饰符）-对本包可见。 Object：所有类型的超类Object类是所有类型的始祖，所有的类型都继承了Object类。 object类型变量在Java中，只有基本类型变量（primitive type）不是对象。其他的所有对象都扩展了Object类。 equals方法Object类的equals方法用于检测一个对象是否等于另外一个。其默认实现是对比两个对象的引用是否相同。这是一个基础的定义。显然，如果两个对象引用相同。则其必然相同。但是我们可以扩展其定义。比如，我们确定所有的字段都相等就算相等，即使引用不同。 Java规范要求equals方法具有下面的特征： 自反性：x.equals(x) == true 对称性：(x.equals(y) == y.equals(x)) 传递性：x.equals(y);,y.equals(z) =&gt;x.equals(z) 一致性：如果x和y引用的对象没有发生变化，则反复调用x.equals(y)应该返回同样的结果 任意非空的引用x，x.equals(null)应该返回false hashCode方法hashCode方法返回给定对象的hash值。默认实现是从其存储地址导出的。不同的类重写了它。比如String类的实现如下： s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 1234567public static int hashCode(byte[] value) &#123; int h = 0; for (byte v : value) &#123; h = 31 * h + (v &amp; 0xff); &#125; return h;&#125; toString方法其返回一个表示对象的字符串。默认返回其类型+地址。一般重写以显示其内部属性。比如eclipse默认生成的toString方法： 123456@Overridepublic String toString() &#123; return \"Sub [name=\" + name + \", groupId=\" + groupId + \", getName()=\" + getName() + \", getId()=\" + getId() + \", getClass()=\" + getClass() + \", hashCode()=\" + hashCode() + \", toString()=\" + super.toString() + \"]\";&#125; 泛型数组列表在Java中，允许在运行时动态申明数组的大小，如： 123public Integer[] getList(Integer size)&#123; return new int[size];&#125; 但是一旦声明，其不能随便改变其大小。 而是用ArrayList则可以动态声明大小并改变容量。 ArrayList是一个有参数类型（type parameter）的泛型类（generic class）。其用法如下(3中格式)： 123ArrayList&lt;Integer&gt; ids1 = new ArrayList&lt;Integer&gt;();ArrayList&lt;Integer&gt; ids2 = new ArrayList&lt;&gt;(); var ids3 = new ArrayList&lt;Integer&gt;(); 在Java5之前没有实现泛型，ArrayList只能返回保存Object的ArrayList，获得后需要强转。 在Java的老版本中，会用vector来实现动态数组，但是ArrayList更加高效，现在不应该再使用vector。 如果事先知道其大小，可以使用ensureAcpacity来分配确定大小的容量。也可以再初始参数传入数值来确定容量。（但这并不是强制的，可仍然可以大于该值） 对象的包装器与自动装箱所有的基本类型都有一个与之对应的类。如Integer类对应基本类型int。通常，这些类被称为包装器。其有8类： Integer Long Float Double Short Byte Character Boolean 前6类有公共的超类Number。 包装器是不可变的，即一旦构造了包装器，旧不允许更改包装在其中的值。 包装器还是final，因此不能派生他们的子类。 注意，范类括号中不允许基本类型。即ArrayList&lt;int&gt;是错误的语法。所以向ArraryList中添加成员时，应该是以下语法： 12ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(Integer.valueOf(3)); 但是实际上，直接list.add(9)也是合法，这是因为自动装箱。 相反的，其也会自动拆箱： 1int a = list.get(0); 其实际上会被编译器翻译为如下： 1int a = list.get(0).intValue(); 还有一点值得注意的是：基本类型和其包装器是不一样的。基本类型存储在常量池中，因此用==判断时，会完全相等。而包装型则是一个对象，则其判断并不一定相等。 记住一下规定： 自动装箱规范要求boolean，byte，char &lt;= 127 ，介于-128与127之间的short和int将被包装到固定对象中。（即符合上述要求的值是包装在同一个对象中，不符合的则可能分布在不同的对象中）所以用==比较时，由于是同一地址，则返回true。 值得注意的是：拆箱和装箱都是编译器的工作，而不是虚拟机。 参数数量可变的方法可以提供参数数量可变的方法 。可以通过下面的方式定义： 123456789101112package test.mw.extendsTest;import java.util.Arrays;public class Test &#123; varFunc(111,222, 333, 444); &#125; public static void varFunc(Object... args)&#123; System.out.print(Arrays.toString(args)); &#125;&#125; 通过这样定义的方法， 得到的可变参数变量为一个数组。 可变参数必须位于最有一个参数。 这也是编译器的工作。当我们调用varFunc(111,222,333)时，实际上编译器会编译为如下代码： 1varFunc(new Integer[]&#123;111,222,333&#125;) 枚举类型枚举类型即限定其属性只有特定类型。 枚举类型实际上就是一个类，它刚好有4个实例，不可能构造新的对象。其示例如下： 1public enum Size&#123;SMALL, MEDIUM, LARGE&#125; 因此在比较两个枚举类型的值时，并不需要调用equals，直接使用==即可。 但是我们可以在其内部定义变量和方法，且可以使用： 1234567891011121314151617public enum Size&#123; SMALL(\"S\"), MEDIUM(\"M\"), LARGE(\"L\"); //实际上是调用下面的构造器方法，参数对应。 private String name; Size(String string) &#123; // TODO Auto-generated constructor stub name = string; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125;Size s = Size.valueOf(Size.class, \"SMALL\");s.setName(\"newS\"); 如上，实际上最上面的三个就是初始化的对象，我们可以通过valueOf来新建Size实例，实例化之后可以通过方法来冲洗设定其值。 反射反射（reflection library）提供了丰富而精巧的工具集，可以用来编写能够动态操纵Java代码。 Class类在Java运行时，系统时钟为所有对象维护一个运行时类型标识。保存其信息的类即为Class。 有以下3中方法获取Class类型的实例 Object类中的getClass()方法。 使用静态方法forName：Class.forName(&quot;java.util.Random&quot;)。 通过T.class来获取Class实例。（T为Java类型，需要import引入）。 注意一个Class对象实际上是一个类型。可能是类，也可能不是类。如int不是类，但int .class是一个Class类型的对象。 虚拟机为每一个类型管理一个唯一的Class对象。因为可以用==来判断两个类是否相等。 一个Class对象有很多方法和属性，而最关键元素有以下3类： Field: 指类的属性。 Method：指类的方法。 Constructor：指类的构造器。 与其对应，有以下六个-3组方法： Field[] getFields()：返回该类的所有公开（public）字段，包括父类继承的 Field[] getDeclaredFields()：返回该类的所有（public, protected, default，private）字段，不包括父类继承的 Method[] getMethods()：返回该类的所有公开（public）方法，包括父类继承的 Method[] getDeclaredMethods()：返回该类的所有（public, protected, default，private）方法，不包括父类继承的 Constructor[] getConstructors()：返回该类的所有构造器，公开的 Constructor[] getDeclaredConstructors()：返回该类的所有构造器，所有的 注意上述的方法是获取所有的成员，相应的还有获取单个成员的6个方法，含义相同，只是仅返回与之匹配的单个方法： Field getFields(String name) Field getDeclaredField(String name) Method getMethod(String name)： Method getDeclaredMethod(String name) Constructor getConstructor(String name) Constructor getDeclaredConstructor(String name) 而在以上3个类中，又可以获取属性（方法）的修饰符（getModifiers()），名称（getName），获取参数（getParameterTypes）或者返回类型（getReturnType()） 注意：上述获取修饰符返回的是一个二进制数据，所以不能直接看出其修饰符有哪些，而需要调用Modifier对象的静态方法isXXX(int modifier)来判断（Modifier.isPublic(modifier)）。 访问对象内部的属性我们可以通过上述特征来分析该类的特征，即使用反射来访问对应类的对象的成员。一般是获取到Field对象后，调用其get(obj)的方式来查看。如： 123456Parent parent = new Parent(888, \"888\"); //id, pubNameClass pclass = parent.getClass();Field pubNameF = pclass.getDeclaredField(\"pubName\");String pubName = (String) pubNameF.get(parent);//String pubName = pubNameF.getString(parent);System.out.println(pubName); 如上的代码可以得到parent的值：”888”。 但是下面的代码却不行： 1234567Parent parent = new Parent(888, \"888\"); //id, pubNameClass pclass = parent.getClass();Field idF = pclass.getDeclaredField(\"id\");int id = (int) pubNameF.get(parent);System.out.println(id);//Exception in thread \"main\" java.lang.IllegalAccessException: class test.extendsTest.Test (in module test) cannot access a member of class test.extendsTest.Parent (in module test) with modifiers \"private\" 大意就是私有符修饰的成员不能通过这种方法来访问。 注意反射始终认为其在包外调用。所以只有public的成员可以直接访问。 Feild.setAccessible(flag: Boolean)我们可以使用setAccessible(true)来覆盖原始的权限，将其设置为public，此时旧可以再访问了 12345678Parent parent = new Parent(888, \"888\"); //id, pubNameClass pclass = parent.getClass();Field idF = pclass.getDeclaredField(\"id\");idF.setAccessible(true);int id = (int) pubNameF.get(parent);System.out.println(id);//888 访问对象内部的方法和构造器和获取属性类似，我们需要获取Method和Constructor对象后，通过其对象执行。 方法对于方法，我们可以通过 1Method.invoke(Object obj, Object... parameters) 来执行对应的方法。其中第一个参数是要执行的对象。后面的参数是要传递给方法的参数。 对于静态方法，第一个参数可以忽略，传入null即可。 构造器对于构造器，我们可以通过 1Constructor.newInstance(Object... parameters); 来调用其构造器。唯一注意的是获取的仍然是Object对象，需要强转才能调用其方法和属性。 继承的设计技巧 将公共字段放在超类中 不要使用protected字段 要适当的使用继承，考察两个类是否确实属于同一类。 再覆盖原方法时，不要改变其原始意义。 多使用多态，而不要使用类型信息。（接口学习后梗方便） 不要滥用反射。反射时脆弱的，他会弱化编译器的错误检测能力，可能将一些编译时错误推到了运行时才能发现。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"对象与类","slug":"对象与类","permalink":"http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"}]},{"title":"Java核心技术-I-4-对象与类","slug":"java核心技术-I-4-对象与类","date":"2022-01-08T05:30:48.000Z","updated":"2022-01-19T02:29:01.314Z","comments":true,"path":"2022/01/08/java核心技术-I-4-对象与类/","link":"","permalink":"http://yoursite.com/2022/01/08/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-4-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/","excerpt":"","text":"面向对象程序设计概述类类是构建对象的模板或蓝图。由类构造(construct)对象的过程被称为创建类的实例(instance)。 封装是指不能让类中的方法直接访问其他类的实例字段。程序只能通过对象得到方法与对象数据进行交互。（这些实例字段就是这个对象的当前状态） 对象对象的3个主要特征 对象的行为（behavior）：有哪些方法。 对象的状态（state）：有哪些实例属性。 对象的标识（identity）：对象的标识（内存中的地址表示）。 类与类之间的关系 依赖(“uses-a”)：A类中调用了B类或其实例。 聚合(“has-a”)：A类中含有B类实例属性。 继承(“is-a”)：A类继承自B类。 其UML表示如下： final实例字段注意final定义的实例字段必须在定义时、或者构造器对象时进行初始化。 对象构造重载一个方法的方法名和参数类型被成为方法的签名（signature）。即区分不同的方法是靠这两个点。 重载是指多个方法拥有相同的名字，不同的参数类型。在调用时传入特定的参数，由编译器选出对应的方法，如果不存在特定方法，则报错。这个过程被称为重载解析（overloading resolution）。 Note： 返回类型和修饰符都不是方法签名的一部分，因此不能存在两个名字相同、参数类型相同却有不同返回类型或不同修饰符的方法。 数据字段初始化 在构造器中设置值。 在声明中赋值。 初始化块。 在一个类的声明中，可以包含任意多个代码块。只要构造这个类，这些块就会被执行。如： 1234567891011class Employee&#123; private static int nextId; private int id; private String name; //Object initialization block &#123; id = nextId; nextId++; &#125;&#125; 但是这种方式不是必须的，也不常见。通常会直接将初始化代码放置到构造器中。 类的导入一个类可以始终所属包中的所有类，以及其他包中的公共类（public class）。 我们可以采用两种方式来访问另一个包中的公共类。 使用完全限定名。 使用import语句导入后直接使用。 Note： 只能使用星号（）导入一个包，而不能使用`import java.或者import ..`导入以Java为前缀的所有包。 当导入的两个包含有相同的方法名字，如果还是使用简写名，则会报错；此时需要使用全限定名。 静态导入在import后加上static关键字则可以导入静态方法和静态字段，而不只是类。如： 123import static java.lang.System.*;out.println(\"hello world!\"); 还可以导入特定的方法 123import static java.lang.System.out out.println(\"hello world!\"); 类设计技巧 一定要保证数据的私有。 一定要对数据进行初始化。 不要在类中使用过多的基本类型。 不是所有的字段都需要单独的字段访问器和字段更改器。 分解有过多职责的类。 类名和方法名要能够提现它们的职责。优先使用不可变的类：即尽量使用那些调用方法后返回副本的类，而不是修改其内部属性的类。主要在于多线程同时试图更新一个对象，就会发生并发修改。其结果就是不可预料的。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"对象与类","slug":"对象与类","permalink":"http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"}]},{"title":"Java核心技术-I-3-Java的基本程序设计结构","slug":"java核心技术-I-3-Java的基本程序设计结构","date":"2022-01-05T12:42:15.000Z","updated":"2022-01-19T02:29:15.455Z","comments":true,"path":"2022/01/05/java核心技术-I-3-Java的基本程序设计结构/","link":"","permalink":"http://yoursite.com/2022/01/05/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-3-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/","excerpt":"","text":"注释注释分为3类： 单行注释：//其后的部分被视为注释。 1Sysout.out.print(\"context\") //annotation 多行注释：/* xxx */内的xxx被视为注释，可以包含多行。 12345/* annotation1 annotation2 annotation3*/ 文档注释型：这种注释以/**开始，以*/结束，这种注释可以用来自动生成文档。 12345/** annotation1 annotation2 annotation3*/ 数据类型Java有8中基本类型（primitive type），其中有4中整型、2种浮点类型、1种字符类型和一种表示真假值得Boolean类型。 整型 类型 存储需求 取值范围 int 4字节 -2147483648~2147483647（刚好超过20亿） short 2字节 -32768~32767 long 8字节 -9223372036854775808~9223372036854775807 byte 1字节 -128~127 Note： 在Java中，整型得范围与运行Java代码得机器无关。 长整型数值有一个后缀L或l。 1Long lVal = 999999999999999l; 从java7开始，可以为数字字面量添加下划线，如9_999_999即为9999999。 浮点类型 类型 存储需求 取值范围 float 4字节 大约±3.402823E+38F（有效位数为6~7位） double 8字节 大约±1.79769313486231570E+308（有效位数为15位） Note: 定义float类型时，其数值有一个后缀F或者f。没有后缀F或f会被默认视为double类型。（实际上也很少使用float，大多使用double）。 常量Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN分别表示IEEE754规定的用于表示溢出和出错情况的三个特殊浮点数值： 正无穷大 负无穷大 NaN（Not a Number） 不能用==判断一个数是否为NaN，而应该用Double.isNaN(param)。 浮点数存在误差，如经典的(2.0 - 1.1) != 0.899999999999, 而不是0.9。这是由于浮点数值采用二进制系统表示，而在二进制系统中无法精确的表示分数1/10。这就像无法用十进制精确的表达1/3一样。如果需要精确的计算，则应该采用BigDecimal类。 char类型char类型原本表示单个字符。不过现在一些Unicode字符需要两个char值来表达。 char类型表示的是十六进制值，其范围是从\\u0000到\\uffff。如\\u2122表示商标（™）。 除了转移序列\\u之外，还有一些用于表示特殊字符的转移序列。参见下表。 转移序列 名称 Unicode值 \\b 退格 \\u0008 \\t 制表 \\u0009 \\n 换行 \\u000a \\r 回车 \\u000d \\&quot; 双引号 \\u0022 \\&#39; 单引号 \\u0027 \\\\ 反斜杠 \\u005c Note： Unicode转义序列会在解析代码之前得到处理。也就是说，Java源代码的任意字符都可以使用 Unicode来编写。 以此会产生一些隐晦的语法错误（现在编译器都会提示），比如: 1// look inside c:\\users 由于\\u并没有跟着4个十六进制数。 变量与常量 从jdk10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就可以不声明变量类型。如： 12var vacationDays = 12;var greeting = \"Hello\"; 常量的定义使用关键字final，并且其只可以被赋值一次（注意并不是只可以在声明时赋值，可以在声明后赋值，但是仅可以被赋值一次）。 运算符在Java中，使用+,-,*,/表示加、减、乘、除运算。 对于/运算，当两个操作数都是整数时，表示整数除法，否则表示浮点除法。 对于%运算，表示求余操作，其操作数可以为整型或者浮点型。 数学函数在Math类中，为了达到最佳的性能，所有的方法都是用计算机浮点单元中的例程。如果要求计算更加准确而不是在乎速度，则可以使用StrictMath类，其API与Math类完全相同。 数值类型的转换隐式转换 图中展示出各种数值类型的转换，其中实线表示可以无损转换，而虚线表示转换会损失精度。 当一个二元操作符连接两个不同类型的值时，需要先将其转换为同一种类型才能进行运算。这种隐式转换的规则如下： 如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。 否则，如果其中一个操作数是flaot类型，另一个操作数就会转换成为float类型。 否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。 否则，两个操作数都将会被转化为int类型。 强制类型转换在Java中，通过：(type) variable来完成强制类型转换，如： 12double pi = 3.1415926;int intPi = (int)pi; //会丢失精度，编译器会warn 注意以上的转换会直接截断小数点。如果需要四舍五入，则可以使用Math.round()函数来实现。 运算符优先级优先级运算符结合性1()、[]、{}从左向右2!、+、-、~、++、–从右向左3、/、%从左向右4+、-从左向右5«、»、&gt;&gt;&gt;从左向右6&lt;、&lt;=、&gt;、&gt;=、instanceof从左向右7==、!=从左向右8&amp;从左向右9^从左向右10|从左向右11&amp;&amp;从左向右12||从左向右13?:从右向左14=、+=、-=、=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;=从右向左 字符串从概念上将，Java的字符串就是Unicode的字符序列。如，字符串”Java\\u2122”由5个Unicode字符J、a、v、a和™组成。并且String并不是基础类型之一，所以在标准的Java类库中提供了一个预制类称为String。 String类没有提供修改字符串中某个字符的方法。如果希望修改字符串中某个位置的值，可以使用substring()方法来实现。 不提供秀嘎方法的原因主要在于可以共享字符串的值，将其存储在一个共享池中，提升效率。详细在jvm虚拟机的内存模型时可以更加详细的了解。 检测字符串是否相等在检测字符串是否相等时，一般不使用==，这是由于实际上只有通过字面量定义的字符串是共享的，而通过构造器或者substring()得到的方法并不是共享的。所以： 如果两个字符串都是用字面量定义的，则可以使用==来判断。 其他情况下，都应当equal()方法来判断相等关系。 综上，还是尽量使用equal()方法来判断，防止不可预知的bug。 底层jdk9之前，String底层是使用char值序列组成，而jdk9中，其底层变成了byte值序列。 构建字符串有些时候，需要由较短的字符串来构建字符，这时如果采用字符串拼接会比较消耗性能，这时候可以采用StringBuilder类来构建字符串。示例如下： 1234StringBuilder builder = new StringBuilder();builder.append(\"str1\");buidler.append(\"str2\");String s = builder.toString(); 输入输出读取输入12345Scanner in = new Scanner(System.in);String name = in.nextLine(); //读取一行String firstName = in.next(); //读取下一个单词int age = in.nextInt(); //读取下一个intdouble tall = in.nextDouble(); //读取下一个double 格式化输出Sysout.print.out(x)将数值x输出到控制台。 Sysout.out.printf()可以进行格式化输出。如：Sysout.out.printf(&quot;%8.2f&quot;, x)。这种语法沿用了C语言函数库中的printf()方法。 其第一个参数格式如下： 分别解释每一项： %：表示格式化输出的标识符。 argument index+$一起表示参数索引，即Sysout.out.printf(FORMAT, x,...restArg)可以接受多个参数，其中1$,2$,n$表示对第一个，第二个，第n个参数进行特定的格式化。 flag：指定控制格式化输出外观的各种标志，如下表： 标志目的举例+打印数字前的符号+3333.33space在正数之前加空格| 3333.33|0在数字前补0003333.33-左对齐|3333.33 |(负数括在括号内(3333.33),添加分组分隔符3,333.33# (for f )包含小数点3,333.# (for x or o)添加前缀 0x 或 00xcafe^转化为大写0XCAFE$指定格式化参数索引，如%1$d,%1$d表示以十进制和十六进制打印第一个参数159 9F&lt;格式化前面参数，如%d%&lt;x表示以十进制和十六进制打印同一个参数159 9F width：表示输出的位宽，如果原内容不足width，则填空格。 t+conversion character：转换符指示要格式化的数据类型。所有内容如下表： 转换符类型 举例d十进制整数 159x十六进制整数9fo八进制整数237f定点浮点数15.9e指数浮点数1.59e+01g通常浮点数&nbsp;a十六进制浮点数0x1.fccdp3s字符串Helloc字符Hb布尔型TRueh散列码42628b2tx日期时间见时间介绍表%百分号%n分隔符 &nbsp; .+precision：表示数值输出的小数点位数，如果不足后面补0。 文件输入输出读取文件12Scanner in = new Scanner(Path.of(\"file.txt\"), StanardCharsets.UTF_8);String l = in.nextLine(); //读取一行，还有其他类型如上代码一样 写入文件1PrintWriter out = new PrintWriter(\"file.txt\", StanardCharsets.UTF_8); 流程控制在Java中没有goto语句，但是设计了另外一种语法来实现其一部分语法。 带标签的break语法可以使用带标签的break来讲程序跳转到确定位置。标签定义后加冒号，其后可以跟任何代码块。break后加标签名字。例如： 1234567891011121314// 循环中使用check_point: //定义标签位置for(...)&#123; for(...)&#123; ...; break check_point; //跳转到check_point位置 &#125;&#125;//任何位置使用check_point1:&#123; if(...) break check_point1;&#125; 大数如果基本的整数和浮点数精度不能满足需求，则可以使用java.Math包中的两个类： BigInteger：大整数。 BigDecimal：大浮点数。 可以使用vlaueOf方法将普通的数值转换为大数。 1BigInteger big = BigInteger.valueOf(1000); 可以使用构造器传入字符串数值。 1BigInteger big = new BigInteger(\"99999999999999999999999999999999999999999999999999999999999999999999999999999999\") 但值得注意的是，大数不能使用普通的算术运算符（如+, -, *, /）。而是要使用大数类的add，multiply方法等来进行运算。如 12BigInteger c = a.add(b);BigInteger d = c.multipy(b.add(BigInteger.valueOf(2))); //d = c * (b + 2) 数组数组声明 12int[] a; // 一般使用这种，因为更容易区分变量名和数据类型int a[]; 数组初始化 123456789101112// 声明和初始化分开int[] a;a = new int[100];// 声明和初始化一起int[] b = new int[100];// 类型推断var c = new int[100];//字面量方法创建数组int[] d = &#123;1,2,3,4&#125;; 一旦创建了数组，就无法改变它的长度。 如果需要可改变大小的数组，可以使用ArrayList。 注意通过字面量方法创建数组时，不需要提供数组大小，也不需要new操作符。 创建一个数字数组时，所有元素都初始化为0；Boolean数组的元素会初始化为false；对象数组的元素则初始化为一个特殊值null。 数组拷贝可以使用Arrays.copyOf(originalArray, newArrayNumber)来创建一个新的数组，并将原数组复制到新数组中，可以间接实现改变数组大小。 123int[] a = &#123;1,2,3&#125;;int[] b = Arrays.copyOf(a, 5);// b = &#123;1, 2, 3, 0, 0&#125; Note 当新数组的长度小于原数组，则会截断原始数组。 命令行参数主函数main(String[] args)的参数是作为命令行参数。如： 1java A -g param1 param2 则结果为： 123args[0]: \"-g\";args[1]: \"param1\";args[2]: \"param2\";","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java核心技术","slug":"Java核心技术","permalink":"http://yoursite.com/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"name":"Java的基本程序设计结构","slug":"Java的基本程序设计结构","permalink":"http://yoursite.com/tags/Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"}]},{"title":"ssm配置文件随记","slug":"ssm配置文件随记","date":"2021-12-25T10:44:25.000Z","updated":"2021-12-26T12:38:31.098Z","comments":true,"path":"2021/12/25/ssm配置文件随记/","link":"","permalink":"http://yoursite.com/2021/12/25/ssm%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%9A%8F%E8%AE%B0/","excerpt":"","text":"这里简单记录一下SSM里的各种配置文件，简单记录一下，作为基础。注意，xml中某些配置是有顺序要求的。 web.xml 引入约束：约束是作为其子标签的编写规范，可以作为提示和规范。 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot; id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;2.5&quot;&gt;&lt;&#x2F;web-app&gt; 配置spring配置文件的位置 1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 配置乱码过滤器：此处的配置是为了配置接受数据的编码信息。（注意是接收参数） 12345678910111213&lt;!--乱码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; spring监听器：此配置是确保在webapp启动的时候spring容器也被初始化。（所以这里也配置了spring配置文件的位置） 1234&lt;!--spring 监听器--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; spring-mvc前端控制器：此配置即springMVC的servlet，让所有的请求都走springMVC的控制器，即只走springMVC的servlet。 1234567891011121314&lt;!--springmvc的前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; applicationContext.xml（spring配置文件） 引入约束：注意spring不同的部分有不同的约束，如基本 的beans，aop，contex等（这里也不需要记每个地址，只需要将xmlns:xxx=…xxx…中的xxx改为对应的单词，如aop，tx）。 123456789101112131415&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beanshttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsdhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;txhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsdhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aophttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsdhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;contexthttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;&lt;beans&gt; 配置组件扫描（扫描service和mapper）：注意context:component-scan内部可以包含context:exclude-filter或者context:include-filter 12345&lt;!--组件扫描 扫描service和mapper--&gt;&lt;context:component-scan base-package=\"com.itheima\"&gt; &lt;!--排除controller的扫描--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"&gt;&lt;/context:exclude-filter&gt;&lt;/context:component-scan&gt; 加载properties文件：可以引入外部的文件，使用其中的变量 12&lt;!--加载propeties文件--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\"&gt;&lt;/context:property-placeholder&gt; 配置数据源：这里采用的c3p0连接池。连接池的本质是为我们维护一系类的数据库连接，防止每此都要打开和关闭连接，浪费资源 1234567&lt;!--配置数据源信息--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; 配置sessionFactory：配置mybatis的sessionFactory，用来获取mybatis的session 123456&lt;!--配置sessionFactory--&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!--加载mybatis核心文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:sqlMapConfig-spring.xml\"&gt;&lt;/property&gt;&lt;/bean&gt; 扫描mapper包，为mapper接口创建实现类 1234&lt;!--扫描mapper所在的包 为mapper创建实现类--&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.itheima.mapper\"&gt;&lt;/property&gt;&lt;/bean&gt; 声明事务控制 平台事务管理器 1234&lt;!--平台事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; 配置事务增强：注意transaction-manager=&quot;transactionManager&quot;可以省略，因为其默认即为transaction-manager=&quot;transactionManager&quot;。 123456&lt;!--配置事务增强--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 配置事务的aop织入 1234&lt;!--事务的aop织入--&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.itheima.service.impl.*.*(..))\"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; spring-mvc.xml 引入约束 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 2. 组件扫描：只扫描controller 12&lt;!--组件扫描 主要扫描controller--&gt;&lt;context:component-scan base-package=\"com.itheima.controller\"&gt;&lt;/context:component-scan&gt; 3. 配置mvc注解驱动：这个标签注册了一系列的beans和adapts，比如JSON（当我们引入了Jackson，则不需要单独配置，在直接在@ResponseBody的controller中返回以额对象就会直接返回一个json），valid等等。 12345678&lt;!--配置mvc注解驱动--&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"defaultCharset\" value=\"UTF-8\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 4. 注册文件上传（可选）:注意id必须为`multipartResolver`，因为spring是按id获取这个bean的。（需要引入`commons-fileupload`坐标） 12345&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;property name=\"maxUploadSize\" value=\"5242800\"/&gt; &lt;property name=\"maxUploadSizePerFile\" value=\"5242800\"/&gt;&lt;/bean&gt; 5. 配置默认servlet：当spring-mvc无法匹配到请求的请求时，使用默认的servlet来处理，可以用来暴露静态资源。 1&lt;mvc:default-servlet-handler/&gt; # sqlMapConfig.xml（不整合spring时的配置） 1. 设置打印sql语句和结果 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;&lt;/settings&gt; 2. 引入约束 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; 3. 加载properties文件 1&lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; 4. 定义别名：这里定义实体类的别名，我们在mapper中的可以使用别名来代替很长的全路径名称。注意这里可以单独配置，也可以扫包。 1234&lt;typeAliases&gt; &lt;!--&lt;typeAlias type=\"com.itheima.domain.Account\" alias=\"account\"&gt;&lt;/typeAlias&gt;--&gt; &lt;package name=\"com.itheima.domain\"&gt;&lt;/package&gt;&lt;/typeAliases&gt; 5. 配置环境：这里配置环境，即可以配置多套设置，比如`development`，`production`。 1234567891011&lt;environments default=\"developement\"&gt; &lt;environment id=\"developement\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 6. 加载映射文件：加载`XXXmapper.xml`。用在配置文件的情况下。同样可以扫包和单独配置。 1234&lt;mappers&gt; &lt;!--&lt;mapper resource=\"com/itheima/mapper/AccountMapper.xml\"&gt;&lt;/mapper&gt;--&gt; &lt;package name=\"com.itheima.mapper\"&gt;&lt;/package&gt;&lt;/mappers&gt; # sqlMapConfig-spring.xml（整合spring的mybatis） 注意mybatis和spring整合后，大部分的配置都在spring里写好了。所以这里不用配置太多。 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;!--定义别名--&gt; &lt;typeAliases&gt; &lt;!--&lt;typeAlias type=\"com.itheima.domain.Account\" alias=\"account\"&gt;&lt;/typeAlias&gt;--&gt; &lt;package name=\"com.itheima.domain\"&gt;&lt;/package&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; # xxxmapper.xml（mapper注解方式） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"priv.mw.mapper.UserMapper\"&gt; &lt;sql id=\"selectAll\"&gt; select * from user &lt;/sql&gt; &lt;select id=\"findAll\" resultType=\"user\"&gt; &lt;include refid=\"selectAll\"&gt;&lt;/include&gt; &lt;/select&gt; &lt;insert id=\"insert\" parameterType=\"user\"&gt; insert user values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;birthday&#125;) &lt;/insert&gt; &lt;update id=\"update\" parameterType=\"user\"&gt; update user set &lt;if test=\"username != null\"&gt; username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"password != null\"&gt; password = #&#123;password&#125; &lt;/if&gt; &lt;if test=\"birthday != null\"&gt; birthday = #&#123;birthday&#125; &lt;/if&gt; &lt;where&gt; id = #&#123;id&#125; &lt;/where&gt; &lt;/update&gt; &lt;delete id=\"delete\" parameterType=\"user\"&gt; delete user from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; xxx.class(mapper接口方式) 1234567891011121314151617181920212223package priv.mw.mapper;import org.apache.ibatis.annotations.*;import priv.mw.domain.User;import java.util.List;@Mapperpublic interface UserMapper &#123; @Select(\"select * from user\") public List&lt;User&gt; findAll(); @Insert(\"insert into user values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;birthday&#125;)\") public Integer insert(User user); @Update(\"update user set username = #&#123;username&#125;, password=#&#123;password&#125;, birthday=#&#123;birthday&#125; where id = #&#123;id&#125;\") public Integer update(User user); @Delete(\"delete from user where id = #&#123;id&#125;\") public Integer delete(User user);&#125; log4j.properties 12345678910111213141516171819202122## Hibernate, Relational Persistence for Idiomatic Java## License: GNU Lesser General Public License (LGPL), version 2.1 or later.# See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.#### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file hibernate.log ####log4j.appender.file=org.apache.log4j.FileAppender#log4j.appender.file.File=hibernate.log#log4j.appender.file.layout=org.apache.log4j.PatternLayout#log4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change 'info' to 'debug' ###log4j.rootLogger=all, stdout","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"配置文件","slug":"配置文件","permalink":"http://yoursite.com/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"name":"随机","slug":"随机","permalink":"http://yoursite.com/tags/%E9%9A%8F%E6%9C%BA/"}]},{"title":"float最全最根本解析","slug":"float最全最根本解析","date":"2021-10-16T12:55:21.000Z","updated":"2021-10-16T16:23:11.762Z","comments":true,"path":"2021/10/16/float最全最根本解析/","link":"","permalink":"http://yoursite.com/2021/10/16/float%E6%9C%80%E5%85%A8%E6%9C%80%E6%A0%B9%E6%9C%AC%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前置知识要想真正得用好浮动，以及清除浮动。必须首先要理解几个概念作为前置知识。 Normal flow （正常流）这个名词在国内一般被翻译为文档流，这个被很多人吐槽，就不再说了。 这个正常流就是我们HTML初始的流模型。也就是整个文档内，如果你不添加其他属性（浮动和绝对定位）那么整个文档就属于正常流。 格式化上下文（formatting context）一个格式化上下文（下文称FC）就是一系列相关的元素排布的环境。不同的FC有不同的排布规则。 正常流中的一个盒子模型，都必然属于一个格式化上下文（formatting context）（并不是每个元素都会建立一个FC，注意属于二字）。而格式化上下文又分为以下5种： BFC(block formatting context) IFC(inline formatting context) RFC(ruby formatting context) - 未被实现 FFC(flex formatting context) GFC(grid formatting context) 值得注意的是： 但是一些FC之间可以产生互动或共存，比如一个IFC可能位于一个BFC元素的内部。 FC建立的类型取决于inner-display。 这里又需要介绍一下inner-display的概念。 display属性实际上我们常使用的display属性，包括两个概念，inner display type和outer display type inner display type内部展示类型即会决定这个元素产生的FC的类型，由此会决定其后代元素如何进行排布。 outer display type外部展示类型决定了他自己如何在流布局中进行排布。 注意：文字没有display 属性。 下面是W3C规定的所有display属性，但是一些并没有实现： Short display Full display Generated box none — subtree omitted from box tree contents — element replaced by contents in box tree block block flow block-level block container aka block box flow-root block flow-root block-level block container that establishes a new block formatting context (BFC) inline inline flow inline box inline-block inline flow-root inline-level block container aka inline block run-in run-in flow run-in box (inline box with special box-tree-munging rules) list-item block flow list-item block box with additional marker box inline list-item inline flow list-item inline box with additional marker box flex block flex block-level flex container inline-flex inline flex inline-level flex container grid block grid block-level grid container inline-grid inline grid inline-level grid container ruby inline ruby inline-level ruby container block ruby block ruby block box containing ruby container table block table block-level table wrapper box containing table grid box inline-table inline table inline-level table wrapper box containing table grid box &lt;display-internal&gt; types — layout-specific internal box 并且其分类如下： 12345678910&lt;display-outside&gt; = block | inline | run-in&lt;display-inside&gt; = flow | flow-root | table | flex | grid | ruby&lt;display-listitem&gt; = &lt;display-outside&gt;? &amp;&amp; [ flow | flow-root ]? &amp;&amp; list-item&lt;display-internal&gt; = table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container&lt;display-box&gt; = contents | none&lt;display-legacy&gt; = inline-block | inline-table | inline-flex | inline-grid 根据inner display type再回影响FC的产生原则，\\&lt;display-outside>与 \\&lt;display-box> 肯定不能影响规则。则剩下的几种，其内部的实现又各不相同。 首先\\&lt;display-inside>必定可以产生FC。 而其他的几种，比如 table-row等由于内部的实现不同，不一定能够产生FC。 根据文档，可以归纳为： 产生BFC flow-chrome未实现 flow-root table table-caption table-row-group table-header-group table-footer-group table-row table-cell 产生RFC ruby 产生FFC flex 产生GFC grid 产生RFC ruby（原ruby标签是用来注释的） BFC(block formatting context)","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"float","slug":"float","permalink":"http://yoursite.com/tags/float/"},{"name":"浮动","slug":"浮动","permalink":"http://yoursite.com/tags/%E6%B5%AE%E5%8A%A8/"}]},{"title":"Vue首屏优化全解析","slug":"Vue首屏优化全解析","date":"2021-10-16T07:00:24.000Z","updated":"2021-10-16T07:02:13.358Z","comments":true,"path":"2021/10/16/Vue首屏优化全解析/","link":"","permalink":"http://yoursite.com/2021/10/16/Vue%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E5%85%A8%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Vue首屏优化全解析打开GZIP直接打包称为xxx.gz文件在前端打包过程中即生成gz文件可以减少部署服务器的打包过程，可以减少服务器的性能压力，提高响应时间。 使用webpack插件CompressionWebpackPlugin来实现gzip打包。 在vue项目根目录新建webpack.config.js来增加webpack配置。 下面是一个基本配置，具体详细见其文档。 123456789101112131415161718192021222324252627282930const CompressionPlugin = require(\"compression-webpack-plugin\");let config = &#123; plugins: []&#125;module.export = (env, argv) =&gt; &#123; if(env.mode === 'production')&#123; let comress = new CompressionPlugin(&#123; //检测并压缩js和css文件 test: /\\.(js|css|svg)$/, //默认即为gzip，可以不写 algorithm: 'gzip', //压缩选项，可以在node文档中找到所有选项 compressionOptions: &#123; level: 1 &#125;, //最小压缩体积，单位bytes，默认0 threshold: 1600, //最小压缩效率，ration = 压缩后体积/压缩前体积，只有效率小于这个值的时候才进行压缩，否则不压缩。默认0.8。传1则全部压缩。 minRatio: 0.5, //输出的文件名字，默认即为'[path][base].gz'，其他参数见文档 filename: '[path][base].gz', //是否删除源文件,默认false deleteOriginalAssets: true &#125;) config.plugins.push(compress) &#125; return config&#125; 其中压缩选项[compressionOptions]可以在这里查看。 注意这里有一个生产和开发两个环境来确定是否注入插件。 我们可以通过Vue.config.productionTip = false /true来改变当前环境。 打开部署服务器gzip一般我们使用nginx来部署前端项目。所以我们这里仅仅介绍nginx的配置。 由于我们之前已经配置了直接打包为gz，此时服务器就不需要再进行压缩，直接传递给浏览器即可。此时我们再nginx的config配置文件中加入对应的配置项即可。 再nginx官方文档中，关于gzip多个API： 常用的有以下几个： Syntax: `gzip on off;` 默认 gzip off; 父级节点 http, server, location, if in location 介绍 是否打开gzip Syntax: **gzip_comp_level** *level*; 默认 gzip_comp_level 1; 父级节点 http, server, location 介绍 压缩等级 Syntax: **gzip_min_length** *length*; 默认 gzip_min_length 20; 父级节点 http, server, location 介绍 文件被压缩的临界大小 这些API若直接属于http节点内，则所有的sever都会生效，而置于对应的server节点的话就只有对应的server会生效，示例： 123456server &#123; gzip on; gzip_min_length 1000; #gzip_proxied expired no-cache no-store private auth; #gzip_types text&#x2F;plain application&#x2F;xml;&#125; 实际上我们再服务器放置的文件都是经过压缩的gz文件，所以我们只需要打开gzip on就行了。 通过SplitChunks实现手动分包，公共包共享在webpack中，官方增加了optimization.splitChunks来手动进行分包。其默认有一定的规则（只影响异步chunks）： 新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹 新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积） 当按需加载 chunks 时，并行请求的最大数量小于或等于 30 当加载初始化页面时，并发请求的最大数量小于或等于 30 对应的默认配置： 1234567891011121314151617181920212223242526module.exports = &#123; //... optimization: &#123; splitChunks: &#123; chunks: 'async', minSize: 20000, minRemainingSize: 0, minChunks: 1, maxAsyncRequests: 30, maxInitialRequests: 30, enforceSizeThreshold: 50000, cacheGroups: &#123; defaultVendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10, reuseExistingChunk: true, &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true, &#125;, &#125;, &#125;, &#125;,&#125;; 这里需要了解几个重要的API，其他的参见webpack官方文档。 splitChunks.chunks：哪些chunks被执行拆分规则。默认：async。 all：所有的chunks都会被执行拆分。 async：只有异步chunks才会被执行拆分。 initial：只有入口chunks才会被执行拆分。 splitChunks.maxAsyncRequests：按需加载时的最大并行请求数。默认：30。 splitChunks.maxInitialRequests：入口点的最大并行请求数。默认：30。 splitChunks.minChunks：拆分前必须共享模块的最小 chunks 数，即一个被共享的模块想要被拆分，那么他被引用的次数至少为minChunks。默认：1。 splitChunks.minSize：生成 chunk 的最小体积（以 bytes 为单位）。默认：20000即2.5KB。 splitChunks.maxSize：告诉 webpack 尝试将大于 maxSize 个字节的 chunk 分割成较小的部分。 splitChunks.maxAsyncSize：maxAsyncSize 和 maxSize 的区别在于 maxAsyncSize 仅会影响按需加载 chunk。 splitChunks.maxInitialSize：maxInitialSize 和 maxSize 的区别在于 maxInitialSize 仅会影响初始加载 chunks。 splitChunks.name：拆分 chunk 的名称。设为 false 将保持 chunk 的相同名称，因此不会不必要地更改名称。这是生产环境下构建的建议值。 splitChunks.minRemainingSize：确保拆分后剩余的最小 chunk 体积超过限制来避免大小为零的模块。其仅在剩余单个 chunk 时生效。 maxSize 只是一个提示，当模块大于 maxSize 或者拆分不符合 minSize 时可能会被违反。 splitChunks.cacheGroups缓存组可以手动设置chunks的匹配规则。缓存组可以继承和/或覆盖来自 splitChunks.* 的任何选项。但是 test、priority 和 reuseExistingChunk 只能在缓存组级别上进行配置。 splitChunks.cacheGroups.{cacheGroup}.priority：一个模块可以属于多个缓存组。优化将优先考虑具有更高 priority（优先级）的缓存组。默认组的优先级为负，以允许自定义组获得更高的优先级（自定义组的默认值为 0）。默认：-20。 splitChunks.cacheGroups.{cacheGroup}.reuseExistingChunk：如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块。这可能会影响 chunk 的结果文件名。默认：true。 splitChunks.cacheGroups.{cacheGroup}.test：这个API可以接受一个函数，字符串以及正则表达式。一般可以使用正则表达式来确定规定文件夹或文件。也可以传入一个函数。function (module, { chunkGraph, moduleGraph }) =&gt; boolean RegExp string。省略它会选择所有模块。它可以匹配绝对模块资源路径或 chunk 名称。匹配 chunk 名称时，将选择 chunk 中的所有模块。 splitChunks.cacheGroups.{cacheGroup}.filename：输出的文件名字。可以使用以下的占位符。 | 模板 | 描述 || :——— | :———————————————————– || [file] | filename 和路径，不含 query 或 fragment || [query] | 带前缀 ? 的 query || [fragment] | 带前缀 # 的 fragment || [base] | 只有 filename（包含扩展名），不含 path || [filebase] | 同上，但已弃用 || [path] | 只有 path，不含 filename || [name] | 只有 filename，不含扩展名或 path || [ext] | 带前缀 . 的扩展名（对 output.filename 不可用） | 也可以传入函数string function (pathData, assetInfo) =&gt; string splitChunks.cacheGroups.{cacheGroup}.enforce：告诉 webpack 忽略 splitChunks.minSize、splitChunks.minChunks、splitChunks.maxAsyncRequests 和 splitChunks.maxInitialRequests 选项，并始终为此缓存组创建 chunk。（注意，这里说的是外部的minSize等，而缓存组内部的minSize是不会被忽略的，还是会被拆分。） 下面贴一个拆分element-plus的拆分示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//这里是elementplus的推荐的按需引用const Components = require('unplugin-vue-components/webpack')const &#123; ElementPlusResolver &#125; = require('unplugin-vue-components/resolvers')module.exports = &#123; configureWebpack: &#123; plugins: [ Components(&#123; resolvers: [ElementPlusResolver()], &#125;), ], optimization: &#123; splitChunks:&#123; chunks: \"all\", maxSize: 30000, minSize: 20000, cacheGroups: &#123; // vendors: &#123; // name: \"chunk-vendors\", // test: /[\\\\/]node_modules[\\\\/]/, // chunks: \"initial\", // priority: 2, // reuseExistingChunk: true, // enforce: true // &#125;, elementUI: &#123; name: \"chunk-elementplus\", //最大12KB maxSize: 10000, minSize: 1000, //正则表达式来获取node_modules/element-plus/ 下的模块 test: /[\\\\/]node_modules[\\\\/]element-plus[\\\\/]/, //所有的chunks都被拆分，异步或同步 chunks: \"all\", priority: 3, reuseExistingChunk: true, //这里会忽略外部的minSize等，但内部的minSize仍然会被遵守 enforce: true &#125;, &#125; &#125; &#125; &#125;&#125; 注意cacheGroups在组件是按需加载时，也是可以进行chunks拆分的。这是极好的，可以的按需加载的组件分包对优化十分友好。 路由懒加载当某一个组件十分大且不是常用组件的时候，使用路由按需加载就是一个不错的方法。 并且vue-router提供很友好的API来让我们进行路由懒加载。 123const Foo = () =&gt; import(/* webpackChunkName: \"group-foo\" */ './Foo.vue')const Bar = () =&gt; import(/* webpackChunkName: \"group-foo\" */ './Bar.vue')const Baz = () =&gt; import(/* webpackChunkName: \"group-foo\" */ './Baz.vue') 通过上述方式，被动态引入(使用import()函数动态导入)的组件将会被单独打包为一个chunk。 且我们可以通过注释自定义chunk的名称。 另外也可以使用： 1234const Foo = () =&gt; Promise.resolve(&#123; /* 组件定义对象 */ &#125;) 来定义路由懒加载。 值得注意的是：import()动态引入也可以用在平时的组件导入。并且这个动态引入的组件也会被分包。按需加载。 组件按需引入实际上我们平时的应用中，自己的代码不会很大，占体积大的一般都是一些第三方组件，比如UI组件，图表组件等。但是这些组件中并不是所有的组件我们都会用到。特别是图表类组件。这个时候使用按需引入十分关键。 一般来说按需引入即为我们手动在使用对用组件的父组件中引入和声明组件。比如Element-ui中。但是在一些新的UI组件，特别是Vue3出来之后，很多组件有了更加智能化的按需导入，我们不用全局导入，只需要使用和配置webpack插件，插件即可自动完成组件的引入，十分方便，比如下列的element-plus的示例： 12//安装插件npm install unplugin-vue-components 123456789101112// webpack.config.jsconst Components = require('unplugin-vue-components/webpack')const &#123; ElementPlusResolver &#125; = require('unplugin-vue-components/resolvers')module.exports = &#123; // ... plugins: [ Components(&#123; resolvers: [ElementPlusResolver()], &#125;), ],&#125; 注意上述是webpack.config.js，使用vue时，需要配置到vue.config.js中。具体见webpack 相关。 静态资源手动压缩，使用CDNCDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 我们可以将自己的静态资源上传到CDN中，在用户进行请求的时候，CDN会根据其位置选择合适的服务器进行资源传送。以获得更好网络性能。 值得注意的是，某些比较大库也可以用CDN引入，不仅可以减少服务器网络压力。还可以保证其稳定性。比如一些公共的CDN站点，比如bootCDN。 在HTML文件中引入script标签。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt; &lt;!-- 关键，引入对应的标签 --&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 配置webpack的externals，下面是vue.config.js： 123456789module.exports = &#123; //其他参数 configureWebpack: &#123; externals: &#123; 'vue': 'Vue' &#125; &#125; //其他参数&#125; 值得注意有两点： 库的引入要直接从库中引入，而不是从路径中引入（一般安装进node_modules都是从库中引入，所以只是注意一下）。即： 1import &#123; createApp &#125; from \"vue\" packge.json中的版本应该与html中引入的一致，否则会发生错误。 经测试，Vue使用外部CDN，vender体积在gzip下的62.79 KiB下降到37.84KiB。优化明显！ 国内各大云平台都有CDN服务，比如阿里云，腾讯云等。下面简单演示将vue.js替换为CDN。 使用ES6模块替代Node模块，帮助webpack进行tree-shake因为webpack的Tree-shake是基于ES6的静态结构。所谓静态结构。即不能动态的根据代码条件来导入。 即只能 1import a from 'mw' 而不能 1234567//Error syntaximport &#123;a&#125; from 'mw'if(a)&#123; import(xxx)&#125;else&#123; import(yyy)&#125; 不能动态引入即可以在词法分析阶段就可以确定模块之间的引入关系。进而就可以通过直接去掉没被引用的模块。 所以我们可以尽量使用ES6的模块，并且我们可以在ackage.json中配置sideEffects属性来帮助webpack确定哪些模块是纯的ES6模块，可以直接进行Tree-shake。 关闭source-map由于打包生成打代码都是经过压缩的，但是在产生错误的时候就会不好调试，此时就诞生了source-map。在源代码产生错误或者信息的时候，我们通过source-map查找到未压缩的源代码的位置。 但是在生产环境中，我们不想把源代码暴露给用户，并且source-map由于没有压缩，体积一般偏大。所以我们一般可以在生产环境中将其关闭。 vue可以这样关闭： 1234//vue.config.jsmodule.exports = &#123; productionSourceMap: true&#125; 删除冗余代码webpack原生的压缩工具minimizer功能有限，我们想要极致的压缩合并配置可以使用UglifyJS，而UglifyJS内核是 uglify-js。 其包含很多配置，详细地址Compress options，下面简单给出一些用的比较多的： drop_console (default: false) — Pass true to discard calls to console.* functions. If you wish to drop a specific function call such as console.info and/or retain side effects from function arguments after dropping the function call then use pure_funcs instead. drop_debugger (default: true) — remove debugger; statements booleans (default: true) — various optimizations for boolean context, for example !!a ? b : c → a ? b : c 前两个默认是关闭的，打开之后就可以在代码中去掉console和debugger。 下面是一个简单的示例： 1234567891011121314151617181920module.exports = &#123; //... configureWebpack : &#123; optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; test: /\\.js(\\?.*)?$/i, parallel: true, uglifyOptions: &#123; compress: &#123; drop_console: true, drop_debugger: true &#125; &#125; &#125;), ], &#125; &#125; //...&#125; ssr或者Prerendering如果仅仅是首页优化，那么使用prerendering更好。因为相较于ssr，不需要服务器承担html文件的编译。prerendering即是把对应的路由先生成html。 prerendering一个简单的示例如下： 1234567891011121314151617//vue.config.jsconst path = require('path')const PrerenderSPAPlugin = require('prerender-spa-plugin')module.exports = &#123; configureWebpack = &#123; plugins: [ ... new PrerenderSPAPlugin(&#123; // Required - The path to the webpack-outputted app to prerender. staticDir: path.join(__dirname, 'dist'), // Required - Routes to render. routes: [ '/', '/about', '/some/deep/nested/route' ], &#125;) ]&#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"},{"name":"首屏优化","slug":"首屏优化","permalink":"http://yoursite.com/tags/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/"}]},{"title":"基于java的脚本语言hair的开发思路3-执行","slug":"基于java的脚本语言hair的开发思路3-执行","date":"2021-09-30T13:15:30.000Z","updated":"2021-10-09T13:01:15.949Z","comments":true,"path":"2021/09/30/基于java的脚本语言hair的开发思路3-执行/","link":"","permalink":"http://yoursite.com/2021/09/30/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80hair%E7%9A%84%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF3-%E6%89%A7%E8%A1%8C/","excerpt":"","text":"执行经过上面的操作，我们已经根据程序生成了一个抽象语法树。此时我们需要让程序达到其预期的结果。即需要我们翻译为Java可执行的代码。实际上执行的过程很简单，既然我们已经生成了抽象语法树。我们只需要将每个节点的结果得到，最后得到根节点的结果，即为该程序的结果。所以这实际上也是一个树的遍历工作，从左边的叶节点开始遍历。依次得到上层的非叶节点的值。 针对不同的节点，我们的实现方法不同，但是我们都将其定义为eval方法，意为evaluate，即得到结果。 下面简单介绍几种类型的节点的实现： 实现基本节点针对一些基本节点，比如 二元运算： 12345678910111213141516/* * For a binary operation, the operation symbol will be considered to process different operation. */public Object eval(Environment env) &#123; String op = operator(); if (\"=\".equals(op)) &#123; ASTree rightTree = right(); Object rightVal = rightTree.eval(env); return computeAssign(env, rightVal); &#125; else &#123; Object left = left().eval(env); Object right = right().eval(env); return computeOp(left, op, right); &#125;&#125; if语句： 123456789101112131415/* * For a if statement, condition will eval first to decide whether the if block be executed. */public Object eval(Environment env) &#123; Object c = condition().eval(env); if (c instanceof Integer &amp;&amp; ((Integer)c).intValue() != FALSE) return thenBlock().eval(env); else &#123; ASTree b = elseBlock(); if (b == null) return 0; else return b.eval(env); &#125;&#125; 实际上这里就是递归的执行元素的eavl方法，实际上就是遍历ast的过程。 注意这里就是脚本语言与编译语言的区别，脚本语言会直接遍历ast执行。而预编译语言会先对源码进行编译，生成可执行程序或中间二进制代码，比如C语言编译会生成对应平台的可执行程序。java会通过Java虚拟机产生javac二进制文件，以此来解决跨平台的问题。 正是因为这个预编译的过程中，会对源码进行一定的分析和运算，将可运算先运算出来，使得预编译程序的效率会远高于脚本语言。","categories":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/categories/hair/"}],"tags":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/tags/hair/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://yoursite.com/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"},{"name":"语法分析","slug":"语法分析","permalink":"http://yoursite.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"基于java的脚本语言hair的开发思路2-语法分析","slug":"基于java的脚本语言hair的开发思路2-语法分析","date":"2021-09-26T07:42:25.000Z","updated":"2021-10-09T13:01:32.199Z","comments":true,"path":"2021/09/26/基于java的脚本语言hair的开发思路2-语法分析/","link":"","permalink":"http://yoursite.com/2021/09/26/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80hair%E7%9A%84%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"","text":"语法分析在经过上一步的词法分析之后，我们已经将程序字符串分以上三种token。要想让程序运行起来，我们还必须将其构造为抽象语法树(Abstract Syntax Tree)。 它是用来表示程序结构的树形结构。其中树的节点也分为不同的类型。 具体的树节点类型后面介绍。 在我们得到AST之后，想要得到结果，就很简单了：我们只需要自底而上活得每个树节点的对应的值。其根节点的值就是最终的程序结果。 所以问题的关键是如何通过token队列来获得AST。这里我们首先引入BNF的概念。 BNFBNF即巴科斯范式，其是一种描述语法的一种形式体系，是一种典型的元语言（相当于一种伪代码来描述语法规则）。其规则如下： 字符本身： “xxx” - 表示xxx字符本身。如：”function”表示匹配function字符。 [xxx]表示xxx模式出现0次或1次。 {xxx}表示xxx模式至少出现0次。 (xxx)表示括号内的模式为一个整体。 xxx|yyy表示匹配xxx或yyy模式。 后来BNF也做了很多扩展，我们这里仅使用以上5种模式。 整个匹配过程中包含两个过程，即： 创建匹配模式实例。 使用该模式匹配token串。 下面分别介绍： 创建匹配模式对于一个匹配模式，就是一个Parser对象。其有两个成员变量： elements：用于存放模式匹配的子模式，即子树模式结构。 factory：用于创建该模式对应的树节点。 接下来我们看看具体的创建代码： 其调用栈如下顺序： 第一步：通过rule()最外层API创建模式，其有两个重载，分别对应是否传入匹配到的树节点类型。 1234567891011/* * Create an empty Parser without a parameter. */public static Parser rule() &#123; return rule(null); &#125;/* * Create a Parser with a ASTree parameter, caution that this Parser is a single node with the parameter. */public static Parser rule(Class&lt;? extends ASTree&gt; clazz) &#123; return new Parser(clazz);&#125; Parser的构造方法，也有两个重载，其中第一个是用于构建模式树的根节点；而第二个适用于直接接受一个Parser并将其成员变量复制过来，其主要是用在maybe方法的实现中。 1234567891011121314151617protected List&lt;Element&gt; elements;protected Factory factory;/* * This constructor is used for first create Parser. */public Parser(Class&lt;? extends ASTree&gt; clazz) &#123; reset(clazz);&#125;/* * This constructor is used for chain call. */protected Parser(Parser p) &#123; elements = p.elements; factory = p.factory;&#125; 接下来的reset方法其实就是初始化（或者重置）Parser的成员：elements和factory 12345678/* * Reset the parser, elements and factory are all need to be reset. */public Parser reset(Class&lt;? extends ASTree&gt; clazz) &#123; elements = new ArrayList&lt;Element&gt;(); factory = Factory.getForASTList(clazz); return this;&#125; 然后就是Factory对象的getForASTList静态方法，这里的两个方法比较重要，主要是如何来构建一个factory。首先会从外部传来的class来构建一个Factory。我们后面再看get方法，首先来分析f == null时的情况。 这里就直接通过new方法来构建一个新的factory，值得注意的是这里实现了本来是make0方法。 注意：这个方法是用在匹配token串，使用该方法创建对应的AST节点。 这里的逻辑是：判断传入的arg的长度是等于1。如果等于1则返回其第一个元素。否则的话就利用org返回一个新的ASTList。 12345678910111213141516171819202122protected static Factory getForASTList(Class&lt;? extends ASTree&gt; clazz) &#123; /** * Get the class with the ASTree class transferred by user. */ Factory f = get(clazz, List.class); /** * If user did not transferred the class, * we implement the make0 method and new a factory which make a normal ASTree object. */ if (f == null) f = new Factory() &#123; protected ASTree make0(Object arg) throws Exception &#123; List&lt;ASTree&gt; results = (List&lt;ASTree&gt;)arg; if (results.size() == 1) return results.get(0); else return new ASTList(results); &#125; &#125;; return f;&#125; 接下来我们来看get方法。这里主要是如何利用传入的class来构建这个factory。首先如果是没有传入class，则直接返回class。 如果class != null时，则会有两种情况： 首先判断这个class有没有create方法（factoryName为字符串creatr），如果有的话就获取这个方法，然后实现了make0方法。 其次判断是否有构造器，如果有的话，make0方法就会直接利用该构造函数来新建一个该对象。 123456789101112131415161718192021222324252627282930313233343536373839protected static Factory get(Class&lt;? extends ASTree&gt; clazz, Class&lt;?&gt; argType)&#123; /** * If user transferred no class, get method return null. */ if (clazz == null) return null; try &#123; /** * Judge whether the class transferred by user has a \"create\" function. * If true, we just use the function to create the ASTree. */ final Method m = clazz.getMethod(factoryName, new Class&lt;?&gt;[] &#123; argType &#125;); return new Factory() &#123; protected ASTree make0(Object arg) throws Exception &#123; return (ASTree)m.invoke(null, arg); &#125; &#125;; &#125; catch (NoSuchMethodException e) &#123;&#125; /** * If the class has not a \"create\" function. * We judge whether the class has a constructor. * If true, we use the constructor to create the ASTree. */ try &#123; final Constructor&lt;? extends ASTree&gt; c = clazz.getConstructor(argType); return new Factory() &#123; protected ASTree make0(Object arg) throws Exception &#123; return c.newInstance(arg); &#125; &#125;; &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(e); &#125;&#125; 值得注意的是Parser对象还有很对方法用来对应BNF的规则： number：用于向Parser的elements添加number型AToken（这里的AToken是在Parser中的内部类，属于模式AST类）。 identifier：用于向Parser的elements添加identifier型AToken。 string：用于向Parser的elements添加srting型AToken。 sep：用于向Parser的elements添加用于间隔型AToken，在BNF中对应字符串本身。 ast：用于向Parser的elements添加基本的树结构，常用于直接传递其他模式串作为子串。 or：用于向Parser的elements添加分支结构的树结构，对应BNF的|。 maybe：用于向Parser的elements添加可省略的模式。 option：用于向Parser的elements添加可省略的模式，对应BNF的[]。 repeat： 用于向Parser的elements添加可重复的模式，对应BNF的{}。 expression：用于向Parser的elements添加以Express为树节点的模式。 下面是一个简单的模式的创建： 1Parser classNew = rule(NewStmnt.class).sep(\"new\").identifier(reserved).sep(\"(\").option(args).sep(\")\"); 其主要是匹配新建对象时的语法，如： 1new Obj(111, 222) 可以看到rule首先接受了一个NewStmnt.class参数，这就意味着，当这个模式匹配成功时，其创建的节点是NewStmnt类型的。 然后sep(&quot;new&quot;)即匹配new这个字符。 identifier(reserved)即匹配保留字，即变量名等。 option(args)即表示匹配可以省略的arguments，这里的args也是在前面定义的一个模式，匹配诸如：222,&quot;uuu&quot;之类的参数模式。 匹配token串在Parser中定义了诸多子类即模式节点，这些节点自己定义了parser方法用于解析对应的token是否匹配。 我们上面构建语法规则实际上形成了一个树，其节点就是之前定义在Parser内部的各种子类。 但其主要依然是一个递归的过程，首先会从队列中peek一个token（peek是不会让该token出队的），然后从匹配树的根部开始向下遍历，查找到其叶节点，然后匹配，如果通过则将调用其factory的make方法，来构建一个对应class的叶节点并且将其推入其elements中。 这里给出了一部分的结构（定义类的结构），我们模拟一下其解析过程： 123456class Myclass&#123; a = 1 constructor(param1)&#123; a = param1 &#125;&#125; 首先我们会通过Lexer会生成一个queue： StrToken:”class”-&gt;IdToken:Myclass-&gt;StrToken:”a”-&gt;… peek一个token，即第一个StrToken。 遍历树：从program-&gt;classDef-&gt;”class”，匹配成功。（若第一次没有匹配成功，将会在树上进行回溯）。 新建一个ClassDef对象的树节点。 接下来再peek一个token，即IdToken:Myclass 再从classDef的第二个节点开始匹配，发现也匹配成功。 创建一个Name树节点并将其加入刚才ClassDef的elements中。 后面也是如此，一次递归，失败就回溯；成功就继续匹配。 下面附上目前版本定义的规则（包括类，数组）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package parser;import static parser.Parser.rule;import java.util.HashSet;import parser.Parser.*;import scanner.Lexer;import token.Token;import ast.*;import entity.Function;import exception.ParseException;public class BasicParser &#123; HashSet&lt;String&gt; reserved = new HashSet&lt;String&gt;(); Operators operators = new Operators(); Parser expr0 = rule(); Parser primary = rule(PrimaryExpr.class) .or(rule().sep(\"(\").ast(expr0).sep(\")\"), rule().number(NumberLiteral.class), rule().identifier(Name.class, reserved), rule().string(StringLiteral.class) ); Parser factor = rule().or(rule(NegativeExpr.class).sep(\"-\").ast(primary), primary); Parser expr = expr0.expression(BinaryExpr.class, factor, operators); Parser statement0 = rule(); Parser block = rule(BlockStmnt.class) .sep(\"&#123;\").option(statement0) .repeat(rule().sep(\";\", Token.EOL).option(statement0)) .sep(\"&#125;\"); Parser simple = rule(PrimaryExpr.class).ast(expr); /** * Function Parser */ Parser param = rule().identifier(reserved); Parser params = rule(ParameterList.class).ast(param).repeat(rule().sep(\",\").ast(param)); Parser paramList = rule().sep(\"(\").maybe(params).sep(\")\"); Parser function = rule(FunctionStmnt.class).sep(\"function\").identifier(reserved).ast(paramList).ast(block); /** * InnerFunction Parser */ Parser innerFunction = rule(InnerFunc.class).sep(\"func\").ast(paramList).ast(block); Parser args = rule(Arguments.class).ast(expr).repeat(rule().sep(\",\").ast(expr));// Parser postfix = rule().sep(\"(\").maybe(args).sep(\")\"); Parser postfix = rule().or(rule(Dot.class).sep(\".\").identifier(reserved), rule().sep(\"(\").ast(args).sep(\")\"), rule(Squarebracket.class).sep(\"[\").ast(expr).sep(\"]\") ); Parser statement = statement0.or( rule(IfStmnt.class).sep(\"if\").sep(\"(\").ast(expr).sep(\")\").ast(block).option(rule().sep(\"else\").ast(block)), rule(WhileStmnt.class).sep(\"while\").sep(\"(\").ast(expr).sep(\")\").ast(block), simple); /** * class Parser */ Parser constructor = rule(Construtor.class).sep(\"constructor\").ast(paramList).ast(block); /** * The order can not be changed. Or constructor maybe regard as simple parser. */ Parser classEle = rule().or(constructor, function, simple); Parser classBody = rule(ClassBody.class).sep(\"&#123;\").option(classEle). repeat(rule().sep(\";\", Token.EOL).option(classEle)).sep(\"&#125;\"); Parser classDef = rule(ClassStmnt.class).sep(\"class\").identifier(reserved).option(rule().sep(\"extends\").identifier(reserved)).ast(classBody); Parser classNew = rule(NewStmnt.class).sep(\"new\").identifier(reserved).sep(\"(\").option(args).sep(\")\"); /** * Array Parsers */ Parser arrayDef = rule(ArrayStmnt.class).sep(\"[\").ast(expr).repeat(rule().sep(\",\").ast(expr)).sep(\"]\"); /** * final program Parser. */ Parser program = rule().or(classDef, statement, rule(NullStmnt.class)) .sep(\";\", Token.EOL); public BasicParser() &#123; reserved.add(\")\"); reserved.add(\";\"); reserved.add(\"&#125;\"); reserved.add(\"]\"); reserved.add(Token.EOL); operators.add(\"=\", 1, Operators.RIGHT); operators.add(\"==\", 2, Operators.LEFT); operators.add(\"&gt;\", 2, Operators.LEFT); operators.add(\"&lt;\", 2, Operators.LEFT); operators.add(\"+\", 3, Operators.LEFT); operators.add(\"-\", 3, Operators.LEFT); operators.add(\"*\", 4, Operators.LEFT); operators.add(\"/\", 4, Operators.LEFT); operators.add(\"%\", 4, Operators.LEFT); /** * avoid cycle reference, so we repair some Parser here. */ primary.repeat(postfix); primary.insertChoice(innerFunction); primary.insertChoice(classNew); primary.insertChoice(arrayDef); simple.option(rule().sep(\")\").option(args).sep(\")\")); &#125; public ASTree parse(Lexer lexer) throws ParseException &#123; return program.parse(lexer); &#125;&#125; 其中reserved即为保留字符，不会被识别为标识符等。 operators即为操作符，主要用在BinaryExpress即二元表达式中。 add函数的参数第一个是操作符，第二个是优先级，第三个是左先计算还是右先计算。","categories":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/categories/hair/"}],"tags":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/tags/hair/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://yoursite.com/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"},{"name":"语法分析","slug":"语法分析","permalink":"http://yoursite.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"基于java的脚本语言hair的开发思路1-词法分析","slug":"基于java的脚本语言hair的开发思路1-词法分析","date":"2021-09-21T07:23:07.000Z","updated":"2021-09-26T07:47:32.008Z","comments":true,"path":"2021/09/21/基于java的脚本语言hair的开发思路1-词法分析/","link":"","permalink":"http://yoursite.com/2021/09/21/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80hair%E7%9A%84%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"","text":"申明：本脚本语言前面的开发思路基本是《两周自制脚本语言》中Stone语言的模型，后期将逐渐分离，添加更多特征。这本书作为入门读物确实不错，但是其设计规范还是有待商榷，一是没有给出一个确定的项目架构、二是部分的结构的成分不够规范（比如token的定义，运算优先级的处理等）。 词法分析一个程序片段被编译器解析的时候是一个很长的字符串。我们的目标是通过一定的手段分析将这个字符串分开来。 而这个被分割后的子字符串我们一般称为Token，Token有很多类型。在V8中定义的部分代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#define BINARY_OP_TOKEN_LIST(T, E) \\ E(T, NULLISH, \"??\", 3) \\ E(T, OR, \"||\", 4) \\ E(T, AND, \"&amp;&amp;\", 5) \\ E(T, BIT_OR, \"|\", 6) \\ E(T, BIT_XOR, \"^\", 7) \\ E(T, BIT_AND, \"&amp;\", 8) \\ E(T, SHL, \"&lt;&lt;\", 11) \\ E(T, SAR, \"&gt;&gt;\", 11) \\ E(T, SHR, \"&gt;&gt;&gt;\", 11) \\ E(T, MUL, \"*\", 13) \\ E(T, DIV, \"/\", 13) \\ E(T, MOD, \"%\", 13) \\ E(T, EXP, \"**\", 14) \\ E(T, ADD, \"+\", 12) \\ E(T, SUB, \"-\", 12)#define EXPAND_BINOP_ASSIGN_TOKEN(T, name, string, precedence) \\ T(ASSIGN_##name, string \"=\", 2)#define EXPAND_BINOP_TOKEN(T, name, string, precedence) \\ T(name, string, precedence)#define TOKEN_LIST(T, K) \\ \\ /* BEGIN PropertyOrCall */ \\ /* BEGIN Member */ \\ /* BEGIN Template */ \\ /* ES6 Template Literals */ \\ T(TEMPLATE_SPAN, nullptr, 0) \\ T(TEMPLATE_TAIL, nullptr, 0) \\ /* END Template */ \\ \\ /* Punctuators (ECMA-262, section 7.7, page 15). */ \\ /* BEGIN Property */ \\ T(PERIOD, \".\", 0) \\ T(LBRACK, \"[\", 0) \\ /* END Property */ \\ /* END Member */ \\ T(QUESTION_PERIOD, \"?.\", 0) \\ T(LPAREN, \"(\", 0) \\ /* END PropertyOrCall */ \\ T(RPAREN, \")\", 0) \\ T(RBRACK, \"]\", 0) \\ T(LBRACE, \"&#123;\", 0) \\ T(COLON, \":\", 0) \\ T(ELLIPSIS, \"...\", 0) \\ T(CONDITIONAL, \"?\", 3) \\ /* BEGIN AutoSemicolon */ \\ T(SEMICOLON, \";\", 0) \\ T(RBRACE, \"&#125;\", 0) \\ /* End of source indicator. */ \\ T(EOS, \"EOS\", 0) \\ /* END AutoSemicolon */ \\ \\ /* BEGIN ArrowOrAssignmentOp */ \\ T(ARROW, \"=&gt;\", 0) \\ /* BEGIN AssignmentOp */ \\ /* IsAssignmentOp() relies on this block of enum values being */ \\ /* contiguous and sorted in the same order! */ \\ T(INIT, \"=init\", 2) /* AST-use only. */ \\ T(ASSIGN, \"=\", 2) \\ BINARY_OP_TOKEN_LIST(T, EXPAND_BINOP_ASSIGN_TOKEN) \\ /* END AssignmentOp */ \\ /* END ArrowOrAssignmentOp */ \\ \\ /* Binary operators sorted by precedence. */ \\ /* IsBinaryOp() relies on this block of enum values */ \\ /* being contiguous and sorted in the same order! */ \\ T(COMMA, \",\", 1) \\ \\ /* Unary operators, starting at ADD in BINARY_OP_TOKEN_LIST */ \\ /* IsUnaryOp() relies on this block of enum values */ \\ /* being contiguous and sorted in the same order! */ \\ BINARY_OP_TOKEN_LIST(T, EXPAND_BINOP_TOKEN) \\ \\ T(NOT, \"!\", 0) \\ T(BIT_NOT, \"~\", 0) \\ K(DELETE, \"delete\", 0) \\ K(TYPEOF, \"typeof\", 0) \\ K(VOID, \"void\", 0) \\ \\ /* BEGIN IsCountOp */ \\ T(INC, \"++\", 0) \\ T(DEC, \"--\", 0) \\ /* END IsCountOp */ \\ /* END IsUnaryOrCountOp */ \\ \\ /* Compare operators sorted by precedence. */ \\ /* IsCompareOp() relies on this block of enum values */ \\ /* being contiguous and sorted in the same order! */ \\ T(EQ, \"==\", 9) \\ T(EQ_STRICT, \"===\", 9) \\ T(NE, \"!=\", 9) \\ T(NE_STRICT, \"!==\", 9) \\ T(LT, \"&lt;\", 10) \\ T(GT, \"&gt;\", 10) \\ T(LTE, \"&lt;=\", 10) \\ T(GTE, \"&gt;=\", 10) \\ K(INSTANCEOF, \"instanceof\", 10) \\ K(IN, \"in\", 10) \\ \\ /* Keywords (ECMA-262, section 7.5.2, page 13). */ \\ K(BREAK, \"break\", 0) \\ K(CASE, \"case\", 0) \\ K(CATCH, \"catch\", 0) \\ K(CONTINUE, \"continue\", 0) \\ K(DEBUGGER, \"debugger\", 0) \\ K(DEFAULT, \"default\", 0) \\ /* DELETE */ \\ K(DO, \"do\", 0) \\ K(ELSE, \"else\", 0) \\ K(FINALLY, \"finally\", 0) \\ K(FOR, \"for\", 0) \\ K(FUNCTION, \"function\", 0) \\ K(IF, \"if\", 0) \\ /* IN */ \\ /* INSTANCEOF */ \\ K(NEW, \"new\", 0) \\ K(RETURN, \"return\", 0) \\ K(SWITCH, \"switch\", 0) \\ K(THROW, \"throw\", 0) \\ K(TRY, \"try\", 0) \\ /* TYPEOF */ \\ K(VAR, \"var\", 0) \\ /* VOID */ \\ K(WHILE, \"while\", 0) \\ K(WITH, \"with\", 0) \\ K(THIS, \"this\", 0) \\ \\ /* Literals (ECMA-262, section 7.8, page 16). */ \\ K(NULL_LITERAL, \"null\", 0) \\ K(TRUE_LITERAL, \"true\", 0) \\ K(FALSE_LITERAL, \"false\", 0) \\ T(NUMBER, nullptr, 0) \\ T(SMI, nullptr, 0) \\ T(BIGINT, nullptr, 0) \\ T(STRING, nullptr, 0) \\ \\ /* BEGIN Callable */ \\ K(SUPER, \"super\", 0) \\ /* BEGIN AnyIdentifier */ \\ /* Identifiers (not keywords or future reserved words). */ \\ T(IDENTIFIER, nullptr, 0) \\ K(GET, \"get\", 0) \\ K(SET, \"set\", 0) \\ K(ASYNC, \"async\", 0) \\ /* `await` is a reserved word in module code only */ \\ K(AWAIT, \"await\", 0) \\ K(YIELD, \"yield\", 0) \\ K(LET, \"let\", 0) \\ K(STATIC, \"static\", 0) \\ /* Future reserved words (ECMA-262, section 7.6.1.2). */ \\ T(FUTURE_STRICT_RESERVED_WORD, nullptr, 0) \\ T(ESCAPED_STRICT_RESERVED_WORD, nullptr, 0) \\ /* END AnyIdentifier */ \\ /* END Callable */ \\ K(ENUM, \"enum\", 0) \\ K(CLASS, \"class\", 0) \\ K(CONST, \"const\", 0) \\ K(EXPORT, \"export\", 0) \\ K(EXTENDS, \"extends\", 0) \\ K(IMPORT, \"import\", 0) \\ T(PRIVATE_NAME, nullptr, 0) \\ \\ /* Illegal token - not able to scan. */ \\ T(ILLEGAL, \"ILLEGAL\", 0) \\ T(ESCAPED_KEYWORD, nullptr, 0) \\ \\ /* Scanner-internal use only. */ \\ T(WHITESPACE, nullptr, 0) \\ T(UNINITIALIZED, nullptr, 0) \\ T(REGEXP_LITERAL, nullptr, 0) 可以看到V8定义了很多token类型，符号、关键字都被分开来定义。 但是作为一门简单的脚本语言，书中简单的将Token分为了3大类： Number Token：整形Token。 String Token：字符串Token。 Identifier Token: 标识符、关键字、变量名、运算符等。（除Number， String以外的单词）。 每种Token我们定义了一个类，其存储的主要信息有行号和实值（数字，字符串，标识符）。 最主要对于代码的解析我们用到了Java的正则匹配。而在V8中是自己写了匹配规则。 我们简单介绍一下： java的正则表达式Pattern类pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。下面是他的所有成员： 名称 解释 返回值 compile(String regex, ?int flags) Pattern类没有构造函数，都是通过该函数来获得匹配实体。其中regex是正则表达式，flags是模式，比如是否匹配换行等，一般使用Patter提供的静态变量来传递。 Pattern：由传入正则表达式编译形成的patter实体。 match(String regex, CharSequence input) 通过传入的regex创建匹配实体并且尝试匹配input。 boolean：是否成功匹配。 quote(String s) 将返回一个仅匹配s的正则表达式。（实际上是在s前后分别\\Q和\\E）。 String：一个仅可匹配s的一个字符串。 CANON_EQ: int 表示当两个字符严格相等时才匹配。主要是对于Unicode字符而言。（不重要，不再赘述）。 / CASE_INSENSITIVE:int 是否大小写敏感，默认是，传入该变量则表示不敏感（也可在regex中插入?i表示此意）。 / COMMENTS:int 是否忽略regex中的空格，不是//s，而是空格或者tab等（也可在regex中插入?x表示此意）。 / DOTALL:int 表示点(.)是否可以匹配所有字符，包括结束符。（也可在regex中插入?s表示此意）。 / LITERAL:int 表示启用字面值解析模式。 指定此标志后，指定模式的输入字符串就会作为字面值字符序列来对待。输入序列中的元字符或转义序列不具有任何特殊意义。 / MULTILINE:int 默认情况下，输入的字符串被看作是一行，即便是这一行中包好了换行符也被看作一行。当匹配“^”到“$”之间的内容的时候，整个输入被看成一个一行。启用多行模式之后，包含换行符的输入将被自动转换成多行，然后进行匹配。 / UNIX_LINES:int 表示仅以\\n为换行，\\r\\n将不会被识别为换行。（也可在regex中插入?d表示此意）。 / 所以基本只会使用compile这个函数和以下的几个静态变量。 示例12private String regexPat = \"\\\\abc\"private Pattern pattern = Pattern.compile(regexPat); Matcher 类Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 下面是其成员： 方法 说明 public MatchResult toMatchResult() 将匹配结果以MatchResult的形式返回 public Matcher usePattern(Pattern newPattern) 修改Matcher对象的Pattern，用以进行新的模式匹配。 public Matcher reset() 重置匹配器的状态。 public Matcher reset(CharSequence input) 重置匹配器的状态，重置目标字符串的值为input。 public int start() 返回当前匹配到的字符串在原目标字符串中的起始索引位置 public int start(int group) 返回当前匹配到的字符串中group组在目标字符串的起始索引位置 public int end() 返回当前匹配的字符串的最后一个字符在原目标字符串中的offset（偏移量），这个需要大家注意一下。 public int end(int group) 返回当前匹配的字符串中group组的最后一个字符在原目标字符串中的offset（偏移量），这个需要大家注意一下。 public String group() 返回匹配到的所有字符串，结合find函数使用。 public String group(int group) 返回匹配到的字符串中的对应index的group组的字符串。 public String group(String name) 返回被named-capturing组捕获的字符串，关于named-capturing group（命名捕获组）是JDK1.7新增的功能，可以将正则表达式中的组进行命名。 public int groupCount() 返回当前Matcher对象捕获的组的个数。 public boolean matches() 将整个目标字符串与正则表达式进行匹配，只有完全匹配才能返回true，否则false。 public boolean find() 对目标字符串进行正则匹配，通过while可以多次执行find方法，获取多次的匹配结果，代码编写方式类似于iterator.next()。 public boolean find(int start) 在指定的索引位置对目标字符串进行正则匹配。 public boolean lookingAt() 目标字符串的起始字符串与正则表达式匹配返回true，否则返回false。 public static String quoteReplacement(String s) 返回字符串s字面意义的替代字符串。 public Matcher appendReplacement(StringBuffer sb, String replacement) 向sb中追加replacement字符串，replacement字符串中可以包含匹配器中的分组参数，如1，2。 public StringBuffer appendTail(StringBuffer sb) 将Matcher匹配后的尾部字符串追加至sb中。 public String replaceAll(String replacement) 将目标字符串中所有满足正则匹配的字符串替换为replacement。 public String replaceFirst(String replacement) 将目标字符串中第一个满足正则匹配的字符串替换为replacement。 public Matcher region(int start, int end) 设置目标字符串的匹配范围。 public int regionStart() 返回匹配器区域的起始点索引位置。 public int regionEnd() 返回匹配器区域的结束点索引位置。 public boolean hasTransparentBounds() TransparentBounds标志位：查询TransparentBounds标志位true public Matcher useTransparentBounds(boolean b) 设置TransparentBounds标志位的值true public boolean hasAnchoringBounds() AnchoringBounds标志位：查询AnchoringBounds标志位的值，此标志位默认为true。在应用正则表达式的时候，我们可以指定目标字符串的检索范围，也就是说在目标字符串的子字符串中应用正则表达式。但此时会有一个问题，那就是 ^ 和 $ 应该匹配整个字符串的开头和结尾呢？ 还是检索范围的起始和结束位置呢？Java 为我们提供了足够的灵活性，我们可以通过下面的方法来查看和设置，默认值是匹配检索范围的起始和结束位置。 public Matcher useAnchoringBounds(boolean b) 设置AnchoringBounds标志位的值true public boolean hitEnd() public boolean requireEnd() boolean match(int from, int anchor) int getTextLength() 返回目标字符串的长度。 CharSequence getSubSequence(int beginIndex, int endIndex) 获取目标字符串的子字符串。 char charAt(int i) 返回目标字符串中索引为i的字符 PatternSyntaxExceptionPatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。 捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组： ((A)(B(C))) (A) (B(C)) (C) 可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。 还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。 正则表达式语法有一个需要注意的点： Java中的转移字符为两个反斜杠\\\\,这与其他语言不同。即当我们需要对一个字符进行转义的时候，我们需要在前面写两个\\。 如：一般的我们需要匹配换行符\\n这个符号的时候，我们只需要这么写：\\n。 而在Java中，我们需要这么写：\\\\n。 下面是匹配的字符： 字符 说明 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， n匹配字符 n。\\n 匹配换行符。序列 \\\\\\\\ 匹配 \\\\ ，\\\\( 匹配 (。 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\\n”或”\\r”之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\\n”或”\\r”之前的位置匹配。 * 零次或多次匹配前面的字符或子表达式。例如，zo 匹配”z”和”zoo”。 等效于 {0,}。 + 一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。 ? 零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。 {n} n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。 {n,} n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。 {n,m} m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。 ? 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。 . 匹配除”\\r\\n”之外的任何单个字符。若要匹配包括”\\r\\n”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式。 (pattern) 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”\\(“或者”\\)”。 (?:pattern) 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (\\ ) 组合模式部件的情况很有用。例如，’industr(?:y\\ ies) 是比 ‘industry\\ industries’ 更经济的表达式。 (？=pattern) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95\\ 98\\ NT\\ 2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 (?!pattern) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95\\ 98\\ NT\\ 2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 x\\ y 匹配 x 或 y。例如，’z\\ food’ 匹配”z”或”food”。’(z\\ f)ood’ 匹配”zood”或”food”。 [xyz] 字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。 [^xyz] 反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。 [a-z] 字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。 [^a-z] 反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。 \\b 匹配一个字边界，即字与空格间的位置。例如，”er\\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。 \\B 非字边界匹配。”er\\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。 \\cx 匹配 x 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。 \\d 数字字符匹配。等效于 [0-9]。 \\D 非数字字符匹配。等效于 [^0-9]。 \\f 换页符匹配。等效于 \\x0c 和 \\cL。 \\n 换行符匹配。等效于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等效于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r \\v] 等效。 \\S 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。 \\t 制表符匹配。与 \\x09 和 \\cI 等效。 \\v 垂直制表符匹配。与 \\x0b 和 \\cK 等效。 \\w 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。 \\W 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。 \\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\\x41”匹配”A”。”\\x041”与”\\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。 \\num 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\\1”匹配两个连续的相同字符。 \\n 标识一个八进制转义码或反向引用。如果 \\n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 \\nm 标识一个八进制转义码或反向引用。如果 \\nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \\nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \\nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。 \\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 \\un 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。 \\p{Punct} 匹配任何标点字符。 下面我们看一下主要的regexPat： 123public static String regexPat = \"\\\\s*((//.*)|([0-9]+)|(\\\"(\\\\\\\\\\\"|\\\\\\\\\\\\\\\\|\\\\\\\\n|[^\\\"])*\\\")\" +\"|[A-Z_a-z][A-Z_a-z0-9]*|==|&lt;=|&gt;=|&amp;&amp;|\\\\|\\\\||\\\\p&#123;Punct&#125;)?\"; 接下来我们按上面的规则来分析这个解析表达式： 1\"\\\\s*((//.*)|([0-9]+)|(\\\"(\\\\\\\\\\\"|\\\\\\\\\\\\\\\\|\\\\\\\\n|[^\\\"])*\\\")|[A-Z_a-z][A-Z_a-z0-9]*|==|&lt;=|&gt;=|&amp;&amp;|\\\\|\\\\||\\\\p&#123;Punct&#125;)?\"; 我们经过格式化。可以得到以下结果： 123456789101112131415161718192021222324252627282930\\\\s* 匹配空格( group(1) ( &#x2F;&#x2F;.* 匹配注释-group(2) ) | ( [0-9]+ 匹配数字-group(3) ) | ( \\&quot;(\\\\\\\\\\&quot;|\\\\\\\\\\\\\\\\|\\\\\\\\n|[^\\&quot;])*\\&quot; 匹配字符串-group(4) ) | [A-Z_a-z][A-Z_a-z0-9]* 匹配标识符，identifier | &#x3D;&#x3D; 匹配&#x3D;&#x3D; | &lt;&#x3D; 匹配&lt;&#x3D; | &gt;&#x3D; 匹配&gt;&#x3D; | &amp;&amp; 匹配&amp;&amp; | \\\\ 匹配\\ | \\\\| 匹配| | \\\\p&#123;Punct&#125; 匹配任何标点字符)? 匹配0次或1次 可以看出，我们将其分割开来，还是比较容易看懂的。所以此时我们再看匹配的Java代码： 1234567891011121314151617private void addToken(int lineNumber, Matcher matcher) &#123; String m = matcher.group(1); //最外层匹配项 // System.out.println(m); if(m != null) &#123; //not a space if(matcher.group(2) == null) &#123; //not a comment Token token; if(matcher.group(3) != null) &#123; //数字Token，例如123 token = new NumToken(lineNumber, Integer.parseInt(m)); &#125;else if(matcher.group(4) != null) &#123; //字符串匹配，例如 \"123\" token = new StrToken(lineNumber, toStringLiteral(m)); &#125;else &#123; //id匹配，例如while token = new IdToken(lineNumber, m); &#125; queue.add(token); &#125; &#125;&#125; 即可以完全和Java代码匹配出来。 总体思路所以词法分析的主要流程很简答： 将代码读取出来为stream，按行读取。 使用正则表达式匹配每一行的代码，将其识别为对应的单词（token）。 将识别出的token加入到Lexer的ArrayList中。","categories":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/categories/hair/"}],"tags":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/tags/hair/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://yoursite.com/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"},{"name":"词法分析","slug":"词法分析","permalink":"http://yoursite.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"java的正则表达式","slug":"java的正则表达式","date":"2021-09-19T01:00:40.000Z","updated":"2021-09-19T01:43:39.051Z","comments":true,"path":"2021/09/19/java的正则表达式/","link":"","permalink":"http://yoursite.com/2021/09/19/java%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"APIPattern类pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 示例12private String regexPat = \"\\\\abc\"private Pattern pattern = Pattern.compile(regexPat); Matcher 类Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxExceptionPatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。 捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组： ((A)(B(C))) (A) (B(C)) (C) 可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。 还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。 正则表达式语法","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Tensorflow2.0-data模块的使用","slug":"Tensorflow2-0-data模块的使用","date":"2021-09-04T12:06:03.000Z","updated":"2021-09-07T13:26:17.640Z","comments":true,"path":"2021/09/04/Tensorflow2-0-data模块的使用/","link":"","permalink":"http://yoursite.com/2021/09/04/Tensorflow2-0-data%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Tensorflow-dataTesorflow官方提供了一些数据集来供我们使用。其地址为Tensorflow-data，我们可以在这里查看数据集的详细细节Tensorflow-data-catalog。 其API地址为API。 简单使用Tensorflow-data有137个API，一般不会全部使用。我们需要了解的第一个API是： tfds.load：从本地或网络载入数据集，并生成tf.data.Dataset对象。 其基本形式为： 1234567891011121314151617tfds.load( name: str, *, split: Optional[Tree[splits_lib.Split]] = None, data_dir: Optional[str] = None, batch_size: tfds.typing.Dim = None, shuffle_files: bool = False, download: bool = True, as_supervised: bool = False, decoders: Optional[TreeDict[decode.Decoder]] = None, read_config: Optional[tfds.ReadConfig] = None, with_info: bool = False, builder_kwargs: Optional[Dict[str, Any]] = None, download_and_prepare_kwargs: Optional[Dict[str, Any]] = None, as_dataset_kwargs: Optional[Dict[str, Any]] = None, try_gcs: bool = False) tfds.load实际上是一个对内建三个方法的语法糖： 新建一个DatasetBuilder： 1builder = tfds.builder(name, data_dir=data_dir, **builder_kwargs) 为这个build下载或准备（本地则不需要下载）数据集： 1builder.download_and_prepare(**download_and_prepare_kwargs) 载入tf.data.Dataset对象： 12345678ds = builder.as_dataset( split=split, as_supervised=as_supervised, shuffle_files=shuffle_files, read_config=read_config, decoders=decoders, **as_dataset_kwargs,) 说完我们再来看每个参数解析： 名字 类型 说明 必须 默认值 name String 数据集的名称，我们可以在Tensorflow-data-catalog查看数据集的名字。注意这里的名字是蛇形命名法，即：a_b_c的下划线分割的形式。 是 / split String/tuple 如何分割数据集，主要有’train’, ‘test’两个是符串以及其tuple构成。如：1: ‘train’, ‘test’，分别表示只载入训练数据，或只载入测试数据。2: [‘train’, ‘test’]，表示载入训练集和测试集，此时第一个参数会返回一个list，我们可以用(train_data, test_data)来解构list。3: ‘train[:120]’, ‘train[:75%]’, ‘test[25%:100%]’, ‘train[:4shard]’：如同python的list截取一样的格式，只不过这里可以是绝对值、者百分比值或者分片。片是tensorflow中的一个概念，数据集在下载时即定义好了一共多少个片，我们可以用info.splits[&#39;train&#39;].num_shards来查看总片数。4: ‘train+test’, ‘train[:25%]+test’: 这种格式会把训练集和测试集合并在一起返回，其中每一部分都可以用列表截断。值得注意的是：每个数据集支持的split的格式不同，需要我们具体来使用。 否 数据集定义的划分模式 data_dir String 写入/读取数据集的地址，我们可以更改这个地址。 否 win下：C:\\Users\\[user]\\tensorflow_datasets batch_size Int 设置一个batch的大小，这里的batch主要是针对较大的数据集，不可能将所有的数据全部读进内存，我们会一次读取一个batch进内存运算。 否 不划分batch shuffle_files Boolean 是否需要打乱输入数据 否 False download Boolean 是否是从远程下载 否 True as_supervised Boolean 是否是监督模式，如果是True的话， tf.data.Dataset decoders read_config with_info builder_kwargs download_and_prepare_kwargs as_dataset_kwargs try_gcs","categories":[{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://yoursite.com/categories/Tensorflow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://yoursite.com/tags/Tensorflow/"},{"name":"Tensorflow-data","slug":"Tensorflow-data","permalink":"http://yoursite.com/tags/Tensorflow-data/"}]},{"title":"西瓜书总结3-线性模型","slug":"西瓜书总结3-线性模型","date":"2021-09-02T14:30:41.000Z","updated":"2021-09-03T13:42:21.926Z","comments":true,"path":"2021/09/02/西瓜书总结3-线性模型/","link":"","permalink":"http://yoursite.com/2021/09/02/%E8%A5%BF%E7%93%9C%E4%B9%A6%E6%80%BB%E7%BB%933-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"基本形式线性模型（linear model）顾名思义即通过线性函数来进行预测的模型。 大部分机器学习算法的本质都是寻找一个函数来将输入进行处理得到预测结果。这里最简单的线性模型是这样，最复杂的神经网络模型也是如此。 线性模型的一般形式为： f(x) = w1x1+w1x1+…+wdxd+b 向量形式则为： f(x) = wTx + b 其中w = (w1; w1; …;wd;)， w和b学得之后，模型就得以确定。 线性模型形式简单、易于构造，但却蕴含着机器学习中一些重要的思想。许多更为强大的非线性模型可在线性模型的基础上通过引入层级结构更高或高维映射而得。 线性回归","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"西瓜书","slug":"西瓜书","permalink":"http://yoursite.com/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"},{"name":"线性模型","slug":"线性模型","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"}]},{"title":"西瓜书总结2-模型评估与选择","slug":"西瓜书总结2-模型评估与选择","date":"2021-08-30T11:27:49.000Z","updated":"2021-09-02T14:15:26.926Z","comments":true,"path":"2021/08/30/西瓜书总结2-模型评估与选择/","link":"","permalink":"http://yoursite.com/2021/08/30/%E8%A5%BF%E7%93%9C%E4%B9%A6%E6%80%BB%E7%BB%932-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/","excerpt":"","text":"经验误差与过拟合概念错误率：分类错误的样本数占样本总数的比例。 精度：1 - 错误率。 训练误差（经验误差）：学习器在训练集上的误差。 泛化误差：学习器在新样本上的误差。 过拟合：把训练样本自身的一些特点当作了所有潜在样本都具有的一般特征。一般无法彻底避免，只能缓解。 欠拟合：与过拟合相反，即对训练样本的一般性质未学习好。 评估方法留出法留出法（hold-out）直接将数据集D划分为两个互斥的集合，其中一个集合用作训练集S，另一个作为测试集T。即D=S∪T，S∩T=Ø。 其缺点在于少了一部分数据，所以训练出来的模型必然会有一定的偏差。 交叉验证法交叉验证法（cross validation）先将数据集D划分为k个大小相似的互斥子集，即D=D1∪D2∪…∪Dk，Di∩Dj=Ø(i ≠ j)。每个子集都尽可能保持数据分布的一致性，即从D通过分层采样获得。然后每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集；这样可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值。通常将其称为“k折交叉验证”。k的最常用取值为10，此时称为10折交叉验证。 其缺点在于时间复杂度会提升，k折即需要训练k次，在高复杂度的算法中，就会有较大影响。 自助法自助法是基于自助采样法（bootstrap sampling）。其过程为：每次随机从D中挑选出一个样本，将其“拷贝”到D1（注意是拷贝，即D1中的数据仍然可以在下一次采样中采集到），这个过程重复执行m次后，我们就得到了包含m个样本的数据集D1。 显然，D中的一部分样本会在D1中出现多次，也可能一次都不出现。 做一个简单的估计，某一样本x在m次采样中都不出现的概率为：(1 - 1//m)m，取极限可得其大概为 1/e = 0.368。即，初始样本集D中约有36.8%的样本未出现在采样集D中D1中，所以我们将D1作为训练集，D/D1作为测试集。这样，实际的评估模型与期望评估的模型都使用了m个训练样本。而仍然有1/3的数据样本没出现在训练集中，可以用于测试。 该方法一般用于样本数量较小，难以有效划分训练集/测试集时。 缺点：改变了初始数据集的分布，这会引入估计偏差。 性能度量性能度量是指衡量模型泛化能力的评价标准。 错误率与精度见上文 查准率、查全率与F1 真实情况 预测情况 正例 反例 正例 TP(真正例) FN(假反例) 反例 FP(假正例) TN(真反例) 则查准率 P与查全率R分别为： P = TP / (TP + FP) R = TP / (TP + FN) 即查准率为预测正例中真实也正例的比例。 查全率为真实情况为正例中预测也为正例的比例。 查准率和查全率是一对矛盾的度量。 P-R图中面积越小则性能越好。 平衡点（BEP）为 查准率 = 查全率时的取值。 F1 = (2 P R)/ (P + R) = (2 * TP) / (样本总数 + TP - TN) 更一般的形式Fβ： Fβ = [(1 + β2) P R] / [(β2 * P) + P] 实际上F1是基于查准率与查全率的调和平均（harmonic mean）： 1 / F1 = (1 / 2) * (1 / P + 1 / R) 同样，Fβ则是加权调和平均： 1 / Fβ = 1 / (1 + β2) * (1 / P + β2 / R) ROC与AUCROC全称为“受试者工作特征”（Receiver Operating Characteristic）曲线。 其纵轴为“真正例率”（True Positive Rate，简称TPR） 横轴为“假正例率”（False Positive Rate，简称FPR） 即： TPR = TP / (TP + FN) FPR = FP / (TN + FP) AUC(Area Under ROC Curve)即ROC曲线下的面积。 代价敏感错误率与代价曲线一般对于不同的类别，我们错误的预测会造成不同的后果。例如把患者诊断为健康人和把健康人预测为病人，显然前者的后果更加严重。基于此，我们给出以下表格来定义不同的样本之间错误预测的代价： 真实情况 预测情况 第0类 第1类 第0类 0 cost01 第1类 cost10 0 所谓代价敏感错误率即要最小化所有样本预测的cost均值最小化。即： 注：假定上表中的第0类为正例，第1类为反例，令D+与D-分别代表样例集D的正例子集和反例子集 在非均等代价下，ROC曲线不能直接反映出学习器的期望总和代价，而代价曲线（cost curve）可以达到该目的。 其横轴为正概率代价： 其中p是样例为正例的概率。 纵轴是取值为[0, 1]的归一化代价。 其中FPR为上面提到的假正例率， FNR = 1 - TPR是假反例率","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"西瓜书","slug":"西瓜书","permalink":"http://yoursite.com/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"},{"name":"模型评估与选择","slug":"模型评估与选择","permalink":"http://yoursite.com/tags/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/"}]},{"title":"聚类的几种算法简述","slug":"聚类的几种算法简述","date":"2021-08-11T15:40:33.000Z","updated":"2021-08-11T17:21:41.712Z","comments":true,"path":"2021/08/11/聚类的几种算法简述/","link":"","permalink":"http://yoursite.com/2021/08/11/%E8%81%9A%E7%B1%BB%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0/","excerpt":"","text":"聚类聚类是无监督学习中应用最广泛的算法。聚类会将数据集中的样本划分为若干个不同的子集，每个子集称为一个簇。 原型聚类原型聚类假设聚类结构能通过一组原型刻画。通常情况下，该类算法先对原型进行初始化，然后对原型进行迭代更新求解。 k均值算法（k-means）该算法的目的是最小化每个簇中每个样本到对应原型的距离。 但是直接求解的话会是一个NP难问题，较难求解，因此我们仍然采用迭代更新的贪心算法来求解可能的最近似解。值得注意的是，这样并不一定能求得最优解。 其算法大致思想如下： 初始化簇的数目K和一组原型向量（从样本中随机选择K个） 迭代每个样本和原型向量，为每个样本找到其距离最近的簇，并将其划为到对应的簇中。 重新计算每个簇对应的原型向量 检查新的原型向量和原来的原型向量是否相等，如果全部更新就停止迭代，即找到了最近似解。 python代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- coding: utf-8 -*-\"\"\"Created on Tue Aug 10 15:17:10 2021@author: mw530\"\"\"import numpy as npimport pandas as pdclass ProBasedClusterin: clusterNum = 3 data = None dataLen = 0 clusterVector = [] clusterSplit = [] def __init__(self, data, clusterNum = 3): self.clusterNum = clusterNum self.data = data self.dataLen = data.shape[0] randArray = self.uniqueRandInt(clusterNum, 0, self.data.shape[0]) for i in range(clusterNum): self.clusterVector.append(data[randArray[i]]) self.clusterSplit.append([]) def uniqueRandInt(self, num, low, high): randArray = [] currNum = 0 while currNum &lt; num: randInt = np.random.randint(low, high) if randInt not in randArray: randArray.append(randInt) currNum += 1 return randArray def eucDistance(self, x, y): return np.sqrt(np.sum((x - y)**2)) def train(self): vectorChangeNum = -1 cycle = 0 while vectorChangeNum != 0: cycle += 1 vectorChangeNum = 0 for i in range(self.clusterNum): self.clusterSplit[i] = [] # 将每个样本分到对应的簇 for i in range(self.dataLen): minDis = 9999999 clusterIndex = -1 for j in range(self.clusterNum): dis = self.eucDistance(self.data[i], self.clusterVector[j]) if(dis &lt; minDis): minDis = dis clusterIndex = j self.clusterSplit[clusterIndex].append(self.data[i]) # print(self.clusterSplit) print(\"##############################\") #计算每个簇的新原型向量 for i in range(self.clusterNum): vector = np.mean(self.clusterSplit[i], axis=0) if not (vector == self.clusterVector[i]).all(): vectorChangeNum += 1 self.clusterVector[i] = vector print(\"第\", cycle, \"次遍历\", \"有\", vectorChangeNum, \"个原型向量不同\") if vectorChangeNum == 0: print(\"找到最佳原型向量，共循环\", cycle, \"次\") return self.clusterSplit def loadData(name): path = './data/' + name file = open(path, 'r') csv = pd.read_csv(file) arr = np.array(csv) return arrdata = loadData('cetics_game.csv')# print(data[1:20, :])clustering = ProBasedClusterin(data)clusterSplit = clustering.train()# print(clusterSplit) 学习向量量化（Learning Vector Quantization）该算法仍然属于原型聚类，因此与K均值相似。也是试图使用一组原型向量来刻画聚类结构。但是该算法假设每个样本有一个标记，学习算法的过程会利用样本的这些监督信息来辅助聚类。 其算法大致思想如下: 初始化学习率 μ，原型向量的个数K，K个原型向量（从样本中随机选择） 从样本集随机选择一个样本x，迭代每个原型向量，找到距离x最近的原型向量p。 根据公式p = p ± μ * (x - p) 更新该原型向量。（如果x与p标记相同为＋，否则为-） 注意该算法的迭代一般就人为确定循环次数。 python代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# -*- coding: utf-8 -*-\"\"\"Created on Tue Aug 10 18:34:25 2021@author: mw530\"\"\"import numpy as npimport pandas as pdclass LearningVectorQuan: protoVecNum = 0 eTa = 0.5 data = None dataLen = 0 labels =None protoVector = [] protoLabels = [] cycleNum = 1000 def __init__(self, data, labels, protoVecNum = 3, eTa = 0.5, cycleNum = 1000): self.protoVecNum = protoVecNum self.eTa = eTa self.cycleNum = cycleNum self.data = data self.labels = labels self.dataLen = self.data.shape[0] randInt = self.uniqueRandInt(self.protoVecNum, 0, self.dataLen - 1) for i in randInt: self.protoVector.append(self.data[i]) self.protoLabels.append(self.labels[i]) def uniqueRandInt(self, num, low, high): randArray = [] currNum = 0 while currNum &lt; num: randInt = np.random.randint(low, high) if randInt not in randArray: randArray.append(randInt) currNum += 1 return randArray def eucDistance(self, x, y): return np.sqrt(np.sum((x - y)**2)) def train(self): for i in range(self.cycleNum): randIndex = np.random.randint(0, self.dataLen - 1) randData = self.data[randIndex] randLabel = self.labels[randIndex][0] minIndex = -1 minDis = 9999999 for j in range(self.protoVecNum): dis = self.eucDistance(randData, self.protoVector[j]) if dis &lt; minDis: minDis = dis minIndex = j if randLabel == self.labels[minIndex]: self.protoVector[minIndex] = self.protoVector[minIndex] + self.eTa * (randData - self.protoVector[minIndex]) else: self.protoVector[minIndex] = self.protoVector[minIndex] - self.eTa * (randData - self.protoVector[minIndex]) return self.protoVector def loadData(name): path = './data/' + name file = open(path, 'r') csv = pd.read_csv(file) arr = np.array(csv) return arr[:, :-1], arr[:, -1:]data, labels = loadData('cetics_game.csv')# print(data, labels)clustering = LearningVectorQuan(data, labels)clusterSplit = clustering.train()print(np.array(clusterSplit).shape) 高斯混合聚类（高斯分布即正态分布）与以上两种算法不同，该算法使用的概率模型来表达聚类原型。 密度聚类该算法亦称为“基于密度的聚类”，此类算法假设聚类结构能够通过样本分布的紧密程度确定。并基于可连接样本不断扩展聚类簇以获得最终的聚类结果。 DBSCAN是一种著名的密度聚类算法，它基于一组“邻域”参数（ε，MinPts）来刻画样本分布的紧密程度。给定数据集D，有一下几个概念需要了解。 ε-邻域：对于xi∈D，其ε-邻域包括样本集D中与xi距离不大于ε的所有样本。 核心对象：若xi的ε-邻域中至少包含MinPts个样本，则xi为一个核心对象。 密度直达：若xi位于xj的ε-邻域中，且xj是一个核心对象，则称xi由xj密度直达。 密度可达：对于xi和xj，若存在样本序列p1, p2, p3, … , pn，其中p1 = xi, pn = xj, 且pi+1由pi密度直达，则称xj由xi密度直达。 密度相连：对xi与xj，若存在xk使得xi与xj均由xk密度可达，则称xi与xj密度相连。 该算法的核心思想如下： 算法先根据给定的邻域参数（ε， MinPts）找出所有的核心对象 以任一核心对象为出发点，找出由其密度可达的样本生成聚类簇，直到所有核心对象均被访问过。 层次聚类层次聚类（hierarchical clustering）试图在不同层次上对数据集进行划分，从而形成树状的聚类结构。数据集的划分可以采用自底向上的聚类策略，也可以采用自顶而下的分拆策略。 AGNES是以这种采用自底向上聚类策略的层次聚类算法。 其算法思想如下： 它先将数据集中的每个样本看作一个初始聚类簇。 然后再算法运行的每一步中找出距离最近的两个聚类进行合并，该过程不断重复，直到达到预设的聚类簇个数。 注意：以上的代码都是自己手写的，可能会有不足。","categories":[{"name":"聚类","slug":"聚类","permalink":"http://yoursite.com/categories/%E8%81%9A%E7%B1%BB/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"聚类","slug":"聚类","permalink":"http://yoursite.com/tags/%E8%81%9A%E7%B1%BB/"}]},{"title":"机器学习1-决策树算法","slug":"机器学习1-决策树算法","date":"2021-07-13T08:03:13.000Z","updated":"2021-09-14T08:42:29.215Z","comments":true,"path":"2021/07/13/机器学习1-决策树算法/","link":"","permalink":"http://yoursite.com/2021/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法回忆总述首先决策树算法的一个核心思想是通过一些方法将数据递归的划分为一个树状结构。其算法流程大致如下： 读取数据 注意CSV是文本格式，读取时是r；Excel是二进制文件，读取时是rb 根据标准计算最优属性，一般选择香农熵，其流程如下： 递归每一个属性，计算该属性的总熵值，总熵值为每个值得熵得和 先统计该属性得所有不重复值的数据条数 根据公式：ent = (-item/count)*np.log2(item/count) 计算每个属性值的熵值 ， 其中item为该属性值的数据数量、count为该属性的数据数量 将上面的每个属性值的ent相加，就得到该属性的总熵值 根据最优属性划分数据 根据划分得到的数据构建决策树，接下来有几种可能： 如果最优属性的label唯一，那么则该属性的值即为该树节点的值 如果不是唯一的，则根据属性值来将其划分为对应的数据字典（例如： {属性值1：[数据1-1， 数据1-2，…]}），然后遍历该字典： 如果该属性值的list的label唯一，则该属性的该值几位一个节点，由此构造节点。 否则对该属性递归该过程来构建树。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"决策树算法","slug":"决策树算法","permalink":"http://yoursite.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/"}]},{"title":"Node学习5-进程机制","slug":"Node学习5-进程机制","date":"2021-05-03T03:06:49.000Z","updated":"2021-05-23T05:56:09.775Z","comments":true,"path":"2021/05/03/Node学习5-进程机制/","link":"","permalink":"http://yoursite.com/2021/05/03/Node%E5%AD%A6%E4%B9%A05-%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6/","excerpt":"","text":"服务端模型得变迁Web服务器的架构已经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。 石器时代：同步最早的服务器，其执行模型是同步的，它的服务模式是一次只为一次请求服务，所有的请求都得按次序等待服务。这意味着除了当前的请求被处理外，其余请求都处于等待被处理的状态。其处理性能相当低下，假设每次响应服务耗时为N秒，则这类服务的QPS为1/N。 这种架构如今已基本被淘汰，只在一些无并发需要的应用中存在。 青铜时代：复制进程为了解决同步架构的并发问题，衍生出了复制多个进程以提高并发量的模式。每个进程为一个连接服务。但这种模式的消耗非常高，因为新建进程的代价是很高的，包括内存上下文的分配。因为再复制进程的同时也会复制进程内部的状态，也就是说同样的状态会在内存中存储多份，造成来个浪费。 假设通过进程复制和预复制的方式搭建的服务器有资源的限制，且进程的上限为M，那么这一类服务的QPS为M/N。 白银时代：多线程为了解决创建进程代价过大的问题，多线程的概念被引入，线程相当于一个简化版的进程，其没有自己的系统资源，所以在创建，废除时，其代价都比进程小的多。但是值得注意的是，不同进程的线程切换会造成上下文的切换，当过多的不同进程的线程进行切换时，消耗仍然很大。虽然其有缺点，但线程仍然是当代操作系统的重要组成部分。 如果忽略多线程上下问切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为N*L/N。 黄金时代：事件驱动多线程的服务模型服役了很长一段时间，Apache就是采用多线程/多进程模式来实现的，当并发量增长到上万时，内存耗用的问题就会暴露出来，即为著名的C10k问题。 为了解决高并发的问题，基于事件驱动的服务模型出现了，像Node和Nginx均是基于事件驱动的方式实现的：即一个线程为所有请求服务，请求到来时触发事件，这与每个请求由一个线程服务的模式完全不同。采用单线程避免了不必要的内存开销和上下文切换问题。 但是这种基于单线程的模式虽然解决了上面的问题，但是其无法高效的利用多核CPU的问题，则为这个模式的问题之所在。所以当我们解决掉这个问题时，那么性能的提升是相当可观的。 多进程架构面对单线程对多核利用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程的各自利用一个CPU，以此实现多核CPU的利用。基于Node提供的child_process模块可以实现多进程的调用。我们创建一个简单的服务端代码： 123456789let http = require('http')const port = 5000 + Math.round(1 + Math.random() * 1000)http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-type': 'text/plain'&#125;) res.end(\"Hello World\\n\")&#125;).listen(port, '127.0.0.1')console.log('server on 127.0.0.1:'+port) 通过node work.js启动它，它会见监听5000到6000之间的一个随机端口。将下面的代码保存为master.js，并通过node master.js启动它： 123456let fork = require('child_process').forklet cpus = require('os').cpus()for(let i = 0; i &lt; cpus.length; i++)&#123; fork('./work.js')&#125; 这段代码会根据当前机器上的CPU的数量复制出当前Node进程数。 会得到如下的结果： 1234server on 127.0.0.1:5123server on 127.0.0.1:5481server on 127.0.0.1:5065server on 127.0.0.1:5516 如下图即为典型的Master-Work模式，又称为主从模式，其广泛用于并行处理业务的模式，具备较好的可伸缩性和稳定性。图中的进程分为两类：主进程和工作进程。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它趋向于稳定。工作进程负责具体的业务处理。 注意通过fork()复制的进程都是一个独立的进程，每个进程都是一个独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10MB的内存。 child_process模块创建子进程异步创建子进程child_process.exec(command[, options][, callback])该方法可以直接异步执行命令（不是JavaScript代码，而是shell命令），options参数可以控制各种条件，比如工作目录，编码等；第三个参数用于设置失败的回调。 该命令衍生shell，然后在shell中执行command，并缓冲任何产生的输出。穿给command字符串会被shell直接处理，特殊字符串（因shell而异）需要被相应地处理： 12345exec('\"/目录/空 格/文件.sh\" 参数1 参数2');// 使用双引号，使路径中的空格不会被解释为多个参数的分隔符。exec('echo \"\\\\$HOME 变量为 $HOME\"');// $HOME 变量在第一个实例中会被转义，但是第二个则不会。 所以对于用户的输入，一定要经过无害化处理才能使用这个函数，因为其可以触发任何命令，很危险! 示例123456789101112const process = require('child_process')let cmd = 'console.log(123456)'process.exec('echo 132',&#123;encoding: 'GBK'&#125;, (error, stdout, stderr) =&gt; &#123; if (error) &#123; console.error(`执行的错误: $&#123;error&#125;`); return; &#125; console.log(`stdout: $&#123;stdout&#125;`); console.error(`stderr: $&#123;stderr&#125;`); &#125;) 值得注意的是：标准输出是在回调的stdout参数中，而不会直接打印在当前控制台中。 源码我们简单看一下其源码： 123456function exec(command, options, callback) &#123; const opts = normalizeExecArgs(command, options, callback); return module.exports.execFile(opts.file, opts.options, opts.callback);&#125; 可以看到其首先是调用了normalizeExecArgs()这个函数，我们再看一下内部： 12345678910111213141516function normalizeExecArgs(command, options, callback) &#123; if (typeof options === 'function') &#123; callback = options; options = undefined; &#125; // Make a shallow copy so we don't clobber the user's options object. options = &#123; ...options &#125;; options.shell = typeof options.shell === 'string' ? options.shell : true; return &#123; file: command, options: options, callback: callback &#125;;&#125; 可以可能首先是做了一个判断，即忽略options功能的实现。 然后是对options做了浅拷贝防止修改用户的options对象。因为后面需要对options.shell进行处理，即是否使用默认的shell.exe。详见下面： shell 的要求Shell 需要能理解 -c 开关。 如果 shell 是 &#39;cmd.exe&#39;，则它需要能理解 /d /s /c 开关，且命令行解析需要能兼容。 默认的 Windows shell尽管微软指定在根环境中 %COMSPEC% 必须包含 &#39;cmd.exe&#39; 的路径，但子进程并不总是遵循相同的要求。 因此，在可以衍生 shell 的 child_process 函数中，如果 process.env.ComSpec 不可以，则使用 &#39;cmd.exe&#39; 作为后备。 然后直接返回了一个对象，并且将command重命名为file（这里我没有看到哪里将command转换为file，但是exeFile确实只接受File，疑惑） 跳出这个函数，看exe()函数，可以发现其仍然是调用了exeFile()函数，我们下面再来看这个函数的源码。 child_process.execFile(file[, args][, options][, callback])该函数预child_process.exe()相似，都是执行命令。但仍然有些许不同。 该方法第一个参数接受一个命令文件（名字或路径），而不是命令的字符串。 child_process.execFile() 函数类似于 child_process.exec()，但默认情况下不会衍生 shell。 指定的可执行文件 file 会被直接衍生作为新的进程，使其比 child_process.exec() 稍微更高效。 由于没有衍生 shell，因此不支持 I/O 重定向和文件通配等行为。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218function execFile(file /* , args, options, callback */) &#123; let args = []; let callback; let options; // Parse the optional positional parameters.解析参数 let pos = 1; if (pos &lt; arguments.length &amp;&amp; ArrayIsArray(arguments[pos])) &#123; args = arguments[pos++]; &#125; else if (pos &lt; arguments.length &amp;&amp; arguments[pos] == null) &#123; pos++; &#125; if (pos &lt; arguments.length &amp;&amp; typeof arguments[pos] === 'object') &#123; options = arguments[pos++]; &#125; else if (pos &lt; arguments.length &amp;&amp; arguments[pos] == null) &#123; pos++; &#125; if (pos &lt; arguments.length &amp;&amp; typeof arguments[pos] === 'function') &#123; callback = arguments[pos++]; &#125; if (!callback &amp;&amp; pos &lt; arguments.length &amp;&amp; arguments[pos] != null) &#123; throw new ERR_INVALID_ARG_VALUE('args', arguments[pos]); &#125; options = &#123; encoding: 'utf8', timeout: 0, maxBuffer: MAX_BUFFER, killSignal: 'SIGTERM', cwd: null, env: null, shell: false, ...options &#125;; // Validate the timeout, if present.验证参数 validateTimeout(options.timeout); // Validate maxBuffer, if present. validateMaxBuffer(options.maxBuffer); options.killSignal = sanitizeKillSignal(options.killSignal); //关键-产生子进程 const child = spawn(file, args, &#123; cwd: options.cwd, env: options.env, gid: options.gid, shell: options.shell, signal: options.signal, uid: options.uid, windowsHide: !!options.windowsHide, windowsVerbatimArguments: !!options.windowsVerbatimArguments &#125;); let encoding; const _stdout = []; const _stderr = []; if (options.encoding !== 'buffer' &amp;&amp; Buffer.isEncoding(options.encoding)) &#123; encoding = options.encoding; &#125; else &#123; encoding = null; &#125; let stdoutLen = 0; let stderrLen = 0; let killed = false; let exited = false; let timeoutId; let ex = null; let cmd = file; function exithandler(code, signal) &#123; if (exited) return; exited = true; if (timeoutId) &#123; clearTimeout(timeoutId); timeoutId = null; &#125; if (!callback) return; // merge chunks let stdout; let stderr; if (encoding || ( child.stdout &amp;&amp; child.stdout.readableEncoding )) &#123; stdout = ArrayPrototypeJoin(_stdout, ''); &#125; else &#123; stdout = Buffer.concat(_stdout); &#125; if (encoding || ( child.stderr &amp;&amp; child.stderr.readableEncoding )) &#123; stderr = ArrayPrototypeJoin(_stderr, ''); &#125; else &#123; stderr = Buffer.concat(_stderr); &#125; if (!ex &amp;&amp; code === 0 &amp;&amp; signal === null) &#123; callback(null, stdout, stderr); return; &#125; if (args.length !== 0) cmd += ` $&#123;ArrayPrototypeJoin(args, ' ')&#125;`; if (!ex) &#123; // eslint-disable-next-line no-restricted-syntax ex = new Error('Command failed: ' + cmd + '\\n' + stderr); ex.killed = child.killed || killed; ex.code = code &lt; 0 ? getSystemErrorName(code) : code; ex.signal = signal; &#125; ex.cmd = cmd; callback(ex, stdout, stderr); &#125; function errorhandler(e) &#123; ex = e; if (child.stdout) child.stdout.destroy(); if (child.stderr) child.stderr.destroy(); exithandler(); &#125; function kill() &#123; if (child.stdout) child.stdout.destroy(); if (child.stderr) child.stderr.destroy(); killed = true; try &#123; child.kill(options.killSignal); &#125; catch (e) &#123; ex = e; exithandler(); &#125; &#125; if (options.timeout &gt; 0) &#123; timeoutId = setTimeout(function delayedKill() &#123; kill(); timeoutId = null; &#125;, options.timeout); &#125; if (child.stdout) &#123; if (encoding) child.stdout.setEncoding(encoding); child.stdout.on('data', function onChildStdout(chunk) &#123; const encoding = child.stdout.readableEncoding; const length = encoding ? Buffer.byteLength(chunk, encoding) : chunk.length; const slice = encoding ? StringPrototypeSlice : (buf, ...args) =&gt; buf.slice(...args); stdoutLen += length; if (stdoutLen &gt; options.maxBuffer) &#123; const truncatedLen = options.maxBuffer - (stdoutLen - length); ArrayPrototypePush(_stdout, slice(chunk, 0, truncatedLen)); ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout'); kill(); &#125; else &#123; ArrayPrototypePush(_stdout, chunk); &#125; &#125;); &#125; if (child.stderr) &#123; if (encoding) child.stderr.setEncoding(encoding); child.stderr.on('data', function onChildStderr(chunk) &#123; const encoding = child.stderr.readableEncoding; const length = encoding ? Buffer.byteLength(chunk, encoding) : chunk.length; stderrLen += length; if (stderrLen &gt; options.maxBuffer) &#123; const truncatedLen = options.maxBuffer - (stderrLen - length); ArrayPrototypePush(_stderr, chunk.slice(0, truncatedLen)); ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr'); kill(); &#125; else &#123; _stderr.push(chunk); &#125; &#125;); &#125; child.addListener('close', exithandler); child.addListener('error', errorhandler); return child;&#125; 这个函数相对还是比较长，有217行。但是结构相当清晰： L 2-4：定义参数变量 L 7-26：解析参数（由于定义了可选参数，所以需要这样解析） L 28-46：定义options并验证参数合法性 L 48-57（关键）：调用spawn()函数产生子进程 Rest：剩下的代码都是为child添加close和error事件和其准备工作 Last：返回child。 在 Windows 上衍生 .bat 和 .cmd 文件child_process.exec() 和 child_process.execFile()之间区别的重要性可能因平台而异。 在 Unix 类型的操作系统（Unix、Linux、macOS）上，child_process.execFile()可以更高效，因为默认情况下不会衍生 shell。 但是在 Windows 上， .bat 和 .cmd 文件在没有终端的情况下不能自行执行，因此无法使用 child_process.execFile()启动。 当在 Windows 上运行时，要调用 .bat 和 .cmd 文件，可以使用设置了 shell 选项的 child_process.spawn()、或 child_process.exec()、或衍生 cmd.exe 并将 .bat 或 .cmd 文件作为参数传入（也就是 shell 选项和 child_process.exec()所做的）。 在任何情况下，如果脚本的文件名包含空格，则需要加上引号。 child_process.spawn(command[, args][, options])可以看到，最后创建进程的工作，都是由这个方法实现的，但是其与exec()有较大的不同，否则也不会设计两个API，一直存在这么久。 spawn()与exec()的不同： exec()的command是包含参数的，而spawn命令的参数是作为函数的第二个参数传入的。 exec()是将处理函数作为回调传入内部，而spawn实现了emitter，可以直接在外部监听事件。还可以准确的监听close等事件，exec()则只能统一监听error事件。 示例123456789101112131415const &#123; spawn &#125; = require('child_process');const ls = spawn('ls', ['-lh', '/usr']);//需要显式的监听ls.stdout.on('data', (data) =&gt; &#123; console.log(`stdout: $&#123;data&#125;`);&#125;);ls.stderr.on('data', (data) =&gt; &#123; console.error(`stderr: $&#123;data&#125;`);&#125;);ls.on('close', (code) =&gt; &#123; console.log(`子进程退出，退出码 $&#123;code&#125;`);&#125;); 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function spawn(file, args, options) &#123; //解析参数 options = normalizeSpawnArguments(file, args, options); //验证timeout validateTimeout(options.timeout); //验证signal validateAbortSignal(options.signal, 'options.signal'); //验证并转换killSignal信号，这里嵌套太深而且不重要，就不再深究 const killSignal = sanitizeKillSignal(options.killSignal); //新建子进程，重要 const child = new ChildProcess(); //这里实际是记录log，而不是debug debug('spawn', options); //初始化子进程参数 child.spawn(options); //子进程超时的操作 if (options.timeout &gt; 0) &#123; let timeoutId = setTimeout(() =&gt; &#123; if (timeoutId) &#123; try &#123; child.kill(killSignal); &#125; catch (err) &#123; child.emit('error', err); &#125; timeoutId = null; &#125; &#125;, options.timeout); child.once('exit', () =&gt; &#123; if (timeoutId) &#123; clearTimeout(timeoutId); timeoutId = null; &#125; &#125;); &#125; //是否有killSignal参数，即终止进程的信号值，有的话添加abort事件 if (options.signal) &#123; const signal = options.signal; if (signal.aborted) &#123; process.nextTick(onAbortListener); &#125; else &#123; signal.addEventListener('abort', onAbortListener, &#123; once: true &#125;); child.once('exit', () =&gt; signal.removeEventListener('abort', onAbortListener)); &#125; function onAbortListener() &#123; abortChildProcess(child, killSignal); &#125; &#125; //返回子进程 return child;&#125; 这个函数中最重要的就是const child = new ChildProcess();这一部分，我们再看一下这个类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function ChildProcess() &#123; FunctionPrototypeCall(EventEmitter, this); this._closesNeeded = 1; this._closesGot = 0; this.connected = false; this.signalCode = null; this.exitCode = null; this.killed = false; this.spawnfile = null; //重要，新建进程 this._handle = new Process(); this._handle[owner_symbol] = this; this._handle.onexit = (exitCode, signalCode) =&gt; &#123; if (signalCode) &#123; this.signalCode = signalCode; &#125; else &#123; this.exitCode = exitCode; &#125; if (this.stdin) &#123; this.stdin.destroy(); &#125; this._handle.close(); this._handle = null; if (exitCode &lt; 0) &#123; const syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn'; const err = errnoException(exitCode, syscall); if (this.spawnfile) err.path = this.spawnfile; err.spawnargs = ArrayPrototypeSlice(this.spawnargs, 1); this.emit('error', err); &#125; else &#123; this.emit('exit', this.exitCode, this.signalCode); &#125; // If any of the stdio streams have not been touched, // then pull all the data through so that it can get the // eof and emit a 'close' event. // Do it on nextTick so that the user has one last chance // to consume the output, if for example they only want to // start reading the data once the process exits. process.nextTick(flushStdio, this); maybeClose(this); &#125;;&#125;ObjectSetPrototypeOf(ChildProcess.prototype, EventEmitter.prototype);ObjectSetPrototypeOf(ChildProcess, EventEmitter);//...ChildProcess.prototype.spawn = function(options) &#123; //...&#125;//...ChildProcess.prototype.kill = function(sig) &#123; //...&#125;//...ChildProcess.prototype.ref = function() &#123; if (this._handle) this._handle.ref();&#125;;ChildProcess.prototype.unref = function() &#123; if (this._handle) this._handle.unref();&#125;;// 可以看到这实际上就是一个原生的JS类，其在构造函数中定义了很多内部变量，其中最重要的是this._handle = new Process();来真实的新建一个进程。而这个类则是从C++底层导出的，所以我们不再向下深入。 在定义完类之后，Node立即为其添加了event模块，用于用户对其进行操作。 其中spawn()也很重要，注意每层的对象都有spawn()函数，其用来得到最后的输出结果。 child_process.fork(modulePath[, args][, options])child_process.fork() 方法是 child_process.spawn()的特例，专门用于衍生新的 Node.js 进程。 与 child_process.spawn() 一样返回 ChildProcess对象。 返回的 ChildProcess会内置额外的通信通道，允许消息在父进程和子进程之间来回传递。 详见 subprocess.send()。 记住，衍生的 Node.js 子进程独立于父进程，但两者之间建立的 IPC 通信通道除外。 每个进程都有自己的内存，带有自己的 V8 实例。 由于需要额外的资源分配，因此不建议衍生大量的 Node.js 子进程。 默认情况下， child_process.fork() 会使用父进程的 process.execPath来衍生新的 Node.js 实例。 该方法应该比较常用的，因为我们在做web的负载均衡或者多核CPU利用时，一般其他的server也是Node，所以通过该API可以直接生成新的进程。 示例1234567//前面的主从的例子let fork = require('child_process').forklet cpus = require('os').cpus()for(let i = 0; i &lt; cpus.length; i++)&#123; fork('./work.js')&#125; 同步创建子进程下面的函数会同步创建，执行进程，并且将会阻塞 Node.js 事件循环、暂停任何其他代码的执行，直到衍生的进程退出。阻塞这些调用对于简化通用的脚本任务和简化应用程序配置在启动时的加载或处理都非常有用。 child_process.execFileSync(file[, args][, options])child_process.execFileSync() 方法通常与 child_process.execFile() 相同，但该方法在子进程完全关闭之前不会返回。 当遇到超时并且已发送 killSignal 时，该方法也需等到进程完全退出后才返回。 如果子进程拦截并处理了 SIGTERM 信号但未退出，则父进程仍将等待子进程退出。 这个函数也是和execFile()的调用栈差不多。 exeFilr()-&gt;spawnSync（lib）-&gt;spawnSync()(internal)-&gt;spawn_sync.spawn(options)(C++内建模块) child_process.execSync(command[, options])child_process.execSync() 方法通常与 child_process.exec() 相同，但该方法在子进程完全关闭之前不会返回。 当遇到超时并且已发送 killSignal 时，该方法也需等到进程完全退出后才返回。 如果子进程拦截并处理了 SIGTERM 信号但未退出，则父进程会等待直到子进程退出。 源码12345678910111213141516function execSync(command, options) &#123; const opts = normalizeExecArgs(command, options, null); const inheritStderr = !opts.options.stdio; const ret = spawnSync(opts.file, opts.options); if (inheritStderr &amp;&amp; ret.stderr) process.stderr.write(ret.stderr); const err = checkExecSyncError(ret, opts.args, command); if (err) throw err; return ret.stdout;&#125; 可以看到这个函数就没有调用exeFileSync()，而是直接调用的spawnSync()函数。下面我们再看spawnSync() child_process.spawnSync(command[, args][, options])child_process.spawnSync() 方法通常与 child_process.spawn() 相同，但在子进程完全关闭之前该函数不会返回。 当遇到超时并且已发送 killSignal 时，该方法也需等到进程完全退出后才返回。 如果进程拦截并处理了 SIGTERM 信号但未退出，则父进程会等待直到子进程退出。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function spawnSync(file, args, options) &#123; options = &#123; maxBuffer: MAX_BUFFER, ...normalizeSpawnArguments(file, args, options) &#125;; debug('spawnSync', options); // Validate the timeout, if present. validateTimeout(options.timeout); // Validate maxBuffer, if present. validateMaxBuffer(options.maxBuffer); // Validate and translate the kill signal, if present. options.killSignal = sanitizeKillSignal(options.killSignal); options.stdio = getValidStdio(options.stdio || 'pipe', true).stdio; if (options.input) &#123; const stdin = options.stdio[0] = &#123; ...options.stdio[0] &#125;; stdin.input = options.input; &#125; // We may want to pass data in on any given fd, ensure it is a valid buffer for (let i = 0; i &lt; options.stdio.length; i++) &#123; const input = options.stdio[i] &amp;&amp; options.stdio[i].input; if (input != null) &#123; const pipe = options.stdio[i] = &#123; ...options.stdio[i] &#125;; if (isArrayBufferView(input)) &#123; pipe.input = input; &#125; else if (typeof input === 'string') &#123; pipe.input = Buffer.from(input, options.encoding); &#125; else &#123; throw new ERR_INVALID_ARG_TYPE(`options.stdio[$&#123;i&#125;]`, ['Buffer', 'TypedArray', 'DataView', 'string'], input); &#125; &#125; &#125; //主要，调用internal的spawnSync的函数 return child_process.spawnSync(options);&#125; 上面都是对参数进行验证和处理。最后只是调用了child_process.spawnSync(options)函数，我们再看一下这个函数。 12345678910111213141516171819202122function spawnSync(options) &#123; const result = spawn_sync.spawn(options); if (result.output &amp;&amp; options.encoding &amp;&amp; options.encoding !== 'buffer') &#123; for (let i = 0; i &lt; result.output.length; i++) &#123; if (!result.output[i]) continue; result.output[i] = result.output[i].toString(options.encoding); &#125; &#125; result.stdout = result.output &amp;&amp; result.output[1]; result.stderr = result.output &amp;&amp; result.output[2]; if (result.error) &#123; result.error = errnoException(result.error, 'spawnSync ' + options.file); result.error.path = options.file; result.error.spawnargs = ArrayPrototypeSlice(options.args, 1); &#125; return result;&#125; 这里最重要的就是第一条语句，即调用了spawn_sync.spawn(options)函数，这个函数也是从C++导入的内部模块。 所以对于Process模块，JavaScript层面只做了参数的验证，处理，以及返回数据。（因为JavaScript的能力就止于此了），其内部具体的逻辑，都是在C++平台来处理的。而这一部分，是由libuv进行处理的，因为涉及到跨平台处理不同。 总结 名称 执行类型 同步/异步 事件处理方式 exec 命令 异步 callback回调/event监听 execFile 命令（文件） 异步 callback回调/event监听 Fork JavaScript模块 异步 event监听 execSync 命令 同步 / execFileSync 命令（文件） 同步 / 进程间通信再Master-Work中模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。对于child_process模块，创建好了子进程，然后与父子进程间通信是十分容易的。 由于Node中的进程模块实现了EventEmitter，所以可以直接使用事件监听的方式来进行通信。 用法对应的子进程有5个事件，其中包括通信的message事件。 事件 触发时间 返回 close 进程关闭 1. code 子进程自行退出时的退出码。2. signal子进程被终止的信号。 disconnect 调用父进程中的 subprocess.disconnect()或子进程中的 process.disconnect() 后会触发 &#39;disconnect&#39; 事件。 / error 1. 无法衍生进程； 2. 无法杀死进程； 3. 向子进程发送消息失败。 err 错误 exit 当子进程结束后时会触发 &#39;exit&#39; 事件。 1. code子进程自行退出时的退出码。 2. signal 子进程被终止的信号。 message 当子进程使用 process.send()发送消息时会触发 &#39;message&#39; 事件。 1. message 一个已解析的 JSON 对象或原始值。 2. sendHandle一个 net.Socket或 net.Server 对象，或 undefined。 通过Process.end()方法，可以向子进程发送消息，而主进程可以通过message事件监听子进程的消息。 而子进程可以通过内置对象process的send()方法，和同样的事件监听来与父进程通信。 示例1234567891011121314151617181920//master.jsconst cp = require('child_process')const n = cp.fork(__dirname + '/sub.js')n.on('message', (m) =&gt; &#123; console.log(`进程消息：$&#123;m&#125;`)&#125;)setTimeout(() =&gt; &#123; work.send('父进程发送消息来了')&#125;, 3000)//work.jsprocess.on('message', (m) =&gt; &#123; console.log(`进程消息：$&#123;m&#125;`)&#125;)setTimeout(() =&gt; &#123; process.send('子进程发送消息来了')&#125;, 2000) 原理为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息。 IPC的全程时Inter-Process-Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间的通信技术有很多，如管道通信、共享存储、消息传递、socket等。Node中实现IPC通信的是管道（pipe）技术。但这个管道与传统的管道有一些不同，在Node中管道是一个抽象层的称呼，具体实现细节由libuv提供，在Windows下由命名管道（named pipe）实现，*nix下则采用Unix Domain Socket。表现在应用层上的进程通信只有简单的message事件和send()方法，接口十分简洁。 句柄传递一般来说，NodeJS用于后端服务器的开发，所以多进程一般用于调动多核CPU来提高并发，那么不同的进程能否监听同一个端口来实现提高并发的目的呢？ 1234567891011121314151617181920212223//work.jsconst http = require('http')http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-Type': 'text/pain'&#125;) res.end('Hello World')&#125;).listen(8888, '127.0.0.1')//master.jsconst fork = requrie('child_process').forkfor(let i = 0; i &lt; 2; i++)&#123; for('./work.js')&#125;得到的错误如下：​```bashevents.js:187 throw er; // Unhandled 'error' event ^Error: listen EADDRINUSE: address already in use 127.0.0.1:8888 很明显，不同的进程启动同一个端口的server，肯定会引起端口占用的问题。 最开始为了解决这个问题，我们的想法是代理。即主进程对外接受所有的网络请求，再将这些请求分别代理到不同端口的进程上。 通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。但是由于进程每接受到一个连接，将会用掉一个我呢见描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程地过程就会用掉两个文件描述符。操作系统地文件描述符是有限的，代理方案浪费掉一倍地文件描述符地做法影响了系统地扩展能力。 为了解决上述问题，Node在V0.5.9加入了进程间发送句柄地功能。sned()方法除了能通过IPC发送数据外，还能够发送句柄，第二个可选参数即为句柄。 句柄即一种用来标识资源地引用，它地内部包含了指向对象地文件描述符。比如句柄可以来吧标识一个socket对象，一个UDP套接字，一个管道等。因此，我们可以通过发送句柄来达到更高地多核利用效率。下面是一个例子（传递一个HTTP句柄）： 123456789101112131415161718192021222324252627282930313233343536373839//master.jsconst &#123; fork &#125; = require('child_process');const net = require('net');const os = require('os');const workers = [];for (let i = 0, len = os.cpus().length; i &lt; len; i++) &#123; const worker = fork('./work.js'); workers.push(worker); console.log('创建新进程：'+worker.pid)&#125;const server = net.createServer();server.listen(9527, () =&gt; &#123; workers.forEach(worker =&gt; &#123; worker.send('SERVER', server); &#125;); //关闭主服务器 server.close();&#125;);//work.jsconst http = require('http');// 创建每个协助进程的 http 服务器，不监听任何端口号const httpServer = http.createServer((req, res) =&gt; &#123; res.end(`Hello world by $&#123;process.pid&#125;\\n`);&#125;);process.on('message', (msg, tcpServer) =&gt; &#123; // 如果是 master 传递来的 tcp server if (msg === 'SERVER') &#123; // 新连接建立的时候触发 tcpServer.on('connection', socket =&gt; &#123; // 把 tcp server 的连接转给 http server 处理 httpServer.emit('connection', socket); &#125;); &#125;&#125;); 可以看到，我们在主进程发送完句柄之后，即关闭监听，也就是说，将所有的请求处理都交给子进程，这样可以做到权责分明。结构图如下： 同端口监听的原理句柄的发送与还原目前子进程对象的send()方法可以发送的句柄类型包括如下几种： net.Socket：TCP套接字。 net.Server：TCP服务器，任意建立在TCP服务上的应用层服务都可以进行传递。 net.Native：C++层面的TCP套接字或IPC管道。 dgram.Socket：UDP套接字。 dgram.Native：C++层面的UDP套接字。 send()方法在将消息发送到IPC管道之前，会将消息组装称为两个对象，一个参数是handle，另一个是message。 我们简单看一下其源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//暴露用于调用的API，主要用来解析参数，后面调用_send()来进行发送target.send = function(message, handle, options, callback) &#123; if (typeof handle === 'function') &#123; callback = handle; handle = undefined; options = undefined; &#125; else if (typeof options === 'function') &#123; callback = options; options = undefined; &#125; else if (options !== undefined) &#123; validateObject(options, 'options'); &#125; options = &#123; swallowErrors: false, ...options &#125;; if (this.connected) &#123; return this._send(message, handle, options, callback); &#125; const ex = new ERR_IPC_CHANNEL_CLOSED(); if (typeof callback === 'function') &#123; process.nextTick(callback, ex); &#125; else &#123; process.nextTick(() =&gt; this.emit('error', ex)); &#125; return false; &#125;;//实际调用的API target._send = function(message, handle, options, callback) &#123; assert(this.connected || this.channel); //消息为空 if (message === undefined) throw new ERR_MISSING_ARGS('message'); // Non-serializable messages should not reach the remote // end point; as any failure in the stringification there // will result in error message that is weakly consumable. // So perform a final check on message prior to sending. if (typeof message !== 'string' &amp;&amp; typeof message !== 'object' &amp;&amp; typeof message !== 'number' &amp;&amp; typeof message !== 'boolean') &#123; throw new ERR_INVALID_ARG_TYPE( 'message', ['string', 'object', 'number', 'boolean'], message); &#125; // Support legacy function signature if (typeof options === 'boolean') &#123; options = &#123; swallowErrors: options &#125;; &#125; let obj; // Package messages with a handle object //注意：这里处理含有handle参数的情况 if (handle) &#123; // This message will be handled by an internalMessage event handler //新的message将会含有一个type属性用来标识handle的类型 message = &#123; cmd: 'NODE_HANDLE', type: null, msg: message &#125;; //判断handle种类 if (handle instanceof net.Socket) &#123; message.type = 'net.Socket'; &#125; else if (handle instanceof net.Server) &#123; message.type = 'net.Server'; &#125; else if (handle instanceof TCP || handle instanceof Pipe) &#123; message.type = 'net.Native'; &#125; else if (handle instanceof dgram.Socket) &#123; message.type = 'dgram.Socket'; &#125; else if (handle instanceof UDP) &#123; message.type = 'dgram.Native'; &#125; else &#123; throw new ERR_INVALID_HANDLE_TYPE(); &#125; // Queue-up message and handle if we haven't received ACK yet. if (this._handleQueue) &#123; ArrayPrototypePush(this._handleQueue, &#123; callback: callback, handle: handle, options: options, message: message.msg, &#125;); return this._handleQueue.length === 1; &#125; obj = handleConversion[message.type]; // convert TCP object to native handle object handle = ReflectApply(handleConversion[message.type].send, target, [message, handle, options]); // If handle was sent twice, or it is impossible to get native handle // out of it - just send a text without the handle. if (!handle) message = message.msg; // Update simultaneous accepts on Windows if (obj.simultaneousAccepts &amp;&amp; process.platform === 'win32') &#123; handle.setSimultaneousAccepts(true); &#125; &#125; else if (this._handleQueue &amp;&amp; !(message &amp;&amp; (message.cmd === 'NODE_HANDLE_ACK' || message.cmd === 'NODE_HANDLE_NACK'))) &#123; // Queue request anyway to avoid out-of-order messages. ArrayPrototypePush(this._handleQueue, &#123; callback: callback, handle: null, options: options, message: message, &#125;); return this._handleQueue.length === 1; &#125; 可以看到这里在接收到参数之后，会构建一个新的message对象，其中含有handle的类型。然后将其推入_handleQueue中，后面由Node进行发送。 实际上发送到IPC管道中的是该句柄的文件描述符，文件描述符实际上是一个整数值。这个message对象在写入到IPC管道时会通过JSON.stringify()进行序列化。所以最终发送到IPC管道中的信息都是字符串。send()能发送消息和句柄不代表它能够发送任意对象。 连接了IPC管道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才出发message事件将消息作为消息体传递给应用层。在这个过程中，消息对象还要被过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件interalMessage。如果message.cmd值为NODE_HANDLE，它将取出message.type值和得到的为文件描述符一起还原出一个对应的对象。这个过程如图。 端口的共同监听在了解句柄传递背后的原理之后，我们继续探索为何发送句柄后，多个进程可以监听到同一个端口。其原因就在于：我们启动独立的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。 Node底层对每个端口监听都设置了SO_REUSEADDR选项，这个选项的含义是不同的进程可以就相同的网卡和端口进行监听，这个服务器套接字可以被不同的进程复用。 但是由于独立启动的进程互相之间不知道文件描述符，所以监听相同的端口时就会失败。但对于send()发送的句柄还原出来的服务而言，他们的文件描述符时相同的，所以可以监听到相同的端口不会引发异常。 多个应用监听同一个端口时，文件描述符同一时间智能被某一个进程所用。也就是说一个连接只能由一个进程处理，这些进程服务是抢占式的。 集群稳定之路进程事件在进程除了message事件外，Node还定义了以下事件： error：当子进程无法被创建或无法被杀死或无法发送消息时会触发该事件。 exit：子进程退出时触发该事件，如果是正常退出，整个事件的第一个参数为推出码，否则为null。如果是通过kill()方法杀死的，会得到第二个参数，它标识杀死进程时的信号。 close：在子进程的标准输入输出流终止时触发该事件，参数与exit相同。 disconnect：在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。 自动重启有了父子进程之间的相关事件之后，就可以在这些关系之间创建出需要的机制。至少我们嫩巩固通过子进程的exit事件来获知其退出的消息。同时利用这个事件，当一个子进程退出时，可以重新启动一个进程来继续服务。 1234567891011121314151617181920212223242526272829let fork = require('child_process').forklet cpus = require('os').cpus()let server = require('http').createServer()server.listen(1337)let works = &#123;&#125;let createWork = function()&#123; let worker = fork(__dirname + '/worker.js') worker.on('exit', function()&#123; console.log('work' + worker.pid + 'exited.') delete workers[worker.pid] createWork() &#125;) //句柄转发 worker.send('server', server) workers[worker.pid] = worker console.log('Create worker. pid:'+worker.pid) for(let i = 0; i &lt; cpus.length; i++)&#123; createServer() &#125; process.on('exit', function()&#123; for(let pid in workers)&#123; workers[pid].kill() &#125; &#125;)&#125; 结果如下： 12345678910111213PS D:\\Test\\Node&gt; node reStart.jsCreate worker. pid:11436Create worker. pid:14868Create worker. pid:16240Create worker. pid:11044//杀死11436C:\\Users\\Administrator&gt;taskkill -F /pid 11436成功: 已终止 PID 为 11436 的进程。//自动新增进程work11436exited.Create worker. pid:15608 负载均衡多个进程的同时服务一个工作时，必须要保证每个进程都得到适量的工作，这种保证多个单元工作量公平的策略叫做负载均衡。 Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一顿工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。 这种机制一般来说是公平的，但是需要明白的是，一个进程的繁忙分为CPU繁忙和I/O繁忙两个部分构成。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够能够抢到较多的进程，形成负载不均衡的情况。 在此Node在v0.11中提供了一种的新的策略使得负载均衡更加合理，即轮转调度算法。轮转调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) % n 个进程来发送连接。在cluster模块中启用它。 Cluster模块前面介绍的child_process模块，如果完全使用该模块来完成一个集群，那么还是有一定的难度，所以Node提供了cluster模块用于更方便的实现集群。 工作原理工作进程由 child_process.fork() 方法创建，因此它们可以使用 IPC 和父进程通信，从而使各进程交替处理连接服务。 cluster 模块支持两种分发连接的方法。 第一种方法（也是除 Windows 外所有平台的默认方法）是循环法，由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程，在分发中使用了一些内置技巧防止工作进程任务过载。 第二种方法是，主进程创建监听 socket 后发送给感兴趣的工作进程，由工作进程负责直接接收连接。 理论上第二种方法应该是效率最佳的。 但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。 可能会出现八个进程中有两个分担了 70% 的负载。 因为 server.listen() 将大部分工作交给主进程完成，因此导致普通 Node.js 进程与 cluster 工作进程差异的情况有三种： server.listen({fd: 7}) 因为消息会被传给主进程，所以父进程中的文件描述符 7 将会被监听并将句柄传给工作进程，而不是监听文件描述符 7 指向的工作进程。 server.listen(handle) 显式地监听句柄，会导致工作进程直接使用该句柄，而不是和主进程通信。 server.listen(0) 正常情况下，这种调用会导致 server 在随机端口上监听。 但在 cluster 模式中，所有工作进程每次调用 listen(0) 时会收到相同的“随机”端口。 实质上，这种端口只在第一次分配时随机，之后就变得可预料。 如果要使用独立端口的话，应该根据工作进程的 ID 来生成端口号。 Node.js 不支持路由逻辑。 因此在设计应用时，不应该过分依赖内存数据对象，例如 session 和登陆等。 由于各工作进程是独立的进程，它们可以根据需要随时关闭或重新生成，而不影响其他进程的正常运行。 只要有存活的工作进程，服务器就可以继续处理连接。 如果没有存活的工作进程，现有连接会丢失，新的连接也会被拒绝。 Node.js 不会自动管理工作进程的数量，而应该由具体的应用根据实际需要来管理进程池。 虽然 cluster 模块主要用于网络相关的情况，但同样可以用于其他需要工作进程的情况。 使用将上面的代码改写为cluster的方式： 这里的setupMaster方法： setupMaster 用于修改默认的 ‘fork’ 行为。 一旦调用，将会按照 cluster.settings 进行设置。 所有的设置只对后来的 .fork() 调用有效，对之前的工作进程无影响。 唯一无法通过 .setupMaster() 设置的属性是传给 .fork() 的 env 属性。 其接受的参数为cluster.settings对象： execArgv &lt;string[]&gt; 传给 Node.js 可执行文件的字符串参数列表。默认值: process.execArgv。 exec 工作进程的文件路径。默认值: process.argv[1]。 args &lt;string[]&gt; 传给工作进程的字符串参数。默认值: process.argv.slice(2)。 cwd 工作进程的当前工作目录。默认值: undefined（从父进程继承）。 serialization 指定用于在进程之间发送消息的序列化类型。可能的值为 ‘json’ 和 ‘advanced’。有关更多详细信息，请参见child_process 的高级序列化。默认值: false。 silent 是否需要发送输出到父进程的 stdio。默认值: false。 stdio 配置衍生的进程的 stdio。 由于 cluster 模块运行依赖于 IPC，这个配置必须包含 ‘ipc’。如果提供了这个选项，则覆盖 silent。 uid 设置进程的用户标识符。参见 setuid(2)。 gid 设置进程的群组标识符。参见 setgid(2)。inspectPort | 设置工作进程的检查端口。这可以是一个数字、或不带参数并返回数字的函数。默认情况下，每个工作进程都有自己的端口，从主进程的 process.debugPort 开始递增。windowsHide 隐藏衍生的进程的控制台窗口（通常在 Windows 系统上会创建）。默认值: false。 12345678910let cluster = require('cluster')cluster.setupMaster(&#123; exec: 'worker.js'&#125;)let cpus = require('os').cpus()for(let i = 0; i &lt; cpus.length; i++)&#123; cluster.fork()&#125; 事件同样，cluster模块提供了一些事件监听： disconnect事件 exit事件 fork事件 listening事件 message事件 online事件：当衍生一个新的工作进程后，工作进程应当响应一个上线消息。 setup事件：每当 .setupMaster() 被调用时触发。 引用本文大部分参考《深入浅出nodejs》以及Node官网","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"进程机制","slug":"进程机制","permalink":"http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6/"}]},{"title":"VSCODE-插件开发1","slug":"VSCODE-插件开发1","date":"2021-04-28T12:23:38.000Z","updated":"2021-04-29T17:23:12.000Z","comments":true,"path":"2021/04/28/VSCODE-插件开发1/","link":"","permalink":"http://yoursite.com/2021/04/28/VSCODE-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911/","excerpt":"","text":"createTextEditorDecorationType(options: DecorationRenderOptions]): TextEditorDecorationType：创建一个新的装饰器。 Parameter Description options: DecorationRenderOptions 装饰类型渲染的选项 Returns Description TextEditorDecorationType 一个新的装饰器实体","categories":[{"name":"VS CODE插件","slug":"VS-CODE插件","permalink":"http://yoursite.com/categories/VS-CODE%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"VS CODE插件","slug":"VS-CODE插件","permalink":"http://yoursite.com/tags/VS-CODE%E6%8F%92%E4%BB%B6/"}]},{"title":"Node学习4-Buffer","slug":"Node学习4-Buffer","date":"2021-04-28T01:31:30.000Z","updated":"2021-04-29T08:56:35.848Z","comments":true,"path":"2021/04/28/Node学习4-Buffer/","link":"","permalink":"http://yoursite.com/2021/04/28/Node%E5%AD%A6%E4%B9%A04-Buffer/","excerpt":"","text":"BufferBuffer 对象用于表示固定长度的字节序列。 从V3.0开始，该对象就继承自Uint8Array（从V3.0版本加入的特性），且继承时带上了涵盖额外用例的方法。只要支持 Buffer 的地方，Node.js API 都可以接受普通的 Uint8Array 模块结构Buffer是一个典型的JavaScript与C++结合的模块，它将性能部分用C++实现，将非性能相关的部分用JavaScript实现。 之前说过，Buffer所占的内存不过是V8分配的，属于堆外内存。由于V8垃圾回收性能的影响，将通用的操作对象用更高效和专用的内存分配回收来管理是个不错的思路。 Buffer内存分配在最开始的Node版本中，是采用了slab分配机制，并且使用构造函数来新建一个Buffer，如： 12let bf = new Buffer(100)//新建一个长度为100的Buffer 并且在内部判断是否大于8KB来使用slab算法。 但是自V5.10版本开始时，新增了Buffer.alloc(size)。在V5.12新增了Buffer.allocUnsafe(size)。并且在与V6.0版本废除该API。 在Node启动的时候，Buffer 模块会预分配一个内部的大小为 Buffer.poolSize （默认为8KB）的 Buffer 实例，作为快速分配的内存池，用于使用 Buffer.allocUnsafe() 创建新的 Buffer 实例、或 Buffer.from(array)、或 Buffer.concat()、或弃用的 new Buffer(size) 构造器但仅当 size 小于或等于 Buffer.poolSize &gt;&gt; 1（Buffer.poolSize 除以二再向下取整）。 Buffer.alloc(size[, fill[, encoding]])该API最大的特点是，永远不会使用内部的Buffer池，而是直接分配。我们来查看其源代码： 1234567891011121314/** * Creates a new filled Buffer instance. * alloc(size[, fill[, encoding]]) */Buffer.alloc = function alloc(size, fill, encoding) &#123; assertSize(size); //有初始化的Buffer，则先申请unsafeBuffer，再填充 if (fill !== undefined &amp;&amp; fill !== 0 &amp;&amp; size &gt; 0) &#123; const buf = createUnsafeBuffer(size); return _fill(buf, fill, 0, buf.length, encoding); &#125; //无填充的话直接新建FastBuffer，FastBuffer是Uint8Array的子类 return new FastBuffer(size);&#125;; 可以看到，这里会判断是否有填充，如果没有填充或者size&lt;0，则直接返回一个FastBuffer。这里的FastBuffer时Uint8Array的一个子类，源代码如下： 12345678class FastBuffer extends Uint8Array &#123; // Using an explicit constructor here is necessary to avoid relying on // `Array.prototype[Symbol.iterator]`, which can be mutated by users. // eslint-disable-next-line no-useless-constructor constructor(bufferOrLength, byteOffset, length) &#123; super(bufferOrLength, byteOffset, length); &#125;&#125; 我们再看如果有填充并且长度不为0，则调用createUnsafeBuffer返回一个未初始化的数组，我们再来看一下其源代码： 12345678910111213// A toggle used to access the zero fill setting of the array buffer allocator// in C++.// |zeroFill| can be undefined when running inside an isolate where we// do not own the ArrayBuffer allocator. Zero fill is always on in that case.let zeroFill = getZeroFillToggle();function createUnsafeBuffer(size) &#123; zeroFill[0] = 0; try &#123; return new FastBuffer(size); &#125; finally &#123; zeroFill[0] = 1; &#125;&#125; 可以看到看到这里的定义是为了解决当运行在一个我们没有一个ArrayBuffer的分配器的独立容器时，zeroFill可能为undefined时，所以调用getZeroFillToggle来直接获取zeroFill，用来解决这个问题。 可以看到整个过程中，没有使用到缓冲池pool的代码。正因如此，这种方式，要比下面的两个API慢得多。 Buffer.allocUnsafe(size)以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，可能包含敏感数据。 该API会在size小于Buffer.poolSize的一半的时使用内部的缓冲池。让我们来看一下该API的代码： 12345678/** * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer * instance. If `--zero-fill-buffers` is set, will zero-fill the buffer. */Buffer.allocUnsafe = function allocUnsafe(size) &#123; assertSize(size); return allocate(size);&#125;; 可以看到内部先判断大小，然后直接返回allocate整个函数的返回值，我们再看allocate函数。 1234567891011121314151617function allocate(size) &#123; if (size &lt;= 0) &#123; return new FastBuffer(); &#125; //如果分配的大小小于4KB if (size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)) &#123; //剩下的缓冲池不足，则新建一个缓冲池 if (size &gt; (poolSize - poolOffset)) createPool(); const b = new FastBuffer(allocPool, poolOffset, size); poolOffset += size; alignPool(); return b; &#125; return createUnsafeBuffer(size);&#125; 可以看到这里就很明显有一个对于缓冲池的判断，如果小于size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)，即默认小于4KB，则再判断缓冲池是否够，不够就新建一个pool然后缓冲池偏移。这里本质上还是一个slab算法，我们后面再讲。 但是当不满足size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)时，会调用createUnsafeBuffer，这个函数即Buffer.alloc()有填充时处理的情况，即直接调用C++内存分配，不从缓冲池分配。 Buffer.allocUnsafeSlow(size)以这种方式创建的 Buffer 实例的底层内存是未初始化的。 Buffer 的内容是未知的，可能包含敏感数据。 刚才提到了，Buffer.allocUnsafe(size)在分配的内存小于4KB时，会使用内部的缓冲池。 这可以避免垃圾回收机制因创建太多独立的 Buffer 而过度使用。 通过消除跟踪和清理尽可能多的单个 ArrayBuffer 对象的需要，该方法可以提高性能和内存使用率。 但是当我们不想从缓冲池中分配内存，而是直接在内存中保有一小块内存时，就可以使用这个API来创建一个非内存池的Buffer。 下面我们来看一下其源代码： 123456789/** * Equivalent to SlowBuffer(num), by default creates a non-zero-filled * Buffer instance that is not allocated off the pre-initialized pool. * If `--zero-fill-buffers` is set, will zero-fill the buffer. */Buffer.allocUnsafeSlow = function allocUnsafeSlow(size) &#123; assertSize(size); return createUnsafeBuffer(size); &#125;; 可以看到代码很简单，先判断大小，然后直接调用allocUnsafeSlow，从内存直接分配。 slab算法当我们使用Buffer.allocUnsafe(size)且内存小于4KB时，就会使用内部的缓冲池，而这个缓冲池的设计就是一个slab算法。所以下面简单介绍一下这个算法。 slab算法是一种动态内存管理机制，最早诞生于SunOS系统中，目前在一些*nix系统中有广泛的应用，如FreeBSD和Linux。 简而言之，slab就是一块申请好的固定大小的内存区域。slab区域具有如下的3中状态： full：完全分配状态。 partial：部分分配状态。 empty：没有被分配状态。 下面我们看一下创建缓冲池的代码： 1234567function createPool() &#123; poolSize = Buffer.poolSize; allocPool = createUnsafeBuffer(poolSize).buffer; markAsUntransferable(allocPool); poolOffset = 0;&#125;createPool(); 可以看到实际上就是在定义后立即调用，内部调用了createUnsafeBuffer预先申请一个Buffer.poolSize的缓冲池。并且将poolOffset设置为0，即没被占用。 我们回顾之前的allocate函数： 1234567891011121314151617function allocate(size) &#123; if (size &lt;= 0) &#123; return new FastBuffer(); &#125; //如果分配的大小小于4KB if (size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)) &#123; //剩下的缓冲池不足，则新建一个缓冲池 if (size &gt; (poolSize - poolOffset)) createPool(); const b = new FastBuffer(allocPool, poolOffset, size); poolOffset += size; alignPool(); return b; &#125; return createUnsafeBuffer(size);&#125; 会发现，其在分配完缓冲池后，会做两件事： poolOffset += size：增加偏移量。 alignPool()：居中缓冲池。 第一个时间不用详细解释，即将刚才分配的内存添加到全局的poolOffset中取。 而第二个函数，我们看看其源代码： 1234567function alignPool() &#123; // Ensure aligned slices if (poolOffset &amp; 0x7) &#123; poolOffset |= 0x7; poolOffset++; &#125;&#125; 这段代码运用了两个位运算，实际上第一个判断是判断poolOffset是否超过了缓冲池的一半，如果没有，则将其定位在缓冲池一半的位置（结合上面判断新建的Buffer的大小是否小于缓冲池的一半）。即实现函数的名字：居中缓冲池。 所以，这种slab算法会造成内存的浪费，因为如果pool的前一部分非常小，只有几个字节，但是由于会进行居中缓冲池的操作，最后这个Buffer仍然会占据Buffer.poolSize &gt;&gt;&gt; 1大小的内存。 （这里我不确定是不是slab算法，因为上面的根据源代码总结出的算法与Linux中slab算法有较大的差距，而很多文章都说Node中Buffer就是slab算法，待我后续确定） Buffer 与字符编码Buffer对象可以与字符串之间进行相互转换。 字符串转Buffer字符串转Buffer主要是通过Buffer.from()函数实现： 这个函数有多个重载函数，可以实现从字符串，数组和对象的到Buffer的转换，具体参见Node官网 示例1234567891011121314151617181920212223console.log(Buffer.from('fhqwhgads', 'utf8'));// 打印: &lt;Buffer 66 68 71 77 68 67 61 64 73&gt;console.log(Buffer.from('fhqwhgads', 'utf16le'));// 打印: &lt;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00&gt;const buf1 = Buffer.from('buffer');const buf2 = Buffer.from(buf1);buf1[0] = 0x61;console.log(buf1.toString());// 打印: aufferconsole.log(buf2.toString());// 打印: bufferclass Foo &#123; [Symbol.toPrimitive]() &#123; return 'this is a test'; &#125;&#125;const buf = Buffer.from(new Foo(), 'utf8');// 打印: &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt; Node.js当前支持的编码如下： &#39;utf8&#39;: 多字节编码的 Unicode 字符。 许多网页和其他文档格式都使用 UTF-8。 这是默认的字符编码。 当将 Buffer 解码为不专门包含有效 UTF-8 数据的字符串时，则会使用 Unicode 替换字符 U+FFFD � 来表示这些错误。 &#39;utf16le&#39;: 多字节编码的 Unicode 字符。 与 &#39;utf8&#39; 不同，字符串中的每个字符都会使用 2 个或 4 个字节进行编码。 Node.js 仅支持 UTF-16 的小端序变体。 &#39;latin1&#39;: Latin-1 代表 ISO-8859-1。 此字符编码仅支持从 U+0000 到 U+00FF 的 Unicode 字符。 每个字符使用单个字节进行编码。 超出该范围的字符会被截断，并映射成该范围内的字符。 使用以上方法之一将 Buffer 转换为字符串，称为解码；将字符串转换为 Buffer，称为编码。 Node.js 还支持以下两种二进制转文本的编码。 对于二进制转文本的编码，其命名约定是相反的：将 Buffer 转换为字符串通常称为编码，而将字符串转换为 Buffer 则称为解码。 &#39;base64&#39;: Base64 编码。 当从字符串创建 Buffer 时，此编码也会正确地接受 RFC 4648 第 5 节中指定的 “URL 和文件名安全字母”。 base64 编码的字符串中包含的空格字符（例如空格、制表符和换行）会被忽略。 &#39;hex&#39;: 将每个字节编码成两个十六进制的字符。 当解码仅包含有效的十六进制字符的字符串时，可能会发生数据截断。 请参见下面的示例。 还支持以下传统的字符编码： &#39;ascii&#39;: 仅适用于 7 位 ASCII 数据。 当将字符串编码为 Buffer 时，这等效于使用 &#39;latin1&#39;。 当将 Buffer 解码为字符串时，则使用此编码会在解码为 &#39;latin1&#39; 之前额外取消设置每个字节的最高位。 通常，当在编码或解码纯 ASCII 文本时，应该没有理由使用这种编码，因为 &#39;utf8&#39;（或者，如果已知的数据始终为纯 ASCII，则为 &#39;latin1&#39;）会是更好的选择。 这仅为传统的兼容性而提供。 &#39;binary&#39;: &#39;latin1&#39; 的别名。 有关此编码的更多背景，请参阅二进制字符串。 该编码的名称可能会引起误解，因为此处列出的所有编码都是在字符串和二进制数据之间转换。 对于在字符串和 Buffer 之间进行转换，通常 &#39;utf-8&#39; 是正确的选择。 &#39;ucs2&#39;: &#39;utf16le&#39; 的别名。 UCS-2 以前是指 UTF-16 的一种变体，该变体不支持代码点大于 U+FFFF 的字符。 在 Node.js 中，始终支持这些代码点。 Buffer不支持的编码Node目前支持的编码格式依然比较少，包括在中国常用的GBK, GB2312, BIG-5等。为此，Buffer提供了一个Buffer.isEncoding()方法来判断编码是否被Node支持。 对于不支持的编码类型，可以借助Node生态圈中的模块完成转换，iconv和iconv-lite两个模块都可以支持更多的编码类型的转换，包括Windwos 125系列、ISO-8859系列、IBM/DOS代码页系列、Macintosh系列、KO18系列，以及Latin1、US-ASCII、也支持宽字节编码GBK和GB2312。 iconv-lite使用纯JavaScript实现，iconv则通过C++调用libiconv库完成。前者比后者更轻量无须编译和处理环境依赖直接使用。在性能方面，由于转码都是消耗CPU，再V8的高性能下，少了C++到JavaScript的层次转换，纯JavaScript的性能比C++表现得更好。具体使用参见： node-iconv iconv-lite 字符串拼接Buffer在使用中，通常是以一段一段得方式传输。例如下面得代码： 123456789101112let fs = require('fs')let rs = fs.createReaderStream('test.md')let data = ''rs.on(\"data\", function(chunk)&#123; data += chunk&#125;)rs.on(\"end\", function()&#123; console.log(data)&#125;) 上面这段代码常见于国外，用于流读取得师范，data事件中得获取得chunk对象即为Buffer对象。对于初学者而言，容易将Buffer当作字符串来理解，所以在接受上面示例时不会觉得有任何异常。 但是一旦流中出现宽字符时，问题就会暴露出来。如果你在通过Node开发得网站上看到�乱码符号，那么问题多半来自这里： 1data += chunk 这段代码里隐藏了toString()操作，它等价于下面得代码： 1data = data.toString() + chunk.toString() 值得注意的是：外国人得语境通常是英文环境，没有宽字符，在他们的场景中，这个toString()不会造成任何问题。但是对于宽字符的中文，却会形成问题。 其主要原因在于，每次data事件发生时，其读取的长度不一定为指定宽字符长度的整倍数，比如UTF-8中，每个字符的长度为3个字节，但是如果我们一次读取的字节为10个字节，那么前两个字符会被正常显示，但是第三个字符只录入了1/3，所以其无法正常显示，最后会被显示为�。 解决办法setEncoding()可读流还有一个设置编码的方法setEncoding()，示例如下： 1readable.setEncoding(encoding) 该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。为此，我们改进之前的程序： 12let rs = fs.createReadStream('test.md', &#123;highWaterMark: 11&#125;)rs.setEncoding('utf8') 再次执行，即可得到正常的结果，说明输出不再受Buffer大小的影响了。 这里我们可以稍微看一下这个函数的源代码（src/lib/internal/streams/readable.js）： 123456789101112131415161718192021// Backwards compatibility.Readable.prototype.setEncoding = function(enc) &#123; if (!StringDecoder) StringDecoder = require('string_decoder').StringDecoder; const decoder = new StringDecoder(enc); this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8. this._readableState.encoding = this._readableState.decoder.encoding; const buffer = this._readableState.buffer; // Iterate over current buffer to convert already stored Buffers: let content = ''; for (const data of buffer) &#123; content += decoder.write(data); &#125; buffer.clear(); if (content !== '') buffer.push(content); this._readableState.length = content.length; return this;&#125;; 可以看到，内部新建了一个StringDecoder，每次data事件发生时，decoder对象会将对得到的Buffer到String的转码，然后传递给调用者。 其中string_decoder之所以能够解决这个问题，是因为其会判断当前编码的单个字符宽度w，当第一次data事件触发的时候，就会只截取前面kw个字节的长度（k\\w &lt; total）多余的（total - k*w）个字符会被保存下来，与下次data事件传过来的字节一直再进行解析。 但是setEncoding的问题在于，其只能支持上述Buffer支持的编码，仍然不能支持GKB等编码。如果遇到这些编码，仍然会出现问题。 数组拼接我们可以将接收到的字节存储在数组中，然后通过iconv-lite等工具再来进行转码： 示例123456789101112let chunks = []let size = 0rs.on('data', function(chunk)&#123; chunks.push(chunk) size += chunk.length&#125;)rs.on('end', function()&#123; let buf = Buffer.concat(chunks, size) let str = iconv.decode(buf, 'GBK') console.log(str)&#125;) 正常的拼接方法是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度，然后调用Buffer.concat方法生成一个合并的Buffer对象。 Buffer与性能Buffer在文件I/O和网络I/O时运用广泛，尤其在网络传输中，它的性能举足轻重。在应用中，如果不是特别大的内容，我们都会使用字符串，但一旦在网络中传输，都需要转换为字符串，以二进制数据进行传输。在web应用中，从字符串到Buffer的转换时时刻刻都在发生，所以提高字符串到Buffer的转换效率，可以大幅度提高网络吞吐量。 下面是net模块的makeSyncWrite函数，在实际中，它是最后处理数据的： 1234567891011121314151617function makeSyncWrite(fd) &#123; return function(chunk, enc, cb) &#123; if (enc !== 'buffer') chunk = Buffer.from(chunk, enc); this._handle.bytesWritten += chunk.length; const ctx = &#123;&#125;; writeBuffer(fd, chunk, 0, chunk.length, null, undefined, ctx); if (ctx.errno !== undefined) &#123; const ex = errors.uvException(ctx); ex.errno = ctx.errno; return cb(ex); &#125; cb(); &#125;;&#125; 可以看到chunk = Buffer.from(chunk, enc);，如果chunk不是Buffer，则将其转换为Buffer。 所以，Node底层仍然是使用Buffer.from()来进行字符串到Buffer的转换，所以，如果是动态的字符串，我们提前转换与Node自动转换区别不大，但是如果是静态的字符串，比如各种错误提示，此时将其提前转换为Buffer，在高并发时，将大幅度提高服务器CPU的利用率。 总结对于经常写JavaScript代码的人，很容易混淆String与Buffer，实际上它们有诸多不同： String长度不定，而Buffer在定义的时候就规定了长度，之后无法改变（可以使用Buffer.concat()变相的增加长度）。 Buffer存储的是二进制数据，字符串与Buffer之间存在编码问题。 在V3版本后，Buffer即为Uint8Array的子类，所以其本质是一个数组。 String的内存由V8引擎分配、回收，而Buffer的内存由Node自己负责，不受其内存限制。 引用本文参考 《深入浅出nodejs》 Node官网 Node源码","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Buffer","slug":"Buffer","permalink":"http://yoursite.com/tags/Buffer/"}]},{"title":"NodeJS学习3-内存控制","slug":"NodeJS学习3-内存控制","date":"2021-04-27T01:13:46.000Z","updated":"2021-04-27T06:15:49.426Z","comments":true,"path":"2021/04/27/NodeJS学习3-内存控制/","link":"","permalink":"http://yoursite.com/2021/04/27/NodeJS%E5%AD%A6%E4%B9%A03-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/","excerpt":"","text":"V8的内存分配在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB），在这样的限制下，将会导致Node无法直接操作大内存对象。比如无法将一个2GB的文件读入内存中进行字符串分析处理，即使物理内存大于2GB，这样在单个Node进程的情况下，计算机的内存资源无法得到充足的使用。 造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上都是通过V8自己的方式来进行分配和管理的。V8这套内存管理机制在浏览器的应用场景下使用起来是绰绰有余，足以胜任前端页面中的所有需求。但在Node中，却限制了开发者随心所欲使用大内存的想法。 原因表层原因在于，V8最初为浏览器设计，不大可能设计大内存使用的场景。对于一个网页（在浏览器中，一个tab有一个JS线程），1.5GB已经足够使用。从官方的说法来说，以1.5GB的垃圾回收堆内存为例，V8做一次垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1s以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端无法接受，前端浏览器同样无法接受。 当然，这个限制也不是不能改变，V8依然在启动时提供可选参数来使用更多内存。 12node --max-old-space-size = 1700 //老生代，单位为MBnode --max-new-space-size = 1024 //新生代，单位为KB 但是注意，这个参数在运行中是无法改变的，一旦启动，内存分配就无法改变，这一点，确实限制了Node的发挥。 V8的垃圾回收机制之前在分析闭包的那篇文章中，全面理解JavaScript作用域与闭包，虽然详细分析了V8的内存结构，但是并没有详细分析垃圾回收机制,这里详细看一下。 V8主要的垃圾回收算法V8的垃圾回收策略主要基于分布式垃圾回收机制。在自动垃圾回收的演变过程中，人们发现暂时没有一种垃圾回收算法能够胜任所有的场景。因为在实际应用中，对象的生存周期长短不一，不同的算法只能针对特定情况具有最好的效果。为此，统计学在垃圾回收算法中产生了较大的作用，现在的垃圾回收算法按对象的存活时间将内存的垃圾回收进行不同的分代。然后分别对不同的内存施以更高效的算法。 V8的内存分代在V8中，主要讲内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象主要为存活时间较长或或者常驻内存的对象。 所以V8的堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提到的改变Node的内存限制就是用以改变新生代和老生代的内存空间的大小。 Scavenge算法在分代的基础上，新生代中的对象主要是通过Scavenge算法进行垃圾回收的。在Scavenge的具体实现中，主要采用了Cheney算法，该算法由C.J.Cheney于1970年首次发表在ACM论文上。 Cheney算法是一种采用复制的方法实现的垃圾回收算法。它讲堆的内存一分为二，每一部分空间成为semispace。在这两个semispace中，只有一个处于使用中，另一个处于空闲中。处于使用状态的semispace称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间进行分配。当开始机型垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，二非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的工程中，就是通过讲存活对象在两个semispace空间之间进行复制。 Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制决定的。但是Scavenge由于只复制存活的对象，并且对于生命周期短的场景只占少部分，所以它在时间效率上有优异的表现。 由于Scavenge是典型的空间换时间的算法，所以无法大规模的应用到所有的垃圾回收机制中。但是可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。所以，V8的堆内存分配应当如下： 实际使用的堆是新生代的两个semispace空间大小和老生代所使用的内存大小之和。 新生代向老生代的转换在V8中，在两种情况下，新生代的对象会转变为老生代的对象（对象晋升）： 当一个对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，会检查它的内存来判断这个对象是否已经经历过一次Scavenge回收，如果经历过了，将该对象从From空间复制到老生代空间中，如果没有，则复制到To空间中。 当要从From空间复制一个对象到To空间时，如果To空间的内存占用使用超过了25%，则这个对象直接晋升到老生代空间中。这个限制的原因在于当这次Scavenge回收完成后，这个To空间将会变成From空间，接下来的内存分将会在这个空间中进行。如果占比过高，会影响后续的内存分配。 Mark-Sweep &amp; Mark-Compact在老生代的对象中，由于存活对象占较大的比例，再采用Scavenge算法就会出现两个问题： 存活的对象较多，复制存活对象的效率会降低。 浪费另一半内存的弊端在这个就先会放大。 为此，V8再老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。 Mark-SweepMark-Sweep即标记清楚，它分为标记和清楚两个阶段。其核心在于，Mark-Sweep再标记阶段遍历堆中的所有对象，并标记活着的对象，再随后的清楚阶段中，只清楚没有被标记的对象。 可以看出，Scavenge中只复制或者的对象，而Mark-Sweep只清除死亡的对象。 而活对象在新生代中只占小部分，死对象在老生代只占较少部分，所以这两种算法刚好能够发挥最大性能。示意图如下（黑色表示死亡的对象）： 缺点Mark-Sweep最大问题在于一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后面的内存分配造成问题，因为可能会出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就提前触发垃圾回收，而这次回收是不必要的。 Mark-Compact为了解决上面Mark-Sweep的碎片问题，在Mark-Sweep上的基础上提出了Mark-Compact，即标记整理。他们的差别在，Mark-Compact会在对象被标记为死亡后，在整理的过程中，将活着的对象向一端移动，移动完成后，直接清理掉边界外的内存。示意图如下（白色各自为存活对象，深色格子为死亡对象，浅色对象为存活对象移动后留下的空间）： 完成移动后，就可以直接清除最右边的存活对象后面的内存区域完成回收。 但是由于Mark-Sweep与Mark-Compact的时间复杂度有很大差距，所以V8采用了结合使用的方式。将其对比如下： 参数/回收算法 Mark-Sweep Mark-Compact Scavenge 速度 较慢 很慢 较快 碎片 有 无 无 空间开销 少 少 双倍空间 发生移动 否 是 是 具体上，V8主要使用Mark-Sweep，在空间不足以对从新生代晋升过来的对象进行分配时才使用Mark-Compact。 Incremental Marking为了避免出现JavaScript逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都要讲应该逻辑暂停下来，带执行完毕垃圾回收后再恢复执行应用的逻辑，这种行为被称为”全停顿“（stop-the-world）。在V8的分布式垃圾回收中，一次小垃圾的回收只影响新生代，由于新生代默认配置得比较少，且存活对象较多，全堆垃圾回收（full垃圾回收）得标记、清理、整理等动作造成得停顿就会比较可怕，需要设法改善。 为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是将回收的时间拆分为多个小”步进“，每做完一个”步进“，就让JavaScript应用逻辑执行一会，垃圾回收与应用逻辑交替执行直到标记阶段完成。 经过改进，垃圾回收的最大停顿时间可以减少到原来的1/6左右。 V8后续还引入了延迟清理（lazy sweeping）与增量式整理（incremental compaction），让清理与整理的动作也变为增量式的。同时还引入了并行标记和并行清理，进一步利用多核性能降低每次的停顿动作。 查看日志我们可以通过在Node启动的时候加上trace_gc来查看Node的垃圾回收日志。 1node --trace_gc app.js 下面贴出一部分运行时日志示例： 12345[14632:000002A161C54EC0] 395853 ms: Scavenge 21.0 (24.3) -&gt; 19.8 (22.0) MB, 1.4 / 0.0 ms (average mu = 0.995, current mu = 0.962) allocation failure [14632:000002A161C54EC0] 395862 ms: Scavenge 20.5 (22.0) -&gt; 20.1 (22.3) MB, 2.0 / 0.0 ms (average mu = 0.995, current mu = 0.962) allocation failure [14632:000002A161C54EC0] 395870 ms: Scavenge 20.7 (22.3) -&gt; 20.4 (22.5) MB, 1.9 / 0.0 ms (average mu = 0.995, current mu = 0.962) allocation failure[14632:000002A161C54EC0] 395879 ms: Scavenge 21.1 (22.5) -&gt; 20.5 (22.8) MB, 2.3 / 0.0 ms (average mu = 0.995, current mu = 0.962) allocation failure [14632:000002A161C54EC0] 395915 ms: Mark-sweep 21.0 (22.8) -&gt; 14.1 (20.0) MB, 10.8 / 0.0 ms (+ 0.3 ms in 3 steps since start of marking, biggest step 0.1 ms, walltime since start of marking 30 ms) (average mu = 1.000, current mu = 1.000) finalize incremental marking via task GC in old space requested 通过垃圾回收日志，可以了解垃圾回收的运行状态，找出垃圾回收的哪些阶段比较耗时，触发的原因是什么。 在启动的时候加上--prof参数可以得到V8运行时的性能分析数据。期中也包含垃圾回收时占用的时间。 1node --prof app.js 这将会在文件根目录生成一个xxx-v8.log文件，从这个文件可以读到每个内存的动作（包括shared libraries, code-creation, sfi, tick等），但是仍然不是很好读，下面是一段示例代码： 123456789101112131415161718192021222324252627282930313233v8-version,7,7,299,13,-node.16,0shared-library,C:\\\\Program Files\\\\nodejs\\\\node.exe,0x7ff76b1a0000,0x7ff76cfc1000,0shared-library,C:\\\\Windows\\\\SYSTEM32\\\\ntdll.dll,0x7ffcc8750000,0x7ffcc8945000,0shared-library,C:\\\\Windows\\\\System32\\\\KERNEL32.DLL,0x7ffcc6dd0000,0x7ffcc6e8d000,0shared-library,C:\\\\Windows\\\\System32\\\\KERNELBASE.dll,0x7ffcc60c0000,0x7ffcc6388000,0shared-library,C:\\\\Windows\\\\System32\\\\WS2_32.dll,0x7ffcc7270000,0x7ffcc72db000,0shared-library,C:\\\\Windows\\\\System32\\\\RPCRT4.dll,0x7ffcc6920000,0x7ffcc6a4b000,0...code-creation,Builtin,3,156659,0x7ff76bede690,86,Constructcode-creation,Builtin,3,156665,0x7ff76bede6f0,78,ConstructVarargscode-creation,Builtin,3,156672,0x7ff76bede750,1028,ConstructWithSpreadcode-creation,Builtin,3,156678,0x7ff76bedeb70,1080,ConstructWithArrayLikecode-creation,Builtin,3,156685,0x7ff76bedefb0,142,ConstructForwardVarargscode-creation,Builtin,3,156692,0x7ff76bedf050,142,ConstructFunctionForwardVarargscode-creation,Builtin,3,156699,0x7ff76bedf0f0,328,JSConstructStubGenericcode-creation,Builtin,3,156706,0x7ff76bedf250,244,JSBuiltinsConstructStubcode-creation,Builtin,3,156712,0x7ff76bedf350,947,FastNewObject...sfi-move,0x3a2b6497110,0xde45da4bb8sfi-move,0x3a2b6497160,0xde45da3f50sfi-move,0x3a2b64971b0,0xde45da3fa0sfi-move,0x3a2b6497200,0xde45da3ff0...tick,0x7ffcc87efb14,66266607,0,0x0,6tick,0x7ffcc87efb14,66283096,0,0x0,6tick,0x7ffcc87efb14,66298653,0,0x0,6tick,0x7ffcc87efb14,66314624,0,0x0,6tick,0x7ffcc87efb14,66330633,0,0x0,6tick,0x7ffcc87efb14,66346563,0,0x0,6tick,0x7ffcc87efb14,66362684,0,0x0,6tick,0x7ffcc87efb14,66378772,0,0x0,6tick,0x7ffcc87efb14,66394645,0,0x0,6tick,0x7ffcc87efb14,66410815,0,0x0,6 我们可以通过V8提供的API： 1node --prof-process isolate-0xnnnnnnnnnnnn-v8.log &gt; processed.txt 生成profile文件，下面是例子（部分）： 123456789101112131415161718192021Statistical profiling result from .\\isolate-000001A24906A4A0-14888-v8.log, (4214 ticks, 0 unaccounted, 0 excluded). [Shared libraries]: ticks total nonlib name 4141 98.3% C:\\Windows\\SYSTEM32\\ntdll.dll 71 1.7% C:\\Program Files\\nodejs\\node.exe [JavaScript]: ticks total nonlib name 1 0.0% 50.0% LazyCompile: *resolve path.js:130:10 1 0.0% 50.0% LazyCompile: *nextPart fs.js:1433:31 [C++]: ticks total nonlib name [Summary]: ticks total nonlib name 2 0.0% 100.0% JavaScript 0 0.0% 0.0% C++ 9 0.2% 450.0% GC 4212 100.0% Shared libraries 也可以采用其他第三方工具进行分析，具体不在细讲。 解决办法V8的这些限制在浏览器端看起来很合理，一个页面很少能占用超多2GB内存，但是在服务端，这就显得捉襟见肘了，为此，Node开发了Buffer，Stream等模块，来弥补V8的不足，后面会陆续详解。 引用本文大部分参考《深入浅出nodejs》以及Node官网","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"内存控制","slug":"内存控制","permalink":"http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/"}]},{"title":"NodeJS学习2-异步的原理和应用","slug":"NodeJS学习2-异步的原理和应用","date":"2021-04-24T11:38:03.000Z","updated":"2021-04-27T06:15:13.345Z","comments":true,"path":"2021/04/24/NodeJS学习2-异步的原理和应用/","link":"","permalink":"http://yoursite.com/2021/04/24/NodeJS%E5%AD%A6%E4%B9%A02-%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/","excerpt":"","text":"内部原理理想的非阻塞异步I/O完美的异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需要在I/O完成后通过回调将数据传递给应用程序即可。 幸运的是：Linux下的AIO就是通过信号或回调来传递数据。 不幸的是：只有Linux下有，而且它还有缺陷-AIO仅支持I/O内核中的O_DIRECT方式读取，导致无法使用系统缓存。 现实的异步I/O现实更加骨感，但是要达成I/O的目标，并非难事。前面我们将场景限定在了单线程的状态下，实际上使用多线程来模拟异步，就会轻松达成效果了。通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据及性能传递，就轻松实现了异步I/O。 最初的Node在*nix平台下采用了libeio，libeio实质上依然采用的线程池与阻塞I/O模拟异步I/O。配合libev实现I/O部分，实现了异步I/O。在Node v0.9.3以后，自行实现了线程池来完成异步I/O。 而在Windows平台下，IOCP在某种程度上提供了较为理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调。用户无须考虑轮询。但是它的内部依然是线程池原理，不同之处在于这些线程池是由系统内核接受管理。 由于Windows平台和in平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的Node与下层的系定义线程池IOCP之间各自独立。Node会在编译期间判断平台，选择性编译\\nix或是win目录下的源文件到目标程序中。 而在*nix平台，对线程池也有不同的方案： The event loop follows the rather usual single threaded asynchronous I/O approach: all (network) I/O is performed on non-blocking sockets which are polled using the best mechanism available on the given platform: epoll on Linux, kqueue on OSX and other BSDs, event ports on SunOS and IOCP on Windows. As part of a loop iteration the loop will block waiting for I/O activity on sockets which have been added to the poller and callbacks will be fired indicating socket conditions (readable, writable hangup) so handles can read, write or perform the desired I/O operation. 即： Linux平台下使用epoll OSX和其他BSDs使用kqueue SunOS使用event ports Windows使用IOCP 值得注意的是： 这里的I/O不仅仅只限于磁盘文件的读写。*nix将计算机抽象了一番，磁盘文件，硬件，套接字等几乎所有的计算机资源都被抽象成为了文件，因此这里描述的阻塞和非阻塞的情况同样适用于套接字等。 平时我们提及到Node是单线程的，这里单线程仅仅只是JavaScript执行在单线程中。在Node中，无论是*nix或者windows平台，内部完成I/O任务的另有线程池。 执行原理事件循环之前在JavaScript宏任务，微任务与Event-loop简单介绍过事件循环的概念。 其在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为一个Tick，每个Tick的过程就是查看是否有事件待处理。如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行他们。然后进入下一个循环，如果不再有事件处理，就退出进程。 观察者在每一个Tick中，都是通过观察者来判断是否有事件需要处理。 每个事件循环有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。 浏览器采用了类似的机制。事件可能来自用户的点击或者加载某个文件时产生，而这些产生的事件都有对应的观察者。在Node中，事件主要来源于网络请求，文件I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O观察者等。观察者将事件进行了分类。 事件循环是一个经典的生产者/消费者模型。异步I/O，网络请求等则是网络事件的请求者，源源不断的为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。 这里用到了观察者模式，在设计模式5-发布-订阅模式（观察者模式）详细介绍过。 请求对象在异步请求回调中，从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做请求对象。 下面以fs.open()作为例子，来看一下其源代码： 1234567891011121314151617181920212223function open(path, flags, mode, callback) &#123; path = getValidatedPath(path); if (arguments.length &lt; 3) &#123; callback = flags; flags = 'r'; mode = 0o666; &#125; else if (typeof mode === 'function') &#123; callback = mode; mode = 0o666; &#125; else &#123; mode = parseFileMode(mode, 'mode', 0o666); &#125; const flagsNumber = stringToFlags(flags); callback = makeCallback(callback); const req = new FSReqCallback(); req.oncomplete = callback; binding.open(pathModule.toNamespacedPath(path), flagsNumber, mode, req);&#125; fs.open()是根据指定的路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初始操作。从代码可以看出，JavaScript层面的代码时通过调用C++核心模块进行下层的操作。其执行流程如下： 这里是JavaScript典型的调用方法： 从JavaScript调用Node的核心模块 核心模块调用C++内建模块 内建模块通过libuv进行系统调用 在libuv中，实质上调用了uv_fs_open()方法。在uv_fs_open()方法中，调用了uv_fs_req_init，将传入的参数添加到uv_fs_t请求对象上。从JavaScript层传入的参数和当前方法都被封装在这个请求对象中，其中我们最为关注的回调函数被设置在这个对象的cb上属性上： 12345678910111213INLINE static void uv_fs_req_init(uv_loop_t* loop, uv_fs_t* req, uv_fs_type fs_type, const uv_fs_cb cb) &#123; uv_req_init(loop, (uv_req_t*) req); req-&gt;type = UV_FS; req-&gt;loop = loop; req-&gt;flags = 0; req-&gt;fs_type = fs_type; req-&gt;result = 0; req-&gt;ptr = NULL; req-&gt;path = NULL; req-&gt;cb = cb;&#125; 对象封装完毕后，在Windows下，则调用QUEUE_FS_TP_JOB()=&gt;uv__req_register()=&gt;QUEUE_INSERT_TAIL()方法将这个uv_fs_t对象推入，线程池中等待执行，该方法的代码如下： 1QUEUE_INSERT_TAIL(&amp;(loop)-&gt;active_reqs, &amp;(req)-&gt;active_queue); 该方法接受2个参数： &amp;(loop)-&gt;active_reqs：要执行的方法的引用。 &amp;(req)-&gt;active_queue：事件循环队列。 至此，JavaScript调用立即返回，由JavaScript底层发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前的后续操作。当前的I/O操作在线程池中等待执行，不断是否阻塞I/O，都不会影响JavaScript线程的后续操作，如此就达到了异步的目的。 （在libuv0.1中，Windows使用的是QueueUserWorkItem()API，而在Unix使用的是默认4个的线程池，而在1.0版本中，在Windows与Unix统一了标准，都是用了线程池，更新公告如下：） Threadpool changes ~~~~~~ In libuv 0.10 Unix used a threadpool which defaulted to 4 threads, while Windows used the QueueUserWorkItem API, which uses a Windows internal threadpool, which defaults to 512 threads per process. In 1.0, we unified both implementations, so Windows now uses the same implementation Unix does. The threadpool size can be set by exporting the UV_THREADPOOL_SIZE environment variable. See :c:ref:threadpool. 请求对象时异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。 执行回调 组装好请求对象，送入I/O线程池等待执行，实际上完成了异步I/O第一部分，回调通知是第二部分。 线程池中的I/O操作调用完毕之后，会将获取的结果存储在req-&gt;result属性上，然后调用PostQueuedCompletionStatus()通知IOCP，告知当前对象操作已经完成： 1PostQueuedCompletionStatus(loop-&gt;iocp, 0, 0, NULL); PostQueuedCompletionStatus()方法的作用是向IOCP提交执行状态，并将线程归还给线程池。通过PostQueuedCompletionStatus()方法提交的状态，可以通过GetQueueCompletionStatus()提取。 在这个过程中，其实还动用了事件循环的I/O观察者。在每次Tick的执行中，它会调用IOCP相关的GetQueueCompletionStatus()方法检测线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中没然后将其作为事件处理。 I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出cb属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。 事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。 非I/O的异步API定时器setTimeout()和setInterval()与浏览器中的API是一致的，分别用于单词和多次定时器执行任务。他们的实现与异步I/O相似，只是不需要I/O线程池的参与。调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树。每次Tick执行时，会从红黑树迭代取出定时器对象，检查是否超过定时时间，如果超过，就会形成一个事件，它的回调函数会立即执行。 众所周知，定时器并不是那么准确其原因也在于事件循环，虽然事件循环非常快，但是如果某个循环占用的时间比较多，那么下次循环时，它也许已经超时很久了。 process.nextTick()process.nextTick() 会添加 callback 到下一个时间点队列。 在 JavaScript 堆栈上的当前操作运行完成之后，且允许事件循环继续之前，此队列会被完全耗尽。 此方法与setTimeout比起来，更加轻量级，因为不需要动用红黑树，创建定时器对象和迭代等操作。其代码如下： 12345678910111213141516171819202122232425262728293031323334// `nextTick()` will not enqueue any callback when the process is about to// exit since the callback would not have a chance to be executed.function nextTick(callback) &#123; validateCallback(callback); if (process._exiting) return; let args; switch (arguments.length) &#123; case 1: break; case 2: args = [arguments[1]]; break; case 3: args = [arguments[1], arguments[2]]; break; case 4: args = [arguments[1], arguments[2], arguments[3]]; break; default: args = new Array(arguments.length - 1); for (let i = 1; i &lt; arguments.length; i++) args[i - 1] = arguments[i]; &#125; if (queue.isEmpty()) setHasTickScheduled(true); const asyncId = newAsyncId(); const triggerAsyncId = getDefaultTriggerAsyncId(); const tickObject = &#123; [async_id_symbol]: asyncId, [trigger_async_id_symbol]: triggerAsyncId, callback, args &#125;; if (initHooksExist()) emitInit(asyncId, 'TickObject', triggerAsyncId, tickObject); queue.push(tickObject);&#125; 每次调用process.nextTick()方法只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。 setIMmediate()setImmediate()方法与process.nextTick()方法类似，都是将回调函数延迟执行。但是两者之间还是有一定的区别： process.nextTick()方法优先级要高于setImmediate()。 process.nextTick()的回调函数保存在一个数组中，setImmediate()的回调函数函数保存在链表中。 process.nextTick()在每轮循环中执行链表中的一个回调函数，而setImmediate()在每轮循环中执行链表中的一个回调函数。 其优先级不同的原因在于：事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每轮循环中，idle观察者先于I/O观察者，I/O观察者先于check观察者。 例子1234567891011121314151617181920process.nextTick(function()&#123; console.log('nexiTick延迟执行1')&#125;)process.nextTick(function()&#123; console.log('nexiTick延迟执行2')&#125;)setImmediate(function()&#123; console.log('setImmediate延迟执行1') process.nextTick(function()&#123; console.log('强势插入') &#125;)&#125;)setImmediate(function()&#123; console.log('setImmediate延迟执行2')&#125;)console.log('正常执行') 结果如下： 正常执行nexiTick延迟执行1nexiTick延迟执行2setImmediate延迟执行1强势插入setImmediate延迟执行2 异步编程的优势与难点优势Node带来的最大特性莫过于事件驱动的非阻塞模型。非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。 Node利用事件循环的方式，JavaScript线程池像一个分配任务和处理结果的管家，I/O线程池中的各个I/O线程都是小二。负责完成分配来的任务，小二与管家之间互不依赖，所以可以保持整体的高效率。但是由于JavaScript是单线程，所以，这个系统的极限就是JavaScript线程。换言之，Node为了解决编程模型中阻塞I/O的性能问题，采用了单线程模型，这导致Node更像是一个处理I/O密集问题的能手，而CPU密集型取决于管家的能耐如何。 而通过C++写出来的V8虽然相较于原生C++多了一个编译过程。但是性能仍然可以逼近顶尖。 难点异常处理在传统的同步编程中，通常使用Java的try/catch/final语句块来进行异常捕获。但是这对于异步编程并不适用。因为在之前提到过，异步I/O主要分为两个阶段：请求提交和处理结果。这两个阶段中间有事件循环机制，两者彼此不相关联。异步方法则通常在第一个阶段请求后立即返回，因为异常不一定发生在这个阶段，try...catch...不会生效。 在Node中为了解决这个问题，一般形成了一个约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步回调没有抛出。在这个约定中，我们在编写的异步方法上。也必须取遵循这样几个原则： 原则一：必须执行调用者传入的回调函数。 原则二：正确传递回异常供调用者判断。 示例代码中： 123456789let async = function(callback)&#123; process.nextTick(function()&#123; let res = something if(error)&#123; return callback(error) &#125; callback(null, res) &#125;)&#125; 另外可能出现的错误写法是： 12345678try&#123; req.body = JSON.parse(buf, options.receiver) callback()&#125;catch (err)&#123; err.body = buf err.status = 400 callback(err)&#125; 上述代码的意图是捕获是捕获JSON.parse()中可能出现的异常，但是却不小心包含了用户传递的回调函数。这意味着如果回调函数中有异常抛出，将会进入catch()代码块中执行，于是回调函数将会被执行两次。这样显然不是预期的结果，可能导致业务混乱。正确的代码应为✔： 12345678try&#123; req.body = JSON.parse(buf, options.reviver)&#125;catch (err)&#123; err.body = buf err.status = 400 return callback(err) //直接return，不再执行下面的操作&#125;callback() 另外还有一种方法就是将错误时执行的回调一并传递给异步函数，在异步函数出错时直接调用错误的回调函数就行了，而且现在普遍采用这种方式，典型的比如Promise.then(suc, fail)，或者Axios等框架的设计。 简单的例子如下： 12345678910let async = function(success, fail)&#123; process.nextTick(function()&#123; try&#123; let res = something success(res) &#125;catch(err)&#123; fail(err) &#125; &#125;)&#125; 如果需要更多参数，可以把函数参数设置为一个对象，现在普遍是这么做的。 函数嵌套过深这也是Node开发被人诟病最多的地方。在现代前端工程化开发中，由于采用Node作为支持，特别是在网络请求中，经常会出现嵌套过深的问题，如： 1234567891011import &#123;req1, req2, req3&#125; from 'api.js'req1().then(res1 =&gt; &#123; let param1 = res1.param req2(param).then(res2 =&gt; &#123; let param2 = res2.param req3(param).then(res3 =&gt; &#123; //DO SOMETHING WITH res3 &#125;) &#125;)&#125;) 这样的问题目前仍然困扰着开发人员。 async函数解决办法但是ES6的async函数为我们提供了一个解决该问题的途径，它可以使我们像编写同步代码一样编写异步代码，其本质是Promise的语法糖。 async函数在定义的时候需要使用async关键词，如下： 123async function req1()&#123; //REQ&#125; async函数会返回一个Promise对象，可以使用then方法获取结果。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 具体的用法可以参考ECMAScript 6 入门 用async可以将上面请求的代码改写为: 12345678import &#123;req1, req2, req3&#125; from 'api.js'async function handleReq()&#123; let param1 = await req1() let param2 = await req2(param1) let param3 = await req3(param2) return param3&#125; 目前的问题有两个（第一个也许不算）： await命令只能在async函数中使用，而async返回的是一个promise对象，也就是说，我们必须最后再调用一个then()方法用于获取结果。（或许这不算什么问题，至少让嵌套次数减少到一次） 兼容性问题： 可以看出，IE完全不支持，chrome也到55版本才支持，所以兼容性是一个很大的问题。 但是如果在工程化的前端开发中，由于多了预编译过程，所以使用ES6的语法会被转义为ES5的可接受代码。比如vue-cli中，在初始化项目时就包含了babel。 阻塞代码在Node中还有一个问题是，没有sleep()这样的线程沉睡功能，能用做延时操作的只有setInterval和setTimeout。但这两个函数并不能阻塞后面的代码执行。 很多人会使用while方式实现阻塞，但是由于Node时单线程，所以使用while会持续占用CPU进行判断，这与真正的线程沉睡相差甚远我，完全破环了事件循环的调度。官方推荐的是使用setTimeout来实现，但是问题在于，setTimeout无法阻塞后面的代码运行。 setTimeout实现实现如下： 12345setTimeout(() =&gt; &#123; //TO DO AFTER 3 SECOND&#125;, 3000)otherFunc1()otherFunc2() 这里虽然定时器内的代码会被延迟执行，但是后面的otherFunc1()，otherFunc2()都会立即执行，这样不符合我们印象中的sleep() setTimeout配合async实现刚才我们讲过async会一直等待await后的语句执行完毕，才会执行后面的语句，所以我们可以利用这个点实现sleep功能。 123456789101112131415function sleep(interval) &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, interval); &#125;)&#125;// 用法async function one2FiveInAsync() &#123; for(let i = 1; i &lt;= 5; i++) &#123; console.log(i); await sleep(1000); &#125;&#125;one2FiveInAsync(); 当然，还有一个问题就是，我们使用sleep()的函数必须定义为async函数，也就是说，外部调用该函数时，也必须定义为async，或者处理Promise。 异步编程的解决方案事件发布订阅模式事件监听器模式是一种广泛应用于异步编程的模式，是回调函数的事件化，又称为发布订阅模式。具体实现可以参见之前写过的设计模式5-发布-订阅模式（观察者模式）。 Node自身提供的event模块是发布订阅模式的一个简单实现，Node中的部分模块抖继承自它，这个模块比前端浏览器中的大量DOM事件简单，不存在事件冒泡，也不存在preventDefault()，stopPropagation()和stopImmediatePropagatiom()等控制事件传递的方法（在14.5版本中，已经写出了Event类，实现了event.bubbles,event.cancelBubble()等方法，但是还没有实现，等待后面官方实现吧）。它具有addListener/om()，once()，removeListener()，removeAllListeners()和emit()等基本的事件监听模式的方法实现。时间发布/订阅模式的操作比较简单，示例代码如下： 12345678910111213const EventEmitter = require('events');class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter();//订阅myEmitter.on('event', () =&gt; &#123; console.log('触发事件');&#125;);//发布myEmitter.emit('event'); 事件发布订阅模式一般来说有两个用处： 业务逻辑解耦，事件发布者无须关注订阅的监听器如何实现业务逻辑，甚至不用关心有多少个监听器的存在，数据通过消息的方式可以很灵活地传递。 另一个角度来看，事件监听模式也是一种钩子（hook）机制，利用钩子导出内部数据或者状态给外部的调用者。 期中HTTP请求时经典场景： 1234567891011121314151617181920212223242526272829303132333435const postData = querystring.stringify(&#123; 'msg': '你好世界'&#125;);const options = &#123; hostname: 'nodejs.cn', port: 80, path: '/upload', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(postData) &#125;&#125;;const req = http.request(options, (res) =&gt; &#123; console.log(`状态码: $&#123;res.statusCode&#125;`); console.log(`响应头: $&#123;JSON.stringify(res.headers)&#125;`); res.setEncoding('utf8'); res.on('data', (chunk) =&gt; &#123; console.log(`响应主体: $&#123;chunk&#125;`); &#125;); res.on('end', () =&gt; &#123; console.log('响应中已无数据'); &#125;);&#125;);//监听事件req.on('error', (e) =&gt; &#123; console.error(`请求遇到问题: $&#123;e.message&#125;`);&#125;);// 将数据写入请求主体。req.write(postData);req.end(); 在HTTP请求的代码种，程序员只需要将视线放在error，data，end这些业务事件点上即可，至于内部的流程如何，无需过多关注。 值得一提的是：Node对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性而考虑的。 如果对一个事件添加超过了10个监听器，将会得到一条警告。这一处设计于Node自身单线程运行有关，设计设认为太多的监听器太多可能导致内存泄漏，所以会存在这样一条警告。 1(node:4004) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 event listeners added to [MyEmitter]. Use emitter.setMaxListeners() to increase limit 调用emitter.setMaxListeners()，参数设为0或者Infinity表示不限制监听器的数量。另一方面，由于时间发布会引起一系列监听器执行，如果事件相关的监听器过多，可能存在过多占用CPU的情景。 为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误出发了error事件，EventEmitter会检查是否有对error事件添加过监听器。如果添加了，这个错误会交由监听器处理，否则这个错误会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter示例应该对error事件进行处理。 Promise/Deferred模式使用时间的方式时，执行流程需要被余预先设定。即便是分支，也需要预先设定，这是由发布/订阅模式的运行机制所决定的。下面为普通的Ajax调用： 12345$.get('/api', &#123; success: onSuccess, error: onError, complete: onComplete&#125;) 在上面的异步调用中，必须严谨的设置目标。那么是否有一种先执行异步调用，延迟传递处理的方式呢？答案就是Promise/Deferred模式。 Promise/Deferred模式最早在JavaScript框架中出现于Dojo的代码中，被广为所知则是来自jQuery1.5版本，该版本几乎重写了Ajax部分，是的调用Ajax可以通过错如下的形式。 1234$.get('./api') .success(onSuccess) .error(onError) .complete(onComplete) 这使得即使不调用success()，error()等方法，Ajax也会执行。 在原始的API中，一个事件只能处理一个回调，而通过Deffered对象，可以对事件加入任意的业务处理逻辑，示例代码如下： 123$.get('/api') .success(onSuccess1) .success(onSuccess2) Promise/Deffered模式在2009年时被Kris Zyp抽象为一个提案，发布在CommonJS规范中。随着使用Promise/Deffered模式的应用逐渐增多，Promise/Deffered提案已经抽象出Promise/A、Promise/B、Promise/D等典型的模式。随后Promise/A规范已经成为EcmaScript的官方规范。ES6中的Promise规范即为Promise/A规范。 具体的Promise原理和手写可以看我的这两篇文章： Promise的实现 Promise理解 引用本文大部分参考《深入浅出nodejs》以及Node官网","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"NodeJS学习1-模块机制","slug":"NodeJS学习1-模块机制","date":"2021-04-22T11:28:08.000Z","updated":"2021-04-24T11:37:00.730Z","comments":true,"path":"2021/04/22/NodeJS学习1-模块机制/","link":"","permalink":"http://yoursite.com/2021/04/22/NodeJS%E5%AD%A6%E4%B9%A01-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/","excerpt":"","text":"CommonJS规范commonJS制定了一套模块的规范，来解决当时JavaScript中没有完善的模块机制，但是现在ES Module已经比较成熟了，在前端工程化开发中大部分都是用的ES Module来进行模块的导入导出。 由于内容比较多，之前在JavaScript中的模块导入导出中已经介绍过基本用法。详细的内容可以看这里。 Node的模块实现Node中，模块总的分为两类： 核心模块：由Node提供的模块 文件模块：由用户编写的模块 这两类模块都会经过以下三个步骤： 路径分析 文件定位 编译执行 注意： 核心模块部分在Node源代码中就被编译为了二进制文件。Node在启动时即被载入到内存中，所以这部分核心模块在引入的时候，文件定位和编译执行这两个步骤可以省略掉，所以其加载速度要快于文件模块。文件模块则是在运行时动态加载的，需要完整的路径分析，文件定位和编译执行过程，所以起运行速度要慢于核心模块。 Node是默认缓存加载为第一优先级，无论是核心模块还是文件模块。require()方法对相同模块的二次加载一律采用缓存优先的方式。 路径分析由于require()函数接受多种标识符，所以不同标识符也有不同的分析方法。大致分为以下几类： 核心模块，如：http, fs, path等 以.或..开始的相对路径文件模块 以/开始的绝对路径文件模块 非核心路径的文件模块，如自定义的connect模块 核心模块核心模块的优先级仅次于缓存加载，其在Node中的源代码编译过程中已经编译为了二进制代码，其加载速度最快。 由于其优先级高于自定义模块，所以我们定义一个标识符与核心模块相同的自定义模块是无法被成功加载的。 路径形式的文件模块以.或..开始的标识符，都会被当作文件模块来处理。并且在初次加载时会将其转换为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。 自定义模块自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种页数的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。这与CommonJS中规定的node_modules的模块文件夹有关，但是在Node中的自定义模块的查找是一个与JavaScript中原型链查找相似，Node首先查找当前目录下的node_modules文件夹下是否存在该模块（注意这里的文件名在下面讲），然后查看父级目录下的node_modules是否存在该模块，再查看父级目录的父级目录是否存在node_modules，形成了一个链。只要在更近一层中发现该模块，即不再向外查找。 由于这种递归式的查找，所以其速度是最慢的。 模块路径： 模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。其本质就是前面提到的，当前目录下的mode_modules文件夹，父级目录下的mode_modules文件夹，父级目录的父级目录下的node_modules。 所以当我们新建一个js文件（该文件可以放在任意目录下），然后输入console.log(module.paths)。 执行该文件后就会得到一个类似下面数组的输出： 123456[ '/home/aa/bb/node_modules', '/home/aa/node_modules', '/home/node_modules', 'node_modules'] 文件定位文件扩展名分析require()函数接受不包含扩展名的文件标识符。这种情况下，Node会按.js，.json，node的次序补足扩展名，依次尝试。 在尝试的过程中，需要调用fs模块同步阻塞式的判断文件是否存在，由于Node是单线程的，所以这里可能会引起一点性能问题。所以，在使用node，json文件时，加上扩展名，会稍微提高一点速度。另外就是可以使用缓存机制，也可以大幅度的环节Node单线程阻塞调用的缺陷。 目录分析和包在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有发现对应文件，但是确得到了一个目录，这在引入自定义模块和组个模块路径进行查找时经常出现。此时，Node会将该目录作为一个包来处理。 此时，Node会在当前目录下查找package.json文件（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象。从中取得mian属性指定的文件进行定位。如果文件名缺少扩展名，将会重复上面的扩展名分析过程。 如果mian属性指定的文件名错误，或者和没有package.json文件，Node会将index当作默认文件名，然后依次尝试查找index.js,index.json,index.node。 如果上面的过程都没有定位到任何文件，则定义模块进入下一个模块路径（上一级路径）进行查找。 如果所有路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。 模块编译在Node中，每个文件模块都是一个对象，它的定义如下： 12345678910function Module(id, parent)&#123; this.id = id this.exports = &#123;&#125; if(parent &amp;&amp; parent.children)&#123; parend.child.push(this) &#125; this.filename = null this.loaded = false this.children = []&#125; 编译和执行时引入文件模块的最后一个阶段。定位到具体文件后，Node会新建一个模块对象，然后根据路径载入并编译。具体不同的文件会有不同的处理方法： js文件：通过fs模块同步读取文件后编译执行。 node文件：用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生效的文件。 json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果。 其余扩展名文件：它们会被当作js文件载入。 JavaScript模块的编译在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function(exports, require, __filename, __dirname){\\n，在尾部添加了\\n})，则一个正常的JavaScript文件会被包装成如下的样子： 123456(function(exports, require, module, __filename, __dirname)&#123; let math = require('math') export.area = function(radius)&#123; return math.PI * radius * radius &#125;&#125;) 即形成了一个闭包，这样每个模块文件之间都进行了作用域隔离。包装过后的代码会通过vm原生的runInThisContext()方法执行（类似于eval，只是具有明确的上下文，不污染全局），返回一个function对象。在这一个过程后，模块就会具有exports属性,require方法，module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个funciton执行。 注意：模块中的exports是module.export的一个形参传递，所以我们必须向module.export添加对象，否则无法添加导出属性。 C/C++模块的编译Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和*nix平台下分别有不同的实现，通过libnv兼容层进行了封装。 实际上，.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译产生的，所以这里只有加载和执行过程。在执行过程中，模块的exports对象与.node魔窟啊产生联系，然后返回给调用者。 C/C++模块给Node使用者带来的优势主要是执行效率方面的，劣势则是C/C++模块的编写门槛比JavaScript高。 JSON文件的编译.json文件的编译是3种编译方式中最简单的。Node利用fs模块同步读取JSON文件文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋值给模块对象的exports，以供外部调用。 JSON文件在用做项目的配置文件时比较有用。如果你定义了一个JSON文件作为配置，那就不必调用fs模块去异步读取和解析，直接调用require()即可引入。 核心模块Node的核心模块在编译成为可执行文件的过程中被编译进了二进制文件，核心模块也分为C/C++编写的和JavaScript编写的两部分，期中C/C++文件存放在Node项目中的src目录下，JavaScript文件存放在lib目录下。 JavaScript核心模块的编译过程在编译所有C/C++文件之前，编译程序需要将所有的JavaScript模块文件编译为C/C++代码，但此时并不会将其编译为可以执行的C/C++代码，而是将其以字符串的形式存储在数组中。具体过程如下： 转存为C/C++代码Node采用了V8自带的js2c.py工具，将所有内置的JavaScript代码（src/node.js和lib/*.js）转换为C++里的数组，生成node_natives.h头文件中。 在这个过程中，JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。 编译JavaScript核心模块lib目录下的所有文件也没有定义require,module,exports这些变量。所以也需要经历文件模块的编译过程。但与文件模块不同的是：获取源代码的位置，核心模块在启动时就被载入内存，所以调用时是直接从内存中取；而文件模块还需要从磁盘中读取。这个速度差别很大。 在代码实现中是通过process.binding(&#39;natives&#39;)取出，编译成功的模块缓存到NativeModule._cache对象中，文件模块则缓存到Module._cache上。 123456789function NativeModule(id)&#123; this.fileName = id + '.js' this.id = id this.exports = &#123;&#125; this.loading = false&#125;NativeModule._source = process.binding('navives')NativeModule._cache = &#123;&#125; C/C++模块的编译过程在核心模块中，大致分为两类： 全部由C/C++编写，我们称为内建模块。 由C/C++完成核心部分，其他部分则由JavaScript实现包装或向外导出。 第二种情况下 一 般是以C/C++完成核心功能，由JavaScript实现包装或向外导出，这样可以平衡脚本语言与静态语言的开发速度与运行效率。 内建模块的组织形式在Node中，内建模块的内部结构定义如下，其在node.h中： 1234567891011struct node_module &#123; int nm_version; unsigned int nm_flags; void* nm_dso_handle; const char* nm_filename; node::addon_register_func nm_register_func; node::addon_context_register_func nm_context_register_func; const char* nm_modname; void* nm_priv; struct node_module* nm_link;&#125;; 每个内建模块在定义之后，都通过NODE_MODULE宏定义到node命名空间中，模块的具体初始化方法挂在为结构的register_func成员： 12345678910#define NODE_MODLE(modname, regfunc)&#123; extern \"C\"&#123; NODE_MODULE_EXPORT node::node_module_struct modname ## _module= &#123; NODE_STANDARD_MODULE_STUFF, regfunc, NODE_STRINGFY(modename) &#125; &#125;&#125; node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有： node_buffer node_crypto node_evals node_fs node_http_parser node_os node_zlib node_timer_wrap node_udp_wrap node_pipe_wrap node_cares_wrap node_tty_wrap node_process_wrap node_fs_event_wrap node_signal_watcher 这些内建模块通过Node提供的get_buildin_module()方法从node_module_list数组中取出这些模块。 内建模块的优势： 由C/C++编写，所以性能上由于脚本语言。 直接被加载收到内存中，速度快于从磁盘中查找。 内建模块的导入导出通常来说，在Node中，由JavaScript编写的核心模块依赖于C/C++编写的内建模块。而文件模块一般依赖于核心模块，而不是直接调用内建模块。 Node在启动时候，会生成一个全局变量process，并会提供一个Binding()方法用来协助内建模块。 C/C++扩展模块C/C++扩展模块是属于文件模块得一类。C/C++模块通过预编译为.node文件，在调用process.dlopen()方法来加载执行。 注意：.node文件实际上是编译过后得二进制文件，所以在不同平台下是不同的，在Windows下，其就是一个.dll文件，在*nix下，其是一个.so文件，加一个.node是为了看起来更自然。 在dlopen()中，实现了分平台加载.so，.dll的方法。 所以一个不同的.node文件是无法混用的，必须重新在其平台下编译成正确的.node文件。 前提条件 GYP项目生成工具：Node编译工具，可以通过npm install -g node-gyp命令安装。 V8引擎C++库：V8是Node自身动力来源之一。它自身由C++写成，可以实现JavaScript与C++互相调用。 libuv库：libuv也是Node自身的动力来源之一。其是一个跨平台的一层封装，通过它去调用一些底层操作，比自己在各个平台下编写实现要高效得多。libuv封装得功能包括事件循环、文件操作等。 Node内部库：写C++模块时，免不了要做一些面向对象得编程工作，而Node自身提供了一些C++代码，比如node::ObjectWrap类可以用来包装你的自定义类，它可以帮助实现对象回收等工作。 其他库：其他存在deps目录下的库在编写扩展模块时也许可以帮助你，比如zlib,openssl,http_parser等。 C/C++扩展模块的编写与核心模块的编写不同，普通的扩展模块不需要无须将源代码编译进Node，而是通过dlopen()方法动态加载。所以在编写普通模块时，无须将源代码写入node命名空间，也不需要提供头文件。 例子编写JavaScript写法： 123exports.sayHello = function()&#123; return 'Hello world'&#125; C++写法： 12345678910111213141516171819202122232425// hello.cc#include &lt;node.h&gt;namespace demo &#123;using v8::FunctionCallbackInfo;using v8::Isolate;using v8::Local;using v8::Object;using v8::String;using v8::Value;void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); args.GetReturnValue().Set(String::NewFromUtf8( isolate, \"Hello world\").ToLocalChecked());&#125;void Initialize(Local&lt;Object&gt; exports) &#123; NODE_SET_METHOD(exports, \"sayHello\", Method);&#125;NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)&#125; // 命名空间示例 编译在不同的平台都可以使用GYP工具进行编译。 首先需要编写.gyp项目文件。node-gyp约定.gyp文件为bidning.gyp，其内容示例如下： 123456789101112131415161718&#123; 'target': [ &#123; 'target_name': 'hello', 'source': [ 'src/hello.cc' ], 'condition': [ [ 'OS == \"win\"', &#123; 'libraries': ['-lnode.lib'] &#125; ] ] &#125; ]&#125; 然后调用 1$ node-gyp configure 接下来会生成一些其他文件，在*nix平台下，会生成Makefile等文件；在Windows下，则会生成vcxproj等文件。 1node-gyp build 此时gyp会根据平台，分别进行make或vcbuild进行编译。编译完成后，hello.node文件会生成了build/Release目录下。 注意： Node.js 使用了静态链接库，比如 V8、libuv 和 OpenSSL。 所有的插件都需要链接到 V8，也可能链接到任何其他的依赖项。 通常情况下，只要简单地引入相应的 #include &lt;...&gt; 声明（如 #include &lt;v8.h&gt;），则 node-gyp 将会自动地定位到相应的头文件。 但是也有一些注意事项需要留意： 当 node-gyp 运行时，它将会检测指定的 Node.js 发行版本，并下载完整的源代码包或只是头文件。 如果下载了完整的源代码，则插件将会具有对完整的 Node.js 依赖项的完全访问权限。 如果只下载了 Node.js 的头文件，则只有 Node.js 公开的符号可用。 可以使用 --nodedir 标志指向本地的 Node.js 源代码镜像来运行 node-gyp。 如果使用此选项，则插件将有权访问全部依赖项。 注意：工具之间存在兼容性问题，最开始我在实验时的版本是: Visual Studio -2019 Node.js -12.14.0 node-gym -8.0.0 python -3.9 结果一直报语法错误，示例如下： 12345678910111213 Hello.ccD:\\Test\\Node\\native\\Hello.cc(16,25): error C2039: \"ToLocalChecked\": 不是 \"v8::Local&lt;v8::String&gt;\" 的成员 [D:\\Test\\Node\\native\\build\\hello.vcxproj]C:\\Users\\Administrator\\AppData\\Local\\node-gyp\\Cache\\12.14.0\\include\\node\\v8.h(1311): message : 参见“v8::Local&lt;v8::String&gt;”的声明 [D:\\Test\\Node\\native\\build\\hello.vcxproj]gyp ERR! build error gyp ERR! stack at ChildProcess.onExit (C:\\Users\\Administrator\\AppData\\Roaming\\nvm\\v12.14.0\\node_modules\\node-gyp\\lib\\build.js:194:23)gyp ERR! stack at ChildProcess.emit (events.js:210:5)gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12)gyp ERR! System Windows_NT 10.0.19042gyp ERR! command \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js\" \"build\"gyp ERR! cwd D:\\Test\\Node\\nativegyp ERR! node -v v12.14.0gyp ERR! node-gyp -v v8.0.0gyp ERR! not ok 网上貌似错误经验不多，我折腾了很久，最后决定换以下node版本，这里使用了nvm版本切换工具。转为最新的15.5.1版本，然后就成功构建了。 C/C++扩展模块的加载得到hello.node文件后，直接通过require()方法来进行标识符解析，路径解析，文件定位，然后加载执行即可。 示例123//main.jsconst hello = require('./build/Release/hello.node')console.log(hello.sayHello()) 调用流程实际上，require()在引入.node文件的过程中，实际上经历了4个层面上的调用。 加载.node文件实际上经历了两个步骤： 调用uv_dlopen()方法去打开动态链接库。 调用uv_dlsym方法找到动态链接库中通过NODE_MODULE宏定义的方法地址。 这两个步骤都是通过libuv库进行封装的： 在*nix平台下实际上调用的是dlfcn.h头文件中定义的dlopen()和dlsym()两个方法； 在Windows平台则是通过LoadLibraryExW()和GetProcAddress()这两个方法实现的。他们分别加载.so和.dll文件（即.node文件） 即我们一般不直接调用process.dlopen()，而是通过require()来获取编写的Node模块。在process.md中写到： process.dlopen(module, filename[, flags]) * module {Object} * filename {string} * flags {os.constants.dlopen} \\Default:** os.constants.dlopen.RTLD_LAZY The process.dlopen() method allows dynamically loading shared objects. It is primarily used by require() to load C++ Addons, and should not be used directly, except in special cases. In other words, [require()][] should be preferred over process.dlopen() unless there are specific reasons such as custom dlopen flags or loading from ES modules. 所以最后总结一下Node中各种模块之间的关系则为： 引用本文大部分参考《深入浅出nodejs》 以及： C++ 插件 node-gyp","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"模块","slug":"模块","permalink":"http://yoursite.com/tags/%E6%A8%A1%E5%9D%97/"}]},{"title":"设计模式6-命令模式与组合模式","slug":"设计模式6-命令模式与组合模式","date":"2021-04-21T02:06:08.000Z","updated":"2021-04-24T14:45:51.743Z","comments":true,"path":"2021/04/21/设计模式6-命令模式与组合模式/","link":"","permalink":"http://yoursite.com/2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"命令模式定义命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 主要解决在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 优缺点优点 通过引入中间件（抽象接口）降低系统的耦合度。 扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。 可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。 缺点 可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。 命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。 实现主要角色 抽象命令类（abstract command）：声明执行的接口，拥有执行命令的抽象方法execute()。 具体命令类（concrete command）：是抽象类的具体实现类，它拥有接收者对象，并通过调用接受者的功能来完成命令要执行的操作。 接收者（receiver）：执行命令功能的相关操作，是具体命令对象业务的真正实现者。 调用者（invoker）：是请求的发送者，他通常拥有很多的命令对象，并通过访问命令对象来执行相关操作，它不直接访问接收者。 代码这里以一个 抽象命令接口 1234//Order.javapublic interface Order &#123; void execute();&#125; 具体命令类 123456789101112//BuyStock.javapublic class BuyStock implements Order &#123; private Stock abcStock; public BuyStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.buy(); &#125;&#125; 123456789101112//BuyStock.javapublic class BuyStock implements Order &#123; private Stock abcStock; public BuyStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.buy(); &#125;&#125; 请求类 12345678910111213141516//Stock.javapublic class Stock &#123; private String name = \"ABC\"; private int quantity = 10; public void buy()&#123; System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] bought\"); &#125; public void sell()&#123; System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] sold\"); &#125;&#125; 命令调用类 12345678910111213141516171819//Broker.javaimport java.util.ArrayList;import java.util.List; public class Broker &#123; private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); public void takeOrder(Order order)&#123; orderList.add(order); &#125; public void placeOrders()&#123; for (Order order : orderList) &#123; order.execute(); &#125; orderList.clear(); &#125;&#125; 使用 Broker 类来接受并执行命令。 1234567891011121314151617public class CommandPatternDemo &#123; public static void main(String[] args) &#123; Stock abcStock = new Stock(); //新建具体命令 BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); //创建执行类 Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); //执行 broker.placeOrders(); &#125;&#125; 图解 JavaScript中的命令模式在JavaScript中，我们无须那么麻烦的创建类。由于函数在JS中作为一等公民，本身就可以作为参数进行传递。所以不一定要将其封装在execute方法中，而是直接将其作为字面量对象的成员进行传递。 比如按钮点击事件的添加： 12345678910111213141516171819202122let bindClick = function(button, func)&#123; button.onClick = func&#125;let MenuBar = &#123; refresh: function()&#123; console.log('刷新子菜单') &#125;&#125;let SubMenu = &#123; add: function()&#123; console.log('添加子菜单') &#125;, del: function()&#123; consle.log('删除子菜单') &#125;&#125;bindClick(button1, MenuBar.refresh)bindClick(button2, SubMenu.add)bindClick(button3, SubMenu.del) 组合模式定义组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 主要解决它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 宏命令宏命令包含了一组具体的子命令对象，不管是宏命令，还是子命令，都有一个execute方法负责执行命令。 1234567891011121314151617181920212223242526272829303132333435363738let CloseDoorCommand = &#123; execute: function()&#123; console.log('关门') &#125;&#125;let openPCCommand = &#123; execute: function()&#123; consoloe.log('开电脑') &#125;&#125;let openQQCommand = &#123; execute: function()&#123; console.log('登录QQ') &#125;&#125;let MacroCommand = function()&#123; return &#123; commandList : [], add: function(command)&#123; this.commandList.push(command) &#125;, execute: function()&#123; for(let c of this,commandList)&#123; c.execute() &#125; &#125; &#125;&#125;let macroCommand = MacroCommand()macroCommand.add(CloseDoorCommand)macroCommand.add(openPCCommand)macroCommand.add(openQQCommand)macroCommand.execute() 在组合模式中，请求在树中传递总是遵循一种逻辑。 请求从树最顶端的对象向下传递，如果当前请求的对象是叶对象（普通子命令），也对象自身会对请求做出相应的处理；如果当前请求的对象是组合对象（宏命令），组合对象则会遍历它下属的子节点，将请求传递给这些子节点。 图解","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"命令模式","slug":"命令模式","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"name":"组合模式","slug":"组合模式","permalink":"http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"}]},{"title":"Node节点的操作","slug":"Node节点的操作","date":"2021-03-22T07:41:53.000Z","updated":"2021-03-23T12:34:17.660Z","comments":true,"path":"2021/03/22/Node节点的操作/","link":"","permalink":"http://yoursite.com/2021/03/22/Node%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"DOM操作Node 是一个接口，各种类型的 DOM API 对象会从这个接口继承。它允许我们使用相似的方式对待这些不同类型的对象；比如, 继承同一组方法，或者用同样的方式测试。 这里我们不谈其属性，只关注Node节点的操作。 Node.appendChild()Node.appendChild(aChild)方法将一个节点附加到指定父节点的子节点列表的末尾处。 值得注意的是： 该方法只接受一个参数 其参数必须是一个Node，不能接受DOMString对象 如果aChild已存在文档中，则该方法会先remove该节点，再在目标位置插入节点 其会返回插入的子节点（aChild） 兼容性如下，可以说是最起始一部分操作方法了。 ParentNode.append() ParentNode.append 方法在 ParentNode的最后一个子节点之后插入一组 Node对象或 DOMString对象。 被插入的 DOMString对象等价为 Text节点。 与appendChild不同的是： 允许追加 DOMString 对象，而 Node.appendChild() 只接受 Node 对象。 没有返回值，而 Node.appendChild() 返回追加的 Node 对象。 可以追加多个节点和字符串，而 Node.appendChild() 只能追加一个节点。 这个方法的兼容性相对差一些，但是功能全面。 Node.insertBefore()Node.insertBefore() 方法在参考节点之前插入一个拥有指定父节点的子节点。函数返回被插入过的子节点。 注意： 如果给定的子节点是对文档中现有节点的引用，insertBefore() 会将其从当前位置移动到新位置 语法1var insertedNode = parentNode.insertBefore(newNode, referenceNode); insertedNode 被插入节点(newNode) parentNode 新插入节点的父节点 newNode 用于插入的节点 referenceNode newNode 将要插在这个节点之前 如果 referenceNode 为 null 则 newNode 将被插入到子节点的末尾。 兼容性 Node.removeChildNode.removeChild() 方法从DOM中删除一个子节点。返回删除的节点。 语法12345let oldChild = node.removeChild(child);//ORelement.removeChild(child); child 是要移除的那个子节点. node 是child的父节点. oldChild保存对删除的子节点的引用. oldChild === child. 注意： 被移除的这个子节点仍然存在于内存中,只是没有添加到当前文档的DOM树中,因此,你还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量比如上例中的oldChild来保存这个节点的引用. 如果使用上述语法中的第二种方法, 即没有使用 oldChild 来保存对这个节点的引用, 则认为被移除的节点已经是无用的, 在短时间内将会被内存管理回收. Node.replaceChild()Node.replaceChild() 方法用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。 语法1let node = parentNode.replaceChild(newChild, oldChild); newChild 用来替换 oldChild 的新节点。如果该节点已经存在于 DOM 树中，则它首先会被从原始位置删除。 oldChild 被替换掉的原始节点。 兼容性 Node.cloneNodeNode.cloneNode()方法返回调用该方法的节点的一个副本. 语法1var dupNode = node.cloneNode(deep); node 将要被克隆的节点 dupNode 克隆生成的副本节点 deep 可选 是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身. 注意: 在 DOM4 规范中(实现于Gecko 13.0(Firefox 13.0 / Thunderbird 13.0 / SeaMonkey 2.10))，deep是一个可选参数。如果省略的话，参数的默认值为 true，也就是说默认是深度克隆。如果想使用浅克隆, 你需要将该参数设置为 false。 在最新的规范里，该方法的行为已经改变了，其默认值变成了 false。虽然该参数仍旧是可选的，但是你必须要为该方法设置 deep 参数，无论是为了向前还是向后兼容考虑。假如开发者没设置参数的话，Gecko 28.0 (Firefox 28 / Thunderbird 28 / SeaMonkey 2.25 / Firefox OS 1.3)) 版本的控制台会发出警告。从 Gecko 29.0 (Firefox 29 / Thunderbird 29 / SeaMonkey 2.26)) 开始该方法默认为浅复制而不是深度复制。 值得注意的是： 克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如onclick=&quot;alert(1)&quot;),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件。 在使用Node.appendChild()或其他类似的方法将拷贝的节点添加到文档中之前,那个拷贝节点并不属于当前文档树的一部分,也就是说,它没有父节点。 如果deep参数设为false,则不克隆它的任何子节点.该节点所包含的所有文本也不会被克隆,因为文本本身也是一个或多个的Text节点。 兼容性 注意:为了防止一个文档中出现两个ID重复的元素,使用cloneNode()方法克隆的节点在需要时应该指定另外一个与原ID值不同的ID Node.containsNode.contains()返回的是一个布尔值，来表示传入的节点是否为该节点的后代节点。 语法1node.contains( otherNode ) node 是否包含otherNode节点. otherNode 是否是node的后代节点. 如果 otherNode 是 node 的后代节点或是 node 节点本身.则返回true , 否则返回 false. 兼容性 Node.isEqualNode Node.isEqualNode()方法可以判断两个节点是否相等。当两个节点的类型相同，定义特征(defining characteristics)相同（对元素来说，即 id，孩子节点的数量等等），属性一致等，这两个节点就是相等的。一些具体的数据指出：多数时候的比较是根据节点的类型来的。 语法1var isEqualNode = node.isEqualNode(otherNode); otherNode: 比较是否相等的节点. 注意：这里的equal与===不同，用===比较时，比较的是node的唯一id。而这里是鸭子比较法。 Node.hasChildNodeshasChildNodes方法返回一个布尔值,表明当前节点是否包含有子节点. 总结有三种方法可以判断当前节点是否有子节点。 node.firstChild !== null node.childNodes.length &gt; 0 node.hasChildNodes() 附加可以使用element标签的innerHTML与innerText属性。以及insertAdjacentHTML方法来修改元素内部的值。 element.innerHTMLElement.innerHTML 属性设置或获取HTML语法表示的元素的后代。 注意：如果一个 , , 或 节点有一个文本子节点，该节点包含字符 (&amp;), (&lt;), 或(&gt;), innerHTML 将这些字符分别返回为&amp;, &lt; 和 &gt; 。使用Node.textContent 可获取一个这些文本节点内容的正确副本。 语法12const content = element.innerHTML;element.innerHTML = htmlString; DOMString包含元素后代的HTML序列。设置元素的 innerHTML 将会删除所有该元素的后代并以上面给出的 htmlString 替代。 注意： SyntaxError ​ 当 HTML 没有被正确标记时，设置 innerHTML 将会抛出语法错误。 NoModificationAllowedError ​ 当父元素是 Document 时，设置 innerHTML 将会提示不允许修改。 安全问题用 innerHTML 插入文本到网页中并不罕见。但这有可能成为网站攻击的媒介，从而产生潜在的安全风险问题。 12345678const name = \"John\";// assuming 'el' is an HTML DOM elementel.innerHTML = name; // harmless in this case// ...name = \"&lt;script&gt;alert('I am John in an annoying alert!')&lt;/script&gt;\";el.innerHTML = name; // harmless in this case 尽管这看上去像 cross-site scripting 攻击，结果并不会导致什么。HTML 5 中指定不执行由 innerHTML 插入的script标签。 然而，有很多不依赖&lt;script&gt;标签去执行，innerHTML 去设置你无法控制的字符串时，这仍然是一个安全问题。例如： 12const name = \"&lt;img src='x' onerror='alert(1)'&gt;\";el.innerHTML = name; // shows the alert 于这个原因，当插入纯文本时，建议不要使用 innerHTML 。取而代之的是使用 Node.textContent或者element.innerText，它不会把给定的内容解析为 HTML，它仅仅是将原始文本插入给定的位置。 兼容性 HTMLElement.innerTextinnerText 属性表示一个节点及其后代的“渲染”文本内容。与innerText一样，其可以作为一个getter，其作为一个getter的时候，获取的内容与用户光标选中后复制的内容差不多 Note: innerText 很容易与Node.textContent混淆, 但这两个属性间实际上有很重要的区别. 大体来说, innerText 可操作已被渲染的内容， 而 textContent 则不会. Node.textContentNode 接口的 textContent 属性表示一个节点及其后代的文本内容。 返回值textContent 的值取决于具体情况： 如果节点是一个 document，或者一个 DOCTYPE ，则 textContent 返回 null。 如果节点是个 CDATA section、注释、processing instruction或者 text node，textContent 返回节点内部的文本内容，例如 Node.nodeValue。 对于其他节点类型，textContent 将所有子节点的 textContent 合并后返回，除了注释和processing instructions。（如果该节点没有子节点的话，返回一个空字符串。） 注意：在节点上设置 textContent 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。 与 innerText 的区别 textContent 会获取所有元素的内容，包括&lt;script&gt;和&lt;style&gt;元素，然而 innerText 只展示给人看的元素。 textContent 会返回节点中的每一个元素。相反，innerText 受 CSS 样式的影响，并且不会返回隐藏元素的文本， 此外，由于 innerText 受 CSS 样式的影响，它会触发回流（ reflow ）去确保是最新的计算样式。（回流在计算上可能会非常昂贵，因此应尽可能避免。） 与 textContent 不同的是, 在 Internet Explorer (小于和等于 11 的版本) 中对 innerText 进行修改， 不仅会移除当前元素的子节点，而且还会永久性地破坏所有后代文本节点。在之后不可能再次将节点再次插入到任何其他元素或同一元素中。 兼容性 参考MDN","categories":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/categories/DOM/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"HTTP缓存","slug":"HTTP缓存","date":"2021-03-11T02:52:31.000Z","updated":"2021-03-11T04:26:24.396Z","comments":true,"path":"2021/03/11/HTTP缓存/","link":"","permalink":"http://yoursite.com/2021/03/11/HTTP%E7%BC%93%E5%AD%98/","excerpt":"","text":"http缓存概念http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源（是否使用缓存还需其他策略进行验证）。 常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。 http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。 http缓存的分类强缓存定义强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。 优缺点优点 直接使用本地缓存，不发送请求，因此响应速度快 缺点 可能无法及时更新服务器资源，造成站点资源的滞后更新 header字段强缓存是通过http返回头部重的Expires或者Cache-Control两个字段来控制的。 Expires该字段会返回一个绝对时间，表示该资源的失效时间，在这个时间之前，都可以直接使用缓存，即命中缓存。 比如上面的图即表示在2021年3月11日03:28:54之前该缓存都有效，即服务器可以使用强缓存，不再请求服务器。 但是这样的绝对时间也会存在问题，即浏览器在校验时间的时候，是根据client的本地时间来确定的，当本地时间与服务器差距较大时，可能存在问题。所以衍生了Cache-Control Cache-Control由于上面的问题，Cache-Control返回的就是一个相对时间，以秒为单位。由于是相对时间，并且开始就是和客户端时间相比的，所以即使客户端与服务端时间存在误差，也不会存在误差问题。 其可以是键值对或者一个单值： 单值是一个数字，如：Cache-Control:3600，代表缓存的有效期为3600s。 键值对包含以下属性： max-age 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 * 60）天，第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。 s-maxage 同 max-age，覆盖 max-age、Expires，但仅适用于共享缓存，在私有缓存中被忽略。 public 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。 private 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。 no-cache 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。 no-store 禁止缓存，每次请求都要向服务器重新获取数据。 must-revalidate指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。 比如上面的Cache-Control的max-control为max-age=600，即600s，10mins的有效期 协商缓存（当强缓存不满足的时候）协商缓存即还需要向服务器发送一个请求，根据服务器的返回消息来决定是否使用缓存。即如果命中，则http返回304，浏览器从缓存中加载资源。其是根据返回信息的HTTP头部的Last-Modify/If-Modify-Since或Etag/If-None-Match来决定是否命中协商缓存。 优缺点优点 时效性更高，根据服务器的返回消息决定是否使用缓存。 缺点 载入速度相对会降低，因为会向服务器发送请求。 header字段Last-Modify/If-Modify-Since浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。 当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。 ETag/If-None-Match与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。 ETag生成因子以Apache为例，ETag生成靠以下几种因子 文件的i-node编号，此i-node非彼iNode。是Linux/Unix用来识别文件的编号。是的，识别文件用的不是文件名。使用命令’ls –I’可以看到。 文件最后修改时间 文件大小生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。所以，理论上ETag也是会重复的，只是概率小到可以忽略。 Last-Modified相对与Etag的问题 Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。 Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。 Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 总结 参考 一文读懂http缓存（超详细） HTTP缓存机制","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"经典1-在浏览器地址栏输入URL后回车，背后所经历的步骤","slug":"经典1-在浏览器地址栏输入URL后回车，背后所经历的步骤","date":"2021-03-05T02:17:36.000Z","updated":"2021-03-11T08:57:22.494Z","comments":true,"path":"2021/03/05/经典1-在浏览器地址栏输入URL后回车，背后所经历的步骤/","link":"","permalink":"http://yoursite.com/2021/03/05/%E7%BB%8F%E5%85%B81-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%9B%9E%E8%BD%A6%EF%BC%8C%E8%83%8C%E5%90%8E%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"在浏览器地址栏输入URL后回车，背后所经历的步骤浏览器层面0、URL解析现在几乎所有浏览器都实现了地址栏快捷搜索的功能，所以这里需要判断用户输入的到底是关键词还是地址，然后进行不同的操作。 关键字使用浏览器内置的搜索引擎地址与关键词来拼接得到最终的URL。 URL对URL进行补全，编码转换等工作。 例如：用户在输入URL时，一般都不会携带协议与端口。当用户输入baidu.com的时候，浏览器会将其补全为： https://baidu.com:80。 chrome默认是补全https协议 其他操作浏览器还会进行其他操作，比如 历史记录缓存检查这一步即可以让我们直接访问之前访问过的URL。 访问限制有些浏览器会对部分网站进行拦截。 1、缓存检查根据浏览器缓存原则，其会优先检查本地是否已经有缓存文件，然后再向服务器发送请求，具体流程如下： 2.1、 浏览器检查DNS缓存（DNS查询1）浏览器检查自己是否有该域名的DNS的缓存。 操作系统层面2.2、 操作系统检查DNS缓存（DNS查询2）如果浏览器查询DNS失败，则调用系统的API进行DNS查询，系统则会先检查自己的本地缓存文件。 2.3、 路由器检查DNS缓存（DNS查询3）系统在本地文件中没有发现改DNS条目的时候，请求会依次向上请求，其中路由器也会保有自己的DNS表，也会进行查询。 2.4、ISP(Internet Service Provider) DNS缓存即互联网服务提供商（移动、联通、典型等）的DNS缓存服务器。 2.5、根域名服务器查询DNS缓存根域名服务是最高层次的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。 如果上面几步都没有查询到对应的DNS缓存，则请求会被发送到根域名服务器查询。 2.6、顶级域名服务器查询（如：org域名服务器、com域名服务器、deu域名服务器）在多数情况下，根域名服务器并不会直接返回IP地址，而是告诉请求应该去请求哪一个顶级服务器（即告诉该顶级服务器的IP地址，系统再请求顶级服务器拿到目标IP地址） 注意：应用层的DNS（域名系统）在传输层采用的是UDP协议。下面是运输层与应用的对应： 建立TCP链接由于HTTP协议是建立在TCP协议之上，所以客户端与服务器之间需要先建立TCP连接，然后再在TCP连接之上发送HTTP请求。 注意：在五层协议中： 应用层 传输层 网络层 数据链路层 物理层 中，上面4层都会有一个头部head来对正文进行封装，物理层传输的数据单位是bit，所以流程大概如下： 在服务器接受到数据包后，会对报文进行一层一层的去头部，并在每层进行处理，主要是在传输层，TCP协议会进行连接确定，即三次握手过程。 第一次 第一次握手：建立连接时，客户端发送syn包（初始序号seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。注意：这个请求不能带数据，但是会消耗一个序号。 第二次 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包（即把报文中的SYN和ACK都设为1），此时服务器进入SYN_RECV状态。 第三次 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 HTTP请求客户端请求由于HTTP是无状态的，所以HTTP只能一次一次的进行。在客户端与服务器建立TCP连接后，客户端开始发送HTTP请求，此处URL的请求是GET方式的。 服务器返回接受请求在HTTP请求到达服务器之后，一般会有一些容器来监听HTTP请求，具体的容器有： Apache Nginx IIS 这些容器会开启一个子进程来处理这个请求。 处理请求接受HTTP报文后，会对其进行解析，获得其中的一些参数（请求方法、域名、路径、来源等），然后对其中的一些参数进行验证： 验证是否接受此方法 验证请求的地址是否正确 等 重定向如果服务器对该请求地址配置了HTTP重定向，则会返回301永久重定向响应，浏览器会根据响应，重新发送HTTP请求到重定向地址。 浏览器层面（接受HTTP请求）浏览器在接受到服务器的响应消息后，会对资源进行分析。 首先是分析Response header，根据状态码做具体的动作。 如果进行了压缩（比如gzip），还需要进行解压。 然后对相应资源做缓存。 然后根据响应资源里的MIME类型去解析响应内容（比如HTML，JSON等） 渲染页面（如果响应是HTML文件）浏览器渲染过程很复杂，其基本流程为： HTML解析（构建DOM树）1. 解码（encoding）传输回来的其实一些二进制数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML代码。 2.预解析（pre-parsing）预解析做的事情是提前加载资源，减少处理事件，系统会识别一些请求资源的属性，比如img标签，video的src属性，并将其加入到请求队列中。 3. 符号化（Tokenization）符号化就是词法分析的过程，将HTML代码解析成为符号，HTML符号包括，开始标签、结束标签、属性名和属性值。 4. 构建树 注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。 在上一步符号化中，解析器获得这些标记，然后以合适的方法创建DOM对象并把这些符号插入到DOM对象中。 CSS解析（构建CSSOM树）当CSS被下载后，CSS解析器就会处理任何CSS，根据语法规范解析出所有的CSS并进行标记化，然后我们得到一个规则表。 CSS匹配规则在匹配一个节点对应的CSS规则时，是按照从右到左的顺序，例如div p { font-size :14px }，会先寻找所有的p标签然后判断它的父元素是否为div。 所以我们在写选择器的时候，尽量用id和class，不要用太多层级的选择器。 渲染树这个过程是一个DOM树与CSS规则树合并的过程。 注意：渲染树会忽略那些不需要渲染的节点，比如设置了display:none的节点。 计算通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把rem转化为px。 级联浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做specificity的公式，这个公式会通过： !important 内联样式 id、class、标签名 的顺序来计算准确的样式。 渲染阻塞在JavaScript宏任务，微任务与Event-loop中，简单介绍了浏览器进程，其中一点是JavaScript线程与GUI渲染线程无法同时进行，遇到JavaScript标签，就会暂停DOM树的解析。 所以如果要对DOM树进行操作或者不阻塞页面，应当将script标签放在body标签的底部，或者使用defer与async，下面是defer与async的区别： 布局与绘制确定渲染树中的所有节点的几何属性，位置，大小等。最后输入一个盒模型，然后遍历渲染树，将其渲染在屏幕中。 合并渲染层将以上绘制的所有图片合并，最终输出一张图片。 回流与重绘回流（reflow）当浏览器发现某个部分发生变化并且影响了布局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。 因为回流可能导致整个dom树的重新构造，所以会影响性能。 重绘(repaint)当浏览器发现某个部分发生变化但是没有影响布局的时候，比如：改变某个元素的背景色，文字颜色等，就会发生重回。 每次重绘后，浏览器还需合并渲染层并输出到屏幕上。 回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。 比如： display:none 会触发回流，而 visibility:hidden 只会触发重绘。 因为： display:none会脱离文档流，不占据页面空间； visibility:hidden,只是隐藏内容，并没有脱离文档流，会占据页面的空间。 JavaScript编译执行这里涉及到编译原理的过程，大概是： 1. 词法分析JavaScript脚本加载完成后，会首先进入词法分析阶段，首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。具体有： 分词，例如将var a = 2，分成var、a、=，2这样的词法单元。 解析：将词法单元转换为抽象语法树AST。 代码生成，将抽象语法树转换成机器指令。 2. 预编译JavaScript中有三种运行环境： 全局环境 函数环境 eval （ES6的let，const会生成块级作用域） 每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。 参考 在浏览器输入 URL 回车之后发生了什么（超详细版） 计算机网络-谢希仁","categories":[{"name":"经典面试题","slug":"经典面试题","permalink":"http://yoursite.com/categories/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"经典面试题","slug":"经典面试题","permalink":"http://yoursite.com/tags/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"设计模式5-发布-订阅模式（观察者模式）","slug":"设计模式5-发布-订阅模式","date":"2021-03-02T08:01:39.000Z","updated":"2021-03-08T01:18:53.320Z","comments":true,"path":"2021/03/02/设计模式5-发布-订阅模式/","link":"","permalink":"http://yoursite.com/2021/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"发布-订阅模式（观察者模式）定义其定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变的时候，所有依赖它的对象都会得到通知。 主要解决一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 在JavaScript中，其主要有以下两个用处： 可以广泛应用于异步编程之中，这是一种代替回调函数的方案。 发布-订阅模式可以取代对象之间的硬编码通知机制，一个对象不用再显示地调用另外一个对象的某个接口。 实现在web开发中，我们其实已经用到了发布-订阅模式，其就是DOM事件。 DOM事件例如我们给一个按钮绑定一个点击事件： 12345function click()&#123; console.log('click')&#125;document.getElmentById('button').addEventListener('click', click, false) 实际上这个事件绑定的过程也是一个发布订阅模式。我们预先将依赖添加到发布者，当发布者事件变化，即点击事件发生的时候，我们再触发该依赖。这就是一个发布订阅模式的触发过程。 简单实现除了DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布-订阅者模式可以用于任何JavaScript代码中。 首先我们要明确三个部分 指定发布者。 为发布者添加一个 缓存列表用于缓存回调函数，以用于通知订阅者。 最后发布消息的时候，发布者遍历整个缓存列表，依次触发里面存放的回调函数。 下面来进行简单的开发 123456789101112131415161718192021let publisher = &#123;&#125; //发布者publisher.cacheList = [] //缓存列表，存放订阅者的回调函数publisher.listen = function(fn)&#123; //订阅消息 this.cacheList.push(fn) //将订阅者函数添加进缓存列表&#125;publisher.trigger = function()&#123; //发布消息 for(let i = 0, len = this.cacheList.length; i &lt; len; i++)&#123; this.[cacheList].apply(this, arguments) &#125;&#125;//简单测试publisher.listen(function(time, msg)&#123; console.log(time+'的消息为'+msg)&#125;)publisher.trigger(1, '你是猪')publisher.trigger(2, '你是狗') 发布订阅者+关键字在上面的例子中，虽然能够实现发布订阅这个功能，但是还有一个问题是不同的订阅者可能需要订阅对不同的消息，所以我们需要给消息加上一个key，以表示消息的类型。 实际上只是需要将消息队列定义为对象，以表示不同的key；在发布消息时，按照key来触发消息。 12345678910111213141516171819202122232425262728293031323334353637383940let publisher = &#123;&#125; //发布者publisher.cacheList = &#123;&#125; //缓存列表，存放回调函数publisher.listen = function(key, fn)&#123; if(!this.cacheList[key])&#123; //如果还没有订阅过此类的消息，给该类消息创建一个缓存列表 this.cacheList[key] = [] &#125; this.cacheList[key].push(fn)&#125;publisher.trigger = function()&#123; let key = Array.prototype.shift.call(arguments) //发布消息 let fns = this.cacheList[key] //取出对应的消息类型 if(!fns || fns.length === 0)&#123; //如果没有订阅该消息，则返回 return false &#125; for(let i = 0, len = fns.length; i &lt; len; i++)&#123; fns[i].apply(this, arguments) //arguments是发布消息时附送的参数 &#125;&#125;//测试publiser.listen('消息类型1', function(msg)&#123; console.log('消息类型1：'+msg)&#125;)publiser.listen('消息类型2', function(msg)&#123; console.log('消息类型2：'+msg)&#125;)publisher.trigger('消息类型1', '你是猪')//消息类型1：你是猪publisher.trigger('消息类型2', '你是狗')//消息类型2：你是狗 为任何对象添加发布订阅者实际上发布者订阅者模式可以为任何对象添加，我们只需要将主要的三个属性添加到对象，即可使对象拥有发布订阅模式。 123456789101112131415161718192021let installEvent = function(obj)&#123; obj.cacheList = &#123;&#125; obj.listen = function(key, fn)&#123; if(!this.cacheList[key])&#123; //如果还没有订阅过此类的消息，给该类消息创建一个缓存列表 this.cacheList[key] = [] &#125; this.cacheList[key].push(fn) &#125; obj.trigger = function()&#123; let key = Array.prototype.shift.call(arguments) //发布消息 let fns = this.cacheList[key] //取出对应的消息类型 if(!fns || fns.length === 0)&#123; //如果没有订阅该消息，则返回 return false &#125; for(let i = 0, len = fns.length; i &lt; len; i++)&#123; fns[i].apply(this, arguments) //arguments是发布消息时附送的参数 &#125; &#125;&#125; 取消订阅的事件有时候我们需要取消订阅的事件，现在我们来实现这个功能。 12345678910111213141516let remove = function(key, fn)&#123; let fns = this.cacheList[key] if(!fns)&#123; return false &#125; if(!fn)&#123; fns &amp;&amp; (fns.length = 0) &#125;else&#123; for(let i =fns.length; i &gt; 0; i--)&#123; let _fn = fns[i] if(_fn === fn)&#123; fns.splice(i, 1) //删除订阅者的回调函数 &#125; &#125; &#125;&#125; 全局的发布-订阅对象对于每一个需要实现发布订阅模式的对象，都需要在对象上添加相同的四个属性，虽然理论上没有性能损失不大，但是我们还是可以建立一个全局的发布订阅对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let Event = (function()&#123; let cacheList = &#123;&#125; let listen, trigger, remove listen = function(key, fn)&#123; if(!cacheList[key])&#123; cacheList[key] = [] &#125; cacheList[key].push(fn) &#125; trigger = function()&#123; let key = Array.prototype.shift.call(arguments) let fns = cacheList[key] if(!fns || fns.length === 0)&#123; return false &#125; for(let i = 0,fn; fn = fns[i++];)&#123; fn.apply(this, arguments) &#125; &#125; remove = function(key, fn)&#123; let fns = cacheList[key] if(!fns)&#123; return false &#125; if(!fn)&#123; fns &amp;&amp; (fns.length = 0) &#125;else&#123; for(let l = fns.length - 1; l &gt;= 0; l--)&#123; let _fn = fns[l] if(_fn === fn)&#123; fns.splice(l, i) &#125; &#125; &#125; &#125; return &#123; listen, trigger, remove &#125;&#125;)()Event.listen('类型1', function(name)&#123; console.log('类型1：'name)&#125;)Event.trigger('类型1', '垃圾')//类型1：垃圾 全局事件的问题全局事件虽然可以解决开销，但是却出现了其他问题：命名冲突。 越来越多的发布订阅的添加，极其可能出现命名冲突的问题，由此我们如果使用全局事件，则必须使用命名空间来解决问题。 关于离线事件在异步事件中，极可能出现我们添加监订阅不够及时，使得事件已经触发了。这样就会出现预期之外的错误了。所以在这种需求中，我们需要实现离线事件。此种情况，我们可以建立一个离线事件的堆栈，当发布的时候还没有对象来订阅此事件，则暂时将其存放至离线栈，等有对象来订阅此对象的时候，我们将遍历堆栈并且依次执行这些函数。 实现下面我们将上面两点结合起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124let Event = (function()&#123; let global = sthi, Event, _default = 'default' Event = function()&#123; let _listen, _trigger, _remove, _slice = Array.prototype.slice, _shift = Array.prototype.shift, _unshift = Array.prototype.unshift, namespaceCache = &#123;&#125;, _create, find, each = function(ary, fn)&#123; let ret for(let i = 0, len = ary.length; i &lt; len; i++)&#123; let n = ary[i] ret = fn.call(n, i, n) &#125; return ret &#125; _listen = function(key, fn, cache)&#123; if(!cache[key])&#123; cache[key] = [] &#125; cache[key].push(fn) &#125; _remove = function(key, fn, cache)&#123; if(cache[key])&#123; if(fn)&#123; for(let i = cache[key].length; i &gt;= 0; i--)&#123; if(cache[key][i] === fn)&#123; cache[key].splice(i, 1) &#125; &#125; &#125;else&#123; cache[key] = [] &#125; &#125; &#125; _trigger = function()&#123; let cache = _shift.call(arguments), key = _shift.call(arguments), args = arguments, _self = this, stack = cache[key] if(!stack || !stack.length)&#123; return &#125; return each(stack, function()&#123; return this.apply(_self, args) &#125;) &#125; _create = function(namespace)&#123; let namespace = namespace || _default let cache = &#123;&#125;, offlineStack = [], ret = &#123; listen: function(key, fn, cache)&#123; _listen(key, fn, cache) if(offlineStack == null)&#123; return &#125; if(last === 'last')&#123; offlineStack.length &amp;&amp; offlineStack.pop() &#125;else&#123; each(offlineStack, function()&#123; this() &#125;) &#125; offlienStack = null &#125;, one: function(key, fn, last)&#123; _remove(key, cache) this.listen(key, fn, last) &#125;, remove: function(key, fn)&#123; _remove(key, cache, fn) &#125;, trigger: function()&#123; let fn, args, _self = this _unshift.call(arguments, cache) args = arguments fn = function()&#123; return _trigger.apply(_self, args) &#125; if(offlineStack)&#123; return offlineStack.push(fn) &#125; return fn() &#125; &#125; return namespace ? (namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret) : ret &#125; return &#123; create: _create, one: function(key, fn, last)&#123; let event = this.create() event.one(key, fn, last) &#125;, remove: function(key, fn)&#123; let event = this.create() event.remove(key, fn) &#125;, list: function(key, fn, last)&#123; let event = this.create() event.listen(key, fn, last) &#125;, trigger: function()&#123; let event = this.create() event.trigger.apply(this, arguments) &#125; &#125; &#125; return Event&#125;)() JavaScript中的发布订阅模式值得注意的是，之前我们编写的发布订阅模式，和一些其他的语言（比如Java）中的实现还是有区别的。在Java中实现一个自己的发布订阅模式，通常会把订阅者自身当作引用传入发布者对象中，同时订阅者对象还需提供一个名为诸如update的方法，供发布者对象在适合的时候调用。而在JavaScript中，我们用注册回调函数的形式来代替传统的发布订阅模式，更加方便。 参考 《JavaScript设计模式与开发实践》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"发布-订阅模式","slug":"发布-订阅模式","permalink":"http://yoursite.com/tags/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式4-迭代器模式","slug":"设计模式4-迭代器模式","date":"2021-03-01T02:30:22.000Z","updated":"2021-03-01T04:07:07.647Z","comments":true,"path":"2021/03/01/设计模式4-迭代器模式/","link":"","permalink":"http://yoursite.com/2021/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"迭代器模式定义迭代器模式是指提供一种方法顺序访问一个集合对象中的各个元素，而不需要暴露该对象的内部表示。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 主要解决不需要关心对象内部表示来遍历整个对象。 内部迭代器内部迭代器是指事先定义好迭代器的迭代规则，他完全接受整个迭代过程，外部只需要一次初始调用。 实现我们实现一个each内部迭代器，接受两个参数： arr：要被迭代的数组 fn：迭代规则函数 fn在每一次数组循环时都会执行 123456789101112131415161718const each = function(arr, fn)&#123; for(let i = 0, len = arr.length; i &lt; len; i++)&#123; fn(i, arr[i]) &#125;&#125;//调用each([1,2,3], function(index, item)&#123; console.log(index, item)&#125;)/**结果*0 1*1 2*2 3*/ 内部迭代器的缺点就是无法很好的组合个迭代，只有在一个迭代规则中嵌入另外一个迭代器，这样未必显得代码冗余，影响代码可读性。所以产生了外部迭代器。 外部迭代器外部迭代器一般会提供一个next类似的函数，没调用一次，就会返回该次迭代的结果。我们可以在外部拿到结果，进行跟多的操作。 下面我们简单实现一个外部迭代器的原型： 12345678910111213141516171819202122232425262728293031323334const Iterator = function(obj)&#123; let current = 0 let maxLen = obj.length let next = function()&#123; if(current &lt; maxLen)&#123; current++ return &#123; value: obj[current], done: false &#125; &#125;else&#123; return &#123; value: undefined, done: true &#125; &#125; &#125; return &#123; next, len: maxLen &#125;&#125;let arr = [1,2,3]let iterator_arr = Iterator(arr)iterator_arr.next()/**&#123;* value: 1,* done: false*&#125;*/ 上面的函数实现了ES6提供的Iterator接口最基本的部分。我们可以在外部拿到迭代结果，现在我们可以同时拿到两个迭代器的结果而不用嵌套迭代器。 见到那写一下两个迭代器元素的比较： 123456789let compare = function(iterator1, iterator2)&#123; //比较元素长度 if(iterator1.length !== iterator2.length)&#123; return false &#125; while(!iterator1.next().done &amp;&amp; !iterator2.next().done &amp;&amp; iterator1.next().value !== iterator2.next().value)&#123; return false &#125;&#125; JavaScript中遍历迭代器说到底还是对某种数据结构进行遍历的的一个接口。在一般的高级语言中，对于特殊的数据结构，比如数组都会封装一个方法进行遍历。而在JavaScript中，表示集合类的数据结构中，包括ES6增加的Map和Set，一共就有4种： Object Array Set Map 对于数组和对象，我在JavaScript中数组与对象的遍历方法中，进行了详细的探讨。 在那篇文章中，实际上都是数组或对象的内部迭代器的实例，比如的数组的forEach等方法。 而在ES6中，提供了原生的Iterator接口来实现外部迭代器，而在Java等语言中，早就提供了该接口。 IteratorIteratorIterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环（详见下文）。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。 ES6 规定， 默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。 Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。 属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。 如： 123456789101112const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; 上面代码中，对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。 ES6中有一些对象已经原生实现了Iterator 接口： Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 值得注意的是Object并没有原生实现iterator，原因是： 对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。 当我们对一个数组完成赋值，其Symbol.iterator属性就随之生成了。比如下面的例子： 1234567let arr = ['a', 'b', 'c']let ite = arr[Symbol.iterator]()iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 调用 Iterator 接口的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。 （1）解构赋值对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set = new Set().add('a').add('b').add('c');let [x,y] = set;// x='a'; y='b'let [first, ...rest] = set;// first='a'; rest=['b','c']; （2）扩展运算符 扩展运算符（…）也会调用默认的 Iterator 接口。 12345678// 例一var str = 'hello';[...str] // ['h','e','l','l','o']// 例二let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd'] 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。 1let arr = [...iterable]; （3）yield* yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; （4）其他场合 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])） Promise.all() Promise.race() Iterator 接口与 Generator 函数Symbol.iterator()方法的最简单实现，还是使用Generator 函数。 1234567891011121314151617181920212223let myIterable = &#123; [Symbol.iterator]: function* () &#123; yield 1; yield 2; yield 3; &#125;&#125;;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; * [Symbol.iterator]() &#123; yield 'hello'; yield 'world'; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// \"hello\"// \"world\" 上面代码中，Symbol.iterator()方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。 for…of 循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。 for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 示例12345678910111213141516171819202122232425262728//数组const arr = ['red', 'green', 'blue'];for(let v of arr) &#123; console.log(v); // red green blue&#125;//Setvar engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkit//Mapvar es6 = new Map();es6.set(\"edition\", 6);es6.set(\"committee\", \"TC39\");es6.set(\"standard\", \"ECMA-262\");for (var [name, value] of es6) &#123; console.log(name + \": \" + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 参考 《JavaScript设计模式与开发实践》 Iterator 和 for…of 循环","categories":[{"name":"迭代器模式","slug":"迭代器模式","permalink":"http://yoursite.com/categories/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"http://yoursite.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式3-代理模式","slug":"设计模式3-代理模式","date":"2021-02-27T06:32:20.000Z","updated":"2021-02-28T13:22:51.727Z","comments":true,"path":"2021/02/27/设计模式3-代理模式/","link":"","permalink":"http://yoursite.com/2021/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式定义当目标对象不方便直接访问或者访问者不满住要求的时候，提供一个代理对象来控制对目标对象的访问。访问者实际上访问的是代理对象。代理对象对请求做出一些处理之后，再把请求转交给目标对象。 主要解决在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 优缺点优点 职责清晰。 高扩展性。 智能化。 缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 远程代理（主要针对Java）远程代理可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。 Copy-on-Write 代理定义 Copy-on-write (CoW or COW), sometimes referred to as implicit sharing or shadowing, is a resource-management technique used in computer programming to efficiently implement a “duplicate” or “copy” operation on modifiable resources. 写时复制（copy-on-write，简称 CoW 或 COW），也叫隐式共享（implicit sharing）或隐藏（shadowing），是计算机编程中的一种资源管理技术，用于高效地复制或拷贝可修改资源 If a resource is duplicated but not modified, it is not necessary to create a new resource; the resource can be shared between the copy and the original. Modifications must still create a copy, hence the technique: the copy operation is deferred to the first write. By sharing resources in this way, it is possible to significantly reduce the resource consumption of unmodified copies, while adding a small overhead to resource-modifying operations. 具体的，如果复制了一个资源但没有改动，就没必要创建这个新的资源，此时副本能够与原版共享同一资源，在修改时仍需要创建副本。因此，关键在于：将拷贝操作推迟到第一次写入的时候。通过这种方式来共享资源，能够显著减少无改动副本的资源消耗，而只是略微增加了资源修改操作的开销 实例但是在JavaScript种，以前还不好对这种代理进行很好的描述，因为以前JavaScript并没有对对象属性进行监听的方法（实际上也只有obj.defineProperty），在ES6引入了Proxy之后，我们可以很方便的实现COW代理。下面给出简单实现： 123456789101112131415161718let person = &#123; name: 'tom', num: 123&#125;let p_person = new Proxy(person, &#123; get: function(target, proKey, receiver)&#123; return target[proKey] &#125;, set: function(target, propKey, value, receiver)&#123; //深拷贝一个对象 let newObj = deep_clone(target) //修改新对象的值 newObj[proKey] = value //替换proxy对象为新对象 p_preson = newObj &#125;&#125;) 上面的例子中，充分利用了JavaScript弱类型语言的特征，在最开始时将p_person赋值为Proxy对象，在执行get操作时，直接返回被访问对象的值；在执行set操作时，在对被访问对象执行深拷贝，并把p_person赋值为新对象。 但是这样存在一些问题： Proxy对象同样会占用空间，如果确定目标对象大概率会被改动，并且目标对象并不是很大，建议直接deep_clone。 Proxy对象内部的定义比较复杂，每一个对象都要重复该过程。所以我们封装一个函数，来执行这个过程。 1234567891011121314151617181920212223let person = &#123; name: 'tom', num: 123&#125;function produce_p(obj)&#123; let new_obj = new Proxy(obj, &#123; get: function (target, propKey, receiver) &#123; return target[propKey]; &#125;, set: function (target, propKey, value, receiver) &#123; //深拷贝一个对象 let newObj = deep_clone(target) //修改新对象的值 newObj[proKey] = value //替换proxy对象为新对象 new_obj = newObj &#125;, &#125;) return new_obj&#125;let person_p = produce_p(person) //代理对象 这样我们就解决了第二个问题，第一个问题是无法解决的，需要我们自行解决。 保护（Protect or Access）代理定义保护代理模式(Access Proxy), 也叫Protect Proxy. 这种代理用于对真实对象的功能做一些访问限制, 在代理层做身份验证. 通过了验证, 才调用真实的主体对象的相应方法。 这种限制，应该分为两种： 对访问来源做限制 对访问内容做限制 实例但是JavaScript中目前不能对一种进行限制（使用透明代理），我们使用ProxyAPI来实现对访问内容进行限制： 123456789101112131415//加入我们要对sex进行读限制，对person进行写限制let content = &#123; person: 'tom', place: 'park', sex: 'male'&#125;let content_p = new Proxy(content, &#123; get: function(target, propKey, receiver)&#123; return proKey === 'sex' ? false : target[proKey] &#125;, set(target, propKey, value, receiver)&#123; proKey === 'person' ? '' : target[proKey] = value &#125;&#125;) 同样的，我们也可以对content_p进行封装，创建一个工厂，以进行更好复用代码。 如果实际要对访问来源做限制，只能使用非透明的方式，即读写必须通过函数来进行操作。 1234567891011121314151617181920212223242526let content = &#123; person: 'tom', place: 'park', sex: 'male'&#125;let source1 = &#123; name: 'source1'&#125;let source2 = &#123; name: 'source2'&#125;function get(obj, prop)&#123; //限制来自于source1的访问 if(this.name === 'source1' || prop === 'sex')&#123; return false &#125;else&#123; return obj[prop] &#125;&#125;//模拟从source1来源下访问contentget.call(source1, content, 'sex')//false 缓存(Cache)代理定义缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算的时候，如果传递进来的参数与之前的一致，则直接返回结果，减少运算。 实例下面是一个对乘积进行缓存的代理： 123456789101112131415161718let mult = function&#123; let res = 1 for(let i = 0, len = arguments.length; i &lt; len; i++)&#123; res *= arguments[i] &#125; return res&#125;let proxy_mult = (function()&#123; let cache = &#123;&#125; return function()&#123; let args = Array.prototype.join.call(arguments) if(args in cache)&#123; return cahe[args] &#125; return cache[args] = mult.apply(this, arguments) &#125;&#125;)() 同样的，我们可以对proxy_mult进行封装，创建一个工厂，来生成函数工厂。 12345678910111213141516171819202122232425262728293031323334//计算乘积函数let mult = function&#123; let res = 1 for(let i = 0, len = arguments.length; i &lt; len; i++)&#123; res *= arguments[i] &#125; return res&#125;//计算加和函数let plus = function&#123; let res = 1 for(let i = 0, len = arguments.length; i &lt; len; i++)&#123; res += arguments[i] &#125; return res&#125;let proxyProxy = function(fn)&#123; let cache = &#123;&#125; return function()&#123; let args = Array.prototype.join.call(arguments) if(args in cache)&#123; return cahe[args] &#125; return cache[args] = fn.apply(this, arguments) &#125;&#125;let proxyMult = proxyProxy(mult)let proxyPlus = proxyProxy(plus)proxyMult(1,2,3,4) //24proxyPlus(1,2,3,4) //10 虚拟代理定义虚拟代理作为创建开销大的对象的代表，经常会直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理地来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。 实例合并请求减少开销这个用法其实和函数的节流效果一致，将多次操作合并为一次，以减少消耗，特别是网络请求。 比如文件同步时，虽然我们和设计checkbox来合并请求，但是并不是每个用户都会按我们设计的逻辑来进行操作。他们可能仍然一个一个的同步，这样会加大服务器的负担。所以我们可以把一段时间内的请求存储下来，每隔一段时间进行同步。以减少服务器的负担。 1234567891011121314151617181920let syncFile = function(id)&#123; //同步&#125;let proxySyncFile = (function()&#123; let ids = [] let timer return function(id)&#123; ids.push(id) if(timer)&#123; return &#125; timer = setTimeout(function()&#123; syncFile(ids.join()) claerTimeout(timer) timer = null cache.length = 0 &#125;, 2000) &#125;&#125;)() 惰性加载这个作用就是虚拟代理最初的用法。 比如我们有一个库名叫composite，其作用是 查询页面内图片的的OCR文字(picOcr) 建立页面的虚拟DOM(virtualDOM) 进行大数计算(bigNumberCalc) 用webGL绘制一个游戏(webGLGame) 可以想象，这个库的每个功能都是比较困难，所以其代码量都比较大，并且我们并不一定会使用到其所有功能，假如picOcr是最常用的模块，我们直接加载该模块。所以我们可以将其他的模块做成懒加载，需要使用时再加载。 1234567891011121314151617181920const composite = &#123; picOcr : function()&#123; //直接加载 &#125;, virtualDOM: function()&#123; let vd = _load('virtualDOM') composite.virtualDOM = vd composite.virtualDOM(arguments) &#125;, bigNumberCalc: function()&#123; //逻辑相同 &#125;, webGLGame: function()&#123; //逻辑相同 &#125;, _load: function(name)&#123; //加载模块 return get(name) &#125;&#125; 当然，上面的设计是最简单的模块设计方式，有很多问题，但是这不是我们讨论的重点，我们这里讨论的重点是延迟加载部分，可以看到 virtualDOM模块最初是没有被加载的，在调用的时候我们才通过网络加载，最后覆盖原始对象，下次调用时就是直接调用实际代码了。 但实际上这不是好的方案，好的延迟加载方案是： 在库被加载完成后，通过异步网络同时加载需要的模块，这样用户在调用其他模块时，也不会感觉到延迟，同时不会阻塞页面。 其他代理在代理模式中，还有其他的模式，但是在JavaScript中并不是常用的，比如： 防火墙代理控制网络资源的访问，保护服务器资源的安全。 远程代理为一个对象在不同的地址空间提供局部代表。在JavaScript中，远程代理可以是另一个虚拟机中的对象。 智能引用代理取代了简单的指针，它在访问对象的同时执行一些附加操作，比如计算一个对象被引用的次数。 ES6的Proxy在ES6之前，JavaScript只能通过Object.defineProperty来进行数据代理。并且还无法做到对对象属性的代理监听。以至于Vue不得不设计一个Vue.prototype.set来监听对象属性的修改。但是ES6的的ProxyAPI在编程语言的层面上提供了代理，这样使得我们这一章的代理模式的实现变得极其简单。下面简单介绍其用法。 ES6提供原生的Proxy构造函数，用来生成Proxy实例。 1let proxy = new Proxy(target, handler) Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，- target参数表示所要拦截的目标对象。 handler参数也是一个对象，用来定制拦截行为。 如果handler没有做任何拦截为{}，则直接通向原对象。 示例123456789101112131415161718192021let stu = &#123; name: 'tom', number: 123, sex: 'male'&#125;let handler = &#123; get: function(target, propKey, receiver)&#123; if(propKey === 'sex')&#123; return false &#125; return target[propKey] &#125;, set: function(target, propKey, value, receiver)&#123; if(propKey === name)&#123; return false &#125; target[propKey] = value &#125;&#125;let stu_p = new Proxy(stu, handler) 上面代理拦截了get和set方法，拦截了获取stu对象的sex属性、设置stu的name属性。 其中handler中，支持的拦截属性有13种： get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[&#39;foo&#39;]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 简单介绍上面的参数分别为： target：目标对象，即被代理的对象 propKey： 操作的属性键名 value：操作的属性值 receiver：代理对象 propKey：属性键名 propDesc：属性的描述，详见Object.defineProperty() proto：原型对象 Vue3中的响应式完全依赖了这个API，所以其是非常有用的。用起来也简单。还是需要深入理解。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"代理模式","slug":"代理模式","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式2-策略模式","slug":"设计模式2-策略模式","date":"2021-02-24T01:55:03.000Z","updated":"2021-02-24T06:47:25.675Z","comments":true,"path":"2021/02/24/设计模式2-策略模式/","link":"","permalink":"http://yoursite.com/2021/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式定义定义一系列的算法，把它们一个个封装起来，并且使他们可以相互替换。 主要解决在多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护的问题。 奖金的例子很多公司的年终奖的是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为S的员工年终奖有4倍工资，绩效为A的员工年终奖有3倍工资，绩效为B的员工年终奖有2倍工资。假如需要一段代码来计算对应员工的年终奖。 最基础写法我们直观想到的就是用if...else或者switch...case的方法来写。如下 123456789let calculateBonus = function(performanceLevel, salary)&#123; if(performanceLevel === 'S')&#123; return salary * 4 &#125;else if(performanceLevel === 'A')&#123; return salary * 3 &#125;else if(performanceLevel === 'B')&#123; return salary * 2 &#125;&#125; 虽然代码简单，但是这段代码有很多问题： 过多的if...else语句，代码结构不好 calculateBonus函数缺乏弹性，如果增加一种新的绩效C，或者修改现有等级的奖金逻辑，就必须深入函数内部进行修改，这违背了开放-封闭原则 算法复用性差，如果需要在程序的其他地方重用这些算法就只能重新写（cpoy）一份相似的。 所以我们现在尝试一步步重构代码。 使用组合函数重构代码这里我们将不同的绩效的计算代码抽出来，形成对应的计算函数，在计算奖金里调用这些函数进行计算。 123456789101112131415161718192021let performanceS = function(salary)&#123; return salary * 4&#125;let performanceA = function(salary)&#123; return salary * 3&#125;let performanceB = function(salary)&#123; return salary * 2&#125;let calcalateBonus = function(perfomanceLevel, salary)&#123; if(performanceLevel === 'S')&#123; return performanceS(salary) &#125;else if(performanceLevel === 'A')&#123; return performanceA(salary) &#125;else if(performanceLevel === 'B')&#123; return performanceB(salary) &#125;&#125; 但是这段代码对于最大的问题还没有解决： 过多的if...else语句，代码结构不好 calculateBonus函数缺乏弹性，如果增加一种新的绩效C，或者修改现有等级的奖金逻辑，就必须深入函数内部进行修改，这违背 使用策略模式重构代码一个策略模式的程序至少由两部分组成。 第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。 第二部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这一点，说明Context中要维持对某个策略对象的引用。 使用传统面向对象语言的算法12345678910111213141516171819202122232425262728293031323334353637let performanceS = function()&#123;&#125;performanceS.prototype.calculate = function(salary)&#123; return salary * 4&#125;let performanceA = function()&#123;&#125;performanceS.prototype.calculate = function(salary)&#123; return salary * 3&#125;let performanceB = function()&#123;&#125;performanceS.prototype.calculate = function(salary)&#123; return salary * 2&#125;let Bonus =function()&#123; this.salary = null this.strategy = null&#125;Bonus.prototype.setSalary = function(salary)&#123; this.salary = salary&#125;Bonus.prototype.setStrategy = function(strategy)&#123; this.strategy = strategy&#125;Bonus.prototype.getBonus = function()&#123; if(!this.strategy)&#123; throw new Error('未设置strategy属性') &#125; return this.strategy.calculate(this.salary)&#125; 根据上面的模式，我们将计算具体奖金的方法封装。然后定义Bonus来调用封装的方法来计算具体的奖金。 但是对于JavaScript，我们的实现可以更简单一些。 JavaScript版本的策略模式我们可以直接使用字面量对象来封装strategy。然后通过Context来计算奖金。 1234567891011121314151617181920//定义策略let strategy = &#123; S: function(salary)&#123; return salary * 4 &#125;, A: function(salary)&#123; return salary * 3 &#125;, B: function(salary)&#123; return salary * 2 &#125;&#125;//定义Contextlet calculateBonus = function(level, salary)&#123; return srtategy[level](salary)&#125;console.log(calculateBonus('S', 20000)) //输出：80000console.log(calculateBonus('A', 10000)) //输出：30000 表单验证表单验证与上面计算奖金的算法类似，都是由多个相似的规则组成。加入现在有以下规则： 用户名不能为空 密码长度不能少于6位 手机号码必须符合格式 基本写法1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;body&gt; &lt;form id='registerForm'&gt; 请输入用户名：&lt;input type='text' name='userName'/&gt; 请输入密码：&lt;input type='text' name='password'/&gt; 请输入手机号：&lt;input type='text' name='phoneNumber'/&gt; &lt;button&gt; 提交 &lt;/button&gt; &lt;/form&gt; &lt;script&gt; let registerForm = document.getElementBuId('registerForm') registerForm.onsubmit = function()&#123; if(registerForm.userName.value === '')&#123; alter('用户名不能为空') return false &#125; if(registerForm.password.valu.length &lt; 6)&#123; alter('密码不能少于6位') return false &#125; if(!/(!1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value))&#123; alert('手机号码格式不正确') return false &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这是最常见的编写方式，其缺点也与奖金计算的最初版本一样。 registerForm.onsubmit函数比较庞大，包含了很多if...else语句。 registerForm.onsubmit缺乏弹性，如果增加校验规则必须深入函数内部进行修改，违背了开放-封闭原则。 算法复用性差，如果在程序中增加另外一个表单，我们仍然需要写完全相同的算法。 用策略模式重构表单校验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//校验规则let stategies = &#123; isNonEmpty: function(value, errorMsg)&#123; if(value === '')&#123; return errorMsg &#125; &#125;, minLength: function(value, length, errorMsg)&#123; if(value.length &lt; length)&#123; return errorMsg &#125; &#125;, isMobile: function(value, errorMsg)&#123; if(!/(!1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value))&#123; return errorMsg &#125; &#125;&#125;//校验类let Validator = function()&#123; this.cache = [] //保存校验规则&#125;Validator.prototype.add = function(dom, rule, errorMsg)&#123; let ary = rule.split(':') //把strategies和参数分开 this.cache.push(function()&#123; //把校验规的步骤用空函数包装起来，并且放入cache let strategy = ary.shift() //用户挑选的strategy ary.unshift(dom.value) //把input的value添加进参数列表 ary.push(errorMsg) //把errorMsg添加进参数列表 return strategies[strategy].aplly(dom, ary) &#125;)&#125;Validator.prototype.start = function()&#123; for(let i = 0; validatorFunc; validatorFunc = this.cache[i++])&#123; let msg = validatorFunc() //开始校验，并取得校验后的返回值 if(msg)&#123; //如果有确切的返回值，说明校验没有通过 return msg &#125; &#125;&#125;//Context类let validatorFunc = function()&#123; let validator = new Validator() //添加一些校验规则 validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空') validator.add(registerForm.password, 'minLength:6', '密码长度不能少于6位') validator.add(registerForm.phoneNumer, 'isNonEmpty', '用户名不能为空') let errorMsg = validator.start() //获得校验结果 return errotMsg //返回校验结果&#125;let registerForm = document.getElementById('registerForm')registerForm.onsubmit = function()&#123; let errorMsg = validatorFunc() //如果errorMsg有确切的返回值，说明未通过校验 if(errorMsg)&#123; alert(errorMsg) return false //🚫表单提交 &#125;&#125; 策略模式的优缺点优点： 策略模式利用了组合、委托和多态的技术和思想，可以有效的避免多重条件选择语句。 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得他们易于切换，易于理解，易于扩展。 在策略模式的算法也可以服用在系统中的其他地方，从而有效的避免代码的冗余。 在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 缺点： 会增加许多的策略类或者策略对象。 策略模式的最大特点就是将同类操作封装在一个对象中，然后再其他类中调用该对象中对应的操作。 参考《JavaScript设计模式与开发实践》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"策略模式","slug":"策略模式","permalink":"http://yoursite.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式1-单例模式","slug":"设计模式1-单例模式","date":"2021-02-22T02:19:56.000Z","updated":"2021-02-24T06:44:36.111Z","comments":true,"path":"2021/02/22/设计模式1-单例模式/","link":"","permalink":"http://yoursite.com/2021/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式最近在写Vue插件，发现自己通过直观想法写的东西总是与别人的插件有一定的差距。我也明白别人的库中用了一种或多种设计模式，使代码结构更加恰当等等。之前就说要学习一下设计模式，被搁置到现在，现在买了《JavaScript设计模式与开发实践》，后面会陆续将自己的学习过程通过博客记录。 单例模式定义保证一个类仅有一个实例，并提供一个访问它的全局访问点。 描述单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象。 实现传统单例模式JavaScript语言原生设计的时候并没有设计类的概念，并且对象是可以直接通过字面量来新建对象，不一定需要通过类来实例化对象。所以在JavaScript中的单例模式与Java等面向对象语言稍有不同。下面通过传统的面向对象语言的方式来设计单例模式。 简单实现要实现标准的单例模式，无非是要用一个变量来标志当前是否已经为某个类创建过对象，如果创建过，则在下一次创建的时候直接返回该对象。 123456789101112131415161718let Singleton = function(name)&#123; this.name = name&#125;Singleton.instance = nullSingleton.prototype.getName =function()&#123; alert(this.name)&#125;Singleton.getInstance = function(name)&#123; if(!instance)&#123; this.instance = new Singleton(name) &#125; return this.instance&#125;let a = Singleton.getInstance('name1')let b = Singleton.getInstance('name2') 或者使用闭包将instance标志放在闭包中： 1234567891011121314151617let Singleton = function(name)&#123; this.name = name&#125;Singleton.prototype.getName = function()&#123; alert(this.name)&#125;Singleton.getInstance = (function()&#123; let instance = null return function(name)&#123; if(!instance)&#123; instance = new Singleton(name) &#125; &#125; return instance&#125;)() 通过这种方式，我们只能通过getInstance方法来获得该对象。这样增加了该方法的不透明性，不能通过new来创建对象，下面来编写一个头i摩纳哥的单例类。 透明的单例类下面来实现一个透明类，来实现一个CreateDiv单例类，他的作用是是负责在页面中创建唯一的div节点，代码如下： 1234567891011121314151617181920212223let CreateDiv =(function()&#123; let instance; let CreateDiv =function(html)&#123; if(instance)&#123; return instance &#125; this.html = html this.init() return instance = this &#125; CreateDiv.prototype.init = function()&#123; let div = document.createElement('div') div.innerHTML = this.html document.body.appendChild(div) &#125; return CreateDiv&#125;)()let a = new CreateDiv('name1')let b = new CreateDiv('name2')a === b //true 这个构造方法虽然完成了一个透明的单例类，但是它同样有一些缺点，即违背了“单一职责原理” 单一职责原则（SRP：Single responsibility principle）又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定一个类应该只有一个发生变化的原因。 用代理实现单例模式为了实现单一职责原理，我们要引入代理类的方式，把负责管理单例的代码分离出去。 1234567891011121314151617181920212223242526var CreateDiv = function(html)&#123; this.html = html this.init()&#125;CreateDiv.prototype.init = function()&#123; let div = document.createElement('div') div.innerHTML = this.html document.body.appendChild(div)&#125;//代理类，可以处理各种类let proxyCreateDiv = (function()&#123; let instance return function(fn, html)&#123; if(!instance)&#123; instance = new fn(html) &#125; return instance &#125;&#125;)()let a = new ProxySingletonCreateDiv(CreateDiv, 'name1')let b = new ProxySingletonCreateDiv(CreateDiv, 'name2')a === b //true 上面的代码中，我们将业务代码与管理逻辑分开到两个类中，实现了单一职责原理。 JavaScript中的单例模式由于JavaScript是一门原生无类(class-free)语言，也是正因如此，生搬硬套单例模式的概念并无意义。 单例模式的核心是：确保只有一个实例，并提供全局访问。 全局变量不是单例模式，但在JavaScript中，我们经常会把全局变量当成单例来使用。 当我们使用字面量对象在全局作用域下创建对象a时，对象a确实是独一无二的，并且也是可以在任意位置上访问。这样满足单例模式的两个条件。 但是这样会污染全局变量，我们可以使用两种方法： 使用命名空间。 使用闭包封装私有变量。 惰性单例所谓惰性单例就是在需要的时候才创建。实际上上面的单例模式就已经是惰性单例了，在为初始化之前都是null，只有在new的时候才进行创建。 下面用一个实际应用场景，就是登录框的设计：在用户未点击之前，登录框不会显示，点击时才会出现登录框。 这里有几种处理方式： 提前将登录框插入到文档中，并将其display属性设置为none，在点击时将display属性设置为block。这样性能问题就是，这个登录框可能永远用不到，这样就浪费了性能。 在用户点击时，使用JavaScript将登录加入文档流；在用户登录成功或者×时，将其从文档流中删除。这样的性能问题也有，就是第一次生成的登陆框实际是可以保存，方便以后使用。 所以最佳方案就是最开始不生成登录框，等用户点击时生成，并且这之后将其display属性设为none，方便以后使用，这样也就是我们的单例模式。 所以最后的代码如下（已经将业务代码与管理代码分离）： 12345678910111213141516171819202122232425262728293031//获取对应对象单例let getSingle = function(fn)&#123; let result //使用一个闭包来保存result return function()&#123; return result || (result = fn.apply(this, arguments)) &#125;&#125;//创建登录框并返回let createLoginLayer = function()&#123; let div = document.createElement('div') div.innerHTML = '登录框' document.body.appendChild(div) return div&#125;//创建函数的单例let createSingleLoginLayer = getSingle(createLoginLayer)//点击事件监听document.getElementById('loginBtn').onclick = function()&#123; let loginLayer = createSingleLoginLayer() loginLayer.style.display = 'block'&#125;//取消事件监听document.getElementById('cancelBtn').onclick = function()&#123; let loginLayer = createSingleLoginLayer() loginLayer.style.display = 'none1&#125; 总结单例模式是一个比较重要的单例模式，在进行底层开发或者注重性能的任务中，单例模式可以节省很多消耗，提高性能。 参考 《JavaScript设计模式与开发实践》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"JavaScript中的模块导入导出","slug":"JavaScript中的模块导入导出","date":"2021-02-14T10:47:09.000Z","updated":"2021-03-09T14:02:07.383Z","comments":true,"path":"2021/02/14/JavaScript中的模块导入导出/","link":"","permalink":"http://yoursite.com/2021/02/14/JavaScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"模块的概念 （Modular design） 所谓的模块化设计，简单地说就是将产品的某些要素组合在一起，构成一个具有特定功能的子系统，将这个子系统作为通用性的模块与其他产品要素进行多种组合，构成新的系统，产生多种不同功能或相同功能、不同性能的系列产品。 这是在整个设计行业对模块化的定义。对于编程语言中的模块化设计，其基本思路就是将有相同功能的部分代码封装在一起，形成一个通用的，可复用的模块，使之在其它系统中可以重复利用，并不会对模块内部产生影响。所以设计模式中模块化设计的三大特征也要遵循： 相对独立性 互换性 通用性 换做在编程语言中，相对独立性即要使私有成员无法被外部访问并暴露给外部指定的方法。通用性在程序设计中多被称为可复用性，而模块设计的原则和目的也是可复用性。模块可以减少我们对重复代码的编写，提高开发的效率。 JavaScript对模块的需求最初JavaScript是作为网页开发的脚本而开发，Brendan Eich 可能也不会想到当初十几天开发出的一个脚本语言如今会焕发如此的生命力，也正是因为开发周期如此之短，使之缺点在当今工程化的JavaScript中被极大的放大。其中一个就是模块的概念，JavaScript原生并没有模块的概念，就如同没有原生的类一样（尽管ES6推出了所谓的类）。为此，开发者想出了很多方法从语言层面来模拟模块化。 初期的模块化在各类框架，插件没有流行，JavaScript仅作为一门脚本语言的时候，开发人员想出了一些方法来对项目中一些方法集合进行封装，形成类似于模块的模式。 原生写法描述模块就是实现特定功能的一组方法。 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 例子1234567function m1()&#123; //...&#125;function m2()&#123; //...&#125; 缺点 “污染”了全局变量，无法保证不与其他模块发生变量名冲突 模块成员之间看不出直接关系。 对象写法描述为了解决上面的“全局变量污染的问题”，又利用了对象这一数据类型，使一个模块成为一个对象，模块的成员作为对象的成员变量。 例子12345678910111213var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 缺点 私有变量被直接暴露给外部，如上面的_count应该是一个保留的私有变量，但是在外部我们也是可以访问到的。 立即执行函数（IIFE）写法描述又为了解决无法保有私有成员的问题（其本质是JavaScript没有局部作用域的问题，具体看这里），这里利用了立即执行函数形成一个闭包的同时也形成了一个局部作用域，这个作用域内的变量在外部是无法访问到的。这样就解决了上面的私有便变量的问题。 例子123456789101112131415161718var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); 这里module1形成了一个闭包，返回一个对象，我们只能访问到对象暴露的m1和m2方法，内部的_count是无法被访问到了。 优点 提高性能：通过 IIFE 的参数传递常用全局对象 window、document，在作用域内引用这些全局对象。JavaScript 解释器首先在作用域内查找属性，然后一直沿着链向上查找，直到全局范围，因此将全局对象放在 IIFE 作用域内可以提升js解释器的查找速度和性能； 压缩空间：通过参数传递全局对象，压缩时可以将这些全局对象匿名为一个更加精简的变量名； 缺点 不能很好的管理依赖，缺少一个依赖管理者。比如依赖的调用顺序，在没有管理者时，我们必须自己确定调用顺序，比如： 我们要调用module1的mock方法， 而module1又依赖module2 module2又依赖module3 module4又依赖module3 我们则必须按这个顺序加载脚本文件 12345678&lt;script src='./module4'&gt;&lt;/script&gt;&lt;script src='./module3'&gt;&lt;/script&gt;&lt;script src='./module2'&gt;&lt;/script&gt;&lt;script src='./module1'&gt;&lt;/script&gt;&lt;script&gt; module1.mock()&lt;/script&gt; 立即执行函数（IIFE）的衍生写法放大模式描述如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。 例子123456789var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1); 上面的代码为module添加了一个m3属性。并将新的模块实体返回。 宽放大模式描述对于上面的放大模式，存在一定的问题。由于在浏览器中，所有的资源都是异步加载的，所以上面的参数可能不存在，所以我们必须要考虑这种情况，增强代码的健壮性。 例子1234567var module1 = ( function (mod)&#123; //... return mod;&#125;)(window.module1 || &#123;&#125;); 上面的代码相当于是给函数参数设置了一个默认参数为{}，当window.module1不存在的时候，在对{}空对象进行操作。 现代模块设计恩格斯说：“社会一旦有技术上的需要，则这种需要会比十所大学更能把科学院推向前进。”随着进入大前端时代，网站的规模越来越大，逻辑层面越来越复杂。模块化的管理成为必然，很多模块管理框架应运而生。具有代表性的有： Node.js中CommonJS 基于 AMD 的 RequireJS 基于 CMD 的 SeaJS ECMAScript规定的ES Module CommonJS描述CommonJS 是Node.js中采用的一种规范，其基本原则有： 由于Node是在服务端运行，所以CommonJS的模块加载是同步进行的，所以其在浏览器中并不适用，因为浏览器中的文件都是通过网络加载的，并不适合同步加载。 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 每个模块内部有一个全局变量module，这个变量是一个对象，它的exports属性（即module.export）用于导出模块。 每个模块内部有一个全局变量require，其是一个函数，用于导入模块，参数即模块的地址。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 例子导出12345678910111213141516//module1.jslet _temp = -1let pi = 3.1415926let exchange = function(a, b)&#123; _temp = a a = b b = _temp return [a,b]&#125;module.export.pi = pimodule.export.exchange = exchange//或者这么写module.export.sum = function(a, b)&#123; return a + b&#125; 导入1234let module1 = require('./module1.js')console.log(module1.exchange(1, 2)) //[2, 1]console.log(module1.pi) //3.1415926 详细介绍module对象Node内部提供一个Module构建函数。所有的模块都是Module的实例。 查看Node源码： 123456function Module(id, parent)&#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; //...&#125; 可以发现其是一个构造器函数，其中设置了以下属性： module.id：模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回一个对象，表示调用该模块的父级块。 module.children 返回一个数组，表示该模块要用到的其他子级模块。 module.exports 表示模块对外输出的值。 实际上我们模块导入的过程就是为对应模块的module.exports对象增加成员的过程。 目录加载规则通常一个项目都有一个入口文件（或函数），比如C语言，Java中的main函数。在Node项目中，一般也会指定一个入口文件，让require方法可以通过这个入口文件，加载整个项目。 一般这个入口放在packge.json文件，并将入口文件写入main字段。如： 12345//packge.json&#123; \"name\": \"new_project\", \"main\": \"./main/index.js\"&#125; require发现参数字符串指向一个目录以后，会自动查看该目录的packge.json文件，然后加载main字段指定的入口文件。如果packge.json文件没有main字段，或者没有packge.json文件，则会加载该目录下的index.js文件或者index.node文件。 模块缓存Node会在第一次加载模块后，缓冲该模块（实际上是缓存该模块的module.exports属性）。如： 123require('./moudle1.js')require('./moudle1.js').num = 1require('./moudle1.js').num //1 上面三次导入一个模块，但是我们添加的成员变量在第三次缓冲时仍然可以访问到，证明其是被缓冲在内存中的。 我们可以通过删除require.cache的对应属性来删除模块缓冲。 删除模块缓冲12345678//删除指定模块delete require.cache[moduleName]Reflect.deleteProperty(require.cache, moduleName)// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) 模块的加载机制CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。 下面是一个模块文件lib.js。 123456789// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。 然后，加载上面的模块。 1234567// main.jsvar counter = require('./lib').counter;var incCounter = require('./lib').incCounter;console.log(counter); // 3incCounter();console.log(counter); // 3 上面代码说明，counter 输出以后，lib.js 模块内部的变化就影响不到 counter 了。 AMD描述AMD 全称为 Asynchromous Module Definition（异步模块定义）。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，它是一个在浏览器端模块化开发的规范。 AMD 模式可以用于浏览器环境并且允许异步加载模块，同时又能保证正确的顺序，也可以按需动态加载模块。 特点 AMD是依赖前置，即提前声明需要的依赖。 对依赖的加载是提前进行的，在运行前就加载所有的依赖。 用法模块通过 define 函数定义在闭包中，格式如下： 1define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]： 1define(function(require, exports, module) &#123;&#125;） factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 例子(require.js)定义模块12345678910111213141516171819define(['jquery'], function($)P&#123; var num = 555 var _version = 0.01 var showMessage = function(message)&#123; if(!message)&#123; return &#125;else&#123; $('#messageBox').html('欢迎访问' + name) &#125; &#125; return&#123; 'num':num, 'showMessage': showMessage &#125;&#125;)//_version为内部维护变量，无法被外部访问到 引入模块1234567891011121314// 配置文件require.config(&#123; baseUrl: 'js', paths: &#123; jquery: 'lib/jquery-1.11.1', &#125;&#125;);// 加载模块require(['jquery', 'script/hello'],function ($, hello) &#123; $(\"#btn\").click(function()&#123; hello.showMessage(\"test\"); &#125;);&#125;); CMD描述CMD（Common Module Definition） 是 SeaJS 在推广过程中对模块定义的规范化产出。CMD 规范的前身是 Modules/Wrappings 规范。 特点 CMD推崇依赖就近，即在依赖使用时才引入。 CMD是延迟执行的，即使用的时候才延迟执行的。 用法（SeaJS）1、seajs.config({…}); //用来对 Sea.js 进行配置。2、seajs.use([‘a’,’b’],function(a,b){…}); //用来在页面中加载一个或多个模块。3、define(function(require, exports, module){…}); //用来定义模块。Sea.js 推崇一个模块一个文件，遵循统一的写法：4、require(function(require){var a = require(“xModule”); … }); //require 用来获取指定模块的接口。5、require.async, //用来在模块内部异步加载一个或多个模块。 例如： 123456define(function(require)&#123; require.async(['aModule','bModule'],function(a,b)&#123; // 异步加载多个模块，在加载完成时，执行回调 a.func(); b.func(); &#125;) &#125;); 6、exports, //用来在模块内部对外提供接口。 例如： 123456define(function(require, exports)&#123; exports.varName01 = 'varValue'; // 对外提供 varName01 属性 exports.funName01 = function(p1,p2)&#123; // 对外提供 funName01 方法 .... &#125; &#125;); 7、module.exports, 与 exports 类似，用来在模块内部对外提供接口。例如： 123456define(function(require, exports, module) &#123; module.exports = &#123; // 对外提供接口 name: 'a', doSomething: function() &#123;...&#125;; &#125;;&#125;); 例子定义模块123456789101112131415161718192021222324252627// seajs 的简单配置seajs.config(&#123; base: \"../sea-modules/\", alias: &#123; \"jquery\": \"jquery/jquery/1.10.1/jquery.js\" &#125;&#125;);// 所有模块都通过 define 来定义define(function(require, exports, module) &#123; // 通过 require 引入依赖 var $ = require('jquery'); var Spinning = require('./spinning'); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ... //或者使用return向外提供接口 return &#123; someVal: someVal, doSomething: doSomething &#125;&#125;); 如果retunr语句是模块的唯一代码，还可以简化为： 1234define(&#123; someVal: someVal, doSomething: function() &#123;&#125;&#125;); 引入模块1234567891011121314151617181920212223//单一模式seajs.use('./a') //回调模式seajs.use('./a', function(a) &#123; a.run()&#125;); //多模块模式seajs.use(['./a', './b'], function(a, b) &#123; a.run() b.run()&#125;)//在一个模块中引入其他模块define(function(require, exports, module) &#123; //同步引入其他模块 var module1 = require('./module1') //异步引入其他模块 var module2 = require.async('./module2')&#125;) 注意： 对 module.exports 的赋值需要同步执行，不能放在回调函数里。 在html中 ，为script标签添加data-main = true确定其为主入口。data-main通常用在只有一个入口的情况，use可以用在多个入口的情况 UMD描述UMD（Universal Module Definition），AMD模块以浏览器第一的原则发展，异步加载模块。CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。 特点 兼容 AMD 和 CommonJS 规范的同时，还兼容全局引用的方式 例子1234567891011121314151617(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; //AMD define(['jquery'], factory); &#125; else if (typeof exports === 'object') &#123; //Node, CommonJS之类的 module.exports = factory(require('jquery')); &#125; else &#123; //浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery); &#125;&#125;(this, function ($) &#123; //方法 function myFunc()&#123;&#125;; //暴露公共方法 return myFunc;&#125;)); ES Module描述在 ES Module 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES Module 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES Module 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 CommonJS 和 AMD 模块，其本质是在运行时生成一个对象进行导出，称为“运行时加载”，没法进行“编译优化”，而 ES Module 不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。这称为“编译时加载”或者静态加载，即 ES Module 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES Module 模块本身，因为它不是对象。 由于 ES Module 是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ESz Module 还有以下好处： 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES Module 格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。 不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。 特点 静态编译 输出的值引用，而非值拷贝 import 只能写在顶层，因为是静态语法 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。（具体严格模式内容不再赘述） 例子导出模块123456789101112131415161718192021222324252627282930//module1.jslet pi = 3.1415926let d = 'default'let sum = function(a, b)&#123; return a + b&#125;let bactch1 = 1let bactch2 = 2let bactch3 = 3//导出已定义的变量export piexport sum//直接导出声明的变量export const e = 2.718281828459export function multiply(x, y) &#123; return x * y;&#125;;//批量导出export &#123;bactch1, bactch2, bactch3&#125;//导出默认export default d//对导出变量重命名,并且重命名为default，与上面的说法一致export &#123;d as default&#125; 注意： export default 命令用于指定模块的默认输出。export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字 export default只能导出变量，不能在后面声明变量。如： 12//错误export default const pi = 3.1415926 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 如： 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 面代码输出变量foo，值为bar，500 毫秒之后变成baz。 导入模块1234567891011//直接导入模块所有成员import * from 'module1'//批量导入模块import &#123;pi, e, sum&#125; from 'module1'//直接执行所加载的模块import 'lodash';//在一条import语句中，同时输入默认方法和其他接口import _, &#123; each, forEach &#125; from 'lodash'; 注意 export后无法直接接变量内容。如： 12//错误export 3 import()import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以import和export命令只能在模块的顶层，不能在代码块之中。如，下面的代码会报错 1234// 报错if (x === 2) &#123; import MyModual from './myModual';&#125; 但是有时候我们需要按需引入又该怎么办，ES2020提案 引入import()函数，支持动态加载模块。 import(specifier) 特点 import函数的参数specifier，指定所要加载的模块的位置。 import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import()返回一个 Promise 对象。模块作为Promise的参数返回下面是一个例子。 123456789const main = document.querySelector('main');import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 兼容性 总结目前JavaScript的模块规范就是上面谈到的四种，CommonJS、AMD、CMD、ES Module。 CommonJS 用在服务器端，AMD 和CMD 用在浏览器环境，ES Module 是作为终极通用解决方案，时下热议的vite即利用了ES Module。 比较AMD 和 CMD 的区别 执行时机： AMD 是提前执行，CMD 是延迟执行。 对依赖的处理：AMD 推崇依赖前置，CMD 推崇依赖就近。 API 设计理念：AMD 的 API 默认是一个当多个用，非常灵活，CMD 的 API 严格区分，推崇职责单一。 遵循的规范：RequireJS 遵循的是 Modules/AMD 规范，SeaJS 遵循的是 Mdoules/Wrappings 规范的 define 形式。 设计理念：SeaJS 设计理念是 focus on web, 努力成为浏览器端的模块加载器，RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。 CommonJS 和 ES Module 的区别 加载时机：CommonJS 是运行时加载（动态加载），ES Module 是编译时加载（静态加载） 加载模块：CommonJS 模块就是对象，加载的是该对象，ES Module 模块不是对象，加载的不是对象，是接口 加载结果：CommonJS 加载的是整个模块，即将所有的接口全部加载进来，ES Module 可以单独加载其中的某个接口（方法） 输出：CommonJS 输出值的拷贝，ES Module 输出值的引用 this: CommonJS 指向当前模块，ES Module 指向 undefined 参考 JavaScript 模块化总结 Module 的语法-阮一峰 import-MDN Javascript模块化编程（一）：模块的写法-阮一峰","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"AMD","slug":"AMD","permalink":"http://yoursite.com/tags/AMD/"},{"name":"CMD","slug":"CMD","permalink":"http://yoursite.com/tags/CMD/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://yoursite.com/tags/CommonJS/"},{"name":"ES Module","slug":"ES-Module","permalink":"http://yoursite.com/tags/ES-Module/"}]},{"title":"Fetch方法的使用","slug":"Fetch方法的使用","date":"2021-02-13T06:16:24.000Z","updated":"2021-02-17T05:21:09.103Z","comments":true,"path":"2021/02/13/Fetch方法的使用/","link":"","permalink":"http://yoursite.com/2021/02/13/Fetch%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"介绍Fetch是基于Promise开发的用于访问和操纵 HTTP 管道的一个API。其提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。 以前浏览器中的网络请求只能通过XMLHttpRequest实现（虽然大多使用的是封装过后的接口）。而Fetch则结合Promise提供了一种更加简化的发送网络请求的方式（其调用方法与axiso相似）。 用法Fetch()方法Fetch接受两个参数： Promise&lt;Response&gt; fetch(input[, init]); ?input 定义要获取的资源。这可能是：一个 USVString字符串，包含要获取资源的 URL。一些浏览器会接受 blob: 和 data: 作为 schemes.一个 Request对象。 init 可选 一个配置项对象，包括所有对请求的设置。可选的参数有： method: 请求使用的方法，如 GET、POST。 headers: 请求的头信息，形式为 Headers值的对象字面量。 body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。 mode: 请求的模式，如 cors、 no-cors 或者 same-origin。 credentials: 请求的 credentials，如 omit、same-origin 或者include。为了在当前域名内自动发送 cookie ， 必须提供这个选项， 从 Chrome 50 开始， 这个属性也可以接受 FederatedCredential 实例或是一个 PasswordCredential 实例。 cache: 请求的 cache 模式: default、 no-store、 reload 、 no-cache、 force-cache或者 only-if-cached 。redirect: 可用的 redirect 模式: follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误）, 或者 manual (手动处理重定向). 在Chrome中默认使用follow（Chrome 47之前的默认值是manual）。 referrer: 一个 [USVString](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString) 可以是no-referrer、client或一个 URL。默认是client。` referrerPolicy: 指定了HTTP头部referer字段的值。可能为以下值之一： no-referrer、no-referrer-when-downgrade、origin、origin-when-cross-origin、unsafe-url 。 integrity: 包括请求的 subresource integrity 值 （ 例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。 返回值一个 Promise对象。 例子发送带凭据的请求注意：Fetch默认是不携带凭据的请求（即使是跨域源），要将credentials: &#39;include&#39;添加到传递给 fetch()方法的init对象，才能使请求携带凭证。 123fetch('https://example.com', &#123; credentials: 'include'&#125;) 如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加 credentials: &#39;same-origin&#39;。 12345// The calling script is on the origin 'https://example.com'fetch('https://example.com', &#123; credentials: 'same-origin'&#125;) 上传 JSON 数据使用 fetch() POST JSON数据 123456789101112var url = 'https://example.com/profile';var data = &#123;username: 'example'&#125;;fetch(url, &#123; method: 'POST', // or 'PUT' body: JSON.stringify(data), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; 'Content-Type': 'application/json' &#125;)&#125;).then(res =&gt; res.json()).catch(error =&gt; console.error('Error:', error)).then(response =&gt; console.log('Success:', response)); 上传文件可以通过 HTML &lt;input type=&quot;file&quot; /&gt; 元素，FormData()和 fetch()上传文件。 123456789101112var formData = new FormData();var fileField = document.querySelector(\"input[type='file']\");formData.append('username', 'abc123');formData.append('avatar', fileField.files[0]);fetch('https://example.com/profile/avatar', &#123; method: 'PUT', body: formData&#125;).then(response =&gt; response.json()).catch(error =&gt; console.error('Error:', error)) 上传多个文件可以通过HTML &lt;input type=&quot;file&quot; mutiple/&gt; 元素，FormData()和 fetch()上传多个文件。 12345678910111213141516var formData = new FormData();var photos = document.querySelector(\"input[type='file'][multiple]\");formData.append('title', 'My Vegas Vacation');// formData 只接受文件、Blob 或字符串，不能直接传递数组，所以必须循环嵌入for (let i = 0; i &lt; photos.files.length; i++) &#123; formData.append('photo', photos.files[i]);&#125;fetch('https://example.com/posts', &#123; method: 'POST', body: formData&#125;).then(response =&gt; response.json()).then(response =&gt; console.log('Success:', JSON.stringify(response))).catch(error =&gt; console.error('Error:', error)); 自定义请求对象除了传给 fetch() 一个资源的地址，你还可以通过使用 Request()构造函数来创建一个 request 对象，然后再作为参数传给 fetch()： 123456789101112131415var myHeaders = new Headers();var myInit = &#123; method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' &#125;;var myRequest = new Request('flowers.jpg', myInit);fetch(myRequest).then(function(response) &#123; return response.blob();&#125;).then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL;&#125;); Request() 和 fetch() 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝： 1var anotherRequest = new Request(myRequest,myInit); Request对象Request构造器可以构造一个Request对象，其作为Fetch方法的参数。 该构造器接受的参数与Fetch一致： 请求地址 init对象 此处不再赘述。 此外，我们可直接通过const method = Request.method的方式来获取init属性。如： 12345const myRequest = new Request('http://localhost/flowers.jpg');const myURL = myRequest.url; // http://localhost/flowers.jpgconst myMethod = myRequest.method; // GETconst myCred = myRequest.credentials; // omit 方法Request对象有以下方法可以调用： Request.clone() 创建当前request的副本。 Request实现 Body`， 因此它也有以下方法可用: Body.arrayBuffer() 返回解决一个ArrayBuffer表示的请求主体的promise. Body.blob() 返回解决一个Blob表示的请求主体的promise. Body.formData() 返回解决一个FormData表示的请求主体的promise. Body.json() 返回解决一个JSON表示的请求主体的promise. Body.text() 返回解决一个USVString(文本)表示的请求主体的promise. 注意：这些Body功能只能运行一次; 随后的调用将通过空strings/ ArrayBuffers解析. header对象使用 Headers的接口，你可以通过 Headers()构造函数来创建一个你自己的 headers 对象。一个 headers 对象是一个简单的多名值对： 12345let content = \"Hello World\";let myHeaders = new Headers();myHeaders.append(\"Content-Type\", \"text/plain\");myHeaders.append(\"Content-Length\", content.length.toString());myHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\"); 也可以直接接受一个字面量对象来构造header对象 12345myHeaders = new Headers(&#123; \"Content-Type\": \"text/plain\", \"Content-Length\": content.length.toString(), \"X-Custom-Header\": \"ProcessThisImmediately\",&#125;); 方法 Headers.append() 给现有的header添加一个值, 或者添加一个未存在的header并赋值. Headers.delete() 从Headers对象中删除指定header. Headers.entries() 以 迭代器 的形式返回Headers对象中所有的键值对. Headers.get() 以 ByteString 的形式从Headers对象中返回指定header的全部值. Headers.has() 以布尔值的形式从Headers对象中返回是否存在指定的header. Headers.keys() 以迭代器的形式返回Headers对象中所有存在的header名. Headers.set() 替换现有的header的值, 或者添加一个未存在的header并赋值. Headers.values() 以迭代器的形式返回Headers对象中所有存在的header的值. 注意 在header已存在或者有多个值的状态下Headers.set()和 Headers.append()的使用有如下区别, Headers.set()将会用新的值覆盖已存在的值, 但是Headers.append()会将新的值添加到已存在的值的队列末尾. 如果您尝试传入名称不是有效的HTTP头名称的引用，则所有Headers方法都将引发 TypeError 。 如果头部有一个不变的Guard，则变异操作将会抛出一个 TypeError 。 在其他任何失败的情况下，他们默默地失败。 出于安全考虑，某些头只能由用户代理控制。这些头信息包括 forbidden header names 和 forbidden response header names。 一个Headers对象也有一个关联的guard，它具有不可变的值，request，request-no-cors，response或none。 这会影响 set()，delete(), 和append()`方法 改变header. Guard属性描述Guard 是 Headers对象的特性，基于不同的情况，它可以有以下取值：immutable、request、request-no-cors、response 或 none。 由于 Headers 可以在 request 请求中被发送或者在 response 请求中被接收，并且规定了哪些参数是可写的，Headers 对象中的 guard 属性。这个属性没有暴露给 Web，但是它影响到哪些内容可以在 Headers 对象中被操作。 规则当使用 Headers()constructor创建一个新的 Headers对象的时候，它的 guard 被设置成 none（默认值）。当创建 Request或 Response对象的时候，它将拥有一个按照以下规则实现的与之关联的 Headers`对象： 新对象的类型 创建时的构造函数 关联的 Headers对象的 guard Request Request() request Request Request()，mode 设置成 no-cors request-no-cors Response Response() response Response immutable immutable guard属性值的特征： none：默认的 request：从 request 中获得的 headers（Request.headers）只读 request-no-cors：从不同域（Request.mode no-cors）的 request 中获得的 headers 只读 response：从 response 中获得的 headers（Response.headers）只读 immutable：在 ServiceWorkers 中最常用的，所有的 headers 都只读。 Response 对象描述如上所述，Response实例是在 fetch() 处理完 promise 之后返回的。其呈现了对一次请求的响应数据。 我们可以通过一个构造函数来创建一个Response对象，但更多的是通过一个Fetch请求返回的Response对象。 属性 Response.headers只读 包含此 Response 所关联的 Headers对象。 Response.ok只读 包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。 Response.redirected只读 表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。 Response.status只读 包含 Response 的状态码 （例如 200 表示成功）。 Response.statusText只读 包含了与该 Response 状态码一致的状态信息（例如，OK对应 200）。 Response.type 只读 包含 Response 的类型（例如，basic、cors）。 Response.url只读 包含 Response 的URL。 Response.useFinalURL 包含了一个布尔值，来标示这是否是该 Response 的最终 URL。 Response 实现了 Body接口，所以以下属性亦可用： Body.body 只读 一个简单的 getter，用于暴露一个 ReadableStream类型的 body 内容。 Body.bodyUsed只读 包含了一个布尔值来标示该 Response 是否读取过 Body。 方法 Response.clone() 创建一个 Response 对象的克隆。 Response.error() 返回一个绑定了网络错误的新的 Response 对象。 Response.redirect() 用另一个 URL 创建一个新的 Response。 Response 实现了 Body接口，所以以下方法同样可用： Body.arrayBuffer() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 ArrayBuffer格式的 Promise 对象。 Body.blob() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 Blob 格式的 Promise 对象。 Body.formData() 读取Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 FormData 格式的 Promise 对象。 Body.json() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 JSON 格式的 Promise 对象。 Body.text() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 USVString 格式的 Promise 对象。 body对象Body代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。 一般我们也是从一个请求中得到一个body对象。当然，直接通过body构造器来创建一个body也是被允许的。 属性 Body.body 只读一个简单的getter用于暴露一个ReadableStream类型的主体内容。 Body.bodyUsed 只读一个Boolean 值指示是否body已经被标记读取。 方法 Body.arrayBuffer() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是ArrayBuffer。此操作会将bodyUsed状态改为已使用（true）。 Body.blob() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是Blob。此操作会将bodyUsed状态改为已使用（true）。 Body.formData() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是FormData表单。此操作会将bodyUsed状态改为已使用（true）。 Body.json() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是使用JSON解析body文本的结果。此操作会将bodyUsed状态改为已使用（true）。 Body.text() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是USVString（文本）。此操作会将bodyUsed状态改为已使用（true）。 比起XHR来，这些方法让非文本化的数据使用起来更加简单。 兼容性 可以看到Fetch的兼容性还是有一定的问题，Chrome42版本才开始支持从与Firefox从39版本才支持，而IE到目前位置都不支持。这是一个很大的问题。如果要在生产环境中使用，必须引入很多pollyfill，相较于使用Promise封装的XHR，这样看来优势又荡然无存，随着版本的迭代，未来肯定是Fetch的，但不是现在。 参考 使用 Fetch-MDN","categories":[{"name":"Fetch","slug":"Fetch","permalink":"http://yoursite.com/categories/Fetch/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Fetch","slug":"Fetch","permalink":"http://yoursite.com/tags/Fetch/"}]},{"title":"about跨域","slug":"about跨域","date":"2021-02-09T14:29:31.000Z","updated":"2021-10-21T06:45:37.073Z","comments":true,"path":"2021/02/09/about跨域/","link":"","permalink":"http://yoursite.com/2021/02/09/about%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"域的概念域（Domain）作为计算机网络中一个重要的概念，其阐述的是：网络中一组计算机的逻辑集合，是活动目录中的核心单元、是活动目录的分区。其有以下特点： 域定义了安全边界，每个域均有各自的安全策略以及与其它域的信任关系，在没有授权的情况下，不允许其他域中的用户访问本域中的资源。 中可以存储上百万个对象，不同的域之间具有层次关系，可以建立域树或域林，以便于域的扩展。域树通常由一个或多个共享连续的名称空间的域组合而成，其中第一个域称作根域，其他域称为子域，如图。 域林通常由一个或多个域树组成，如图10-15所示。其中，各个域树并不共享相同的名称空间，但域林内所有域树的域都具有相同的架构、配置信息、全局目录（Global Catalog）等。 所以浏览器根据域的概念，规定了同源策略（Sameoriginpolicy），其是浏览器最重要的安全策略之一。其保证了每个网页的安全性。确保非同源站点无法相互访问资源，JavaScript交互等。具体到浏览器中，同源是指具有相同的： 协议 域名 子域 端口 这其中任何一项不同，皆被视为非同源。会受到同源策略的限制。具体的url的格式： 注意：上面写的仅仅是url中影响影响跨域的4部分，url还有一下的部分： 虚拟目录部分 文件名部分 锚点部分 参数部分 完整的目录结构如下： 在浏览器中，同源策略限制的对象有： Cookie、sessionStorage、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求 但是下面的4个请求是允许跨域请求资源的： &lt;img src=XXX&gt; &lt;video src=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 客户端和服务端通信jsonp原理jsonp（JSON with Padding）本身是一种hack的方法来实现跨域，其利用的原理有两个： script没有同源策略的限制。 script标签请求的数据会直接执行。这一点就排除了img和link两个标签。 具体原理是：利用script的src属性，发送带有callback回调函数的GET请求，服务端在接受数据后，将要发送的数据作为函数的参数传回client，由于script会立即执行，则可以直接拿到数据。 优缺点优点兼容性强，支持IE10以下浏览器跨域问题（CORS不支持） 缺点 仅支持GET方法（由script标签的请求性质决定） 安全性不高，易遭受攻击 实现client端原生JavaScript实现12345678910&lt;script&gt; function login(res)&#123; //拿到服务端结果 &#125; //发送JSONP请求 let jp = document.createElement('script') script.type= 'text/javascript' jp.src = 'http://www.jsonp.com:8080/login?user = admin &amp; callback = login' document.body.appendChild(script)&lt;/script&gt; 可以看到jsonp中的src其实并不是一个脚本地址，而是一个请求地址。 JQuery实现12345678910111213$ajax(&#123; url: 'http://www.jsonp.com:8080/login', type: get, dataType: 'jsonp', jsonCallback: 'login', data: &#123; user: 'admin' &#125;&#125;)function login(res)&#123; //拿到结果&#125; axios实现123$.getJSON(\"https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?\", function(data) &#123; //data &#125;); server端返回数据： 1login(&#123;'status': true, 'user': 'admin'&#125;) CORS方案CORS（Cross-origin resource sharing），即跨域资源共享。它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。 同源安全策略 默认阻止“跨域”获取资源，即网页发送的跨域请求根本不会达到服务器即被浏览器拦截，服务器没有决定的权限。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。 CORS将不同的请求分为简单请求与复杂请求，根据请求的不同，CORS会进行不同的操作。 对于复杂请求，CORS会先发送一个OPTIONS预请求。具体再后面复杂请求时进行。 首先我们区分一下简单请求与复杂请求： 简单请求简单请求必须满足几个条件： 使用的方法以下类型： GET HEAD POST 除了被用户代理自动设置的首部字段（例如 Connection ，User-Agent）和在 Fetch 规范中定义为 禁用首部名称 的其他首部，允许人为设置的字段为 Fetch 规范定义的 对 CORS 安全的首部字段集合。该集合为： Accept Accept-language Content-Type（下面有额外限制） DPR Downlink Save-Data Viewport-Width Width Content-Type的值仅限于以下三种： text/plain multipart/form-data-默认表单提交模式，实际上再body部分还是xxx=xxx&amp;yyy=yyy得形式进行传递。 application/x-www-form-urlencoded-当表单需要文件上传的时候的类型。 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象。 例子 12345678910111213141516171819202122GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin: http://foo.exampleHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61Access-Control-Allow-Origin: *Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml[XML Data] 请求中关键的是： Origin: http://foo.example 它表明请求来源是http://foo.example 响应中关键的是： Access-Control-Allow-Origin: * 其表明该资源允许被任意外域访问。但一般最好是值开放给规定的域，以保证安全： Access-Control-Allow-Origin:http://foo.example 复杂请求所有非简单请求皆为复杂请求，对于复杂请求，浏览器会首先发起一个预检请求（OPTIONS），以获取服务器是否允许该请求。 下面是一次复杂请求的过程： 第一次预请求头部： 1234567891011121314151617181920212223242526OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://foo.exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-TypeHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 在请求头部中：最重要的几个字段为： Origin: http://foo.example：表示请求的来源为http://foo.example，使服务端进行鉴别是否够允许该请求来源。 Access-Control-Request-Method: POST：表示正式请求的方法为POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type：表示正式请求将携带两个自定义请求头部字段：X-PINGOTHER，Content-Type，服务器据此决定，该实际请求是否被允许。 在响应头部中：最为重要的几个字段为： Access-Control-Allow-Origin: http://foo.example：表示服务端允许来自http://foo.example的请求。 Access-Control-Allow-Methods: POST, GET, OPTIONS：表示服务端允许的方法为POST,GET,OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type：表示服务端允许携带自定义请求头部字段为：X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400：表示响应的有效时间为86400秒，也就是24小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。 请注意：浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。 附带身份凭证的请求在XMLHttpRequest 或 Fetch的CORS中，可以基于HTTP cookies和HTTP认证信息发送身份凭证。 但在默认情况下，浏览器不会携带身份信息。如果要使浏览器携带信息，需手动设置： 1234567891011var invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/credentialed-content/';function callOtherDomain()&#123; if(invocation) &#123; invocation.open('GET', url, true); invocation.withCredentials = true; //关键 invocation.onreadystatechange = handler; invocation.send(); &#125;&#125; 注意：不光client要设置withCredentials。 server还需要设置一个头部属性： Access-Control-Allow-Credentials: true 如果响应中缺失 Access-Control-Allow-Credentials: true（第 17 行），则响应内容不会返回给请求的发起者。 注意： 如果要使请求携带身份凭证，服务端不得设置Access-Control-Allow-Origin为*。 响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。 下面简单列举一下CORS中常用的HTTP头部字段 总结来说这两种方法，简单请求由于规范了一些属性，所以只需要验证origin。 而复杂请求给了开发者更多可自定义项，则需要服务端进行更多的验证，包括来源，请求方式，请求头字段等。 Fetchfetch是一个可以用域访问和操作HTTP管道的API。这个方法是为了替代之前的XMLHttpRequest。该API不需要像XMLHttpRequest进行复杂的配置。且不基于回调方案，而是结合了ES6的Promise来进行数据的处理。就像使用axios一样简单。唯一的问题是该方法不能被pollyfill，且兼容性不是特别好，IE所有版本均不兼容。 但是我们必须了解，因为其是未来的网络连接方案。 fetch全局方法可以接受两个参数，第一个是url，第二个是配置数据（部分如下），并返回一个Promise。 url: url地址（可以为blob）。 options: method: 请求使用的方法，如 GET、POST。 headers: 请求的头信息，形式为 Headers值的对象字面量。 body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams或者 USVString对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。 mode: 请求的模式，如 cors no-cors 或者 same-origin。 credentials: 请求的 credentials，如 omit、same-origin 或者include。为了在当前域名内自动发送 cookie ， 必须提供这个选项。 其中的mode参数即可以直接设置是否跨域。如果填写no-cors，则该请求会被限制为仅同源可请求。只要这个字段传入一个任意的字符串或者不填，都是默认cors。 当然，原理还是CORS，所以服务器还是需要设置字段进行相应的配置。 其实fetch有很多可说，具体可以参考我写的另外一篇文章Fetch方法的使用 中间件代理描述中间件代理服务器即利用一个中间服务器转发实际服务器的请求，由于中间件服务器与实际服务器之间不需要遵循同源策略，即可以从实际服务器请求数据。实际上代理的主要作用并不是应对跨域。而是如其名，代理后端真实服务器，比如在分布式设计中，一个代理服务器可以代理后端多台真实服务器，做到具体业务和底层逻辑解耦。 实际上这种方式下，代理服务器仍然需要进行跨域配置，但是免去了后端真实服务器的跨域配置。具体流程如下： 例子在node中，一般使用express做为server容器，其中的express-http-proxy可以直接用来转发请求，作为一个中间件代理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//middleware.jsconst app = express();const http = require(\"http\");let proxy = require('express-http-proxy');//配置跨域app.use((req, res, next) =&gt; &#123; res.header('Access-Control-Allow-Origin', \"*\"); res.header('Access-Control-Allow-Headers', 'Content-Type,Content-Length,Authorization,Accept,X-Requested-With'); res.header('Access-Control-Allow-Methods','PUT,POST,GET,DELETE,OPTIONS'); res.header('X-Powered-By', '3.2.1') if(req.method === 'OPTIONS') &#123; res.send(200); &#125; else &#123; next(); &#125;&#125;);//配置代理服务器，代理/api接口app.use('/api', proxy('http://realServer.com', &#123; //过滤器 filter: function(req, res)&#123; return req.method === 'GET' &#125;, //请求路径解析 proxyReqPathResolver: function(req)&#123; return req.url+'token=123456' //请求转发路径 &#125;, //返回数据处理,如果过程有异步操作应返回Promise（可选） userResDecorator: function(proxyRes, proxyResData, userReq, userRes) &#123; //同步 data = JSON.parse(proxyResData.toString('utf8')); data.newProperty = 'exciting data'; return JSON.stringify(data); //异步 return new Promise(function(resolve) &#123; proxyResData.funkyMessage = 'oi io oo ii'; setTimeout(function() &#123; resolve(proxyResData); &#125;, 200); &#125;); &#125;,&#125;))app.listen(3000) 真实服务器不需要配置跨域，仅一个简单的server即可（这里也采用express） 12345678//server.jsconst app = express();const http = require(\"http\");app.get('/api', function(req, res)&#123; res.send('REAL SERVER MESSAGE!')&#125;) 业务中，使用代理服务器多用于业务解耦，或者负载均衡，跨域只是其中一个特点。 nginx反向代理描述使用nginx反向代理其本质与node中间件代理一样，都是使用一个中间服务器，来转发请求到实际的后端服务器中，但同样，nginx的反向代理多用来做负载均衡或业务解耦，跨域问题的解决只是其中一个特点。 例子下面那是一个简单的nginx的配置： 1234567891011121314// proxy服务器server &#123; listen 80; server_name www.middleware.com; location / &#123; proxy_pass http://www.realServer.com:8080; #关键，反向代理 proxy_cookie_domain www.realServer.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.middleware.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 跨页面通信postMessage描述window.postMessage()方法可以安全地实现跨源通信。此方法可以不考虑两个页面是否同源。只要能拿到对应窗口的引用对象，就可以使用该api进行通信。 窗口引用我们可以通过： 子窗口window.open(URL,name,features,replace) | 参数 | 描述 || :——- | :———————————————————– || URL | 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 || name | 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 和 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 || features | 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 || replace | 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。 | 1let newwin = window.open('http://www.child.com', 'child') iframe let newWin = document.getElemetnById(&#39;iframe&#39;).contentWindow 拿到窗口引用。 语法otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow：其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。 message：将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。[1] targetOrigin`：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。**如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是\\。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。** transfer可选：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 示例123//parent windowlet newWin = window.open('http://www.child.com', 'child')newWin.postMessage('hello', 'https://www.orgin.com') 在子窗口中我们可以添加message事件监听。 12345window.onmessage = function(e) &#123; console.log(e.data) //hello //返回消息 e.source.postMessage('world', e.origin)&#125; websocket通信描述 Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。 websocket本身支持跨域，不会存在CORS的限制。 WebSocket和HTTP都是应用层协议，都基于 TCP 协议。 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。 WebSocket在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 例子在前端我们使用Websocket构造器来新建一个Websocket实例。 12345678910let socket = new Websocket('ws://websocketServer.com')socket.onopen = function()&#123; //向服务器发送数据 socket.send('client-connect...')&#125;socket.onmessage = function(e)&#123; //接受服务器返回的数据 console.log(e.data) &#125; 在后端我们采用node.js，其他语言差别不大。 12345678910let express = require('express')let app = express()let Websocket = require('ws')let wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection', function(ws)&#123; ws.on('message', function(data)&#123; console.log(data) //client-connect... ws.send('server-connect...') &#125;)&#125;) document.domain + iframe该方法仅适用于主域相同，子域不同的场景。 原理两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 例子123456789101112&lt;!-- a.html --&gt;&lt;body&gt; &lt;iframe src=\"http://source.com:3000/b.html\" frameborder=\"0\" onload=\"load()\" id=\"frame\"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'source.com' function onload()&#123; //读取b.html中的变量 console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678&lt;!-- b.html --&gt;&lt;body&gt; hellob &lt;script&gt; document.domain = 'source.com' let a = 100; &lt;/script&gt;&lt;/body&gt; 两个hack方法下面的两个方法是利用一些hack的方法进行通信，往往更加麻烦，所以参考一下即可。 window.name + iframe原理window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在（这一点很重要），并且可以支持非常长的 name 值（2MB）。 例子其中a.html和b.html是同域的，都是http://localhost:3000，但b.html为a.html的iframe，则a.html与b.html可以使用window.name进行通信;而c.html是http://localhost:4000 1234567891011121314151617&lt;!-- a.html(http://localhost:3000/b.html) --&gt; &lt;iframe src=\"http://localhost:4000/c.html\" frameborder=\"0\" onload=\"load()\" id=\"iframe\"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125; &lt;/script&gt; b.html为中间代理页，与a.html同域，内容为空。 1234&lt;!-- c.html(http://localhost:4000/c.html) --&gt; &lt;script&gt; window.name = 'hello' &lt;/script&gt; 本方法利用了window.name属性在切换源后不变的性质，将数据传送到外域。但是比较复杂，需要用第三个页面进行中转，所以一般不用。 location.hash + iframe原理与window.name上一种方法相似， a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接JavaScript访问来通信。 例子其中a.html和b.html是同域的，都是http://localhost:3000，但b.html为a.html的iframe;而c.html是http://localhost:4000 123456789101112131415&lt;!-- http://www.localhost:3000/a.html --&gt;&lt;iframe id=\"iframe\" src=\"http://www.localhost:4000/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + '#user=admin'; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert('data from c.html ---&gt; ' + res); &#125;&lt;/script&gt; 12345678910&lt;!-- http://www.localhost:4000/b.html --&gt;&lt;iframe id=\"iframe\" src=\"http://www.localhost:3000/c.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt; 12345678&lt;!-- http://www.localhost:3000/c.html --&gt;&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); &#125;;&lt;/script&gt; 总结上面总结了很多方法， 但是CORS和jsonp是使用最多的跨域方法，CORS在现代开发中使用最多，但是jsonp兼容性更强，对于低版本的浏览器（比如IE10以下），可以实现跨域。 代理方法的用处不仅限于解决跨域，它有更大的作用，后期再探讨。 后面页面通信中，postMessage使用的更多，其他的hack方法仅在特定的环境下才有较好的效果。 参考 前端跨域系列（3）- 跨域方法总结 WebSockets URL组成详解 express-http-proxy express-http-proxy Cross-Origin Resource Sharing (CORS)","categories":[{"name":"通信","slug":"通信","permalink":"http://yoursite.com/categories/%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"通信","slug":"通信","permalink":"http://yoursite.com/tags/%E9%80%9A%E4%BF%A1/"}]},{"title":"JavaScript宏任务，微任务与Event-loop","slug":"JavaScript宏任务，微任务与Event-loop","date":"2021-02-09T10:47:09.000Z","updated":"2021-03-11T08:49:44.762Z","comments":true,"path":"2021/02/09/JavaScript宏任务，微任务与Event-loop/","link":"","permalink":"http://yoursite.com/2021/02/09/JavaScript%E5%AE%8F%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8EEvent-loop/","excerpt":"","text":"浏览器进程（chrome）chrome中有5个主要进程： 浏览器进程（Browser Process）：顶层进程，负责浏览器各进程工作，Tab外的工作由它负责。 UI Thread：负责浏览器按钮、地址栏。 storage Thread：负责文件访问。 渲染器进程（Renderer Process）：浏览器内核，负责Tab内的所有工作。 Main Thread ：构建dom树 -&gt; 加载资源 -&gt; js下载与执行 -&gt; 样式计算 -&gt; 构建布局树 -&gt; 绘制 -&gt; 创建层树。（注：Main不是一个线程，而是多个线程的集合，为了方便介绍先聚合一下，后面展开讲）。 Worker Thread: Web Worker 运行在这个线程，可能存在多个。 Compositor Thread: 合成器，将层合成帧，分成多个磁贴。 Raster Thread: 栅格化磁贴后交给GPU。 网络进程（Network Process）：负责真正的发送http请求，接收和发送网络请求。 插件控制进程（Plugin Process）：控制所有的插件。 GPU进程（GPU Process）：其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3DCSS的效果，只是随后网页、Chrome的UI界面都选择采取GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome也引入了GPU进程。 Main线程Main线程是一些线程的集合，主要用于整个网页的工作。 其包括： GUI渲染线 程： 负责渲染工作，包括解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 注意：GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存等到JS引擎空闲时立即被执行。 JS引擎线程： JS引擎线程负责解析Javascript脚本，运行代码（比如Chrome的V8)。 一个Tab页内中无论什么时候都只有一个JS线程在运行JS。 因为GUI渲染线程与JS引擎线程是互斥的，所以当JS执行的时间过长，页面的渲染也会阻塞。 事件触发线程： 主要用来控制事件循环，添加回调事件到队列中。 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会被添加到事件线程中。 当对应的事件符合触发条件并被触发时，该线程会把事件添加到队列的队尾，等待JS引擎的处理 注：由于JS单线程的关系，所以这些队列中的事件都得等JS引擎空闲了才会被执行 定时触发器线程： setInterval与setTimeout执行的线程。 由于js引擎是单线程的，如果由js来计时会影响计时准确性，因此额外使用一个线程来计时并触发定时。 但是需要注意的是： setInterval与setTimeout的计时并不是很准确的，其误差在（10~20ms）： 再chrome底层中规定setInterval的最低时间为4ms。 windows等系统底层的时间并不是完全准确的，普通的时间API误差在10~15ms（部分情况）。 由于JavaScript引擎是单线程，即使回调完全准确的将任务加入执行队列，但是前面的任务的执行时间仍然会增加回调任务的误差。 异步http请求线程： XMLHttpRequest连接后会新开一个线程。 将检测到状态变更时，如果设置有回调函数，该线程就产生状态变更事件。 当然，实际做请求工作的还是 Network Process。 JavaScript单线程JavaScript的一大特点就是单线程设计，这一特点也造成了JavaScript的众多特性。这样设计可以使程序的开发更加简单，因为其不会涉及线程的通信，管理，比如在操作DOM的时候，如果是多线程，就需要组织各个线程的先后关系，但是单线程就不会涉及这些问题。这也使得JavaScript成为了一门入门比较简单的语言。 同步与异步而JavaScript的任务又分为同步任务和异步任务。 同步任务是指直接按照代码顺序将其加入到执行栈中任务。 而异步任务是指需要一定的时间才能完成，并且这段时间的操作不是JavaScript线程能够控制的，这个时候则需要其他线程予以辅助。比如上面的定时触发器线程，异步http请求线程等。都可以帮助JavaScript完成定时器和http请求的异步任务。而上面的事件触发线程则用来在异步任务完成时，将回调函数添加到执行栈中。其基本过程如图： 执行栈（Execution Stack）当我们调用一个方法的时候，js会生成一个与这个方法相对应的执行环境，也叫执行上下文，这个执行环境存在着这个方法的私有作用域、参数、this对象等等。因为js是单线程的，同一时间只能执行一个方法，所以当一系列的方法被依次调用的时候，js会先解析这些方法，把其中的任务按照执行顺序排队到一个地方，这个地方叫做执行栈。 事件表格（Event Table）JavaScript保有的一中数据结构，它会存储所有的延迟事件（回调函数）。在对应异步操作完成过后，会由事件触发线程将对应的回调函数添加到事件队列中等待执行。 事件队列（Event queue）当我们发出一个ajax请求或其他异步操作的时候，他并不会立刻返回结果，为了防止浏览器出现假死或者空白，主线程会把这个异步任务挂起(pending)，继续执行执行栈中的其他任务，等异步任务返回结果后，js会将这个异步任务按照执行顺序，加入到与执行栈不同的另一个队列，也就是事件队列。 Event-loop Event-loop Definitions： To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each agent has an associated event loop, which is unique to that agent. 翻译：为了协调事件、用户交互、脚本、渲染、网络等等，用户代理必须使用本节中描述的事件循环。每个代理都有一个相关的事件循环，该事件循环对该代理来说是唯一的。 每个Event-loop包含： 正在运行任务，它可以是一个任务或者null。并且在最初的时候，其是一个null。其实为了处理可重入性。 一个微任务队列，这是一个微任务队列，起初是空的。 有一个标志微任务检查点的布尔值。 HTML Living Standard Agent Definitions： An agent comprises a set of ECMAScript execution contexts, an execution context stack, a running execution context, an Agent Record, and an executing thread. Except for the executing thread, the constituents of an agent belong exclusively to that agent. 翻译：代理包括一组ECMAScript执行上下文、一个执行上下文堆栈、一个正在运行的执行上下文、一个代理记录和一个正在执行的线程。除执行线程外，代理的组成部分专属于该代理。 HTML Living Standard 所谓事件循环，就是浏览器中（此处只谈浏览器，不涉及Node）各项任务（同步任务，异步任务）的执行次序之间的协调。其基本过程如下图： 其基本过程： 主线程运行的时候会生成堆（heap）和栈（stack）； js从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中； 当程序调用外部的API时，比如ajax、setTimeout等，会将此类异步任务挂起，继续执行执行栈中的任务，等异步任务返回结果后，再按照执行顺序排列到事件队列中； 主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到事件队列中。 主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个过程是循环往复的… …。 这个过程被称为“Event Loop 事件循环”。 宏任务、微任务首先需要明确的是：宏任务和微任务都是异步任务，其不同在于回调执行的时机。 在标准中，任务是分为task和microtask，任务和微任务。全文中提到宏任务（Macro task）的只有两处： Unlike other algorithms in this and other specifications, which behave similar to programming-language function calls, spin the event loop is more like a macro, which saves typing and indentation at the usage site by expanding into a series of steps and operations. 翻译：与本规范和其他规范中的其他算法(其行为类似于编程语言函数调用)不同，spin事件循环更像是一个宏，它通过展开成一系列步骤和操作来节省使用站点上的输入和缩进。 可能是由于这一处，我们多用macro task来描述task。 而在HTML Standard中，对于task的解释为： 形式上，一个task是一个包含如下内容的结构体： steps：完成该任务需要的一系列步骤。 A source：任务源之一，用于对相关任务进行分组和序列化。 A document：与任务相关联的文档，对于不在窗口事件循环中的任务，则为空。 A script evaluation environment settings object set：一组环境设置对象，用于在任务期间跟踪脚本评估。 对于microtask定义有： A microtask is a colloquial way of referring to a task that was created via the queue a microtask algorithm. 翻译：微任务是指通过微任务算法队列创建的任务。 从执行顺序上来看两者的不同： 可以明确的是微任务是在一个宏任务结束后进行，此时即为上文提到的checkpoint，查看是否存在可执行的微任务。 具体宏任务和微任务为： 宏任务 整体script setTimeout setInterval setImmediate 其他 微任务 Promise的then方法（注意Promise内部的内容是同步内容，立即执行） process.nextTick， MutationObserver 几个简单例子定时器、Promise123456789101112131415161718192021setTimeout(function()&#123; console.log('定时器开始') &#125;); new Promise(function(resolve)&#123; console.log('马上执行for循环'); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125; &#125;).then(function()&#123; console.log('执行then函数') &#125;); console.log('代码执行结束');/** 马上开始for循环* 代码执行结束* 执行then函数* 定时器开始*/ 解释： 执行到setTimeout，先由Event Table保留其回调函数。并且在其延迟任务完成后由事件触发线程将其加入到Event Queue。 执行到new Promise，由于其函数参数是同步的，所以立即执行。打印：马上执行for循环。并将then方法的回调加入到微任务队列。 执行到console.log(&#39;代码执行结束&#39;);，同步代码。直接打印：代码执行结束 第一个事件循环结束，到checkpoint，检查是否有微任务，发现then方法回调，直接打印：执行then函数。 第二轮事件循环开始，执行第一个宏任务，setTimeout的回调进入执行栈，即执行 console.log(&#39;定时器开始&#39;)，直接打印：定时器开始 定时器、Promise、async123456789101112131415161718192021222324252627282930313233343536async function async1 () &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2 () &#123; console.log('async2');&#125;console.log('script start');setTimeout(function () &#123; console.log('setTimeout');&#125;, 0);async1();new Promise(function (resolve) &#123; console.log('promise1'); resolve();&#125;).then(function () &#123; console.log('promise2');&#125;);console.log('script end');//输出顺序：// script start // async1 start // async2 // promise1 // script end // async1 end// promise2// setTimeout 对于async函数，本质是基于Promise，所以： 12345678910111213async function async1 () &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;//等价于function async1 () &#123; console.log('async1 start'); Promise.resolve(async2()).then(() =&gt; &#123; console.log('async1 end'); &#125;)&#125; 这样就容易理解前面的答案了，根据Promise参数函数为同步，then方法为微任务，可以很容易推的结果。 最后说实话，这一部分仍然没有很好的理解，主要是官方的文档解释的比较抽象并且没有定性的解释，加之我的英语不行，不能很好的理解整个流程，只能简单的确定执行次序。这一部分还需要在后面深入的理解。 参考 JS引擎的执行机制（event loop），宏任务和微任务 HTML Standard","categories":[{"name":"JavaScrit","slug":"JavaScrit","permalink":"http://yoursite.com/categories/JavaScrit/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"宏任务","slug":"宏任务","permalink":"http://yoursite.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"},{"name":"微任务","slug":"微任务","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"}]},{"title":"Promise的实现","slug":"Promise的实现","date":"2021-02-04T05:03:48.000Z","updated":"2021-02-09T10:43:36.364Z","comments":true,"path":"2021/02/04/Promise的实现/","link":"","permalink":"http://yoursite.com/2021/02/04/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"前面已经写过一篇文章来理解Promise及其使用方法，这里尝试来模拟Promise。 要求根据Promise/A+原理，有以下几个点需要遵守： Promise有一个Promise States，其有三种状态： pending：初始状态，可以转化为fulfilled，rejected。 fulfilled： 需要一个value作为结果。 不能转化为其他状态。 rejected： 需要一个reason作为一个原因。 不能转化为其他状态。 必须要一个then方法，接受两个参数 onFulfilled：当操作成功时发生的回调。 onRejected：当操作失败时发生的回调。 一旦promise完成，每一次调用then方法，得到的结果必须是相同的。 Promise返回的必须也是一个promise。 开发实现1，2功能首先我们实现第一个和第二个特点： 基本思路如下： 一个Promise首先要有一个status，表示当前的状态，其有三种状态： PENDING：表示当前Promise未完成，此时的回调函数会加入相应的队列 RESOLVED：表示当前Promise已经完成，且时resolve状态，直接调用成功的函数。 REJECTED：表示当前Promise已经完成，且时rejected状态，直接调用失败的函数。 然后我们要定义两个值： value：用于resolve时的返回值。 reason：用于rejected时的返回值。 上面说到当Promise状态为PENDING时，我们会把回调函数放到相应的队列，所以我们还会定义两个队列 resolvedCallQueue：存放成功的回调函数 rejectedCallQueue：存放失败的回调函数 然后我们定义Promise的resolve和rejected函数，在这两个函数中，我们会改变Promise的状态并且给value或者reason赋值，最后执行相应的函数队列。 最后我们会定义Promise的then方法。如同上面对于状态的定义，我们会根据当前Promise的状态来处理then方法传来的回调函数。 下面用ES6的class来实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Promise &#123; constructor(executer) &#123; //定义Promise状态枚举数据 this.status_enum = &#123; PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED', &#125;; //成功的返回值 this.value = undefined; //失败的返回值 this.reason = undefined; //成功的回调函数队列 this.resolvedCallQueue = []; //失败的回调函数队列 this.rejectedCallQueue = []; //当前Promise状态 this.status = this.status_enum.PENDING; //Promise完成 let resolve = (value) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.RESOLVED; this.value = value; for (let i = 0; i &lt; this.resolvedCallQueue.length; i++) &#123; this.resolvedCallQueue[i](this.value); &#125; &#125; &#125;; //Promise失败 let reject = (reason) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.REJECTED; this.reason = reason; for (let i = 0; i &lt; rejectedCallQueue.length; i++) &#123; this.rejectedCallQueue[i](this.reason); &#125; &#125; &#125;; //执行Promise函数 try &#123; executer(resolve, reject); &#125; catch (e) &#123; console.log('错误', e); reject(e); &#125; &#125; //定义then函数 then(onfulfilled, onrejected) &#123; //检测参数必须为函数 if(!onfulfilled instanceof Function || !onrejected instanceof Function)&#123; throw new Error('Uncaught TypeError: Promise resolver is not a function') &#125; //当Promise状态为RESOLVED时，进行成功回调函数 if (this.status === this.status_enum.RESOLVED) &#123; onfulfilled(this.value); &#125; //当Promise状态为REJECTED时，进行失败回调函数 if (this.status === this.status_enum.REJECTED) &#123; onrejected(this.reason); &#125; //当Promise状态为PENDING时，将其回调函数加入相应队列，在完成时会执行相应的函数队列 if (this.status === this.status_enum.PENDING) &#123; this.resolvedCallQueue.push(onfulfilled); this.rejectedCallQueue.push(onrejected); &#125; &#125;&#125; 下面用原型实现(基本原理一样，因为class本质也是原型链的语法糖)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Promise(executer) &#123; this.status_enum = &#123; PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED', &#125;; this.value = undefined; this.reason = undefined; this.resolvedCallQueue = []; this.rejectedCallQueue = []; this.status = this.status_enum.PENDING; let resolve = (value) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.RESOLVED; this.value = value; for (let i = 0; i &lt; this.resolvedCallQueue.length; i++) &#123; this.resolvedCallQueue[i](this.value); &#125; &#125; &#125;; let reject = (reason) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.REJECTED; this.reason = reason; for (let i = 0; i &lt; rejectedCallQueue.length; i++) &#123; this.rejectedCallQueue[i](this.reason); &#125; &#125; &#125;; try &#123; executer(resolve, reject); &#125; catch (e) &#123; console.log('错误', e); reject(e); &#125;&#125;Promise2.prototype.then = function then(onfulfilled, onrejected) &#123; if (this.status === this.status_enum.RESOLVED) &#123; onfulfilled(this.value); &#125; if (this.status === this.status_enum.REJECTED) &#123; onrejected(this.reason); &#125; if (this.status === this.status_enum.PENDING) &#123; this.resolvedCallQueue.push(onfulfilled); this.rejectedCallQueue.push(onrejected); &#125;&#125;; 这样，Promise的基本功能就已经实现，简单测试如下： 1234567891011121314let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('2秒！！！'); resolve(111); &#125;, 2000);&#125;);p.then((res) =&gt; &#123; console.log('p1'); console.log(res);&#125;);p.then((res) =&gt; &#123; console.log('p2'); console.log(res);&#125;); 结果： 1234567892秒！！！p1111p2111 实现1，2，3功能前面我们基本实现了Promise的基本功能，但是还是一个问题是：Promise必须返回一个Promise，上面的代码并不满足这一点。 所谓我们为了实现返回的都是Promise，我们需要重写then方法，使之返回的是一个Promise，这时，我们还是要根据当前Promise的状态来分开来处理。 但是其中心点是，必须持续执行Promise，直到其返回值不是一个thenable对象或方法，所以请是一个递归的过程。所以我们定义了一个函数cycleResolve，其接受四个参数： newPromise：新建的被用于返回的Promise target：回调函数执行的获得结果（可能仍然是一个Promise） resolve：新Promise的resolve函数 reject：新Promise的reject函数 该函数的功能是：判定返回值target是不是一个thenable对象（包括Promise），如果是，继续执行其then方法。给i贵这个过程，知道返回值不是thenable对象，然后将其值resolve出去。 注意： 只有target是一个thenable对象并且其then属性是一个函数时，才会调用其then方法，否则会直接将targetresolve出去。 一旦遇到错误，都会直接reject(e) then方法中必须使用setTimeout来使内部的操作成为宏任务，在下一个tick执行。这样才能拿到newPromise，否则会出现未初始化错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127class Promise &#123; constructor(executer) &#123; this.status_enum = &#123; PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED', &#125;; this.value = undefined; this.reason = undefined; this.resolvedCallQueue = []; this.rejectedCallQueue = []; this.status = this.status_enum.PENDING; //定义resolve方法，任务完成时调度 this.resolve = (value) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.RESOLVED; this.value = value; for (let i = 0; i &lt; this.resolvedCallQueue.length; i++) &#123; this.resolvedCallQueue[i](this.value); &#125; &#125; &#125;; //定义reject方法，任务失败时调度 this.reject = (reason) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.REJECTED; this.reason = reason; for (let i = 0; i &lt; this.rejectedCallQueue.length; i++) &#123; this.rejectedCallQueue[i](this.reason); &#125; &#125; &#125;; //执行定义Promise时传入的任务 try &#123; executer(this.resolve, this.reject); &#125; catch (e) &#123; console.log('错误', e); this.reject(e); &#125; &#125; //定义then方法 then(onfulfilled, onrejected) &#123; //新建一个Promise用于返回 let newPromise = new Promise((resolve, reject) =&gt; &#123; if (this.status === this.status_enum.RESOLVED) &#123; setTimeout(() =&gt; &#123; try &#123; let target = onfulfilled(this.value); cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;, 0); &#125; if (this.status === this.status_enum.REJECTED) &#123; //建立宏任务，方便拿到newPromise，否则会出现未初始化错误 setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;); &#125; if (this.status === this.status_enum.PENDING) &#123; this.resolvedCallQueue.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let target = onfulfilled(this.value); //将resolve函数保留的成功值传递作为参数 cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;, 0); &#125;); this.rejectedCallQueue.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); //将resolve函数保留的成功值传递作为参数 cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;); return newPromise; &#125; function cycleResolve(newPromise, target, resolve, reject) &#123; //禁止循环调用 if (newPromise === target) &#123; return reject(new TypeError('循环调用')); &#125; if ( target !== null &amp;&amp; (typeof target === 'object' || typeof target === 'function') /*确定其是一个对象*/ ) &#123; try &#123; let then = target.then; /*确定是否是一个thenable对象*/ if (typeof then === 'function') &#123; then.call( target, (newTarget) =&gt; &#123; resolvePromise(newPromise, newTarget, resolve, reject); &#125;, (e) =&gt; &#123; reject(e); &#125; ); &#125; else &#123; resolve(target); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; resolve(target); &#125; &#125; 至此，Promise的基本功能都已经完成，接下来我们完成剩下的一些细枝末节的东西，包括： 实现resolve方法 实现reject方法 实现catch方法。 实现finally方法。 实现Promise的其他方法： Promise.all([p1, p2, p3]) Promise.race([p1, p2, p3]) Promise.allSettled(p1, p2, p3) Promise.any(p1, p2, p3) 注意： 各个函数的功能不再赘述，具体查看Promise理解 下面的代码就只写对应部分，多余部分不再进行赘述。 实现catch方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960catch(onrejected) &#123; /*在class中定义catch方法*/ const newPromise = new Promise3((undefined, reject) =&gt; &#123; if (this.status === this.status_enum.REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); cycleReject(newPromise, target, reject); &#125; catch (e) &#123; console.log(e) reject(e); &#125; &#125;, 0); &#125; if (this.status === this.status_enum.PENDING) &#123; this.rejectedCallQueue.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); cycleReject(newPromise, target, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;);&#125;&#125;//循环rejectfunction cycleReject(newPromise, target, reject) &#123; //禁止循环调用 if (newPromise === target) &#123; return reject(new TypeError('循环调用')); &#125; if ( target !== null &amp;&amp; (typeof target === 'object' || typeof target === 'function') /*确定其是一个对象*/ ) &#123; try &#123; let then = target.then; /*确定是否是一个thenable对象*/ if (typeof then === 'function') &#123; then.call( target, (newTarget) =&gt; &#123; resolvePromise(newPromise, newTarget, reject); &#125;, (e) =&gt; &#123; reject(e); &#125; ); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125;else&#123; reject(target) &#125;&#125; 其实这里的操作与then方法逻辑基本一致，唯一不同的是，我们只需要捕捉reject，不捕捉resolve。 实现finallyPromise的finally的方法无论promise的结果是成功还是失败，都会执行，并且返回该promise。所以实现很简单。执行其promise的then方法来获取该promise的结果。 1234finally(callback) &#123; callback(); return this.then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;);&#125; 实现Promise.resolve方法(下面的方法是直接作为class的静态函数成员的)1234567891011121314151617static resolve(val) &#123; //如果是一个Promise if(val instanceof Promise3)&#123; return val //如果没有参数，或者为null,undefined &#125;else if(!val)&#123; return new Promise3((resolve, reject) =&gt; &#123;resolve()&#125;) //参数存在但不存在then方法 &#125;else if(val &amp;&amp; !val.then instanceof Function)&#123; return new Promise3((resolve) =&gt; &#123; resolve(val); &#125;); //参数存在且存在then方法 &#125;else if(val &amp;&amp; val.then instanceof Function)&#123; return new Promise3(val.then) &#125;&#125; 实现Promise.reject方法123456static reject(val)&#123; //直接将val作为理由返回 return new Promise((resolve,reject)=&gt;&#123; reject(val); &#125;)&#125; ## 实现Promise.all([p1, p2, p3])1234567891011121314151617static all(arr) &#123; let res = [] return new Promise((resolve, reject) =&gt; &#123; for(let i = 0, len = arr.length; i &lt; len; i++)&#123; arr[i].then((v) =&gt; &#123; res.push(v) //是否所有的promise都是resolve if(res.length === arr.length)&#123; return resolve(res) &#125; &#125;, (e) =&gt; &#123; //只要一个reject，直接reject return reject(e) &#125;) &#125; &#125;)&#125; 实现Promise.race([p1, p2, p3])1234567891011121314static race(arr) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i].then( (v) =&gt; &#123; return resolve(v) &#125;, (e) =&gt; &#123; return reject(e) &#125; ); &#125; &#125;);&#125; 实现Promise.allSettled([p1, p2, p3])12345678910111213141516171819202122232425static allSettled(arr) &#123; let res = []; let count = 0; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i].then( (v) =&gt; &#123; res.push(&#123; status: 'fulfilled', value: v, &#125;); &#125;, (e) =&gt; &#123; res.push(&#123; status: 'rejected', reason: e, &#125;); &#125; ).finally(() =&gt; &#123; //计数器必须在这里统计，因为异步操作，若放在then中，在finally中无法读取预期的值 ++count === arr.length &amp;&amp; resolve(res) &#125;); &#125; &#125;);&#125; 实现Promise.any(p1, p2, p3)123456789101112131415161718static any(arr) &#123; let res = []; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i].then( (v) =&gt; &#123; //只要有一个resolve，则直接resolve return resolve(v); &#125;, (e) =&gt; &#123; res.push(e); res.length === arr.length &amp;&amp; reject(res); &#125; ); &#125; &#125;);&#125;&#125; 最后本人能力有限，可能会出现错误，谅解。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"全面理解JavaScript作用域与闭包","slug":"全面理解JavaScript作用域与闭包","date":"2021-01-31T09:26:46.000Z","updated":"2021-03-25T15:12:42.800Z","comments":true,"path":"2021/01/31/全面理解JavaScript作用域与闭包/","link":"","permalink":"http://yoursite.com/2021/01/31/%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/","excerpt":"","text":"作用域pre：块语句块语句（或其他语言的复合语句）用于组合零个或多个语句。该块由一对大括号界定，可以是labelled： 块语句会生成一个块级作用域，生成块级作用域包含两种方法： 使用任意声明符号（’’, var,let,const）在函数中会生成一个块级作用域。 使用let,const在任何块语句中生成一个块级作用域。 注意：var在非函数的块语句中不会生成一个块级作用域。 介绍中都会使用var来进行举例，在变量声明中会对let和const进行说明。 介绍变量的简单说作用域就是在哪里可以访问到该变量。在JavaScript中，变量的作用域分为 全局作用域。 局部作用域。 这个全局与局部是相对的。因为在浏览器环境下，window对象被称为全局对象（在ES6中，顶层对象被规范为globalThis对象，在node中会指向global对象。）。而相对的，函数中的变量被称为局部变量。特点如下： 局部变量只能在该作用域和其子作用域中访问到。 全部变量可以在任作用域中访问到。 例子123456789101112var out = 'out-msg'//全局变量-作用域是全局作用域，可以在任何位置访问到function func()&#123; var in = 'in-msg' //局部变量-作用域是局部作用域， console.log(out) //out-msg console.log(in) //in-msg&#125; console.log(in) //VM229:1 Uncaught ReferenceError: out is not definedconsole.log(out) //out-msg 作用域链由于上面提到，全局与局部是相对的。由于window是浏览器环境中的最基础的变量，所以他被称为全局变量。而函数中（局部作用域）链中的还可以再定义函数，而内部函数仍然可以访问到外部函数中定义的变量。这样多个函数嵌套就会形成一个作用域链。 例子1234567891011121314151617var a = 'window'//可以访问到a，访问不到v3,v4,v2function fun1()&#123; var v1 = 'v1' //可以访问到a,v1，访问不到v3,v4,v2 function fun2()&#123; var v2 = 'v2' //可以访问到a,v1,v2，访问不到v3,v4 function fun3()&#123; var v3 = 'v3' //可以访问到a,v1,v2,v3，访问不到v4 function func4()&#123; //可以访问到a,v1,v2,v3,v4 &#125; &#125; &#125;&#125; 所以，这样由window-fun1-&gt;fun2-&gt;fun3-&gt;func4形成了一个作用域链。 tip： 当要使用一个变量时，系统会按照作用域链的顺序向上依次查询。所以，变量名相同时，局部变量会优先被访问。 使用var定义变量时，局部作用域只会在函数内部产生，当使用let,const时，只要是花括号内部，都会产生一个作用域。 变量申明目前JavaScript中4中声明变量的方式：无声明标志，var,let,const 无声明标志所谓不用声明标志，就是直接使用变量名进行声明，如 1234a = 1function fun()&#123; b = 2&#125; 这样申明的变量有一些特点： 无论在哪里申明（即使是在函数块中），其都是一个全局变量，即会被挂载在全局对象window上，即无声明标志无论如何都不会构成局部作用域。 varvar是ES6出现之前JavaScript中的声明标志之一（另外一个时function用来声明一个函数变量）。所以他也具有一些特征。 变量提升变量的声明与赋值在理解变量提升之前，我们要明白变量声明与变量赋值之间的关系。 变量声明是指确定这个作用域中该变量的存在。 1var v 变量赋值就是为已经声明的变量进行赋值。 1v = 'variable' 这两个操作可以一起进行。 1var v = 'variable' 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。 例子12345678bla = 2var bla;// ...// 可以隐式地（implicitly）将以上代码理解为：var bla;bla = 2; 重要的是，提升将影响变量声明，而不会影响其值的初始化。当到达赋值语句时，该值将确实被分配： 12345678910111213function do_something() &#123; console.log(bar); // undefined var bar = 111; console.log(bar); // 111&#125;// is implicitly understood as:function do_something() &#123; var bar; console.log(bar); // undefined bar = 111; console.log(bar); // 111&#125; 值得注意的是： 变量提升是在对应作用域下进行的，内层的作用域变量不会提升到外部中，所以会产生下面的问题： 123456var ov = 'out'function func()&#123; console.log(ov) var ov = 'in'&#125;func() 问结果是什么。 答：由于变量提升的按照作用域进行的，所以虽然这里外部声明了一个ov，但是在函数func内部也声明了一个ov变量，且在这个函数赋值之前就使用了，所以这里实际上等价于： 1234567var ov = 'out'function func()&#123; var ov console.log(ov) ov = 'in'&#125;func() 而单独的变量声明不赋值，在JavaScript中其默认值为undefined，所以这里打印出来的是undefined 值得注意的是： 只要是在变量还没有赋值之前进行操作，其值都是undefined。如： 12var x = y, y = 'A'console.log(x + y) //undefinedA 由于x = y时进行时，A还没有被赋值。但是由于变量提升，y是存在的，且其值为undefined，根据JavaScript的primitive算法，得x + y结果为undefinedA。 letlet声明符号是ES6引入的新的声明符号，为了解决var的一些问题。其有一下特点： 其在块语句中声明就会生成一个块级作用域（只要花括号存在）。 同一个变量名，只能被声明一次。 不会存在变量提升，取而代之的是暂时性死区。 下面依次解释： 其在块语句中声明就会生成一个块级作用域（只要花括号存在）。以前JavaScript中只有全局作用域和函数作用域。而ES6引入的let与const相当于为JavaScript引入了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。 同一个变量名，只能被声明一次。使用var时，同一个变量名，可以被多次声明。如： 123var a = 123var a = 'abc'//不会报错 但是使用let时，不允许重复声明同一个变量。 123let a = 123let a = 'abc'//VM971:2 Uncaught SyntaxError: Identifier 'a' has already been declared 不会存在变量提升，取而代之的是暂时性死区。上面提到，使用var声明变量时，会存在变量提升的现象。即相当于所有的变量，无论何处声明，其都被在最顶部声明，且默认赋值为undefined，然后在运行到声明处，在会被赋值为对应的值。所以在声明之前使用该变量，其结果都是undefined。 而使用let声明时，在声明之前，是无法使用的。从程序开始之前，到声明之间，被称为暂时性死区。如： 123console.log(a) Uncaught ReferenceError: b is not definedlet a = 123 立即执行函数（IIFE）定义一个函数后将其立即执行的形式，形如： 123456(function()&#123; var a = '100' console.log(a)&#125;)()//函数会立即执行，并输出100 其具有以下特点： 函数会立即执行 每执行一次，就会创建一个块级作用域，可以解决典型的异步问题： 12345for(var i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;, 500)&#125; 众所周知，这里的结果是：555~，其原因就是： setTimeout是一个异步函数，当其回调函数执行的时候，for循环，已经完成了。所以后面打印出来的都是4。 用var时，不存在块级作用域，所以一个for循环中，使用的都是同一个i，导致前面的i会被后面的i所覆盖。 所以前面提到IIFE每执行一次都会创建一个快进作用域，所以可以这么解决。 12345for(var i = 0; i &lt; 5; i++)&#123; (function(i)&#123; console.log(i) &#125;)(i)&#125; 这样其结果就是：1234 但是当ES6的let出现之后，我们不再需要立即执行函数了来创建块级作用域了。直接使用let进行变量声明即可： 12345for(let i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;, 500)&#125; 其结果也是：1234 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; constconst也是ES6引入的声明符号。其基本与let一致： 每使用一次都会创建一个块级作用域。 同一个变量名，只能被声明一次。 并且，其还有一下特征： const声明一个只读的常量。一旦声明，常量的值就不能改变。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 值得注意的是：变量不可以被更改，但是其属性是可以被更改的。如： 123456789101112131415161718const obj = &#123; a: 1, b: 2&#125;obj = &#123;&#125;// SyntaxError: Missing initializer in const declarationobj.a = 3 //成功console.log(obj)\"&#123; a: 3, b: 2&#125;\" 垃圾回收机制基于最开始JavaScript设计的初衷，JavaScript的内存管理都是自动执行的，而且是不可见的。程序员基本上不需要自动管理内存。 V8内存模型要想更好的理解JavaScript的内存回收机制，要先简单理解一下JavaScript的内存模型（这里以V8为例） 首先JavaScript的变量分为两大类： 基本变量 Number Boolean String Symbol BigInt null undefined 引用变量：Object，Array，Date，RegExp 然后看一下V8的内存模型： 栈区栈区用于存储变量的名称以及内存中的地址。该地址又指向堆区、常量区或函数定义区。 例如： 在我们定义一个变量时： 12var a = 'string'var b = &#123;&#125; a为基本类型，所以他的值存储在池（常量区），所以： 在栈区建立一个单元：|变量名|内存地址|（如|a|0x1245a|） 在池（常量区）的0x1245a存储’string’ b为引用类型，其值存储在堆区，所以： 在栈区建立一个单元：|变量名|内存地址|（如|b|0x1245b|） 在堆的0x1245b的位置存储{} 值得注意的是： 变量未被初始化或者被赋值为undefined时，栈区的地址部分被置空。表示没有任何意义。 堆区用于存放引用类型的值，如上面的b，其具体的值就存储在堆区。 值得注意的是： 在堆区，预存着一个特殊对象null，其地址固定，所有的值为null的变量都指向这一块内存。 所以，需要手动释放一个变量时，只需要将该变量赋值为null，则此时其指向null，原来的内存在无引用时会被GC（garbage recycle）机制回收。 常量区与堆区相对，其存储常量的值。如上面的a变量。 常量区具有以下特征： 所有的值一旦写入无法改变。 所有相同的常量值在常量区都是惟一的。 注意：常量区的值与常量是不同的。常量区的值不可改变是指对应地址的内存内容是无法改变的。而当我们在改变常量时，实际上大概是这么个流程： 先检索常量区是否存在新的变量值。 如果存在，则直接将栈区的地址改为该常量的地址；若不存在，则在常量区新开辟一个地区，将新的变量存储到该地址，再将该常量的地址改为新的内存地址。 函数定义区函数定义区用于存放被定义的函数代码段。 值得注意的是：函数的声明有两种： 函数声明，形如 123function func()&#123; //...&#125; 这种定义的方式不会再栈区生成相应的函数名，因为此时其不是一个变量。引擎会直接在函数定义区定义这个函数，我们在调用这个函数的时候，引擎会去函数定义区搜索这个函数名进行调用。 函数引用，形如： 123var func = function()&#123; //...&#125; 这种方式会在栈区生成一个变量来保存这个函数的地址。函数代码段仍然保存在函数定义区。 两种定义方式在调用的时候会表现出一些不同。 对于第一种方式，V8引擎会在预扫描阶段进行函数提升，也就是说，你可以在函数定义之前调用该函数； 对于第二种方式，尽管引擎也会进行变量提升（因为其本身就是一个变量），但是并不会在提升的时候对变量赋值，因此不可以在定义之前调用该函数。 1234567//可以正常调用，因为引擎会提前扫描代码，将该函数存储到函数定义区f();function f()&#123;&#125;//报错，因为虽然g也进行了变量提升，但此时g的值是undefined，不能调用g();var g = function()&#123;&#125; 另外，如果函数名发生了重名，浏览器会以通过栈区变量引用的函数优先。如： 12345var f = function()&#123;&#125;function f()&#123;&#125;//会调用第一个函数f(); 之所以出现这种情况，是因为JavaScript引擎总是优先搜索栈区，所以上面的函数会优先被调用。但是如果调用发生在函数定义之前，那么就会调用通过函数声明定义的函数，代码如下： 12345//会调用下面的以函数声明定义的函数f();var f = function()&#123;&#125;//这个函数被调用function f()&#123;&#125; 究其原因，还是在调用函数时变量f的值为undefined，因此引擎才会去函数定义区搜索函数f。总的来说，引擎在调用函数时会以栈区的变量优先，如果搜索不到或为undefined，则会去函数定义区搜索。 但是两者实际上并不冲突，我们同样可以用一个变量来指向一个声明式函数，如： 12function f()&#123;&#125;var g = f; 现在变量g也拿到了函数f的内存地址，使用g同样可以访问该函数。 函数缓冲区函数缓冲区用于存放函数运行时动态申请的空间。函数运行时引擎会为其分配一片空间。当函数运行结束后，会回收其空间。只有当闭包产生的时候才会保留函数缓冲区中的数据。 垃圾回收机制JavaScript 中内存管理的主要概念是可达性（Reachability）。简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。 从上面的内存分配可以看出，每一个变量都会在栈区存储其名字和地址，地址又指向堆区或池。所以JavaScript的GC机制就是当不存在一个变量指向一个内存地址，则引擎认定该内存可以被回收。 这其中有一部分变量是一定可达的，被称为根（root），如： 全局对象 正被调用的函数的局部变量和参数 相关嵌套函数里的变量和参数 其他（引擎内部调用的一些变量） 这些根上面挂载的变量则也一定可达。 具体比如： 12345678let num = 123let cont = 11let str = 'str'let cs = 'cs'let obj = &#123; cont, cs&#125; 此时内存分配结构为： 即池和堆中的每个被分配的内存块都可以通过栈区的变量访问到。所以他们都是可达的，故不会被GC回收。 但是当我们将某一个变量赋为null时候，原来堆池中的值就变成不可达，GC就会进行回收。如： 12345678910111213let num = 123let cont = 11let str = 'str'let cs = 'cs'let obj = &#123; cont, cs&#125;num = nullcont = nullstr = nullcs = null 这个时候把所有的基础变量都置为null，则本来按照回收机制，其所有的基础变量都会被GC回收，但是由于obj中引用了cont,cs，所以虽然这两个变量被置为null了，但是内存中实际的值并没有被回收。此时其内存状况如下 可以看到由于可以从obj访问到cs,11，所以他们不会被回收。 回收算法（精简版）基本的垃圾回收算法称为“标记-清除”，定期执行以下“垃圾回收”步骤: 垃圾回收器获取根并“标记”(记住)它们。 然后它访问并“标记”所有来自它们的引用。 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。 以此类推，直到有未访问的引用(可以从根访问)为止。 除标记的对象外，所有对象都被删除。 下面是一个简单的过程（via前端面试：谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776)）： 可以看出，这实际上是一个广度遍历的过程，对整个栈区的变量构成的图进行广度遍历，并对遍历到的内存坐下标记。当遍历完成时，内存中未被遍历到的内存则证明时不可达的，则GC则可以将其回收。 剩下的内存是不可达的，则会被回收。 上面就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。 一些优化: 分代回收——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。 增量回收——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。 空闲时间收集——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。 闭包上面谈了这么多，都是为了更好的理解闭包。既然理解了内存模型和垃圾回收机制，再理解闭包就是如鱼得水了。 首先我们知道函数内的变量的生命周期只是该函数的运行过程。函数运行一旦结束，函数内的变量就会从函数缓冲区中删除掉。但是有的时候我们需要将函数中的变量永久（或长时间）保存下来，这个时候只需要在函数内部再新建一个函数，并且再内层函数中使用外层函数的变量。再将内层函数作为结果返回出来。由于此时外层函数中的变量由于被内层函数中使用，所以他们是可达的，则GC不会将其回收。如： 12345678910111213function out()&#123; let i = 0; function inner()&#123; i++ console.log(i) &#125; return inner&#125;let in = out()in() //1in() //2in() //3 这里就是一个典型的闭包。我们将使用外层函数的内部函数作为结果返回。我们调用该返回函数就可以操作到外层函数的变量。 闭包的应用用闭包模拟私有方法编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。 而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）： 123456789101112131415161718192021222324var Counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;&#125;)();console.log(Counter.value()); /* logs 0 */Counter.increment();Counter.increment();console.log(Counter.value()); /* logs 2 */Counter.decrement();console.log(Counter.value()); /* logs 1 */ 在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：Counter.increment，`Counter.decrement和Counter.value`。 该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。 这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。 你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量Counter。我们可以把这个函数储存在另外一个变量makeCounter中，并用他来创建多个计数器。 使用闭包形成一个块级作用域，完成异步回调函数（这里使用let解决更好）就像上面的IIFE中，我们使用了闭包来形成一个块级作用域，来完成异步回调函数，不至于造成异步函数执行时循环以完毕。 123456for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; (function(item)&#123; document.getElementById(item.id) = `内容-$&#123;i&#125;` &#125;)(item) &#125; 这里就是利用闭包形成了一个块级作用域。使每一次循环都有一个作用域，使在异步回调执行的时候，其值是正确的。 参考 前端面试：谈谈 JS 垃圾回收机制 Javascript垃圾回收机制 ECMAScript 6 入门 block","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"作用域","slug":"作用域","permalink":"http://yoursite.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"垃圾回收机制","slug":"垃圾回收机制","permalink":"http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"bind,call,apply的用法及实现","slug":"bind-call-apply的用法及实现","date":"2021-01-27T09:57:04.000Z","updated":"2021-01-29T01:35:08.920Z","comments":true,"path":"2021/01/27/bind-call-apply的用法及实现/","link":"","permalink":"http://yoursite.com/2021/01/27/bind-call-apply%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"bindbind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 参数thisArg 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。 当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。 如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg。 arg1, arg2, ... 当目标函数被调用时，被预置入绑定函数的参数列表中的参数。 返回值返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。 描述bind() 函数会创建一个新的绑定函数（bound function，BF）。绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语），它包装了原函数对象。调用绑定函数通常会导致执行包装函数。绑定函数具有以下内部属性： [[BoundTargetFunction]] - 包装的函数对象（即新生成的函数）。 [[BoundThis]] - 在调用包装函数时始终作为 this 值传递的值。 [[BoundArguments]] - 列表，在对包装函数做任何调用都会优先用列表元素填充参数列表。 [[Call]] - 执行与此对象关联的代码。通过函数调用表达式调用。内部方法的参数是一个this值和一个包含通过调用表达式传递给函数的参数的列表。 当调用绑定函数[[BoundTargetFunction]]时，它调用 [[BoundTargetFunction]] 上的内部方法 [[Call]]，就像这样 Call(*boundThis*, *args*)。其中，boundThis 是 [[BoundThis]]，args 是 [[BoundArguments]] 加上通过函数调用传入的参数列表。 绑定函数也可以使用 new 运算符构造，它会表现为目标函数已经被构建完毕了似的。提供的 this 值会被忽略，但前置参数仍会提供给模拟函数。 用法改变this指向（创建绑定this指向的函数）1234567891011121314let a = 'outterA'let obj = &#123; a: 'innerA'&#125;function printA()&#123; console.log(this.a)&#125;printA() //'outterA'let innerPrintA = printA.bind(obj)innerPrintA() //innerA 偏函数通俗的讲，偏函数就是指通过一个初始函数A，创建出另外的函数A1,A2，这两个函数含有了初始参数1，2。这里使用bind是利用了他的两个特点。 bind返回的是绑定函数，区别与Function.prototype.call()，Function.prototype.apply()的立即执行 其接受的是参数列表，并且会与绑定函数调用时的参数合并作用[[call]]原函数，区别于Function.prototype.apply() 123456789function add(arg1, arg2)&#123; return arg1 + arg2&#125;let addThirtynine = add.bind(null, 39)let addEleven = add.bind(null, 11)addThirtynine(3) //42addEleven(3) //14 改变setTimeout，setInterval的this指向由于setTimeout，setInterval的函调函数中this的指向总是window（即使在严格模式下）。所以可以使用bind改变回调函数中的this指向。 123456789101112131415let obj = &#123; message: '内部消息'&#125;message = '外部消息' //这种方法是吧message变量挂载在window上setTimeout(function()&#123; console.log(this.message)&#125;, 1000)//一秒后打印出：'外部消息'setTimeout(function()&#123; console.log(this.message)&#125;.bind(obj), 1000) //将this的指向改变为obj//一秒后打印出：'内部消息' 作为构造函数使用的绑定函数与偏函数用法类似，相当于为构造器提供默认参数。 1234567891011121314151617181920function Point(x, y)&#123; this.x = x this.y = y&#125;Point.prototype.toString = function()&#123; return `$&#123;this.x&#125;,$&#123;this.y&#125;`&#125;let p = new Point(1, 2)p.toString() //'1,2'let emptyObj = &#123;&#125;let YAxisPoint = Point.bind(null, 0/*x*/)let axisPoint5 = new YAxisPoint(5)axisPoint5.toString() //'0,5'axisPoint instanceof Point; // trueaxisPoint instanceof YAxisPoint; // truenew YAxisPoint(17, 42) instanceof Point; // true 快捷调用一些特定的函数被绑定在特定数据类型种，最典型的例子就是Array.prototype.slice，其只能由数组调用。实际上这个函数也接受类数组的对象(array-like object)，这个时候实际上是要改变this的调用。 一般的用法： 1234567let slice = Array.prototype.slicefunction convert()&#123; return slice.apply(arguments) //arguments是一个类数组对象&#125;convert(1,2,3,4) //[1, 2, 3, 4] 在使用bind后，由于其可以生成绑定函数，所以将要使用的函数作为this就可以不用每次都使用apply。 12345678let unboundSlice = Array.prototype.slice;let slice = Function.prototype.apply.bind(unboundSlice); //这个slice就是上面的slice.apply()的一个绑定函数function convert()&#123; return slice(arguments) //arguments是一个类数组对象&#125;convert(1,2,3,4) //[1, 2, 3, 4] 兼容性 Pollyfill法一： 123456789101112131415161718// Does not work with `new (funcA.bind(thisArg, args))`if (!Function.prototype.bind) (function()&#123; let slice = Array.prototype.slice; Function.prototype.bind = function() &#123; let thatFunc = this, thatArg = arguments[0]; let args = slice.call(arguments, 1); if (typeof thatFunc !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - ' + 'what is trying to be bound is not callable'); &#125; return function()&#123; let funcArgs = args.concat(slice.call(arguments)) //合并参数 return thatFunc.apply(thatArg, funcArgs); //绑定this指向 &#125;; &#125;;&#125;)(); 这里利用了Function.prototype.apply构造一个函数，运行及执行apply方法，达到bind的特点。 法二： 12345678910111213141516171819202122232425262728293031// Yes, it does work with `new (funcA.bind(thisArg, args))`if (!Function.prototype.bind) (function()&#123; let ArrayPrototypeSlice = Array.prototype.slice; Function.prototype.bind = function(otherThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; let baseArgs= ArrayPrototypeSlice.call(arguments, 1), baseArgsLength = baseArgs.length, fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; baseArgs.length = baseArgsLength; // reset to default base arguments baseArgs.push.apply(baseArgs, arguments); return fToBind.apply( fNOP.prototype.isPrototypeOf(this) ? this : otherThis, baseArgs ); &#125;; if (this.prototype) &#123; // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; &#125; fBound.prototype = new fNOP(); return fBound; &#125;;&#125;)(); callcall() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 注意：该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 参数thisArg 可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 arg1, arg2, ... 指定的参数列表。（与bind一样） 描述call方法相较于bind，他会生成一个绑定函数并立即调用。 用法基本方法：改变this指向123456789101112let obj = &#123; message: 'inner-message'&#125;message = 'outter-message'function log()&#123; console.log(this.message)&#125;log() //'outter-message'log.call(obj) //'inner-message' 使用 call 方法调用父构造函数使用call方法绑定this对象为自己子类中，则可以完成对父构造器的调用。达到简单的继承效果。 1234567891011121314151617function Product(name, price)&#123; this.name = name this.price = price&#125;function Food(name, price)&#123; Product.call(this, name, price) //调用父构造器，并将this绑定为Food的示例 this.category = 'food'&#125;function Toy(name, price)&#123; Product.call(this, name, price) //调用父构造器，并将this绑定为Toy的示例 this.category = 'toy'&#125; let cheese = new Food('feta', 5)let fun = new Toy('robot', 40) 为匿名函数指定this对象1234567let obj = &#123; message: 'obj-message'&#125;(function()&#123; console.log(this.message)&#125;).call(obj)//'obj-message' 兼容性 Pollyfill1234567891011121314151617181920if (!Function.prototype.call) &#123; Function.prototype.call = function () &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError( 'Function.prototype.call - what is trying to be bound is not callable' ); &#125; let func = this let that = arguments[0] let args = [] for (let i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]) &#125; that.func = func that.func(...args) delete that.func &#125;;&#125; applyapply() 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。 参数 thisArg 必选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 argsArray 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 返回值调用有指定this值和参数的函数的结果。 描述 apply 与 call() 非常相似，不同之处在于提供参数的方式。apply 使用参数数组而不是一组参数列表。apply 可以使用数组字面量（array literal），如 fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])，或数组对象， 如 fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))。 你也可以使用 arguments对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。 从 ECMAScript 第5版开始，可以使用任何种类的类数组对象，就是说只要有一个 length 属性和(0..length-1)范围的整数属性。例如现在可以使用 NodeList 或一个自己定义的类似 {&#39;length&#39;: 2, &#39;0&#39;: &#39;eat&#39;, &#39;1&#39;: &#39;bananas&#39;} 形式的对象。 需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。 用法基本方法：改变this指向123456789101112let obj = &#123; message: 'inner-message'&#125;message = 'outter-message'function log()&#123; console.log(this.message)&#125;log() //'outter-message'log.apply(obj) //'inner-message' 函数数组参数变为列表参数+使用内置函数1234let arr = [2,3,4,5,7]let max = Math.max.apply(null, arr)//7 在ES6中扩展运算符（spread）···来实现函数数组参数变为列表参数： 1234let arr = [2,3,4,5,7]let max = Math.max(...arr)//7 兼容性 Pollyfill1234567891011121314151617181920if (!Function.prototype.apply) &#123; Function.prototype.apply = function () &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError( 'Function.prototype.apply - what is trying to be bound is not callable' ); &#125; let func = this let that = arguments[0] let args = [] for (let i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]) &#125; that.func = func that.func(args) delete that.func &#125;; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"bind","slug":"bind","permalink":"http://yoursite.com/tags/bind/"},{"name":"call","slug":"call","permalink":"http://yoursite.com/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://yoursite.com/tags/apply/"}]},{"title":"JavaScript中数组与对象的遍历方法","slug":"JavaScript中数组与对象的遍历方法","date":"2021-01-26T05:48:19.000Z","updated":"2021-10-12T14:41:01.068Z","comments":true,"path":"2021/01/26/JavaScript中数组与对象的遍历方法/","link":"","permalink":"http://yoursite.com/2021/01/26/JavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"数组for循环最传统的方法，按下标存取，也是最高效的方法 123456789101112let arr = [1,2,3,4]for(let i = 0; i &lt; arr.length; i++)&#123; console.log(arr[i])&#125;//1，2，3，4//不用每次计算len，更加高效for(let i = 0, let len = arr.length; i &lt; len; i++)&#123; console.log(arr[i])&#125;//1，2，3，4 for…of循环for...of语句创建一个迭代器(ES6引入，迭代器只会便利可枚举属性)。每一次循环都会调用迭代器的next对象。并返回当前该迭代器的值。 123456let arr = [1,2,3,4]for(let val of arr)&#123; console.log(val)&#125;//1,2,3,4 另外只要实现了迭代器的数据才能使用for...of循环。具体有：Array，Maps，Set，String，Arguments Object参数对象，Generators(生成器) for…in循环for...in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。 123456let arr = [1,2,3,4]for(let i in arr)&#123; console.log(i)&#125;//0，1，2，3 注意： for ...in循环遍历得到的结果为数据的键（数组即为下标）。 数组最好不要用for...in，因为for...in循环是为遍历对象而且设计的。 该方法也可用于String遍历下标。 for...in会顺着原型链向上遍历，原型链上所有的可遍历对象都会被遍历。比如（定义Array.prototype.max = () =&gt; {...}来获取数组中最大值，如果这么定义，那么这个属性也会被for...in纳入遍历） Array.prototype.entries()该方法一个新的 Array 迭代器对象。Array Iterator是对象，它的原型（proto:Array Iterator）上有一个next方法，可用用于遍历迭代器取得原数组的[key,value]。 12345678910var arr = [\"a\", \"b\", \"c\"];var iterator = arr.entries();console.log(iterator);/*Array Iterator &#123;&#125; __proto__:Array Iterator next:ƒ next() Symbol(Symbol.toStringTag):\"Array Iterator\" __proto__:Object*/ 用法一（直接使用Iterator的next对象）： 123456789const array1 = ['a', 'b', 'c'];const iterator1 = array1.entries();console.log(iterator1.next().value);// expected output: Array [0, \"a\"]console.log(iterator1.next().value);// expected output: Array [1, \"b\"] 用法二（二维数组按行排序）： 1234567891011121314151617181920212223242526function sortArr(arr) &#123; var goNext = true; var entries = arr.entries(); while (goNext) &#123; var result = entries.next(); if (result.done !== true) &#123; result.value[1].sort((a, b) =&gt; a - b); goNext = true; &#125; else &#123; goNext = false; &#125; &#125; return arr;&#125;var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];sortArr(arr);/*(4) [Array(2), Array(5), Array(5), Array(4)] 0:(2) [1, 34] 1:(5) [2, 3, 44, 234, 456] 2:(5) [1, 4, 5, 6, 4567] 3:(4) [1, 23, 34, 78] length:4 __proto__:Array(0)*/ 法三（使用for…of 循环）最典型： 1234567891011121314151617var arr = [\"a\", \"b\", \"c\"];var iterator = arr.entries();for (let v of iterator) &#123; console.log(v);&#125;// [0, \"a\"]// [1, \"b\"]// [2, \"c\"]for (let [index, value] of iterator) &#123; console.log(index+'---'+value);&#125;// 0-\"a\"// 1-\"b\"// 2-\"c\" Array.prototype.keys() keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。 与上面的Array.prototype.entries()相同，只是遍历的是索引键。用法与上面完全一致，本质也是迭代器。 典型用法(结合for...of)： 1234567let arr = [1,2,3,4]for(let i of arr.keys())&#123; console.log(i)&#125;//0，1，2，3 Array.prototype.values()values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值 与上面的Array.prototype.entries()相同，只是遍历的是索引键。用法与上面完全一致，本质也是迭代器。 典型用法(结合for...of)： 1234567const arr = ['a', 'b', 'c'];for (const value of arr.values()) &#123; console.log(value);&#125;//a，b，c Array.prototype.every()every()方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 其接收一个回调函数callback，callback 在被调用时可传入三个参数：元素值，元素的索引，原数组。 every 不会改变原数组。 every 和数学中的”所有”类似，当所有的元素都符合条件才会返回true。正因如此，若传入一个空数组，无论如何都会返回 true。（这种情况属于无条件正确：正因为一个空集合没有元素，所以它其中的所有元素都符合给定的条件。) 注意：若收到一个空数组，此方法在一切情况下都会返回 true。 典型用法： 123456789101112let arr = [5,6,4,7,8]arr.every((value, index, arr) =&gt; &#123; return value &gt; 3&#125;)//true（因为所有的value都大于3）arr.every((value, index, arr) =&gt; &#123; return value &gt; 5&#125;)//false（其中4,5不满足条件） every方法不会改变数组。 Pollyfill（最基础，下同）1234567891011121314151617181920212223if (!Array.prototype.every) &#123; Object.defineProperty(Array.prototype, 'every', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.every ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = true; for (let [i, v] of this.entries()) &#123; if (!callback(v)) &#123; res = false; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.some()这个方法与上面的方法使用方法完全相同，但是所用相反，some()方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 其接收一个回调函数callback，callback 在被调用时可传入三个参数：元素值，元素的索引，原数组。 注意：如果用一个空数组进行测试，在任何情况下它返回的都是false。 典型用法： 12345678910111213let arr = [6,9,3,4]arr.some((value, index, arr) =&gt; &#123; return value &gt; 8&#125;)//true（因为存在一个9大于8）arr.some((value, index, arr) =&gt; &#123; return value &gt; 12&#125;)//false（因为所有的value都小于12） some方法不会改变数组。 Pollyfill1234567891011121314151617181920212223if(!Array.prototype.some)&#123; Object.defineProperty(Array.prototype, 'some', &#123; enumerable: false, value: function (callbakc) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.some ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = false; for (let [i, v] of this.entries()) &#123; if (callbakc(v, i, this)) &#123; res = true; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.filter()filter() 方法创建一个新数组, 其包含通过所提供函数实现的过滤的所有元素的结果。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：一个数组，包含所有的元素的检测结果。 1234567let arr = [1, 2, 3, 4]arr.filter((value, index, arr) =&gt; &#123; return value &gt; 2&#125;)//[3, 4] 该方法可用于剔除不合法数据，比如 1234567let arr = [1,2,3, undefined, null, 4, 5]arr.filter((value, index, arr) =&gt; &#123; return value != undefined &amp;&amp; value != null&#125;)//[1, 2, 3, 4, 5] flter方法不会改变数组。 Pollyfill12345678910111213141516171819202122if (!Array.prototype.filter) &#123; Object.defineProperty(Array.prototype, 'filter', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.filter ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = []; for (let i = 0; i &lt; this.length; i++) &#123; if (callback(this[i])) &#123; res.push(this[i]); &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.find() find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：数组中满足提供的测试函数的第一个元素的值。 1234567let arr = [1,2,3,4]arr.find((value, index, arr) =&gt; &#123; return value &gt; 2&#125;)//2（由于3，4均大于2，但是3是第一个，所以返回3的下标2） find方法不会改变数组。 Pollyfill1234567891011121314151617181920212223if (!Array.prototype.find) &#123; Object.defineProperty(Array.prototype, 'find', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.find ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = undefined; for (let i = 0; i &lt; this.length; i++) &#123; if (callback(this[i], i, this)) &#123; res = this[i]; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.findIndex()findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：数组中满足提供的测试函数的最后一个元素的值。 1234567let arr = [1,2,3,4]arr.find((value, index, arr) =&gt; &#123; return value &gt; 2&#125;)//3（由于3，4均大于2，但是4是最后一个，所以返回4的下标3） Pollyfill123456789101112131415161718192021222324if (!Array.prototype.findIndex) &#123; Object.defineProperty(Array.prototype, 'findIndex', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.findIndex ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = -1; for (let i = 0; i &lt; this.length; i++) &#123; if (callback(this[i], i, this)) &#123; res = i; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.forEach()forEach()方法对数组的每个元素执行一次给定的函数。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：undefined。 forEach() 为每个数组元素执行一次 callback 函数；与 map() 或者 reduce() 不同的是，它总是返回 undefined 值，并且不可链式调用。其典型用例是在一个调用链的最后执行副作用（side effects，函数式编程上，指函数进行 返回结果值 以外的操作）。 forEach 不会直接改变调用它的对象，但是那个对象可能会被 callback 函数改变。 示例： 12345678let arr = [1, 2, 3, 4]let res = []arr.forEach((value, index, arr) =&gt; &#123; res.push(value*2) &#125;)console.log(res) //[2,4,6,8] Pollyfill123456789101112131415161718if (!Array.prototype.forEach) &#123; Object.defineProperty(Array.prototype, 'forEach', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.forEach ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; for (let i = 0; i &lt; this.length; i++) &#123; callback(this[i], i, this); &#125; &#125;, &#125;);&#125; Array.prototype.map()map()方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。（forEach类似，区别是forEach不用返回，一起操作都在回调函数中进行） 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：一个由原数组每个元素执行回调函数的结果组成的新数组。 上面的示例重写： 12345let arr = [1, 2, 3, 4]let res = arr.map((value, index, arr) =&gt; &#123; return value * 2&#125;)console.log(res) //[2, 4, 6, 8] callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。 因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。 map不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组） 根据规范中定义的算法，如果被map调用的数组是离散的（如：arr = [emptyx2, 3]），新数组将也是离散的保持相同的索引为空。 Pollyfill1234567891011121314151617181920if (!Array.prototype.map) &#123; Object.defineProperty(Array.prototype, 'map', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.map ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = []; for (let i = 0; i &lt; this.length; i++) &#123; res.push(callback(this[i], i, this)); &#125; return res; &#125;, &#125;);&#125; Array.prototype.reduce()reduce()方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 接受：函数累计处理的结果reducer 函数接收4个参数: Accumulator (acc) (累计器) Current Value (cur) (当前值) Current Index (idx) (当前索引) Source Array (src) (源数组) callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。 返回值：函数累计处理的结果 示例： 数组里所有值的和 1234var sum = [0, 1, 2, 3].reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue;&#125;, 0);// 和为 6 累加对象数组里的值 要累加对象数组中包含的值，必须提供初始值，以便各个item正确通过你的函数。 123456var initialValue &#x3D; 0;var sum &#x3D; [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue.x;&#125;,initialValue)console.log(sum) &#x2F;&#x2F; logs 6 你也可以写成箭头函数的形式： 1234567var initialValue &#x3D; 0;var sum &#x3D; [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce( (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue.x ,initialValue);console.log(sum) &#x2F;&#x2F; logs 6 计算数组中每个元素出现的次数 12345678910111213var names &#x3D; [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Tiff&#39;, &#39;Bruce&#39;, &#39;Alice&#39;];var countedNames &#x3D; names.reduce(function (allNames, name) &#123; if (name in allNames) &#123; allNames[name]++; &#125; else &#123; allNames[name] &#x3D; 1; &#125; return allNames;&#125;, &#123;&#125;);&#x2F;&#x2F; countedNames is:&#x2F;&#x2F; &#123; &#39;Alice&#39;: 2, &#39;Bob&#39;: 1, &#39;Tiff&#39;: 1, &#39;Bruce&#39;: 1 &#125; Polyfillreduce 被添加到 ECMA-262 标准第 5 版，因此它在某些实现环境中可能不被支持。把下面的代码添加到脚本开头可以解决此问题，从而允许在那些没有原生支持 reduceRight 的实现环境中使用它。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Production steps of ECMA-262, Edition 5, 15.4.4.21// Reference: http://es5.github.io/#x15.4.4.21// https://tc39.github.io/ecma262/#sec-array.prototype.reduceif (!Array.prototype.reduce) &#123; Object.defineProperty(Array.prototype, 'reduce', &#123; value: function(callback /*, initialValue*/) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.reduce ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError( callback + ' is not a function'); &#125; // 1. Let O be ? ToObject(this value). var o = Object(this); // 2. Let len be ? ToLength(? Get(O, \"length\")). var len = o.length &gt;&gt;&gt; 0; // Steps 3, 4, 5, 6, 7 var k = 0; var value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &lt; len &amp;&amp; !(k in o)) &#123; k++; &#125; // 3. If len is 0 and initialValue is not present, // throw a TypeError exception. if (k &gt;= len) &#123; throw new TypeError( 'Reduce of empty array ' + 'with no initial value' ); &#125; value = o[k++]; &#125; // 8. Repeat, while k &lt; len while (k &lt; len) &#123; // a. Let Pk be ! ToString(k). // b. Let kPresent be ? HasProperty(O, Pk). // c. If kPresent is true, then // i. Let kValue be ? Get(O, Pk). // ii. Let accumulator be ? Call( // callbackfn, undefined, // « accumulator, kValue, k, O »). if (k in o) &#123; value = callback(value, o[k], k, o); &#125; // d. Increase k by 1. k++; &#125; // 9. Return accumulator. return value; &#125; &#125;);&#125; 1234567891011121314151617181920//concise method if (!Array.prototype.reduce) &#123; Object.defineProperty(Array.prototype, 'reduce', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.map ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let count = 0; for (let i = 0; i &lt; this.length; i++) &#123; count += callback(count, this[i], i, this); &#125; &#125;, &#125;); &#125; Array.prototype.reduceRight()这个方法与Array.prototype.reduce()只是执行顺序上相反（从右到左）。 reduceRight()方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 求一个数组中所有值的和1234var sum = [0, 1, 2, 3].reduceRight(function(a, b) &#123; return a + b;&#125;);// sum is 6 （虽然结果相同，但是是从右到左加） 展示 reduce 与 reduceRight 之间的区别123456var a &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;];var left &#x3D; a.reduce(function(prev, cur) &#123; return prev + cur; &#125;);var right &#x3D; a.reduceRight(function(prev, cur) &#123; return prev + cur; &#125;);console.log(left); &#x2F;&#x2F; &quot;12345&quot;console.log(right); &#x2F;&#x2F; &quot;54321&quot; PolyfillreduceRight 被添加到 ECMA-262 标准第 5 版，因此它在某些实现环境中可能不被支持。把下面的代码添加到脚本开头可以解决此问题，从而允许在那些没有原生支持 reduceRight 的实现环境中使用它。 12345678910111213141516171819202122232425262728293031// Production steps of ECMA-262, Edition 5, 15.4.4.22// Reference: http://es5.github.io/#x15.4.4.22if ('function' !== typeof Array.prototype.reduceRight) &#123; Array.prototype.reduceRight = function(callback /*, initialValue*/) &#123; 'use strict'; if (null === this || 'undefined' === typeof this) &#123; throw new TypeError('Array.prototype.reduceRight called on null or undefined'); &#125; if ('function' !== typeof callback) &#123; throw new TypeError(callback + ' is not a function'); &#125; var t = Object(this), len = t.length &gt;&gt;&gt; 0, k = len - 1, value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &gt;= 0 &amp;&amp; !(k in t)) &#123; k--; &#125; if (k &lt; 0) &#123; throw new TypeError('reduceRight of empty array with no initial value'); &#125; value = t[k--]; &#125; for (; k &gt;= 0; k--) &#123; if (k in t) &#123; value = callback(value, t[k], k, t); &#125; &#125; return value; &#125;;&#125; 下面是几种遍历方法的时间对比，可以看出传统for...耗时最少，；for...in最差。 对象for…in方法上面已经提到了for...in方法用于遍历数据的索引键。所以这个方法也可以用于遍历对象，具体方法如下： 123456789101112let obj = &#123;a : 1, b : 2, c : 3, d : 4&#125;for(let i in obj)&#123; console.log(`$&#123;i&#125;---$&#123;obj[i]&#125;`)&#125;/**a---1*b---2*c---3*d---4*/ Object.entries()Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。 参数 obj 可以返回其可枚举属性的键值对的对象。 返回值Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。 示例1234567891011121314151617181920212223242526272829const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]// array like objectconst obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]// array like object with random key orderingconst anObj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]// getFoo is property which isn't enumerableconst myObj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value() &#123; return this.foo; &#125; &#125; &#125;);myObj.foo = 'bar';console.log(Object.entries(myObj)); // [ ['foo', 'bar'] ]// non-object argument will be coerced to an objectconsole.log(Object.entries('foo')); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]// iterate through key-value gracefullyconst obj = &#123; a: 5, b: 7, c: 9 &#125;;for (const [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125; $&#123;value&#125;`); // \"a 5\", \"b 7\", \"c 9\"&#125;// Or, using array extrasObject.entries(obj).forEach(([key, value]) =&gt; &#123;console.log(`$&#123;key&#125; $&#123;value&#125;`); // \"a 5\", \"b 7\", \"c 9\"&#125;); Object.keys()Object.keys()方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。 参数 obj 要返回其枚举自身属性的对象。 返回值一个表示给定对象的所有可枚举属性（索引键）的字符串数组。 描述Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性（索引键）。这些属性的顺序与手动遍历该对象属性时的一致。 示例1234567891011121314151617181920// simple arrayvar arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // console: ['0', '1', '2']// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.keys(obj)); // console: ['0', '1', '2']// array like object with random key orderingvar anObj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.keys(anObj)); // console: ['2', '7', '100']// getFoo is a property which isn't enumerablevar myObj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function () &#123; return this.foo; &#125; &#125;&#125;);myObj.foo = 1;console.log(Object.keys(myObj)); // console: ['foo'] Object.values()Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。 参数 obj 被返回可枚举属性值的对象。 返回值一个包含对象自身的所有可枚举属性值的数组。 描述Object.values()返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。 示例12345678910111213141516171819var obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.values(obj)); // ['bar', 42]// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.values(obj)); // ['a', 'b', 'c']// array like object with random key ordering// when we use numeric keys, the value returned in a numerical order according to the keysvar an_obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.values(an_obj)); // ['b', 'c', 'a']// getFoo is property which isn't enumerablevar my_obj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function() &#123; return this.foo; &#125; &#125; &#125;);my_obj.foo = 'bar';console.log(Object.values(my_obj)); // ['bar']// non-object argument will be coerced to an objectconsole.log(Object.values('foo')); // ['f', 'o', 'o'] 本文大部分参考了MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"遍历","slug":"遍历","permalink":"http://yoursite.com/tags/%E9%81%8D%E5%8E%86/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1/"}]},{"title":"flex布局与grid布局简介","slug":"flex布局与grid布局简介","date":"2021-01-24T07:45:23.000Z","updated":"2021-01-25T13:19:33.582Z","comments":true,"path":"2021/01/24/flex布局与grid布局简介/","link":"","permalink":"http://yoursite.com/2021/01/24/flex%E5%B8%83%E5%B1%80%E4%B8%8Egrid%E5%B8%83%E5%B1%80%E7%AE%80%E4%BB%8B/","excerpt":"","text":"flex布局flex布局可以更加简洁的实现之前使用浮动和绝对布局实现的一些布局。特别是item的展示界面等。 首先应该明确一个概念，这个概念在grid布局中也存在，就是container与item，即被布局的元素被称为item，包围这些item的元素即为container。在flex布局中，item的大小要自己设置。 flex布局相对于grid布局，简单许多，它是按照轴线的方式进行布局，按照item其规定一个主轴线main axis（默认为水平），然后对应的即为交叉轴cross axis（默认为垂直）。 所以其属性也分为容器属性和元素属性。 容器属性首先要使用flex布局，就要将容器的display属性设为flex。 注意：一旦将容器的display属性设为flex，则其item的float、clear和vertical-align属性将失效。 1. flex-direction属性flex-direction属性规定了主轴的方向。由于主轴可能有水平、垂直方向，又每个轴又可以从左到右，从上到下或相反。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2. flex-wrap属性flex-wrap属性规定了主轴是否进行换行。默认是不进行换行，又由于flex布局中，item的大小是自己规定的，所以在一行中，若item的总宽度大于父容器的宽度，则会对元素的宽度进行压缩。其有3个属性： nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，从最后一行的左边开始换行，向上换行。 3. flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4. justify-content属性justify-content属性定义了项目在主轴上的对齐方式。其有5个值。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等，两侧无间隔。 space-around：每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。 space-evently：每个项目两侧的间隔相等。间隔等于两侧的间隔。 5. align-items属性align-items属性将所有直接子节点上的align-self值设置为一个组。 align-self属性设置项目在其包含块中在交叉轴方向上的对齐方式。其有5个属性（需要注意的是这里是对每个交叉轴而言，即规定每个交叉轴上元素的对其方式，每个交叉轴上的行宽不会变，这里区别于align-content属性）： flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6. align-content属性align-content属性设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。如果项目只有一根轴线，该属性不起作用。（即每个交叉轴的宽度不是固定的，区别于上面的align-items属性）其有6个值： flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目属性这些属性用于item中。 1. order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 2. flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3. flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4. flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。（这个属性与width相斥，只有一个属性生效。） 5. flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 3. align-self属性align-self属性允许单个项目有与其他项目在交叉行不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 注意：MDN中每个属性还有另外的一些值，比如align-items还有self-atart，start等属性，但是实测在chrome中虽然不会提示错误，但是也不会生效，只有上面的属性会生效，而且VSCODE中也只会提示上面的值，所以，目前只需掌握上面的值即可 grid布局grid布局应该是目前原生最先进的布局方案，也正是因为其原生先进，所以其兼容性并不是很好。 可以看出Chrome在57版本以上才支持，而IE直接不支持。所以不是很友好。但这grid布局是以后的主流。所以可以提前了解其特点。 相同，grid布局中也分为：container容器和item项目。 容器属性1. display 属性display: grid指定一个容器采用网格布局。 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 2. grid-template-columns 属性， grid-template-rows 属性容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 12345.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 上面代码指定了一个三行三列的网格，列宽和行高都是100px。 除了使用绝对单位，也可以使用百分比。 12345.container &#123; display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%;&#125; repeat()：repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。如：repeat(3, 20px)，也可以定义为repeat(3, 10px 20px 30px) auto-fill 关键字：有时，项目的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。 1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; 上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。 fr 关键字：为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。 1234.container &#123; display: grid; grid-template-columns: 1fr 1fr;&#125; 上面代码表示两个相同宽度的列。 fr可以与绝对长度的单位结合使用，这时会非常方便。 1234.container &#123; display: grid; grid-template-columns: 150px 1fr 2fr;&#125; 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。 minmax() minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 1grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 auto 关键字 auto关键字表示由浏览器自己决定长度。 1grid-template-columns: 100px auto 100px; 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。 网格线的名称 grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。 12345.container &#123; display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&#125; 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 3. grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。 最新标准中，grid-row-gap缩写为row-gap；grid-column-gap缩写为colimn-gap。 grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。 1grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; 4. grid-template-areas 属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。 12345678.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i';&#125; 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。 多个单元格合并成一个区域的写法如下。 123grid-template-areas: 'a a a' 'b b b' 'c c c'; 上面代码将9个单元格分成上下a、b、c三个区域。 下面是一个布局实例。 123grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\"; 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。 如果某些区域不需要利用，则使用”点”（.）表示。 123grid-template-areas: 'a . c' 'd . f' 'g . i'; 上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 下面是一个经典布局（其中item的属性grid-area下面介绍）： 1234567891011121314151617181920212223242526 &lt;!--css代码--&gt;.grid &#123; display: grid; grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\"; /* background-color: rgb(247, 80, 177); */ grid-template-rows: 30px 300px 30px; grid-template-columns: 400px 50px 50px; &#125; #header&#123; grid-area: header; background-color: rgb(206, 206, 206); &#125; #main&#123; grid-area: main; background-color: rgb(235, 224, 74); &#125; #sidebar&#123; grid-area: sidebar; background-color: rgb(250, 99, 99); &#125; #footer&#123; grid-area: footer; background-color: rgb(112, 72, 255); &#125; 1234567&lt;!--html代码--&gt; &lt;div class=\"grid\"&gt; &lt;div class=\"grid-inner\" id=\"header\"&gt;&lt;/div&gt; &lt;div class=\"grid-inner\" id=\"sidebar\"&gt;&lt;/div&gt; &lt;div class=\"grid-inner\" id=\"main\"&gt;&lt;/div&gt; &lt;div class=\"grid-inner\" id=\"footer\"&gt;&lt;/div&gt; &lt;/div&gt; 效果图： 3. grid-auto-flow 属性grid-auto-flow 属性决定子元素的排列方式。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 即grid-auto-flow 属性默认值为：row 其取值可以有： 单值 row（默认值）：按行进行排列 column：按列进行排列 dense：该关键字指定自动布局算法使用一种“稠密”堆积算法，如果后面出现了稍小的元素，则会试图去填充网格中前面留下的空白。这样做会填上稍大元素留下的空白，但同时也可能导致原来出现的次序被打乱。 如果省略它，使用一种「稀疏」算法，在网格中布局元素时，布局算法只会「向前」移动，永远不会倒回去填补空白。这保证了所有自动布局元素「按照次序」出现，即使可能会留下被后面元素填充的空白。 双值 row dense：按行排列，并按稠密算法进行填补。 column dense：按列排行，并按稠密算法进行填补。 正式语法1[ row | column ] || dense 4. justify-items 属性， align-items 属性， place-items 属性justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。 1234.container &#123; justify-items: start | end | center | stretch; align-items: start | end | center | stretch;&#125; 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-items属性是align-items属性和justify-items属性的合并简写形式。 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 下面是一个例子。 1place-items: start end; 如果省略第二个值，则浏览器认为与第一个值相等。 另外这个属性还有其他的值，但是支持度并不好： 支持较好的属性： 5. justify-content 属性， align-content 属性， place-content 属性justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。 start - 对齐容器的起始边框。 end - 对齐容器的结束边框。 center - 容器内部居中。 stretch - 项目大小没有指定时，拉伸占据整个网格容器。 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性是align-content属性和justify-content属性的合并简写形式。 1place-content: &lt;align-content&gt; &lt;justify-content&gt; 如果省略第二个值，浏览器就会假定第二个值等于第一个值。 6. grid-auto-columns 属性， grid-auto-rows 属性有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行（使用grid-column-start等属性）。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 123456789.container&#123; display:flex; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125;.item8&#123; grid-row-start: 4; grid-column-start: 2;&#125; 可以看到原本container只有3行3列，但是第8个item被设定在第四行，则浏览器会自动生成第4行，这个第四行就会受grid-auto-rows属性控制。 7. grid-template 属性， grid 属性grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。 grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。 项目属性1. grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线 1234.item-1 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。 上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。 除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。 下面的例子是指定四个边框位置的效果。 123456.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4;&#125; 另外，这4个属性的值还可以取网格线名字，和上面的网格线名字 1234.item-1 &#123; grid-column-start: header-start; //这里是网格线名字 grid-column-end: header-end; //这里是网格线名字&#125; 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 123.item-1 &#123; grid-column-start: span 2;&#125; 上面代码表示，1号项目的左边框距离右边框跨越2个网格。 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 2. grid-column 属性， grid-row 属性grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 1234.item &#123; grid-column: &lt;start-line&gt; / &lt;end-line&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt;;&#125; 下面是一个例子。 1234567891011.item-1 &#123; grid-column: 1 / 3; grid-row: 1 / 2;&#125;/* 等同于 */.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;/* 等同于 */.item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 3. grid-area 属性grid-area属性指定项目放在哪一个区域。 123.item-1 &#123; grid-area: e;&#125; 上面代码中，1号项目位于e区域，效果如下图。 注意：需要在container中使用： 123grid-template-areas: 'a b c' 'd e f' 'g h i'; 来指定区域的位置 grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 下面是一个例子。 123.item-1 &#123; grid-area: 1 / 1 / 3 / 3;&#125; 4. justify-self 属性， align-self 属性， place-self 属性justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 1234.item &#123; justify-self: start | end | center | stretch; align-self: start | end | center | stretch;&#125; 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-self属性是align-self属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 下面是一个例子。 1place-self: center center; 如果省略第二个值，place-self属性会认为这两个值相等。 总结可以看出： flex布局与grid布局相较于原始的浮动布局，简单快捷很多。所以目前flex布局使用的较多，但是由于grid布局的兼容性并不好，所以使用的并不多。 两种布局的属性中存在很多其他W3C以规定的属性，但是浏览器很多都没有实现，Chrome虽然有对应的值，但是并没有生效。 一个问题使用flex布局进行多行布局，并使用justify-content:center/space-around-space-between时，如果最后一行的item数目少于屏幕能容纳的最大数，最后一行会出现问题，即最后一行不能左对齐，会按照其属性进行居中。 目前还没找到很好的解决办法，特别是在每行的数目不能确定的情况下，目前最普遍的方法时使用空白标签占位法，即使用每行添加最大能容纳的item数目的空白标签。这样空白标签不会显示，显性标签就会展示为左对其。但是任然还有一个问题，就是如果每行的数目减小，或者刚好能够容纳，则会出现一行(甚至两行)空白区域。虽然不影响，但是感觉仍然不是最优解。grid布局虽然能够在格式上完美解决，但是由于其兼容性，也不是很好的解决办法。目前仍在想能有什么解决办法。","categories":[{"name":"布局","slug":"布局","permalink":"http://yoursite.com/categories/%E5%B8%83%E5%B1%80/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"},{"name":"flex布局","slug":"flex布局","permalink":"http://yoursite.com/tags/flex%E5%B8%83%E5%B1%80/"},{"name":"grid","slug":"grid","permalink":"http://yoursite.com/tags/grid/"}]},{"title":"Vue插件开发4-插件的打包与引用","slug":"Vue插件开发4-插件的打包与引用","date":"2021-01-13T04:10:05.000Z","updated":"2021-01-16T06:49:24.073Z","comments":true,"path":"2021/01/13/Vue插件开发4-插件的打包与引用/","link":"","permalink":"http://yoursite.com/2021/01/13/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%914-%E6%8F%92%E4%BB%B6%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E5%BC%95%E7%94%A8/","excerpt":"","text":"Vue插件的打包还是犯了一个最基础的错误，本来插件打包Vue-CLI官网给出了说明，而我还在苦苦百度。百度上的教程都是几年前的，全是照搬一套。 具体过程就是： 按照Vue插件开发1-插件原理即应用编写一个插件。 使用命令vue-cli-service build --target lib --name myLib [entry] myLib就是你的插件名字，主要是JS文件的命名。 [entry]是你的文件入口文件，即导出install函数文件 执行该命令就会生成打包完成的js文件。 dist/drag-window.common.js：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包) dist/drag-window.umd.js：一个直接给浏览器或 AMD loader 使用的 UMD 包 dist/drag-window.umd.min.js：压缩后的 UMD 构建版本 dist/drag-window.css：提取出来的 CSS 文件 (可以通过在 vue.config.js 中设置 css: { extract: false } 强制内联) js.map：source map文件是js文件压缩后，文件的变量名替换对应、变量所在位置等元信息数据文件，一般这种文件和min.js主文件放在同一个目录下。 比如压缩后原变量是map，压缩后通过变量替换规则可能会被替换成a，这时source map文件会记录下这个mapping的信息，这样的好处就是说，在调试的时候，如果有一些JS报错，那么浏览器会通过解析这个map文件来重新merge压缩后的js,使开发者可以用未压缩前的代码来调试，这样会给我们带来很大的方便！ npm插件的上传npm其实就是一个仓库。与git一样，我们使用npm install xxx的时候实际上是把其仓库中的xxx文件夹下载到本地。并再到node_modules中，我就可以直接使用import xxx from xxx的语法引入插件，实际上与我们在src下新建一个文件夹lib，然后使用import xxx from ./lib/xxx.js效果一样。 所以我们只需要 在npm注册一个npm账号。 然后新建一个文件夹使用npm init 初始化一个package.js文件。 123456789101112131415&#123; \"name\": \"drag-window\", \"version\": \"0.0.21\", \"description\": \"A plugin creating a drag window\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"darg\", \"window\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\" ], \"author\": \"mw530\", \"license\": \"MIT\"&#125; 这是一个最基本的样板，关键是private: true，然后把main.js设为生成的那个js文件。 在命令行使用npm adduser将自己的用户添加上去。 使用npm publish上传自己的文件。 注意：其中一个点是仓库必须切换为官方仓库，不能为淘宝仓库。 官方仓库：npm config set registry=http://registry.npmjs.org 淘宝仓库：npm install -g cnpm –registry=https://registry.npm.taobao.org; 插件的引用与Vue插件开发1-插件原理即应用的使用一样，只是引入的地址直接写插件命即可，如import xxx from &#39;xxx&#39;。然后使用Vue.use(xxx)。 注意样式表文件需全局直接import xxx/aaa.css，如果在&lt;style&gt;使用了使用了scope属性，则其样式表只在对应组件起效，如果不加，则会全局影响。","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/tags/Vue%E6%8F%92%E4%BB%B6/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"Vue插件开发3-简单拖动窗口的优化","slug":"Vue插件开发3-拖动窗口的优化","date":"2021-01-13T04:02:08.000Z","updated":"2021-01-16T02:05:31.776Z","comments":true,"path":"2021/01/13/Vue插件开发3-拖动窗口的优化/","link":"","permalink":"http://yoursite.com/2021/01/13/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%913-%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"","text":"思路思路一中心思想：首先算出首次拖动窗口距视窗的上面和左面的距离，然后计算出每次鼠标的偏移量（可正可负）。然后将其相加，就可得到新的偏移量。 代码思路： 设置一个变量，用于标记鼠标是否按下。 mousedown钩子函数中记录下此时的clientX1,clientY1,offsetX,offsetY。 mousemove钩子函数中记录下次此时的clientX2,clientY2，然后计算两组量： 拖动之前拖动框距文档边框的距离left1 = clientX1 - offsetX，top1 = clientY1 - offsetY 拖动的距离disX = clientX2 - clientX1，disY = clientY2 - clientY1 此时新的left2 = left + disX，top2 = top + disY 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546banMouseDown(e) &#123; console.log(\"鼠标按下\"); this.isDown = true; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); Vue.set(this.currenctPositon, \"x\", e.clientX); Vue.set(this.currenctPositon, \"y\", e.clientY); Vue.set(this.currenctPositon, \"offX\", e.offsetX); Vue.set(this.currenctPositon, \"offY\", e.offsetY);&#125;,banMouseUp() &#123; this.isDown = false; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"default\";&#125;,banMouseMove(e) &#123; debounce(this, this.handle, 20)(e); //节流函数&#125;,handle(e) &#123; if (this.isDown) &#123; console.log(e); let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); let cx = e.clientX; let cy = e.clientY; let moveX = (this.currenctPositon.x - this.currenctPositon.offX) + (cx - this.currenctPositon.x); let moveY = (this.currenctPositon.y - this.currenctPositon.offY) + (cy - this.currenctPositon.y); Vue.set(this.currenctPositon, \"x\", cx); Vue.set(this.currenctPositon, \"y\", cy); dw.style.left = moveX + \"px\"; dw.style.top = moveY + \"px\"; &#125;&#125;, 思路二然后又发现另一个思路（似乎更简单）： 中心思想：要想达到拖动效果，即要保持鼠标的位置相对于拖动框是相对静止的。而鼠标的位置相对于拖动框就是offset的值，是不会变化的。所以当鼠标发生移动时，拖动框的位置也要发生变化，才能保证offset的值是不变的。所以我们在新的一次鼠标移动(mousemove)后，新的偏移量应当赋予拖动框的left,right值。即left = clientX2 - offsetX，top = clientY2 - offsetY 代码思路： 设置一个变量，用于标志鼠标是否按下。 mousedown钩子函数中记录下此时的clientX1,clientY1,offsetX,offsetY。 mousemove钩子函数中记录下次此时的clientX2,clientY2，然后计算拖动出偏移量dOffsetX，dOffsetY，具体 left = clientX2 - offsetX top = clientY2 - offsetY 将拖动窗口的样式: style.left设置为left style.top设置为top 实测是可以使用的。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940banMouseDown(e) &#123; console.log(\"鼠标按下\"); this.isDown = true; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); Vue.set(this.currenctPositon, \"x\", e.clientX); Vue.set(this.currenctPositon, \"y\", e.clientY); Vue.set(this.currenctPositon, \"offX\", e.offsetX); Vue.set(this.currenctPositon, \"offY\", e.offsetY);&#125;, banMouseUp() &#123; this.isDown = false; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"default\"; &#125;, banMouseMove(e) &#123; debounce(this, this.handle, 20)(e); &#125;, handle(e) &#123; if (this.isDown) &#123; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); let cx = e.clientX; let cy = e.clientY; Vue.set(this.currenctPositon, \"x\", cx); Vue.set(this.currenctPositon, \"y\", cy); let moveX = this.currenctPositon.x - this.currenctPositon.offX; let moveY = this.currenctPositon.y - this.currenctPositon.offY; dw.style.left = moveX + \"px\"; dw.style.top = moveY + \"px\"; &#125; &#125;,&#125; 思路三接下来我发现了另外一个api：movementX，movementY，这个api会在mousemove时记录与上一次移动的距离，所以就在思路一的基础上可以省略求disX,disY的过程，所以有了以下代码： 123456789101112131415161718handle(e) &#123; if (this.isDown) &#123; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); let cx = e.clientX; let cy = e.clientY; Vue.set(this.currenctPositon, \"x\", cx); Vue.set(this.currenctPositon, \"y\", cy); let moveX = this.currenctPositon.x -this.currenctPositon.offX + e.movementX; let moveY = this.currenctPositon.y -this.currenctPositon.offY + e.movementY; dw.style.left = moveX + \"px\"; dw.style.top = moveY + \"px\"; &#125;&#125;, 但是由于movementX,movementY返回的是int，精度不够，所以会出现不跟手的情况；而且IE均不支持该属性，所以不是最优方案。 思路四最后我去参考了layui的方案。 12345678910111213141516171819202122232425262728293031323334353637383940 moveElem.on('mousedown', function(e)&#123; e.preventDefault(); if(config.move)&#123; dict.moveStart = true; dict.offset = [ e.clientX - parseFloat(layero.css('left')) ,e.clientY - parseFloat(layero.css('top')) ]; ready.moveElem.css('cursor', 'move').show(); &#125; &#125;);_DOC.on('mousemove', function(e)&#123; //拖拽移动 if(dict.moveStart)&#123; var X = e.clientX - dict.offset[0] ,Y = e.clientY - dict.offset[1] ,fixed = layero.css('position') === 'fixed'; e.preventDefault(); dict.stX = fixed ? 0 : win.scrollLeft(); dict.stY = fixed ? 0 : win.scrollTop(); //控制元素不被拖出窗口外 if(!config.moveOut)&#123; var setRig = win.width() - layero.outerWidth() + dict.stX ,setBot = win.height() - layero.outerHeight() + dict.stY; X &lt; dict.stX &amp;&amp; (X = dict.stX); X &gt; setRig &amp;&amp; (X = setRig); Y &lt; dict.stY &amp;&amp; (Y = dict.stY); Y &gt; setBot &amp;&amp; (Y = setBot); &#125; layero.css(&#123; left: X ,top: Y &#125;); &#125; layui采用的是一种更为常见的方式。 其关键在于其并没有直接拿offsetX，而是通过clientX - left，clientY - top来计算offset。其原因在于可能是offset属性的兼容性问题。 Feature Chrome Edge Firefox (Gecko) Internet Explorer Opera Safari Basic support (Yes) (Yes) 39.0 (39.0) 6 (Yes) (Yes) Redefined from long to double 56 ? ? ? ? ? offsetX在早期返回一个int，这对于拖动窗口有很大的影响，比如上面的movement属性，所以layui选择了更加稳定的直接获取其style.left属性。 函数节流这一部分，我觉得可加可不加，因为虽然DOM消耗很大，但是目前计算机的性能是完全足够承担一秒几十次到上百次的DOM重绘的。额可以在后期加入检测机制，如果机器性能较差，则可以节流mousemove函数。具体细节可以查看函数的节流与防抖","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Vue插件开发","slug":"Vue插件开发","permalink":"http://yoursite.com/tags/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"拖动窗口","slug":"拖动窗口","permalink":"http://yoursite.com/tags/%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"Vue插件开发2-事件对象e与视窗api详解","slug":"Vue插件开发2-事件对象e与视窗api详解","date":"2021-01-13T03:57:39.000Z","updated":"2021-01-21T02:09:25.631Z","comments":true,"path":"2021/01/13/Vue插件开发2-事件对象e与视窗api详解/","link":"","permalink":"http://yoursite.com/2021/01/13/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%912-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1e%E4%B8%8E%E8%A7%86%E7%AA%97api%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"事件参数 首先Vue没有对事件对象做修改，所以在Vue中的事件对象仍然与原生一样。 其对象属性具体又分为4类： 鼠标 / 键盘属性 属性 描述 altKey 返回当事件被触发时，”ALT” 是否被按下。 button 返回当事件被触发时，哪个鼠标按钮被点击。一个数字，表示鼠标事件发生时按下的鼠标按钮。可能的值：0：鼠标左键1：车轮按钮或中间按钮（如果有）2：鼠标右键注意： Internet Explorer 8和更早版本具有不同的返回值：1：鼠标左键2：鼠标右键4：车轮按钮或中间按钮（如果有）注意：对于左侧配置的鼠标，返回值会反转 buttons buttons属性返回一个数字，指示触发鼠标事件时按下了哪些鼠标按钮或鼠标按钮。一个数字，表示鼠标事件发生时按下的一个或多个鼠标按钮。如果按下多个按钮，则组合这些值以产生新数字（例如，如果按下左按钮（1）和右按钮（2），则返回值为1 + 2，即3） 。可能的值：1：鼠标左键2：鼠标右键4：滚轮按钮或中间按钮8：第四个鼠标按钮（通常是“浏览器返回”按钮）16：第五个鼠标按钮（通常是“浏览器转发”按钮）注意：对于左侧配置的鼠标，返回值会反转 clientX 返回当事件被触发时，鼠标指针的水平坐标。 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 ctrlKey 返回当事件被触发时，”CTRL” 键是否被按下。 metaKey 返回当事件被触发时，”meta” 键是否被按下。 relatedTarget 返回与事件的目标节点相关的节点。 screenX 返回当某个事件被触发时，鼠标指针的水平坐标。 screenY 返回当某个事件被触发时，鼠标指针的垂直坐标。 shiftKey 返回当事件被触发时，”SHIFT” 键是否被按下。 IE 属性除了上面的鼠标/事件属性，IE 浏览器还支持下面的属性： 属性 描述 cancelBubble 如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。 fromElement 对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。 keyCode 对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup 事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。 offsetX,offsetY 发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。 returnValue 如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 fasle，可以取消发生事件的源元素的默认动作。比如在a标签的事件中如果将该值设为false，则不会跳转；在submit按钮中就不会提交事件。 srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。 toElement 对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。 x,y 事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。 但是当前大部分浏览器的事件对象都已经趋近于统一，比如上图是chrome的事件对象，其中也涵盖了大部分上述所谓IE属性。 标准 Event 属性下面列出了 2 级 DOM 事件标准定义的属性。 属性 描述 bubbles 返回布尔值，指示事件是否是起泡事件类型。 cancelable 返回布尔值，指示事件是否拥有可取消的默认动作。 currentTarget 返回其事件监听器触发该事件的元素。 eventPhase 返回事件传播的当前阶段。 target 返回触发此事件的元素（事件的目标节点）。 timeStamp 返回事件生成的日期和时间。 type 返回当前 Event 对象表示的事件的名称。 这部分参数中使用较多的可能是前面几个属性，比如bubbles，cancelables 标准 Event 方法下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法： 方法 描述 initEvent() 初始化新创建的 Event 对象的属性。 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 stopPropagation() 不再派发事件。 这些方法是挂载在原型链的Event对象上的，所以直接的点击或其他事件是看不到的。 参数详解 currentTarget、srcElement与target currentTarget事件属性返回其事件侦听器触发事件的元素。 target始终返回触发事件的真实元素。（在事件冒泡中与currentTarget不同） currentTarget在直接捕捉e得到的结果为null，必须在函数中通过一个变量存储下来。 target的值会始终存储在e中，可以直接通过e查看。 srcElement与target一致，指向事件触发的元素，旧版本firefox不支持。 detail：detail属性返回一个包含事件详细信息的数字。在onclick和ondblclick上使用时，该数字表示当前的点击次数。在onmousedown和onmouseup上使用时，该数字表示当前点击次数加1。 isTrusted：isTrusted事件属性返回一个布尔值，指示事件是否可信。注意：在Chrome，Firefox和Opera中，如果事件由用户调用，则该事件是受信任的，如果由脚本调用，则不受信任。在IE中，除了使用createEvent()方法创建的事件之外，所有事件都是可信任的。 relatedTarget：relatedTarget属性返回与触发鼠标事件的元素相关的元素。relatedTarget属性可以与mouseover事件一起使用，以指示光标刚刚退出的元素，或者使用mouseout事件来指示光标刚刚输入的元素。 which：which属性返回一个数字，表示触发鼠标事件时按下了哪个鼠标按钮。（注意与button不一致） | 项目 | 描述 || :——- | :———————————————————– || 返回值： | 一个数字，表示鼠标事件发生时按下的鼠标按钮。可能的值：0：没有按钮1：鼠标左键2：滚轮按钮或中间按钮（如果有）3：鼠标右键注意：对于左侧配置的鼠标，返回值会反转。 | 视窗相关参数这里具体详解视窗相关参数： clientX,clientY：在页面（不包括浏览器bar部分）可视范围，与最左面，最上面的距离。 pageX、pageY：在整个页面范围内（包括不可视的部分），与最左面，最上面的距离。 screenX、screenY：距离显示器最左面，最上面的距离。（当窗口全屏时，即client加浏览器bar） layerX、layerY：鼠标相比较于当前坐标系的位置,即如果触发元素没有设置绝对定位或相对定位,以页面为参考点,如果有,将改变参考坐标系,从触发元素盒子模型的border区域的左上角为参考点。值得注意的是：该属性是以border边界为0，而offset是以content边界为0。 但是MDN上标注该属性为非规范属性，各个浏览器结果预期不一致，最好不要使用。 offsetX、offsetY：距离事件触发元素的左面，上面的距离。 注意：offset中，padding会被算在内。border会被算作负值。即offset是以padding作为边界的，超过这个边界即被判为负值。 DOM元素还含有一个属性用于计算该元素相对于视窗的距离：getBoundingClientRect()，该方法有4个属性： top：元素上边到视窗上边的距离; right：元素右边到视窗左边的距离; bottom：元素下边到视窗上边的距离; left：元素左边到视窗左边的距离; 注意：这些属性一旦超出视窗范围即为负数 DOM元素还带有一下一组（4个）属性： offsetLeft：返回元素相对于父级元素的左侧偏移量 offsetTop：返回元素相对于父级元素的左侧偏移量 offsetHeight：返回元素的高度（包括padding，border） offsetWidth：返回元素的宽度（包括padding，border） offsetParent：返回元素的父级元素 clientLeft：返回元素到父级元素左侧的距离（包括padding，不包括border） clientTop：返回元素到父级元素上侧的距离（包括padding，不包括border） clientHeigt：返回元素的高度（包括padding，不包括border） clientWidth：返回元素的宽度（包括padding，不包括border） scrollHeight：返回元素的滚动总高度（即总页面，包括因滚动而不在视野内的）（包括padding，不包括border） scrollWidth：返回元素的滚动宽度（即总页面，包括因滚动而不在视野内的）（包括padding，不包括border） 具体需要注意的是： 即offsetxxx包括border，其他的clientxxx，scrollxxx不包括border 这个距离与dom.style.left一样，指的是相对于外层具有定位标志（具有positon样式的元素）的祖先元素的距离。（若外层元素没有positon属性，则以ducoment为其定位元素） 通过element.style.left只能用来赋值（是字符串，需加后缀px），无法直接获取其值，必须通过上面的offsetLeft来获取其具体值。","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/tags/Vue%E6%8F%92%E4%BB%B6/"},{"name":"事件参数","slug":"事件参数","permalink":"http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0/"}]},{"title":"Vue插件开发1-插件原理即应用","slug":"Vue插件开发1-插件原理即应用","date":"2021-01-12T06:45:27.000Z","updated":"2021-01-14T13:49:55.819Z","comments":true,"path":"2021/01/12/Vue插件开发1-插件原理即应用/","link":"","permalink":"http://yoursite.com/2021/01/12/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911-%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%8D%B3%E5%BA%94%E7%94%A8/","excerpt":"","text":"原理简介 插件通常用来为 Vue 添加全局功能。-Vue官网 我觉得广义上的插件，实际上就是一些可以复用的功能或组件的封装。 首先分析Vue源码： 12345678910111213141516171819202122232425//src-&gt;core-&gt;instance-&gt;index.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 我们可以法Vue实例最初是一个函数，然后在其上挂载各种属性。作为函数，我们就可以为其直接添加属性，或者向其prototype上添加参数。 Vue的插件通常包括一下几种： 添加全局方法或者 property。如：vue-custom-element 注册代码： 123456function install(Vue) &#123; Vue.customElement = function vueCustomElement(tag, componentDefinition, options = &#123;&#125;) &#123; //... &#125; //...&#125; 可以看到，这里是直接向Vue实例上添加属性方法。 使用： 1Vue.customElement() 另外，这个插件使用了Web Component这一新的属性，还得找个时间学习一下。它可以在HTML文件中直接使用自定义标签。 添加全局资源：指令/组件/过滤器/过渡等。如 vue-touch 注册代码（vue-touch）： 123456vueTouch.install = function (Vue) &#123; Vue.directive('touch', &#123; //... &#125; //...&#125; 这里是使用了Vue的directive定义了一个全局的v-touch指令。 123&lt;a v-touch:tap=\"onTap\"&gt;Tap me!&lt;/a&gt;&lt;div v-touch:swipeleft=\"onSwipeLeft\"&gt;Swipe me!&lt;/div&gt; 另外，还可以通过Vue.filter注册全局的filter来进行使用，比如 123456789let plugin = &#123;&#125;plugin.install = function(Vue, options)&#123; Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;)&#125; 则可以直接在Vue的tempelate中使用 1&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; 值得注意的是全局组件的注册，因为很多时候我们开发组件是需要组件样式支撑的。这个时候就需要全局注册组件。比如element-UI(可惜无了)，iview这种组件库就需要注册大量的全局样式。 注册代码（部分）（element-UI）： 123components.forEach(component =&gt; &#123; Vue.component(component.name, component);&#125;); 这里使用Vue.component注册全局组件，这样注册的组件可以直接在任何组件中引用而不需在script中申明。 值得注意的是，这样引入的组件即使未被引用，依然会被打包，因此，在大型组件库中尽量少使用全局注册，否则会增加打包后的js大小。 通过全局混入来添加一些组件选项。如 vue-router 注册代码： 123456789101112131415161718export function install (Vue) &#123; Vue.mixin(&#123; beforeCreate () &#123; if (isDef(this.$options.router)) &#123; this._routerRoot = this this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, '_route', this._router.history.current) &#125; else &#123; this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this &#125; registerInstance(this, this) &#125;, destroyed () &#123; registerInstance(this) &#125; &#125;)&#125; 可以看到，这里vue-router使用了Vue.minin对beforeCreate进行了混入，使该混入钩子在Vue自身的钩子之前调用。 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。比如element-UI等组件库。 注册代码： 123456789101112131415161718192021222324const install = function(Vue, opts = &#123;&#125;) &#123; locale.use(opts.locale); locale.i18n(opts.i18n); components.forEach(component =&gt; &#123; Vue.component(component.name, component); &#125;); Vue.use(InfiniteScroll); Vue.use(Loading.directive); Vue.prototype.$ELEMENT = &#123; size: opts.size || '', zIndex: opts.zIndex || 2000 &#125;; Vue.prototype.$loading = Loading.service; Vue.prototype.$msgbox = MessageBox; Vue.prototype.$alert = MessageBox.alert; Vue.prototype.$confirm = MessageBox.confirm; Vue.prototype.$prompt = MessageBox.prompt; Vue.prototype.$notify = Notification; Vue.prototype.$message = Message;&#125; 在Vue的prototype上添加很多参数方法。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router vue-router中有一个index.js与install.js，在install.js中，只提供了与Vue相关的注册函数。在index中，定义了很多自己的API。 使用插件通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成： 123456// 调用 `MyPlugin.install(Vue)`Vue.use(MyPlugin)new Vue(&#123; // ...组件选项&#125;) 也可以传入一个可选的选项对象： 1Vue.use(MyPlugin, &#123; someOption: true &#125;) Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。 Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 Vue.use()。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 Vue.use()： 123456// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时var Vue = require('vue')var VueRouter = require('vue-router')// 不要忘了调用此方法Vue.use(VueRouter) 另外，全局样式表的引入需要直接在main.js中import，这样的css样式也会被全局注册，会影响所有的组件。 开发插件Vue插件打开发其实很简单，最关键的就是其必须要暴露一个install方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 12345678910111213141516171819202122232425262728293031MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) Vue.component('my-component', Mcomponent) //常用 Vue.filter('my-filter', Mfilter) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125;export MyPlugin 应用根据上面的原理，我们只需要遵顼插件定义和使用的规则即可，其目录解构并不重要，但是为了规范，可以新建一个plugin用来存储插件文件，插件的目录解构可以自定义。另外，项目直接使用vue-cli生成一个普通的项目即可。 可以看到，在index.js文件中，我们定义了install函数，并在Vue的prototype上挂载了一个函数和一个方法，同时，也注册了一个全局的组件dwin。最后将该对象导出。 然后在main.js中，我们从index.js中引入dw，然后使用Vue.use(dw)将该组件导入。 然后我们就可以在任何组件中使用dwin组件了。 这样一个简单的组件开发就完成了，具体的打包和上传到npm仓库见这里","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Vue插件开发","slug":"Vue插件开发","permalink":"http://yoursite.com/tags/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"dragWindow","slug":"dragWindow","permalink":"http://yoursite.com/tags/dragWindow/"}]},{"title":"TypeScript特点2","slug":"TypeScript特点2","date":"2021-01-10T06:40:17.000Z","updated":"2021-01-11T06:52:20.742Z","comments":true,"path":"2021/01/10/TypeScript特点2/","link":"","permalink":"http://yoursite.com/2021/01/10/TypeScript%E7%89%B9%E7%82%B92/","excerpt":"","text":"类型兼容性TS中的类型兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。 与Java不同，Java的强制转换是基于继承的，只有有继承关系的对象才可以进行转换。 即只要对象中的成员有包含关系，则可以进行类型转换。如， 1234567891011interface Named &#123; name: string;&#125;class Person &#123; name: string;&#125;let p: Named;// OK, because of structural typingp = new Person(); 这一点也是根据JS的灵活性设计的，JS中变量类型是自动检测的，程序员不需要专门进行规定。 对象的兼容TS结构化类型系统的基本规则是，如果x要兼容y，（所谓x兼容y，就是x可以被赋值为y），如 12345678interface Named &#123; name: string;&#125;let x: Named;// y's inferred type is &#123; name: string; location: string; &#125;let y = &#123; name: 'Alice', location: 'Seattle' &#125;;x = y; 称为x兼容y。 这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。 函数的兼容函数参数兼容函数的兼容与对象的兼容相反，函数x的参数包含函数y的参数，则x兼容y。如 12345let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // OKx = y; // Error 要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。 第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。 这里可以理解为，在函数赋值时，函数的参数可以被忽略的，（注意：函数调用的时候仍然必须赋值相等的参数，否则采用可选参数）但是限制了不能多余参数。即y中的参数s，在被赋值给x的时候直接被忽略，即 1234567//JS中函数调用的灵活性function f(a, b)&#123; //...&#125;f(1, 2); //参数b被忽略f(1, 2, 3) //多加参数c 函数返回值兼容返回参数少的函数可以被赋值为参数多的函数（这里TS称参数多的为参数少的函数的子类），即源函数可以被赋值为子类，即向下转换，如 12345let x = () =&gt; (&#123;name: 'Alice'&#125;);let y = () =&gt; (&#123;name: 'Alice', location: 'Seattle'&#125;);x = y; // OKy = x; // Error, because x() lacks a location property 类的兼容类的兼容只比较实例成员。静态部分不会被比较。（仍然是基于成员的比较，而不是Java中的继承），如 123456789101112131415class Animal &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;class Size &#123; feet: number; constructor(numFeet: number) &#123; &#125;&#125;let a: Animal;let s: Size;a = s; // OKs = a; // OK 高级类型交叉类型（Intersection Types）交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。 通俗的讲，就是包含所有成员类型的成员属性。如： 123456789101112131415161718192021222324252627function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; //将T与U成员变量混合成为新的变量，并返回该变量，返回时采用交叉类型而不是any let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person(\"Jim\"), new ConsoleLogger());var n = jim.name;jim.log(); 联合类型（Union Types）形式：A|B|C 含义： 作为参数时，仅支持A类或B类或C类，其他类型数据均不被接接受。如： 1234567function f(value: number|string)&#123; //...&#125;f(1); //正常f(\"1\"); //正常f(true); //失败 作为返回值时： 1234567891011121314151617interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;function getSmallPet(): Fish | Bird &#123; // ...&#125;let pet = getSmallPet();pet.layEggs(); // okaypet.swim(); // errors 由于返回的是A|B,所以我们只能访问A与B的交叉成员。 类型保护与区分类型（Type Guards and Differentiating Types）联合类型可以使我们接受多种特定类型的参数，但是我们要在函数内部更具参数类型执行特定的操作时又该如何判断呢。下面的写法是错误的，因为联合类型在访问任何独有参数时，都会发生错误。 123456789let pet = getSmallPet();// 每一个成员访问都会报错if (pet.swim) &#123; pet.swim();&#125;else if (pet.fly) &#123; pet.fly();&#125; 为了使代码工作，必须使用类型断言 12345678let pet = getSmallPet();if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125; 用户自定义的类型保护注意到，这种写法，我们在任何时候调用参数属性时，都必须加上类型断言。我们可以采用另外一种写法使之后的参数调用不再加上类型断言。 TS中的类型保护机制使之成为现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词： 123function isFish(pet: Fish | Bird): pet is Fish &#123; return (&lt;Fish&gt;pet).swim !== undefined;&#125; 在这个例子里， pet is Fish就是类型谓词。 谓词为 parameterName is Type这种形式， parameterName必须是来自于当前函数签名里的一个参数名。 每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型（在以后对应分支中的参数的每次调用都会被识别为该类型），只要这个类型与变量的原始类型是兼容的。 12345678// 'swim' 和 'fly' 调用都没有问题了if (isFish(pet)) &#123; pet.swim();&#125;else &#123; pet.fly();&#125; typeof类型保护实际上我们可以发现，在上面的断言函数中执行的内容就是判断参数是否为对应类型，是返回true，否返回false，所以我们在断言函数内部可以使用typeof来进行判断。 1234567891011121314151617function isNumber(x: any): x is number &#123; return typeof x === \"number\";&#125;function isString(x: any): x is string &#123; return typeof x === \"string\";&#125;function padLeft(value: string, padding: string | number) &#123; if (isNumber(padding)) &#123; return Array(padding + 1).join(\" \") + value; &#125; if (isString(padding)) &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 更进一步，对于原始类型（number, string, boolean, symbol），TS直接将typeof识别为断言函数，而不必我们每次都为原始类型类型编写一个断言。 123456789function padLeft(value: string, padding: string | number) &#123; if (typeof padding === \"number\") &#123; return Array(padding + 1).join(\" \") + value; &#125; if (typeof padding === \"string\") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 这些 typeof类型保护只有两种形式能被识别： typeof v === &quot;typename&quot;和 typeof v !== &quot;typename&quot;， &quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。 instanceof类型保护对于非原始类型，如何做到类型判断并收紧呢？TS提供了instanceof类型保护，也可以避免我们重写断言函数。 123456789101112131415161718192021222324252627282930313233interface Padder &#123; getPaddingString(): string&#125;class SpaceRepeatingPadder implements Padder &#123; constructor(private numSpaces: number) &#123; &#125; getPaddingString() &#123; return Array(this.numSpaces + 1).join(\" \"); &#125;&#125;class StringPadder implements Padder &#123; constructor(private value: string) &#123; &#125; getPaddingString() &#123; return this.value; &#125;&#125;function getRandomPadder() &#123; return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(\" \");&#125;// 类型为SpaceRepeatingPadder | StringPadderlet padder: Padder = getRandomPadder();if (padder instanceof SpaceRepeatingPadder) &#123; padder; // 类型细化为'SpaceRepeatingPadder'&#125;if (padder instanceof StringPadder) &#123; padder; // 类型细化为'StringPadder'&#125; instanceof的右侧要求是一个构造函数，TypeScript将细化为： 此构造函数的 prototype属性的类型，如果它的类型不为 any的话 构造签名所返回的类型的联合 null和undefinedTS将null，undefined视为两种不同的类型，他们不能被赋值给任何其他类型的参数。如官方文档所说： 注意，按照JavaScript的语义，TypeScript会把 null和 undefined区别对待。 string | null， string | undefined和 string | undefined | null是不同的类型。 可选参数与可选属性使用了 --strictNullChecks，可选参数会被自动地加上 | undefined: 1234567function f(x: number, y?: number) &#123; return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, 'null' is not assignable to 'number | undefined' 也就是说，可选属性可以被赋值为undefined作为占位参数，但是不能被赋值为null。 同样的，可选属性也可被赋值为undefined作为占位参数。 12345678910class C &#123; a: number; b?: number;&#125;let c = new C();c.a = 12;c.a = undefined; // error, 'undefined' is not assignable to 'number'c.b = 13;c.b = undefined; // okc.b = null; // error, 'null' is not assignable to 'number | undefined' 类型别名形如C中的typedef语法，TS提供了类型别名。 1234567891011type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入： 1type Container&lt;T&gt; = &#123; value: T &#125;; 我们也可以使用类型别名来在属性里引用自己： 12345type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125; 类型别名只能出现在申明的左侧。 字符串字面量类型字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。 12345678910111213141516171819type Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\";class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === \"ease-in\") &#123; // ... &#125; else if (easing === \"ease-out\") &#123; &#125; else if (easing === \"ease-in-out\") &#123; &#125; else &#123; // error! should not pass null or undefined. &#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, \"ease-in\");button.animate(0, 0, \"uneasy\"); // error: \"uneasy\" is not allowed here 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。 1Argument of type &#39;&quot;uneasy&quot;&#39; is not assignable to parameter of type &#39;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#39; 数字字面量类型TypeScript还具有数字字面量类型。 123function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 &#123; // ...&#125; 我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候： 123456function foo(x: number) &#123; if (x !== 1 || x !== 2) &#123; // ~~~~~~~ // Operator '!==' cannot be applied to types '1' and '2'. &#125;&#125; 换句话说，当 x与 2进行比较的时候，它的值必须为 1，这就意味着上面的比较检查是非法的。 可辨识联合（Discriminated Unions）你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素： 具有普通的单例类型属性— 可辨识的特征。 一个类型别名包含了那些类型的联合— 联合。 此属性上的类型保护。 12345678910111213interface Square &#123; kind: \"square\"; size: number;&#125;interface Rectangle &#123; kind: \"rectangle\"; width: number; height: number;&#125;interface Circle &#123; kind: \"circle\"; radius: number;&#125; 首先我们声明了将要联合的接口。 每个接口都有 kind属性但有不同的字符串字面量类型。 kind属性称做 可辨识的特征或 标签。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起： 1type Shape = Square | Rectangle | Circle; 现在我们使用可辨识联合: 1234567function area(s: Shape) &#123; switch (s.kind) &#123; case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; &#125;&#125; Symbols这个部分也是ES6的引入一种新的原生类型，如number，string。 其特点是唯一，一个symbols是唯一独特的，无法改变的。即使两个symbol输入的key一样，这两个值仍然是完全不同的。 symbol类型的值是通过Symbol构造函数创建的。 123let sym1 = Symbol();let sym2 = Symbol(\"key\"); // 可选的字符串key Symbols是不可改变且唯一的。 1234let sym2 = Symbol(\"key\");let sym3 = Symbol(\"key\");sym2 === sym3; // false, symbols是唯一的 像字符串一样，symbols也可以被用做对象属性的键。 1234567let sym = Symbol();let obj = &#123; [sym]: \"value\"&#125;;console.log(obj[sym]); // \"value\"","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"TypeScript特点1","slug":"TypeScript特点1","date":"2021-01-09T07:18:36.000Z","updated":"2021-01-10T06:40:00.050Z","comments":true,"path":"2021/01/09/TypeScript特点1/","link":"","permalink":"http://yoursite.com/2021/01/09/TypeScript%E7%89%B9%E7%82%B91/","excerpt":"","text":"基础类型VoidTS中增加了void类型，用于表示没有任何类型，一般也是用于一个函数没有返回值，但是与其他语言不同的是，TS允许一个变量直接声明为Void型（虽然这没什么用）。 1let unusable: void = undefined; void型变量只能被赋值undefined,null Null 和 Undefined这里的null与undefined与JS中基本一致，其是所有类型的子类，即所有的变量都可被赋值为null与undifined。 Nevernever表示那些永远不存在的的值的类型。从应用的角度来看，与void对比，never一般用于无法返回的函数的返回值类型。比如抛出错误的函数，死循环的函数。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; never与null、undefined一致，也是所有类型子类（比null,undefined级别更低）。 除了上述最常用的方法，never有其他用处。比如尤雨溪谈到的收窄类型 类型断言简单说，就是在对any型变量操作时跳过TS在编译时的检测，对于一个any的变量，我们在某些特定情况下知道其必定为某种特定类型，此时调用其特定的方法。我们可以跳过编译时的检测，但是其对运行没有影响。 具体，形式一：“尖括号”语法 123let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 形式二：as语法 123let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 注意，无论是否通过类型断言，没有指定属性的变量始终返回undefined，如 1234567let a : any = 145;let b = (a as string).length;console.log(a.length); //undefinedconsole.log(b); //undefined 解构解构这一部分ES6也支持 ，并且我觉得这是一个非常好的特征，可以更加灵活地进行变量的交换，拆分，合并。 数组解构下面的形式是最简单的数组解构形式 1234let input = [1, 2];let [first, second] = input;console.log(first); // outputs 1console.log(second); // outputs 2 解构用于以申明的变量(交换变量是一个很好的应用) 12// swap variables[first, second] = [second, first]; 用于函数参数 12345function f([first, second]: [number, number]) &#123; console.log(first); console.log(second);&#125;f(input); …语法获取剩余变量 123456789let [first, ...rest] = [1, 2, 3, 4];console.log(first); // outputs 1console.log(rest); // outputs [ 2, 3, 4 ]function f([first, ...second]: [number, number, number, number]) &#123; console.log(first); //1 console.log(second); //[2,3,4]&#125;f(1,2,3,4); 只要位置对应，可以解构数组任何位置元素 123456let [first] = [1, 2, 3, 4];console.log(first); // 1let [, second, , fourth] = [1, 2, 3, 4];console.log(second); // 2console.log(fourth); // 4 对象解构与数组解构原理一致，只要键名一致，就可以就行解构。如， 12345678let o = &#123; a: \"foo\", b: 12, c: \"bar\"&#125;;let &#123; a, b &#125; = o;console.log(a) //fooconsole.log(b) //12 也可以用没有申明的赋值： 1(&#123; a, b &#125; = &#123; a: \"baz\", b: 101 &#125;); 注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。 同样，我们可以使用...语法进行剩余元素提取。 12345678let o = &#123; a: \"foo\", b: 12, c: \"bar\"&#125;;let &#123;a, ...others&#125; = o;console.log(a); //fooconsole.log(others); //&#123; b: 12, c: 'bar' &#125; 属性重命名我们也可以对提取的元素进行重命名， 1let &#123; a: newName1, b: newName2 &#125; = o; 这里需要注意的是:不是表示类型，而是旧名字与新名字的间隔。 但是如果需要限制提取元素的类型，则不能进行属性重命名。 展开我们可以使用...语法来进行数组（对象的展开），如 数组展开 123let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5]; //bothPlus = [0,1,2,3,4] 对象展开 12let defaults = &#123; food: \"spicy\", price: \"$$\", ambiance: \"noisy\" &#125;;let search = &#123; name: \"me\", ...defaults &#125;; //search = &#123;name:\"me\",food:\"spicy\", price: \"$$\", ambiance: \"noisy\" &#125; 值得注意的是，在对象展开中，相同的键值对会被合并！ 接口这里的接口与传统面向对象语言中的接口有一定的差距， 在面向对象的语言中（如Java），接口是一个抽象类型，是抽象方法的集合。 而在TS中，接口更多的是对数据及其解构进行检查。 下面是一个典型的用法： 1234567891011interface LabelledValue &#123; label: string; size: int; //顺序无关&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;printLabel(myObj); //Size 10 Object 与函数参数一致，接口中允许可选属性，只读属性的存在，例如： 123456789interface SquareConfig &#123; color?: string; width?: number; //加?可选属性&#125;interface Point &#123; readonly x: number; readonly y: number; //readonly-只读属性&#125; readonly vs const readonly用于属性； const用于变量； 额外的属性检查这里有一点需要注意的是，如果是采用字面量形式参数时，会触发额外属性检查。如： 12345678910interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;); 这里会报错： script.ts(6,46): error TS2355: A function whose declared type is neither ‘void’ nor ‘any’ must return a value. script.ts(10,31): error TS2345: Argument of type ‘{ colour: string; width: number; }’ is not assignable to parameter of type ‘SquareConfig’. Object literal may only specify known properties, but ‘colour’ does not exist in type ‘SquareConfig’. Did you mean to write ‘color’? 但是我们在传参时不采用字面量对象传参，而是采用变量直接穿，则不会触发额外属性检查。 1234567891011interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let arg = &#123; colour: \"red\", width: 100 &#125;;let mySquare = createSquare(arg); 运行正常！ 函数类型当然TS中的接口也有传统面向对象语言中的抽象方法集合的功能。 123interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 与java不同，TS中的接口是可以直接被使用的，如， 12345let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125; 即直接定义变量的类为接口，在Java中这是不允许的，只有实现接口后的类才能被实例化。 接口实现这一点与java一致，接口是可以被实现的。 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; And，TS中接口可以多继承！ 函数TS中函数部分比较简单，主要仍然是格式问题 123function f(v1: int, v2: string) boolean&#123; //...&#125; 其他的细节都是JS中的内容，此处不谈。","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"2020-奋斗的一年","slug":"2020-奋斗的一年","date":"2020-12-31T15:34:10.000Z","updated":"2021-01-07T15:46:56.788Z","comments":true,"path":"2020/12/31/2020-奋斗的一年/","link":"","permalink":"http://yoursite.com/2020/12/31/2020-%E5%A5%8B%E6%96%97%E7%9A%84%E4%B8%80%E5%B9%B4/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+U0yD2u19z+hIl0tz/+DcsEUkp18GvtZdsfJFirU8LNbS/NpztXqJzUso7GC3DCzVCEMquNr5IlcnOgOvugTp6HDH90NlI6GglxnROl+m5bdVOu0rqesS90tutcttbqPYM/BGPgAJCTfCz/o/XKd8mx1Mn1Ha83w5/bcgmzLKMPI3xPLrXDAuyrISUYlmImXBFrdsZ/zuvF5OpxD0nN07nXtPdnL9f875LimkcbZsPRlN5/QAO6wTwDDtfQo/xZI5bbw2y7EAISaSJQ2FHI2z5J0DqQ4q2/hDBWRer1yqjWPXfgIGh1iRV5oQexga+fJG+lvmmmqcSF6YIlfjzNpyJdry2np9/cONKG5LSebaF4HWxl88+zvcxtVraUj9UMVShtpyl89+FMMlvhTJExM2GOR60mbJpHCGcBZCPpLVm0gV2S+beC2j0hpUM6ZmAnQ9eswM5aBd+X/kZ6Eah38rciJgEqCwkD0P/D9FtQWcBLL9oHPb2GcKQeCkwi0ZXQSaCtj1akCb2yEcVZG6e26OalqWCQ6ESV5TdAis6Ln6bCh76at3rDsRDylxDJp8kWkkqhvEsizYwuTopxzUOUFXyF7UYFf+pa1KJd/gnoDK47d2txjs69z39q7KFsukdC3qzgcwMZzXDTRnPGmweJ+KAZJcZUWjKuADBfIh3KJy21Klw5BDYhNvceR5Q/f7YeYjlXCvwjhnz61bZJd/oDaq2V3O/cPu1O+fbIGie7KolegLTg3quNHdGmVWMtHasj9TIj1y9j/bZJ1C1WCbP2+G1k2SulQnLS+YFrnCmMTBae/JD4FBRaILMwojOgmVKCftlWWp53K0TyMOGnEh4fPfp6V8Iyi5fxobTa63o3lX4aJzyOskZ1x0d31nkHj/IolEfc2K785RnLTyQMeN4riH5r3YgXzF6rnlBipk5Vuav/9x8dMGrMUmhsYM3tClY1fsvSgEIvxtWk98e6TUYeqDZN+kWnrzeOn6TUBKGfoN6fPinkJMWDFppyaow770bpZtSP4+mTd6r3OMph78efq0eKzyhef/paUo8bzqHYupLj2zUdKNr59Hz4qbwZ6JW0C0LAEYUrb/i9fYbSHQPfM9lQk+r/FNYDJGKQ8dF1UtKrb6I9ImcIPjPuuSgEm1hm+XSIut9lWXeS5mmpbL1/kvrb/m7Sxb8RZ06TzYZ6DtslPOes7pHPnjcJSGbKv1V36wVekAkVM63wYdf3QFMUppP1MR1MSIAjlz02ddJ4g9V0cJWylLhz5hDxMqixRfk3s+UD+9Q2+XQ2tT9z4xSeavXa27x5U9ChymZ7scdjesU4U/eHDCv6oKrhXihvzI3dM/0sETqWjJr9aOfJhbmbuicVzsYN6JFodUQu7gifW0/Qi2Qhwyajo8di7vHSIZwpleyj+C+a+uU3sFyp0MjxpbSagEf4QcIEqx4P8gtCuZG43VBypPvi5qcJvoKwTXL7r0jncBT4d30neifY6fZegyLrMaUIjj64Z2F/2/hz1ZsLo28KWeAkbO8JmziwGJ5+LoX8BktyKhYt7jniM5xFyL45LCbgrhdjnhlgSpyqZ8gSbBgUaoLQggawrh7G6ISr4BMOBKKDrjDu++Bukk4KAqV2B4fdYi32Oe0VdHCCRKgl7SBGKEwnRzVVnWvf0fqEq6btAdnVOHYGnbUXc4WPA54gq7DpICtoSl8AeEyUlolHGbDsGUEc2QBT93SJQce3OLE0/YpNEUvy3T3rlfF1ZiQ0UVJVZbK0PSM0qiPX8EMealx1FI3KDts53hGH5+fXYyEbApJ0++/Iq/GdzgihGOkO0xegSPC5c7PmKQxOsnw+xdeBQ5w+oEV94oGBZ8p41GtyoT4+GUcInjWosj4zZGRfgfOroiQfc8G2NAJO8aQYeMwEVykd30V6319DC9Y4TeJbOSgcQTyIfn0m8VjXnXcQjHtfFLYcdfmbTtSzv3+81oC4EL0v3YLunP8MkqJHLcs6Yuf5liqY3wTTgSAZrGwqj/Me+g5eW3BO2GpXVc7kDNvFFnb1YH7QRQZnD7SvTW8q5xOHnemr1duYZ6B9aVV0UZXR/Tgwe0lumlVscMvjkN/jiS20M4MmvoByR7hmUXsE+Eg/YAZ/gdYTkMniPs5dUBvWMuRU9RO7hTzbBHQ7Tado7xCj2p16T2x2OzaBwvkikMp5uCWnKWzqeke2S/rBSGMlzpzAfoJRDeM0tDhHkhDdz3GntodsfzfnjLggopOzMgmGC1kBUWaQijuFMLcq/pmnWmuig5/rwlsKQceG7xC60J4m/pc9e1+AOFmJwhoEtixiufj6hxy2XhVhoymUvorJhYU8RFaZkq4S87Skgqb/tXfNqZeBb8mWPhna2rotaE24lKgSyn+SWLX7YmIa1hUlCI+T2pyBOaMAldvxdXRuR7JLzHWpMUEliB1UQ5CnsZZrNXeDJzCSbjG7u3ieC/KyRfr9MhgdaMFnKopyv9mZtF2aWnNaBTwie+1cUG9jmRDGIWTZCX8ovbwqgBqPPQiQJSP1nfT/oj2pncicBI3Gjx9xws8Nt2x6+Zw4PCKjsVKdndf10JqtIOFoDRhBdr1irimnLcYE9y86I/PIPyCQItlTw6bgZg07Ri7OBWUbYSXUkI3e2m6ZgeeBpmCw6RUnOh9NAXqIGi91ZlyhTW1FM9j/a8BmefTVc9pDR6zfJ4tKjPTzUCV2PchCzuNLv1Nx4rxn/PGUmHVIaJGnEBBYqs+XEdEtr0O/nDzFw5NCJIqAqLiruTmgpVDXAq/Sa6YWzEWAS532LktyMsYAxvL3YHE7m50tmB2yO9XD3DZqc5R+84A7b+jX7PMpKS7J/1yeTLLxpCZulmp7/BHJgu03A7WCqgEPqP2dwi41t19gIoWv/jFo2/XYataUgnwf0p7BPScFNVMZvdlc5K747ZguVcHyxyMc2DQvyw/hOcDl/ccWvf53HdKC/cRafGdx702MJVLg0BnZ8Qxtq61NquE7Be7uDUqMpKCJFFL1Gmm+88zJzVcnibIRkBqASpQUPBsQ9BVfKVv6751MhEOner0tzpRbqKHi3mV0aDfo8YeKWwF4/fS8N6B4M5Lsjhboyh6knhMl8P/UlUcNRkts+TTps0p2iYXhfcXFpJDQWhes4G81BBZ2EfIiWb+KY94pVTgcx2dZ/S7qfTk2L8HCBFiCq5a021Co5m6FJFM3FTY0Zo0dgS8nboLkhRwi1WPAyCy2K0ZAwPmg20yWutWKMwrjh5Ne9N+p33dU+l8bs9CbvfMLPO/XmSoDAU0xTrOaiXJHbfSpSoBD36kXQzy3FdlXrf60ADeHrRq1v9aMbInkozZ1eOKw/T/UoAWlMpOrrsQBP4td006AXX3e5Dv0GVfF93ybais0Tqfik6s3QFIPJHlVH+9M41kMDzGJ5kkPFNEAMKZVMJ63EmDWysg2z7NoCqmtMqUPtGnuJIbvOF8mCyKayGOr4GSYZuAma1qPHqA6ImKCM2R8b+HCBYBrVmpLVdBGGnYVQ8Dfk6WKaCUFP8wT1FEk5yExaQj+E8/5Ve7jHQl0Otl1dauIctslhpVh6hQGB0fc55a/xgWdWkYt1OmbQhLE8FoXWJvo7tQlaI7fIPuhWHUb9lZzt1trVgcV2VWvYDy9fnR2v/zEbI0fLX2eugS27kBDFiqCxExqjnHiemPq7FVCT/k1LRqylacLUsnW2JE5t8IcIEEFKfl17ro5JqV4/yv//2M/Wi6kJCj0Ap2zorGxVAr4rpB5tdKHrZcB2jFdfdGZJVq+g5mMTK0pYBKx+ZuHRzywqQjHzwrVB38wC3WpJ3kL1Q5tOK/y5L9jDuJvWKcfo63ugcwdvUuY4eTq6VvsjeAleI35aen1+i7jZI36QulTtgNk9JLCeHx958CBH5rCxrZ/TQGKBSAp2tnK77znGz/bKxZnnu9dRGaYQN6oNB2L5d7+vfobzYww3tVzV8vRQTcbWbFy2W9SxSy+ohBwYQqXMmOzYrNF/U1Bjyv3qWpKaq8XXfzUA2+lO0HVyhQLzKB4mMFwVlvWeoAwU9e0X5mcvSE0ekHUtStnxanceZzUHPro4t1PHgxTp52Nx0KqaTxKBB5TjE0ZVvi3HpfT6OiELNaYKTNC3HdQHwXZy0a4G730j0ZR5gjlr7RTzC1GP9/xdIorWket/wXZZnbg4gNfyRZ38Wl7Yd8ZbQFtkxFTN5jsJflccjYMNDHrnWkQkXYXl9oPjV0Cfugd9jTRdfC22eebGAdexfj/zPOSALZ7YZLUptxOTFgSO1PbfV5NGk0D3HCex2Z2auMm8MGrqGccb2oB19D7r62wvbobSD2Y0tsk8he2sfi1qmPLrkZ0Ev4DU4YpdBWpcDOiwlzqoh/xioqMhT0GwULDywpulnLsLyom2T0dVd5JQqgWkzdmbt5necfGqWDwiwTTJBsZqwiRRfR6TN2Lfzz4/rUccps4s0+rSRv3CXRrQDPd41497g1qk/X+lMuHk2+3jM433mM+BZG2q0VZEePNSbujTojPONRV1jbwDQhq2qNFstHNm1DYUEtfoijCWmvHWq/iRV3pqJjUl8O7CZgWo+WMoNw+zkQgueMkd9PsV3AAR4A8QMdF7RQHa9N0TQdPhfmgWy5miHrVtsaN6tc75ppwZPgY8MI6XnR+c6ofM9rzj8U+OCuIbv3kiJEK94SanfqL//3mOr4/F4KYMnDJUB5TMin7/JEQxTX3KkeLQs6 var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"2020","slug":"2020","permalink":"http://yoursite.com/categories/2020/"}],"tags":[{"name":"2020","slug":"2020","permalink":"http://yoursite.com/tags/2020/"},{"name":"计划","slug":"计划","permalink":"http://yoursite.com/tags/%E8%AE%A1%E5%88%92/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"考研遇到了问题！！！","slug":"考研遇到了问题！！！","date":"2020-04-22T10:46:58.000Z","updated":"2020-04-22T11:49:36.858Z","comments":true,"path":"2020/04/22/考研遇到了问题！！！/","link":"","permalink":"http://yoursite.com/2020/04/22/%E8%80%83%E7%A0%94%E9%81%87%E5%88%B0%E4%BA%86%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81/","excerpt":"","text":"回顾考研与2020想想考试复习考研已经有整整3个多月了，大概一月下旬就开始复习了！ 首先复习了两门科目 数学 英语 数学采用了看视频的方式进行了一轮复习，到四月十号左右就完成了。 英语的话由于最开始没有资料，只有几套真题，所以我直接上手真题。当然，错误率非常之高，问题只有一点：单词和短语积累不够，感觉每一道题，只要单词，短语90%理解，那基本不会错的。所以后面开始用百词斩背单词。由于之前背过，所以考研的词汇还有事多天就要背完了，当然会忘记，所以在考研的过程中，要不间断的背下去。 总体回顾的话，我感觉4月之前，也就是1,2,3月份的状态比较好，早上做英语，下午看视频学习数学，晚上复习数学。作息比较规律，至少可以做到不赖床。 四月的问题进入四月，数学的基础部分基本完成，英语也看了许多视频，把刘晓艳得语法，长难句都看了一遍。书也差不多过了一遍。但是接近四月中旬时出现了很大的问题： 问题 身体出现了问题： 最开始是牙龈出血严重，平时都能感觉口型腔内的血腥味 耳鸣开始困扰我，只要周围声音一大，耳膜就开始震动，耳朵很敏感；晚上睡觉时耳鸣严重（倒是没太影响睡眠）。后来去检测发现鼻炎严重，开始治疗鼻炎。 开始上课了，导致不得不频繁的使用电子设备，很容易分心。 看书感觉很难集中精力去想问题，看着讲义上的内容，完全不想动脑。 不节制玩游戏。 聊天过于频繁。 解决方法既然出现的问题，就必须去解决问题。否则只会被问题一点点拖垮！以我现在的状态，不配考上研究生！ 对于身体问题，只能说加紧治疗，毕竟没有更好的办法，只要不影响学习（但是我感觉最近这一系列问题的出现都是身体问题引起的）。 上完课就将电子设备放到远离自己的位置，避免手能够直接接触。 难集中精力，我觉得80%因为电子设备在旁边，所以先实行方法2，看是否还有其他原因。 立刻戒掉游戏，可以在周末玩一会。 当断不断，必受其乱！现在不是时候！ 接下来的安排既然选择了考研，我就不会退缩！所以我有以下安排来恢复状态，想想高中时一天学习14.5个小时的时候，现在这些算的了什么？！毕竟我是南实出来的人，还是练出来了吧！ 想想自己为什么考研？之前的我还不是很明确，但是现在，我觉得考研的目的很简单，就是为了实现自己的人生目标，实现阶级的跨越，在这样一个阶级越来越固化的时代，中国为底层提供了一个很好的工具，就是读书。起码读完硕士，就迈入了中薪阶层。后面在考虑是否读博士，现在的我并不很排斥继续读博士。 具体措施如下： 恢复斗志很关键，必须要恢复斗志，这是一切的来源！ 尽量隔离电子设备，学习时不看手机！ 每天计划，用纸打印表格。 每周总结，并发布到博客上。 规律作息，早上6:30起床，晚上23:30睡觉。 每周天放松，早上看书，下午玩游戏，晚上看技术文章，写总结。（作息仍然不变！） 一定要坚持下去最开始我在想考研该是有多困难啊！那么多人考不上，后来我才发现原来不是考研难，而是复习的这个过程最困难。不比高中，有人24hours的监督你来学习，时间制定好，饭做好。大部分人可能都没有高考时一半用心，所以考上的人那么少。我现在是真的体会到了他们常说的一句话，考研比的是坚持，比的是身体，比的是自律！一点没错！智商的影响只在于你是否能考上北大清华。加油，记住你对自己的定位！","categories":[{"name":"考研","slug":"考研","permalink":"http://yoursite.com/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://yoursite.com/tags/%E8%80%83%E7%A0%94/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Vue源码1-从初始化到响应式原理","slug":"Vue源码1-从初始化到响应式原理","date":"2020-01-08T14:09:52.000Z","updated":"2020-01-08T15:37:47.093Z","comments":true,"path":"2020/01/08/Vue源码1-从初始化到响应式原理/","link":"","permalink":"http://yoursite.com/2020/01/08/Vue%E6%BA%90%E7%A0%811-%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"首先介绍后面要用到的几个类： Observer类：用于将一个数据变为响应式（可被观测） Watcher类：一个依赖（一个指令对应一个依赖），一旦有一个指令用到了某个对象属性，那么就会新建一个Watcher作为订阅者。 Dep类：依赖管理器，一个对象属性对应一个Dep，其有一个内部属性subs用于存放依赖。 Vue初始化Vue原型是在src/instance/idnex.js中定义的： 12345678910111213141516171819202122232425//src/instance/idnex.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 可以看到Vue原型是一个function。在这个函数只判断了是否是new出来的，否则报警告。然后直接调用了_init()方法，这个方法是在下面的initMixin(Vue)中混入的初始化方法。下面看一下这个方法中的重要部分。 1234567891011121314151617181920212223//init.js 52-72 liens initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props //state包括data，props，methods initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; 这里按顺序进行了一下操作(最简化，不考虑分支)： 首先初始化了生命周期 initLifecycle(vm) 初始化了事件($on,$emit,$once…) initEvents(vm) 初始化了render initRender(vm) 调用了beforeCreate生命周期 callHook(vm, &#39;beforeCreate&#39;) 是初始化inject initInjections(vm) 接下来的initState中，初始化了data,props,methods。 initState(vm) 初始化provide initProvide(vm) 调用生命周期created，callHook(vm, &#39;created&#39;),如同官网所说： 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前尚不可用。 最后一步将el挂载到页面。vm.$mount(vm.$options.el) 响应式原理（以对象为例）响应式的所有文件都放在observer文件夹下： observer array.js:数组的处理相关处理 dep.js:依赖管理器类的定义及其处理 index.js:整个observer的出口 scheduler.js:调度者相关文件 traverse.js:递归遍历一个对象，以唤醒所有转换getter，使每个嵌套的属性内的对象作为“深度”依赖项收集。 watcher.js:观测者，依赖的类定义与相关处理。 还是接着上面的第6步:initState initState方法定义在state.js中，下面节选这一部分中内容： 12345678910111213141516171819202122//state.jsexport function proxy ()&#123; //代理处理 //比如当我们调用this.xxx 的时候实际上它是挂载在vm._data.xxx的，这里的代理同样使用了Object.defineProperty()来进行了代理。&#125;export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 可以看到intiState中，Vue进行了下面主要操作： initProps(vm, opts.props) initMethods(vm, opts.methods) initData(vm) initWatch(vm, opts.watch) 然后以data为例，分析对data的处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243//state.jsfunction initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 在这个函数里 首先看data是一个对象还是一个函数，对其进行对应的处理 然后判断他不能与props,methods中的属性同名，因为最终这三部分都会被挂载到vm实例上。 最后调用observe()方法来使data变为可被观测的 然后我们看observe()方法，这个方法就位于observer下的index.js中了。 1234567891011121314151617181920212223//observer/index.jsexport function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 作为整个将数据变为响应式的入口函数，它进行了一下操作： 判断传入的val如果不是一个对象或者是一个Vnode，就直接返回，不做处理 判断整个val是否有__ob__整个属性或者是不是Observer的子类，如果是的话，直接将val.__ob__返回 进行了一系列的其他的判断，比如是否应该被观测（shouldObserve这个对象定义在全局中，判 标识此时是否应该处理数据）、是否处于服务端渲染模式、是一个数组或是一个对象、是不是可扩展的、是不是Vue本身。 新建一个Observer对象，并将value传入。 继续向下看，新建Observer对象过程，Observer对象也在index中定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//observer/index.jsexport class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 可以看到Observer对象包含了三个私有属性： value：当前观测对象 dep：依赖管理器 vmCount：将这个对象作为$data的数量 再看他的构造方法中，执行流程如下： 初始化了value，dep，vmCount 并给value的加上一个(不可枚举的)__ob__属性，可以联系上面判断__ob__的操作 判断value是否是一个数组，然后执行对数组的observer操作。现不看数组。 如果不是，则代表value是一个对象，则执行walk()方法对其进行处理。 在walk()中，可以看到Vue遍历了对象的所有属性并对其调用了defineReactive方法 我们再跟进defineReactive方法中（这个方法就差不多是核心了）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; //为每一个属性建立一个依赖收集器 const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125; &#125;)&#125; 还是分析一下他的执行流程： 首先建立了一个Dep对象，即每一个属性都有一个依赖管理器用来收集用到这个属性的依赖，这一部分后面在讲。 判断这个对象属性能否被修改，及判断其configurable属性。 判断这个对下给你属性是否自带了getter与setter，如果有的话就将其缓存下来。 判断是否在函数调用时为这个对下给你属性传入了customSetter，如果有的话，则先调用getter将其值存储下来。 判断有无子对象或者是否在函数调用时确定只观测表层属性（不循环处理），如果都不满足则递归进行子属性的响应式处理。 这里就使整个响应式的核心：Object.defineProperty，在这里Vue为其定义了enumerable,configurable,get,set get()： 获取原始的属性值（通过原始getting或者直接获取） 判断Dep.target的值是否存在（这个值后面介绍Dep对象时介绍，代表的是当前的依赖），如果存在的话，就调用dep对象的depend()方法进行依赖收集。 接下来判断是否有子ob对下给你，如果有的话，也调用子的dep的depend方法进行依赖收集。同时判断对象属性原来的值是否是个数组，如果是的话，调用dependArray方法进行数组的依赖收集。 set() 获取对象属性原本的值，调用原来的getter，如果没有，就接受传入的值。 判断有没有必要更新。 判断是否有customSetter，如果有的话，就调用 如果只有getter，没有setter，则直接返回。这里是为了修复#7981的BUG，问题大概是如果一个对象属性如果被其他插件修改后只有getter，但没有setter，也就是说整个插件的原意是将其变为一个不可写入的属性，但是如果不加这一句进行判断，那么Vue会直接调用val = newVal，对其进行赋值。这不符合预期，所以加了这一句判断，直接返回不进行处理。 判断如果原来有setter的话，就调用其setter。否则就直接赋值给val。 然后同样是对子属性的处理。 这一步进行依赖派发。 至此，defineReactive方法流程介绍完毕。但是我们还留下了两个坑 依赖收集dep.depend()具体如何完成的 依赖通知dep.notify()具体如何完成的 接下来我们在进入这两个函数进行分析。 首先我们看一下Dep对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//observer/dep.js/* @flow */import type Watcher from './watcher'import &#123; remove &#125; from '../util/index'import config from '../config'let uid = 0/** * A dep is an observable that can have multiple * directives subscribing to it. * 一个dep可以有多个指令（包括\"&#123;&#123;&#125;&#125;\",\"v-text\",\"v-html\"...）订阅它。 * target属性用于表示正在处理的依赖，当确定为这个值的指令时，则将其添加到subs中（addSub函数）。 * subs属性用于存放所有的依赖，他的依赖是Watcher类 */export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this/* 这个依赖管理器Dep实例 */) &#125; &#125; notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;// The current target watcher being evaluated.// This is globally unique because only one watcher// can be evaluated at a time.Dep.target = nullconst targetStack = []export function pushTarget (target: ?Watcher) &#123; targetStack.push(target) Dep.target = target&#125;export function popTarget () &#123; targetStack.pop() Dep.target = targetStack[targetStack.length - 1]&#125; 可以看到Dep对象有三个属性， target：一个静态属性，类型是Watcher，即当前执行的依赖 id：Dep的标识符 subs：整个dep中所有的依赖，是一个Watcherd数组 然后我们直接看depend()方法： 这个函数判断dep的target是否存在，如果存在的话，则调用当前依赖的addDep方法，我们知道这个target是一个Watcher。所以我们看一下Watcher： 1234567891011121314151617181920212223242526272829303132export default class Watcher &#123; //初始化了很多属性 vm: Component; expression: string; cb: Function; id: number; deep: boolean; user: boolean; lazy: boolean; sync: boolean; dirty: boolean; active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any;&#125; addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; //调用depaddSub方法把这个指令（this）添加到这个dep中 dep.addSub(this) &#125; &#125; &#125; 可以看到在addDep中，判断这个Watcher对应的新dep中是否含有这个传进来的Dep，如果没有就其push到新dep与新depIds中，然后判断原来的dep中是否含有这个watcher，如果没有，就push进来。 这里的newDep与dep是为了灵活的动态更新视图，思考以下场景： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;span v-if&#x3D;&quot;nameShow&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;span&gt; &lt;span v-if&#x3D;&quot;ageShow&quot;&gt;&#123;&#123;age&#125;&#125;&lt;&#x2F;span&gt; &lt;input :value&#x3D;&quot;name&quot;&#x2F;&gt; &lt;input :value&#x3D;&quot;age&quot;&#x2F;&gt; &lt;button @click&#x3D;&quot;nameShow &#x3D; !nameShow&quot;&gt;切换name状态&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;ageShow &#x3D; !ageShow&quot;&gt;age&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name:&quot;Register&quot;, data () &#123; return &#123; nameShow: true, ageShow: true, name:&quot;123&quot;, age:&quot;111&quot; &#125; &#125;&#125;&lt;&#x2F;script&gt; 当nameShow与ageShow都是true时，我们对表单机进行修改以修改name与age的值时，肯定会涉及到到依赖的分发。 但是当我们点击button将nameShow或ageShow的值切换为false时，视图上已经不显示对应信息，则讲道理应该不会在对这个依赖进行通知。这个newDep的存在就是为了这里。 至此，依赖收集的过程基本完成。下面看看如何进行依赖派发的： 当一个对象属性被改变时，其set方法就会被调用，由此调用dep.notify()，进行依赖派发。我们看一下dep.notify()这个函数内部： 12345678910111213141516//observer/dep.jsnotify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 可以看到首先是对subs所有的依赖进行了排序，根据官方的注释是应为：如果subs不是异步运行的话，那么他们没有在调度者中进行排序，所以我们需要对其进行排序以保证其正确按序派发。 然后这里调用每一个watcher的update方法，进行DOM的更新。看一下update()方法 12345678910update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 可以看到首先判断了这个watcher是不是懒加载的，如果是的话，将其dirty属性变为true，Vue会在调用到它时进行加载，否则看他是不是同步的，如果是的话，立即调用run()进行DOM更新操作，否则就将其推入到queueWatcher队列中，等待调度者，进行调度。（这里就不再讲调度算法，后续再讲） 再进入run()方法： 1234567891011121314151617181920212223242526272829303132//observer/watcher.js /** * Scheduler job interface. * Will be called by the scheduler. */ run () &#123; if (this.active) &#123; const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher \"$&#123;this.expression&#125;\"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125; &#125; 由官方的注释也可以看出来，这个run()是由调度者进行执行的（除非他是一个同步的watcher） run()函数的运行流程如下： 判断这个wacher是否的活动的，如果是才操作。 通过get()获取这个watcher对应的值，判断获取到的值与watcher中保存的值是否相同 如果不等，则把当前watcher中保存的值作为oldValue保存下来，将当前watcher中的value设为获取到的value，然后判断这个watcher是不是用户定义的（this.user）（根据调度者中注释，watcher分为user watcher与render watcher），如果使用定义的watcher则用try--catch预防错误，否则直接调用这个watcher的回调函数。这个回调函数就会进行真正操作，比如调用rrnder更新DOM。 数组的响应式如何实现在上面我们介绍Dep对象时，在其构造方法中，我们只看了this.walk()对对象的操作，现在我们看一下对数组的操作： 123456789101112131415161718192021export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; 如果value是一个对象，那么会判断value有没有__ptoto__对象，因为部分浏览器不支持这个属性，如果有的话，则调用protoAugment(value, arrayMethods)把arrayMethods挂载到value的__proto__上，我们再看一下arrayMethods，它放在 observer/array.js中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 可以看到 首先是以原生Array的prototype作为原型创建了一个新的对象arrayMethods。 列举出需要被修改的数组方法methodsToPatch 对methodsToPatch进行forEach循环，并给arrayMethods定义每一个列举出的方法（不可枚举），如果这些方法中要为这个数组插值，我们必须也要探测这个值是否是一个引用类型（Araay或者Object），并也要将其变为响应式，所以后面判断了如果是push,unshift,splice则拿到要插入的值inserted 判断inserted是否存在，如果存在，也使用observeArray将其变为响应式。 进行依赖收集ob.dep.notify() 返回原始方法调用后返回的结果。 然后我们再看protoAugment方法： 12345function protoAugment (target, src: Object) &#123; /* eslint-disable no-proto */ target.__proto__ = src /* eslint-enable no-proto */&#125; 可以看到很简单，就只是把第一个参数的__proto__修改为第二个参数，结合我们刚刚传入的参数，即：将这个数组的_proto_修改为arrayMethods，即上面我们分析的这个对象。 再看copyAugment方法，这个方法也很简单，是针对不支持__proto__属性的浏览器： 1234567891011/** * Augment a target Object or Array by defining * hidden properties. *//* istanbul ignore next */function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125;&#125; 即遍历所有的方法名字，并将其设置为到目标数组上的不可枚举属性。 最后我们看一下observeArray方法： 12345678/** * Observe a list of Array items. */observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125; 这里实际上就是将数组的每一个值变为响应式。 但是还有一点是：我们还可以通过下标的方式为数组赋值，但是JS中找不到方法检测整个操作，所以Vue也无法检测到，所以Vue提供了Vue.set和Vue.del这两个api，用来弥补这一点。 至此，响应式的整个流程就差不多完成了。 最后梳理以下整个流程(对象)： 这个流程主要是我通过分析源码，借助一定的网上资料整理出来的，可能其中会有错误。希望大家指出来，谢谢。","categories":[{"name":"Vue源码","slug":"Vue源码","permalink":"http://yoursite.com/categories/Vue%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Vue源码","slug":"Vue源码","permalink":"http://yoursite.com/tags/Vue%E6%BA%90%E7%A0%81/"},{"name":"响应式原理","slug":"响应式原理","permalink":"http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"}]},{"title":"JavaScript中的&，&&，|，||","slug":"JavaScript中的与或运算","date":"2020-01-07T11:51:20.000Z","updated":"2020-01-07T11:54:33.006Z","comments":true,"path":"2020/01/07/JavaScript中的与或运算/","link":"","permalink":"http://yoursite.com/2020/01/07/JavaScript%E4%B8%AD%E7%9A%84%E4%B8%8E%E6%88%96%E8%BF%90%E7%AE%97/","excerpt":"","text":"简单区分&amp;,&amp;&amp;,|,||&amp;&amp; 位与运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右全为1才为1 || 位或运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右有一个1结果就为1 &amp;&amp;&amp;&amp; 逻辑运算符（与） — 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- 如果第一个值（转换后）为true，则返回后一个值。 如果第一个值（转换后）为false，则返回第一个值。 |||| 逻辑运算符（或）—- 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- 如果第一个值（转化后）为true，则返回第一个值。 如果第一个值（转化后）为false，则返回第二个值。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"运算符","slug":"运算符","permalink":"http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"Vue中动态添加路由的问题","slug":"Vue中动态添加路由的问题","date":"2020-01-06T01:52:42.000Z","updated":"2020-01-06T09:09:09.732Z","comments":true,"path":"2020/01/06/Vue中动态添加路由的问题/","link":"","permalink":"http://yoursite.com/2020/01/06/Vue%E4%B8%AD%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"起始前端的权限控制一直是一个可繁可简的问题，要想简单，直接写入所有路由，然后将每个路由的权限写入路由原信息中，然后在router.beforeEach中判断这个路由是否该用户的权限，进行reject()或者next()。这样做很简单，但是Vue提供了一个addRouter的api，用于动态注册路由，由此可以用这个api来根据用户角色进行动态路由注入。 问题动态注入路由后404问题一般我们将公共路由放置到路的初始化中，这其中就包括404页面，他的path一般是*,也就是匹配所有路由，因此Vue官方文档中提到： 当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: &#39;*&#39; } 通常用于客户端 404 错误。 所以我们一般将404放到静态路由的最后一个，但是当我们动态注入路由后，理论上来说，404的优先级应该比我动态注入的路由高，所以我第一使用动态注入时，所有页面跳转至404页面。开始以为是注入失败，后来将404页面删除就能够正常跳转了。 解决办法 所以我参照了element-ui-admin中的思路，没有使用*来匹配404页面，而是在router.beforeEach中，判断路由是否存在，手动跳转路由。 我在今天(2020-1-6)再次测试，发现Vue-router似乎对*进行了优化，即使将*的路由放到任意位置，包括首位，也会正确匹配路由，即当前所有路由中不存在时，才回去主动匹配*里有。当前使用的版本是：Vue(2.6.10)，Vue-router(3.1.3)，但是仅仅对*做了优化，其他通配符，比如/*并没有优化。 综合就是如果Vue-router版本够高，则可以使用*的方式来进行通配页面。 刷新路由消失的问题还有一个问题就是如果用户主动刷新浏览器，那么动态注入的路由就会生效，但是浏览器url并不会变，这个时候又会跳转至404。我这里采用的比较简答的方法就是在Vue实例初始化的时候进行重新注入。 在用户登录时将其用户标识信息存储至SessionStorage。 在Vue实例初始化时（第一次或刷新），首先应该是判断token，如果token失效，直接跳转至登录页。 如果token有效，再通过sessionStorage获取用户标识符，请求后端用户权限等级。再进行路由注入，并跳转至权限对应的页面。 因为刷新过程中整个页面的数据都会重新载入，所以我们必须使用一个持久化的容器，sessionStorage,localStorage,cookie都可以，但是我们不能将权限信息直接明文放到这些容器中，要么加密，要么只存储标识符，通过标识符再请求用户信息。 用户退出的问题使用router.addRouter的问题在于官方只提供了增加路由的api，并没有提供一个清除路由的api，这就导致如果同一个页面两个用户先后登录，那么就会出现路由重复注入，或者越级路由暴露的问题。经过查找资料，目前有两个主流的办法： 直接location.reload()刷新页面，重置整个Vue实例，路由当然也被重置。 优点 方便，一行代码解决问题。 缺点 如果页面应用过大，那么重新载入可能会花费一定的时间，会给用户不好的体验。 使用hack的方法，直接创建一个新的VueRouter，并将静态路由添加到新的路由中去，然后用新Router的matcher去替换就Router的matcher，这样相当于变相的清除了动态注入的路由。 优点 解决了上面刷新页面的问题。 缺点 官方没有提过使用该方法，所以可能会存在一定的问题，但是我发现element-ui-admin中也是使用的这个方法来实现路由清除，所以目前应该是不会有太大的问题。版本更新后就不一定了，也许后续官方就会推出清除路由的api。 附代码： 1234567891011121314151617181920//router.jsconst routes = [ /* 静态路由 */]const createRouter = () =&gt; &#123; return new VueRouter(&#123; routes &#125;);&#125;;const resetRouter = () =&gt; &#123; const newRouter = createRouter(); router &amp;&amp; (router.matcher = newRouter.matcher);&#125;;export &#123;resetRouter&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"动态路由","slug":"动态路由","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"}]},{"title":"Vue中的插槽与keep-alive","slug":"Vue中的插槽与keep-alive","date":"2020-01-05T15:01:42.000Z","updated":"2020-01-05T15:02:43.462Z","comments":true,"path":"2020/01/05/Vue中的插槽与keep-alive/","link":"","permalink":"http://yoursite.com/2020/01/05/Vue%E4%B8%AD%E7%9A%84%E6%8F%92%E6%A7%BD%E4%B8%8Ekeep-alive/","excerpt":"","text":"插槽初次真正接触插槽是在Elementui中的表格中在自定义列的内容时 12345678910111213&lt;el-table-column label&#x3D;&quot;姓名&quot; width&#x3D;&quot;180&quot;&gt; &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;&lt;el-popover trigger&#x3D;&quot;hover&quot; placement&#x3D;&quot;top&quot;&gt; &lt;p&gt;姓名: &#123;&#123; scope.row.name &#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;住址: &#123;&#123; scope.row.address &#125;&#125;&lt;&#x2F;p&gt; &lt;div slot&#x3D;&quot;reference&quot; class&#x3D;&quot;name-wrapper&quot;&gt; &lt;el-tag size&#x3D;&quot;medium&quot;&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;&#x2F;el-tag&gt; &lt;&#x2F;div&gt; &lt;&#x2F;el-popover&gt; &lt;&#x2F;template&gt;&lt;&#x2F;el-table-column&gt; 在列中插入一个template用来放置我们自定义的内容，并且可以通过slot-scope=&quot;scope&quot;中的scope来获取这一列的row信息。 仔细看了官方文档才明白，插槽slot是用来接收父组件在调用子组件时，在子组件标签内添加添加的内容，这个内容可以时文字，标签，或是其他组件。并且可以在slot上通过v-bind绑定值传递到父组件（说起来也算是子组件向父组件传值哦~）。可以预见，在el-table-column组件中，肯定存在一个slot来接受父组件的template: 123&lt;el-table-column&gt; &lt;slot v-bind:rowRata&#x3D;&quot;rowData&quot;&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;el-table-column&gt; 值得注意的是：scope-slot,slot这两个语法在2.6.0之后都被官方废除，但是并未移除。在3.0中会被移除，取而代之的是新的v-slot指令。具体用法如下： 插槽的作用域值得重视的是，插槽总是在父组件中渲染的，引用官方的一句话： 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 这句话中的“在”字，即我们能看到的。即使是插槽这样传递到子组件中元素。 所以，插槽总是能访问父组件的数据，而不能访问子组件的数组。但是有时我们又必须访问子组件的数据怎么办呢？这就用到了v-slot（slot-scope）属性。 官方称之为 作用域插槽对于默认插槽（即default），可以通过开始的代码形式，来获取子组件的值，前提是在子组件中使用 v-bind将其绑定到slot上。 123456&#x2F;&#x2F;父组件&lt;child&gt; &lt;template v-slot&#x3D;&quot;defaultPorps&quot;&gt; &#123;&#123;defaultPorps.user.name&#125;&#125; &lt;&#x2F;template&gt;&lt;child&gt; 123&#x2F;&#x2F;子组件&lt;slot v-bind:user &#x3D; &#123;&quot;name&quot;:&quot;tom&quot;&#125;&gt;&lt;&#x2F;slot&gt; 还有一点值得注意的是，Vue将整个slot的所有bind值封装为一个对象，所以我们使用v-bind绑定的值仅仅是该对象的一个属性（但是我们可以通过ES6的解构方法来直接拿到属性值） 具名插槽这个就很简单的了，一个子组件可能具有多个插槽，我们可以必须为止加上名字来区分，（如果不加，比如上面的例子中，v-slot = “xxx”全称应该是 v-slot:default=”xxx”，默认名字就是default），使用方法如下： 123456&#x2F;&#x2F;父组件中&lt;child&gt; &lt;template v-slot&#x3D;&quot;slot1&quot;&gt;对应插槽1&lt;&#x2F;template&gt; &lt;template v-slot&#x3D;&quot;slot1&quot;&gt;对应插槽2&lt;&#x2F;template&gt; &lt;template v-slot&#x3D;&quot;slot1&quot;&gt;对应插槽3&lt;&#x2F;template&gt;&lt;&#x2F;child&gt; 123456&#x2F;&#x2F;子组件中&lt;template&gt; &lt;slot name&#x3D;&quot;slot1&quot;&gt;&lt;&#x2F;slot&gt; &lt;slot name&#x3D;&quot;slot1&quot;&gt;&lt;&#x2F;slot&gt; &lt;slot name&#x3D;&quot;slot1&quot;&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;template&gt; 另外v-slot也可以缩写为#，就像v-on缩写为@，v-bind缩写为: keep-alive这个属性之前没有尝试过，但是最近遇到有个组件想要在来回切换时保持状态，既保持用户观看的内容，开始是想手动记录用户的状态，后来发现Vue官方提供了这个抽象组件，正好解决了问题， keep-alive基本用法是缓存某些组件的状态，我们从Vue的生命周期函数中可以发现，在组件失活时，都会触发beforeDestroy生命周期函数，但是如果我们将其包裹在keep-alive标签下，那么这些组件在失活时，并不会调用beforeDestroy方法，而是调用activated和deactivated` 这两个生命周期钩子函数将会被对应执行。将其缓存起来。 keep-alive组件有3个porp. include - 字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max - 数字。最多可以缓存多少组件实例。 基本用法123456789101112131415161718192021222324252627&#x2F;&#x2F;缓存所有的组件&lt;keep-alive&gt; &lt;component1&gt;&lt;&#x2F;component1&gt; &lt;component2&gt;&lt;&#x2F;component1&gt; &lt;component3&gt;&lt;&#x2F;component1&gt;&lt;&#x2F;keep-alive&gt;&#x2F;&#x2F;缓存特定组件&lt;keep-alive inlude&#x3D;&quot;component1&quot;&gt; &lt;component1&gt;&lt;&#x2F;component1&gt; &lt;component2&gt;&lt;&#x2F;component1&gt; &lt;component3&gt;&lt;&#x2F;component1&gt;&lt;&#x2F;keep-alive&gt;&#x2F;&#x2F;不缓存特定组件&lt;keep-alive exclude&#x3D;&quot;component2&quot;&gt; &lt;component1&gt;&lt;&#x2F;component1&gt; &lt;component2&gt;&lt;&#x2F;component1&gt; &lt;component3&gt;&lt;&#x2F;component1&gt;&lt;&#x2F;keep-alive&gt;&#x2F;&#x2F;规定最多缓存2个组件&lt;keep-alive max&#x3D;&quot;2&quot;&gt; &lt;component1&gt;&lt;&#x2F;component1&gt; &lt;component2&gt;&lt;&#x2F;component1&gt; &lt;component3&gt;&lt;&#x2F;component1&gt;&lt;&#x2F;keep-alive&gt; 当然，也可以配合Vue-router。来进行使用： 配合路由在使用Vue-router进行组件选择性渲染的时候，我们同样也可以使用keep-alive，因为&lt;router-view&gt;&lt;/router-view&gt;组件是一个抽象路由，并不会真正创建一个组件结构在整个文档结构中，所以keep-alive对其仍然有效。代码如下： 12345678910111213141516171819202122232425262728293031323334//router.jsimport Vue from 'vue'import Router from 'vue-router'import Home from './views/Home.vue'import Login from './views/Login.vue'import Register from \"./views/regisetr.vue\"Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'home', component: Home &#125;, &#123; path: '/about', name: 'about', componet: About &#125;, &#123; path: '/login', name: 'login', component: Login &#125;, &#123; path: '/register', name: 'register', component: Register &#125; ]&#125;) 12345678910 &lt;transition :duration&#x3D;&quot;500&quot; mode&#x3D;&quot;out-in&quot; enter-active-class&#x3D;&quot;animated bounceIn&quot; leave-active-class&#x3D;&quot;animated bounceOutDown&quot; &gt; &lt;keep-alive exclude&#x3D;&quot;Login,Register&quot; max&#x3D;2&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt;&lt;&#x2F;transition&gt; 上面的代码即表示，不缓存Login,Register组件，并且最多缓存2和组件。 *值得注意的是，当同时使用transiton组件与keep-alive组件时，transiton组件必须位于外层，很容易想明白，keep-alive组件对其内部的组件进行管控，如果将transiton组件放置到其内部，即使它是抽象组件，也会被被keep-alive组件管控，导致不正常**","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"插槽","slug":"插槽","permalink":"http://yoursite.com/tags/%E6%8F%92%E6%A7%BD/"},{"name":"keep-alive","slug":"keep-alive","permalink":"http://yoursite.com/tags/keep-alive/"}]},{"title":"Vue中的组件传值","slug":"Vue中的组件传值","date":"2020-01-05T10:05:01.000Z","updated":"2021-03-06T12:02:07.317Z","comments":true,"path":"2020/01/05/Vue中的组件传值/","link":"","permalink":"http://yoursite.com/2020/01/05/Vue%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/","excerpt":"","text":"父 =&gt; 子父组件向子组件传值比较简单，直接使用v-bind:key = val 1234&#x2F;&#x2F;父组件&lt;template&gt; &lt;child :name &#x3D; &quot;&#39;tom&#39;&quot; :age&#x3D;&quot;&#39;12&#39;&quot; &#x2F;&gt;&lt;&#x2F;template&gt; 12345678910&#x2F;&#x2F;子组件&lt;template&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125; &lt;div&gt;&lt;&#x2F;template&gt;&lt;sctipt&gt; props:[&quot;name&quot;,&quot;age&quot;]&lt;&#x2F;sctipt&gt; 这样在子组件中可以显示父组件给子组件传的值。 值得注意的是：在子组件中可以对父组件穿的值进行检验。 123456789101112131415161718192021222324252627282930&#x2F;&#x2F;子组件&lt;template&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125;----&#123;&#123;id&#125;&#125;----&#123;&#123;address&#125;&#125;---&#123;&#123;email&#125;&#125; &lt;div&gt;&lt;&#x2F;template&gt;&lt;sctipt&gt; props:&#123; &#x2F;&#x2F;验证为字符串 &quot;name&quot;:String, &#x2F;&#x2F;验证为数字 &quot;age&quot;:Number, &#x2F;&#x2F;验证为字符串或者数组 &quot;id&quot;:[String,Number], &#x2F;&#x2F;验证为必须传递的字段，并且默认值为北京 &quot;address&quot;:&#123; required:true, default:function()&#123; return &quot;北京&quot; &#125; &#125;, &#x2F;&#x2F;进行高级验证 &quot;email&quot;:&#123; validator: function(val)&#123; return &#x2F;^([a-zA-Z]|[0-9])(\\w|\\-)+@[a-zA-Z0-9]+\\.([a-zA-Z]&#123;2,4&#125;)$&#x2F;.test(val) &#125; &#125; &#125;&lt;&#x2F;sctipt&gt; 子 =&gt; 父一般不推荐子组件向父组件传值，即父 =&gt; 子的单向数据流会使整个项目更加容易维护。否则无法维护项目的整体性，组件内的状态可能会发生不在预期之内的改变。 但有时又必须通过子组件来改变父组件的值，则Vue官方提供了子组件与父组件通信的方法。借用这个通信的方法可以顺势进行传值。 12345678910111213141516171819202122232425&#x2F;&#x2F;父组件&lt;template&gt; &lt;!-- 通过组件事件进行传值 --&gt; &lt;child @getData &#x3D; getData&#x2F;&gt; &#123;&#123;val&#125;&#125;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; val:&quot;父组件的值&quot; &#125; &#125;, methods:&#123; getData(val)&#123; this.val &#x3D; val; &#125; &#125;, mounted()&#123; &#x2F;&#x2F;或者直接挂载在vue实例上 this.$on(&#39;getData&#39;, this.) &#125;&#125;&lt;&#x2F;script&gt; 123456789101112131415161718192021&#x2F;&#x2F;子组件&lt;template&gt; &lt;button @click&#x3D;&quot;sendData&quot;&gt; 向父组件传值 &lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; val:&quot;子组件的值&quot; &#125; &#125;, methods:&#123; sendData(val)&#123; this.$emit(&quot;getData&quot;,this.val); &#125; &#125;&#125;&lt;&#x2F;script&gt; 即利用v-on为子组件 添加一个自定义时间，并将父组件的特定方法传入这个监听事件。 在子组件中调用this.$emit(&#39;funcName&#39;,args...)来调用父组件的方法，并利用参数将值传入至父组件。 兄弟组件兄弟组件或者跨多级组件则可以使用vuex来进行数组的传输。具体就不在这里讨论vuex的用法。 跨级组件通信 Vuex $attrs、$listeners Provide、inject $attrs、$listenersvm.$attrs 2.4.0 新增 类型：{ [key: string]: string } 只读 详细： 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。 vm.$listeners 2.4.0 新增 类型：{ [key: string]: Function | Array&lt;Function&gt; } 只读 详细： 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。 示例123456789101112131415161718192021222324252627282930 &lt;template&gt; &lt;div class&#x3D;&quot;test&quot;&gt; &lt;child v-bind&#x3D;&quot;&#123;name, sex, age&#125;&quot; v-on&#x3D;&quot;&#123;changeName,changeAge&#125;&quot;&gt;&lt;&#x2F;child&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import child from &#39;.&#x2F;child&#39;export default &#123; data() &#123; return &#123; name: &#39;张三&#39;, sex: &#39;男&#39;, age: 11, &#125; &#125;, components: &#123; child &#125;, methods: &#123; changeName(name) &#123; this.name &#x3D; name &#125;, changeAge(age) &#123; this.age &#x3D; age &#125; &#125;&#125;&lt;&#x2F;script&gt; 子组件child.vue 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class&#x3D;&quot;child&quot;&gt; child组件的$attrs &#123;&#123;$attrs&#125;&#125; &lt;child-child v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot; @showAttrs&#x3D;&quot;showAttrs&quot;&gt;&lt;&#x2F;child-child&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import childChild from &#39;.&#x2F;child-child&#39;export default &#123; name: &quot;child&quot;, props: [&#39;name&#39;], inheritAttrs: false, created() &#123; console.log(&#39;child&#39;, this.$listeners) &#125;, components: &#123; childChild &#125;, methods: &#123; showAttrs() &#123; console.log(this.$attrs) &#125; &#125;&#125;&lt;&#x2F;script&gt; 孙子组件：child-child.vue 123456789101112131415&lt;template&gt; &lt;div class&#x3D;&quot;child-child&quot;&gt; child-child组件的$attrs &#123;&#123;$attrs&#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;child-child&quot;, inheritAttrs: false, created() &#123; console.log(&#39;child-child&#39;,this.$listeners) &#125;&#125;&lt;&#x2F;script&gt; 利用$attrs、$listeners可以实现层级传递，将跨级组件的值传递下去。 Provide、injectprovide / inject 2.2.0 新增 类型： provide：Object | () =&gt; Object inject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } 详细： provide 和 inject 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是： 一个字符串数组，或 一个对象，对象的 key 是本地的绑定名，value 是： 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或 一个对象，该对象的： from property 是在可用的注入内容中搜索用的 key (字符串或 Symbol) default property 是降级情况下使用的 value 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。 示例12345678910111213141516171819202122232425// 父级组件提供 'foo'var Provider = &#123; provide: &#123; foo: 'bar' &#125;, // ...&#125;// 子组件注入 'foo'var Child = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; \"bar\" &#125; // ...&#125;//孙组件注入var grandson = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; \"bar\" &#125; // ...&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"组件传值","slug":"组件传值","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"}]},{"title":"Vue中异步请求更新data导致数据变为非响应式的问题","slug":"Vue中异步请求更新data导致数据变为非响应式的问题","date":"2020-01-05T04:22:40.000Z","updated":"2020-01-05T07:27:21.749Z","comments":true,"path":"2020/01/05/Vue中异步请求更新data导致数据变为非响应式的问题/","link":"","permalink":"http://yoursite.com/2020/01/05/Vue%E4%B8%AD%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9B%B4%E6%96%B0data%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E5%8F%98%E4%B8%BA%E9%9D%9E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题最近在项目遇到一个棘手的问题，看了1天才发现是异步与Vue的数据更新机制导致了结果与预期不一致。 最开始的代码流程是这样： 通过一个请求拿到一组数据data1，包括下一个请求的关键字 在第一个请求的回掉函数中使用for循环利用上一个数组的关键字发送多个子请求得到对应的datan，并在每个子请求的回调中对data1和datan进行对比，然后给data1添加一个字段key 在第一个请求的回调中把修改后的data1赋给Vue实例的data中 产生的问题在Vue实例中的data1对象中，原来的数据都是响应式的，但是我后来添加的数据并不是响应式的，导致DOM不更新。 解决过程产生问题后我先后大概经过了3次修改来解决这个问题： 思路一：data转换为响应式的时间首先我从响应式这个角度去分析，Vue是在哪个生命周期函数内将data挂载到Vue实例中的(因该是在beforeCreate与created之间)，而我做这些操作是在mounted，所以此时data因该已经被挂载到了Vue实例中，后来我又在思考JS中存在变量提升，是不是Vue中也存在，即是否在mounted中存在譬如this.xxx = yyy这样的语句会被提升到其他语句之前执行，yyy的内存地址提前就会被写入到this.xxx的位置，然后在这个内存地址被赋值时就将其变为响应式，所以第一次data1被赋值为一个数组时他是响应式的，但是后面对这个内存地址的变量进行的操作是为数组内的对象进行赋值this.data1[i].key = val，这样的赋值是无法被Vue探测到的，所以其后添加的属性无法变为响应式。这样子似乎一切都说的通，但是关键是这种变量提升这个东西我之前从未在Vue中遇到过，我查阅资料也发现根本不存在这种机制。于是这个说法被PASS。 不过这个过程中我也复习了一下生命周期函数和Vue中数组对象的处理： Vue生命周期引用官方的一张图： 值得注意的是：data，methods等都是在beforeCreated与created之间进行的。经常使用的mounted已经是在模板已经编译完成之后了。 Vue中对数组和对象的处理对于动态更新DOM最基本的原理是定义一个变量的getter和setter，在其中触发更新DOM操作，对于数组，我们整个赋值，我们可以使用getter和setter监听，但是如果我们操作数组内部的元素，比如arr[1] = 0，这样的操作我们是无法监听到的，因此在Vue中，如果这样给data赋值，这个值并不会变为响应式，而是一个普通的值。具体有 数组 通过索引去修改数组中的值，arr[i] = val 直接修改数组的长度，arr.length = n 对象 给对象添加属性（包括data根节点，比如没有在data中初始化某个值，在后续直接使用this.data1 = {}，这样data1无法变为响应式，dev模式下console会报错） 删除对象属性，（包括data根节点） 对于以上的问题，Vue提供了vm.$set这个api来解决。 对于数组的第一个问题，可以使用以下方式来解决： vm.$set(vm.data1,index,val) 对于数组的第二个问题，可以使用数组的方法来解决： vm.data1.splice(3) //data1会被切割为0-3项 原因是Vue在内部也修改了Array原型链上的方法，使其能够被Vue监听到，包括： push() pop() shift() unshift() splice() sort() reverse() 思路二：请求异步的问题这一次我似乎意识到了可能是异步的问题，因为之前玩canvas时，也是一直结果达不到预期，结果是img标签的onload事件是一个异步事件，导致结果不对。再仔细看这次的代码，可以发现，在第一次请求回调内部，由于接下来的子请求又是异步事件，所以直接执行了最后的this.data1 = data1。在子请求回掉函数执行时，data1已经被挂载到vm.data中，此时再对其进行添加属性处理，相当于是上面的对象添加属性的问题。所以必然是非响应式的。于是我this.data1 = data1放到子请求的回调中，每接受一次回调执行一次，虽然感觉这样很消耗性能。 但是结果是，data1数组中只有一个值的属性变为了响应式，其他的数组值仍然是非响应的。。。至少结果逼近真相了。 思路三：Vue对于data赋值的性能优化在Vue中，有一个异步更新队列，在Vue检测到data的值改变时，会将其写入异步更新队列中，在下一个事件循环中去进行DOM跟新等等。并且在这个队列中，会对数据写入进行优化，比如this.data1原来等于1,接下来执行了两句赋值，this.data1 = 3;this.data1 = 1;并且这两句在同一个tick（事件循环队列）中，那么Vue就不会对data1进行操作了。 那么这里极可能是在极短的时间内对data1进行了两次赋值，Vue将这两次操作优化，第一次是整个赋值，第二个则只对修改的部分进行了变更，但是前面又说道，Vue没办法探测数据内容或对象属性的添加操作。所以第一个是响应式的，而第二个则不是响应式的。 所以唯一的解决办法就是只进行一次data1的根赋值，所以我想到了 axios.all这个api，它是在所有请求完成之后返回并进行回调函数。在该回调函数中进行数据处理，再直接将data1赋给vm实例上。 成功解决 总结还是不太够仔细，异步这样的问题不能立即看出来，导致前面走了很大的弯，还好后面分析过程比较正确，找到了我呢提所在。不过也好，重温了一下，生命周期，Vue对数组和对象的处理等等。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"},{"name":"响应式数据","slug":"响应式数据","permalink":"http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE/"}]},{"title":"2019年的我，21岁的人生","slug":"2019年的我，21岁的人生","date":"2020-01-04T02:59:17.000Z","updated":"2020-01-08T15:38:37.033Z","comments":true,"path":"2020/01/04/2019年的我，21岁的人生/","link":"","permalink":"http://yoursite.com/2020/01/04/2019%E5%B9%B4%E7%9A%84%E6%88%91%EF%BC%8C21%E5%B2%81%E7%9A%84%E4%BA%BA%E7%94%9F/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+xhrtEbZtpfU7eONN5uOcBCoQ1sdu3/DQEPRqaQr9Ft2U7IFix2OxnHj6QjJ56TbGOxSK8LVRIlFXKY8HpqmyoTpy60usMYPfchBWVLxTH2Pw3hXdemmcHLjFtxyGu+2H6nhlwA8bw6GFAKXxDDnLvzjWAFnzzHIQ3C7BStkGPJ1OiHNZtbncoyNtWPpaxQJ0vdtKaJsPzLqHdIR+kq/rYSKFIwshTH6iDtKw7iHTOrcK1bwkMWWopfIAKfzEyOunWHcaYcAiowVz56e1GhOm4hng1ZNkXHE1xb/qNxVhScX6tkGKFFzfkJS1VDo2NM7fcaHjdXD7OWlE9Zk238BMHbajlKlht5meyAYNmENZSO+CNZFxgihkwJrDjnMgeVpbqc8Tlx1dr5VLhWNFiiOBgvXKv2Qh4H0aYdzo8Qt29TNY2PQ7YO4VSApYJEJBt5KopfDNmACDNq8X28Y8r07xDtlM+DL0X0NOWlT0j1ACODzpO2bsgsez5Vkm9rcAnJHDFt/Ra3qyjmHjxVVzdvsiotXQByrwJVBaF1KvnqVgbhMJfT0TfS2KK5VICm9oMZE34KAiUftPip8Bp98dYrvYDcmCULW7cIZb1mzhc/2pG2H3M4szziw67sqdHvA1obFM0Nyb2wIakam4CK/I65/pw8JgBEGxtA7DU1oi6WROD9/7pDHM9rYIaMZjORU+aKiUOLAhAfHjbNDNPSQOtSzPnAtRuwyr4EyI/AapQv/FzDi3XjauoWmlJ6ErhYBoDitshlVThcE5PIXAlT+gYdkpYET0/b6raSDaKcaU/cleAct/Wj2cv5npCs6/k74VYp8YApTelU0a7PPCRllJNZRahkFY9J3ACCX00hvOC4DVGT0Urkb4uDFl+vdTsjcirBWSTnuxhk734VDiWFcsNlVvnPYS9BauEZyjBzbaJ2Id06Lp9HocmpQqv3BPwzQuJOy27yxyvWriAZla/NZEtVwjI6xMi6emgE1EdcPSdtA0hdYdqNquD8tKEWfZwDPdkFDwTExXhhM+VWKaFfPY3fvNlKbTDC8CFCtyEjRiHW3Jdp8s6JZOB3KyEbC+/8GCriy5k6t0sg6NY3bMeQt2NJ9/uD/FG7Y3acE6I4/hqOVeLI6NgfftLmL1hbr0t+3WvXM22shkT5lfs+WBIekmoyZF1tpWabN6sYUFFxLvlOukOfrVQa+VROFk7cYdV8MxXk0r3jb+LRfDKdj5GrQJ1ZUuubAwU3IJvx4+XF5RUuyoV5lJNmmepkyuAzwHivTZUWtFxNCIxpjTtL5yra82wBlckakoSwI3zLsKdN6wkH118Bkvvb4LfhxDAkaudcuJOhbmhL4+E/PhWQXUc/Mcy5M8z/TET/m6fiCUwC/VLdck2sHuV0osvq2CJq4YbscDUojrJBzSOnbfHhy3ARmDlBGdv9CaAtMph7AVlEJxnD5E2GGRni/pJmQmufbRJqD//JC/l092qIWEH+6gnE+Brzv0MiltFr9VvZqgYeWTpOtyvHXv7zzW92G73Qba1Ny6GKX6DLY4wF4sdfqEWFNr4e6ZoaKMzbTNA+HUbgDk0mlCQjMT4J9lNPY6XieGiWvOgGlK6E5mtLrSpbCe7rtza3HCb1sAA2d1dyE54kmWhMtQ5aPWafb6Smiha/qVZgwIUHjng91ECOPiqrrgLbigtyd/15RpYWftuBOYWEBe85wb1tYInXZPnnl7tUR1mcY+Ihvb+q/5ZsAeXN9NoyQ5H4ri1YuF16HlT7GFlI3tcwFsukoumQic2u6gjbHicdR+tT74JA/PBUdkTguwsXGna2xjxCcQa6rLPnQS6U0y0MZtv1zaE4hPNRu1tvJRPdWzEJ+h4wS2KXJ3QMAEcLh2VMWLixgmIS9HHMV7ANDhcpnSs9Zl3/J5QoHas+dS9SoF7tvUX5YYnFBOkvSeyqqT6Ti07bpdkAbrrhFmhf0rn3wbbzSexjHKii26FVWM+RxdU/22YF9wjRUc1X8WgxLTch1IG3qIcQZfvMAMHz2Xu3WRsRzn5ekRULxsHj8qPvh9J/2xnxM8kQ05AYNIGtVm8sWWVArPZMEQsv+wWgUEgJNb8LhqaLARx0QpaPkTPSwnvchpBfSA2KeFqCc3pu6xxCRc6PK8UsNRF9gOI+yVZBWMi/ZCjLv/x8UP6SG/aXVjb8s9F9IGKRib/zVQdgTZKH9s9TE6ARNOw8h+aVWQZimSu8bEBEX+aOXYVICsynen42gFSdLcM/JCUqX6KnPgckH7m5Vydq/SpV4v+yQxsOoZ+N1dzndn3VICVmKxRQVz1iue3szJWrJ2JIJN9sDiNMchR7R/slR9ymrf0a2B7aEKOW2SzdQzMhbZtRmQoDqlAFK58Slntbwx8Aq2b5kWBzunA+53L+W2qNadn2J1mdPfKB0qYjZNL3FODUTpgddPiwphJtgWlmjm44QzGzaV7kSFunH/4K+2RnVNUi7tGFQovtvaMOVyr3Nz/JR4X+1svFoXPX0oDgN1rd/9B+IpP47wSNf/Pu1woGdikJVz7Q2SHKOqVeDqh1OfT2cY7TXaxtkboAdvYlL5xrcNPcQPpdvbTJKpvm1jxlvgciBmfnfT3NagJBjYH4yTeUqJnRzITTT4vACbigayN3x6FUavmwWHDHFAil1zk3kQfn5Rv8DQyMmrc7zq6ZqE/mDOvsN4WzmYf/gR2owTb5/nnEtYaBOrx2UjcUSZby2ktaqIIP0HxXQmNTmRPb8HhktXBXcS6o4vvAfNytIRlLUgYZgMpPxi7DIM5iDsP2dBtxr4k+hPnyzz0ZVZ8ZLdK8X9RjittJybKjmv7RU0ARD/9sdO0QkFQr6fKGYqu2e/gHEAoSwSSODAgJP9H5UIWnxykVzHekzXWAmt4gC4U7AS8tKjRBit2jA166dUE7K4thpmDI+Z9SLZA4trfZ/dMVL66GLiCpZfVgWrUnCug4NhPxpoCW4NRi/pOO4kZige754fYHrlBaihvnk/xg64l6Dz8t7scCAWkIUJE+19El0a9v+z49TxnQ2fQWuAi4Amy7lZxbkevbANWJl3mASip2kjTScEXoULaJUvUmyygC9FnTZNuKSCa/mqXWsxDFxUmaPCCgHKt3Z8XM9A/fIsykAUsd4dQsWDoFVLtfMB7e2ZdBxqqLEteOkebbOAi8oAhxEa57cJ9EPc6f2Ssvhzty00y3SpDEOwpMmf2TNsrSEwhvftqKJCpZqnGt64kfpon9QSdBpx08XnupmcoWwXmckxJkCIHPY8LGbJEgbVefHgyF2KgdblHD+TLWMz/Hk/lbb7F8EPaqsD01mlth5Y4F/SQqeKdbFZnuCQ9dvy6JbamHQfwtOBuU89wH/5sthIDW7uLZ8eYXkF6PA4NRwFG/+qsU2OB9/pLzBiY2t3hAGra8kpfvpzuwhMVSSjZmDzh19FasMh/i52HgG/Ak4eV560uXTux7C8YvavnX8a4TXGPGeH/PnxsLzi+nGW//TLpt1qVAYLy7ImWwjelpitJlyCWySBphYg0HoSptO1XNY6ZV99WrOwfHKOepG906L0Y2i19VM0gWUwX1UAk3MmtmOXWpiGyeOJj0rPdSXAYicqEWN3WrtZ5o3oWj4/9SKhX2Gvh6sq9mlr0q6VzL3wUlgxAE717d6WeH32bLWeo+koo9y8PJX8JFEGTDRuZ1sQXaBfvR1m+janNtuDHlF/xjn5WxODQj7ZjUX8ZwIVpvKwzWAVDvcx3zfSS7O9jVSoYsTwR14kwYWNK5icDxydZKLHHYLhkZBq7skI8oapE7+g81zmk0gTsOO4BSf5MdS/xGOHD01xUwnwLx39axxYHDZVRNz46iJHhX2xg019RtlEIG71DU+VNHzIVwtsJjZptV192dZRFm/3lPfEWIUi7emkHEc8cmvSDUdAtVIyU4NzrJZG33z6gmQDOIQJQRH3X3LsNyubp9xOPTmW3bh8DITi7ABga+rjtIxxCiKnJshu0ukaEAakaLOGJCvfhm/HZzYv/TtY3vYQHOGmm62MgEMfbkSLS2pIjFUePioPNPhoDpE5IOkeIRj34YEIaPt84HG/0t8uJWTBp/ODmNFx1NmIhU4d0u47Zt16coQ7p5DGqdp9SQaNGJU6/TVAn2hNEs4bQuZIN9c2mPOkkq+TbI64oyNNe7wPEgOt4iJZdPn9LxNK9Wfh5Mi9qKzF5OKzHCQsoynshcBTGXpqQyA7Gu5EfEYB/SO9C4EuFGccnyoQH82iEwCWj4QElUuQUA258ku79AZJDrADt60GDpEamj1rbo36GlTgg0uZvMgQckrKgExWWDxGbab1QRklZrkuz1W+OxABNwpEpUxPZWwKaWI1hzmhhkEvRlVDS+RyvHZmg+iny+h2OAcTtLGxpE2PywC6MqJFV1stp0D8d/JDXSfRcHoEMgobI4WgT7yqurchbOFM2QZ+x55hH7A/UQ2kf23YMsVgMExkqVjh8VMMunUJDH1mGHWojxVfXp3bxRDMEFZF1LvSmZDCRahMl8xtGQfxxZcMkQJgowh5HCzvKQnbeiqZLbStsu3gQHozqjMk0CM1+FTjxjKQUAC6yadicYdSEh0/NQly8RmmUaXXSRuzp3JNkol0TLwUcSoD8neWTx7Zs+EJrZTZjBaNQk6V+RSa2o5nKPKO29fCjkAiC4vQqrO5Dv/dTTwPuNN8UrQF+I5Ate5BdnJgx1BEHmeQOGV5Jop/PdCshlpGY1dvkmuNBUy7tTGXkXvKVUQrPT07Be2iFZd+8iaEeMhCP5InTKDuDxRtbqGn6CkSzBbeFKwqTnlANzwFHrCk+fHsaVc4dJmxwS84GzxsVbJ1L9afOF6RfaWaLCImRiSGqJiukjnu9b/7uRFdIB/0bILO99N1iZ0KdkfxR5tnlAQZB5FGC4F4rLygixwVpKwvkFSQ3DGl/qP2/l5+nIKXODNxcqQM8WWNNdTRquDedvWL6AYk10PS1WE9vlP3RQP4Df6EtQeO5p0OyxOB3IDeB4dNHHQyJ1DjRhIbAn5nGWbWlbIunqRqeADEzxhvX8MSFbb7RN9gCdKZFAb9JjpQLnjJLD50157BpbooXCR7DkD+KFxq6dnBLWPm3qBkLKiUhQwd5hJ10FSuQ/taxL0fRcXXs8BZ4b6CkNvGN7FiyQ9YZ+fjHMgugDdsOb0zXYZ4cING3uetup9QDoMRPSKLsw4qxR5AgxY7pdqgn4ozqGmUz2XchrdyVlXwY5M6P+f1bV+fJNS0tkt8aiXmyYBnye/9z3eJniT1v7joGmOizap7CnWdib2ZbPwpQ1hlJxH9bbntiT59X6YYugS/0w+O6QcjvC5DDJQ1RGnyFY4l+ZQs4NqhNHiN5qM/qgRSIWeyLeWIdqw/yce4O6wIJpiyHh2d2cn/2tQxMkAU3RZIkGLs5tAqW5sMykyfUvDHvuSVQNgX5ZfuuPB5DAYu07xsIf50lcR731dDMwNYohs9Y3x26FPZzakNa1JmBE4WBpLrHJ7L9T9fiuf6XM2hw4Lzv7LiNMMjLmyJpjSXHuDw0b07FBSZBCFZq9eDj0CH5M1hNwb2qAWZMhmHRrdG+faqxGChdP8XxboFreoVMWar7uViFEXcPDnvF9A32SahqD5+lwBx1b743zYApuqlQKGegzJw0JNgsoft9pTvqI8zuBySba3W1WFXzIoN15oYduShxeqncXUPM5d4cH7C3bRlbgeu+jsd4IrjEkn41e4VxNvryaB9p1QC/UXnhCGyZ4EXtgDcE89XtYyhkeVnA1mj8KSPDm5Nim623Ofv9Pmzhy6Vhdb5t20BinfcawT9K/dxFvYa1awJwGZYK6R2DbsoZRk09uScAh/GoFSQQXYLvKGg1y1xvAPKPEUjycnI36sNYe5lGXLO9v9AhCTcd7t6wQPpFMONvkvIjV/6jh6p9/lXlXdvH9tG0jo4nU78igGrCKwRNt26lLkDmlrWV6Isy4Mg0Nb2y67FdBmpW8MeDKtM7UwLJIJkmAA8b9iObNvJeHDsdydsewT3tFGKtwI3hn8wGASK/PoVtp8r27Ki3wr4xGOYaiNjOXFt74d8Wsf1hFN6d9gsS/aHPOVjPPOSXMXDmHGXYMOZp/D9Xh7tKOj8xHCaAEeRTOxzVbVMPEXPrepPbHPsLibnEPTMakChbhIIAHMfas/ie7ft04iJ4ua7NuRHrchXKvjSF/We3+kpReifUVXKwr7VSubkYtsSQUoPrMXnZNEmafL4QIhZYzxGYVPwZz13z+/kvT/ys2i2O0xT3I2oWJXtFGtz++K00wR0/8lysjXRYH4chQSUIaPF7saBH4ddchyZQvqaJPY0CK0izwNtaqhjVH3A8+O421f18iukEQMelYVz3LZ7aKIE/deoJ3U5muGWwsE3ZLa+JCVyCJ0dVw7cxkiGP7jztMtv3iLjc7LIfTlONoUuJVJdaS9Eh9Hw37IOTbjDbhgW4MxDcK/eOZeNqkSct8BqoCwiqtK7iA6J/hWMXzgv8+fer9w1fO6yDqRIH2NFQs0tEwyyaNOwkVnqE6Dg3FJyDXN8itwmF7MXUhJdmxY2eHbitxbq8/8myGtIkuxKsWGpEQ0nSSMSgiw/2f5WIHQizOkjyLhQ89Rup44PhzrYAPSREOz94o4S1rTZ8akO94ciedWWKs9CoyDulY5DCv6RRWVDs0R1vlR7jcsE/vmq0hh9bb5kpQAqiVcBtt55He61gO5ToWZyp8Kq+V/6fkr1qL546at2xur73/M7KHHhrC2UbgJony3dpGlQZrGLv2jTcgFCPaewyFow/NzcHPgE89gf11AoeCIBuyoKHNAc3psSY9c8qyqZTWVEMZ2GvyESeLpyt0LYtnDy4UsACIfJa1xXxVHw5nFk5hqM8/fSM4GQkeNvWRdXpWANe7UbmjyEyVvmCmHJxKyUeV9ZcZiRutMC67iccSUo5dvtfQ/n32a0NbV9810w5McXmgzylfV9bLFUrgLwPeckTOWH7DR3xfA++k1oGtLI0l9rsSUacLuad5lOGO00W+trV7yC95W8TlySgnrqzsRgAK/81ZQz7gnuAcPiLAIbkNraqwT8D+WnTizqItnFEtS4XJKa4DpnF2VgO/PIkCLegsWylJpFvJILGwjiVsFD/61iX7d7i3Y/IiUw14BmkBgLXYAzdR593wPkWmlufoQIkIKIp5rC7BfWSck4j+A5M4Hbnqy4MfZeplJmQZWtgTP+G+7MluSD5fABWy3mlMwhcUIUiNQXXpa9UjQC8WZM+zlN1C2XuhQJwfCo92g0rLT2Ods5Hv0D7vtKgcfyOH9z/FMyvIyvJdOsT6MR/1lPtvXZ9inSSPoPBL+f5g2+EbG0JHvGWOAxUezhUR9WwAN9aEl3UEEev8Mjcin4DVP/Z4mwl3ScqgAEuuSWvq5BhF8UK/7le8GEB4Rlw+JlI1sfKN+SA4f0SD/QFsBH7YH6qsPf+AMiyW5xFcU9liHBuZ3iiW382LHxczJ54dT4/6N81wJ8af+4K3k0tM4szBlPIQ7Mx7DqR5xsmpTeTnlTbPTO3YAplpw1UYHzXfBqVnf+RamP/KL64zjFDlIA5ZhkB1SpDlJ0BToqdWCWmrjqM3cIFHaEDZb9+ubOTFOGn2JpD77C6qfdsSSKGe5cVpYff6xWR1vKlj92p4XqM0g0AOc+5ktWe6NJWYglYtA7OdhPy8+BCZ3KUJdoHJ/ePidaUpBsf6CYPQ/Wpkmzq2Fq82kza2E7cEA96gGj/ftSv7+BfE3TUPVh7UD5+ZIr47uaNPd+c9E76eHvSRoYhSJusPBQbFaZZLSumti+t4EdTpBRH0Ze1X2aufxPFNqOq2ilOG3ZPd2ywl65ozcU5tv+gMc/pOgeTS6qwS0Gp2t59vK1WokcEI0wKNZWVx2FMxfmroBV3/DRQ+qEpKx8NXAQzIkNnx0JvRnGn4w/Now2MUo3ftag/H4Guf4NlKWnA0Rz36xUXapLFd2893+wD0dFxSPrcUAQXoDSTqEov0DR6RcyLCVMF5JwR/BH9CQYKYBOnwNGO+mizUmeGZTyPSmrEtAdF9xTvpzokfNl9cBvf6pU+nrlFNbMzqvf4KEvvaulUrPXSjGzo0U9RblE8VgIMZ+hK8sDWVhAH6nCQS93Xya5CthoPc3y/BG9sCjl5kyqqCu/tZ+OTXVvg/GNn5hDzz+Ho+F8b51E7oozC1D6OX0rVU4rsV5j9jcfg9PeDLNzQpa4YBOyPQlAJlIqEs/vaD47unXmMyZ5F3spBDo9cIkr2PwXpinONbauHKObWWNyp8DssKAWxLFyavUaM28t6FRzZeB4Jx+9xDRBTh+Kni1iHn4y/WTFFyr6otIWGb+WBvhCqxU7EMAvUB3hSYb632wzyxjDrCGdOuAMJFDFANfS+cqZbC/VaCfyPGam9iHJlbJDr6j10P+vWnrNBw5ZhUOFv17Kh6k/lMqM6+TGUSP4HB++x62K8gono6iHAR+yPldEKX1l8iTEaY3ICLfqBhT98nMo2DQ5m8X3ApwU/tnljFZWppKfUWNYH1a5lIUO7QAiuzlkLYfl+9Fw+PHRGuvDkn689Ze9taJ3vPdht09CpXmmItbw+wsQCODB7WpvMycmzckWe0fKN6Q2FS4qnJNzakyiPzle3QRzIzsTtHqWrJhbitTiyRejAyJmCOQjxFqiCv1mxiVMj7iElhNe4JYKYyUruKqYGCZxudVdsYj5UogA/7jNmTcK3cufeZg8omT7phOwNsn3TRVnmTZhwFbIUr0w59VQ9UN+yMnJqjKGC296Nt4qi7X3F+8OK660Xy5NkyfIBZVaEV9nKeSMln4wIrX7DWYVjvuilFaNIuhS4pylOfHU8oza+FkO3JGio1aEpOOQzM8rhDSLpUdg4NTlKzgYhTSM8XvqzC2ZMKGSawGd/JmtBkKyJlsF8w9GhDLbCLIINDwPFHmgjFN7F0zFSdJ3EuEvkOruL/4P3ZyqHfWUDcY7R25yWUOELOY3dXw7E3nBTsLc6yrc6SDp/2qAcopVsaT4I8kWhjeogreoJRZ4IT7wRsSXCu/v9v931apKOW8ZcjOaMcE/IQSosUY6W5fS/Sj+j140vw9SVEf9VhMO5R+R/zozYyN5f/nnqv//kHe8TQfOTelERXEUcETy/FdwtiuKn0aTEnlGjXY8fzlxHOyp/Bfel5vDLSQiKiyIxuqyYeKqTTs+CfrCOZCQ6XkN0l+3KSGn5aASN+C6UKpP7hbwUQFrHp9+G4YbRRzfwtEKTQbZbDHOX2KCXHMgSbnOXWGEspRlFD1ioAjPsPYawmEa0YgBrfTK1FvidCMnZcUAJxH4UbS5gMWir6+Zfffy9fHZvtPfZqPeuSXwQkyIM++4D9F0qB+/mDO0burCl1iuPe2nLfihnoDwt5zzrcsHwI/mgY7t3GXOapI5JGBurYIO9yEWmruOdBpeJ9L0Mu1H8xtRZC7T+Eyaya9+1dOXZ/mr5CQN+I3+6xMYtbI18UjNj27LlOuAPNnKw1IifgV4xn731rdwYg7XcKsgu5yY0ZUajIH31yia/nmNOnQhz8SKGYK1ayLM4AhAic32kqQOsQCesrHO24rBrz9DMqRV8CckLry/1tin2zLosThOlKdNUxXaptxXvZqqaCGCUOKq5ylkPgDFvvc90sMTijBVz47aXYs1XLVDkYBtb50qmSV+7JjXVerxn3m+L7KfXUckX39zR1S8l8BJ38MNQbx1xd1a+JUQzAtEiUxTY8dJnjHVpAHywYtrmmYKRnr75IWmKSS/pFUeAqt4uQ5ckLJQyPM3t6YM6b5u0o6TlepbFwau7cNHZNc+6c9SzfIIIan94/7uuKeKQmEWs/T98VcsGGzNo+D0s52gSl2coKDOiyT8HhQe0Km4vKqH10tkFu56sCegOKjVgipGEMtqOxitSBjMGvt5IVL/fyCLdvd8Dz8oCzpdoQZ09J/6dFgBhWoJrKUaL5IxOBwDz9QaAcy96ynnqLSKUn2TXy/7MPT1l0nY9nL5+q1aL19Iq9wKgL4JpEbBR7CFh+XO1xBQisrEKxyRPhjOiRdO3O79/3yk5yda1hXQqLYYzfcTkls7t0GkS5vMMgy9ehk5UdXmBu9pw3YduVpTF1WLP5liwdlGO24207iHyZ3YecnEk82lAM2iqTJti0oLdU8JDaZFuk++n761Tt6oQuIDJFj9h6hXbR8MUwU+q8ykqO7bAhkO5f83WOEEXHE0X+g1WKwg70PGpMcZWEf5xkkOsQdo1i2QSHypZmRKCSr7pxzR+E1KsjV44buTDmE1ZesGx+t6DfA75QT2yUlaGpQ1hQvE3asjZVxS2+HhtVROOo/uKesVw/8SOrN0vW6/iRGri+Vp/EacCtmtyLWe0ZXhtrvoJME+6atrYT2joqbG9hAxDKeRgXvLDibkAGqJuYsqri3SsRq+vpKSwKaWgycsW15tJVXIp8gkX3WD6YvlfMIXCJndW9cLP8k+9twY6iSwrpbA33N8Tp9GloVfU8JivL5/XWoAtT9FghnCBkdvBkw/SDwy3kWCnJD1N+uJVDYGlrOo0t4VxfjQeuiSV1xw84dABF32y9rS1d1Khqfbb/V9AhX3pHWRSLI+53pHXHsXDT6Uyw0yP4qUzMIgJ3wdpgCAgUdNRJ4rnm9KakZ+vjfW+hf/yVvxqXXthzYHKmmuIDdaDJRt8Ne1XbnZd58Zupq25P3JdsW3JxE1Tmr4nMW7AP5b7HJ4mU8qXePXj7fYC7HVC+nrQXx+RDnYjwOoe5N4QtI4naH+YdHMqNt+wLp53qz4RYkjBXoQL9eLBRTwIiWI0lrsMNQp1evSwe7uIfl8XKuzbeIc/Fr6bWNKxlQToD85JbFincdDTBM26dnOkZX3Nao5QTciUPDyXn1eSVsiq9Bhh0IuHTt6FC8lQO2Wm1jNoAVgde37ZIcY9opqbnhAIpoAriROCaqQDEdRz0NX+wYNvivu2TQhD6k5kXcylCdNs5MmWHwO77Hhf/RAJ+0nyieabdfpu1MVnXB+Pdri/0DGxEgDKvt2anO7Z+GcmLIz+4EVELymySthSQlkmtb2du67LUBS+W2Zg6512+6Z1TvMKcZuJJ4eYY+aAB2tRhAXdY/9KKL/leQ9gVf58b4D3KsQxTKJY0UWWS6anWvfP9dsa31ajORMeLp2sN6pkSIZZugu5PztTR0g0iGe/RVKeGRNiVCA5gg0nj0NQ/xu3oaV1ysseMuTN2xVWrVE45mM106NDe4q9b/1TkTvgIR072e742QOs4Ywt1tXTfw9DvSC0P04xa8Bf7rIakXp+2tObqhqvnnOv6pgfcsp7R6m4sN6bFsoXVGhuBW6eSH2TdFnR7PxVsUUhe4y2Dc9oE13AFV/zy7K0hYCUpZS94k0a8+nvWfZTyczgB1w5SN0BG1VywGJBeiZaRd1tOxqrBKHxVA9rluFZKpGVA0i5qdoZmEjpntgLerL9PtqVS93dciIYwsPBqdnoa4wb1wKfezxAbXFf0tDx5bvtxwMIfdmTJ8/GVqu8YDTXejKl4IB0zKQX7Xydlf2iIkMBitZKNvcfPTNMFJij3FDtTPVcB+0J0yuKnzXC6bKg8044uhahVIvt+Cz8kjg/ZrZnnCM4f7VrgjoCtTf8UoCDnJnIA4FXfNUmqcIwmYkF1VG/dJQePYVWABGnVBfQS79oNV/Myj1ylzYFMVRlqoVf24TSxRo5vWelhKY5Dr8/JCO8OgYo5qNN9O7Yfl1408qx7llvthq2cwzyJ0hFVKGpiD9zbzIDs1xenW2XOp1MIZ7iq2gWjmOJ5hYLD2QU8WmbluIxBWnGOnJ8nCMMGuaOUaEmpaJO5B/qDIIWja0IfIc0k7ZoA50weZSb8GUnezne6LuVydU2rG+3vWQ8XwHGt9PI/zjC+9BlOmWW8VAzjFSuTSDxgsdT8y5x6TDcjJnuSHdDPbVUGRJ19UMrQ9fd0dK8xoXSQb45Qs2DbDzbKT+NIvwIf8urloSNnYV0NtMIaTrOBSkRnI8oK/LgkqwXpTbLfvTsQQAEbnEVbOHqaUG+tfYS0Ze7HF/PxG3cjDI4r+NIBSN4IqPpAgSvTIR0NIZp7A+phT19+KAAKVCRGisTYT0J89UyGTznTceHekR23spR9zEPQbNPBAtlJzGLNVjM7LfUxoWCaU4jNk45 var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"2020","slug":"2020","permalink":"http://yoursite.com/tags/2020/"}]},{"title":"react中的事件绑定","slug":"react中的事件绑定","date":"2019-12-22T08:39:36.000Z","updated":"2019-12-22T09:51:52.269Z","comments":true,"path":"2019/12/22/react中的事件绑定/","link":"","permalink":"http://yoursite.com/2019/12/22/react%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/","excerpt":"","text":"遇到的问题最近想试一下React，之前一直用Vue在写东西。稍微看了几篇教程后，就开始写，能够基本运行起来，可能是因为项目比较简单吧。但是也遇到了几个问题，首先就是React的事件绑定问题： 我第一次的写法是： 12345handleEvent()&#123; console.log(\"test\")&#125;&lt;Button onClick=\"handleEvent\"&gt; &lt;/Button&gt; 这样普通的点击事件是能够正常触发的。 this的指向问题但是当我要使用this时，这种写法就出了问题。 1234567handleEvent()&#123; this.setState(&#123; state1 : 111 &#125;)&#125;&lt;Button onClick=\"handleEvent\"&gt; &lt;/Button&gt; 这样就会报错this为undefined的。于是我就想起了之前看过的文章以及结合之前对JavaScript的函数的this分析。就明白此时函数在调用时不是被react对象直接调用的。所以该函数的this的指向为undefined。所以要想使用react对象的方法，只有将函数的this指向为react。根据之前文章对this的分析，要想绑定this，可以使用： call（一次绑定并调用） apply （一次绑定并调用） bind（永久绑定） 箭头函数 () =&gt; {}永久绑定 但是事件是要多次调用并且不是绑定时就调用，而是事件被触发时才调用，所以排除call与apply方法。所以选择bind与箭头函数为最佳(后来看官方文档时发现官方也是推荐了这两种方法来绑定this)。 所以有以下方法： 在构造函数中绑定函数的this指向 12345678910constructor(props)&#123; super(props) this.handleEvent = this.handleEvent.bind(this)&#125;handleEvent()&#123; console.log(this) //此时指向react对象&#125;&lt;Button onClick=&#123;handleEvent&#125;&gt;&lt;/Button&gt; 在事件绑定时绑定函数this 12345handleEvent()&#123; console.log(this) //此时指向react对象&#125;&lt;Button onClick=&#123;this.handleEvent.bind(this)&#125;&gt;&lt;/Button&gt; 至此，this的指向问题基本解决。 函数传参的问题接下来遇到需要传参的函数。我使用了与Vue与原始HTML同样的写法 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;this.handleEvent(\"123\")&#125;&gt;&lt;/Button&gt; 当我尝试触发事件时，发现事件触发不成功，并且在打开控制面板时发现在页面初始化时，该事件被自动触发了3次，点击按钮无法触发。于是我不禁思考JSX的语法，让我想到了EL表达式，EL表达式中的代码会被直接运行，该位置会被填充为运行后的结果。再来看这个问题就发现自己的问题了。 {}内的代码在JSX模板编译时被当成代码直接运行，而tihs.handleEvent(&quot;123&quot;)在JavaScript中不就是直接运行函数吗，所以函数在模板编译时直接被运行了，而onClick的事件则被绑定为函数的返回值，但是这个函数没有返回值，所以事件绑定失败。 所以如何解决这个问题就很简单了，只要在事件绑定的位置放置一个函数而不是函数的调用就行了,方法也有两个： bind方法传参 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;this.handleEvent.bind(this,\"123\")&#125;&gt;&lt;/Button&gt; 箭头函数 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;() =&gt; &#123;this.handleEvent(123)&#125;&#125;&gt;&lt;/Button&gt; 折腾一下在看到箭头函数时我又思考能不能不用箭头函数，直接用匿名函数实现函数的调用。像这样： 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;function(para)&#123;this.handleEvent(para)&#125;&#125;&gt;&lt;/Button&gt; 再一想发现好想更不行，匿名函数没有绑定this指向。所以也就拿不到this.handleEvent()函数了。那就试试绑定一下匿名函数的this指向，像这样： 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;function()&#123;this.handleEvent(123)&#125;.bind(this)&#125;&gt;&lt;/Button&gt; OK，事件成功绑定，但是转念一想，这么搞还不如直接bind原函数，也避开了使用箭头函数。纯属折腾吧。 获取事件对象event在Vue或者原生HTML中，event被存储在window下的event对象中，在绑定事件时将event对象传入即可获得点击事件对象。 但在React中，我们可以这么做： 当我们不需要为这个函数传参时，event对象会自动传入该函数，我们通过第一个参数获取event对象 当我们需要传参时，我们需要手动传入event对象 12345678handleEvent = (para,e) =&gt; &#123; console.log(para) console.log(e)&#125;&lt;Button onClick=&#123;(e) =&gt; &#123;this.handleEvent(123,e)&#125;&#125;&gt;&lt;/Button&gt;//或者这样&lt;Button onClick=&#123;this.handleEvent(123,e)&#125;&gt;&lt;/Button&gt; Last至此，React中的函数事件绑定基本可以搞定。写了一段时间的React，感觉相较于Vue，更灵活。刚入手的话，习惯了Vue模板文件的 &lt;template&gt; &lt;style&gt; &lt;script&gt;这种分明的设计，React中的JSX写起来感觉有点复杂。在对比anted与elemenui，感觉elementui的api简直太简单了。后期在多体验看看吧！","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"事件绑定","slug":"事件绑定","permalink":"http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"}]},{"title":"CSS伪类与伪元素","slug":"CSS伪类与伪元素","date":"2019-11-20T14:54:39.000Z","updated":"2021-10-21T05:52:03.173Z","comments":true,"path":"2019/11/20/CSS伪类与伪元素/","link":"","permalink":"http://yoursite.com/2019/11/20/CSS%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0/","excerpt":"","text":"伪类？伪元素？之前一度认为伪类就是一组选择器，伪元素是不在DOM树的中的一些元素。但是当我看完MDN上的所有伪类与伪元素之后，才发现伪类与伪元素同属于CSS选择器的范畴，而伪元素其特殊之处在于伪元素可以选择的是一些不在DOM树中的元素，比如::selection用于选中用户用鼠标勾选的字符串；当然也可以选择在DOM树中的元素，比如::first-line用于选中元素的第一行，在特殊一点说，伪元素多用于选择一些特殊的东西，而伪类用于元素级别的选择，比如:nth:child用于选择某元素的第n个 伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。 伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::。 实际上最好的方法就是记住伪类与伪元素主要有哪些、特别是伪元素并不多。 伪类状态伪类 选择器 示例 说明 :link a:link 选择所有未访问的链接 :visited a:visited 选择所有访问过的链接 :hover a:hover 鼠标悬浮在链接上的状态 :active a:active 选择在激活状态的链接 :focus input:focus 选择获取焦点的输入框元素 :focus-within form:focus-within 用在父级元素上，当子元素获得焦点时，父元素获得对应属性(IE未实现) 结构化伪类 选择器 示例 示例说明 :first-child p:first-child 匹配一组兄弟元素中的第一个元素。（如果这个元素是p，就被匹配，否则不会被匹配。） :first-of-type p:first-of-type 匹配一组兄弟元素中其类型的第一个元素。（即使第一个不是p，也会一次向下检索，直到找到这个p。） :last-child p:last-child 匹配一组兄弟元素中的最后一个元素。（如果这个元素是p，就被匹配，否则不会被匹配。） :last-of-type p:last-of-type 匹配一组兄弟元素中其类型的最后一个元素。（即使最后一个不是p，也会一次向上检索，直到找到这个p。） :not(selector) :not(p) 选择所有p以外的元素（不支持伪类嵌套） :nth-child(n) li:nth-child(2n+1) 首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3…）。样例中即匹配所有奇数项的标签（注意所有的兄弟标签都会被算进去，即使不是li标签） :nth-last-child(n) p:nth-last-child(2) 匹配一列兄弟元素，从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。（与上面相同，只是从后往前数） :nth-of-type(n) p:nth-of-type(2) 匹配某种类型的一列兄弟元素（比如，&lt;p&gt;元素）——兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。 :nth-last-of-type(n) p:nth-last-of-type(2n+1) 匹配某种类型的一列兄弟元素（比如，&lt;p&gt;元素）——兄弟元素按照an+b形式的式子进行从后向前匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。（与前面的类似，只是方向是从后往前数）样例意思是匹配所有父元素下，是奇数位置的p元素。 :only-of-type p:only-of-type 匹配兄弟元素中某类型仅有的元素。样例即为选择一个p元素，其兄弟元素都不是p元素。 :only-child p:only-child 匹配没有兄弟元素的元素。 :target #news:target 匹配当前URL目标的元素（含锚点）。 表单伪类 选择器 示例 示例说明 :disabled input:disabled 选择所有被禁用的元素。 :enabled input:enabled 选择所有被启用的（enabled）元素。 :required input:required 选择设置 required 属性的表单元素 :read-only input:read-only 选择设置 readonly 只读属性的元素 :read-write input:read-write 选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。 :checked input:checked 匹配被选中的 input 元素，input 元素包括 radio 和 checkbox :empty p:empty 匹配所有没有子元素的 p 元素 :in-range input:in-range 选择在指定区域内的元素 :out-of-range input:out-of-range 选择不在指定区域内的元素 :valid input:valid 选择条件验证正确的表单元素 :invalid input:invalid 选择条件验证错误的表单元素 :optional input:optional 选择没有 required 属性，即设置 optional 属性的表单元素 :default - 匹配默认选中的元素(提交按钮总是表单的默认按钮)。 :indeterminate - 当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。 :scope - 匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。(试验阶段) :root :root 匹配文档树的根元素。 伪元素单双冒号 选择器 作用 说明 ::before/:before 在被选元素前插入内容。 需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。 ::after/:after 在选被元素后插入内容 其用法和特性与:before相似。 ::first-letter/:first-letter 匹配元素中文本的首字母。 匹配元素的第一个字母。 ::first-line/:first-line 匹配元素中第一行的文本。 匹配包含此伪元素的元素的第一行。 双冒号 选择器 作用 说明 ::selection 匹配被用户选中或者处于高亮状态的部分. 在火狐浏览器使用时需要添加 -moz 前缀。 ::placeholder 匹配占位符的文本。 只有元素设置了 placeholder 属性时，该伪元素才能生效。 LAST对于伪类与伪元素，最好的不是区分它们，而是记住常用的选择器是属于伪类还是伪元素。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"伪元素","slug":"伪元素","permalink":"http://yoursite.com/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"},{"name":"伪类","slug":"伪类","permalink":"http://yoursite.com/tags/%E4%BC%AA%E7%B1%BB/"}]},{"title":"CSS3过渡与动画","slug":"CSS3过渡与动画","date":"2019-11-18T13:13:17.000Z","updated":"2019-11-19T01:23:21.050Z","comments":true,"path":"2019/11/18/CSS3过渡与动画/","link":"","permalink":"http://yoursite.com/2019/11/18/CSS3%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/","excerpt":"","text":"CSS3-过渡 CSS3中，我们为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript。 使用transition属性，CSS3会自动为属性的变化来添加过渡样式。这个属性一般可以用在:hoevr :active等伪元素切换。 transition也是一个复合属性： 1234tag&#123; transition:transition-property ransition-duration transition-timing-function transition-delay; &#125; 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 transition-property该属性用于定义需要渐变的CSS属性，比如color width等。 可选值 描述 none 没有过渡动画。 all 所有可被动画的属性都表现出过渡动画。 IDENT 性名称。由小写字母 a 到 z，数字 0 到 9，下划线（_）和破折号（-）。第一个非破折号字符不能是数字。同时，不能以两个破折号开头。 transition-duration该属性定义渐变的时间，要带单位（s,ms）。 transition-timing-function这个属性是过渡的核心。引用MDN官方的描述： CSS属性受到 transition effect的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变。 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 step-start 直接跳到结束处 step-end transition-duration steps() 步进函数将过渡时间分成大小相等的时间时隔来运行没有过度效果，而是一帧一帧的变化，integer等于几就分成几帧，阶跃函数 steps()函数steps(&lt;integer&gt;[,start| end]?) :用于指定间隔个数（该值只能是正整数） 第二个参数可选，默认是end,表示开始值保持一次，若参数为start，表示开始值不保持 end:用于指定在step中间隔数少于该有的变化次数时，因该丢弃前面的部分还是后面的部分。 123456789即每个关键帧都分成两次变化完成，则一共有七次变化。七帧 一共变化七次， div本身没有颜色，所以最终的背景无色。但是，只变化七次，有七种颜色，加上无色，一种八种状态，所以需要丢弃一种状态start 橙、黄、灰、蓝、深灰蓝、绿、无色 原理：去掉第一帧的效果，end 红、橙、黄、灰、蓝、深灰蓝、无色原理：去掉最后一帧的效果 cubic-bezier(n,n,n,n)贝塞尔曲线函数的四个值，具体原理后面研究一下再写一篇博客。 transition-delay CSS的transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 下面写个例子 12345678910div&#123; width:120px; color:red; transition:all 0.5s ease 1s; &#125;div:hover&#123; width:200px; color:blue;&#125; 这段代码设定在鼠标划过时，所有的属性在1s后开始过渡，过渡时间为0.5s，过渡方式为ease。 CSS动画CSS3中，我们可以用2个属性来定义函数。 @keyframes animation 利用这两个属性可以制作简单或复杂的CSS东阿虎 @keyframes @keyframes 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。这比转换更能控制动画序列的中间步骤。 Point： 如果一个关键帧规则没有指定动画的开始或结束状态（也就是，0%/from 和100%/to，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。 如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 如果多个关键帧使用同一个名称，以最后一次定义的为准。 @keyframes 不存在层叠样式(cascade)的情况，所以动画在一个时刻（阶段）只会使用一个的关键帧的数据。 如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 因为@keyframes 的规则不存在层叠样式(cascade)的情况，即使多个关键帧设置相同的百分值也不会全部执行。 如果某一个关键帧出现了重复的定义，且重复的关键帧中的css属性值不同，以最后一次定义的属性为准。例如： 123456@keyframes identifier &#123; 0% &#123; top: 0; left: 0px&#125; 50% &#123; top: 30px; left: 20px; &#125; 50% &#123; top: 10px; &#125; 100% &#123; top: 0; left: 30px;&#125;&#125; 上面这个例子中，50% 关键帧中设置的属性top: 10px是有效的，但是其他的属性会被忽略 关键帧中出现的 !important 关键词将会被忽略 @keyframes格式如下： @keyframes 动画名字 { ​ 阶段名:{ ​ 元素属性 ​ } } 其中阶段名可以百分比或者from/to example: 1234567@keyframes mykeyframes&#123;0% &#123;background:red;&#125;25% &#123;background:yellow;&#125;50% &#123;background:blue;&#125;100% &#123;background:green;&#125;&#125; 这样就新建了一个动画关键帧，现在我们就需要使用animation将其添加到对应的元素上。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"过渡","slug":"过渡","permalink":"http://yoursite.com/tags/%E8%BF%87%E6%B8%A1/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"函数的防抖与节流以及一些重要的函数模式","slug":"函数的防抖与节流以及一些重要的函数模式","date":"2019-11-17T12:25:01.000Z","updated":"2021-03-09T13:06:47.277Z","comments":true,"path":"2019/11/17/函数的防抖与节流以及一些重要的函数模式/","link":"","permalink":"http://yoursite.com/2019/11/17/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"防抖（debounce）在学习单片机开发时，按键防抖非常重要，我们必须使用一定的方法来进行防抖，否则会造成一次按键按键的多次触发的情况。而在JavaScript中，同样会有这样的问题，即在用户进行持续性的操作时，在用户大概率完成后，在进行后续操作（请求服务器，浏览器渲染等）。如果不进行防抖操作，会导致服务器或浏览器的性能浪费。 其具体定义：在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后： - 如果在一段时间内没有再次触发滚动事件，那么就执行函数 - 如果在一段时间内再次触发滚动事件，那么当前的计时取消，重新开始计时 下面是一个函数实现： 123456789101112function debounce(fun, delay) &#123; let timer return function (arguments) &#123; //获取函数的作用域和变量 let that = this; let args = arguments; clearTimeout(timer) // 清除定时器 timer = setTimeout(function () &#123; fun.apply(that, args) &#125;, delay) &#125;&#125; 该函数接受一个目标函数与延迟，该函数内部返回了一个函数，并将目标函数的id设为定时器的id。如果第一次调用该函数，会设置一个定时器，设定在delay毫秒后执行目标函数，但是如果在delay毫秒时间内再次调用该函数的防抖函数，那么就会清除掉目标函数的定时器，也就不会执行了。并再次设置一个定时器，循环以上步骤。 节流（Throttle）节流更是一个重要的概念，特别是在进行渲染的操作时（比如，mousemove，scoll），如果不进行节流，那么浏览器将会消耗很多性能，致使页面卡顿与操作不流畅。 具体定义：是指在一定的时间内只允许函数执行特定次数。 123456789101112131415161718192021function throttle(fn,delay)&#123; let _self = fn, timer, firstTime = true; return function()&#123; let args = arguments _this = this if(firstTime)&#123; _self.apply(_this, args) return firstTime = false &#125; if(timer)&#123; return false &#125; timer = setTimeout(function()&#123; clearTimeout(timer) timer = null _self.apply(_this, args) &#125;, delay||500) &#125;&#125; 该函数的核心是在：在外部先判断目标函数fun的timer属性是否为空。如果为空，则代表一次函数还未执行完，则直接返回。否则则设定目标函数的timer属性为一个定时器，在定时器的函数中将timer清空，并执行目标函数。 2021/2/17最近在读《JavaScript设计模式与开发实践》，发现除了函数的节流与防抖，还有一些高级函数模式，可以用来解决一些问题。 分时函数当一个任务需要进行大量同类操作，此时可能会造成页面的卡顿。此时，为了防止页面卡顿，我们要把单个大型任务分割成为多个小的任务，典型的场景是：大量数据插入表格。 我们把但分时函数代码如下： 12345678910111213141516171819let timeChunk = function(ary, fn, count)&#123; let obj let t let len = ary.length let start = function()&#123; for(let i = 0; i &lt; Math.min(count || 1, ary.length); i++)&#123; let obj = ary.shift() fn(obj) &#125; &#125; return function()&#123; t = setInterval(function()&#123; if(ary.length === 0)&#123; return clearInterval(t) &#125; start() &#125;, 200) &#125;&#125; 比如我们需要添加1000调信息到页面中，我们采用每次创建8个节点。 123456789101112let ary = []for(let i = 1; i &lt;= 1000; i++)&#123; ary.push(i)&#125;let renserList = timeChunk(ary, function(n)&#123; let div = document.createElement('div') dic.innerHTML = n document.body.appenChild(div)&#125;, 8)renderList() 惰性加载函数当一个任务在执行之前后悔事先执行一些预先性工作，并且这些工作在每次执行时的结果都是一样的，那我们可以在第一次得到结果后就将其凝固，在以后的每一次执行时就可以减少判断次数，提高性能。 一个典型的场景就是浏览器能力检测，常见的写法如： 12345678let addEvent = function(elem, type, handler)&#123; if(window.addEventListener)&#123; return elem.addEventListener(type, handler, false) &#125; if(window.attachEvent)&#123; return elem.attachEvent('on' + type, handler) &#125;&#125; 这个函数的缺点是，当它每次被调用的时候都会执行里面的if条件分支，虽然执行这些if分支的开销不算大，但也许有一些方法可以让程序避免这些重复的执行条件。如下面的方案就是在最开始调用一次判断，后续调用该函数时，就不会再进行判断了： 123456789101112let addEvent = (function()&#123; if(window.addEventListener)&#123; return function(elem, type, handler)&#123; elem.addEventListener(type, handler, false) &#125; &#125; if(window.attachEvent)&#123; return function(elem, type, handler)&#123; return elem.attachEvent('on' + type, handler) &#125; &#125;&#125;)() 第三种方案就是我们的懒加载函数，代码如下： 123456789101112let addEvent = function(elem, type, handler)&#123; if(window.addEventListener)&#123; addEvent = function(elem, type, handler)&#123; elem.addEventListener(type, handler, false) &#125; &#125;else if(window.attachEvent)&#123; addEvent = function(elem, type, handler)&#123; elem.attachEvent('on'+type, handler) &#125; &#125; addEvent(elem, type, handler)&#125; 这个函数在第一次调用时，会根据条件分支，对addEvent事件进行重载，并且对其进行调用一次。这个函数不必判断第一次，而是自动在第一次时重载，很妙。 这里有一个知识点是，在具名函数的执行过程中是可以对具名函数进行重新赋值的。 summary总体来说，在进行某些操作时，比如表单实时验证或者绘图的操作等，函数的防抖与节流会大幅度节省服务器与浏览器的性能！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"防抖","slug":"防抖","permalink":"http://yoursite.com/tags/%E9%98%B2%E6%8A%96/"},{"name":"节流","slug":"节流","permalink":"http://yoursite.com/tags/%E8%8A%82%E6%B5%81/"}]},{"title":"Vue中局部修改组件样式","slug":"Vue中局部修改组件样式","date":"2019-11-17T11:52:19.000Z","updated":"2019-11-17T12:18:40.077Z","comments":true,"path":"2019/11/17/Vue中局部修改组件样式/","link":"","permalink":"http://yoursite.com/2019/11/17/Vue%E4%B8%AD%E5%B1%80%E9%83%A8%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"Vue如何修改子组件样式在使用element-ui或者i-view这些第三方样式库时，我们有时会想只在某一个组件中局部修改库中的样式而部影响全局样式。 首先我们需要打开控制器找到对应组件的CSS样式的类名或者id 有以下几种方式 不在style样式上添加scope属性&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;el-input&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .father el-input{ color:red; } &lt;/style&gt; 这样相当于只修改father类下的el-input的属性。 使用 &gt;&gt;&gt; 穿透scope的用处scoped是Vue里面style标签的一个特殊属性，当一个style标签拥有scoped属性的时候，就相当于说明它里面的样式只作用于当前这个Vue页面，不会污染到全局的样式，从而实现了组件样式的模块化，那么它是怎么实现的呢？其实如果我们给style标签加上了scoped属性，在编译的时候，他会给我们组件里面的每一个样式加一个自定义的属性data-v-5558821a,从而通过给含有这个自定义属性的标签加上样式，从而实现了部分样式的穿透。 &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;el-input&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; .father &gt;&gt;&gt; el-input{ color:red; } &lt;/style&gt; 如果使用的是less或者sass可以将 &gt;&gt;&gt; 换为 /deep/ &lt;style scoped&gt; .father /deep/ el-input{ color:red; } &lt;/style&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"CSS3-转换","slug":"CSS3-转换","date":"2019-11-05T01:23:39.000Z","updated":"2019-11-08T09:18:21.422Z","comments":true,"path":"2019/11/05/CSS3-转换/","link":"","permalink":"http://yoursite.com/2019/11/05/CSS3-%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"CSS3中的转换CSS3中的转换可以形成简单的动画，对于页面的小优化有点金的效果。 CSS3中的转换都在transform属性中定义，在该属性中定义其他函数来进行不同的转换。 CSS3的2D转换translate()该函数接受两个参数，分别是其x，y轴的偏移量，右下为正方向。 transform:translate(50px,100px); 将原元素向右、下移动50px、100px。 如果只填一个参数，则默认为x轴偏移。 transform:translate(50px); 向x轴移动50px; transform:translate(0,100px); 向y轴移动100px； rotate()该函数接受一个参数，确定偏移的角度，正值为顺时针，负值即为逆时针。 transform: rotate(30deg);//顺时针30度 transform: rotate(-30deg);//逆时针30度 scale()该函数接受两个参数，分别为x轴的倍数，y轴的倍数。 scale(2,3); 将容器宽度放大2倍，高度放大3倍。 skew()通过 skew() 方法，元素将偏斜相应的角度，注意这个偏斜与rotate(旋转)不同，skew将会绕x,y轴偏斜x,y度，观察到的肉眼的形状会改变！比如只偏斜某一轴，则原元素会变成一个平行四边形。(与其他转换一样，其内容也会做对应的变换) transform: skew(30deg); transform: skew(0deg,30deg); transform: skew(30deg,30deg); matrix()matrix() 方法把所有 2D 转换方法组合在一起。默认值为：transforms:matrix(1,0,0,1,0,0); matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 matrix原意是矩阵，所以这六个参数分别是矩阵的6个位置的值： matrix(a,b,c,d,e,f) 也就是利用这个矩阵与原容器做运算后获得新位置。 所以我们运算过后的结果就是： x’=ax+cy+e y’=bx+dy+f 移动所以根据这个式子，我们可以推算如果要对元素进行x轴移动，则x’直接增大固定数值，即改变e的值： 向x轴移动10px，y不变 matrix(1,0,0,1,10,0) 向x,y轴都移动10px matrix(1,0,0,1,10,10) 缩放缩放的实质就是奖x，y轴的数值放大n倍，即： x’=2y y’=2x 对于上面的： x’=ax+cy+e y’=bx+dy+f 可得到： nx = ax+cy+e ny = bx+dy+f 易得： a = nb = 0c = 0d = ne = 0f = 0 即，进行缩放的话，我们只需要修改a,d的值以修改宽,高的缩放程度 旋转利用极坐标，我们可以算出偏移角度与元素某点的坐标的关系。 根据原理图得： 推算可以得到： 所以，我们得： a = cosθ b = -sinθ d = sinθ e = cosθ 所以改变abde，即可实现旋转。 偏移同样由数学知识 即： b = tanθxe = tanθy 所以，skew操作只与b、e相关。 不过如果不是利用CSS3来做一些复杂的变换，可以用这种方式来减少代码。否则最好不要使用这个函数，因为它可能会使你的调试复杂困难。 transform-origin()该属性确定转换的基点位置。 example: transform-origin:20px 20px; 规定变换的基点为：(x=)20px (y=)20px 其值可以为： left center right length % CSS3的3D转换我们在2D之中，我们看过“translate，scale，rotate”这三个变换属性。在3D变换中，这三个属性被拆分3个方向的分属性： translate() translateX() translateY() translateZ() scale() scaleX() scaleY() scaleZ() ratate() rotateX() rotateY() rotateZ() 每个方向上的分量分别是沿某一轴变换。比如：translateX(120)表示沿X轴正方向移动120px。 另外3D还有几个属性： transform-styleCSS 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。 flat 设置元素的子元素位于该元素的平面中。 preserve-3d 指示元素的子元素应位于 3D 空间中。 perspective-originperspective-origin属性也可以有3参数方式，第三个值为Z值。 backface-visibilitybackface-visibility 属性定义当元素不面向屏幕时是否可见。 perspective&amp;&amp;perspective-originperspective 属性定义 3D 元素距视图的距离，以像素计。(类似于AE相机中的属性值)。 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 元素添加perspective属性后，可再添加perspec-origin控制观察位置(类似与AE中的相机的x,y位置)。 注释：perspective 属性只影响 3D 转换元素。 .father{ width:400px; height:400px; perspective:120px; perspective-origin:10px 10px; background-color:blue; margin: 60px; } .son{ margin:60px ; width:120px; height:120px; background-color:gray; transform: rotateX(30deg); } 我们观察当perspective-origin值与perspective值改变时，元素发生的变化。 可以明显看出，当perspective值改变的时候，相当于我们视觉的位置与元素的距离发生了改变。而当perspective-origin发生改变的时候，我们是视觉的x，y位置发生了改变，所以我们看到元素的形状及其位置发生了改变。 LastCSS3中的3D变换算是一门学问，下一章解析过渡的时候一起再解析一下，让自己多理解一下。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"transform","slug":"transform","permalink":"http://yoursite.com/tags/transform/"},{"name":"translate()","slug":"translate","permalink":"http://yoursite.com/tags/translate/"},{"name":"scale()","slug":"scale","permalink":"http://yoursite.com/tags/scale/"},{"name":"rotate()","slug":"rotate","permalink":"http://yoursite.com/tags/rotate/"},{"name":"skew()","slug":"skew","permalink":"http://yoursite.com/tags/skew/"},{"name":"matrix","slug":"matrix","permalink":"http://yoursite.com/tags/matrix/"}]},{"title":"CSS3-文本效果和字体","slug":"CSS3-文本效果和字体","date":"2019-11-04T07:26:39.000Z","updated":"2019-11-05T11:49:18.718Z","comments":true,"path":"2019/11/04/CSS3-文本效果和字体/","link":"","permalink":"http://yoursite.com/2019/11/04/CSS3-%E6%96%87%E6%9C%AC%E6%95%88%E6%9E%9C%E5%92%8C%E5%AD%97%E4%BD%93/","excerpt":"","text":"CSS3中的文字效果及字体CSS3本来规定了较多的文字属性，但是大部分没有被实现，所以只介绍已经被实现的属性。 text-shadowtext-shadow用于创建一个文字阴影，其参数如下： 参数 说明 &lt;offset-x&gt; x轴的偏移量 &lt;offset-y&gt; y轴的偏移量 &lt;blur-radius&gt; 模糊半径 example1: text-shadow: 5px 5px 5px #FF0000; text-shadow案例利用text-shdow的叠加，可以实现多种文字特效： 火焰文字效果关键：在文字外层加上多层黄色，红色的阴影，并且模糊程度越来越大，颜色的掌控很关键。否则可能不会很逼真。 background:black; text-align:left; text-shadow: 0 -5px 4px #FF3,2px -10px 6px #fd3,-2px -15px 11px #f80,2px -25px 18px #f20; color:red; 立体凸起效果关键：将背景颜色与温习颜色设为一致，再设置一个白色的阴影，一个黑色的阴影，x轴分别偏移-1px，1px即可达到效果。 text-shadow: -1px -1px white,1px 1px #333; color:#D1D1D1; font-weight: bold; background: #CCC; 立体凹下效果关键：与凸起相似，但是将两个偏移量交换一下，即可实现凹下效果。 text-shadow: 1px 1px white,-1px -1px #333; color:#D1D1D1; font-weight: bold; background: #CCC; 描边效果关键：设置4个黑色的阴影，模糊度为0，分别向上下左右各偏移1px，即可实现描边效果。 text-shadow: -1px 0 black,0 1px black,1px 0 black,0 -1px black; color:#ffffff; background: #CCC; 外发光效果关键：不要为阴影设置x，y的偏移量，增大模糊度，即可实现。 text-shadow: 0 0 0.2em #F87,0 0 0.2em #f87; color:#d1d1d1; background: #CCC; 3D效果关键：在同一方向上多次叠加颜色更深的阴影。 color:white; font-size: 200px; text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px 10px black; 关于text-shadow对于各种文字效果，如果我们认真分析文字附加效果的颜色及光影效果，我们可以利用text-shadow模拟出很多的文字效果。 word-wrap/overflow-wrapword-wrap又叫做overflow-wrap： word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”。 稳定的谷歌 Chrome 和 Opera 浏览器版本支持这种新语法。 该属性含有一个参数，其可以有以下值： 值 说明 normal 表示在正常的单词结束处换行。 break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 CSS3 @font-face 规则以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。 使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。 当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。 您所选择的字体在新的 CSS3 版本有关于 @font-face 规则描述。 您”自己的”的字体是在 CSS3 @font-face 规则中定义的。 实例： &lt;style&gt; @font-face { font-family: myFirstFont; src: url(sansation_light.woff); } div { font-family:myFirstFont; } &lt;/style&gt; 在font-family中，还可以定义字体的其他属性： 结束通过text-shadow和自定义字体，我们可以实现多种我们想要的字体效果了！结合上一章的背景，网页肯定能换发生机！","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"text-shadow","slug":"text-shadow","permalink":"http://yoursite.com/tags/text-shadow/"},{"name":"word-wrap","slug":"word-wrap","permalink":"http://yoursite.com/tags/word-wrap/"},{"name":"overflow-wrap","slug":"overflow-wrap","permalink":"http://yoursite.com/tags/overflow-wrap/"},{"name":"font-face","slug":"font-face","permalink":"http://yoursite.com/tags/font-face/"}]},{"title":"CSS3-背景","slug":"CSS3-背景","date":"2019-10-29T01:48:59.000Z","updated":"2019-11-01T10:23:17.505Z","comments":true,"path":"2019/10/29/CSS3-背景/","link":"","permalink":"http://yoursite.com/2019/10/29/CSS3-%E8%83%8C%E6%99%AF/","excerpt":"","text":"backgroundCSS中，background是一个符合属性，是以下单属性的符合属性： background-color background-position background-size background-repeat background-origin background-clip background-attachment background-image 其格式如下 background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; background-colorbackground-color属性设置一个元素的背景颜色。 元素的背景是元素的总大小，包括填充和边界（但不包括边框）。 example: background-color:yellow; 其属性支持以下内容： 颜色关键值，如：red,blue… Hex颜色值，如：#bbff00… Hex含透明颜色值，如：#ffbb0036;（最后两位表示透明度，ff则为不透明，可省略，则变为普通Hex） RGB颜色值，如：rgb(255,255,255) RGBA颜色值，RGB可透明的颜色值，如：rgba(55,56,125,0.5)，透明度为0.5 特殊值： currentColor：该值是CSS3新增的一个颜色关键字，等会详细介绍。 transparent：透明背景 全局变量： inherit：继承上一级的背景颜色。（注意，该值可用于所有的CSS属性） initial：设置背景色的为默认值（每一个CSS属性都有一个默认值，有些为none，则设置没有效果），此属性可用于清除父级的继承属性。如p标签中的span标签的文字颜色继承问题。 unset：如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。换句话说这个unset关键字会优先用 inherit 的样式，其次会应该用initial的样式。 currentColor关键字CSS新增了currentColor关键字 currentColor代表了当前元素被应用上的color颜色值。 使用它可以将当前这个颜色值应用到其他属性上，或者嵌套元素的其他属性上。并且该属性会继承上级属性值。 example1: .box{ color:red; background-color:currentColor; //此时currentColor=red; height:100px; width:100px; } exmaple2: .fatherBox{ color:red; } .sonBox{ background-color:currentColor;//此时currentColor继承父级的color属性，为red } background-image其属性有以下内容： url():该函数接受一个地址作为背景图片的url，可以是本地地址，也可以是网络地址。 color值：&lt;rgb()&gt; | &lt;rgba()&gt; | &lt;hsl()&gt; | &lt;hsla()&gt; | &lt;hex-color&gt; | &lt;named-color&gt; | currentcolor | &lt;deprecated-system-color&gt; linear-gradient():该函数用于生成一个线性渐变。 radial-gradient()：该函数用于生成一个径向渐变。 repeating-linear-gradient()：该函数用于生成一个重复的线性渐变 repeating-radial-gradient()：该函数用于生成一个重复的线性渐变。 关键字：inherit(从父级继承) linear-gradient()CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于数据类型，是一种特别的数据类型。 其参数有以下几个： angle：角度，可为以下值： 角度值deg，如45deg，-120deg,方向递增方向为顺时针方向。 角度关键字，如，to left，to bottom right，这些关键字等同于相应的角度，如to top = 0deg，to right = 90deg，to bottom right = 135deg color-stop:结束位置颜色值（渐变开始位置）, 包含颜色及结束位置，如red 30%，blue 50% 只包含颜色值，如red,rgb(123,45,26)，此时每一个颜色会被设置默认的结束位置值，即按颜色均分该区域。如，red blue = red 0%,blue 100% 值得注意的是，每个颜色结束位置之间的距离就是这两个颜色渐变的距离 如： red 0%,blue 100%，那么红色与蓝色在之间的渐变距离即为100% red 0%,blue 50%,brown 100%，那么红色与蓝色之间的渐变距离则为50%，蓝色与棕色之间的渐变距离也为50%。 仔细思考一下会发现，如果两个颜色之间的渐变距离为0，那么他们之间的就不会有渐变，再利用角度的可改变与多次使用该属性，即可实现绘制图形 比如： 条形背景： background: linear-gradient(90deg,rgb(153, 153, 153) 50%,rgb(105, 105, 105) 50%); background-size: 20%; background-repeat: repeat; 切角效果 background: linear-gradient(45deg,red 10%,transparent 10%), linear-gradient(135deg,red 10%,transparent 10%), linear-gradient(-45deg,red 10%,transparent 10%), linear-gradient(-135deg,red 10%,transparent 10%); 折角效果 background:linear-gradient(-135deg,transparent 51%,rgba(0, 0, 0, 0.178)51%) no-repeat 100% 0 / 6em 6em, linear-gradient(-135deg,transparent 10%,rgb(169, 169, 233) 10%); 利用其线性切割+重复性，可以实现多种图案，只要想象力足够，唯一需要考虑的就是性能问题，如果通过其绘制过于复杂的线性动画导致页面性能损失，那也是得不偿失的。 radial-gradient()该函数接受5个属性： 参数 描述 可选值 &lt;size&gt; 整个渐变的尺寸大小，如果设置为circle,则可以在前面通过”100px”，”10%”的格式设置其半径，radius；如果设置为ellipse，则可以在前面通过”100px 200px”,”10% 20%”的格式设置其短半径与长半径的值。 绝对单位数值，如100px。相对单位数值，如20% &lt;extent-keyword&gt; 此关键字的词用于确定渐变最外侧的边与哪个边相切，或与哪个角相距。实际上也是确定半径，所以也可以通过size属性直接设置半径。 见下表 &lt;shape&gt; 渐变的形状。圆形（渐变的形状是一个半径不变的正圆）或椭圆形（轴对称椭圆）。默认值为椭圆。椭圆半径与容器的长宽比例相同。 redius：绝对单位数值，如100px；shape：’circle’,’ellipse’ &lt;position&gt; 渐变圆的圆心位置 一般在前面加上 at 关键字 ， 绝对单位数值，如100px。相对单位数值，如20% &lt;color-stop&gt; 渐变的颜色及其渐变结束位置 color:Hex值，rgb值，rgba值，颜色关键字；stop：绝对单位数值，如100px。相对单位数值，如20% 关键字 常量 描述 常量 描述 closest-side 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 closest-side 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 closest-corner 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 closest-corner 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 farthest-side 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 farthest-side 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 farthest-corner 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 farthest-corner 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 radial-gradient()基本应用example1(自己设置半径)： background-image: radial-gradient(100px 150px ellipse at 200px 250px,yellow 50%,red 70%); background-repeat: no-repeat; example2(用关键字)： background-image: radial-gradient(closest-side ellipse at 200px 250px,yellow 50%,red 70%); background-repeat: no-repeat; radial-gradient()高级应用与radial-gradient一样，如果设置两个结束颜色的渐变距离为0或为负值，则可形成径向切割，以此构成多样化的图形。 如： example1(内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%); 但是我们一般会想要多个内凹圆角，当我们简单的将多个radial-gradient堆起来就会发现前一个背景无论如何都会把后面的背景给覆盖掉。所以我们最好的办法是结合background-size,backround-position,background-repeat结合起来，形成多个不叠加的背景！ example2(两个内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 100% / 50% 100%, radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 100%; example3(四个内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 0% / 50% 50%, radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 0%/ 50% 50%, radial-gradient(100px circle at 0 100%,transparent 50%,red 50%) no-repeat 0% 100%/ 50% 50%, radial-gradient(100px circle at 100% 100%,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 50%; repeating-linear-gradient()repeating-linear-gradient() 函数用于创建重复的线性渐变 “图像”。该属性的参数与linear-gradient()相同，所以不在赘述。 由于可以重复的组成背景图形，因此用处更多，条形背景是一个典型的应用。 example1: background: repeating-linear-gradient(yellow 0%,yellow 10%,black 10%,black 20%); example2: background: repeating-linear-gradient(rgba(255, 255, 0, 0.397) 0%,rgba(255, 255, 0, 0.397) 10%,rgba(0, 0, 0, 0.26) 10%,rgba(0, 0, 0, 0.26) 20%), repeating-linear-gradient(to right,rgba(255, 255, 0, 0.397) 0%,rgba(85, 243, 36, 0.397) 10%,rgba(0, 0, 0, 0.26) 10%,rgba(0, 0, 0, 0.26) 20%); repeating-radial-gradient()repeating-radial-gradient()用于创建多个repeating-radial原点辐射。参数与repeating-radial()一致。 example1: background: repeating-radial-gradient(circle at center, rgb(146, 146, 146) 0, rgb(146, 146, 146) 2%, black 2%,black 4%); 渐变综合应用用渐变生成一个复古胶盘： .box3 { position: relative; margin: 100px; height: 400px; width: 400px; color: cadetblue; border-radius: 50%; background: linear-gradient(30deg, transparent 40%, rgba(42, 41, 40, .85) 40%) no-repeat 100% 0, linear-gradient(60deg, rgba(42, 41, 40, .85) 60%, transparent 60%) no-repeat 0 100%, repeating-radial-gradient(#2a2928, #2a2928 4px, #ada9a0 5px, #2a2928 6px); background-size:50% 100%, 100% 50%, 100% 100%; } .box3:after{ position: absolute; top: 50%; left: 50%; margin: -35px; border: solid 1px #d9a388; width: 68px; height: 68px; border-radius: 50%; box-shadow: 0 0 0 4px #da5b33, inset 0 0 0 27px #da5b33; background: #b5ac9a; content: &apos;&apos;; } background-sizebackground-size 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。 其参数有以下内容： 值 解释 &lt;length&gt; &lt;length&gt; 值，比如10px,10em…指定背景图片大小，不能为负值。 &lt;percentage&gt; &lt;percentage&gt; 值，如10%，指定背景图片相对背景区（background positioning area）的百分比。背景区由background-origin设置，默认为盒模型的内容区与内边距，也可设置为只有内容区，或者还包括边框。如果attachment 为fixed，背景区为浏览器可视区（即视口），不包括滚动条。不能为负值。 auto 以背景图片的比例缩放背景图片。 cover 缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。 contain 缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。 inherit/initial/unset 继承父级该属性的值/默认值/如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。 注意， 如果其值为&lt;length&gt;时，则可以分别设置其宽高，如： background-size: 50% 25%; 如果background有多个值，那么在background-size就可以有多个值，并且与其一一对应。 background-size: 50% 25%, contain, 3em; //有3个背景图片 background-originbackground-origin 规定了指定背景图片background-image 属性的原点位置的背景相对区域. 参数如下： 值 解释 border-box 背景图片的摆放以border区域为参考 padding-box 背景图片的摆放以padding区域为参考 content-box 背景图片的摆放以content区域为参考 下面是效果图： background-clipbackground-clip 设置元素的背景（背景图片或颜色）是否延伸到边框或padding下面。 值 解释 border-box 背景延伸至边框外沿（但是在边框下层）。 padding-box 背景延伸至内边距（padding）外沿。不会绘制到边框处。 content-box 背景被裁剪至内容区（content box）外沿。 text 背景被裁剪成文字的前景色。（实验性属性，chrome需加上-webkit-前缀） 下面是效果图： example: -webkit-background-clip: text; color: transparent; font-size: 200px; background-positionbackground-position 为每一个背景图片设置初始位置。 这个位置是相对于由 background-origin 定义的位置图层的。 参数如下： 值 解释 center 用来居中背景图片。 top, left, bottom, right 用来指定把这个项目（原文为 item）放在哪一个边缘。另一个维度被设置成 50%，所以这个项目（原文为 item）被放在指定边缘的中间位置。 &lt;length&gt; 指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。 &lt;percentage&gt; 指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。 该属性可以分别用两个值规定x,y的距离 如：example1： background-position：50px 50px; 也可以向自己规定的边的距离： example2： background-position: right 50px bottom 50px; 我们也可以使用关键词center来居中背景： example3： background-position: center; 如果我们规定一个关键词，另一个关键词则为center： example4： background-position: left; 如果我们将距离值设置为负值，那么背景就会偏离出容器内部，延时到容器的外部（不会显示出来）。 example5: 注意：background还可以拆分为background-position-x与background-position-y，用来分别设置x，y轴的距离。虽然这是一个是实验性属性，不过大部分浏览器都实现了该方法，一般不会出问题 background-repeatbackground-repeat CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。 其参数包含以下，并且每一个单参数都可以改写成双参数（x,y两个方向）的形式： 属性值 含义 双值 repeat 默认值，图像在水平方向和垂直方向都重复以填满容器 repeat repeat repeat-x 图像只在水平方向重复以填满容器 repeat no-repeat repeat-y 图像只在垂直方向重复以填满容器 no-repeat repeat space 图像向两端对齐重复以填满容器，多余空间用空白代替 space space round 图像向两端对齐重复以填满容器，多余空间通过图像拉伸来填充 round round no-repeat 不重复，图像只显示一次 no-repeat no-repeat 注意round与space的区别 round通过图片拉伸将容器内部全部填满： background-repeat: round; space将对应数量的背景填入容器，多余的空间将background-color的颜色填充。 background-repeat: space; 并且我们可以通过双值的方式，分别设置想，x，y上的重复方式 example1： background-repeat: space round; background-attachmentbackground-attachment CSS 属性决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。 属性 解释 fixed 此关键字表示背景相对于window窗口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。 local 此关键字表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。 scroll 此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。 fixed的效果：当fixed时，背景图随着容器位置的改变而改变，也就是说背景图是以window位置为基础的（可以想想象为：背景图已经铺满了window，该容器的位置会截取对应位置的一部分作为其背景图）。 local效果：当local时，背景会随着容器的的滚动而滚动，但是其基准任然是容器（随着容器的位置的改变，背景的位置并没有改变） scroll效果：当scroll时，当我们滚动容器时，背景图不会改变；而且当容器位置改变时，背景图也没有发送改变（相对于容器），也就是说，此时背景是以容器为基准的。 给容器添加滚动条height:300px; width:300px; overflow: scroll; 添加此属性后，无论容器的内容是否超过300px，滚动条都会被添加； 如果设置： height:300px; width:300px; overflow: auto; 那么，如果容器的内容超过300px，滚动条才会被添加。 overflow属性同样是一个复合属性。它是overflow-x,overflow-y两个属性的复合属性。同样的是，overflow可以写两个值： overflow: auto scroll; 设置x轴为自动，y轴为添加滚动条时。 Last背景图这一部分的样式很有意思，特别是渐变那一部分，可以组成很多有趣的图形，不过这一部分内容还是多，需要多看多实践，才能深入掌握！","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"background","slug":"background","permalink":"http://yoursite.com/tags/background/"},{"name":"background-color","slug":"background-color","permalink":"http://yoursite.com/tags/background-color/"},{"name":"background-image","slug":"background-image","permalink":"http://yoursite.com/tags/background-image/"},{"name":"background-size","slug":"background-size","permalink":"http://yoursite.com/tags/background-size/"},{"name":"background-origin","slug":"background-origin","permalink":"http://yoursite.com/tags/background-origin/"},{"name":"background-clip","slug":"background-clip","permalink":"http://yoursite.com/tags/background-clip/"},{"name":"background-position","slug":"background-position","permalink":"http://yoursite.com/tags/background-position/"},{"name":"background-repeat","slug":"background-repeat","permalink":"http://yoursite.com/tags/background-repeat/"},{"name":"background-attachment","slug":"background-attachment","permalink":"http://yoursite.com/tags/background-attachment/"}]},{"title":"CSS3-边框","slug":"CSS3-边框","date":"2019-10-19T14:09:49.000Z","updated":"2019-10-21T08:30:44.030Z","comments":true,"path":"2019/10/19/CSS3-边框/","link":"","permalink":"http://yoursite.com/2019/10/19/CSS3-%E8%BE%B9%E6%A1%86/","excerpt":"","text":"引言之所以想到重学CSS3，是因为最近在看《CSS揭秘》一书时，在发现原来CSS3的内容有很多当时没有深入去琢磨，只是简单学习了其基础用法。下面就通过其一些高级用法来深入的研究一下CSS3的内容。 该内容分为： 边框 背景 文本效果 字体 2D、3D转换 过渡 动画 多列、用户界面（盒尺寸、轮廓） 媒体查询 CSS边框border-radiusborder-radius参数解析该属性与padding、margin相同，可以有1、2、3、4个值，所以复习一次： Example1: border-radius:10px; 四个角的弧度相同，均为10px。 Example2: border-radisu:10px 50px; 左上、右下弧度为10px，左下、右上弧度为50px。 Example3: border-radius:10px 50px 100px; 左上弧度10px，右上、左下弧度50px，右下弧度100px。 Example4: border-radius:10px 50px 100px 200px; 左上、右上、右下、左下弧度分别为：10px 50px 100px 200px; 实际上border-radius是一个简写属性，它是下面四个属性的简写： border-top-left-radius border-top-right-radius border-bottom-left-radius border-bottom-right-radius 所以也可以直接单独设置每个角的值。 border-radius参数单位border-radius参数可以为： 绝对值，比如px,em,rem等。 相对值，百分比值（参数为height、width） border-radius参数意义 这个值实际上就是这个圆角的半径值。 如果是百分比值，则通过这个容器的height\\width算出对应的值。 border-radius配置一个圆角两侧的不同弧度如上图所说，如果按照普通配置，圆角就是在容器的一角形成一个圆，将其1/4作为其圆角。 实际上我们可以分别配置一个圆角的两侧的弧度。即，将一个椭圆的1/4圆作为容器的圆角。 borde-radius:x1 x2 x3 x4/y1 y2 y3 y4; 等价于: border-top-left-radius: x1 y1; border-top-right-radius: x2 y2; border-bottom-right-radius: x3 y3; border-bottom-left-radius: x4 y4; 当然，/前后的属性可以简写： 一个值： borde-radius:x1/y1; 等价于： border-top-left-radius: x1 y1; border-top-right-radius: x1 y1; border-bottom-right-radius: x1 y1; border-bottom-left-radius: x1 y1; 两个值： borde-radius:x1 x2/y1 y2; 等价于： border-top-left-radius: x1 y1; border-top-right-radius: x2 y2; border-bottom-right-radius: x2 y1; border-bottom-left-radius: x2 y2; /前后的值是配置的是每个角的x半径、y的半径。可以为1，2，3，4个值，原理和上面一样。 border-radius高级应用基础用法-圆角.div{ height: 500px; width: 900px; border: 3px solid red; bakcground-color: brown; border-radius: 20px; } 圆形、椭圆圆形（容器的height、width必须相同，height、width的值即为圆的直径） .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-radius: 50%; } 椭圆（height、width即为该椭圆的x轴、y轴的直径） .box{ margin: 20px; height: 500px; width: 700px; border: 3px solid red; background: brown; border-radius: 50%; } 标签图形 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-bottom-right-radius: 50% 100px; border-bottom-left-radius: 50% 100px; } 烧杯 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-bottom-right-radius: 100px 100px; border-bottom-left-radius: 100px 100px; } 树叶 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-radius: 0 100% / 0 100%; } border-radius总结 实际上只要是包含圆角的图形我们都可以通过border-radius来构造，通过多个元素的+定位+圆角来构成图形。 box-shadowbox-shadow参数解析 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 基础用法： box-shadow:10px 10px 10x 10px blue; 值得注意的是： box-shadow的值允许有多组值。 example1: box-shadow: 10px 10px 10px 10px blue,20px 20px 20px 20px black; 高级应用-作为边框如果我们将blur值设为0，即不模糊，再将其h-shadow、v-shadow设置为0，即不偏移，即可将其设置边框。 example2: box-shadow: 0 0 0 10px blue； 再利用可以添加多个边框的性质，即可实现多边框。 box-shadow: 0 0 0 10px blue, 0 0 0 20px black; outlineoutline在元素外部绘制一条线。 outline:outline-color,outline-style,outline-width; 值 描述 outline-color 规定边框的颜色。 outline-style 规定边框的样式。 outline-width 规定边框的宽度。 inherit 规定应该从父元素继承 outline 属性的设置。 example: outline: greenyellow 5px solid; outline也是一个简写属性，即为：outline-color、outline-style、outline-width的简写。outline-style的风格繁多。 值 描述 none 默认。定义无轮廓。 dotted 定义点状的轮廓。 dashed 定义虚线轮廓。 solid 定义实线轮廓。 double 定义双线轮廓。双线的宽度等同于 outline-width 的值。 groove 定义 3D 凹槽轮廓。此效果取决于 outline-color 值。 ridge 定义 3D 凸槽轮廓。此效果取决于 outline-color 值。 inset 定义 3D 凹边轮廓。此效果取决于 outline-color 值。 outset 定义 3D 凸边轮廓。此效果取决于 outline-color 值。 inherit 规定应该从父元素继承轮廓样式的设置。 注意，还有一个与outline相关的属性-&gt;outline-offset，该属性可以为负值 利用outline的虚线轮廓与outline-offset可以实现缝线风格的边框。 缝线风格outline:greenyellow 2px dashed; outline-offset: -10px; border-image注意： 在大多数浏览器下，要应用border-image，必须要先设置边框border属性 当border-image存在且其第一个参数border-image-source不为none时，border-style属性将不会生效，若border-image-source为none，则border-style生效 border-image参数 值 描述 border-image-source 用在边框的图片的路径。 border-image-slice 图片边框向内偏移。 border-image-width 图片边框的宽度。 border-image-outset 边框图像区域超出边框的量。 border-image-repeat 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。 example: .box { margin: 200px; height: 500px; width: 500px; border: 100px solid transparent; background: rgb(243, 103, 103); border-image: url(&apos;/bg.png&apos;) 30% 20%/2/1 repeat; } 注意参数的格式： border-image:border-image-source border-image-slice/border-image-width/border-image-outset border-image-repeat 接下来解析一下这几个参数 border-image-source解释：第一个参数，图片地址，这个不用解释。 border-image-slice解释：第二个参数，图片边框向内偏移，即从何处裁剪背景图片。 example: border-image: url(&apos;/bg.png&apos;) 33% 20% 50% 10% repeat; //省略其他参数 该参数的个数与padding,margin相同，四参数则为上右下左的顺序，三参数则为上下、左、右，两参数则为上下、左右、一参数则全相同 border-image-width解释：第三个参数，规定border-image的宽度，被borer-width也会被相应的缩放以适应border-iamge宽度。单位为倍数，2则为被border-image-slice切割后图片的2倍，0.3则为原来的0.3倍。 example: border-image: url(&apos;/bg.png&apos;) 33%/1/0 round;//默认该参数为1 改变参数为2、0.3 border-image: url(&apos;/bg.png&apos;) 33%/2/0 round; border-image: url(&apos;/bg.png&apos;) 33%/0.2/0 round; 注意，这个参数并不会实际改变border-width中定义的宽度，如果该属性增加，则会向容器内部扩展 border-image-outset解释：该属性会将border-image向外偏移一定量。单位任然是倍数，默认为0，即占据border的位置，向外扩展0倍，1代表增加1倍，即直接与容器的border连接。向外扩展1倍。2倍则偏移两倍，则会在容器外部与边框相距边框的距离。 默认值为0： border-image: url(&apos;/bg.png&apos;) 33%/1/0 round; 变为1： border-image: url(&apos;/bg.png&apos;) 33%/1/1 round; 变为2： border-image: url(&apos;/bg.png&apos;) 33%/1/2 round; 变为0.5： border-image: url(&apos;/bg.png&apos;) 33%/1/0.5 round; 注意这里border-image向外偏移了0.5，即占据了border的一半width。 border-image-repeat解释：该属性用于如何分布border-image-slice切割后的部分该如何组合分布在边框上。它含有以下属性： 值 描述 stretch 默认值。拉伸图像来填充区域 repeat 平铺（repeated）图像来填充区域。 round 类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域。 space 类似 repeat 值。如果无法完整平铺所有图像，扩展空间会分布在图像周围 initial 将此属性设置为默认值。 inherit 从父元素中继承该属性。 特别解释一下： tretch只会将剪切过后的图片放置一张在边框位置，然后拉伸以适应边框的长度。 repeat会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽大于border-width，居中后将多余的部分隐藏在两侧。 round会将多个切割后的图片组合放在边框位置，并且组合后的图片长/宽小于border-width，然后会缩放切割图片以适应长（宽）度。 space会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽小于border-width，多余的部分会空出来，如果有背景色，则用背景色填充。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"border-radius","slug":"border-radius","permalink":"http://yoursite.com/tags/border-radius/"},{"name":"box-shadow","slug":"box-shadow","permalink":"http://yoursite.com/tags/box-shadow/"},{"name":"border-image","slug":"border-image","permalink":"http://yoursite.com/tags/border-image/"}]},{"title":"javaee之spring框架总结","slug":"javaee之spring框架总结","date":"2019-08-09T08:36:31.000Z","updated":"2019-08-09T08:38:51.988Z","comments":true,"path":"2019/08/09/javaee之spring框架总结/","link":"","permalink":"http://yoursite.com/2019/08/09/javaee%E4%B9%8Bspring%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","excerpt":"前言spring作为目前最流行，应用最广泛的后端框架，它有着许多优点与特色，比如应用它IOC（控制翻转）的功能以及spring内部的封装，可以与hibernate，struts进行整合，这里只是简单的介绍其主要功能。","text":"前言spring作为目前最流行，应用最广泛的后端框架，它有着许多优点与特色，比如应用它IOC（控制翻转）的功能以及spring内部的封装，可以与hibernate，struts进行整合，这里只是简单的介绍其主要功能。 springIOCIOC内部原理IOC内部使用了映射的原理： &lt;bean id = &quot;userService&quot; class=&quot;cn.itcast.UserService&quot;/&gt; 内部原理如下： //解析dom4j解析xml文件得到class属性值 String classValue = &quot;class属性值&quot;; //使用反射创建类对象 Class clazz = Class.forName(classValue); //创建类对象 UserService service = clazz.newInstance(); return service; Bean实例化类的无参构造方式&lt;bean id=&quot;user&quot; calss=&quot;cn.itcast.ioc.User&quot;&gt;&lt;/bean&gt; 类的静态工厂方法类方法： public class Bean2Factory{ public static Bean2 getBean2(){ return new Bean2(); } } 配置文件： &lt;bean id=&quot;bean2&quot; class=&quot;cn.itcast.bean.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt; 类的实例工厂方法类方法： public class Bean3Factory{ public Bean3 getBean3(){ return new Bean3(); } } 配置文件： &lt;bean id=&quot;bean3Factory&quot; class=&quot;cn.itcast.bean.Bean3Factory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;&gt; 获取实例化对象//加载配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //获取实例 User user = (User) context.getBean(&quot;user&quot;); Bean标签的常用属性 id属性：对这个bean的属性名，获取该bean的实例时所需的名字。 class属性：创建对象所在类的全路径。 name属性：功能与id属性一样，id属性不能包含特殊字符，但是在name属性值里面可以包含特殊字符。 scope属性：单实例与否。 singleton：默认值，单实例 prototype：多实例 属性注入使用构造函数注入bean： public class PropertyDemo1{ pubcli PropertyDemo1(String username){ this.username= username; } } 配置文件： &lt;bean id=&quot;demo&quot; class=&quot;cn.itcast.property.PropertyDemo1&quot;&gt; &lt;construct-arg name=&quot;username&quot; value=&quot;谁谁谁&quot;&gt;&lt;/construct-arg&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); PropertyDemo1 demo = (demo) context.getBean(&quot;demo&quot;); System.out.println(demo.username); 使用set方法注入bean： class setBookname{ private String bookname; public void setBookname(String bookname){ this.bookname = bookname; } } 配置文件： &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.property.Book&quot;&gt; &lt;property name=&quot;bookname&quot; value=&quot;嘿嘿嘿&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); setBookname book = (book) context.getBean(&quot;book&quot;); System.out.println(book.bookname); 注入对象类型属性UserDao： public class UserDao{ public test(){ System.out.print(&quot;test...&quot;); } } UserService： public class UserService{ private UserDao userDao; public void setUserDao(User userDao){ this.userDao = userDao; } } 配置文件： &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt; //id为类中的属性名 //ref值与生成的bean的id值相同 &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.userDao.test(); 注入数组，list集合，map集合，properties类型属性&lt;bean id=&quot;person&quot; class=&quot;cn.itcast.property.Person&quot;&gt; &lt;!-- 数组 --&gt; &lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- list --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;小奥&lt;/value&gt; &lt;value&gt;小金&lt;/value&gt; &lt;value&gt;小普&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- map --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aa&quot; value=&quot;lucy&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;bb&quot; value=&quot;mary&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;cc&quot; value=&quot;tom&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- properties --&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverclass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; IOC注解方式 在spring配置文件中引入约束： xmlns:context=”http://www.springframework.org/schema/context&quot; xsi:schemaLocation=” http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; 在配置文件中开启注解扫描 //base-package：需要扫描注解的包 &lt;context:component-scan base-package=”cn.itcast”&gt;&lt;/context:component-scan&gt; 创建注解对象在bean中类的上方加上注解：@Component(value=&quot;...&quot;) bean： @Component(value=&quot;user&quot;) //等价于&lt;bean id=&quot;user&quot; class=&quot;...&quot;&gt; public class User{ public test(){ System.out.println(&quot;got it!&quot;); } } 调用： public class test( ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); user.test(); //got it! } 可以了解的是，spring提供了4个注解关键字来实例化bean，其中后3个是Componnet的衍生： @Component:都可以使用 @Controller: web层 @Service: 业务层 @Repository: 持久层 注解确定单、多实例@Scope(value=&quot;prototype&quot;) //多实例 @Scope(value=&quot;singleton&quot;) //单实例 注解注入属性注入基本类型@Value(value) bean: public class test{ @Value(&quot;谁谁谁&quot;) private String username; @Value(123) private int userid; } 不过我们想向本类中注入值的情况比较少，掌握即可 注入属性对象类型 @Autowired:自动检测属性并注入，前提是这个属性对象已经通过spring创建了对象实例，配置文件方式或注释方法都可以。 Resource(name=”对象名”)，对象名是通过spring创建的实例id值或name值 创建属性实例 @Component(value=”userDao”) class userDao{ } 注入属性的两种方式 @Autowired private UserDao userDao; @Resource(name=&quot;userDao&quot;) Private UserDao userDao; 配置文件与注解混合使用可以在配置文件中声明对象的属性类，然后在对象中通过注解注入属性。 配置文件： &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; 类： @Resource(name=&quot;bean0&quot;); private Bean0 bean0; @Resource(name=&quot;bean1&quot;); private Bean0 bean1; spring中的AOP名词解释 Joinpoint(连接点)：类里面可以被增强的方法，这些方法被称为连接点。 Ponitcut(切入点)：所谓切入点是指我们要对哪些Joinpoint进行拦截。 Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Aspect(切面): 是切入点和通知（引介）的结合 增强：增强的逻辑，成为增强，包含以下类型： 前置通知：在方法之前执行 后置通知：在方法之后执行 异常通知：在方法出现异常时执行 最终通知：在后置通知之后执行 环绕通知：在方法之前和之后执行配置文件 引入xml命名空间 http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd 使用表达式配置切入点(实际增强的方法) 表达式： execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* cn.itcast.aop.Book.add(…)) execution( cn.itcast.aop.Book.(..)) execution( .*(..)) 匹配..开头的方法 execution( save(..)) AspectJ的aop操作 AspectJ不是spring的一部分，和spring一起使用aop操作。 spring2.0以后新增了对AspectJ的支持。 AspectJ可以用配置文件或注释文件。 配置对象 配置aop操作 aop:config //配置切入点 &lt;aop:pointcut expression=&quot;execution(* cn.itcast.aop.Book.*(..))&quot; id=&quot;pointcut1&quot;&gt; //配置切面，将增强用到切入点上 &lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:aspect&gt; &lt;/aop:config&gt; 值得注意的是： aop:point标签是在配置切入点，即哪些方法需要被增强，其中expression为表达式，id为自定义名称。 aop:aspect标签是在配置切面，即用哪些增强(方法)来增强切入点。 在aop:aspect内部标签表示的是增强的方式。包含以下标签： aop:before 前置通知 aop:after-returning 后置通知 aop:around 环绕通知 aop:after-throwing 异常通知 aop:after 最终通知 AspectJ的注解AOP操作 创建对象 &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt; 在spring核心配置文件中，开启aop操作 aop:aspectj-autoproxyaop:aspectj-autoproxy 在增强类上使用注解完成aop操作 @Aspect public class MyBook{ @Before(value=&quot;execution(* cn.itcast.aop.Book.*(..))&quot;) public void before1(){ System.out.print(&quot;before........&quot;); } } sping的jdbcTemplate操作 设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(“com.mysql.jdbc.Driver”); dataSource.setUrl(“jdbc.mysql:///database0”); dataSource.setUsername(“root”); dataSource.setPassword(“root”); 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); 创建sql语句，并执行jdbcTemplate中的方法 增加 String sql = “insert into user value(?,?)”;int rows = jdbcTemplate.update(sql,”lucy”,”250”); 修改 String sql = “update user set password =? where username=?”;int rows = jdbcTemplate.update(sql,”1234”,”lucy”); 删除 String sql = “delete from user where username=?”;int rows = jdbcTemplate.update(sql,”lucy”); 查询 //返回对象String sql = “select * from user where username=?”;User user jdbcTemplate.queryForObject(sql,new MyRowMapper(),”mary”);System.out.println(user); //实现RowMapperclass MyRowMapper implements RowMapper{ @Override public User mapRow(Result re, int num) throws SQLException{ String username= rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); User user = new User(); user.setUsername(username); user.setPassword(password); }} //返回list String sql = &quot;select * from user&quot;; List&lt;User&gt; list = jdbcTemplate.query(sql,new MyRowMapper()); System.out.println(list); Spring配置c3p0连接池和dao使用jdbcTemplate因为配置jdbcTemplate数据库的数据库信息实际上还是创建对象，注入属性。所以同样可以用Spring的AOP进行对象的创建。 导入c3p0以及配合的jarbao 配置c3p0连接池 dao使用jdbcTemplate 创建service和dao，配置service和dao对象，并把service注入dao对象 &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c3p0.UserService&quot;&gt; &lt;proerpty name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c3p0.UserDao&quot;&gt; 2. 创建jdbcTemplate对象 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate){ this.jdbcTemplate = jdbcTemplate; } 3. 把模板对象注入dao中 &lt;bean id=&quot;userDao&quot; class=&quot;class.itcast.c3p0.UserDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; 4. 在jdbcTemplate对象里注入dataSource private DataSource dataSource; privateSQLExceptionTranslator exceptionTranslator; private boolean lazyInit = true; public void setDataSource(DataSource dataSource){ this.dataSource = dataSource; } &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;bean&gt; spring的事务管理xml方式 在核心配置文件中配置事务管理器 配置事务增强 &lt;tx:advice id=”txadvice” transaction-manager=”transactionManager”&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;account*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; tx:advice 配置切面 aop:config &lt;aop:pointcut expression=&quot;execution(* cn.itcast.service.OrderService.*(..))&quot; id=&quot;pointcut1&quot;&gt; &lt;aop:adviser advice-ref=&quot;txadvice&quot; point=ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; 注解方式 配置事务管理器 开启事务注解 &lt;tx:annotation-driven transaction-manager=”transactionManager”/&gt; 在需要使用事务的方法所在类上面添加注解 @Transactional public class ordersService{ } Last这里的内容多是视频教学笔记中的内容加上我自己的理解，只是不是很深，只是一个最基本的用法，并且省去了配置环境的问题，比如导入jar包等等，这里面可能有很多错误或不足，因为我也是才开始接触。加油加油！","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/tags/JavaEE/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"javaee之hibernate框架总结","slug":"javaee之hibernate框架总结","date":"2019-08-08T10:09:11.000Z","updated":"2021-03-08T02:55:58.693Z","comments":true,"path":"2019/08/08/javaee之hibernate框架总结/","link":"","permalink":"http://yoursite.com/2019/08/08/javaee%E4%B9%8Bhibernate%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","excerpt":"前言Hibernate目前使用的还是比较多，虽然不及mybatis。 Hibernate概述Hibernate工作在javaEE三层结构中的dao层，对数据库进行crud操作，其核心思想是orm（object relational mapping，对象关系映射），并且Hibernate支持多种查询方式，包括HQL，QBC,SQL三种方式。 orm 让实体类和数据库表进行一一对应关系 让实体类首先和数据库表对应 让实体类属性 和 表里面字段对应 不需要直接操作数据库表，而操作表对应实体类对象","text":"前言Hibernate目前使用的还是比较多，虽然不及mybatis。 Hibernate概述Hibernate工作在javaEE三层结构中的dao层，对数据库进行crud操作，其核心思想是orm（object relational mapping，对象关系映射），并且Hibernate支持多种查询方式，包括HQL，QBC,SQL三种方式。 orm 让实体类和数据库表进行一一对应关系 让实体类首先和数据库表对应 让实体类属性 和 表里面字段对应 不需要直接操作数据库表，而操作表对应实体类对象 配置文件Hibernate的核心配置文件有如下要求： 必须在src下 必须为hibernate.cfg.xml 配置核心文件 引入约束 12&lt;!DOCTYPE hibernate-configuration PUBLIC&quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot;&quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt; 配置信息 123456789101112131415161718192021222324252627&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 第一部分： 配置数据库信息 必须的 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;&#x2F;hibernate_day01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt;&lt;!-- 第二部分： 配置hibernate信息 可选的--&gt; &lt;!-- 输出底层sql语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 输出底层sql语句格式 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- hibernate帮创建表，需要配置之后 update: 如果已经有表，更新，如果没有，创建 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 配置数据库方言 在mysql里面实现分页 关键字 limit，只能使用mysql里面 在oracle数据库，实现分页rownum 让hibernate框架识别不同数据库的自己特有的语句 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第三部分： 把映射文件放到核心配置文件中 必须的--&gt; &lt;mapping resource&#x3D;&quot;cn&#x2F;itcast&#x2F;entity&#x2F;User.hbm.xml&quot;&#x2F;&gt;&lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 值得注意的是： 配置数据库信息部分与jdbc部分的配置信息一致 hibernate.show_sql： 在编译时控制台输出生成的SQL语句 hibernate.format_sql : 在上面的属性开启的前提之下输出格式化之后的SQL语句 hibernate.hbm2ddl.auto : 配置数据库方言在mysql里面实现分页 关键字 limit，只能使用mysql里面在oracle数据库，实现分页rownum让hibernate框架识别不同数据库的自己特有的语句 配置映射文件映射文件是一个表与实体的配置映射 命名没有确定规则 位置也没有确定位置 引入约束 &lt;!DOCTYPE hibernate-configuration PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN” “http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 配置映射关系 12345678910&lt;hibernate-mapping&gt; &lt;class name&#x3D;&quot;priv.mw.dao&quot; table&#x3D;&quot;t_user&quot;&gt; &lt;id name&#x3D;&quot;uid&quot; column&#x3D;&quot;uid&quot;&gt; &lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;password&quot; column&#x3D;&quot;username&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;class&gt; &lt;&#x2F;hibernate-mapping&gt; 值得注意的是： hibernate-mapping package:填写包名，如果此处填写了完整的包名，则后面class的name属性只需要填写class名字。否则class的name属性则需要填写完整的名字，及包含包名的类名。 class name：填写类名（全路径或名字） table：数据库中表名。（orm中表与类一一对应） id：每一张表必须要有一个唯一的属性。 name：类中属性的名字 column：为表中列的名字 property:表中的属性 name:类中的属性名 column：表中的列名 值得注意的是： id或property中的column是可选的，如果不填，则默认与name属性相同。 实体类的编写规则 实体类中的属性是私有的 私有属性使用公开的set和get方法 要求实体类有属性作为唯一值(一般使用id值) 实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类，其目的是Integer score = null。可以表示不存在这个值，而基本类不能为null。 主键的生成策略 native：自动增长 uuid：uuid算法 CRUDsession方式 加载核心配置文件 加载SessionFactory对象 使用SessionFactory对象创建session对象 开启事务 开始写具体逻辑，crud操作 提交事务 关闭资源 12345678910111213141516171819202122232425262728public test()&#123; //1. 加载hibernate核心配置文件 //这一步从src中查找hibernate.cfg.xml Configuration cfg = new Configuration(); cfg.configure(); //2. 创建SessionFactory对象 //同时读取映射文件，创建表格 SessionFactory sessionFactory = cfg.buildSessionFactory(); //3. 创建Session对象 Session session = session.openSession(); //4. 开启事物 Transaction tx = session.beginTransaction(); //5. 写入具体的crud操作 User user = new User(); user.setUsername(\"李雷\"); user.setPassword('123'); user.setAddress(\"日本\"); session.save(user); //6. 提交事务 tx.commit(); //7. 关闭资源 session.close(); sessionFactory.close(); } session对象导航查询常用的方法： get():通过OID 从数据库中抓取数据，并把数据加载到一个新实例对象上。 save():执行insert语句，当数据库存在这条记录时，会抛出异常。 saveOrUpdate():如果数据库中不存在该数据，则执行insert语句，如果存在则执行更新操作。 update():当数据库中存在这条记录时，Hibernate 总会执行一条SQLUPDATE 语句；当数据库中不存这条记录时，就会抛出异常。 delete():当数据库中存在这条记录时，Hibernate 总会执行一条SQLDELETE 语句；当数据库中不存这条记录时，就会抛出异常。 load():该方法与get相同，但是不会立即去查询数据库，而是等待需要使用该数据时才去查询。比如用ID查询ID，get方法任然回去查询数据库，而load则直接返回使用的ID，不去查询数据库。 实体对象三种状态 瞬时状态(Transident):如果对象从未与Session对象关联过，称该对象处于瞬时状态（或临时状态）。 持久状态(Persisdent):如果对象与Session对象关联起来，且该对象对应到数据库记录，则称该对象处于持久化状态。比如通过get获取的对象。 游离状态(Detached)：当持久化对象的Session关闭后，这个对象就会从持久化状态改变成游离状态。 HQL方式example： 12Query query = session.createQuery(\"from Customer where name=?\");query.setParameter(\"mw\"); 条件查询： from Customer c where c.cid=? and c.custName=? 模糊查询 from Customer c where s.custName like ? 排序查询 from Customer order by cid desc 分页查询 Query query = session.createQuery(“from Customer”); query.setFirstResult(0); query.setMaxReaults(3); List list = query.list(); 投影查询:查询不是所有字段值，而是部分字段的值 Query query = session.createQuery(“select cusName from Customer”); List list = query.list(); for(Object object : list){ Systom.out.println(Object); } 聚集函数使用 Query query = session.createQuery(&quot;select count(*) from Customer&quot;); object obj = query.uniqueResult(); Long lobj = (Long)obj; int count = lobj.intValue(); 内连接查询（返回list）：选取两张表的外键相同的数据返回。 Query query = session.createQuery(“from Customer c inner join c.setLinkMan”) 迫切内连接（返回对象） Query query = session.createQuery(&quot;from Customer c inner join fetch c.setLinkMan&quot;) 左外连接（返回list）：返回左侧表中的所有数据以及右侧与之外键相同的的数据。 Query query = session.createQuery(“from Customer c left outer join c.setLinkMan”); 迫切左外连接（返回对象） Query query = session.createQuery(&quot;from Customer c left outer join fetch c.setLinkMan&quot;); 右外连接：返回左右侧表中的所有数据以及左侧与之外键相同的的数据。 Query query = session.createQuery(“from Customer c right outer join s.setLinkMan”); QBC方式调用Criteria的方法实现查询 查询所有 Criteria criteria = session.createCriteria(Customer.class); List list = criteria.list(); 条件查询 Criteria criteria = session.createCriteria(Customer.class); cretera.add(Restrictions.eq(“cid”,1)); critera.add(Restrictions.eq(“custName”,”someone”)); List list = criteria.list(); cretiria.add(Restrictions.like(“custName”,”%s%”)); 排序查询 Criteria criteria = session.createCriteria(Customer.class); cretiria.addOrder(Order.desc(“cid”)); 分页查询 Criteria criteria = session.createCriteria(Customer.class); criteria.setFirstResult(0); criteria.setMaxResult(3); 统计查询 Criteria criteria = session.createCriteria(Customer.class); criteria.setProjection(Projections.rowCount()); Object obj = criteria.uniqueResult(); Long lobj = (Long) obj; int count = lobj.intValue; 离线查询：不通过session对象来创建查询对象，即可以在dao层session对象关闭后也能执行查询。一般用在多条件查询直接在service层进行离线查询。 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class); Criteria criteria = detachedCriteria.getExecutableCriteria(session); List list = criteria.list(); hibernate一对多操作这里的一对多其实就是SQL中一对多的概念，不过我们在学习如何在hibernate中来使用这个概念。 以客户，联系人为例： 创建两个实体类，客户、联系人 让连个实体之间相互表示，即将对方对象作为一个自己的一个私有属性，并设置set,get方法。 在客户实体类里面表示多个联系人 private Set setLinkMan = new HashSet(); public Set getSetLinkMan(){ return setLinkMan;} public void getSetLinkMan(Set setLinkMan){ this.setLinkMan = setLinkMan;} 在联系人实体类里面表示所属客户 private Customer customer; public Customer getCustomer(){ return customer;} public void setCustomer(Customer customer){ this.customer = customer;} 配置客户映射关系 //在客户映射文件中，表示联系人 //使用set标签表示所有联系人 //set中name为联系人中的set集合名称 //column为外键名称 //class中写联系人的实体全路径 配置联系人映射文件 //name：在联系人实体中的客户属性的名字 //class：联系人class的全路径 //column：外键名称 配置核心配置文件 resource：映射文件的路径名称 &lt;mapping resource=&quot;cn/itcast/entuty/Customer.hbm.xml&quot;&gt; &lt;mapping resource=&quot;cn/itcast/entuty/LinkMan.hbm.xml&quot;&gt; 一对多级联保存123456789101112131415Customer customer = new Customer();customer.setCustName(\"百度\");customer.setCustLevel(\"普通客户\");customer.setCustSource(\"网络\");customer.setCustPhone(\"110\");customer.setCustMobile(\"999\");LinkMan linkman = new LinkMan();linkman.setLkm_name(\"小宏\");linkman.setLkm_gender(\"男\");linkman.setLkm_phone(\"911\");//2 把联系人放到客户里面customer.getSetLinkMan().add(linkman);//3 保存客户session.save(customer); 一对多级联删除删除某个客户，把客户里面所有的联系人删除 需在set中配置cascade属性： 12345&lt;set name=\"setLinkMan\" cascade=\"save-update,delete\"&gt;Customer customer = session.get(CUstomer.class,3);session.delete(customer); 一对多级联更新123456789101112//根据id查询Lucy联系人，客户百度Customer baidu = session.get(Customer.class,1);//设置持久态对象Customer lucy = session.get(LinkMan.class,2);//把联系人放入客户对象中baidu.getSetLinkMan().add(lucy);//把客户放到联系人中lucy.setCustomer(baidu); 值得注意的是： 在默认转态下，两个对象都会维护这个关系。所以会执行两次SQL语句。为了解决这个问题，可以在set中配置inverse属性，让某一方放弃维护。 inverse: false不放弃维护 true放弃维护 hibernate多对多实际上我们在比较少用多对多关系，会将其转化为两个一对多关系。 以用户和角色为例： 创建实体类，用户和角色 让两个实体类相互表示 一个用户有多个角色，使用set集合 123456789101112131415161718192021Private Set&lt;Role&gt; setRole = new HashSet&lt;Role&gt;(); public Set&lt;Role&gt; getSetRole()&#123; return setRole;&#125; public void setSetRole(Set&lt;Role&gt; setRole)&#123; this.setRole = setRole;&#125; 2. 一个角色有多个用户，使用set集合 private Set&lt;User&gt; setUser = new HashSet&lt;User&gt;(); public Set&lt;User&gt; getSetUser()&#123; return setUser;&#125; public void setSetUser(Set&lt;User&gt; setUser)&#123; this.setUser =setUser;&#125; 配置映射关系 在用户里面表示所有角色，使用set标签 在角色中表示所有用户，使用set标签 在核心配置文件中引入映射文件 多对多级联保存任然需要在set中配置cascade &lt;set name=&quot;setRole&quot; table=&quot;user_role&quot; cascade=&quot;save-update,delete&quot;&gt; 实体类中代码： 1234567891011121314151617181920212223242526272829303132User user1 = new User();user1.setUser_name(\"lucy\");user1.setUser_password(\"123\");User user2 = new User();user2.setUser_name(\"mary\");user2.setUser_password(\"456\");Role r1 = new Role();r1.setRole_name(\"总经理\");r1.setRole_memo(\"总经理\");Role r2 = new Role();r2.setRole_name(\"秘书\");r2.setRole_memo(\"秘书\");Role r3 = new Role();r3.setRole_name(\"保安\");r3.setRole_memo(\"保安\");//2 建立关系，把角色放到用户里面// user1 -- r1/r2user1.getSetRole().add(r1);user1.getSetRole().add(r2);// user2 -- r2/r3user2.getSetRole().add(r2);user2.getSetRole().add(r3);//3 保存用户session.save(user1);session.save(user2); 多对多级联删除1234&lt;set name=\"setRole\" table=\"user_role\" cascade=\"save-update,delete\"&gt;User user = session.get(User.class,1);session.delete(user); 多对多级联更新12345678User lucy = session.get(User.class,1);Role role = session.get(Role.class,1);//为用户添加角色lucy.getSetRole().add(role);//把用户角色删除lucy.getSetRole().remove(role); hibernate缓存hibernate为了增加查询效率，建立了缓存机制。即在查询到某个数据后，则将其存储到内存中，下一次查询时直接获取内存中的数据，不用向数据库查询，直接获取，加快查询速度。 hibernate的一级缓存默认打开的 hibernate的一级缓存使用范围，是session范围，3. hibernate的一级缓存中，存储数据必须 持久态数据 hibernate事务与SQL的事务一致，保证一系列工作的全部执行。具有以下特性： 原子性： 确保工作单元中的所有操作都成功完成; 否则，该事务被中止的故障点，操作回滚到操作之前的状态。 一致性：确保数据库正确后成功提交事务更改状态。 隔离性：事务操作彼此独立和透明。 持久性：可确保提交的事务的结果或仍然存在系统故障的情况下的作用。 try { 开启事务 提交事务}catch() { 回滚事务}finally { 关闭} 12345678910111213141516171819202122232425262728293031public void testTx() &#123; SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; try &#123; sessionFactory = HibernateUtils.getSessionFactory(); session = sessionFactory.openSession(); //开启事务 tx = session.beginTransaction(); //添加 User user = new User(); user.setUsername(\"小马\"); user.setPassword(\"250\"); user.setAddress(\"美国\"); session.save(user); int i = 10/0; //提交事务 tx.commit(); &#125;catch(Exception e) &#123; e.printStackTrace(); //回滚事务 tx.rollback(); &#125;finally &#123; //关闭操作 session.close(); sessionFactory.close(); &#125;&#125; 通过session.beginTransaction()获取Transaction对象。 最后这个说明只是一个简单的概述，根据黑马程序员2016年版的笔记总结而来，肯定不是全部的，但是这个足够进行简单的操作。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/tags/JavaEE/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"hibernate","slug":"hibernate","permalink":"http://yoursite.com/tags/hibernate/"}]},{"title":"javaee之struts框架总结","slug":"javaee之struts框架总结","date":"2019-08-08T00:32:52.000Z","updated":"2019-08-08T10:15:24.283Z","comments":true,"path":"2019/08/08/javaee之struts框架总结/","link":"","permalink":"http://yoursite.com/2019/08/08/javaee%E4%B9%8Bstruts%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","excerpt":"前言最近在了解后端开发框架，所以先从SSH（Struts，Spring，Hibernate）开始，因为在企业级开发中SSH任然在使用，所以还是有必要了解一下，后面再详细学习SSM（Spring MVC，Spring，mybatis），目前互联网企业中大多都在使用SSM。","text":"前言最近在了解后端开发框架，所以先从SSH（Struts，Spring，Hibernate）开始，因为在企业级开发中SSH任然在使用，所以还是有必要了解一下，后面再详细学习SSM（Spring MVC，Spring，mybatis），目前互联网企业中大多都在使用SSM。 这一期先介绍struts。 strutsstruts介绍struts是一个工作在表示层，负责与JSP页面实现交互，将用户的请求委派给相应的Action处理。 配置过滤器在web-app内添加如下内容： &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 创建action方法一 直接创建Actionpublic class Democlass{ public String execute(){ return &quot;none&quot;; } } 方法二 继承ActionSupport类（最常用）public class Democlass extends ActionSupport{ public String execute(){ return &quot;none&quot;; } } 方法三 实现接口Actionpublic class Democlass implements Action{ public String execute(){ return &quot;none&quot;; } } 配置文件配置文件必须是命名为struts.xml，并且位于src目录下。 引入dtd约束&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; 配置action&lt;package name=&quot;methoddemo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;&quot; class=&quot;cn.itcast.method.BookAction&quot; method=&quot;&quot; &gt; &lt;result name=&quot;ok&quot;&gt;hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 结构为：package-&gt;action-&gt;result package参数： name:（必填）自定义名称 namespace:（可选）命名空间 extends:（可选）该包继承自其它包，一般填struts-default abstract:（可选）该类是否是一个抽象包，抽象包中不能包含Action定义。 action参数： name：（必填）action的标识，在URL访问时后缀为该值。 class：（可选）Action的类的全路径。 method：（可选）指定请求Action时调用的方法，默认为execute方法。 converter：（可选）指定类型转换器的类。 result参数： name：（可选）指定逻辑视图的名称，默认为success。（为指定函数的返回值） type：（可选）指定访问内容的方式，主要有如下方式（默认为dispatcher） dispatcher：页面转发 redirect：页面重定向 chain：action转发 redirectAction：action重定向 global-result如果在action类的方法中，返回了一个字符串，但如果没有配置对应的result，则浏览器会返回404，但是global-result可以匹配任何action中的对应action。 注意：如果action中与global-result同时配置了相同的result。则局部result优先级更高。 &lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; &lt;global-results&gt; action获取表单数据使用ActionContext类获取ActionContext context = ActionContext.getContext(); Map&lt;String,Object&gt; map = context.getParameters(); //使用Map.Entry遍历获取的Map for(Map.Entry&lt;String, Object&gt; entry : map.entrySet()) { System.out.println(entry.getKey()+&quot;--&quot;+Arrays.toString((Object[]) (entry.getValue()))); } 使用SevletActionContext类获取该方法直接获取request对象。 HttpServletRequest request = ServletActionContext.getRequest(); //下面就是调用request了 String para1 = request.getParameter(&apos;para1&apos;); String para2 = request.getParameter(&apos;para2&apos;); String para3 = request.getParameter(&apos;para3&apos;); 使用接口获取requestpublic class Demo implements ServletRequestAware{ @Override public void setServletRequest(HttpServletRequest){ this.request = request; } } 在action中操作域对象struts的域对象与servlet的域对象一样，用于存储数据，在JSP页面中直接获取。 具体用法： request域 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(“key”,”value”); session域 HttpSession session = request.getSession(); session.setAttribute(“key”,”value”); ServletContext域 ServletContext context = ServletAction.getServletContext(); context.setAttribute(“key”,”value”); 属性封装表单提交的数据会自动封装到类实例的属性 一、直接将表单提交的属性封装到action中 在action成员中定义变量 生成变量的set,get方法 private String userName; private String password; private String address; public String getUserName(){ return this.userName; } public String setUserName(String userName){ this.userName = userName; } public String getPassword(){ return this.password; } public String setPassword(String userName){ this.password = password; } public String getAddress(){ return this.address; } public String setAddress(String userName){ this.address = address; } 模型驱动封装(重点) action实现接口ModelDriven 实现接口里面的getModel方法 在action里创建实体类对象 class Demo extends ActionSupport implements ModelDriven{ private User user = new User(); public User getModel(){ return user } } 使用模型驱动封装，一个表单只能封装一个模型驱动封装。 不能同时使用属性封装与模型驱动封装。 表达式封装使用表达式封装是指在表单提交时，name属性则为具体实例的属性（struts有自己的表示方式，比如：User.name） 在action中声明实例类 生成实例类的set与get方法 private User user; public User getUser(){ return user; } public void setUser(User user){ this.user = user } 在表单输入项的name属性里面写表达式形式 username:&lt;\\input type=”test” name=”user.userName”&gt; password:&lt;\\input type=”password” name=”user.password”&gt; address:&lt;\\input type=”text” name=”user.address”&gt; 封装到集合中封装到list集合第一步 在action声明List第二步 生成list变量的set和get方法 private List&lt;User&gt; list; public List&lt;User&gt; getList(){ return list; } public void setList(List&lt;User&gt; list){ this.list = list; } 第三步 在表单输入项中写表达式 username:&lt;input type=&quot;text&quot; name=&quot;list[0].userName&quot;&gt; password:&lt;input type=&quot;password&quot; name=&quot;list[0].password&quot;&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[0].address&quot;&gt; &lt;br/&gt;&lt;br/&gt; username:&lt;input type=&quot;text&quot; name=&quot;list[1].userName&quot;&gt; password:&lt;input type=&quot;password&quot; name=&quot;list[1].password&quot;&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[1].address&quot;&gt; 封装到Map集合第一步 声明map集合第二步 生成get和set方法 private Map&lt;String,User&gt; map; public Map&lt;String,User&gt; getMap(){ return map; } public void setMap(Map&lt;String,User&gt; map){ this.map = map; } username:&lt;input type=&quot;text&quot; name=&quot;map[one].userName&quot;/&gt; password:&lt;input type=&quot;password&quot; name=&quot;map[one].password&quot;/&gt; address:&lt;input type=&quot;text&quot; name=&quot;map[one].address&quot;/&gt; OGNL表达式与EL表达式一样，OGNL表达式可以用来操作值栈。 引用struts标签库//引用标签库 &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt; //操作 &lt;s:property value=&quot;&apos;haha&apos;.length()&quot;&gt; 值栈 在servlet中，我们把数据放到了域对象中，在页面中使用EL表达式获取；域对象同样在一定范围内，存值和取值。 在struts中也提供了一种存储机制，类似与域对象，被称为值栈，也可以存值获取值。 在action中把数据存到值栈中，在页面中获取数据。 servelet和action区别 Servlet：默认在第一次访问创建，创建一次，单实例对象。 Action：访问时创建，每次访问的时候，都会创建一个action对象。所以它是一个多实例对象。 值栈存储在action中。 获取值栈对象ActionContext context = ActionContext.getContext(); ValueStack stack1 = context.getValueStack(); 每一个action只有一个值栈对象。 值栈分为两部分： root：list集合 context：map集合（实际就是action的上下文），包含如下内容： request：HttpRequest对象的引用 session：HttpSession对象引用 application：ServletContext对象的引用 parameters：传递的相关参数 attr：域对象，使用seAttribute(“key”,”value”)存储 可以使用s:debug来查看action的结构 向值栈中存值 使用set方法 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); stack.set(“key”,”value”); 使用push方法 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); stack.push(“something”); 向值栈中存放对象 private User user = new User(); public User getUser(){ return user; } public String excute() throws Exception{ user.setUsername(&quot;lucy&quot;); user.setPassword(&quot;123&quot;); user.setAddress(&quot;美国&quot;); return &quot;success&quot;; } 向值栈中存放list集合 private List list = new ArrayList(); public List getList(){ return list; } public String excute() throws Exception{ User user1 = new User(); user1.setUsername(&quot;lucy&quot;); user1.setPassword(&quot;123&quot;); user1.setAddress(&quot;美国&quot;); User user2 = new User(); user2.setUsername(&quot;tom&quot;); user2.setPassword(&quot;12345&quot;); user2.setAddress(&quot;意大利&quot;); list.add(user1); list.add(user2); return &quot;success&quot;; } 从值栈中取值我们都是用OGNL表达式结合struts标签来获取值栈中的值。 获取字符串&lt;s:property value=&quot;username&quot;/&gt; 获取对象//方法一 &lt;s:property value=&quot;list[0].username&quot;/&gt; &lt;s:property value=&quot;list[0].password&quot;/&gt; &lt;s:property value=&quot;list[0].address&quot;/&gt; &lt;br/&gt; &lt;s:property value=&quot;list[1].username&quot;/&gt; &lt;s:property value=&quot;list[1].password&quot;/&gt; &lt;s:property value=&quot;list[1].address&quot;/&gt; //方法二 &lt;s:iterator value=&quot;list&quot;&gt; &lt;s:property value=&quot;username&quot;/&gt; &lt;s:property value=&quot;password&quot;/&gt; &lt;s:property value=&quot;address&quot;/&gt; &lt;s:iterator&gt; //方法三 &lt;s:iterator value=&quot;list&quot; var = &quot;user&quot;&gt; &lt;s:property value=&quot;#user.username&quot;/&gt; &lt;s:property value=&quot;#user.password&quot;/&gt; &lt;s:property value=&quot;#user.address&quot;/&gt; &lt;s:iterator&gt; 获取set值&lt;s:property value=&quot;key&quot;&gt; 获取push方法&lt;s:property value=&quot;[0].top&quot;&gt; 可以通过debug的方式看出，值栈实际上就是存在context中，作为其属性。 EL表达式可以不去值栈数据EL表达式实际上是增强了getAttribute方法，如果在request中获取到对应的值，则返回该值，否则再到值栈中检索。 OGBL中的#与% # 获取context中的值 &lt;s:property value=”#user.username”/&gt; 获取request中的值 &lt;s:property value=”#request.req”/&gt; % 在struts2标签中表单标签 在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别。 &lt;s:textfield name=&quot;username&quot; value=&quot;%{#request.req}&quot;&gt; struts拦截器struts的拦截器是一种AOP(面向切面编程)思想的实践，通俗的来说就是不改变源代码来实现对原来类或方法的拓展。 而在每次action启动的时，我们都会为每个action方法增加一些拦截器，在action对象创建之后，action方法之前，拦截器的方法得到执行，拦截决定是否放行，然后由下一个拦截器接手继续执行，知道所有拦截器执行完。一旦任何一个拦截器拒绝了，那么后面的拦截也都不会执行了。 拦截器与过滤器 过滤器：理论上可以过滤任意内容，包括html,jsp,servlet… 拦截器：只能拦截action 自定拦截器编写拦截器方法 继承MethodFilterInterceptor并重写其中的doIntercept方法。 public class MyFilter extends MthodsFilterInterceptor{ protected String doIntercept(ActionInvocation invocation)throws { //如果符合条件，则通过执行invocation.invoke()来放行 if(somthongright){ invocation.invoke(); }else{ //否则，不执行invocation.invoke() return &quot;null&quot;; } } } 配置拦截器在package中： 声明拦截器 //class为自定义拦截器的全路径 使用自定义的拦截器在要使用的action内部使用： //name为上面配置的name值 3.还有一点要注意，由于interceptor-ref值默认为执行struts的默认拦截器，我们修改了之后就不会执行默认拦截器了，所以我们还要执行默认拦截器。 &lt;interceptor-ref name=&quot;defultStack&quot;&gt;&lt;/interceptor-ref&gt; 这里的defaultStack是struts在对默认拦截器的一个名称定义，直接引用不能改变。 如果我们需要让某些action不进行拦截，我们可以在使用拦截器时加入属性： &lt;param name=&quot;excludeMthods&quot;&gt;login&lt;/param&gt; struts常用标签库 s:property :使用OGNL表达式获取值栈的值。 s:iterator :使用OGNL迭代获取值栈中的值。 s:iterator :查看值栈的结构和数据。 struts的表单属性，struts对HTML表单属性都有封装，但一般不用，比如&lt;s:input type=”text”&gt; 最后虽然struts目前用的最少，但是最为SSH三大框架之一，了解一下还是有利于以后的工作。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/tags/JavaEE/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"struts","slug":"struts","permalink":"http://yoursite.com/tags/struts/"}]},{"title":"javaScript深入解析3-类与行为委托","slug":"javaScript深入解析3-类与行为委托","date":"2019-07-19T14:11:44.000Z","updated":"2021-03-09T11:43:48.933Z","comments":true,"path":"2019/07/19/javaScript深入解析3-类与行为委托/","link":"","permalink":"http://yoursite.com/2019/07/19/javaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%903-%E7%B1%BB%E4%B8%8E%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/","excerpt":"JavaScript中“纠结的类”正如前文所说，JavaScript中并没有传统意义上的“类”，可能是因为在JavaScript这门脚本语言诞生之初，并没有人会他会有如今的成就，所以就借用了Self语言的基于原型的面向对象设计。具体可以看JavaScript的诞生","text":"JavaScript中“纠结的类”正如前文所说，JavaScript中并没有传统意义上的“类”，可能是因为在JavaScript这门脚本语言诞生之初，并没有人会他会有如今的成就，所以就借用了Self语言的基于原型的面向对象设计。具体可以看JavaScript的诞生 面向对象编程（OOP）面向对象编程是一种编程思想，其重要思维体现在： 封装性：讲一组方法，变量封装在一个“模块”中，一般来说是一个类。 继承性：继承性是面向对象技术中的另外一个重要特点，是指一个类继承另一个类的方法，类的继承。他们的关系通常是父与子的关系。 多态性：是指子类对父类的方法进行重写或重载。 对于传统的OOP语言，比如java，C++。 类意味着复制。 实例化时，他的行为会被复制到实例中；继承时，行为也会被复制到子类中。 JavaScript中的类JavaScript程序员开始大都是由其它语言程序员没经过系统学习这门语言的精髓就开始编程（因为大家认为JavaScript是一门脚本语言，是如此的简单。）所以从开始到现在，程序员们总是试图使用JavaScript来进行面向对象编程，寻找类这个东西的存在。然而不幸的是，JavaScript没有传统的类。还好我们拥有[[prototype]]这个好东西，我们才能进行所谓的面向对象编程。但这任然不是我们传统观念上的面向对象编程，即使是ES6中ECMA提供的class关键字，任然是[[prototype]]的原法糖。 detail在许多JavaScript库中都提供了类的语法糖，我们来看一下其内部是如何实现的。 类123456function Person(name)&#123; this.name = name;&#125;var tom = new Person('tom');var mike = new Person('mike'); 我们可以直接用new操作符进行“类的实例化”，但是JavaScript中不存在类。所以我们实际上是新创建了一个空对象，然后将其[[prototype]]设为Person.prototype。然后将该函数的this指向新建对象，然后调用该函数，如果函数没有返回对象，就返回新建对象。 继承下面是最典型的一种继承实现方式（JavaScript中多种实现继承的方式，但大同小异）： 1234567891011121314151617function Person(name)&#123; this.name = name; Person.prototype.me = function()&#123;console.log('Person')&#125;;&#125;function Student(name,id)&#123; //调用父级构造函数，相当于super Person.call(name); this.id = id; Student.prototype.onduty = function()&#123;console.log('Studnet')&#125;;&#125;//\"继承\"Student.prototype = Object.create(Person.prototype);var person0 = new Person('tom');var student0 = new Student('mike',123); 我们可以看出来，所谓的继承，也就是Student.prototype = Object.create(Person.prototype)这句话，实际上是将子类Student的[[prototype]]设置为一个空对象，该对象的[[prototype]]指向父级类Person的prototype。（Object.create(obj1)）的意义是创建一个空对象，该对象的[[proottype]]指向obj1首先我们需要了解的是，我们有4个对象(在JavaScript中函数也是对象，可以拥有自己的属性)来储存数据： student0 student0.proto ([[prototype]])（注意通过Object.create方式创建的__proto__并不指向Student.peototype） Student Student.prototype 根据原型链的查找规则，我们在获取实例的某个属性时，会分别从：student0 —&gt; student0.proto-&gt;Student-&gt;Student.prototype查找。 看下面的图： 我们可以看到，子类的属性在实例的__proto__中，父类的属性在实例的__proto__的__proto__中，因此我们可以获取子类，父类的所有方法，我们就完成就继承。 ES6的中类上面提过，ES6中的出现了class关键字，下面我们通过ES6的方法重写一下的例子： 12345678910111213141516171819202122class Person&#123; construct(name)&#123; this.name = name; &#125; speak()&#123; console.log(\"name:\"+this.name); &#125;&#125;class Student extends Person&#123; construct(name,id)&#123; super(name); this.id = id; &#125; me()&#123; console.log(\"name:\"+this.name); console.log(\"id:\"+this.id); &#125;&#125;var person0 = new Person();var student0 = new Student(); 这个看上去漂亮多了，就像是在写传统的OOP的语言。但是实际上，它的背后任然是混乱的[[prototype]]的链。 ES6的class还有一个常用的特点，静态方法。所谓静态方法，就是直接可以在类上面直接调用的方法。 1234567891011class Person&#123; construct(name)&#123; this.name = name; &#125; speak()&#123; console.log(\"name:\"+this.name); &#125; static sayme()&#123; console.log('me'); &#125;&#125; 想一下class背后的原理，用ES5的语法来实现以下static： 1Person.sayme = function()&#123;console.log('me');&#125; 没错，就是这么简单！只是因为这个方法是类自身的属性，并不是方法的[[prototype]]属性值。 混入(mixin)正如我们之前所说，传统的OOP意味着复制。 然而我们JavaScript中模拟的类，并不是传统的复制，而是基于原型链的“伪类”。 所以为了实现很真实的“类”，我们有了混入(mixin)这一概念。 显示混入看下面的例子： 123456789101112131415161718192021222324252627function mixin(sourceObj,tragetObj)&#123; for(var key in sourceObj)&#123; if(!(key in targetObj))&#123; targetObj[key] = sourceObj[key] &#125; &#125; return targetObj;&#125;var Vehicle = &#123; engines: 1, ignition: function()&#123; console.log(\"turn on my engine\") &#125;, drive: function()&#123; this.ignition(); console.log(\"Steering and move forward!\"); &#125;&#125;;var Car = mixin(Vehicle,&#123; wheel: 4, dirive: function()&#123; Vehicle.drive.call(this); console.log(\"Rolling on all\"+this.wheels+\"wheels!\") &#125;&#125;) ​没错，就是一次复制过程。现在我们也可以用： 1object.assign(targetObj,sourceObj); 因为这个方法的原理就是上面的mixin函数。 隐式混入思考下面代码： 1234567891011121314151617181920var something = &#123; cool: function()&#123; this.greeting = \"hello wowld!\"; this.count = this.count ? this.count++ : 1; &#125;&#125;Something.cool();something.greeting; //hello worldsomething.count; //1var Another = &#123; cool: function()&#123; something.cool.call(this); &#125;&#125;Another.cool();Another.greeting; //\"hello world\"Another.count; //1 (count不是共享的) 关键在于something.cool.call(this)，将something.cool函数的this指向了Another这个对象。因此，我们把Something的行为“混入”到Another中。 更合理的编程思想：行为委托类与委托的前世今生如我们前面所说，JavaScript本身是不存在类的，只是为了适应程序员们的设计习惯，我们使JavaScript中有了“类”的存在，实际上这种设计方式无疑是把吧苹果涂上橙色，在上面插上孔…然后把它装饰成橘子。但他始终都是苹果，无论我们怎么在外部伪装。既然如此，为什么我们不直接把它当成橘子来吃呢？ 如何使用行为委托看下面的例子： 123456789101112131415161718var Task = &#123; setId: fucntion(id)&#123;this.id = id;&#125;, outputID: function()&#123;console.log(this.id)&#125;&#125;var someWork = Object.create(Task);someWork.prepareTask = fucntion(id,label)&#123; this.setId(id); this.label = label;&#125;some.outputTaskDetails = function()&#123; this.outputId(); console.log(this.label);&#125;var someWork0 = Object.create(someWork); 在上面这段代码中，Task，someWork都不是类（或者函数），而是对象。我们把someWork的[[prototype]]委托给了Task。这很符合Self语言的基于原型的面向对象编程的思想。这也被成为“对象关联（OLOO）” 对象关联风格的代码还有一些不同之处。 在代码上，id和label数据成员都是直接存储someWork之上，而不是Task。 在类的思想上，我们鼓励方法的重写（多态）。也就上在子类中定义父类同名的函数。但在委托行为中恰恰相反，我们尽量避免在[[prototype]]链上存在同名函数。 Last不得不说，行为委托从语言底层来说更加适合JavaScript编程，但是越来越多的程序员习惯使用面向对象的编程思想。这迫使JavaScript不得不改变自己，比如在ES6中推出了class的语法糖，但这代表了官方的认可，也许在不久的将来，我们可以看见真正的class出现在JavaScript。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/%E7%B1%BB/"},{"name":"行为委托","slug":"行为委托","permalink":"http://yoursite.com/tags/%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/"}]},{"title":"javaScript深入解析2-原型及原型链","slug":"javaScript深入解析2-原型及原型链","date":"2019-07-18T12:05:44.000Z","updated":"2021-10-11T12:47:22.365Z","comments":true,"path":"2019/07/18/javaScript深入解析2-原型及原型链/","link":"","permalink":"http://yoursite.com/2019/07/18/javaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%902-%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"关于原型(prototype)原型可以说是JavaScript设计中最特殊，也可以说是最精髓的设计，他遍布整个JavaScript对象。几乎也是整个JavaScript技术的核心，只有熟悉了原型，才能充分理解JavaScript中的类与委托机制了。","text":"关于原型(prototype)原型可以说是JavaScript设计中最特殊，也可以说是最精髓的设计，他遍布整个JavaScript对象。几乎也是整个JavaScript技术的核心，只有熟悉了原型，才能充分理解JavaScript中的类与委托机制了。 whatQ：什么是原型呢？ A：在所有对象中都有一个特殊的[[Prototype]]属性，其实就是对其他对象的引用。几乎所有的对象在创建时[[Prototype]]都会被赋予一个非空的值。(注意，部分浏览器将该属性暴露出来，并命名为 __proto__) Q：什么是原型链呢？ A：如上所说，每一个对象都会有一个[[Prototype]]属性，然而[[Prototype]]属性引用的也是一个对象，这个对象同样也会含有[[Prototype]]属性，这样每一个对象就如同一个链节，一起就组成了一个链，我们称之为原型链。 whyQ：为什么要设计这样一个独特的机制呢？ A：或许不应该对存在这个问题如此深究，因为这可能是第一代开发人员的灵光一现，就有了这个特征。但实际上大都认为这是一门动态编译语言，或者说是脚本语言，所以没有设计类的概念，但为了填补这个概念，就有了原型。但谁也不知道JavaScript会在接下来的几十年中发展的如此蓬勃，程序员们多么希望JavaScript有OOP的概念，于是想方设法的使用原型链来模拟类的行为，但无论如何，就现在为止，JavaScript底层是没有类的概念的，包括ES6的类，任然是原型的语法糖。 how我们了解了什么是原型，为什么会存在原型之后，就要知道我们该如何使用它了。 创建对象我们来看一下创建对象的几种方法。 let obj = {num : 0} let obj = new Object({num : 0}) 或者var obj = Object({num : 0}) let construt = function(){this.num = 0} =&gt; let obj = new construct() let obj0 = {num : 0} =&gt; let obj1 = Object.create(obj0) 这几种方法创建的对象有所不同，我们还是来解析一下： 1,2：字面量方法，创建的是一个普通对象，其[[Prototype]]指向Object.prototype（大部分对象的原型链最后都指向它）。 3：new操作符： 当我们看到new操作符，一定会想到类，但是JavaScript中的new操作符与传统OOP语言中的new完全不同，JavaScript中的new只是将函数当成一个构造函数来调用。如同上一篇中所说，JavaScript中所有的函数都一样，不存在本质的构造函数，只有被new调用的函数就是构造函数。我们在回顾一下new操作符的执行过程： 123456789function C(name)&#123; this.name = name;&#125;let obj = new C('mw');console.log(obj);//C &#123;name:'mw'&#125;//此时obj的__proto__指向的是C.prototype 创建一个新的对象 将新对象的[[prototype]]设为C.prototype 将新对象设为函数调用的this 如果函数没有返回其他对象，则new操作符调用的函数会自动返回这个新对象，否则则会直接返回函数内的对象 4: 使用Object.creat()函数来创建对象，实际上是创建了一个新对象，然后将其[[Prototype]]设置为对应对象，如果不加参数，则[[Prototype]]为Object对象。 1234let a = &#123;num : 0&#125;;let b = Object.create(a);console.log(b.__proto__);//&#123;num:0,__proto__:Object&#125; 属性获取，设置与屏蔽当我们有了一个对象，我们可能会对他们做一些操作，比如，[[get]],[[set]],或者seal,freeze等等操作。那么这个过程又是什么样的呢？ 我们提前需要了解的是：每一个对象的每一个属性都是具有属性描述： 数据属性 configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。 enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。 writable：表示能否修改属性值。默认为true。 value： 包含这个属性的数据值，读属性时，从这个位置读；写属性的时候，把新值保存在这个位置。默认为undefined。 访问器属性 configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。 enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。 get：读取属性时调用的函数。默认为undefined。 set：写入属性时调用的函数。默认为undefined。 值得注意的是： 官方来说，只能通过Reflect.defineProperty(obj,proName,proValue)，但是Firefox在最开始指定了__defineGetter__，__defineSetter__，后期Chrome，Opera，Safari也实现了该方法。 在defineProperty()中get,set不能与writable，value，同时设置。 在ES6中，将Object中的很多方法(包括defineProperty…)都放到了Reflect对象中，虽然Object任然包含该方法，但建议使用Reflect对象。 属性获取与屏蔽思考一下下面的代码： 1234let obj = &#123;num : 0&#125;;let str = obj.toString();console.log(str);//\"[object Object]\" 首先我们需要思考的是，我们并没有在obj上定义toString方法，为什么我们能够调用，并且得到一个结果(虽然并不那么漂亮)，我想你肯定猜到了，那是因为obj的原型对象Object拥有这个方法。所以，我们在或得一个对象的值时，是从链的底端开始查找，顺着原型链，一直查到顶端，如果不存在，返回undefined或者error。如果存在，则返回这个值。也就是说，我们能够在一个对象中查找到值，并不代表该对象含有该值，很有可能是该对象的原型链上的某个原型对象含有该值。 思考下面的代码： 12345let a = &#123;getString:function()&#123;return 'from a'&#125;&#125;;let b = Object.create(a);b.getString = function()&#123;return 'from b'&#125;;console.log(b.getString()); 结果是什么呢？hava a try! 没错，结果是’from b’ 这就是我们所说的属性屏蔽，这一切的根源在于：我们是从链底查到链顶的，所以下层的同名属性会优先被获取，一旦引擎获取到该属性，则遍历结束，不会再向下查找。 属性设置与屏蔽当我们为一个对象的键赋值时，会发生三种情况： eg： 12let obj = &#123;&#125;;obj.name = 'value' 如果在[[Prototype]]链上存在名为name的普通数据访问值，并且被标记为可写(writale:true)(默认即为true)，那就会直接在obj上添加一个名为name的新属性，它就是屏蔽属性。 如果在[[Prototype]]链上存在名为name的普通数据访问值，但是该属性被标记为只读，(writable:false)，那么无法修改已有属性或者在obj上创建屏蔽属性。如果在严格模式下，会抛出一个错误；否则会忽略该语句。总之，不会发生屏蔽。 如果在[[Prototype]]链上存在name并且它是一个setter。那就一定会调用这个setter。name不会被添加到obj上，也不会重新定义setter。 屏蔽的发生也许不像我们通常认为，还要联系对象属性的描述符来确定！我们需要记住。 隐式屏蔽正如类型转换一样，同样存在隐式屏蔽，只要操作对象的属性，都有可能发生隐式屏蔽。 比如： 123let obj0 = &#123;num:0&#125;;let obj1 = Object.create(obj0);obj1.num++ //这里发生了隐式屏蔽！！！ 只要是[[set]]，都有可能发生隐式屏蔽 修改[[Prototype]] Object.create()，该方法是最适用的方法。即在创建时就设置其prototype。 123let obj0 = &#123;num:0&#125;;let obj1 = Object.create(obj0);//将obj0设置为obj1的prototype Object.setPrototypeOf()，该方法是ES6新增的方法。 1234let obj0 = &#123;num:0&#125;;let obj1 = Object.create(obj0);Object.setPrototypeOf(obj0,obj1);//把obj1设置为obj0的protoype 构造函数方法 123let F = function()&#123;this.a = 123&#125;;let obj = &#123;&#125;;obj.prototype = new F(); 回顾一下上面new操作符，就能想明白。 检测原型链我们又该如何检测对象的原型连上存在哪些原型对象呢？ instance操作符 123let obj = &#123;&#125;;console.log(obj instance Object);true __proto__属性，如上所说，大多数浏览器实现了__proto__(在ES6中加入了标准)，在兜底情况时，可以使用这种方法检测。 Last理解清楚原型链，我们才能清楚理解后面的委托，“类”等等。所以这一部分是基础。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"原型链","slug":"原型链","permalink":"http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"javaScript深入解析1-this关键字","slug":"javaScript深入解析1-this关键字","date":"2019-07-17T03:44:15.000Z","updated":"2021-03-08T03:38:53.592Z","comments":true,"path":"2019/07/17/javaScript深入解析1-this关键字/","link":"","permalink":"http://yoursite.com/2019/07/17/javaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%901-this%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"前言花了三天时间粗略看完了《你不知道的JavaScript》下部，这一部分介绍了ES6的部分内容（本书出版时ES7,8）的部分特性还未推出，因为之前已经学过ES6，所以这一遍只是温习和关注细节，感觉除了新增的特征，迭代器应该是最重要的部分，因为ES6的很多特性都用到了迭代器，包括 扩展运算符(spread)‘[…]’，泛数组的迭代(for..of循环，keys(),values(),entries()等等),其次就是Promise，这个特性用的也很多，特别是在异步操作上，配合生成器(function */)，迭代器(iterator),就是async异步函数的底层实现。 关于thisthis关键字作为JavaScript开发者必须理解的概念之一，其实并没有那么高深。 whatQ：什么是this？A：this代表的是函数运行的上下文环境。","text":"前言花了三天时间粗略看完了《你不知道的JavaScript》下部，这一部分介绍了ES6的部分内容（本书出版时ES7,8）的部分特性还未推出，因为之前已经学过ES6，所以这一遍只是温习和关注细节，感觉除了新增的特征，迭代器应该是最重要的部分，因为ES6的很多特性都用到了迭代器，包括 扩展运算符(spread)‘[…]’，泛数组的迭代(for..of循环，keys(),values(),entries()等等),其次就是Promise，这个特性用的也很多，特别是在异步操作上，配合生成器(function */)，迭代器(iterator),就是async异步函数的底层实现。 关于thisthis关键字作为JavaScript开发者必须理解的概念之一，其实并没有那么高深。 whatQ：什么是this？A：this代表的是函数运行的上下文环境。Detail： 在所有语言中，都有一个调用栈的概念，即函数被哪个对象所调用（注意JavaScript中对象的概念，几乎所有的方法，参数都有一个宿主对象，其中顶层对象在浏览器中window，在node中则为global）。所以我们再执行一个函数或调用一个变量时，默认是带有一个顶层对象前缀的，不过由于我们所有的代码都在该对象中，则可以省略，不信可以试一下： 123var num = 0;console.log(num);console.log(window.num); 没错，它们的结果都是0。 回归正题，所以粗略的来说，函数被调用的对象即为他的this指向(先不谈硬绑定)，最简单的例子： 12345678var obj = &#123; num : 0, func: function()&#123; console.log(this.num); &#125;&#125;obj.func(); 执行结果是什么呢？没错，是0；因为这里的func函数由obj调用，所以this指向obj。OK,那么再看一下下面这段代码： 12345678910var num = 0;var obj = &#123; num : 1, func: function()&#123; console.log(this.num); &#125;&#125;var outterFunc = obj.func;outterFunc(); 执行结果又是什么呢？have a try!可能出乎你的意料，结果是0.So,why?思考一下我们上面的解释。 没错，也许你想通了，因为这时候的func函数并不是通过obj来调用的，所以this默认指向window，但window中num变量为0，所以结果是0. 在这之中，我们需要了解的是：在JavaScript中，函数，对象，数组，或者说所有对象即对象的子类（因为包括函数，数组皆为对象的子类）都是通过地址的形式存储，类似与C语言中的指针形式存储 思考下面代码： 1var func = function()&#123;console.log(123)&#125; 在JavaScript引擎中时如何运行完这条语句的呢？（你需要了解的是JavaScript不是一门预编译语言，而是一门解释执行的语言（即执行一句，编译一句，当然这是不完全正确的，从变量提升即可以看出来）） 查询是否存在func这个变量—否 声明这个变量 定义函数function(){console.log(123)} 将该函数存储于内存中，并取得其地址 将该地址赋值给func变量 所以func变量实际存储的是该函数的地址。所以函数实际上是没有存储作用域链中的任何信息，它总是一个独立存在的个体。这也就解释了为什么func虽然定义在obj中，但是通过某种方式提取出来后直接调用其this就指向了window。 所以你大概已经明白了了吧，思考一下下面的代码： 12345678910111213var num = 0;function inner()&#123; console.log(this.num)&#125;function outter()&#123; var num = 1; inner();&#125;outter(); 所以，结果是什么呢？ 我猜你肯定答对了，是0； 同样的道理，inner函数虽然在outter函数中被调用，但任然是直接调用，没有任何前缀对象，所以其this指向任然是window。 最后一个例子： 123456789101112var name = \"clever coder\"; var person = &#123; name : \"foocoder\", hello : function(sth)&#123; var that = this; var sayhello = function(sth) &#123; console.log(that.name + \" says \" + sth); &#125;; sayhello(sth); &#125; &#125; person.hello(\"hello world\");//foocoder says hello world 这里内层函数this指向的任然是window，有人认为是JavaScript的设计错误，但是从上面内存的角度去分析，会发现这是正确的。 why &amp; where说了这么多this，那么为什么要用this呢？又在哪里用呢？ Q：why？ A：this的使用使调用上下文对象变得更加简洁，否则，每次调用函数必须传递上下文对象，编码将及其复杂。 Q：where？ A：相信接触过OOP（面向对象编程）的同学应该熟悉这个结构(伪代码)： 123456789Class Example&#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125;&#125;declare instan = new Example('tom',23); 没错，这是一个基本类的构造，只包括了一个constructor构造器方法，其中的this指向的即是这个被实例化的对象(instan),则instan的name属性为’tom’，age属性为23。试想没有this的话，构造器该如何为实例属性赋值呢？只有显式的将instan传递给constructor函数，这将变得无比繁杂。 在js中，不仅是在类，即使是用行为委托方式编码，任然离不开this，因为总是存在对上下文对象的应用。 值得注意的是：JavaScript语言基础中并没有class的概念，即使ES6推出了class关键字，但它任然是使用原型链对类的模拟，任然是ES5部分框架class实现的语法糖 how说了那么多，还是要详细讲一下this的绑定问题： 默认绑定 独立函数调用执行默认绑定。 123456789var a = 0;function func()&#123; console.log('a:'this.a);&#125;func();//a:0 如上面我们所说，这里的func是直接的函数调用，所以执行默认绑定，this指向了window对象。 值得注意的是：在strict模式下，默认绑定this为undefined 12345678910var a = 0;function func()&#123; \"use strict\" console.log('a:'+this.a);&#125;func();//Uncaught TypeError: Cannot read property 'a' of undefined 隐式绑定 这就是我们之前熟悉的用对象来调用函数： 12345678910var obj = &#123; num : 0, func: function()&#123; console.log('num:'+this.num); &#125;&#125;obj.func();//num:0 当含有多层对象引用的时候，只有距函数最近的一个对象为上下文对象 123456789101112131415var obj0 = &#123; num : 0, func: function()&#123; console.log('num:'+this.num); &#125;&#125;var obj1 = &#123; num:1, obj0:obj0&#125;obj1.obj0.func()//num:0 正如我们之前所说的，函数的存储与上下文对象毫无关系，所以，当我们将对象中的函数通过某种方法提取出来时，它就与原来的对象毫无关系了，其this指向则为window了（这种现象一般被称为隐式丢失）。具体可以看上面那个例子。 显示绑定 所谓显示绑定，即通过call(),apply(),以及ES6的bind()函数直接指定this的指向。 12345678910111213var a = 0;var obj = &#123; a: 1&#125;function func()&#123; console.log(this.a);&#125;func.call(obj);//1 值得注意的是：call(),apply()函数的绑定是软绑定，即只在绑定这一次起作用，下一次调用时this任然执行原有绑定规则。 所以就衍生出了硬绑定，ES6之前需要手动封装硬绑定方法： 12345678function bind(fn,obj)&#123; return function()&#123; return fn.apply(obj,arguments) &#125;&#125;//执行此方法后，函数的this指向将被永久绑定在指定对象上，无法修改。 由于这个方法需求太广泛了，所以ES6推出了官方的bind()方法，直接调用即可。 new绑定 与其他语言中构造函数的特殊性不同，在JavaScript中，构造函数是一个普通的函数，唯一的特殊点是它在执行new操作符后自动调用，并且开始执行一系列操作： 创建一个新的对象 这个新对象会被执行[[prototype]]连接(即将__proto__指定为函数的prototype)。 这个对象将会被绑定到对应的函数的this。 如果函数没有返回其他对象，那么new表达式中函数调用会自动返回这个新对象。 第四步解释： 12345678910function Fun()&#123; return &#123; b:2 &#125;&#125;var instan = new Fun()//&#123;b:2&#125; 优先级 如果是new绑定，则this按上面的规则绑定对象。 如果是显示绑定，则this指向显示绑定的对象。 如果有隐式绑定，则this绑定在调用对象上。 否则执行默认绑定，非严格模式下为window，严格模式下位undefined。 箭头函数 =&gt;在ES6中，新加了一种声明函数的方式，箭头函数(=&gt;) 1()=&gt;&#123;&#125; 等价于 function()&#123;&#125; 关于箭头函数的特性就不具体细讲，他与this相关的就是：箭头函数的this决定于定义函数时的外层作用域来决定： 12345678910111213141516//arrayFunc var a = 0; //定义全局变量a function fun() &#123; return (arrayFunc = ()=&gt;&#123; console.log(this.a); &#125;)()//这是一个立即执行函数，也可以在外围多调用一次 &#125; var obj = &#123; a : 1, func: fun() &#125; fun.call(obj);//将fun的this指向obj //1 由于fun的this指向obj，而箭头函数的this根据外围函数的this决定，所以arrayFunc的this也指向obj，则a为1。 123456789101112131415//normal var a = 0; function fun() &#123; return (function normalFunc()&#123; console.log(this.a); &#125;)() &#125; var obj = &#123; a : 1, func: fun() &#125; fun.call(obj); //0 这里普通函数的this根据调用的对象来确定，由于它是单独调用的，所以this指向window，则a为0。 Lastthis的用法相当重要，不管是自己原生开发，或是用框架，特别是使用框架时，由于一般框架会有一个App实例，我们的操作都在这个实例之中进行，所以会无数次用到this，所以我们必须学通。下一期写一下Protype原型链，也是JavaScript中相当重要的一个内容。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"this关键字","slug":"this关键字","permalink":"http://yoursite.com/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"Promise理解","slug":"Promise理解","date":"2019-06-28T13:57:55.000Z","updated":"2021-01-29T07:22:03.607Z","comments":true,"path":"2019/06/28/Promise理解/","link":"","permalink":"http://yoursite.com/2019/06/28/Promise%E7%90%86%E8%A7%A3/","excerpt":"唠唠叨叨最近考试比较多，终于快结束了，间隙时间，我第一遍看了《你不知道的JavaScript》的上中篇，说实话，可能是因为译本的原因，也可能是知识比较深入，我感觉比较难理解，有时感觉一小节讲完，发现他的中心观点只有一句话。但总的来说，这是套值得深入研读的书籍，暑假我将再次研读。","text":"唠唠叨叨最近考试比较多，终于快结束了，间隙时间，我第一遍看了《你不知道的JavaScript》的上中篇，说实话，可能是因为译本的原因，也可能是知识比较深入，我感觉比较难理解，有时感觉一小节讲完，发现他的中心观点只有一句话。但总的来说，这是套值得深入研读的书籍，暑假我将再次研读。 Promise的神秘面纱ES6的知识点着实比较庞大，除了对Number，Array等的扩展。Promise这个概念也很吸引人。比如著名的axios就是采用Promise来封装的。 我在《你不知道的JavaScript》中看到一个比较形象的比喻，当你去买一个汉堡包，你先把钱给服务员，然后服务员会给你一个凭证，在这个汉堡包被完成之前，凭证即代表了你的汉堡包。一段时间过后，服务员通知你结果。但这是服务员可能会对你说：‘Sorry Sir,hamburger has sold out…’这种失败的结果即为Promise中的reject。但大多数情况下，我们期望并得到的结果是一个汉堡包 （ solved）。 也就是说：Promise是一个容器，里面保存着未来才会结束的事件（通常是一个一步操作）的结果。 Promise的特点 Promise的状态不收外界的影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise的基本用法 12345678910111213141516//定义promisevar promise = new Promise(function(resolve,reject) &#123; var res = asycFunc(); if(res.code 满足条件)&#123; resolved(res.data); &#125;else&#123; reject(res.data) &#125;&#125;)//调用promise//1(不推荐). promise.then(res =&gt; &#123;show(res)&#125;,err=&gt;(handleError(err)))//2(推荐). promise.then(res =&gt; &#123;show(res)&#125;).catch(err =&gt; &#123;handleError(err)&#125;) 第二种的好处在于，1.采用链式的写法可以捕获前一个then抛出的错误，而一then中同时写resolve与reject无法做到。2.在语法上更人性化，类似于try…catch…语法。但实际catch = then(null,rejection).都是捕获产生的错误，包括rejected，Error；对于错误，还有一点值得注意的是，reject或者resolve即代表这个promise状态的冻结。类似于函数的return，这两个语句一旦发生，其后面所有的语句都将无效。即使是抛出错误，也无法再被catch所捕获。 Promise的链式玩法 前面的then…catch…其实已经是链式的写法了。 Promise有3个函数可以链式调用。分别是 then(func(reslved,rejected){...}): 为Promise实例添加状态改变时的回调函数。 catch(func(err){...}): 用于指定发生错误时的回调函数。包括rejected也被他处理。 finally(func(){...}): 无论状态如何，是否抛出错误。都将执行该回调。 但其能够一直链式调用的原因是：这3个函数每次调用都会产生一个新的Promise对象，并且这个新的promise会将旧的promise返回值作为参数，这个对象又包含了这3个方法，所以可以一直链式调用。 Promise的高级玩法（模式） Promise.all([p1,p2,…]) 说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为： a. 所有的Promise的值变为resolved时，该对象才返回resolved，并返回所有的结果。b. 一旦有一个Promise对象返回rejected，则整个对象返回rejected，并返回错误原因。 由Promise封装的axios中，有axios.all([re1,re2,…])方法 Promise.race([p1,p2,…]) 说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为： a. 当第一个Promise返回resolved时，整个Promise状态变为resolved，并返回第一个Promise resolved的结果，一旦有任何一个Promise决议为拒绝，他就会拒绝。 值得注意的 Promise.all在传入空数组时，会立即返回resolved；但Promise.race会被一直挂起。所以不要想Promise.race中传递空数组。希望ECMA会尽快修改这一点。 一些骚操作 在《你不知道JavaScript》一书中，提出来一些ES6标准之外的Promise模式之外的一些扩展模式，比如： Promise.none([...]):与Promise.all的情况互换，即所有的Promise都rejected才rejected。反之则返回resolved。 Promise.any([...]):与race相对，该模式忽略rejected，得到第一个resolved。 Promise.first([...]):这个模式类似与any([…])的竞争，，即只要第一个Promise完成，他就会忽略有序的任何拒绝和完成。 Promise.last([...]):这个类似与first([…]，但确实最后一个完成胜出。 示例：Promise.first([...])的实现 //polyfill安全的guard检查 if(!Promise.first){ Promise.first = function(prs){ //返回最终的Promise对象 return new Promise(function(resolve,reject){ //把所有的Promise循环一次 prs.forEach(function(pr){ //把值规整化，并且不管哪个先完成，就决议组Promise Promise.resolve(pr).then(resolve); }) }) } } Promise的实际应用 异步加载图片 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; 异步Ajax 1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 最后Promise着实避免了回调函数的一些缺陷，并且它的使用也越来越广泛，包括后面的async异步函数，也是利用Promise来完成的，因此，这里简单的了解一下Promise还是很有必要的。 2021年1月18日补充概念 其在新建时就开始立即执行，一旦完成，其状态就会”凝固“。 “凝固”过后其状态就不会发生改变，并且与事件不同的是，其可以随之被监听，即： 1234567891011const p1 = new Promise(resolve, reject)&#123; setTimeout(()=&gt;&#123;resolve(1)&#125;, 3000)&#125;p1.then((res) =&gt; &#123; console.log(`$&#123;res&#125;--第一次获取`)&#125;)p1.then((res) =&gt; &#123; console.log(`$&#123;res&#125;--第二次获取`)&#125;) 第一个结果为：1—第一次获取 第二个结果为：1—第二次获取 注意：这两次执行都会在3秒过后执行，并且都会执行；这里区别于普通事件，一旦错过，就无法再监听到了。但是Promise在操作完成后会凝固状态，无论后面在什么时候进行监听（定义其then函数）都会被执行。 以实现的接口 Promise.all([p1, p2, p3])，其返回结果分为两种： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 注意：注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [\"hello\", Error: 报错了] Promise.race([p1, p2, p3])：上面代码中，只要p1、p2、p3之中有一个实例率先改变状态（无论是fulfilled还是reject），p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 下面这个即利用这个特性完成请求超时： 12345678910const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); Promise.allSettled(p1, p2, p3)：方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。 123456789101112const resolved = Promise.resolve(42);const rejected = Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123; console.log(results);&#125;);// [// &#123; status: 'fulfilled', value: 42 &#125;,// &#123; status: 'rejected', reason: -1 &#125;// ] Promise.any(p1, p2, p3)：该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。（与all相反） 1234567891011const promises = [ fetch('/endpoint-a').then(() =&gt; 'a'), fetch('/endpoint-b').then(() =&gt; 'b'), fetch('/endpoint-c').then(() =&gt; 'c'),];try &#123; const first = await Promise.any(promises); console.log(first);&#125; catch (error) &#123; console.log(error);&#125; Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。 捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。 12345678Promise.any(promises).then( (first) =&gt; &#123; // Any of the promises was fulfilled. &#125;, (error) =&gt; &#123; // All of the promises were rejected. &#125;); 下面是一个例子。 1234567891011var resolved = Promise.resolve(42);var rejected = Promise.reject(-1);var alsoRejected = Promise.reject(Infinity);Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123; console.log(result); // 42&#125;);Promise.any([rejected, alsoRejected]).catch(function (results) &#123; console.log(results); // [-1, Infinity]&#125;); Promise.resolve()：有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function (value) &#123; console.log(value); // 42&#125;); 上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出42。 参数不是具有then()方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。 123456const p = Promise.resolve('Hello');p.then(function (s) &#123; console.log(s)&#125;);// Hello 上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。 Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 Promise.reject()：会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 12345Promise.reject('出错了').catch(e =&gt; &#123; console.log(e === '出错了')&#125;)// true 上面代码中，Promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。 目前Chrome(87)中的以实现上述方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"杂记兼第一个开源项目","slug":"杂记兼第一个开源项目","date":"2019-05-19T16:00:30.000Z","updated":"2019-05-19T16:02:46.292Z","comments":true,"path":"2019/05/20/杂记兼第一个开源项目/","link":"","permalink":"http://yoursite.com/2019/05/20/%E6%9D%82%E8%AE%B0%E5%85%BC%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","excerpt":"碎碎念最近过完了第一遍《JavaScript高级程序设计》，有两个感觉 JavaScript体系还是很巨大，值得深入挖掘 这本书太过老旧，我看了一下第一版是在2012年发行，最近一次修订是在2019年，但这一次修订并没有大范围修改书中的内容，仅仅添加了部分ES6的内容，并且ES6还是不是正式版，其中的ArrayType在正式版ES6中并没有实现。","text":"碎碎念最近过完了第一遍《JavaScript高级程序设计》，有两个感觉 JavaScript体系还是很巨大，值得深入挖掘 这本书太过老旧，我看了一下第一版是在2012年发行，最近一次修订是在2019年，但这一次修订并没有大范围修改书中的内容，仅仅添加了部分ES6的内容，并且ES6还是不是正式版，其中的ArrayType在正式版ES6中并没有实现。 虽然如此，总体来说这本书还是非常有价值的，深入的讲解了JavaScript，包括组成部分，ECMAScript+BOM+DOM,HTMLDOM与XML的关系这些以前比较少了解的东西，还有原型链，作用域，实现继承等老生常谈的东西。感觉这本书还是要多刷几次，暑假回家配合《你不知道的JavaScript》二刷，去研究更细微的东西。 第一个开源项目：PageWindow一直在学习，做工程项目，想想也该是时候做一点开源项目，让明年面试更有利一点~ 这个项目使我一直想做的，其实很简单，就是实现页面上模拟windows窗口，好像目前是有这种东西，但我是想将其封装成一个UI库。进而实现伪多任务。 这里主要就是涉及DOM操作。包括鼠标操作比较多： mousedown mouseup mousemove click 第一个demo遇到就是阻止冒泡与阻止默认事件 阻止冒泡 e.stopPropagation() 标准W3C方法 e.cancelBubble = true IE专用，但chrome，firefox也实现了属性 阻止默认事件 e.preventDefault() 标准W3C e.returnValue = false IE专用，但chrome，firefox也实现了属性","categories":[{"name":"pageWindow","slug":"pageWindow","permalink":"http://yoursite.com/categories/pageWindow/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"},{"name":"pageWindow","slug":"pageWindow","permalink":"http://yoursite.com/tags/pageWindow/"}]},{"title":"项目实际问题一:对象深浅拷贝问题","slug":"项目实际问题一-对象深浅拷贝问题","date":"2019-05-18T00:32:35.000Z","updated":"2021-10-13T09:57:32.120Z","comments":true,"path":"2019/05/18/项目实际问题一-对象深浅拷贝问题/","link":"","permalink":"http://yoursite.com/2019/05/18/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E4%B8%80-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98/","excerpt":"第一次经手比较大型的项目，总结第一个问题：对象的深拷贝问题。之前没注意这个问题，写完代码发现总是与自己的想法不符合，经调试才发现是对象的深浅拷贝问题。 原理的话也很简单，对象作为基本类型之外的引用类型，在栈内存中保存着引用变量的名字，而这个变量保存的实际是一个地址，这个地址指向堆内存，实际这个变量的值是保存在堆内存中。 所以当我们直接用 “=” 进行变量copy时，实际copy的是对内存中的地址。copy之后改变原变量的值同样会使新变量的值进行改变。所以有时候我们需要进行深拷贝来在堆内存中开辟一个新的内存空间来放置副本，切断新旧变量之间的联系。","text":"第一次经手比较大型的项目，总结第一个问题：对象的深拷贝问题。之前没注意这个问题，写完代码发现总是与自己的想法不符合，经调试才发现是对象的深浅拷贝问题。 原理的话也很简单，对象作为基本类型之外的引用类型，在栈内存中保存着引用变量的名字，而这个变量保存的实际是一个地址，这个地址指向堆内存，实际这个变量的值是保存在堆内存中。 所以当我们直接用 “=” 进行变量copy时，实际copy的是对内存中的地址。copy之后改变原变量的值同样会使新变量的值进行改变。所以有时候我们需要进行深拷贝来在堆内存中开辟一个新的内存空间来放置副本，切断新旧变量之间的联系。 方法对象的深拷贝适用于所有类型的对象（含数组） JSON.parse(JSON.stringfy(Object)) Point:这是最简单的进行深拷贝的方法，其原理是先将其转换为JSON字符串，此时就不在存在原变量的堆地址，而是以字符串-基本变量保存在栈地址中。再将其转换回对象，则是一个完全与原变量无关的新变量。但是该方法会丢失对象所有的函数属性，undefined，以及会重置原型对象为Object(),或Array(),如果没修改多原型对象，则没有影响。 递归遍历对象 1234567891011121314//只能clone Object和Arrayfunction deepClone1(obj) &#123; //判断obj是否是引用类型 if(obj &amp;&amp; typeof obj === \"object\")&#123; let newObj = Array.isArray(obj) ? [] : &#123;&#125; for(let i in obj)&#123; newObj[i] = deepClone1(obj[i]) &#125; return newObj &#125;else&#123; //如果不是引用类型则直接返回该值 return obj &#125;&#125; } 使用lodash库中的cloneDeep()函数，其原理与上述原理一样，但健壮性更高。 适用于简单对象 Object.assign() eg: const obj = { a: 1 }; const copy = Object.assign({}, obj); console.log(copy); // { a: 1 } Point:该方法只适用于由基本数据类型组成的对象，不能用于对象键或值包含引用类型，否则任然是浅拷贝。同时，该函数会忽略undefined与null值（可以用来过滤无效值） 使用于简单数组 Array.slice(startPositong,endPositon) Array.contact(arr1,arr2) array.splice(startPositon,delteteNum,addArr1,addArr2...) 数组的迭代方法：Array.every(),Array.filter(),Array.map() Point:使用以上方法，必须是由基本数据类型组成的数组，数组项不能包含引用类型，否则任然是浅拷贝！！！ Final以上方法都只会转化可枚举项，对于不可枚举项，都是默认忽略的。 综上，JSON.parse(JSON.stringfy(obj))应该算是最简单且最易用的方法了，并且原生代码的效率相较于JS也会有优势，所以，如果仅仅为了深拷贝，没有其他需求，该方法是比较好的方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"深拷贝","slug":"深拷贝","permalink":"http://yoursite.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"}]},{"title":"项目部署引发的知识","slug":"项目部署引发的知识","date":"2019-04-09T13:38:21.000Z","updated":"2021-10-14T07:06:20.375Z","comments":true,"path":"2019/04/09/项目部署引发的知识/","link":"","permalink":"http://yoursite.com/2019/04/09/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%BC%95%E5%8F%91%E7%9A%84%E7%9F%A5%E8%AF%86/","excerpt":"项目部署之前一直在写东西，都没怎么部署过项目，特别是Linux系统下，本来之前买服务器是想买一个Linux的服务器的，然而，学生党只配用Windows，万恶的阿里云。现在又可以买Linux的了，然而我又不想重新布属我的项目。今天再部署Linux时，才发现完全不会。枯了~ git命令开发最常用命令 git init //初始化一个git文件夹 git remote add origin https://gitee.com/mw530/xxx //为本地仓库添加远程仓库 git status //查看项目状态 git add . //把所有修改文件推送到stage中 git commit -m des(描述) git push //推送到默认分支 git push origin master(本地分支名) : master(远程仓库名) 常用命令 git config –global user.name “Tocy” //配置用户名 git config –global user.email zyvj@qq.com //配置邮箱 git clone 仓库地址 //将远程仓库拉至本地 git add 文件名 //将某一文件提交至stage git diff //查看当前目录的所有修改 git remote add [short_name] [url] //添加远程仓库 git branch //列出所有分支 -* 本地 -r 远程 -a 本地与远程 git branch [branch-name] //新建一个分支，但仍然留在当前分支 git branch -d [branch-name] //删除该分支 git checkout -b [branch-name] //新建并切换到该分支 git checkout [branch-name] //切换到该分支 git checkout [file] //恢复暂存区的指定文件到工作区 git checkout . //恢复暂存区的所有文件到工作区 分支管理 git merge –no-ff develop //将develop合并到当前分支 –no-ff(no-fast forward)的含义：当两个分支之间存在先后关系时，若合并分支在当前分支之后，则git只会移动指针，使当前分支指向被合并分支，这个过程被称为快速合并。而禁止快速，即–no-ff则会在当前分支新建一个提交来存放这一次develop的提交。","text":"项目部署之前一直在写东西，都没怎么部署过项目，特别是Linux系统下，本来之前买服务器是想买一个Linux的服务器的，然而，学生党只配用Windows，万恶的阿里云。现在又可以买Linux的了，然而我又不想重新布属我的项目。今天再部署Linux时，才发现完全不会。枯了~ git命令开发最常用命令 git init //初始化一个git文件夹 git remote add origin https://gitee.com/mw530/xxx //为本地仓库添加远程仓库 git status //查看项目状态 git add . //把所有修改文件推送到stage中 git commit -m des(描述) git push //推送到默认分支 git push origin master(本地分支名) : master(远程仓库名) 常用命令 git config –global user.name “Tocy” //配置用户名 git config –global user.email zyvj@qq.com //配置邮箱 git clone 仓库地址 //将远程仓库拉至本地 git add 文件名 //将某一文件提交至stage git diff //查看当前目录的所有修改 git remote add [short_name] [url] //添加远程仓库 git branch //列出所有分支 -* 本地 -r 远程 -a 本地与远程 git branch [branch-name] //新建一个分支，但仍然留在当前分支 git branch -d [branch-name] //删除该分支 git checkout -b [branch-name] //新建并切换到该分支 git checkout [branch-name] //切换到该分支 git checkout [file] //恢复暂存区的指定文件到工作区 git checkout . //恢复暂存区的所有文件到工作区 分支管理 git merge –no-ff develop //将develop合并到当前分支 –no-ff(no-fast forward)的含义：当两个分支之间存在先后关系时，若合并分支在当前分支之后，则git只会移动指针，使当前分支指向被合并分支，这个过程被称为快速合并。而禁止快速，即–no-ff则会在当前分支新建一个提交来存放这一次develop的提交。 Linux安装node.js 到根目录 cd ~ 建一个文件夹 mkdir deploy 下载node包 wget https://nodejs.org/dist/v10.11.0/node-v10.11.0-linux-x64.tar.xz 解压node包 tar zf node-v10.11.0-linux-x64.tar.xz 重命名包 cd node-v10.11.0-linux-x64.tar.xz/bin &amp;&amp; ls 查看node,npm的版本 ./node -v ./npm -v 设置环境变量 vim ~/.bash_profile 在文件尾部添加以下内容 export NODE_HOME=/deploy/node-v8.11.3-linux-x64 export PATH=$PATH:$NODE_HOME/bin 退出vim: 按 esc 输入:wq enter 退出 保存profile文件 source /etc/profile 将目录软链接到全局环境下（命令后面的/usr/local/bin/node是固定的） ln -s /deploy/node-v8.11.3-linux-x64/bin/node /usr/local/bin/node ln -s /deploy/node-v8.11.3-linux-x64/bin/npm /usr/local/bin/npm 检验安装是否成功 node -vnpm -v 安装Nginx 安装yum npm install yum 安装依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 下载Nginx //创建一个文件夹 cd /usr/local mkdir nginx cd nginx //下载tar包 wget http://nginx.org/download/nginx-1.13.7.tar.gz tar -xvf nginx-1.13.7.tar.g 安装Nginx //进入nginx目录 cd /usr/local/nginx //执行命令 ./configure //执行make命令 make //执行make install命令 make install Nginx常用命令 //测试配置文件 安装路径下的/nginx/sbin/nginx -t //启动命令 安装路径下的/nginx/sbin/nginx //停止命令 安装路径下的/nginx/sbin/nginx -s stop 或者 : nginx -s quit //重启命令 安装路径下的/nginx/sbin/nginx -s reload //查看进程命令 ps -ef | grep nginx Nginx虚拟域名配置及测试验证 //编辑nginx.conf sudo vim /usr/local/nginx/conf/nginx.conf //增加行 include vhost/*.conf //保存退出 ：wq enter //在/usr/local/nginx/conf目录新建vhost文件夹 mkdir vhost //创建每个域名的配置 sudo vim jimisun.com.conf //节点中增加入响应的配置 端口转发 或者访问文件系统 Nginx启动 //进入nginx安装目录 cd sbin sudo ./nginx 测试访问 http://ip地址","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Vue-review-router","slug":"Vue-review-router","date":"2019-03-20T14:36:33.000Z","updated":"2019-03-20T14:38:10.841Z","comments":true,"path":"2019/03/20/Vue-review-router/","link":"","permalink":"http://yoursite.com/2019/03/20/Vue-review-router/","excerpt":"最基本的一个路由展示域 在Vue控制域中写入router规定的标签 Go to Login //该项为路由的链接，默认为a标签 Go to Register//该项为路由的链接，默认为a标签 //该项为渲染路由组件的位置 以下步骤一般不能交换，因为存在相互依赖关系","text":"最基本的一个路由展示域 在Vue控制域中写入router规定的标签 Go to Login //该项为路由的链接，默认为a标签 Go to Register//该项为路由的链接，默认为a标签 //该项为渲染路由组件的位置 以下步骤一般不能交换，因为存在相互依赖关系 创建组件模板 const login = {template:&apos;&lt;h1\\&gt;这是一个登录框&lt;/h1\\&gt;&apos;}; const register = {template:&apos;&lt;h1\\&gt;这是一个注册框&lt;/h1\\&gt;&apos;}; 创建一个routes对象作为VueRouter的参数 const routes = [ {path:&apos;/login&apos;,component:login}, {path:&apos;/register&apos;,component:register} ] 创建一个VueRouter实例，并将上面的routes作为参数，值得注意的是，这里的参数名字是routes，下面是使用ES6的写法简写对象名 const router = new VueRouter({ routes }) 创建Vue实例，值得注意的是，这之中的路由参数为router，下面是使用ES6的写法简写对象名 const vm = new Vue({ el:&apos;#app&apos;, router }) 路由重定向需要添加的是,在创建routes对象时 //创建一个routes对象 const routes = [ //这里是重要点，给需要添加默认路由的加路由加上redirect属性，其值为要转向的路由地址 {path:&apos;/&apos;,redirect:&quot;/login&quot;}, {path:&apos;/login&apos;,component:login}, {path:&apos;/register&apos;,component:register} ] 子路由的使用JavaScript： &lt;script&gt; //创建模板 const teacher = {template:&quot;#teacher&quot;}; const student = {template:&quot;#student&quot;} const teacherName = {template:&quot;&lt;h1&gt;这是老师的名字&lt;/h1&gt;&quot;} const studentName = {template:&quot;&lt;h1&gt;这是学生的名字&lt;/h1&gt;&quot;} const teacherId = {template:&quot;&lt;h1&gt;这是老师的序号&lt;/h1&gt;&quot;} const studentId = {template:&quot;&lt;h1&gt;这是学生的序号&lt;/h1&gt;&quot;} //创建父级routes对象 routes = [ { path:&apos;/student&apos;, component:student, //注意这里子路由的申明的方式 children:[ {path:&apos;name&apos;,component:studentName}, {path:&apos;id&apos;,component:studentId} ] }, { path:&apos;/teacher&apos;, component:teacher, children:[ {path:&apos;name&apos;,component:teacherName}, {path:&apos;id&apos;,component:teacherId} ] } ] //创建VueRouter实例 const router = new VueRouter({ routes }) //创建Vue实例 const vm = new Vue({ el:&quot;#app&quot;, router }) &lt;/script&gt; body &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/student&quot;&gt;student&lt;/router-link&gt; &lt;router-link to=&quot;/teacher&quot;&gt;teacher&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; //注意这里在模板中申明子路由的link和view &lt;template id=&quot;teacher&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/teacher/name&quot;&gt;这是老师的名字 &lt;/router-link&gt; &lt;router-link to=&quot;/teacher/id&quot;&gt;这是老师的id&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; //注意这里在模板中申明子路由的link和view &lt;template id=&quot;student&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/student/name&quot;&gt;这是学生的名字 &lt;/router-link&gt; &lt;router-link to=&quot;/student/id&quot;&gt;这是学生的id&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 带名视图body &lt;div id=&quot;app&quot;&gt; //注意下面的router-view中都是带有name属性的 &lt;h1&gt;这里是默认视图&lt;/h1&gt; &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;h1&gt;这里只显示学生的视图&lt;/h1&gt; &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;h1&gt;这里只显示老师的视图&lt;/h1&gt; &lt;router-view name=&quot;tea&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=&quot;default&quot;&gt; &lt;div&gt; &lt;h1&gt;这是默认的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;stu&quot;&gt; &lt;div&gt; &lt;h1&gt;这是学生的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;tea&quot;&gt; &lt;div&gt; &lt;h1&gt;这是老师的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; js部分 //创建模板 const defaultView = {template:&quot;#default&quot;}; const stuView = {template:&quot;#stu&quot;}; const teaView = {template:&quot;#tea&quot;}; //创建路由参数,这里是关键，component的value可以是一个对象，该对象的键值就是视图的名字和模板对应的名字 const routes = [ { path:&quot;/&quot;, components:{ default:defaultView, stu:stuView, tea:teaView } } ] //创建路由实例 const router = new VueRouter({ routes }) //创建Vue实例 const vm = new Vue({ el:&quot;#app&quot;, router })","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"VueRouter","slug":"VueRouter","permalink":"http://yoursite.com/tags/VueRouter/"}]},{"title":"webpack中ES6代码的压缩问题","slug":"webpack中ES6代码的压缩问题","date":"2019-03-16T03:06:14.000Z","updated":"2019-03-17T14:19:55.978Z","comments":true,"path":"2019/03/16/webpack中ES6代码的压缩问题/","link":"","permalink":"http://yoursite.com/2019/03/16/webpack%E4%B8%ADES6%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E9%97%AE%E9%A2%98/","excerpt":"问题webpack中ES6代码压缩问题： 在使用webpack插件uglifyjs-webpack-plugin压缩JS代码时，发现该插件只能压缩ES5-的代码，遇到ES6，就会报错ERROR in xxx.js from UglifyJs,遂查找解决办法。","text":"问题webpack中ES6代码压缩问题： 在使用webpack插件uglifyjs-webpack-plugin压缩JS代码时，发现该插件只能压缩ES5-的代码，遇到ES6，就会报错ERROR in xxx.js from UglifyJs,遂查找解决办法。 原理解决办法原理如上所说，uglifyjs-webpack-plugin该插件仅支持ES5-的JS代码。 解决办法1. 不使用ES6语法这个办法理论上可行，但是面对ES6那么多方便快捷的语法，不使用的话会大大降低开发的进度，所以一般不使用该方法。 2. 使用babel-loader将ES6转化为ES5代码该方法是网上流行最广的解决办法，具体是： 安装es2015插件 npm install --save babel-preset-es2015 安装babel-loader npm install babel-loader 也许是我环境的问题，网上的教程上都没这一步，但是，如果不安装babel-loader，就会报错ERROR in Entry module not found: Error: Can&#39;t resolve &#39;babel-loader&#39; in........., 这一步需要注意的是： babel-loader必须与babel-core版本相同，否则会报错Error: Cannot find module &#39;@babel/core&#39;,这一点需要自己到package.json中查看babel-loader,与babel-core的版本来确定。（比如，babel-core版本是：6.23.3那么你装的babel-loader必须是7.1.5以下的版本，否则loader就与core不匹配了，注意如果直接npm install babel-loader，默认是安装8.0.0的，所以不兼容） 配置webpack.congfig.js 在rules里加入对js代码的过滤 { test: /\\.js$/, loader: &apos;babel-loader&apos;, options:{ presets:[&quot;es2015&quot;] }, exclude:[/node_modules/] } 建.babelrc文件 在项目根目录新建一个文件名为.babelrc的文件，填入以下内容： { &quot;presets&quot;: [&quot;es2015&quot;] } 这是网上流传最广的办法，不过步骤繁琐，麻烦，下面介绍最优解决方案 3.使用uglifyes-webpack-plugin插件其实上面的坑都是我一个一个经历的，网上的解决办法都是不完整，当我踩完所有坑，感觉这个方法太繁琐了。然后我就准备去深入了解一下uglifyjs-webpack-plugin这个插件，结果无意间发现uglify有一个专门针对ES6的插件uglifyes-webpack-plugin，哇，一试就知道有多爽，完全没有那么多步骤： 安装： npm install uglifyes-webpack-plugin webpack.config.js： const UglifyEsPlugin = require(&quot;uglifyes-webpack-plugin&quot;); plugins:[ new MiniCssExtractPlugin({ //css压缩 filename:&apos;[name][hash].css&apos;, chunkFilename:&apos;[id].[hash].css&apos; }) ], optimization:{ minimizer :[ new UglifyEsPlugin({}), //直接引用 new OptimizeCSSAssetsPligin({}) //css压缩 ] 其实就一句话：new UglifyEsPlugin({}),,与uglifyjs-webpack-plugin的使用一样简单。 需要注意的是uglifyes-webpack-plugin与uglify-es-webpack-plugin并不是同一个插件，前者是官方的，也就是与uglifyjs-webpack-plugin一个维护者的，而后者已被弃用并不再维护 Point 该插件默认就会将ES6代码改成ES5代码，并且有压缩，混淆等功能，与uglifyjs-webpack-plugin基本一致，下面是他的一些重要的API： test:匹配的文件，默认/.js($|?)/i，接受正则表达式 mangle:是否混淆代码，默认为true sourceMap：是否启用SourceMap,默认为false compress: 自定义压缩选项，内容是一个对象，默认{}，该选项下的子选项很重要，提一下 sequences：是否使用逗号运算符来连接连续的表达式，默认true properties：是否优化属性读取方式：a[“foo”] → a.foo，默认true dead_code：是否丢弃不可达代码，默认true drop_debugger：是否丢弃调试语句，默认true unsafe：是否优化危险代码，默认false conditionals：是否优化 if-else 条件语句，默认true comparisons：是否优化比较代码，默认true evaluate：是否直接计算常量的值，默认true booleans：优化布尔表达式，默认true loops：是否优化循环代码，默认true unused：是否丢弃不使用的变量，函数，默认true。这里需要注意，如果你的函数本来就是一个DOM触发事件函数，请关闭此选项，否则，该函数将会被丢弃！！！ hoist_funs：是否提升函数的申明，默认true hoist_vars：是否提升变量的申明，默认false if_return：是否优化优化if/return 和 if/continue join_vars：是否将加入变量申明，默认true cascade：优化连续语句，将 x, x 转成 x，x = something(), x 转成 x = something()——声明变量，默认true side_effects：丢弃副作用声明，默认true warnings：警告潜在的危险优化/代码，默认true global_defs：定义全局变量，默认{} extractComments：是否要删除注释，默认false，接受boolean，正则，函数，对象。 include： 要转化的文件，默认无，接受字符串，正则 exclude：在test验证通过后不转化的文件，默认空，接受字符串，正则 相较于uglifyjs-webpack-plugin，uglify-es-webpack-plugin功能要相对少一些，但基本也能满足要求 附uglifyjs-webpack-plugin常用API： test：测试匹配的文件，接受String|RegExp|Array&lt;String|RegExp&gt;,默认/.js(?.*)?$/i cache: 是否启用文件缓存 ，接受Boolean|String,默认false parallel:是否启用多进程来提高构建速度，接受Boolean|Number，默认false sourceMap: 是否启用SourceMap(将错误信息映射值模块源文件)，开启可能会降低编译速度，接受Boolean，默认false uglifyOptions：压缩选项 extractComments：是否保留注释，接受Boolen,String,RegEXp,function,Object,默认false warningsFilter:允许过滤uglify-js警告。返回true以保持警告，否则为false。接受Function&lt;(warning, source) -&gt; Boolean&gt; Default: () =&gt; true 最后是UglifyJS的官网。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Image对象的complete与onload()事件(以及Canvas的drawImage()函数)","slug":"Image对象的complete与onload()事件(以及Canvas的drawImage()函数)","date":"2019-03-12T11:45:26.000Z","updated":"2019-03-12T11:53:08.590Z","comments":true,"path":"2019/03/12/Image对象的complete与onload()事件(以及Canvas的drawImage()函数)/","link":"","permalink":"http://yoursite.com/2019/03/12/Image%E5%AF%B9%E8%B1%A1%E7%9A%84complete%E4%B8%8Eonload()%E4%BA%8B%E4%BB%B6(%E4%BB%A5%E5%8F%8ACanvas%E7%9A%84drawImage()%E5%87%BD%E6%95%B0)/","excerpt":"问题之前基本看完了canvas的API，准备做一个小游戏，emmm，然后今天就遇到了问题，我本来以为是canvas的问题，但是仔细分析之后才发现是JS中的问题：","text":"问题之前基本看完了canvas的API，准备做一个小游戏，emmm，然后今天就遇到了问题，我本来以为是canvas的问题，但是仔细分析之后才发现是JS中的问题： 回顾关于HTML与JS的关系可以从网页的加载顺序来看，当浏览器打开网页的时候，网页由上至下的解析该网页，然后开始构建DOM树(Document Object Model)(属于JavaScript)，也就是说将HTML的每一个标签构建成一个相应的对象，但是DOM整体就是一个对象，每一个标签是其的一个子对象，对比与JSX有些相似,遇到JS或CSS时利用相应引擎进行解析。从这里就可以理解出，在网页完成加载后，每一个标签就成为了DOM这个对象里的一个子对象，我们使用相应的方法，比如Document.getElementById(“xxx”)就可以获取相应的对象，并进行操作。 Image()对象由上可知，Image()也是一个节点对象，只是是否渲染至页面上的问题。 Image对象的属性 属性 描述 属性 描述 align 设置或返回与内联内容的对齐方式。 align 设置或返回与内联内容的对齐方式。 alt 设置或返回无法显示图像时的替代文本。 alt 设置或返回无法显示图像时的替代文本。 border 设置或返回图像周围的边框。 border 设置或返回图像周围的边框。 complete 返回浏览器是否已完成对图像的加载。 complete 返回浏览器是否已完成对图像的加载。 height 设置或返回图像的高度。 height 设置或返回图像的高度。 hspace 设置或返回图像左侧和右侧的空白。 hspace 设置或返回图像左侧和右侧的空白。 id 设置或返回图像的 id。 id 设置或返回图像的 id。 isMap 返回图像是否是服务器端的图像映射。 isMap 返回图像是否是服务器端的图像映射。 longDesc 设置或返回指向包含图像描述的文档的 URL。 longDesc 设置或返回指向包含图像描述的文档的 URL。 lowsrc 设置或返回指向图像的低分辨率版本的 URL。 lowsrc 设置或返回指向图像的低分辨率版本的 URL。 name 设置或返回图像的名称。 name 设置或返回图像的名称。 src 设置或返回图像的 URL。 src 设置或返回图像的 URL。 useMap 设置或返回客户端图像映射的 usemap 属性的值。 useMap 设置或返回客户端图像映射的 usemap 属性的值。 vspace 设置或返回图像的顶部和底部的空白。 vspace 设置或返回图像的顶部和底部的空白。 width 设置或返回图像的宽度。 width 设置或返回图像的宽度。 标准属性 属性 描述 className 设置或返回元素的 class 属性。 title 设置或返回元素的 title。 Image对象的事件句柄 事件句柄 描述 onabort 当用户放弃图像的装载时调用的事件句柄。 onerror 在装载图像的过程中发生错误时调用的事件句柄。 onload 当图像装载完毕时调用的事件句柄。 浅谈图片加载complete属性：图片显示出来之后其属性由false变为true在这个属性上，IE与其他浏览器有所不同，IE是根据图片的src属性是否是一个有效的图片地址值。即，在IE下，只有当image()对象的src值为一个正确的图片地址时，complete值才为true，否则一直为false，但是在其他浏览器下，当image()对象呗定义完成的时候，其complete值就为true，不会检测其src属性的有效性 也就是说：complete这个属性在IE系浏览器与其他浏览器的判断方式不一样，所以对于适配性来说，最好不用 onload()回调事件onload()是当图像装载完毕后调用的函数。关键是如何才算是装载完毕，经测试， 当我们直接在HTML中定义一个标签，并且在其中规定其onload事件，只有当src属性填写正确时，才算是装载完成，否则onload事件一直不触发，直至修改其src值为有效图片地址的时候才算是装载完成。 当我们在JS代码中手动生成一个Image()对象时，无论其src值是否被赋值为有效的图片地址，其onload事件总会触发，即当我们手动生成一个 Image 对象时，一旦其被生成，则认定为装载完成，立即调用onload事件。至于原因，我还没弄明白，看来需要深入的去了解一下浏览器机制，才能明白这一点。 Canvas中悟到的Image对象的用发法 ctx.drawImage(img,x,y)中的Img应当是一个Image对象，可以是从DOM树中获取的Image()子对象，也可以是一个自己定义的Image()对象，不管是这两者中的哪一者，再绘制到画板上时，都必须将绘制语句写到该对象的onload()函数中，其原因在于，Image()的定义是一个异步执行的操作，也就是说，在执行到let img = new Image()时，JS引擎不会等待该语句执行完毕在继续执行，而是直接继续执行，在对象定义完成时，就会自动调用其onlaod.onerror,onabort回调事件。那么问题就是，可能在对象还没有定义完成的时候，已经执行到了ctx.drawImage()这一条语句，所以绘制不出任何效果(而且大部分情况下，JS语句的执行都是快于对象的定义，所以基本上都绘制不出图形)。所以所有的Canvas图形绘制都必须是在onload中进行的。 问题又出现了，那如果要就行较大型的图形绘制，我不可能把所有代码都写到一个函数里吧，所以再写多个函数时就要多次调用onload事件，但是一个图片的onload事件只能执行一次。所以我想到了一种错误的方法，在不同寒暑表中多次载入同一张图片，并分别调用其回调函数onload，结果当然是失败了。这种情况下onload事件的顺序是无法确定的，即使你是前后分别执行，因为onload函数是异步进行的，现在惟一的办法就是把这张图片统一载入，然后想办法将下面的代码都建立在onlaod函数执行的前提下。然后我找到了一种方法： let img = new Image(); img.addEventListener(‘onload’,’start’,’true’); function start(){ draw1(); draw2(); } fucntion draw1(){ ctx.drawImage(); ... } fucntion draw1(){ ctx.drawImage(); ... } 上面这么写的好处在于，所有的函数后在onload回调函数之后执行了，确保了绘图的正确性。 Last but not least 我在网上搜了很久，在讲解onload()事件时基本就一篇文章，被抄了无数次，但是我试验却发现和文章中的结果完全不一样。文章中写到，即使是在JS代码中定义一个Image()对象时，只要src不赋值，其onload事件就不会触发，但是~像我上面实验的那样，我试验了很多次，都是那样的结果，测试了Chrome，Firefox，IE，Edge，每个浏览器的测试都一样。可能是那篇文章已经是很久之前的了，但是这些同学从未自己试过，直接就抄过去了。所以实践才是真理啊。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"canvas基础","slug":"canvas基础","date":"2019-03-10T13:56:25.000Z","updated":"2021-03-08T02:36:51.217Z","comments":true,"path":"2019/03/10/canvas基础/","link":"","permalink":"http://yoursite.com/2019/03/10/canvas%E5%9F%BA%E7%A1%80/","excerpt":"创建canvas画布css: canvas{ border:3px solid blue; } html: &lt;canvas width=&quot;700&quot; height=&quot;700&quot; id=&quot;myCanvas&quot;&gt; 您的浏览器不支持canvas，请更换浏览器访问！ &lt;/canvas&gt; Javascript: &lt;script&gt; let canvas = document.getElementById(&quot;myCanvas&quot;); let ctx = canvas.getContext(&quot;2d&quot;); &lt;/script&gt;","text":"创建canvas画布css: canvas{ border:3px solid blue; } html: &lt;canvas width=&quot;700&quot; height=&quot;700&quot; id=&quot;myCanvas&quot;&gt; 您的浏览器不支持canvas，请更换浏览器访问！ &lt;/canvas&gt; Javascript: &lt;script&gt; let canvas = document.getElementById(&quot;myCanvas&quot;); let ctx = canvas.getContext(&quot;2d&quot;); &lt;/script&gt; Point: canvas标签是一个双标签，其内部写的是当浏览器不支持canvas时显示的内容，可以插入其他元素，比如文字，图片等。 canvas画布的宽高因该在其标签内定义，不能在其CSS内定义，否则其绘制的图像会按照300*150发生缩放。 所有绘图行为都在script标签中进行。 let ctx = canvas.getContext(“2d”); 所有canvas的API都是定义在该对象上的，其中参数可以是2D，或者3D. Canvas绘制图像canvas的绘制图形有两种方式： context.fill() fill()指的是填充，其默认颜色是黑色，可以在使用fill()之前使用fillStyle()方法改变填充颜色，如果是闭合图像，那么就直接填充。如果是非闭合的路径，则fill()先帮其闭合，然后填充。 12ctx.fillStyle = \"red\";//设置填充色ctx.fillRect(10,10,100,100);//绘制一个填充矩形 context.stroke() stroke()方法会实际的绘制出moveTo()和lineTo()方法的路径。默认颜色是黑色，在绘制之前，可以使用strokeStyle()进行设置。 12ctx.strokeStyle = \"red\";//设置边框填充色ctx.strokeRect(10,10,100,100);//绘制空心矩形 绘制矩形绘制基本矩形12ctx.fillRect(x,y,height,width)//实心矩形ctx.strokeRect(x,y,height,width)//空心边框 x:起点的x坐标(即左上角的x坐标) y:起点的y坐标(即左上角的y坐标) height:矩形的高 width:矩形的宽 改变颜色1234ctx.fillStyle = \"red\";//设置填充颜色ctx.fillRect(10,10,100,100);ctx.strokeStyle = \"red\";//设置边框颜色ctx.strokeRect(200,200,100,100); Point: ctx.fillStyle = “red”用来设置填充颜色 ctx.strokeStyle = “red”用来设置边框颜色 这些描述都要放在绘制图形之前声明 擦除矩形区域 ctx.clearRect(x,y,height,width) ctx.clearRect(50,50,200,200)//绘制一个矩形区域并擦除该区域之前的内容 绘制圆形绘制基本圆实心圆 ctx.arc(x,y,radius,starAngle,endAngle,anticlockwise) x:圆心的x坐标 y:圆心的y坐标 radius:半径 startAngle:开始角度 endAngle:结束角度 anticlockwise:旋转方向， true:逆时针(可选参数，默认为false) false:顺时针 123ctx.fillStyle = \"red\"; //设置填充色ctx.arc(200,200,50,0,Math.PI*2,true);//绘制圆形ctx.fill();//填充 空心圆12345ctx.beginPath()ctx.arc(200,200,50,0,Math.PI*2,true);ctx.strokeStyle = \"red\"; ctx.closePath();ctx.stroke(); Point 上面用到了路径，实际ctx.arc()相当于是一个lineTo()的一个集合。利用其绘制出一个圆形，最后要关闭(ctx.cloePath())，以及要(stroke())才能完全绘制出该图形。 非完整圆如果要绘制一个非完整的圆，比如一个实心半圆，该如何绘制呢？ 答案是使用arc方法中的startAngle和endAngle来改变。 12ctx.fillStyle = \"red\";ctx.arc(200,200,50,0,Math.PI,true); 空心圆形 12345ctx.beginPath();ctx.strokeStyle = \"red\";ctx.arc(400,400,100,0,Math.PI);ctx.closePath();ctx.stroke(); 绘制线段 moveTo(x,y):把画笔移动至画布的制定位置，不创建线条 lineTo(x,y):添加一个点(x,y) stroke():按照之前添加的点绘制路径 1234ctx.strokeStyle = \"red\";//设置填充色ctx.moveTo(0,0);//将画笔移动至(0,0)ctx.lineTo(100,100);//添加一个点(100,100)ctx.stroke();//按点绘制路径 Point 如果没有在第一次指定moveTo(x,y)，则第一个lineTo(x,y) == moveTo(x,y) 如果在lineTo()后没有使用moveTo()方法，则依次连接，eg： ctx.moveTo(0,0); ctx.lineTo(10,10); ctx.lineTo(20,20); ctx.lineTo(30,30); ctx.stroke(); 则画出后是一段从点(0,0)=&gt;(10,10)=&gt;(20,20)=&gt;(30,30)的一段折线。 ctx.beginPath():开始一段路径 ctx.closePath()：闭合路径，即canvas会自动将未闭合的线段的首尾连接起来。 eg(一个三角形): ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(10,10); ctx.lineTo(20,20); ctx.closePath(); ctx.stroke(); 案例(六边形)： var n = 0; var dx = 150;//路径开始x坐标 var dy = 150;//路径开始y坐标 var s = 100;//边长 ctx.beginPath();//路径开始 ctx.fillStyle = &apos;pink&apos;;//设置填充色 ctx.strokeStyle = &apos;rgb(0,0,100)&apos;;//设置边框颜色 var dig = Math.PI / 3;//计算偏移角度 for (var i = 0; i &lt; 6; i++) { var x = Math.sin(i * dig);//计算以下个点的x坐标的增量 var y = Math.cos(i * dig);//计算下一个点的y坐标的增量 ctx.lineTo(dx + x * s, dy + y * s);//绘制下一个点 //console.log( x ,y ) } ctx.closePath();//闭合整个路径 ctx.fill();//设置填充 ctx.stroke();//绘制路径 Point 这个例子用了一点数学知识，主要是： for (var i = 0; i &lt; 6; i++) { var x = Math.sin(i * dig);//计算以下个点的x坐标的增量 var y = Math.cos(i * dig);//计算下一个点的y坐标的增量 ctx.lineTo(dx + x * s, dy + y * s);//绘制下一个点 //console.log( x ,y ) } 其原理是利用了简单的沟股定理，计算下一个点的坐标 线性渐变 let lg = ctx.createLinearGradient(xStart,yStart,xEnd,yEnd) lg.addColorStop(offset,color) xSart:渐变开始点的x坐标 yStart：渐变开始点的y坐标 xEnd：渐变结束点的x坐标 yEnd：渐变结束点的y坐标 offset:设定的颜色离渐变结束点的偏移量 color:绘制的颜色 eg: let lg = ctx.createLinearGradient(0,0,100,200); lg.addColorStop(0,”#E55D87”); lg.addColorStop(1,”#5FC3E4”); ctx.fillStyle = lg; ctx.fillRect(0,0,200,200); Point 线性渐变仅仅是相当于设置填充色，在定义完填充色之后，我们还需要将填充设置为该线性渐变(ctx.fillStyle = gl) 由于线性渐变仅仅是设置填充色，所以具体的背景容器还需要我们自己设置，比如设置一个矩形作为容器ctx.fillRect(0,0,200,200) 由于渐变背景的坐标是相对于画布，而图形的坐标也是相对于画布，所以在定义背景时，需要注意与图形的坐标搭配以达到需要的效果 径向渐变 12let rg = ctx.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)rg.addCOlorStop(offset,color); xSart:发散开始的圆心x坐标 yStart：发散开始的圆心y坐标 radiusStart：发散开始圆的半径 xEnd：发散结束圆心的x坐标 yEnd：发散结束圆心的y坐标 radiusEnd：发散结束圆的半径 offset：设定的颜色结束点的偏移量(0-1) color:绘制颜色 12345678var g1 = ctx.createRadialGradient(200, 150, 0, 200, 150, 200); g1.addColorStop(0.1, '#F09819'); g1.addColorStop(1, '#EDDE5D'); ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(200, 150, 100, 0, Math.PI * 2, true); ctx.closePath(); ctx.fill(); 图形变形缩放 scale(x,y) x:x坐标轴按x比例缩放 y:y坐标轴按y比例缩放 前面参数的是按倍数来衡量的(0.5=&gt;50%,1=&gt;100%,2=&gt;200%) eg: 1234567ctx.strokeStyle = \"red\"; ctx.scale(2,2); ctx.strokeRect(5,5,25,15); ctx.scale(2,2); ctx.strokeRect(5,5,25,15); ctx.scale(2,2); ctx.strokeRect(5,5,25,15); Point 缩放一个图形，先使用ctx.scale(x,y)对画布进行缩放处理，后面再创建要缩放的工具ctx.strokeRect(5,5,25,15);。 缩放的原点都是在(0,0)位置。 旋转 ratate(angle) angle:旋转的角度，以弧度计。 eg: 1234ctx.strokeStyle = \"red\";// ctx.strokeRect(5,5,200,200);ctx.rotate(20*Math.PI/180);//旋转5°ctx.strokeRect(5,5,200,300); Point: 默认的旋转中心是在(0,0)位置。下面介绍如何改变旋转中心。 平移 translate(x,y) x:坐标原点向x轴平移x y:坐标原点想y轴平移y eg1(以矩形中心为原点旋转)： 1234567891011ctx.strokeStyle = \"red\"; //以(0,0)为原点绘制一个起点为(200,200)，边长为200的正方形 ctx.strokeRect(200,200,200,200); //移动原点至(300,300)，即上面矩形的中心位置 ctx.translate(300,300); //将画布进行一个45°的旋转，得到一个旋转后的图形 ctx.rotate(45*Math.PI/180); //将原点坐标改为(0,0) ctx.translate(-300,-300); //绘制出旋转后的矩形 ctx.strokeRect(200,200,200,200); eg2(以矩形中心为原点缩放图形): 123456ctx.strokeStyle = \"red\";ctx.strokeRect(200,200,100,100);ctx.translate(250,250);ctx.scale(2,2);ctx.translate(-250,-250);ctx.strokeRect(200,200,100,100); Point 上面提到的，scale,rotate方法的操作都是对画布而言的，貌似整的canvas的思维都是这样，需要我们有反向思考的能力。 组合图形 1globalCompositeOperation = type 后绘制的图形如何与之前的图像叠加渲染，取决与type。下面是type的种类： source-over(默认):在原图形之上绘制(覆盖)。 destination-over:在原图形之下绘制。 source-in:显示原有图形和新图形的交集，新图形在上，所以颜色为新图形颜色 destination-in:显示原图形和新图形的交集，原图形在上，所以颜色为原图形的颜色 source-out:只显示新图形的非交集部分 destination-out:只显示旧图形的非交集部分 source-atop:显示原图形和交集部分，新图形在上，所以交集部分为新图形颜色 destination-atop：显示新图形和交集部分，新图形在上，所以交集部分为新图形颜色 lighter：显示原有图形和新图形，交集部分做颜色叠加 copy:只显示新图形 eg: 12345ctx.globalCompositeOperation = \"lighter\"; ctx.fillStyle = \"red\";ctx.fillRect(50,50,200,200); ctx.fillStyle = \"blue\";ctx.fillRect(100,100,200,200); Point 该属性与上面的ctx.translate(x,y)一样，一旦作用，就对下面的元素都起作用，如果要还原，请在此使用该属性还原。 阴影 shadowOffsetX:设置或返回阴影距形状的水平距离(默认值为0)-shadowOffsetY:设置或返回阴影形状的垂直距离(默认值为0) shadowColor:设置或返回阴影的颜色 shadowBlur:设置或返回阴影的模糊级别(值越大越模糊) eg: ctx.shadowOffsetX=20; ctx.shadowColor=”blue”; ctx.shadowBlur = 50; ctx.fillStyle = “red”; ctx.fillRect(100,100,200,200); 1234ctx.shadowBlur = 0;ctx.shadowOffsetX = 0;ctx.fillStyle = \"yellow\";ctx.fillRect(400,400,100,100); Point 相同的是，阴影属性也是对一下的所有图形都生效。要取消阴影效果，必须重置: 12ctx.shadowBlur = 0;ctx.shadowOffsetX = 0; 图像操作 drawImage(img,x,y):在画布上定位图像 drawImage(img,x,y,width,height):在画布上定位图像，并规定图像的宽度和高度 drawImage(img,sx,sy,swidth,sheight,x,y,width,height) img:规定要使用的图像，画布或视频 sx(可选):开始剪切的x坐标位置 sy(可选):开始剪切的y坐标位置 swidth(可选):被剪切的图像的宽度 sheight(可选):被剪切的图像的高度 x:在画布上放置img的x坐标位置 y:在画布上放置img的y坐标位置 width(可选):要使用的图像的宽度。(拉伸或压缩) height(可选)：要使用的图像的高度。(拉伸或压缩) eg: 12345let img = new Image();img.src = \"expi.jpg\";img.onload = function()&#123; ctx.drawImage(img,100,100,200,200,200,200,200,200);&#125; Point img因该是一个img对象，img = new Image()或者是一个Image的DOM标签document.getElementById(&quot;img&quot;)(实际也是一个Image对象，因为在HTML中，每创建一个img标签，就会自动创建一个Image对象。) 在使用该标签时，应当使用，Image对象的回调函数onload,否则不能渲染成功，其原因是: 12let img = new Image(); img.src = \"expi.jpg\"; 这个过程中，对img.src赋值的时候，可能还没有赋值完成，就进行了ctx.drawImage语句，由于还没赋值完成，此使img.src还是空，所以无法渲染出来。 图像平铺 createPattern(image,type) type: no-repeat:不平铺 repeawt-x:按x轴方向平铺 repeat-y:按y轴方向平铺 repeat：全方向平铺 eg: let img = new Image; img.src = “beauty.png”; img.onload = function(){ let pattern = ctx.createPattern(img,”repeat-x”); ctx.fillStyle = pattern; ctx.fillRect(10,10,500,500); } Point 相同的是，必须要配合Image的oload回调函数来使用，道理同上。 图像剪切 clip() 该函数的使用方法： 创建剪切区域:ctx.rect(x,y,width,heigth) 设置剪切部分的填充色:ctx.fillStyle = “pink” 进行填充:ctx.fill(); 进行剪切:ctx.clip(); eg: 12345678910ctx.fillStyle = \"yellow\";ctx.fillRect(0,0,300,300);ctx.rect(100,100,500,500);ctx.fillStyle = \"pink\";ctx.fill();ctx.clip();ctx.fillStyle = \"blue\";ctx.fillRect(0,0,200,200); Point -一旦剪切了某个区域，则之后的所有绘图都会被限制在被剪切区域内进行（不能访问画布上的其他区域）。我们也可以在使用clip()方法之前通过使用save()方法将之前的画布保存下来,并在任意时间使用restored()方法。 绘制文字 fillText(text,x,y):绘制实心文字 x:文字的中心点x坐标 y：文字的中心点y坐标 strokeText():绘制文字描边(空心文字) textAlign：设置或返回文字内容的当前对齐方式(注意：其都是相对于该文字对象的中心)，其值有： start:默认。文本在指定的位置开始。 end:文本在指定的位置结束。 left:文本左对齐。 center:文本的中心被放置在指定的位置。 right:文本右对齐。 textBaseline：设置会返回在绘制文本时使用的当前文字基线,其值有： Bottom：文本基线是 em 方框的底端。 Top：文本基线是 em 方框的顶端。 Middle：文本基线是 em 方框的正中。 Alphabetic：默认。文本基线是普通的字母基线。 hanging：文本基线是悬挂基线。 font:设置或返回文本内容的当前文字属性 eg: 12345ctx.font = \"40px Arial\";ctx.textAlign = \"center\";ctx.fillText(\"Hello World\",200,200);ctx.strokeText(\"Hello World\",200,300);console.log(ctx.textBaseline);","categories":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/categories/Canvas/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"JavaScript中的.与[]的区别","slug":"JavaScript中的.与[]的区别","date":"2019-03-03T04:17:00.000Z","updated":"2019-03-03T05:04:01.331Z","comments":true,"path":"2019/03/03/JavaScript中的.与[]的区别/","link":"","permalink":"http://yoursite.com/2019/03/03/JavaScript%E4%B8%AD%E7%9A%84.%E4%B8%8E[]%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"叨叨一下最近在看ES6，感觉很有意思啊。然后就遇到了这个问题，.(点)与[] (方括号)的区别。","text":"叨叨一下最近在看ES6，感觉很有意思啊。然后就遇到了这个问题，.(点)与[] (方括号)的区别。 正文这个问题是在遍历器(Iterator)这一部分发现的，其中对于不存在遍历器的数据结构，比如一个对象。我们可以自定义一个遍历器，就可以实现forEach,for…in…等方法。然后就出现下面这段语句： var arrlike = { 0:a, 1:b, 2:c } arrlike.[Symbol.iterator](){ //遍历器内容，略 } 问题就在：arrlike.[Symbol.iterator]()，如果Symbol是对象arrlike的一个属性，那么为什么不能用arrlike.Symbol…的方法来获取该属性。 下面就说一下这两个的区别： 相同: .与[]都可以获取元素的属性。 不同: 中括号运算符可以用字符串变量的内容作为属性名。点运算符不能。 中括号运算符可以用纯数字为属性名。点运算符不能。 中括号运算符可以用js的关键字和保留字作为属性名。点运算符不能。 说回上面的arrlike.[Symbol.iterator](),Symbol.iterator是一个JS内置的一个关键字，然后这个属性返回的是一个函数。 然后后面的括号就是执行该函数。 function fun1(){return &quot;yes&quot;} console.log(func1) //function... console.log(func1()) //yes LastES6还是真的有意思，加油鸭！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JSP实战项目:学生信息管理系统的总结","slug":"JSP实战项目-学生信息管理系统的总结","date":"2019-02-09T04:38:11.000Z","updated":"2019-02-09T09:26:53.927Z","comments":true,"path":"2019/02/09/JSP实战项目-学生信息管理系统的总结/","link":"","permalink":"http://yoursite.com/2019/02/09/JSP%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"前言简单学习了一下JSP，不知道以后老师怎么教的，不过我是感觉到JSP的真谛还是Java，无论是按照MVC或者三层模式，一般Control层都是servlet来写，Model层都是用纯java来写，当然，在JSP文件中，也是可以进行这些操作的，毕竟在JSP的&lt;%…%&gt;中完全可以写java代码，而servlet的本质就是java的一个类。但是一般在开始时总是界面与逻辑分开，否则整个项目结构混乱，代码冗余。所以我觉的学JSP本质还是学java，学servlet。","text":"前言简单学习了一下JSP，不知道以后老师怎么教的，不过我是感觉到JSP的真谛还是Java，无论是按照MVC或者三层模式，一般Control层都是servlet来写，Model层都是用纯java来写，当然，在JSP文件中，也是可以进行这些操作的，毕竟在JSP的&lt;%…%&gt;中完全可以写java代码，而servlet的本质就是java的一个类。但是一般在开始时总是界面与逻辑分开，否则整个项目结构混乱，代码冗余。所以我觉的学JSP本质还是学java，学servlet。 正文整个项目差不多就包含学生信息的增删改，准备添加一个文件上传，不过还没添加，嘿嘿嘿。后面再说。 在这个过程中我遇到了不少问题，下面我就想起什么就讲什么吧~ 前端部分 前端完美居中之flex布局： 在登陆界面这种只需要一个div完美居中的情况，flex布局是在一个不错的方法： body{ display:flex;//设置body为flex布局 justify-content:center; //设置布局主轴上的对齐方式为居中 align-items:center;//设置另一轴的对齐方式为居中 } 这种布局下，body里的内容就会完美居中。 另外在回顾一下flex布局里的所有属性： 容器属性 flex-direction: 决定主轴的方向，即项目排列的方向，有四个可能的值：row(默认)|row-reverse|column|column-reverse flex-wrap:默认情况下，item排列在一条线上，即主轴上，flex-wrap决定当排列不下时是否换行以及换行的方式，可能的值nowrap(默认)|wrap|wrap-reverse flex-flow:flex-direction和flex-wrap的简写形式，如：row wrap|column wrap-reverse等。默认值为row nowrap，即横向排列 不换行。 justify-content:决定item在主轴上的对齐方式，可能的值有flex-start（默认），flex-end，center，space-between，space-around。 align-items:决定了item在交叉轴上的对齐方式，可能的值有flex-start|flex-end|center|baseline|stretch align-content:该属性定义了当有多根主轴时，即item不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，定义了align-content后，align-items属性将失效。 容器属性 order：order的值是整数，默认为0，整数越小，item排列越靠前。 flex-grow：定义了当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大；可能的值为整数，表示不同item的放大比例 flex-shrink：定义了当容器空间不足时，item是否缩小。默认值为1，表示当空间不足时，item自动缩小，其可能的值为整数，表示不同item的缩小比例。 flex-basis：表示项目在主轴上占据的空间，默认值为auto，其可为具体数值(px)。 flex：flex属性是flex-grow、flex-shrink和flex-basis三属性的简写总和。 align-self： align-self属性允许item有自己独特的在交叉轴上的对齐方式，它有六个可能的值：auto|flex-start|flex-end|center|baseline|stretch。默认值为auto。 前端onsubmit属性 这个属性真有点用~这个属性是用在submit按钮上的，他可以在你提交表单之前进行数据的审核。在审核通过后再上传，如果审核不通过，则不提交。具体代码如下。 //表单部分 &lt;input type=&quot;submit&quot; value=&quot;提交&quot; onsubmit=&quot;return check()&quot;&gt; //JS部分 function check(){ //执行判断，注意要返回一个boolean值，该值来确定是否需要提交表单 } Jquery的ajax请求 由于原生JS的ajax请求有点负载，所以我还是采用了jquery。所以还是具体介绍一下jquery的ajax请求。 1. $(“#id”).load(url,data,function(response,status,xhr)) 这种请求方法可以直接将请求到的数据添加到指定元素中（其本质还是get()方式）。 url：（必选）请求的地址 data:（可选）要发送的数据,采用键值存储发送，多个数据时采用花括号：{key1:value1,key2:value2} function():（可选），在服务器反馈后执行的函数。 response：服务器返回的数据 status：服务器返回的status值 xhr：服务器返回的xhr对象 2. $.get(url,data,function(response,status,xhr) 这个基本的get请求，get()只请求数据，不对数据做任何处理。 但是jquery将jsonp也封装进了get方法中，所以我们再调用get方法时，可以使用jsonp进行传输，但一般是是直接传字符串: $.get(url,data,function(data,status,xhr){}) 如果需要使用JSONP来请求，需要再声明： $.get(url,data.function(data,status,xhr){},&quot;JSONP&quot;) 关于JSON与JSONP，可以看一下这一篇文章，还是比较易懂。 3. $.get(url,data,function(response,status,xhr) 回顾一下，get与post： get: 数据追加到url中传输，因此保密性较差，直接可视化，不适用于账户，密码等信息的传输。 由于url的限制，也不适用于较长数据的传输，一般url的数据量在1KB左右。 由于使用url直接传输，因此传输效率会比post方式高。 post： post是将数据封装为HTTP消息发送给服务器，这样做有以下优点： 数据传输量相较于get()方法得到提升，一般文件传输都是利用该方法 数据保密性得到一定性的保护，无法直接获取，但需要注意的是，通过抓包，任然可以获得post提交的所有数据。所以我们在传输密码时，一般是通过加密传输，不传明文密码。这一点，在HTTPS中得到了较好的解决。但是HTTPS需要申请且价格昂贵，所以目前对于数据的加密任是最好方法。 4.$.ajax({ type:”get”,url:”url”,data:””,async:true,function(data,status,xhr){} }) 注意：async即异步，一般默认是true，即，你删掉async这个选项，则默认为true，还记得ajax的含义么： Asynchronous JavaScript and XML 第一个就是async，所以如果是false，就没意义了对吧，不过也许有的情况有用，了解到就好。 5. $.getJSON(url,data,function(response,status,xhr) 我觉得这是jquery中最好用的一个方法了，因为他将请求到的JSON字符串直接转换为JSON对象了，直接用key和value属性就可以使用了，舒服的板~ JS的cookies的使用 之前一直是使用的localStorage或者sessionStorage来存储数据，使用这个就很便捷，直接使用key来取value值就行了，我好像还有一个专门的文章来介绍，不过最终好像还是cookies使用的较多一点，可能是兼容性的原因，然年后我发现cookies的使用比localStorage要复杂一些，所以还是看一下： 设置cookie： function setCookie(cname,cvalue,exdays) { var d = new Date();//实例化一个时间 d.setTime(d.getTime()+(exdays*24*60*60*1000));//设置过期时间的变量 var expires = &quot;expires=&quot;+d.toUTCString();//将Date()对象转化为数组 document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;//设置cookie } 获取cookie值： function getCookie(cname) { var name = cname + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;);//分割cookie字符串 for(var i=0; i&lt;ca.length; i++) { var c = ca[i].trim();//去除空格 if (c.indexOf(name)==0) return c.substring(name.length,c.length); }//搜索是否存在该cookie，是则返回值 return &quot;&quot;; } 注意：可以看出，JS的cookie的API设计似乎没有localStorage那么友好，毕竟很多年前的东西了。所以document.cookie是直接获得整个cookie，以键值对用”=”连接起来，具体获得对应的值还需要我们自己来处理字符串，emmmm，从体验上来说，没有那么友好，但还有一点值得注意的是，document.cookie是一个方法，当你对他进行赋值操作的时候。他是直接识别”=”添加键值，而对其进行取值的时候，是以字符串返回所有的cookie值。 上面获取cookie的方法不是唯一的，因为处理字符串的方式不是唯一的，包括正则也是不错的方法 后端部分 关于MVC的理解我觉得也是学到的一部分，即将视图，模型，控制分离，而且无论是哪种设计方式，最终目的是保证层次的清晰。这样无论是对一次开发还是重构，都是及其重要的。 另外对于JSP这门后端语言，我觉得要理解其精髓，还是要学习servlet，java。因为model，controller层，一般都是采用servlet或者java来开发，似乎很少有用JSP来写逻辑层面的东西的。 在开发时我遇到了一个BUG卡了我好几天，搜索也没有结果，知道我理解其原因，啧啧啧： 我用java写好后端数据库交互层后，直接写了mian函数进行测试，成功！但是在我使用JSP文件发送ajax请求时，后端文件报错，无法找到sql驱动文件，我检查了sql文件，确实是在Java Resource的library中，并且直接运行java文件也通过了。。。搜索了很久，突然想到既然是javaweb程序，是不是在调用库文件时时使用的WebContent-&gt;WEB-INF-&gt;lib下的库文件，而不是调用java的库文件。我直接将sql驱动添加到javaweb的库中。nice，运行成功！ 关于eclipse的问题，在测试的某一段时间，发现整个工程没有更新了，修改了代码也没有用，以前也发生过，一般重启一下server就ok了，可这次重启也没用，没办法，清除缓存把，我直接清除了工程的缓存。然后。。。就是java程序无法运行，一直报错：无法找到main函数入口。在网上看到很多这种情况，但一般都说是classpath设置不对，但我另一个工程却可以运行，所以明显不是这种情况，然后我看到了这篇文章我按照第二条的方法，发现我有个库文件报错，直接移除，ok，解决（可是这和我的main函数有什么关系呢？？？） 最后在java那些库文件的语法方面我就不再BB了，反正是固定的API，按文档写就OK（其实是我懒，哈哈哈）~~~ 最后 最后我觉得我还是有个大问题，那就是变量的命名问题。。。This is a problem。很多不规范，这个在我以后的实践中尽量解决，比如~写个文档啊，哈哈哈。 所以这个项目就告一段落，前端的框架看一下就开学了~~~只能开学去看Python的GUI编程了~","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"实战","slug":"实战","permalink":"http://yoursite.com/tags/%E5%AE%9E%E6%88%98/"}]},{"title":"JSP数据库处理","slug":"JSP数据库处理","date":"2019-01-31T08:50:58.000Z","updated":"2019-01-31T09:44:46.171Z","comments":true,"path":"2019/01/31/JSP数据库处理/","link":"","permalink":"http://yoursite.com/2019/01/31/JSP%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86/","excerpt":"JSP的数据库操作经过这两天的操作，我觉得还是要看视频或者买书或者看官方文档学习，网上的资料缺点太多，写的过于简单，甚至兼容性也有问题。所以，搞了一天，终于，把数据库搞出来了~","text":"JSP的数据库操作经过这两天的操作，我觉得还是要看视频或者买书或者看官方文档学习，网上的资料缺点太多，写的过于简单，甚至兼容性也有问题。所以，搞了一天，终于，把数据库搞出来了~ 源码分析sql.java package student.servlet; import java.sql.*; public class sql { public static void Update(){ Statement stmt = null; Connection connection = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } String name=&quot;root&quot;; String pwd=&quot;957837&quot;; String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;; try { connection = DriverManager.getConnection(url,name,pwd); System.out.print(&quot;数据库连接成功！&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { stmt = connection.createStatement(); String sqlString = &quot;insert into blog values(5,&apos;https&apos;,&apos;hhhhh&apos;,&apos;2015-8-9&apos;)&quot;; int lines = stmt.executeUpdate(sqlString); System.out.print(&quot;插入成功&quot;+lines+&quot;受影响&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { if(stmt != null) { stmt.close(); } connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public static void Select() { Statement stmt = null; Connection connection = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } String name=&quot;root&quot;; String pwd=&quot;957837&quot;; String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;; try { connection = DriverManager.getConnection(url,name,pwd); System.out.print(&quot;数据库连接成功&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { stmt = connection.createStatement(); String sqlString = &quot;select * from blog&quot;; ResultSet res = stmt.executeQuery(sqlString); System.out.println(&quot;查询数据库成功&quot;); while(res.next()) { int num= res.getInt(&quot;order_id&quot;); String title = res.getString(&quot;title&quot;); System.out.println(num); System.out.println(title); } } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { if(stmt != null) { stmt.close(); } connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public static void main(String[] args){ // Update(); Select(); } } 代码分析： 对于连接数据库这种操作，一般不在JSP中操作，而是用javabean来操作，也就是说在创建一个java文件，将其作为数据库处理的文件，然后再JSP文件中连接该文件进行操作。 引入数据库驱动，首先要去网上下载一个数据库驱动，不同的数据库系统驱动不同，这个是由数据库厂商提供的。下载完之后，就将其copy到Web App Libraries文件夹中。然后就可以使用该Class了。 然后就是： Statement connection = DriverManager.getConnection(url,name,pwd) 使用该句来连接数据库（注意：在Java文件中，该句需要添加try…catch…）。 增删改数据库: Statement stmt = connection.createStatement(); String sql = “insert…”; //该方法返回的是受影响的行数 int res = connection.executeUpdate(sql) 查数据库：查数据唯一不同的是执行语句： String sql =”…”; ResultSet res = connection.executeQuery(sql); while(res.next()) { int num= res.getInt(&quot;...&quot;); String title = res.getString(&quot;...&quot;); System.out.println(num); System.out.println(title); } 注意：在获取数据库内容时，使用:ResultSet res =connection.executeQuery(sql),这个res是一个表的集合。可以类比遇一个Iterator 使用一个while循环来使用获取全部的数据。 res该对象含有：next(),hasNext()等方法来获取下一个。主要的还是get方法。但是获取不同类型的数据需要用不同的get方法：getInt(“name”);getString(“”)…like this。 最后需要注意的是，连接完数据库后，要把链接关闭。 stmt.close(); connection(); 这两个都要被关闭！ ##Last but important##就上面这几句代码，emmmm，在网上找了一天，现在才发现，网上的资料的参差不齐，终归还是要看文档，不行就看书，then，看视频。经验，哈哈哈。还有6天，做一个Demo吧，哈哈哈。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"JSP基础部分","slug":"JSP基础部分","date":"2019-01-30T13:46:43.000Z","updated":"2019-01-30T14:43:15.712Z","comments":true,"path":"2019/01/30/JSP基础部分/","link":"","permalink":"http://yoursite.com/2019/01/30/JSP%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/","excerpt":"JSP这几天把JSP基本部分看了，方便记忆，还是回顾一下。文件部分有一点复杂，所以后面直接单独解析一下。","text":"JSP这几天把JSP基本部分看了，方便记忆，还是回顾一下。文件部分有一点复杂，所以后面直接单独解析一下。 日期处理其实日期处理部分还是JAVA中的Date()对象提供的。只是之前学习JAVA是没认真看，哈哈哈。 获取时间eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*, javax.servlet.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;显示当前时间与日期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示当前时间与日期&lt;/h1&gt; &lt;% Date date = new Date(); out.print( &quot;&lt;h2 align=\\&quot;center\\&quot;&gt;&quot; +date.toString()+&quot;&lt;/h2&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 提示：任然是实例化Date对象，然后对该对象进行操作，其中该对象有以下方法： 序号 方法 &amp; 描述 boolean after(Date date)如果比给定的日期晚，则返回true，否则返回false boolean before(Date date)如果比给定的日期早，则返回true，否则返回false Object clone( )获取当前对象的一个副本 int compareTo(Date date)如果与给定日期相等，则返回0，如果比给定日期早，则返回一个负数，如果比给定日期晚，则返回一个正数 int compareTo(Object obj)与 compareTo(Date) 方法相同，如果 obj 不是Date类或其子类的对象，抛出ClassCastException异常 boolean equals(Object date)如果与给定日期相同，则返回true，否则返回false long getTime( )返回从1970年1月1日凌晨至此对象所表示时间的毫秒数 int hashCode( )返回此对象的哈希码 void setTime(long time)使用给定参数设置时间和日期，参数time表示从1970年1月1日凌晨至time所经过的毫秒数 String toString( )将此对象转换为字符串并返回这个字符串 日期的比较 使用getTime()方法得到毫秒数，然后比较毫秒数就行了。 使用before()，after()，equals()方法。比如，new Date(99,2,12).before(new Date(99,2,18))返回true。 使用compareTo()方法，这个方法在Comparable接口中定义，在Date中实现。 使用SimpleDateFormat格式化日期eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;%@ page import=&quot;javax.servlet.*,java.text.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;显示当前时间与日期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示当前时间与日期&lt;/h1&gt; &lt;% Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd HH:mm:ss&quot;); out.print( &quot;&lt;h2 align=\\&quot;center\\&quot;&gt;&quot; + ft.format(dNow) + &quot;&lt;/h2&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; SimpleDateFormat格式码 字符 描述 示例G 时代标识符 AD y 4位数年份 2001 M 月 July or 07 d 日 10 h 12小时制， A.M./P.M. (1~12) 12 H 24小时制 22 m 分钟 30 s 秒 55 S 毫秒 234 E 星期 Tuesday D 一年中的某天 360 F 一个月中某星期的某天 2 (second Wed. in July) w 一年中的某星期 40 W 一个月中的某星期 1 a A.M./P.M. 标记 PM k 一天中的某个小时 (1~24) 24 K 一天中的某个小时，A.M./P.M. (0~11) 10 z 时区 Eastern Standard Time ‘ 文本分隔 Delimiter “ 单引号 ` 页面重定向页面重定向是指在client访问a.jsp时，根据据需要，a.jsp页面将请求重定向至另一个页面。注意这一个过程中，a.jsp的所有内容都不会返回至client，而是直接将请求引导至新页面，也就是说client会进行二次访问，新页面的加载还是又client来完成。 eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;页面重定向&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;页面重定向&lt;/h1&gt; &lt;% // 重定向到新地址,关键部分 String site = new String(&quot;http://www.runoob.com&quot;); response.setStatus(response.SC_MOVED_TEMPORARILY); response.setHeader(&quot;Location&quot;, site); %&gt; &lt;/body&gt; &lt;/html&gt; 还有一个类似的请求转发，而请求转发是在接手到client的请求后，在server端进行请求，然后再这个请求的基础上将新内容返回。也就是说，该种方法只经历了1次请求，并且转发只能是转发到本次请求的服务器，而重定向则可以定向到其他服务器。(进过我的测试暂时是这样) 我在看这一部分时，想在重定向或者焕发之前给client一些提示，但是由于该页面的内容内容根本不会写入到response中，所以是不能实现的，在网上查找了一圈的资料，基本都是说使用前端来实现跳转，才能给客户端反馈。 比如: out.print(&quot;&lt;script&gt; alert(&quot;即将跳转至百度！&quot;); window.href=&quot;http:www.baidu.com&quot;; &lt;/script&gt;&quot;) 所以，如果使用重定向或者是转发，是不能给客户端提示的，如果要提示，就要用前端实现跳转。 JSP点击量统计在菜鸟上，对于统计量方法的实现，时使用application对象来存储一对键值，在访问时动态变化，实现访问量统计。所以我们看一下applicant这个对象，它有以下特点： 在服务器启动时自动创建，在服务器关闭时自动销毁 一个网站仅有一个application，也就是说所有的客户共享一个application。 所以如果服务器遇到宕机，那么这个量就被销毁了，所以最保险的方法是将其储存到数据库中，并定期刷新。保证不会频繁访问数据库，又可以最大化的保存数据。 eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;访问量统计&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Integer hitsCount = (Integer)application.getAttribute(&quot;hitCounter&quot;); if( hitsCount ==null || hitsCount == 0 ){ /* 第一次访问 */ out.println(&quot;欢迎访问菜鸟教程!&quot;); hitsCount = 1; }else{ /* 返回访问值 */ out.println(&quot;欢迎再次访问菜鸟教程!&quot;); hitsCount += 1; } application.setAttribute(&quot;hitCounter&quot;, hitsCount); %&gt; &lt;p&gt;页面访问量为: &lt;%= hitsCount%&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; JSP自动刷新我其实觉得这个功能可以在前端实现，不过也许有些时候必须要使用后端实现呢，所以还是看一下，其实就一句： response.setIntHeader(&quot;Refresh&quot;, 5); eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;自动刷新实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;自动刷新实&lt;/h2&gt; &lt;% // 设置每隔5秒刷新一次 response.setIntHeader(&quot;Refresh&quot;, 5); // 获取当前时间 Calendar calendar = new GregorianCalendar(); String am_pm; int hour = calendar.get(Calendar.HOUR); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); if(calendar.get(Calendar.AM_PM) == 0) am_pm = &quot;AM&quot;; else am_pm = &quot;PM&quot;; String CT = hour+&quot;:&quot;+ minute +&quot;:&quot;+ second +&quot; &quot;+ am_pm; out.println(&quot;当前时间为: &quot; + CT + &quot;\\n&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 通过这个栗子可以看出效果，当然，对于日期的刷新，不肯能用这个东西，肯定是局部的ajax来实现。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"JSP中的表单编码问题","slug":"JSP中的表单编码问题","date":"2019-01-28T12:13:29.000Z","updated":"2019-01-28T12:35:17.410Z","comments":true,"path":"2019/01/28/JSP中的表单编码问题/","link":"","permalink":"http://yoursite.com/2019/01/28/JSP%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8D%95%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"JSP的编码才看了几天的JSP，把最重要的表单提交看了一下，遇到了中文编码的问题，然后我查了一下JSP的默认代码是：ISO-8859-1重新设编码的语句共有下面几句：","text":"JSP的编码才看了几天的JSP，把最重要的表单提交看了一下，遇到了中文编码的问题，然后我查了一下JSP的默认代码是：ISO-8859-1重新设编码的语句共有下面几句： pageEncoding=”UTF-8” contentType=”text/html;charset=UTF-8” request.setCharacterEncoding(“UTF-8”) response.setCharacterEncoding(“UTF-8”) pageEncoding=”UTF-8” 是在第一阶段，转换阶段（即将JSP文件转化为servlet文件的过程中使用该局代码提示的编码） contentType=”text/html;charset=UTF-8” 是用在第二阶段，将servle渲染为html时，使用该语句的编码 request.setCharacterEncoding(“UTF-8”) 是用来指定对浏览器发送来的数据以特定的字符集进行重新编码，常用于对 POST 请求参数进行解码。 response.setCharacterEncoding(“UTF-8”) 是用来在服务器将响应返回到浏览器前，对响应使用指定字符集进行重新编码。一旦使用了该种方式，即使该响应页面指定了具体的 contentType，也将失效。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"编码","slug":"编码","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"Python3_CGI编程踩坑日记","slug":"Python3-CGI编程踩坑日记","date":"2019-01-14T12:25:07.000Z","updated":"2019-01-14T14:02:46.626Z","comments":true,"path":"2019/01/14/Python3-CGI编程踩坑日记/","link":"","permalink":"http://yoursite.com/2019/01/14/Python3-CGI%E7%BC%96%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/","excerpt":"Hard-start这是学习Python的第六天，也是进入Python高级编程的第一天，嗯，对，然后我就遇见了Big Problem，甚至到现在都还有一个问题没有解决。","text":"Hard-start这是学习Python的第六天，也是进入Python高级编程的第一天，嗯，对，然后我就遇见了Big Problem，甚至到现在都还有一个问题没有解决。 Problem I met Apache的安装问题 在得之要使用Apache之后，我直接就百度Apache，然后再官网首页 结果下载下来直接用不了，解压了发现文件不对。然后一搜教程才发现文件下载错了。 应该在这里下载： 终于完成填了第一个坑！ Apache配置问题 要启用CGI，必需修改配置文件。而这个配置不仅仅是是一个地方，是n个地方： ServerRoot配置 ServerRoot “” 主要用于指定Apache的安装路径，此选项参数值在安装Apache时系统会自动把Apache的路径写入。Windows安装时，该选项的值为Windows安装的路径，Linux安装时该选项值为编译时选择的路径 找到： Define SRVROOT &quot;${SRVROOT}&quot; ServerRoot &quot;${SRVROOT}4&quot; 改为： Define SRVROOT &quot;D:\\web\\Apache24&quot; ServerRoot &quot;D:\\web\\Apache24&quot; 其中”${SRVROOT}”应改为你你安装Apache的目录。 Listen 配置 Listen主要侦听web服务端口状态，默认为：80，即侦听所有的地址的80端口，注意这里也可以写成IP地址的侦听形式，不写即默认的地址：0.0.0.0 找到： Listen:80 改为： Listen:8080 一般不为80，因为容易占用，改为其他好一点。比如我改为8080。 CGI配置 找到： AddHandler cgi-script .cgi .pl 改为： AddHandler cgi-script .cgi .pl .py 这里是增加对Python的支持。 找到： &lt;Directory &quot;/${SRVROOT}&quot;&gt; AllowOverride none Require all denied &lt;/Directory&gt; 改为： &lt;Directory &quot;D:\\web\\Apache24\\cgi-bin&quot;&gt; AllowOverride None Options Indexes FollowSymLinks ExecCGI Require all granted Require host ip &lt;/Directory&gt; 注意这里/${SRVROOT}任然还是Apache的安装地址。 Python解释器 我就这么按照runoob上代码粘贴下来，like this： #!/usr/bin/python3 print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是来自菜鸟教程的第一CGI程序&lt;/h2&gt;&apos;) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) 然后就出现了500错误，下面是log里的提示： [Mon Jan 14 11:31:58.626473 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。 : [client ::1:52212] couldn&apos;t create child process: 720002: hello.py [Mon Jan 14 11:31:58.660452 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。 : [client ::1:52212] AH01223: couldn&apos;t spawn child process: D:/web/Apache24/cgi-bin/hello.py 百度了半天，突然想起Apache如何载入编译器呢，然后直接百度上面代码的第一行： #!/usr/bin/python3 然后才知道这是Linux下Python的解释器位置，我枯了。然后我找到了自己Python3的安装位置，却发现没有exe文件，我又枯了。但是用sys自己的命令： import sys sys.path 得到了就是这个位置。不管了，直接写吧！于是得到了这一段代码： #!D:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python.exe 没错，就是这么长，不知道自己当时怎么安装的。我又枯了。 结果成功解析了！！！ 但是！！！ 又乱码了，检查了py文件的编码，发现py默认是utf-8啊。然后终于在网上找到了解决办法。没错，是print()函数的问题。 又大佬看print()源码使用Unicode，果然乱码了，然后引入了这一段代码： import io sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) 即：将print()函数改为utf-8编码输出，终于留了一张图： 附上正常获取text，textarea的代码，其他的都一样。 (text.html): &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/cgi-bin/text.py&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt; &lt;input tyep = &apos;text&apos; name = &apos;name&apos;/&gt; &lt;textarea name=&quot;personinform&quot;&gt;个人信息&lt;/textarea&gt; &lt;input type=&apos;submit&apos; value=&apos;提交&apos;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; (text.py): #!D:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python.exe import io import sys import cgi, cgitb sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) form = cgi.FieldStorage() name = form.getvalue(&apos;name&apos;) personinform= form.getvalue(&apos;personinform&apos;) print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;) print(name) print(personinform) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) 下面是get从url来获取键值的方法： #!D:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python.exe import io import sys import cgi, cgitb sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) form = cgi.FieldStorage() name = form.getvalue(&apos;name&apos;) number = form.getvalue(&apos;number&apos;) print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;) print(name,number) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) last problem(unsolved) 最后一个问题就是CGI的文件上传问题。由上面的代码可以知道，所有接受的数据都来自： cgi.FieldStorage() 网上的教程都这么获得数据： import cgi, os import cgitb; cgitb.enable() form = cgi.FieldStorage() # 获取文件名 fileitem = form[&apos;filename&apos;] # 检测文件是否上传 if fileitem.filename: # 设置文件路径 fn = os.path.basename(fileitem.filename) open(&apos;/tmp/&apos; + fn, &apos;wb&apos;).write(fileitem.file.read()) message = &apos;文件 &quot;&apos; + fn + &apos;&quot; 上传成功&apos; else: message = &apos;文件没有上传&apos; 但是问题在于， fileitem.filename == none 我直接输出 fielitem fileitem = MiniFielStorage(&apos;filename&apos;,&apos;test.txt&apos;) #test.txt为上传的文件名 所以fileitem.filename始终为none。所以一直解决不了，查了各种资料，不过官方文档里有类似的解释，但是还是没有解决办法。明天再看吧~~~难受啊，马飞~","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"CGI","slug":"CGI","permalink":"http://yoursite.com/tags/CGI/"}]},{"title":"欢迎2019-假如我年少有为","slug":"欢迎2019-假如我年少有为","date":"2019-01-13T12:08:09.000Z","updated":"2020-01-08T15:38:47.126Z","comments":true,"path":"2019/01/13/欢迎2019-假如我年少有为/","link":"","permalink":"http://yoursite.com/2019/01/13/%E6%AC%A2%E8%BF%8E2019-%E5%81%87%E5%A6%82%E6%88%91%E5%B9%B4%E5%B0%91%E6%9C%89%E4%B8%BA/","excerpt":"不知道怎么开始这一篇文章，首先应该是欢迎2019吧，又度过了一年。真要回忆这一年，我竟然没有多少印象。我尽力去回忆，尽力去把这一年的日子换算成有价值的东西。不知道我什么时候变得如此的现实，一切似乎都不能是白过的。","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+8Nak6ytm1/c8YBXZfuqA6+jjo9JaLL1BeAVxPn93oLjqiFaxvccrt9TqttMmRkdjGRbyqdChE/qiajbhrZlEub/Ntb99StR01RIatfEHZ9IyZpKT+5ZJ/VLH9/8D6hadUF8IEwSwe7OcT2CgWa62DJ2AazVZymhmbO4PaRlsf84n66Hy6UAYsuuGKDW522u2oi+rrb1zpy56C98fFxRZDLK/7J/Z43aaNB56YUagyc2z9G7v3Gw6gxWGUadKE5OQslsbDt0JIRuHOuF/c/RnEglt31EQdSRAG2+9gHYNK0e7puToARPDc4t+j6rNExhkYZpg38jaDCWBzENsszHGI45aaGq7E2FMYfnX3SdbXVJnIMCwxstssASRcMk9q8IUABzvec19B3ekXVF8/wZvmsWxB1l+KETmIFkQj/0hJd1MPKgSGe/kH+qkAd7Vo3wS4nmiKKSG74IOL6TwEDDZat5fNwChgze1/L9K45V5QkPVknodqxOvVbW1Lv91LG20RIMmtBe8gAyuF0xs8H+hmN2nXHQJ8owK4jfoUDAgWmtiaTTuNUr+5KRtmYTuf0QLzSaoFU+9GVpYX5/S/q65iavK1a8L8ESkcImVLZnS5HCSZ5pcOzb5sSlHe8MihT8Ut4tMmwRqzTKNRj5sTxJeq1bzMkEbjzoKsrkz9KrLKS+8FTmSEMg+8Trl4KudwL9PfKjgPQqp6ndqO+cbHFWeFrYkLESCPJgqOl8D54PinHS0q95xLzLHZQtV72j6FQ7d/a0w8fFiMOyRQ4IpkWRp65IujsV4ppQulvC78xwC/nfx8qYvCLJArKuV92Gv62opZpZwKsVBxUpSNZ2bs052Ah45UaDyFoks+USEuBawpc4upx+pAvHq76tRtzKxDcmtHCSl2q6p/zQpm7fKwC6iK6fX7bICHFuimwYGA7wAhBpcNsOQOhDMk5vmST/Vu4xLPDmmUymULVjPJ9oUPyUKl5e7bKunTaBUWTohtCl1FS0FI0b8NQ+L380lxDHpdT6T4CzzkqSpbrgpQA3uhc4zakq2zSQ8vbxILI2P1rK9pJKgyq0yNaNY378kd/W2MtjlytAVx99oI4JEfFbtlTRvwCI/V158Yul+od+nWCLMiX+uWodEVfGS0Kd5t0ar0eZLk0oxT67gE35enREPyN+4x37vjtt0uGAIlAzVjxLOR5pjaT+nwdN3m96NQ1XDwUelcTVDd0l6K/Y+Rnm4GZ0Iy2HpL6p6W27LfhX8FUFANBmGtOkrL7LKd/KgW3NuxRHXVHqWusfufSNe86QiRWl+CKqWAG1KmOmJTaYXjd/QW6HXlRs6uMG0SY4o0e87hpBXotrilDzuqbrNKo8v6oS6soLUk5AVrjtYAKXc8n/LJPDFhDspiruo81IdT5wr79+TYZgZpw7nHFhYXjW2kkWl6MZHZB31pxeU/XTzph49/A+ktOWvOWRM32XCb1b4AOR1wf59J+cuGvg19PoFTjIgApYTJjWwgg2bCBLOfMqHN+6dJWbU+WOn+zD0fCbFiQm1qkMflPFPKbfffqqdbp/fys1EdCLr0PjAJLDh4zVbIGCAgBCNNxTG1NHDoV6VC6Og3lnz189xi34RkXFxY12lvb2vEs1t8Xg0c9e24eWnKKxuf9bvNtgUuABwwKTbTgQsMOsPTsPZejCrtEtM69fobvx54hQPXswH173tAYGoqifqkAdlSwuERKaX+FxQuqOlYAiMQ+BHSMXStGQ+cghjCJoc5B5jkbz4BDcM9fP/TUdYvDVW7BXarJxRFNvCwj3RsbJ/7M6nF6iSXBpIvvbKhiircZaHvG8Opl+DAZWXZbl0g8hc7e5YuCitKOXTNt+OeXYUF7g9+3L5wMVjpes7GB01o+ypsQ7px8F/Ocj327X+KpWZzrDbuXNyLLG+zYpSjqjNwKoPTUnBjtx3cEUJfyuHSgF8phxPwCm4qcrUghiJ6Znz7wH5bcNluIkglQGgkYs0AWdnBpLfjEod7BYAnT0s/LX107G4Zd/4dmAZ+9tHh53KRoZWSSxA46+8NqYLXklUVK/cN8SvKG0BaJvvtCsuodh0aMNShXfgnJGTznUUVuzIhzqLGwvC7qk8RMSpXDNBJGOZwDxG+Fp8ZguQdquPLVOVo/hJ6UEa9T0a1y0yFGKPrbGNmQbsydNCyf42Ai8QKEtVjIwurcjvyig3LRRzsIsUYHlBG41TD653rsXnjRHrq67aIKeSe2ns8hz5pqn4l9M7XlkgtViMTepbAdKB0hW5z+wA/kuft1GAWK1eHQN4r4jkZZ5bbwnYHXVdXoUeVea35yhFwD1/DfYsjGoCLCq61Q87OE5M/J3jO2GYmwUA6jYVyIkiid95GAiUY30EWtj+akRv1H/YR18Duko3nQyQtM0tidhbjO8ndpuRw/qkvMASqnndcY+Ko3SEV9jvl2t7FK56ZGlW6obHynX23KQMMjdCYFhkRg0CZSinsIqAHaR79tw+qCTlYr4E1WZCpkhtp+u/K0Dbc2OfJSAKUEbEOgdfJjMj0hKyaO1EoGbKVXdkm0HJ3pN/sZwYxfmhMOQNLFQGzXy2kzVUfuesEo/qEXvO1XT2jV2XLAg8WgRJg0FmgJW7fss+2yHZmhVOQgqQV/Vhs3nw2ZzMXcwXWjkS/iV3Im2DfYfRfm2a3TON3N/6cd6uKLtAPClfJZabI/fxSwBOdoQZJRwpJzS+mKApwTUDyH9noLeoMyDZyrji93Xhcy0tbkdqkfuFnBcEKgIwGwqiX6A3eAEleTbiZTraxSV53etuxRGhNqdhBWaPma93+oWFCJsQW7FHlrrjBE/c7lRgqIvWpqdpLGOvKhqhOzulFC31GCPQL/Z4DMDQth3HCt56hmo+/79Aw95lA4lP1vhnHsz+kMw6eMHNNAt7NFkbyf4oaoELcR8rlOmaA0tA5pa/m0yVI7l2nsLOfaUBwsLo0MUbOw+FlcZICBUGatAxLcmtAxVAjtg+Fc9ZI9iBh1Qrb/RIkVPeUhrP/3sn0NLCo/ldyFn5SlDqHRY4Y+qqPI9mvjkJn5TnVt8aHfRmyfiUgUIH5ZQGT4fR3qrFM9Ej5aOhcKY5ga2TaPy8Yi/2H+cBhHL0APlOq5M67t6zR/hzy6SxWcSkXbgXmHXXYoaDwq+D5AUUdoHso0VKJGN7luwQlxL3xeXCD6qVLxGaLcPwhdRf7sy10UfnMK/NnV4EAQVlHuhHL9yRkhiSPplNJBdtULAaoeMPyHJy4H4U/x8D6UfAVjRq7VaQnm1bGVEx+eAxAKeKru6kS31IXoC9nzrD6LRbuPodMOBRXnYh4Wm/6bcH9YRKaesb8yk+zjn7LvorGQ28MStWe37566m99R6/jzyxPOth/7VyKfZpH6d86DOLH2mJzN6/A1rvqqNj2sGob188W/RbPiHFqq7WMJmRKyzOeneCnZJb89/+t1V8PFKt45aIiF35+g3VefpkPDbpHK8Bt0OTzbWmaWTETcAPxHJ7L0a6RGN75CAe6fD01PcuLS4RdLdwwkEPzXZgh2nJNh7EvM8j2K2SNHwxruJ8wk0Kh1O72WtSYHAFqC6HzSXj/x86fWSc67HrNiFE/09s5WDadb1bUadOax35Ixa+gcdhbBDiNsIMKn+OsVuF70S1YN4QiGKN4GJ+qW0ZKFfQSEZF5JUi0vPK7yp6nOdQgJqN4RYpASZ0NQiWyV2LMZ0iO56K7QPYqjOqDeTk2n63CloCaD84b2Eb87AlLu84FVPEv3sK5ngZWzPeHnElivUAnNOXaSe7pnElEsOoGxSoi4+zJg3upEwae2Iw/zwnicoSL6Y2/I8mXfmuqClPARThtrrGGr3vQRRLAGGXmJ6RIyNlYzoNWavVYrnGB5XaTthVgNmQzNIwhmA8M37dUc0W82orDPZPYvxeJH+VY+wa4tUFWf9MyTr1Pyk9uYshVqPUSDGTJ0siZwqGpPUewWW/z/yVaZeW8EiYH2ekk28gl2q+KEktXdLQ5HgTpe+KGq54Q6/PG50OVWNEMgogOVo0yyTTlr3aKoUsHisxG6kHAbqKnZKQfxYn4pRr++q5C4gJZeCBJTRAtDPhKrRFvLjxt9F3Wd0PPsVTQDznjtqQyaPv/fApcrokFVlBNHhk8Tey/9oSavO9sWORFuk/dHQjavf91fvNgmpPhXkpjGYmQ4lyJaAgpXsyql8BhkUaPrABbs78UxAMWNMx+f/y1SlxbCM5pcmvdKQnZms3riEAbECLcLm/OUU/ZOFGGdOvnd39ZF+KH1E6JiTUR7yuwvBqnNBjNK07EKSZq3PfrEdJGDeAVPBH7iWHhwQaeIOJ1JmQL/YFl2dV6spjefqae0HO/ToMxGvq3xQBrL+s1VgIyzMTlXjeR8YRnFsbmM/25vWVwK7DistwNxbwlx2/PfMgOdBMvL3GGaBZaC0R0hDWCzA5Ic6qKQSsT6RICYQGbfehCf870dWw8DlnpzX8gL0BcC1DEgtfciuN3cFa3XtwinRTE7L/mXupFj0aMH40PoW2EaNZRIPb+cdZcIExpWzvC4aS4UzIg4EVgKA5iZRTlIGY18Yb7jlJ4nwD6q0lZeQvAAnpD/NJnnexRcqV17iFhR1eACxww5KWGUOT1CrvRrPRixvbbQX6sPMXBaSWH6UdBOIJ+w5p3pT9SVdG0Dl4dH/hAFWdtp+xw/Skm+cJmmP6WaJnZaITaDSxrXg3i6hoCjSaZY1Vm6Hi+fCNbrIEUTEj8DxCDuwnt+DKaxqYxpd5rsjP5bfQNFGagGHBc7eTxZu7G79PsPuV/CtEsrtLPvaE4DBTCwOhFfxGcV61o37wx69RwHCwg+2nbRZkMS4M9O4Slx1BmOE6lwHmnMDyKO6I4hxK7KQ3hv5aDhUAUdcfbu0s2PZjG5KNsO/CBXT/TEvpLvrnLsklC2EMqL00MPVQEILlwp2/05ECU9U3LaHd+lpKbyBvIvEDstzItVra2d3viQ9PzufoxKgeSvoYmtfir6JBHTZurgry1mMa8ZI0/ijB+Imo51/EdO6yn37N+0pDfeOZ51qY9jEEq8PhIHK2VPT2AFlR2LFfjdR0rfVOl/xH2lNX7QaqG7/1HimH5KMGnY8LBQOwW6abmQHLfk9Os2MPyjmx+knXvK1S/Fmy52QqH/YSB8ef69VNmwjv9Ay50+qRVzmq/Jp1K2loiH1B8fWStO5u/t5R7m0t/WheJ2RRAih3KXlMZfpe7InTbHBHXGC9RQ/NmHv2gv+7pLwMRv/2SmltkWGxmzWE+8VdUtTsIIIx3bJD/1TZBQrbGlIuggsQw7dEASW/ZOuZg+zPCDwwiOGQPzh5dA4HLM860ezQieAJeB6IkcWMDNRChuCNFRitzfz1mAQzxxNjM/MHb+8Fqtb0/xha+QWY4ntzcNoKF3pzPaU27RvN1ecPhWAKHyq7np+aL4RmFyuyq4VIcy7uJieB0cRh2jnqoQXrJ7nUET+e3AKisdWh0ChUUg5M/I7rmInH5u8BJLsxv47eZmJMbBDcf9uVHzxAo8d8zoJlynvKTGZFcFTzyPCggRDYxX4KyecEacgXC6ePAqQKfP1E4XQIEcNIu56E0oltDeku6+xoeIKcRaaC2iotwtcBizSeV9tPxj9qRGglKPLGqpuBkCMeTwgCkc3JpTKVcVO0pC7Zx5e+aPAJczaD6lp9ZAt5+Zkwi183i11QqHL9mnoXqoaqF23y8AMLAUdyB6JQwOiqlCoZE+PerfBEkL2RFvuAEYqjgUrrfGKBtVHhLtE8ZYIy9QPAVADI4k37jwM8SDCbrBe35YWpeJ9zhPRVfy64CJyDimNA/BOvAzQNTkJDwOudKjEuNmXVIS7tvsIlIdt0/BmQyQkeBNWwHWnSRsPiVHwAlz/eAR4StHTg+rspmojenZO07Qxfvi3rKNub3CPWXMR43qzp1rrQC8AHjL1klT8ZwoCipNHP2BS4CP2gXqQrCUS8vRopvwe68SOi/l4MskFSZVPh4+neErCpGfFA2VGE2ETbRuCWJEH7NC/HpHy8Goahrgkmqk11XQl2Z1LfEm9nYz/M81m4ctv2F/DdFT/dKZrsH2qywGm1b6fZQfJR0Nt/jEmPEd+j+IjyjOWA/J/TL3XOgkHamn5QQLMmgNA9+05w8JbVIoz2WTuQPXE1BbwOTajeOEaKmaNW7N9bWvKrDmD1Du/o4LSYKhMWm8qI7IdcKRqIdMKd23sE6mre9yXu63bKtHFxaoSitSUbRdX0ogQYVB5gzj8uYvJDjj3mZlAstv4FMkMKvc/Zco+ZrKGjCTQCldgMbHbpU3qS6I+SvELAob/FJKuCq5HOnHTd2RmsB8LMawwD6VFA1D72KM8GjXgQ0l6szwcR/0dA8G6VJWDbyigSCqwnS/sfHbokuHPKj3iCr4JhxHLjqg/sH0FBtvPPgeUwF7c/Bdm6wAOPdp6vi4jo48bXOukttrqL3YvQSpnGVTv64EEVPMIU3ZWaofo7Ya8oCqTgPJDZx7Ej6SANGxmVMecuvEk/t2NuDLTxVJdSh/oPeRPVgAWKUEQ== var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"2019","slug":"2019","permalink":"http://yoursite.com/tags/2019/"}]},{"title":"周报(0)","slug":"周报(0)","date":"2018-12-01T04:10:17.000Z","updated":"2019-01-12T15:31:43.707Z","comments":true,"path":"2018/12/01/周报(0)/","link":"","permalink":"http://yoursite.com/2018/12/01/%E5%91%A8%E6%8A%A5(0)/","excerpt":"LeetCode： 简单思路：令i从0开始向后跑寻找与下标为length-1不相等的数，找到之后将那个数放到length的位置上，并且令length长度加1，最后返回length就行了。","text":"LeetCode： 简单思路：令i从0开始向后跑寻找与下标为length-1不相等的数，找到之后将那个数放到length的位置上，并且令length长度加1，最后返回length就行了。代码部分： int removeDuplicates(int* nums, int numsSize) { if(numsSize==0){ return 0; } int length = 1; for(int i=0;i&lt;numsSize;i++){ if(nums[i]!=nums[length-1]){ nums[length++]=nums[i]; } } return length; } Java学习部分内容重写与重载重写：在子类中1. 参数列表必须完全与被重写方法的相同 2. 返回类型必须与被重写方法的返回类型相同 3. 访问权限不能比父类中被重写的方法的访问权限更低。例如，父类的一个方法被申明为public，那么该子类中重写该方法就不能申明为protected。 4. 父类的成员方法只能被它的子类重写 5. 申明为final的方法不能被重写 6. 申明为static的方法不能被重写，但是能够被再次申明 7. 子类与父类在同一个包中，那么子类可以重写父类的所有方法，除了声明为private与final的方法 8. 子类与父类不在一个包中，那么子类只能够重写父类的声明为public和protected的非final方法 9. 构造方法不能被重写 10. 如果不能继承一个方法，则不能重写这个方法 super1. 在父类的某一方法被重写后，如果需要调用原父类的方法，需在该方法前加super关键字 重载 ：在同一个类中1. 被重载的方法必须改变参数列表（参数个数或类型不一样） 2. 被重载的方法可以改变返回类型 3. 被重载的方法可以改变访问修饰符 4. 被重载的方法可以声明新的或更广的检查异常 5. 方法能够在同一个类中或者一个子类中被重载 6. 无法以返回值类型作为重载函数的区分标准 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 来自 http://www.runoob.com/java/java-override-overload.html 2.多态：同一个行为具有多个不同表现形式或形态的能力。 向上转型：子类引用的对象转换为父类类型称为向上转型。 重写式多态：也叫运行时多态，这种多态通过动态绑定技术来实现，是指在执行期间判断所引用的对象的实际类型调用起相应的方法。 Animal animal = new Cat(); //向上转型 1. 向上转型时，子类单独定义的方法会丢失。比如上面Dog类中定义的run方法，当animal引用指向Dog类实例时是访问不到run方法的，animal.run()会报错。 2. 子类引用不能指向父类对象。Cat c = (Cat)new Animal()这样是不行的。 向上转型后方法引用的优先级问题： 继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 注意：此时的（super）O 指的是O的父类。以下面的8为例： b.show(C) 由于b的引用对象为B，所以可以调用的方法有：show(B)，show(A) （this.show(O)） 又b的类型也为B，所以方法也先在B中选择，发现没有show(C)方法 （super.show(O)） 在B的父类，即A中查找show(C)方法，任然没有查找到 （this.show(super)O） 原式为：b.show（C），又C的父类为B，所以该式变为：b.show(b)，并且在B中查找，找到了该方法，于是执行该方法，得到结果：B and B 实例class A { public String show(D obj) { return (“A and D”); } public String show(A obj) { return (&quot;A and A&quot;); } } class B extends A{ public String show(B obj){ return (“B and B”); } public String show(A obj){ return (&quot;B and A&quot;); } } class C extends B{ } class D extends B{ } public class Demo { public static void main(String[] args) { A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(&quot;1--&quot; + a1.show(b)); System.out.println(&quot;2--&quot; + a1.show(c)); System.out.println(&quot;3--&quot; + a1.show(d)); System.out.println(&quot;4--&quot; + a2.show(b)); System.out.println(&quot;5--&quot; + a2.show(c)); System.out.println(&quot;6--&quot; + a2.show(d)); System.out.println(&quot;7--&quot; + b.show(b)); System.out.println(&quot;8--&quot; + b.show(c)); System.out.println(&quot;9--&quot; + b.show(d)); } }//结果：//1–A and A//2–A and A//3–A and D//4–B and A//5–B and A//6–A and D//7–B and B//8–B and B//9–A and D 从4向后的解析原理：当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。Animal animal = new Cat(); //向上转型 Animal为引用对象Cat为引用变量 首先，a2是类型为A的引用类型，它指向类型为B的对象。A确定可调用的方法：show(D obj)和show(A obj)。a2.show(b) ==&gt; this.show(b)，这里this指的是B。 然后.在B类中找show（B obj），找到了，可惜没用，因为show（B obj）方法不在可调用范围内，this.show(O)失败，进入下一级别：super.show(O)，super指的是A。 在A 中寻找show（B obj)，失败，因为没用定义这个方法。进入第三级别：this.show((super)O)，this指的是B。在B中找show（（A）O）,找到了：show(A obj)，选择调用该方法。 输出：B and A 上面的例子简单的介绍了多态的意义，同一个行为具有不同的表现形式或形态的能力。 多态（重写式）实现的条件： 1. 继承（实现） 2. 重写 3. 向上转型 重载式多态：也叫编译时多态，也就是说这种多态在编译时已经确定好了。在调用这种方法时，通过传入不同的参数得到不同的结果。 此处重载式多态有不同的说法，部分观点认为：重载不属于多态，认为多态仅仅指的是在程序运行时根据不同的输入，而方法有不同的响应称之为多态；但重载指的是：在一个类里，方法名字相同，而参数不同。也就是说在程序编译时就确定了该方法的响应。所以不能称之为多态。关于这个部分，我还没有更深的理解，所以暂时保留意见。","categories":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/categories/%E5%91%A8%E6%8A%A5/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/%E5%91%A8%E6%8A%A5/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"JavaScript数组（二，ES6部分）","slug":"JavaScript数组（二，ES6部分）","date":"2018-11-02T10:06:23.000Z","updated":"2018-11-02T10:08:09.215Z","comments":true,"path":"2018/11/02/JavaScript数组（二，ES6部分）/","link":"","permalink":"http://yoursite.com/2018/11/02/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%8CES6%E9%83%A8%E5%88%86%EF%BC%89/","excerpt":"前言上次介绍了ES5之前发布的JS的数组方法，这次再看一下ES5中发布的JS方法。","text":"前言上次介绍了ES5之前发布的JS的数组方法，这次再看一下ES5中发布的JS方法。 正文 indexOf()和lastIndexOf() 描述： indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。 应用： 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。 exp: var arr = [1,3,5,7,7,5,3,1]; console.log(arr.indexOf(5)); //2（5在该数组的第2位） console.log(arr.lastIndexOf(5)); //5(从后向前，5在数组的第5位) console.log(arr.indexOf(5,2)); //2（从第二位开始检索，任然2在第5位） console.log(arr.lastIndexOf(5,4)); //2（从倒数第四位开始检索，5在倒数第四位） console.log(arr.indexOf(&quot;5&quot;)); //-1（数组中没有字符&quot;5&quot;，所以返回-1） forEach() 描述： 对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。 应用： 用于遍历数组，获得数组成员的内容，索引，及其数组本身 var arr = [1, 2, 3, 4, 5]; arr.forEach(function(x, index, a){ console.log(x + ‘|’ + index + ‘|’ + (a === arr)); }); // 输出为： // 1|0|true // 2|1|true // 3|2|true // 4|3|true // 5|4|true map() 描述： 遍历一个数组，并且经过处理后返回一个新的数组。 原型： arr.map(function(currentValue，index，arr),thisValue) currentValue 必须 当前元素值 index 可选 当前元素的索引值 arr 可选 当前元素属于的数组对象。 exp:通过map方法返回数组元素的平方 var arr = [1, 2, 3, 4, 5]; var arr2 = arr.map(function(item){ return item*item; }); console.log(arr2); //[1, 4, 9, 16, 25] 注意，map()方法不会改变原数组，而是返回一个新的数组，注意function中药返回值，否则为空数组 exp2: var arr = [1,2,3,7,9]; var arr2 = arr.map(function(x,index,a){ x=x+1; }); console.log(arr2);//[undifined,undifined,undifined,undifined,undifine] console.log(arr);//[1,2,3,7,9] 即使在map()的函数中改变currentValue的值，原数组的职业不会改变。而如果没有返回值，则该数组为undefined。 filter() 描述： “过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 原型：array.filter(function(currentValue,index,arr), thisValue) currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 exp： var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; var arr2 = arr.filter(function(x, index) { return index % 3 === 0 || x &gt;= 8; }); console.log(arr2); //[1, 4, 7, 8, 9, 10] 该方法的注意事项和上一个方法差不多，也是不会改变原数组，并且必须要有返回值，否则数组为undefined。 every() 描述： 判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 原型：array.filter(function(currentValue,index,arr), thisValue) currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 应用： 检测数组所有元素是否都符合指定条件（通过函数提供）。 exp： var arr = [1, 2, 3, 4, 5]; var arr2 = arr.every(function(x) { return x &lt; 10; }); console.log(arr2); //true var arr3 = arr.every(function(x) { return x &lt; 3; }); console.log(arr3); // false some() 描述： 判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 应用： some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。 exp： var arr = [1, 2, 3, 4, 5]; var arr2 = arr.some(function(x) { return x &lt; 3; }); console.log(arr2); //true var arr3 = arr.some(function(x) { return x &lt; 1; }); console.log(arr3); // false 注意： some() 方法会依次执行数组的每个元素： 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。 reduce()和 reduceRight() 描述： 这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 原型（以reduce为例）： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 currentIndex 可选。当前元素的索引 arr 可选。当前元素所属的数组对象。 exp： var values = [1,2,3,4,5]; var sum = values.reduceRight(function(total, currentValue, currentIndex, arr){ return total + currenValue; },10); console.log(sum); //25 最后这是ES6中提供的数组方法，对于ES6，我还没有认真研究，不过这些方法还是挺实用的，对于低版本的浏览器可能会不支持。感觉开发中还是要针对需求使用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript数组","slug":"JavaScript数组","date":"2018-10-25T16:22:49.000Z","updated":"2018-10-26T13:48:01.919Z","comments":true,"path":"2018/10/26/JavaScript数组/","link":"","permalink":"http://yoursite.com/2018/10/26/JavaScript%E6%95%B0%E7%BB%84/","excerpt":"JavaScript数组复习一下数组，发现有些方法都忘记了 定义数组的方式 采用直接量创建 var MyArray = [];//创建空数组 var MyArray = [1,2,3];//创建数字型数组 var MyArray = [“A”,”B”,”C”];//创建字符型数组 var MyArray = [{id:1},{id:2},{id:3}];//创建对象型数组 采用构造函数创建 var MyArray = new Array(); MyArray[0] = 0; MyArray[1] = “A”; var MyArray = new Array(5); var MyArray = new Array(5,4,3,2,1);","text":"JavaScript数组复习一下数组，发现有些方法都忘记了 定义数组的方式 采用直接量创建 var MyArray = [];//创建空数组 var MyArray = [1,2,3];//创建数字型数组 var MyArray = [“A”,”B”,”C”];//创建字符型数组 var MyArray = [{id:1},{id:2},{id:3}];//创建对象型数组 采用构造函数创建 var MyArray = new Array(); MyArray[0] = 0; MyArray[1] = “A”; var MyArray = new Array(5); var MyArray = new Array(5,4,3,2,1); 属性 constructor 描述：返回对创建此对象的数组函数的引用。 应用1：用于判断元素类型 exp： &lt;script type=&quot;text/javascript&quot;&gt; var test=new Array(); if (test.constructor==Array) { document.write(&quot;This is an Array&quot;); } if (test.constructor==Boolean) { document.write(&quot;This is a Boolean&quot;); } if (test.constructor==Date) { document.write(&quot;This is a Date&quot;); } if (test.constructor==String) { document.write(&quot;This is a String&quot;); } &lt;/script&gt; 输出： This is an Array 应用2：用于获取构造函数的原形 exp: &lt;script type=&quot;text/javascript&quot;&gt; function employee(name,job,born) { this.name=name; this.job=job; this.born=born; } var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985); document.write(bill.constructor); &lt;/script&gt; 输出： function employee(name, job, born) {this.name = name; this.job = job; this.born = born;} length 描述：设置或返回数组中元素的数目 应用：设置或返回数组中元素的数目 exp： &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;John&quot; arr[1] = &quot;Andy&quot; arr[2] = &quot;Wendy&quot; document.write(&quot;Original length: &quot; + arr.length) document.write(&quot;&lt;br /&gt;&quot;) arr.length=5 document.write(&quot;New length: &quot; + arr.length) &lt;/script&gt; 输出： Original length: 3 New length: 5 prototype 描述：使您有能力向对象添加属性和方法 应用：向对象添加属性和方法 exp: //定义一个employee对象 function employee(name,job,born) { this.name=name; this.job=job; this.born=born; } //实例化一个employee var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985); employee.prototype.salary=null; bill.salary=20000; document.write(bill.salary); &lt;/script&gt; 值得注意的是：prototyp是面向对象编程的重要属性。在W3C的解释中，可以知道函数也是一个对向（具体函数与对象的关系后续再详细讨论），每个函数对象都具有一个子对象prototype。Prototype 表示了该函数的原型，prototype表示了一个类的属性的集合。当通过new来生成一个类的对象时，prototype对象的属性就会成为实例化对象的属性。 方法 contact() 描述：连接两个或更多的数组，并返回结果 应用：连接n个数组 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; var arr2 = new Array(3) arr2[0] = &quot;James&quot; arr2[1] = &quot;Adrew&quot; arr2[2] = &quot;Martin&quot; var arr3 = new Array(2) arr3[0] = &quot;William&quot; arr3[1] = &quot;Franklin&quot; //执行连接操作 document.write(arr.concat(arr2,arr3)) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin,William,Franklin join() 描述：把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 应用：创建一个数组，然后把它的所有元素放入一个字符串 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr.join(&quot;.&quot;)) &lt;/script&gt; 输出： George.John.Thomas 注意：join(separator)中separator为间隔符，若为空择默认为逗号。 pop() 描述：pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值 应用：创建一个数组，然后删除数组的最后一个元素 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr) document.write(&quot;&lt;br /&gt;&quot;) document.write(arr.pop()) document.write(&quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas Thomas George,John push() 描述：push() 方法可把它的参数顺序添加到 arrayObject 的尾部。 它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。 arrayObject.push(newelement1,newelement2,....,newelementX) newelement1（必选）- 要添加的第一个元素 newelement2（可选）- 要添加的第二个元素 newelementX（可选）- 要添加的第X个元素 应用：创建一个数组，并通过添加一个元素来改变其长度 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.push(&quot;James&quot;) + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas 4 George,John,Thomas,James reverse() 描述：用于颠倒数组中元素的顺序（该方法会改变原来的数组，而不会创建新的数组） 应用：创建一个数组，然后颠倒其元素的顺序 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.reverse()) &lt;/script&gt; 输出： George,John,Thomas Thomas,John,George shift() 描述:用于把数组的第一个元素从其中删除，并返回第一个元素的值(如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject) 应用：创建一个数组，并删除数组的第一个元素。请注意，这也将改变数组的长度 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.shift() + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas George John,Thomas slice() 描述：slice() 方法可从已有的数组中返回选定的元素 arrayObject.slice(start,end) start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end: 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 应用：创建一个新数组，然后显示从其中选取的元素 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) //截取数组的2-4位（注意数组下标从0开始） document.write(arr.slice(2,4) + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin Thomas,James George,John,Thomas,James,Adrew,Martin sort() 描述：用于对数组的元素进行排序 arrayObject.sort(sortby) sortby 可选。规定排序顺序。必须是函数。 返回值为对数组的引用。请注意，数组在原数组上进行排序，不生成副本 参数说明：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。若 a 等于 b，则返回 0。若 a 大于 b，则返回一个大于 0 的值。 应用：创建一个数组，并按字母顺序进行排序 exp1： &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.sort()) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin Adrew,George,James,John,Martin,Thomas exp2:实现对多位数的排序（利用排序函数作为参数） &lt;script type=&quot;text/javascript&quot;&gt; function sortNumber(a,b) { return a - b } var arr = new Array(6) arr[0] = &quot;10&quot; arr[1] = &quot;5&quot; arr[2] = &quot;40&quot; arr[3] = &quot;25&quot; arr[4] = &quot;1000&quot; arr[5] = &quot;1&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.sort(sortNumber)) &lt;/script&gt; 如果不写该函数作为参数，只会对多位数的第一位以ASCII码进行排序，无法实现多位数排序 splice() 描述：splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 该方法会改变原始数组 arrayObject.splice(index,howmany,item1,…..,itemX) index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX 可选。向数组添加的新项目。 请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 应用： exp1:创建一个新数组，并向其添加/删除一个元素 &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) //从第二个位置修改，&quot;howmany&quot;参数为0择不删除，第三个参数为要添加的元素 arr.splice(2,0,&quot;William&quot;) document.write(arr + &quot;&lt;br /&gt;&quot;) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin George,John,William,Thomas,James,Adrew,Martin exp2：删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素 var arr = new Array(6) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" arr[3] = \"James\" arr[4] = \"Adrew\" arr[5] = \"Martin\" document.write(arr + \"\") arr.splice(2,1,\"William\") document.write(arr) 输出： George,John,Thomas,James,Adrew,Martin George,John,William,James,Adrew,Martin exp3:删除从 index 2 (“Thomas”) 开始的三个元素，并添加一个新元素 (“William”) 来替代被删除的元素 var arr = new Array(6) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" arr[3] = \"James\" arr[4] = \"Adrew\" arr[5] = \"Martin\" document.write(arr + \"\") arr.splice(2,3,\"William\") document.write(arr) 输出： George,John,Thomas,James,Adrew,Martin George,John,William,Martin unshift 描述：可向数组的开头添加一个或更多元素，并返回新的长度 arrayObject.unshift(newelement1,newelement2,….,newelementX) newelement1 必需。向数组添加的第一个元素。 newelement2 可选。向数组添加的第二个元素。 newelementX 可选。可添加若干个元素。 说明：unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。 请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。 请注意，unshift() 方法无法在 Internet Explorer 中正确地工作！ 应用：创建一个数组，并把一个元素添加到数组的开头，并返回数组的新长度 exp: var arr = new Array() arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" document.write(arr + \"\") document.write(arr.unshift(\"William\") + \"\") document.write(arr) 输出： George,John,Thomas 4 William,George,John,Thomas 一些不常用的方法 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 valueOf() 返回数组对象的原始值 说明以上内容均来自W3Cschool，我是为了加深印象，巩固一下知识点。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JS代码段所放位置的区别","slug":"JS代码段所放位置的区别","date":"2018-10-19T14:27:14.000Z","updated":"2018-10-19T16:44:07.515Z","comments":true,"path":"2018/10/19/JS代码段所放位置的区别/","link":"","permalink":"http://yoursite.com/2018/10/19/JS%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%89%80%E6%94%BE%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"前言在很久之前就遇到了这个问题，由于代码段放的位置不对导致代码段无法生效。所以这次就简单写一下代码段不同位置的区别。 正文","text":"前言在很久之前就遇到了这个问题，由于代码段放的位置不对导致代码段无法生效。所以这次就简单写一下代码段不同位置的区别。 正文 JavaScriptJS是一种解释性脚本（不进行预编译） 高级语言的两种翻译方式： 编译 以基本的C语言为例，大部分语言是直接通过编译器将高级语言编译成为机器可以懂的机器语言（二进制文件 .exe）。但是也有不一样的，比如JAVA这种跨平台语言，它是将高级语言先编译成为JAVA虚拟机能够识别的class文件，在不同的平台上再编译为相应的机器语言，实现跨平台。 解释 解释性脚本脚本不需要编译，在执行时才进行解释。解释性脚本语言有专门的解释器，不过每次执行时都需要编译，所以效率比较低。 JavaScript也有自己的解释器–JavaScript引擎，他是浏览器的一部分。 HTML 语言的执行顺序作为一门解释性脚本语言，它的执行顺序是从前到后顺序执行。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Html页面内容执行顺序&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var userId = $(&apos;#hiddenUserId&apos;).val(); var contextPath = $(&apos;#hiddenContextPath&apos;).val(); var userName = $(&apos;#hiddenUserName&apos;).val(); alert(userName); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 按照顺序执行，先解析该文档为HTML文档，接着解析head部分的script脚本，head部分的style样式，接着渲染body部分，接着解析body中的script脚本。 按照以上顺序，我就可以理解为什么我上一次引用的验证码脚本以及vue框架放在HTML中head部分时，无法生效。原因是在于如果将脚本放在head中，script脚本执行时DOM树还没有被渲染，所以脚本是无法执行对DOM进行修改的。而如果将脚本放在body尾部，执行此脚本时，DOM树已被渲染完毕，所以可执行修改操作。 结论1.head中所放的JavaScript代码段主要功能应该是不会在页面加载时就进行执行的脚本功能，即后续通过其他操作触发的（比如onclik按键触发），这类脚本可以预先解释，在需要时再执行 2.body后面放的脚本应该是页面加载时就要触发的脚本，比如对DOM数内容的初始化（向上面的验证码系统，vue的脚本） 特殊情况以下情况可以改变JS代码的执行顺序 window.onload:等到页面中的所有内容加载完成后才会执行。 $(document).ready():页面中所有的DOM结构绘制完成后就能够执行。 script脚本中，大部分浏览器支持async和defer属性。 async表示的意思是异步加载JavaScript文件，它的下载过程可以在HTML的解析过程中进行，加载完成之后立即执行这个文件的代码，执行文件代码的过程中会阻塞HTML的解析，它不保证文件加载的顺序。 defer表示的意思是在HTML文档解析之后在执行加载完成的JavaScript文件，JavaScript文件的下载过程可以在HTML的解析过程中进行，它是按照script标签的先后顺序来加载文件的。 参考资料： 1.把JavaScript文件放在文档的头部还是尾部 2.CSS、JS 放置位置与前端性能的关系？ 3.HTML页面的加载顺序","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"node-js基本用法解析","slug":"node-js基本用法解析","date":"2018-09-22T07:18:33.000Z","updated":"2018-09-25T13:34:51.186Z","comments":true,"path":"2018/09/22/node-js基本用法解析/","link":"","permalink":"http://yoursite.com/2018/09/22/node-js%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/","excerpt":"前言 为什么会想到搞一下node呢，emmmm，主要是之前想收图片，每个人4张，一共几十个人，如果都通过qq发过来那简直市场噩梦（虽然我最后还是经历了这擦会给你噩梦），所以下定决心要搞一下后端的东西，PHP，ASP学习成本有点高，速成还是有点难，所以我想到了node.js这个神奇的东西，用js的语言来写后端的东西，nice哦。所以就有了这篇文章。","text":"前言 为什么会想到搞一下node呢，emmmm，主要是之前想收图片，每个人4张，一共几十个人，如果都通过qq发过来那简直市场噩梦（虽然我最后还是经历了这擦会给你噩梦），所以下定决心要搞一下后端的东西，PHP，ASP学习成本有点高，速成还是有点难，所以我想到了node.js这个神奇的东西，用js的语言来写后端的东西，nice哦。所以就有了这篇文章。 正文EventEmitter模块这个模块可以说是node中一个核心的模块，包括fs，http，net等模块的事件都是继承自该模块，若不使用继承的方法，其基本用法是： //引入events模块 var eventEmitter = require(&apos;events&apos;); //创建eventEmitter var events = new events.EventEmitter(); event.on(&apos;some_event1&apos;,function(){ console.log(&quot;监听器1执行&quot;); }) event.addListener(&apos;some_event2&apos;,function(){ console.log(&quot;监听器2执行&quot;); }) event.removeListener(&apos;some_event1&apos;,function(){ console.log(&quot;监听器1移除&quot;); }) event.emit(&apos;some_event1&apos;); 这是一些基本的用法，不过这个方法在平时不怎么用，所以了解一下就ok了。 文件系统fs异步与同步由于node是基于JS，所以异步与同步是不可回避的一个问题，在之前的博文中，我们也解析过JS的异步与同步操作，这里不再赘述。而node中文件操作是同时支持异步与同步操作，具体区别这里也不再赘述。 异步与同步代码var fs = require(&apos;fs&apos;); //异步读取 fs.readFile(&apos;input.txt&apos;,function(err,data){ if(err){ return console.error(err); } console.log(&apos;异步读取&apos;+data.toString()); }); //同步读取 var data = fs.readFileSync(&apos;input.txt&apos;); console.log(&quot;同步读取：&quot;+dataString()); console.log(&apos;文件操作完毕&apos;); 注意这里是展示同步与异步的代码区别，一般是在操作代码后加上“Sync”(同步)，但一般我们并不使用这种同步的方法，因为在文件大一点的时候这会严重影响代码执行的效率。 打开文件语法格式 fs.open(path,flag,callback) 参数 path-文件路径 flag-文件打开的模式 callback-回调函数，该函数带有两个参数（err,fd），err-&gt;错误，fd-fileData，文件内容及信息 下面是flag的参数及其说明 获取文件信息语法格式 fs.stat(path,callback) 参数 path-文件路径 call-回调函数 var fs = require(&apos;fs&apos;); fs.stat(&apos;/Users/liuht/code/itbilu/demo/fs.js&apos;, function (err, stats) { console.log(stats.isFile()); //true }) 下面是该类中的方法： 写入文件语法格式 fs.writeFile(file,data[,option],callback) 参数 file-文件名或文件描述 data-要写入的数据，可以是字符串（String）或缓冲变量（Buffer）对象 option-该参数是一个对象，包含{encoding,mode,flag}。默认为{utf8,0666,w} callback-回调函数（仅包含err，在写入失败时返回） var fs = require(&apos;fs&apos;); console.log(&apos;准备写入文件&apos;); fs.writeFile(&apos;input.txt&apos;,&apos;我是通过fs.file写入的内容&apos;,function(err){ return console.log(err); } console.log(&apos;数据写入成功！&apos;); console.log(&apos;读取写入的数据!&apos;); fs.readFile(&apos;input.txt&apos;,function(err,data){ if(err){ return console.log(err);} console.log(&apos;读取文件内容：&apos;+data.toString()); }); }); 这是代码执行效果： $ node file.js 准备写入文件 数据写入成功！ 读取写入的数据！ 异步读取文件数据: 我是通 过fs.writeFile 写入文件的内容 读取文件语法格式 fs.readFile(fd,buffer,offset,length,position,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 buffer - 数据写入的缓冲区。 offset - 缓冲区写入的写入偏移量。 length - 要从文件中读取的字节数。 position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。 callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。 var fs = require(&quot;fs&quot;); var buf = new Buffer.alloc(1024); console.log(&quot;准备打开已存在的文件！&quot;); fs.open(&apos;input.txt&apos;, &apos;r+&apos;, function(err, fd) { if (err) { return console.error(err); } console.log(&quot;文件打开成功！&quot;); console.log(&quot;准备读取文件：&quot;); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){ if (err){ console.log(err); } console.log(bytes + &quot; 字节被读取&quot;); // 仅输出读取的字节 if(bytes &gt; 0){ console.log(buf.slice(0, bytes).toString()); } }); }); 下面是代码执行效果： $ node file.js 准备打开已存在的文件！ 文件打开成功！ 准备读取文件： 25 字节被读取 This is a test inputtxt 关闭文件fs.close(fd,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 callback - 回调函数，没有参数。 fs.close(fd, function(err){ if (err){ console.log(err); } console.log(&quot;文件关闭成功&quot;); 截取文件fs.ftruncate(fd,len,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 len - 文件内容截取的长度。 callback - 回调函数，没有参数（但含有err参数）。 fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){ if (err){ console.log(err); } // 仅输出读取的字节 if(bytes &gt; 0){ console.log(buf.slice(0, bytes).toString()); } 删除文件fs.unlink(path,callback) 参数 path-路径 callback-回调函数，没有参数（但含有err参数） 实例 var fs = require(&apos;fs&apos;); console.log(&apos;开始删除文件！&apos;); fs.unlink(&apos;input.txt&apos;,function(err){ if(err){ return console.log(err); } console.log(&quot;删除成功！&quot;); }) 创建目录fs.mkdir(path,[,mode],callback) 参数 path - 文件路径。 mode - 设置目录权限，默认为 0777。 callback - 回调函数，没有参数。 实例 var fs = require(&apos;fs&apos;); console.log(&apos;创建目录 /tmp/test/&apos;); fs.mkdir(&quot;/tmp/test/&quot;,function(err){ if(err){ return console.log(err); } console.log(&apos;目录创建成功&apos;); }) 这是执行效果 $ node file.js 创建目录 /tmp/test/ 目录创建成功。 ###读取目录###语法 fs.readdir(path,callback) 参数 path - 文件路径。 callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。 实例 var fs = require(&quot;fs&quot;); console.log(&quot;查看 /tmp 目录&quot;); fs.readdir(&quot;/tmp/&quot;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); 执行效果 $ node file.js 查看 /tmp 目录 input.out output.out test test.txt ###删除目录### 语法 fs.rmdir(path,callback) 实例 var fs = require(&quot;fs&quot;); // 执行前创建一个空的 /tmp/test 目录 console.log(&quot;准备删除目录 /tmp/test&quot;); fs.rmdir(&quot;/tmp/test&quot;,function(err){ if (err) { return console.error(err); } console.log(&quot;读取 /tmp 目录&quot;); fs.readdir(&quot;/tmp/&quot;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); }); 执行效果： $ node file.js 准备删除目录 /tmp/test 读取 /tmp 目录 …… 文件模块还有很多方法，具体可以参见node.js官方文档 http模块http模块一般是使用createServer方法来创建服务器，下面是不使用html文件的代码： //获取http方法并定义到变量 var http = require(&apos;http&apos;); http.createServer(function(req,res){ res.writeHead(400,{&apos;Content-Type&apos;:&apos;text/html&apos;}) res.end(&quot;This is a test&quot;); }).listen(3000); console.log(&quot;server running at http://127.0.0.1:3000/&quot;); 这个代码执行后会在网页上显示This is a test 的字样。 下面是使用html文件来作为网页显示： var http = require(&apos;require&apos;); var fs = require(&apos;fs&apos;); var url = require(&apos;&apos;); //创建服务器 http.createServer(function(req,res){ //解析请求，包括文件名 var pathname = url.parse(req.url).pathname; //从文件系统中请求文件内容 console.log(&apos;request for&apos;+pathname+&apos;received&apos;); fs.readFile(pathname.substr(1),function(err,data){ if(err){ console.lor(err); //发送404（未查找到文件）HTTP状态码并规定解析文件为html文件 res.writeHead(404,{&apos;Content-Type&apos;:&apos;text/html&apos;}); }else{ //发送200（正常）HTTP状态码并规定解析文件为html res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;}); //响应文件内容 res.write(data.toString()); }) res.end(); }).listen(3000); console.log(&quot;Server running at http://127.0.0.1:3000/&quot;); index文件： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 执行上面JS代码，并在浏览器中填入：http://127.0.0.1:8080/index.html，就会显示出index.html网页内容。 url及post和get请求url是指请求的地址，其中不仅包含路径，还了可以包含多个参数，如下图，网址‘http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&#39; 以下代码可以从url中获取相关的参数： var http = require(&apos;http&apos;); var url = require(&apos;url&apos;); var util = require(&apos;util&apos;); http.createServer(function(req,res){ res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;;&apos;charset=utf-8&apos;}); res.end(util.inspect(url.parse(req.url,true))); }).listen(3000); 其效果： 其中util模块是一个工具模块，提供了很多功能，其中util.inspect(object[,options]),这里option的选项很多，这里不再展开叙述。其作用是一个将任意对象转换 为字符串的方法,通常用于调试和错误输出。 将url中的属性值提取出来， var http = require(&apos;http&apos;); var url = require(&apos;url&apos;); var util = require(&apos;util&apos;); http.createServer(function(req,res){ res.writeHead(200,{&apos;Conten-Type&apos;:&apos;text/plain&apos;}); var params = url.parse(req.url,true).query; res.write(&quot;网站名：&quot;+params.name); res.write(&quot;\\n&quot;); res.write(&quot;网站URL：&quot;params.url); res.end(); }).listen(3000); 效果： 获取表单数据 var http = require(&apos;http&apos;); var querystring = require(&apos;querystring&apos;); var postHTML = &apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;&apos; + &apos;&lt;body&gt;&apos; + &apos;&lt;form method=&quot;post&quot;&gt;&apos; + &apos;网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;&apos; + &apos;网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;&apos; + &apos;&lt;input type=&quot;submit&quot;&gt;&apos; + &apos;&lt;/form&gt;&apos; + &apos;&lt;/body&gt;&lt;/html&gt;&apos;; http.createServer(function (req, res) { var body = &quot;&quot;; req.on(&apos;data&apos;, function (chunk) { body += chunk; }); req.on(&apos;end&apos;, function () { // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/html; charset=utf8&apos;}); if(body.name &amp;&amp; body.url) { // 输出提交的数据 res.write(&quot;网站名：&quot; + body.name); res.write(&quot;&lt;br&gt;&quot;); res.write(&quot;网站 URL：&quot; + body.url); } else { // 输出表单 res.write(postHTML); } res.end(); }); }).listen(3000); 其效果如图： 将表单提交的数据利用express框架获取表单内容var express = require(&apos;express&apos;); var app = express(); //将文件夹public设为express公开文件夹(express模块已经将fs方法至于其中，因此在设置公开文件夹时不需再引用fs模块)。 app.use(express.static(&apos;public&apos;)); app.get(&apos;/index.html&apos;,function(req,res){ res.sendFile(_dirname+&apos;/&apos;+&apos;index.html&apos;); }) app.get(&apos;/process_get&apos;,function(req,res){ var response = { &quot;first_name&quot;:req.query.first_name, &quot;last_name&quot;:req.query.last_name }; console.log(response); res.end(JSON.stringify(response)); }); var server = app.listen(8081,function(req,res){ var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port); }); html代码： &lt;html&gt; &lt;body&gt; &lt;form action=&quot;http://127.0.0.1:8081/process_get&quot; method=&quot;GET&quot;&gt; First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt; &lt;br&gt; Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 效果如图： express模块是一个web应用框架，他提供了很多强大的功能来更简单的创建web应用。 利用express及multer来实现文件的上传multer模块主要处理表单文件的上传。 var express = require(&apos;express&apos;); var multer = require(&apos;multer&apos;); var app = express(); app.use(express.static(&apos;public&apos;)); // 通过 filename 属性定制 var storage = multer.diskStorage({ destination: function (req, file, cb) { cb(null, &apos;/web开发/测试/upload&apos;); // 保存的路径，备注：需要自己创建 }, filename: function (req, file, cb) { // 将保存文件名设置为 字段名 + 时间戳+后缀，比如 logo-1478521468943 cb(null, file.fieldname + &apos;-&apos; + Date.now()+&apos;.jpg&apos;); } }); // 通过 storage 选项来对 上传行为 进行定制化 var upload = multer({ storage: storage }) //var upload = multer({dest : &apos;upload/&apos; }); //var upload = multer({storage:storage}); app.get(&apos;/index&apos;,function(req,res){ res.send(_dirname+&quot;/&quot;+&quot;index.html&quot;); }) //single中的第二个参数代表可以接受几个文件，2代表可以接受两个文件 app.post(&apos;/upload&apos;,upload.single(&apos;pics，2&apos;),function(req,res){ res.send(&quot;ok&quot;); }) var server=app.listen(3030,function(){ var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) }) 上面这段代码可以实现文件的上传并将其放在规定的文件夹及其规律化的命名： html代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!-- &lt;span&gt;first item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;first_item&quot;&gt;&lt;br/&gt; &lt;span&gt;second item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;second_item&quot;&gt;&lt;br/&gt; --&gt; &lt;span&gt;file&lt;/span&gt;&lt;input type=&quot;file&quot; name=&quot;pics&quot;&gt;&lt;br/&gt; &lt;/be/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 最后终于把这个简单的文章写完了，这只是node的冰山一角，node还有很多模块及其方法，想要精通段时间内几乎是不可能的，后面还是要继续努力xio习啊！ 引用 菜鸟教程 Nodejs进阶：基于express+multer的文件上传","categories":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/categories/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"千万不要躺太久-三和大神的生活","slug":"千万不要躺太久-三和大神的生活","date":"2018-08-30T11:45:44.000Z","updated":"2018-08-31T14:40:51.424Z","comments":true,"path":"2018/08/30/千万不要躺太久-三和大神的生活/","link":"","permalink":"http://yoursite.com/2018/08/30/%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E8%BA%BA%E5%A4%AA%E4%B9%85-%E4%B8%89%E5%92%8C%E5%A4%A7%E7%A5%9E%E7%9A%84%E7%94%9F%E6%B4%BB/","excerpt":"三和大神“三和大神”是一群平凡而又特殊的工人，平凡在于他们也是干活领工资，也在人才市场找工作。特殊在于他们的工作信仰与普通的工人不同，他们的理念是“干一天，玩三天”，只要身上有钱，就不去工作，什么时候口袋空了，什么时候就去工作。","text":"三和大神“三和大神”是一群平凡而又特殊的工人，平凡在于他们也是干活领工资，也在人才市场找工作。特殊在于他们的工作信仰与普通的工人不同，他们的理念是“干一天，玩三天”，只要身上有钱，就不去工作，什么时候口袋空了，什么时候就去工作。 三和大神的贫瘠生活经济的贫瘠“干一天玩三天”，这就是三和大神所信奉的生活状态，那这一天挣多少呢？ –大约86元人民币 接下来的三天就可以过着自由的生活，安逸的躺在十几元的廉价旅馆中，把已经发霉的被子盖在身上，闻着各种习以为常的异味，连着WiFi刷着破损的手机，吃着4元一碗的挂逼面，喝着1元一瓶的挂逼水，或者是在1元一小时的网吧中玩上两天。在身上已经没有钱够吃一碗挂逼面时，又站起来去到“人才市场”干一天。 精神的贫瘠干完这一天又回到那家小旅馆，躺下…… 这样一个又一个的循环，他们生活里毫无波澜，仿佛一滩没有生命的死水，唯一能激起一圈涟漪的应该就是兜里没有钱时，又要去干一天的无奈。他们希望通过网络弥补现实生活的贫瘠，在手机中看着这个明星又出轨了，那个人扶老奶奶又被讹了，他们手指迅速点击着屏幕，批判这个明星的生活作风太差，指责这个社会的黑暗，没有好人了。或者在游戏中虐一下对手，或者嘲讽一下对手，或者夸耀一下自己，将自己想象为游戏角色，以此拾得自己早已丢失在生活中自豪感。 然后又到了工作的那一天，他们将自己的精神冻结起来，以一种自我麻痹的状态完成工作，然后又回到网络上，拾回自己的精神，他们不敢把自己的精神带回到现实生活，因为他们不敢面对那个真实的自己，那个一无所有的自己，那个毫无地位的自己。 感情的贫瘠在“三和大神”的行列中，感情似乎是一件不可望更不可及的东西，没有亲人或者亲人根本不联系，更别提爱情，不想要更不需要，一人吃饱全家喝足的状态，这样毫无牵挂，似乎完全没有必要再在社会中跌跟头了，一直躺在地上就挺舒服。 他们为什么到这一步？每个人自来到这个世界，都不甘于低于别人，那为什么“三和大神”会甘于这样的生活？ 对生活失去希望宋春江，27岁迈入大神的行列，中专学习的服装和电脑，本以为毕业后可以找个好工作，有个温馨的家庭，平静的生活。可学校分配的工作是做流水线工人，早上7点工作到晚上11点甚至更晚。刚毕业那会还觉得有机会，七八年后，他已不再想过日子，这期间他也从流水线工人变成了标准的“三合大神”。过着“干一天玩三天”的生活。是什么让他成为了“三和大神”？—失去生活的希望 流水线的工作，无限制的循环一件事情，似乎完全看不见自己的未来，还是带着每日全身的疲倦，与其如此，不如过着“三和大神”的生活来的实在，累一天“舒服”三天。 误入歧途 东东，22岁，来自农村，因为上班时打瞌睡被老板娘说了几句就辞职来到三和，住进了15元一晚的宾馆。开始“三和大神”的生活。 躺下太久就站不起来了！ 对于“三和大神”，我感到的不是同情，而是可怜，甚至是可笑，所有的一切不过都是自己不想站起来的原因罢了！不过是自己懒惰的借口！我们不得不承认社会的不公，你也许永远无法成为王健林，马云，但你是可以靠自己的努力让你过上普通人的生活。觉得自己的工作没希望就换个有希望的工作，找不到就去学习。这中国这片土地上永远不缺可供学习的地方。唯一缺的是愿意一心一意去学习的人。所谓的“三和大神”不过是那些受不了现实的打击或承受不了现实的打磨，倒在路上的一群人！他们甘愿倒在半路！他们甘愿走在社会的最低层！那么这就是不会被同情的，因为是他们自己选择了自己的道路，不是别人，更不是这个社会！“讨厌长期劳动，喜欢日结”不过是自己不愿努力的掩饰罢了，就如同“讨厌站起来，喜欢躺在在床上”一样可笑。 我们都一样人性相同其实他们与我们有什么不同？哪一个人不希望每天轻轻松松，什么都不干，不去承受，不去负担。这种人性的弱点是始终存在的。即使是再伟大的人，也会有偷懒的想法。古代的皇帝，每天翻阅奏章，管理国家大事，几乎所有的大事都会通过皇帝的脑袋，难道他不想随便完成然后去后宫吃喝玩乐？如今的富商哪一个不是每天满满的日程，用尽心思的去经营自己的生意，难道他们不想停下来休息一下？芸芸众生谁不辛苦？谁生活在温室中？谁不想停下来“躺在地上”？但我们没有那么做，因为“躺下太久，就站不起来了”！ 选择不同但我们的选择不同，我们选择了站起来，继续前进。现实一次又一次的将我们击倒，但仍然有人站起来，继续前进！“三和大神”就是被击倒后站不起来的那一群人。他们倒下后发现原来躺着是这么舒服啊，那就别站起来了，干脆做他一场黄粱大梦，或在梦中，或在网络中。 请不要躺太久！请不要躺太久，以至于忘记如何站立！不管自己的梦想是否遥远，都请一直走下去，因为至少你可以更清晰的看见自己的梦想啊。","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"社会","slug":"社会","permalink":"http://yoursite.com/tags/%E7%A4%BE%E4%BC%9A/"},{"name":"见解","slug":"见解","permalink":"http://yoursite.com/tags/%E8%A7%81%E8%A7%A3/"}]},{"title":"开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）","slug":"开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）","date":"2018-08-25T01:01:03.000Z","updated":"2018-08-25T11:50:13.614Z","comments":true,"path":"2018/08/25/开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）/","link":"","permalink":"http://yoursite.com/2018/08/25/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%89%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%EF%BC%88%E5%88%A9%E7%94%A8localStorage%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%EF%BC%89/","excerpt":"前言这个小项目花了我大概10天的时间（每天5h左右），可以说是很慢了，主要是JS的很多知识点不熟悉，边研究边开发。而且数据库部分仍然时使用本地存储，也就是说这个案例是无法投入到实际使用中，但后面我会去研究一下mysql，在服务器端部署一个小型的数据库，估计不会花太长时间，另外觉得node.js挺有意思，hexo就是基于node.js，将JS用于与计算机系统的直接沟通，That`s cool，本来我的原计划是将博客信息存储在本地文件中，比如直接在本地存储一个JSON文件用来存储一篇博客，后来发现这个是实现不了的，因为浏览器内核无法与系统直接沟通，内核是在浏览器提供的一个BOX中运行，无法直接操作系统文件，emmmm，可能这也是为系统安全把，不然随便一个恶意网页就可以操作你的文件，This is unimaginative。也是因为这个所以才有了node.js的诞生的吧！","text":"前言这个小项目花了我大概10天的时间（每天5h左右），可以说是很慢了，主要是JS的很多知识点不熟悉，边研究边开发。而且数据库部分仍然时使用本地存储，也就是说这个案例是无法投入到实际使用中，但后面我会去研究一下mysql，在服务器端部署一个小型的数据库，估计不会花太长时间，另外觉得node.js挺有意思，hexo就是基于node.js，将JS用于与计算机系统的直接沟通，That`s cool，本来我的原计划是将博客信息存储在本地文件中，比如直接在本地存储一个JSON文件用来存储一篇博客，后来发现这个是实现不了的，因为浏览器内核无法与系统直接沟通，内核是在浏览器提供的一个BOX中运行，无法直接操作系统文件，emmmm，可能这也是为系统安全把，不然随便一个恶意网页就可以操作你的文件，This is unimaginative。也是因为这个所以才有了node.js的诞生的吧！ 正文BB了那么久，咳咳，进入正题。 首页 布局过后首页上半部分是这样，和当初的设计差不多。整个上半部分是一个轮播图。 var i=0; setInterval(function(){ if(i&lt;4) { i++; $(document).ready(function(){ $(&quot;.item&quot;).eq(i).fadeIn(2000).siblings().fadeOut(2000); }); } else { $(document).ready(function(){ $(&quot;.item&quot;).eq(3).fadeIn(2000).siblings().fadeOut(2000); }); i=-1; } //console.log(i); }, 4000); 用了jquery的fadeIn,fadeOut方法，由于没有按钮使代码很简单，只用了十多行代码。唯一有问题的最后一张图片与第一张总是相差设定时间的2倍，想了许多办法没有解决，我就直接班另一张图片插入到最后一张与第一张的间隔之间，这样就实现图片的播放速度是均匀的，但问题是不循环播放的，有一张图片要多出现一次。 顶部分别是home，catalogue，和login的链接，左半部分有博主本人的logo。 点击logo可以将其大部分隐藏到屏幕外侧，like this， 再次点击边缘部分，可再次点击召唤出logo &lt;- &lt;-其原理也很简单，只是利用了jquery的动画方法， animate（） 布局方面整个上半部分设计简单，只用了原生的CSS与html完成。 下半部分是文章展示部分，我是在首页设置了几篇置顶文章，具体方法是直接在在html文档中写入写入这一部分代码，不是JS后期插入到文档中，然后下面是使用JS写入的文章部分，这些文章都是存储在数据库中的部分，并且可以在article页面查看。具体实现方式是在写入博客时将博客的title，date，tags，article写入到一个对象中，再JSON化写入本地（这里JSON化的原因在上期关于localStorage的介绍中已经写到，主要原因是localStorage只能存储string要想保留格式，JSON化是一种比较好的办法）。然后在首页读取数据再JSON.parse，在格式插入到文档中。 另外在首页还需要解决问题就是将文章序号传输到文章展示页面，因为当点击文章标题或more时，需要跳转至文章展示页面，展示该文章。我所想到的解决办法是在添加文章到首页文档流中时就把序号写入放置该文章的div的id的尾部，传输到展示页面时再通过this关键字读取id关键字（在测试中我也发现this无法获取class属性的值，原因我正在探索中，后面会出一起专门关于this的文章），并通过charAt()获取该序号，然后通过URL传值的方法将其传递到展示页面。 展示页面 文章展示页面提供问文章的全面展示，并且提供评论功能。（本来是打算在首页也只展示文章的部分，后来感觉有点麻烦，看后面有时间了再实现）。 接上面首页传输文章序号到展示页面，展示页面通过函数解析序号，这个函数我实用的网上的一个模板，代码如下。 UrlParm = function() { // url参数 var data, index; (function init() { data = []; index = {}; var u = window.location.search.substr(1); if (u != &apos;&apos;) { var parms = decodeURIComponent(u).split(&apos;&amp;&apos;); for (var i = 0, len = parms.length; i &lt; len; i++) { if (parms[i] != &apos;&apos;) { var p = parms[i].split(&quot;=&quot;); if (p.length == 1 || (p.length == 2 &amp;&amp; p[1] == &apos;&apos;)) {// p | p= data.push([&apos;&apos;]); index[p[0]] = data.length - 1; } else if (typeof(p[0]) == &apos;undefined&apos; || p[0] == &apos;&apos;) { // =c | = data[0] = [p[1]]; } else if (typeof(index[p[0]]) == &apos;undefined&apos;) { // c=aaa data.push([p[1]]); index[p[0]] = data.length - 1; } else {// c=aaa data[index[p[0]]].push(p[1]); } } } } })(); return { // 获得参数,类似request.getParameter() parm : function(o) { // o: 参数名或者参数次序 try { return (typeof(o) == &apos;number&apos; ? data[o][0] : data[index[o]][0]); } catch (e) { } }, //获得参数组, 类似request.getParameterValues() parmValues : function(o) { // o: 参数名或者参数次序 try { return (typeof(o) == &apos;number&apos; ? data[o] : data[index[o]]); } catch (e) {} }, //是否含有parmName参数 hasParm : function(parmName) { return typeof(parmName) == &apos;string&apos; ? typeof(index[parmName]) != &apos;undefined&apos; : false; }, // 获得参数Map ,类似request.getParameterMap() parmMap : function() { var map = {}; try { for (var p in index) { map[p] = data[index[p]]; } } catch (e) {} return map; } } }(); 有点长，权当备份一下，后面在分析这个函数。 展示页面解析到文章序号后，展示函数直接通过读取数据库读取到数据添加到文档流中。 评论部分的实现也比较简单，通过读取文档中用户输入的信息并将其重新写入该文章数据库中的JSON中，展示时自动展示出来。 目录页面 目录页面展示了所有通过JS放入数据库的文章（不包括首页置顶文章）。 这里的实现就是直接遍历数据库中的博客文章信息，因为当时存储时是格式命名的，所以遍历很简单，再把title循环添加到文档流中就ok了。 登录及后台管理页面 登录页面使用MD5加密方式，与本地存储的密匙（未来的密匙存储在服务器端）进行对比。 这里是在登录过后显示页面，首先这里布局还是用了frame框架，我暂时还没想到更好的替代办法，虽然frame在H5已被抛弃。 在写博客页面，用户将自己的文章内容输入，然后提交，文章内容会被JSON化后被保存到数据库，下次进入首页时就会直接被展示出来。 删改页面也是遍历数据库，直接修改数据库内容就好了，还是比较简单了，具体过程就不再赘述。 最后的工具页面是我想没事可以自己开发一些简单的工具，比如什么颜色拾取等等，这也是后话。 最后其实这个小项目还是比较简单，代码量也不是很大，主要是练一下手，熟悉以一下前端的一些知识，当然这个小项目还有很多不足需要满足，包括在代码规范等等,方便后面的深入学习。当然后面在学习玩数据库后会把本地数据库改为服务器端的数据库，使之可以实际运行。","categories":[{"name":"博客开发系列","slug":"博客开发系列","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"博客开发","slug":"博客开发","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}]},{"title":"关于JS单线程，异步执行的理解","slug":"关于JS单线程，异步执行的理解","date":"2018-08-22T02:13:24.000Z","updated":"2018-08-22T04:20:53.093Z","comments":true,"path":"2018/08/22/关于JS单线程，异步执行的理解/","link":"","permalink":"http://yoursite.com/2018/08/22/%E5%85%B3%E4%BA%8EJS%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"前言在这几天的开发过程中，遇到了不少问题，阻塞最久的应该就是一段JS代码没有按照我以为的执行顺序去执行，想想好像也没有具体的了解JS的执行过程，所以花了一整天的时间来了解了一下JS的执行机制。","text":"前言在这几天的开发过程中，遇到了不少问题，阻塞最久的应该就是一段JS代码没有按照我以为的执行顺序去执行，想想好像也没有具体的了解JS的执行过程，所以花了一整天的时间来了解了一下JS的执行机制。 问题代码for(var i=0;i&lt;=3;i++){ $(document).ready(function){ console.log(i); }); 出现问题的代码简化过后大概是这个样式，我的预期是输出1，2，3，但输出的结果却为3,3,3，我开始以为是JS单线程执行的缘故，所以Jquery代码被放在了callback queue（任务队列）的最后执行，但我查询资料后发现仅发现浏览器会为定时器，ajax等多开线程，jquery应该不算，正在我疑惑之时，我打开了Jquery的官方文档，看到了 $(document).ready(function(){});的定义：文档准备完成后，内部的匿名函数作为document(ready)的回调函数进行执行，而此时for早已进行玩了。这就解释了为什么都是3,3,3。 正文从浏览器谈起浏览器的进程与线程浏览器是多进程的 Browser进程：负责浏览器的主进程（协调，主控）。 第三方插件进程：每一个插件对应一个进程。 GPU进程：用于绘制3D图形等。 浏览器渲染进程 （render进程，浏览器内核）：每一个Tab页面一个进程，这个进程渲染我们所看到的每个页面。 浏览器渲染进程是多线程的前面我们说到我们所看到的页面都是有渲染进程进行渲染的，而他又是多线程的： GUI渲染线程（浏览器内核） 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发进程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 进入正题，JS的执行过程js的同步任务和异步任务 所有同步任务（能够立即被执行，不消耗时间的任务，如变量核函数的初始化，时间的绑定等等不需要回调函数的任务）都在主线程中执行，形成执行栈（stack），heap（堆）用来存储变量，对象等。 所有异步任务（一半会有操作，如点击事件，定时事件，具有回调函数的事件）运行在事件触发线程中，当异步任务有结果是，其回调函数（Callback Function）就会被放到任务队列中，等待执行。 当执行栈中同步任务执行完毕后， JS引擎就会从任务队列中（callback queue）中查找任务放入执行栈中，这个过程就被称之为事件循环event loop。 从上面的解释中可以看到JS引擎始终是在执行栈中单线程执行任务，当执行栈空时，接下来的任务才回从任务队列中读取下一任务。 何为异步 所谓的异步，就是在其他线程（事件触发线程，异步http请求线程等）的辅助下，JS线程实现异步处理任务。举个栗子： consloe.log(&quot;a&quot;) setTimeout(function() { console.log(&quot;b&quot;) }, 0) console.log(&quot;c&quot;) 模拟其运行过程： 1.consloe.log(&quot;a&quot;)// JS引擎发现这是一个同步任务，立即执行打印出a; 2.setTimeout(function() { console.log(&quot;b&quot;) }, 0)//JS引擎只想此处时发现这是一个异步任务，所以直接交由定时触发线程。 JS引擎继续向下执行，与此同时，定时触发线程接收到该事件，解析代码过后， 将在0毫秒实际是4毫秒，因为在上面我们讲到，W3C规定定时引擎的最低时间为4毫秒）后向JS引擎发送 回调函数，并将其推到任务队列中等待执行。 3.console.log(&quot;c&quot;)//再向定时引擎发送定时事件后立即执行该代码。打印出c。 4.定时引擎将console.log(&quot;b&quot;)推入任务队 列，在console.log（&quot;c&quot;）运行完成后，执行栈空，再将其推入执行栈，然后执console.log(&quot;c&quot;)， 打印出c,因此这段代码输出的结果为a,c,b,而不是a,b,c. 注意，即使setTimeout不是4毫秒后，而是0毫秒后返回回调函数，执行结果任然是a,c,b。因为这是一个排队的过程，console.log(“b”)任是排在console.log(“c”)之后的。 由此，一个异步任务就在JS引擎与其他线程的共同作用下完成了。 参考资料从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 js的单线程和异步 JavaScript单线程和异步机制 最后这只是一个简单的理解，其中还有许多部分可能没有完善，等以后有更深的理解时再来完善吧。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"利用SS（Shadowsocks）快速搭建一个vpn","slug":"利用SS（Shadowsocks）快速搭建一个vpn","date":"2018-08-20T10:43:57.000Z","updated":"2018-08-20T12:06:34.774Z","comments":true,"path":"2018/08/20/利用SS（Shadowsocks）快速搭建一个vpn/","link":"","permalink":"http://yoursite.com/2018/08/20/%E5%88%A9%E7%94%A8SS%EF%BC%88Shadowsocks%EF%BC%89%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAvpn/","excerpt":"前言前几天玩kali时发现需要下一个插件，但是需要科学上网，无奈打开之前的vpn软件，发现几乎都关闭了服务，于是我就诞生了自己搭建一个vpn的想法，于是在参考了网上的教程后，折腾了一上午终于成功了。 正文一，购买服务器（vps）国外的服务器提供商比较多，比如DigtaOcean，Vultr，Amazon等等，我选择了Vultr，因为它提供的vps价格最低的一款仅2.5$/月（后来才发现是个坑，后人谨记），其实DigtaOcean也还不错，绑定信用卡就送10刀，而他价格最低的一款vps价格为5刀，相当于是说送你两个月的体验时间，Amazon好像开可以免费体验一年，所以选择服务器时要多方考虑一下，","text":"前言前几天玩kali时发现需要下一个插件，但是需要科学上网，无奈打开之前的vpn软件，发现几乎都关闭了服务，于是我就诞生了自己搭建一个vpn的想法，于是在参考了网上的教程后，折腾了一上午终于成功了。 正文一，购买服务器（vps）国外的服务器提供商比较多，比如DigtaOcean，Vultr，Amazon等等，我选择了Vultr，因为它提供的vps价格最低的一款仅2.5$/月（后来才发现是个坑，后人谨记），其实DigtaOcean也还不错，绑定信用卡就送10刀，而他价格最低的一款vps价格为5刀，相当于是说送你两个月的体验时间，Amazon好像开可以免费体验一年，所以选择服务器时要多方考虑一下，地点我们尽量选在米国，具体速度我没有测试过。注意：千万不要选择2.5刀那款服务器，因为它只有一个ipv6的地址，是无法用来搭建的（具体原因我没有深入探索，但估计也是，不是所有的服务都兼容ipv6，购买这款服务器时官方也会有提示），所以我们选择5刀的那款，系统选择Ubuntu，当然其他的也是可以的。但我们在后面还是把enable ipv6勾上，为我们分配一个ipv6的地址。label和hostname是你自己的信息。至此，服务器的购买就完成了，等待服务器初始化和开机。 二，连接服务器此时，我们可以在你的控制面板里看到你服务器端的ip地址以及用户名和密码。然后我们需要远程连接到你的服务器，这里我们选择Xshell这款软件。点击文件，新建。在主机输入我们在控制面板中看到的IPV4的地址，之后会提示我们输入用户名及密码，这些信息也都在控制面板中，我就不再截图。 之后我们就会连接上我们的服务器。 然后就输几行代码就ok了。 apt-get install python-pip pip install shadowsocks 两行代码就安装好了ShadowSocks,下面就是配置SS文件 nano /etc/shadowsocks.json nano相比于vim更对Linux新手友好。之后将下面这段代码改为你的账户后粘贴进去。 { “server”:”0.0.0.0”, “server_port”:8388, “local_address”: “127.0.0.1”, “local_port”:1080, “password”:”mypassword”, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”: false } 多账户： { “server”:”0.0.0.0”, “port_password”:{ “8381”:”xxxxxxx”, “8382”:”xxxxxxx”, “8383”:”xxxxxxx”, “8384”:”xxxxxxx” }, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”: false } | 字段 | 说明 || server | ss服务监听地址，0.0.0.0允许所有人访问，如果只是自己用，可以改成自己使用端的ip || server_port | ss服务监听端口 || local_address | 本地的监听地址 || local_port | 本地的监听端口 || password | 密码 || timeout | 超时时间，单位秒 || method | 加密方法，默认是aes-256-cfb || fast_open | 使用TCP_FASTOPEN, true / false || workers | workers数，只支持Unix/Linux系统 | 然后启动服务 ssserver -c /etc/shadowsocks.json -d start 如果需要关闭服务 ssserver -c /etc/shadowsocks.json -d stop 至此，我们服务器端就配置好了，现在就是需要下载shadowsocks连接就ok了。 客户端的使用由于SS在天朝已经GG了，官网已经打不开了，只在github中更新，所以，在这里下载以及查看官方文档。！client 下载完客户端后，输入我们的服务器IP，刚刚在SS中设置端口及密码，点击确定就可以连接到我们的vpn了。 然后就查找学习资料吧~","categories":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://yoursite.com/categories/Shadowsocks/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://yoursite.com/tags/Shadowsocks/"},{"name":"vpn","slug":"vpn","permalink":"http://yoursite.com/tags/vpn/"}]},{"title":"对于JS中localStorage的理解","slug":"对于JS中localStorage的理解","date":"2018-08-20T07:13:20.000Z","updated":"2018-08-20T08:36:46.437Z","comments":true,"path":"2018/08/20/对于JS中localStorage的理解/","link":"","permalink":"http://yoursite.com/2018/08/20/%E5%AF%B9%E4%BA%8EJS%E4%B8%ADlocalStorage%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"前言最近在开发博客的过程中，遇到了数据储存的问题，由于我服务器中还未安装sql，加上我对数据库的操作还不是很熟悉，所以先把数据放入了localStorage中，所以我就具体了解了一下这个本地数据库。 正文前端的存储数据的三种方式前端一般数据存储的方式有三种： cookies sessionStorage localStorage","text":"前言最近在开发博客的过程中，遇到了数据储存的问题，由于我服务器中还未安装sql，加上我对数据库的操作还不是很熟悉，所以先把数据放入了localStorage中，所以我就具体了解了一下这个本地数据库。 正文前端的存储数据的三种方式前端一般数据存储的方式有三种： cookies sessionStorage localStorage 简单介绍一下这三种方式的异同： cookies与localStorage可以是永久存储（cookies可设置失效时间；用户不主动清除） sessionStorage与localStorage属于H5引入的新标签，在IE8，Chrome4.0等以上才能执行；并且存储空间更大（5MB/站点）相对于cookies（4KB/站点）。具体localStorage的解析 localStorage的优势与局限优势 相对于cookies拓展了空间大小。 相对于sessionStorage，可永久存储信息。 局限 由于是H5引入的属性，可能一些老版的浏览器不支持该属性。 localStorage所存储的信息被限定被string类型，但由于有JSON等对象转换算法，所以也无所谓了。 另外我在网上了解到，localStorage无法被爬虫抓取到，这一点我目前没有深入探究。 localStorage的使用判断浏览器是否支持 localStorage属性if(！window.localStorage){ alert(&quot;您的浏览器不支持localStorage&quot;) return false} else{ //执行代码 } localStorage的写入三种方法： var data=window.localStorage; data[&quot;name&quot;] = MJ;//关键字name写入 data.age = 20;//关键字age的写入 data.setItem = [&quot;shcool&quot;,清华大学];//关键字school写入 注意：前面是将localStorage属性放入了data变量，同样可以不放入变量，直接调用，所以前面的代码等同于: localStorage[&quot;name&quot;]=MJ; localStorage.age=20; localStorage.setItem(&quot;school&quot;,清华大学); localStorage的读取三种方法： var name = localStorage[&quot;name&quot;]; var age = localStorage.age; var school = localStorage.getItem(&quot;school&quot;); 同样想写入方法一样，也可以将localStorage放入变量中在调用。 值得注意的是，官方更推荐使用，setItem与getItem语法，其原因未具体说明，我猜测可能是为了与JS中的对象区分开，更加语言话，不产生混淆 localStorage的删改localStorage改关键字的值其实就是重新为其赋值，即： localStorage.setItem(&quot;name&quot;,MW); var nameAfter=localStorage.getItem(&quot;name&quot;); //nameAfter===MW-&gt;true localStorage的删除： localStorage.clear();//删除改站点的所有localStorage数据 localStorage.removeItem(&quot;name&quot;); //此时localStorage.name-&gt;nudifined 关于存储的数据仅为string的解决办法（JSON数据类型转换）一，写入时转换为JSON格式输入 var person={ name = &quot;MJ&quot;, age = 20, maritalStatus = true } localStorage.setItem(&quot;person&quot;,JSON.string(person)); 二，读取时转换为JS变量 var person =JSON.parse(localStorage.getItem(&quot;person&quot;)); typof(person.age) //typeof检查变量类型为number typeof(person.maritalStstus)//boolean 最后本来写之前感觉有很多注意要写，但写起来感觉哪些之前感觉是注意点的地方其实只是一个普通的点，所以感觉写起来感觉没有太重要的点，但需要注意的点还是有滴，比如三种存储的异同，localStorage存储的数据仅为string等等。ok，就这样把！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"localStorage","slug":"localStorage","permalink":"http://yoursite.com/tags/localStorage/"}]},{"title":"Apicloud不同页面传值","slug":"Apicloud不同页面传值","date":"2018-08-13T11:00:52.000Z","updated":"2018-08-13T13:26:24.749Z","comments":true,"path":"2018/08/13/Apicloud不同页面传值/","link":"","permalink":"http://yoursite.com/2018/08/13/Apicloud%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC/","excerpt":"前言 标准开头，前一段时间因为需要开发一个简单的app,所以接触了一下Apicloud,因为没有native应用的开发知识，所以采用了Apicloud的web应用开发。其中不同页面的传值问题我具体研究一段时间，因为之前一直传值不成功。 正文方法一：api.execScript","text":"前言 标准开头，前一段时间因为需要开发一个简单的app,所以接触了一下Apicloud,因为没有native应用的开发知识，所以采用了Apicloud的web应用开发。其中不同页面的传值问题我具体研究一段时间，因为之前一直传值不成功。 正文方法一：api.execScript 这个方法本来的功能是用来不同页面的函数的传递，当然，也可以用来传递值，将这个值作为函数的参数就可以传递到其他页面。具体： index1： //name是该页面函数的参数，作为参数传递到另一个页面 var str=&quot;test(&quot;+name+&quot;)&quot;; api.exeScript({ name:&quot;index2&quot;, script:str}); index2: //index2页面代码 function test(name){ alert(name); } 方法：api.addEventListener&amp;&amp;api.sendEvent这个是利用广播事件传递参数。 index1:发送广播 api.sendEvent({ name:&apos;myEvent&apos;, extra:{key1:&apos;value&apos;,key2:&apos;key2&apos;} }); index2:接受广播 api.addEventListener({ name:&apos;myEvent&apos;}, function(ret){ if(ret&amp;&amp;ret.value){ var value = ret.value; alert(value.key1+&apos;,&apos;+value.key2); } }); 方法三 :api.LocalStorage这个方法很简单，采用了本地数据存储的方法来交换数据。 index1: $api.setStorage(&apos;name&apos;,&apos;value&apos;);//数据存储 index2: $api.getStorage(&apos;name&apos;);//取出name值 另外： $api.rnStorage(&apos;name&apos;);//清除name值 $api.clearStorage(&apos;name&apos;);//清除所有本地数据 方法四 ：api.openWin&amp;api.openFrame&amp;api.openFrameGroup最后最简单的是采用打开窗口时可以顺带传值。 index1: //打开新窗口 api.openWin({ name:index2, url:index2.html, pageParam: { key : value, } }); //打开frame组 api.openFrameGroup({ name: &apos;group1&apos;, rect: { //frame的位置 x: 0, y: 0, w: &apos;auto&apos;, h: &apos;auto&apos; }, frames: [{ //frame组 name: &apos;frame1&apos;, url: &apos;frame1.html&apos;, bgColor: &apos;#fff&apos; }, { name: &apos;frame2&apos;, url: &apos;frame2.html&apos;, bgColor: &apos;#fff&apos; }] }, function(ret, err) { //回调函数 var index = ret.index; }); index2: apiready=function(){ var test=api.pageParam.key; alert(test); }","categories":[{"name":"Apicloud","slug":"Apicloud","permalink":"http://yoursite.com/categories/Apicloud/"}],"tags":[{"name":"Apicloud","slug":"Apicloud","permalink":"http://yoursite.com/tags/Apicloud/"}]},{"title":"开发一个简单的个人博客（1）UI设计","slug":"代码开发一个简单的个人博客（1）UI设计","date":"2018-08-13T08:55:46.000Z","updated":"2018-08-25T00:51:43.963Z","comments":true,"path":"2018/08/13/代码开发一个简单的个人博客（1）UI设计/","link":"","permalink":"http://yoursite.com/2018/08/13/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%881%EF%BC%89UI%E8%AE%BE%E8%AE%A1/","excerpt":"前言本来早该写这个博客，因为前一段时间一直在学习各种框架，为这个开发做准备。所以一直拖到现在才开始这个系列的文章，估计这个系列文章会持续4-5期，来写下我开发这个网站的全过程。我会尽力开发到理想状态，具体效果在月底估计会出来。","text":"前言本来早该写这个博客，因为前一段时间一直在学习各种框架，为这个开发做准备。所以一直拖到现在才开始这个系列的文章，估计这个系列文章会持续4-5期，来写下我开发这个网站的全过程。我会尽力开发到理想状态，具体效果在月底估计会出来。 正文UI设计 在具体开发开发之前，我先概括的设计出来一个几个用户界面，包括主页，文章界面，后台用户界面。具体设计软件时使用Axure。 主页界面 主页是采用了比较简洁通用的设计样式，顶部是采用了稍隐藏式的顶部栏样式，顶部栏左侧是Tags,Home链接；左侧是后台界面的登录按钮。其次整个上部是一个轮播图，右侧是一个作者介绍，包括简书，github等的链接，头像，头像左侧准备设计一个按钮，点击时头像隐藏到右侧。 在底部没有采用过多的装饰，作者权限以及在有条件下可以开发一个浏览人数（图片上未展示）。文章界面文章界面上部是没有做改动，与主页界面一样，唯一不同的是轮播图改为静态图片展示，为了更好的阅读体验。其次在界面左侧引用了百度的分享控件，用来分享。在底部，我准备自己开发一个简单的评论系统，并不打算采用第三方评论系统。方案在后面写出。 后台界面 最后的后台用户界面，具体选项目前只准备了写博客与删除博客，以及使用工具的选项。具体美化可以在后期自我发挥~","categories":[{"name":"博客开发系列","slug":"博客开发系列","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"博客开发","slug":"博客开发","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}]},{"title":"《亮剑》精神-军人的尊严","slug":"《亮剑》精神","date":"2018-07-25T11:12:33.000Z","updated":"2018-08-31T14:40:25.887Z","comments":true,"path":"2018/07/25/《亮剑》精神/","link":"","permalink":"http://yoursite.com/2018/07/25/%E3%80%8A%E4%BA%AE%E5%89%91%E3%80%8B%E7%B2%BE%E7%A5%9E/","excerpt":"近来3天读完了《亮剑》一书。说来奇怪，平时读书无不是强忍困意的煎熬，唯独这本书，里面的情节，人物，仿佛有莫大的吸引力。把我带入那个战火纷飞的年代……","text":"近来3天读完了《亮剑》一书。说来奇怪，平时读书无不是强忍困意的煎熬，唯独这本书，里面的情节，人物，仿佛有莫大的吸引力。把我带入那个战火纷飞的年代……我对李云龙的理解，仅限于电视剧中的那个形象，鲁莽，草率，但却勇敢，敢作敢当，思维已与常人。甚至当我刚读到原著时，我也这么认为，因为电视剧几乎是忠于原文，没有做改动，确是都梁笔下的那个李云龙。 但也是当我读到后来我才发现，电视剧未免有些片面，只塑造了一个能征善战的李云龙，这恐怕不是都梁的本意，也是由于敏感原因，导演无法将都梁笔下的那个李云龙活生生塑造出来。不过在我看来，李云龙这个人物的关键就在于后面的部分，前面的部分塑造了他的英勇，而后面李云龙的改变与他的坚持正是这个人物的灵魂所在。他在成长，却也有他坚持的信条！ 当他岳父谈及党内出现错误之时，他严厉的表示反对，因为他认为他跟及的共产党是不可能犯错误的，错在岳父根深蒂固的资产阶级思想。甚至在他的岳父岳母被拉到农村进行改造之时他仍认为这是他们的错误所对应的惩罚。 他信念的动摇是在赵刚死之后，作为搭档十几年的老战友，他相信赵刚是不会犯这种错误的，但他还是不明白到底是谁的错，他要去打死害死赵刚的人，被田雨制止，从这里他开始了他的思考，到底是谁的错误，使这些原本无罪的人受到非人的待遇。 当时他已是一军之长，管理着一个军的庞大队伍，而这一个军队却被两派所谓的左系革命派骑在头上，当其中一派要求得到他的支持时，他装病躲进来医院，以此来避开，而新来的副军长马天生确实一个极其“聪明”之人，他在李云龙“养病”之时，选着了其中一方支持，而另一方却得到省军区的支持。两派系随之进入了军事级别的斗争，若不是书中描述，我怎么也不会想到两个工人组成的团体可以在一座城市中兵戎相见，动辄就是大炮相见，甚至想要夺取军库，拿取大型榴弹炮，而这种榴弹炮的攻击半径几乎是半个城市。 李云龙不敢抵抗，因为一旦抵抗，毫无疑问，下场和赵刚没有区别。李云龙是个聪明人，他一忍再忍，企图想到一个两全其美的办法，但还没等到他想出来，他的一个师部就被革命派占领，军事机密，武器全落入他人之手，他明白只意味着什么，一旦不加以制止，整个城市都将毁于一旦。 李云龙还是那个李云龙，他亮剑了。就如同他在平安城下的那句“开炮！”。他开始下达了命令。这命令也代表这李云龙的灭亡，一颗流星的陨落，一个时代的结束。 最终，李云龙在他家里的阁楼上用那把楚云飞送他的勃朗宁手枪结束了自己的一生。 赵刚在临终的信中写着死亡也是一种反抗，他是对自己信条的坚持，所不同的是，李云龙坚持的是他的军人尊严！宁死不屈的精神！ 原文中对李云龙自杀前用了大量的文笔，无非是为了诠释，李云龙一生戎马，可倾尽一生，也无法想出，到底是谁的错，毛主席不会错，共产党不会错，那可能就是他李云龙的错误吧。","categories":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"感情","slug":"感情","permalink":"http://yoursite.com/tags/%E6%84%9F%E6%83%85/"}]},{"title":"在ESC服务器上搭建静态网站","slug":"ecsAndWebsite","date":"2018-07-22T14:14:41.000Z","updated":"2018-07-25T14:12:41.473Z","comments":true,"path":"2018/07/22/ecsAndWebsite/","link":"","permalink":"http://yoursite.com/2018/07/22/ecsAndWebsite/","excerpt":"开始前面在连接上服务器后，紧接着我想测试一下服务器的网站搭建，下面就把简单的教程贴出来。 1.首先要要在服务器管理页面对服务器进行配置（我最开始就是忘了配置服务器的端口，结果怎么都不对!!!）由于我们HTTP的对应端口是80，所以我们在安全组规则中添加对80端口的开放。","text":"开始前面在连接上服务器后，紧接着我想测试一下服务器的网站搭建，下面就把简单的教程贴出来。 1.首先要要在服务器管理页面对服务器进行配置（我最开始就是忘了配置服务器的端口，结果怎么都不对!!!）由于我们HTTP的对应端口是80，所以我们在安全组规则中添加对80端口的开放。 添加好之后: 2.我的windows服务器中是没有自带IIS的，所以先从IIS的安装开始，点击左下角的服务器管理图标进入服务器管理页面。 3.在服务器管理中点击角色并点击右面的添加角色。 4.进入添加角色向导。 5.钩选Web服务器(IIS),点击安装。 6.点击安装后会弹出是否添加，点击“添加必需的功能”。 7.然后会弹出角色服务，由于我们搭建的静态网页，所以勾选常见的HTTTP功能，如果需要构建动态网站，可够相爱U呢引用程序开发下的相应功能。 8.然后等待角色安装完成。 9.然后就可以输入服务器的公网IP查看是否成功安装IIS服务。看到上面这张图就代表安装成功了。 10.添加应用池。 11.添加站点，注意，IP地址要选择全部未分配 *12.最后是默认文档的修改，服务器中默认的主页是default.htm,你可以把它改成你的主页名。 13.在浏览器输入你的ip地址。查看你的网页。 结尾至此，一个静态网站就搭建好了。其中容易发生错误的点主要有： 安全规则没有配置或者没有配置正确。 创建新站点的IP地址要选择全部未分配。 借鉴资料： 部分图片取自csdn博主bestself_iot的文章IIS 静态页面网站搭建","categories":[{"name":"website","slug":"website","permalink":"http://yoursite.com/categories/website/"}],"tags":[{"name":"esc","slug":"esc","permalink":"http://yoursite.com/tags/esc/"},{"name":"website","slug":"website","permalink":"http://yoursite.com/tags/website/"}]},{"title":"xhellAnEcsd","slug":"xhellandcsd","date":"2018-07-22T03:51:30.000Z","updated":"2018-07-25T14:14:05.082Z","comments":true,"path":"2018/07/22/xhellandcsd/","link":"","permalink":"http://yoursite.com/2018/07/22/xhellandcsd/","excerpt":"关于ecs服务器的连接问题最近看阿里云有一个学生优惠，就申请了一个优惠的ecs服务器，一个月9.9,2G内存，40G云盘，血赚不亏。","text":"关于ecs服务器的连接问题最近看阿里云有一个学生优惠，就申请了一个优惠的ecs服务器，一个月9.9,2G内存，40G云盘，血赚不亏。然后我就开始配置服务器，发现这个廉价的服务器是没办法更换操作系统的，自带的是一个Windows Server 2008 32位。然后我就开始准备连接服务器。阿里云自带有连接服务，但每天都要登陆网页会很麻烦。 然后我就下载了xshell，但一直连接不上，查看服务器端口配置，发现ssh端口22是打开的。后来我在网上查了很多资料，发现还是连接不上。最后我才意识到可能是操作系统的问题。果然我查询了sxhell支持的操作系统。得到如下结果： xshell等软件仅支持Linux，UNIX，centos等。 对于windows系统，需要用RDCMan或者windows自带的远程桌面连接。","categories":[{"name":"ecs","slug":"ecs","permalink":"http://yoursite.com/categories/ecs/"}],"tags":[{"name":"ecs","slug":"ecs","permalink":"http://yoursite.com/tags/ecs/"},{"name":"xshell","slug":"xshell","permalink":"http://yoursite.com/tags/xshell/"}]},{"title":"第一篇博客啊","slug":"blog","date":"2018-07-19T16:36:22.000Z","updated":"2018-07-20T03:25:25.931Z","comments":true,"path":"2018/07/20/blog/","link":"","permalink":"http://yoursite.com/2018/07/20/blog/","excerpt":"","text":"这是我的第一篇博客啊！折腾了3天了，不过算起来也只是几个小时，还没弄好，心态有点爆炸啊，js也几天没有学了。这是百度的链接emmmm,暂时就这样！123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;fuck you&quot;); return 0;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"}]}]}