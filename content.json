{"meta":{"title":"My Wonderland","subtitle":"This is it!","description":"Something is going happen if you try to fight for it!","author":"Michael Wang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2018-07-19T16:20:13.000Z","updated":"2018-07-20T16:11:53.116Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"简介Michael Wang 目前在学习前端知识，一只想变成大佬的菜鸡。赏一首诗盖说夫妻之缘，伉俪情深，恩深义重。论谈共被之因，幽怀合卺之欢。 凡为夫妻之因，前世三生结缘，始配今生夫妇。夫妻相对，恰似鸳鸯，双飞并膝，花颜共坐；两德之美，恩爱极重，二体一心。 三载结缘，则夫妇相和；三年有怨，则来仇隙。若结缘不合，想是前世怨家。反目生怨，故来相对。妻则一言数口，夫则反目生嫌。似猫鼠相憎，如狼羊一处。 既以二心不同，难归一意，快会及诸亲，以求一别，物色书之，各还本道。愿妻娘子相离之后，重梳蝉鬓，美扫娥眉，巧逞窈窕之姿，选聘高官之主，弄影庭前，美效琴瑟合韵之态。 解怨释结，更莫相憎；一别两宽，各生欢喜。三年衣粮，便献柔仪。伏愿娘子千秋万岁。 听一首歌"},{"title":"目录","date":"2018-07-19T16:19:34.000Z","updated":"2018-07-19T16:23:27.276Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-19T16:19:53.000Z","updated":"2018-07-19T16:22:20.068Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript中的模块导入导出","slug":"JavaScript中的模块导入导出","date":"2021-02-14T10:47:09.000Z","updated":"2021-02-16T07:01:37.699Z","comments":true,"path":"2021/02/14/JavaScript中的模块导入导出/","link":"","permalink":"http://yoursite.com/2021/02/14/JavaScript中的模块导入导出/","excerpt":"","text":"模块的概念 （Modular design） 所谓的模块化设计，简单地说就是将产品的某些要素组合在一起，构成一个具有特定功能的子系统，将这个子系统作为通用性的模块与其他产品要素进行多种组合，构成新的系统，产生多种不同功能或相同功能、不同性能的系列产品。 这是在整个设计行业对模块化的定义。对于编程语言中的模块化设计，其基本思路就是将有相同功能的部分代码封装在一起，形成一个通用的，可复用的模块，使之在其它系统中可以重复利用，并不会对模块内部产生影响。所以设计模式中模块化设计的三大特征也要遵循： 相对独立性 互换性 通用性 换做在编程语言中，相对独立性即要使私有成员无法被外部访问并暴露给外部指定的方法。通用性在程序设计中多被称为可复用性，而模块设计的原则和目的也是可复用性。模块可以减少我们对重复代码的编写，提高开发的效率。 JavaScript对模块的需求最初JavaScript是作为网页开发的脚本而开发，Brendan Eich 可能也不会想到当初十几天开发出的一个脚本语言如今会焕发如此的生命力，也正是因为开发周期如此之短，使之缺点在当今工程化的JavaScript中被极大的放大。其中一个就是模块的概念，JavaScript原生并没有模块的概念，就如同没有原生的类一样（尽管ES6推出了所谓的类）。为此，开发者想出了很多方法从语言层面来模拟模块化。 初期的模块化在各类框架，插件没有流行，JavaScript仅作为一门脚本语言的时候，开发人员想出了一些方法来对项目中一些方法集合进行封装，形成类似于模块的模式。 原生写法描述模块就是实现特定功能的一组方法。 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 例子1234567function m1()&#123; //...&#125;function m2()&#123; //...&#125; 缺点 “污染”了全局变量，无法保证不与其他模块发生变量名冲突 模块成员之间看不出直接关系。 对象写法描述为了解决上面的“全局变量污染的问题”，又利用了对象这一数据类型，使一个模块成为一个对象，模块的成员作为对象的成员变量。 例子12345678910111213var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 缺点 私有变量被直接暴露给外部，如上面的_count应该是一个保留的私有变量，但是在外部我们也是可以访问到的。 立即执行函数（IIFE）写法描述又为了解决无法保有私有成员的问题（其本质是JavaScript没有局部作用域的问题，具体看这里），这里利用了立即执行函数形成一个闭包的同时也形成了一个局部作用域，这个作用域内的变量在外部是无法访问到的。这样就解决了上面的私有便变量的问题。 例子123456789101112131415161718var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); 这里module1形成了一个闭包，返回一个对象，我们只能访问到对象暴露的m1和m2方法，内部的_count是无法被访问到了。 优点 提高性能：通过 IIFE 的参数传递常用全局对象 window、document，在作用域内引用这些全局对象。JavaScript 解释器首先在作用域内查找属性，然后一直沿着链向上查找，直到全局范围，因此将全局对象放在 IIFE 作用域内可以提升js解释器的查找速度和性能； 压缩空间：通过参数传递全局对象，压缩时可以将这些全局对象匿名为一个更加精简的变量名； 缺点 不能很好的管理依赖，缺少一个依赖管理者。比如依赖的调用顺序，在没有管理者时，我们必须自己确定调用顺序，比如： 我们要调用module1的mock方法， 而module1又依赖module2 module2又依赖module3 module4又依赖module3 我们则必须按这个顺序加载脚本文件 12345678&lt;script src='./module4'&gt;&lt;/script&gt;&lt;script src='./module3'&gt;&lt;/script&gt;&lt;script src='./module2'&gt;&lt;/script&gt;&lt;script src='./module1'&gt;&lt;/script&gt;&lt;script&gt; module1.mock()&lt;/script&gt; 立即执行函数（IIFE）的衍生写法放大模式描述如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。 例子123456789var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1); 上面的代码为module添加了一个m3属性。并将新的模块实体返回。 宽放大模式描述对于上面的放大模式，存在一定的问题。由于在浏览器中，所有的资源都是异步加载的，所以上面的参数可能不存在，所以我们必须要考虑这种情况，增强代码的健壮性。 例子1234567var module1 = ( function (mod)&#123; //... return mod;&#125;)(window.module1 || &#123;&#125;); 上面的代码相当于是给函数参数设置了一个默认参数为{}，当window.module1不存在的时候，在对{}空对象进行操作。 现代模块设计恩格斯说：“社会一旦有技术上的需要，则这种需要会比十所大学更能把科学院推向前进。”随着进入大前端时代，网站的规模越来越大，逻辑层面越来越复杂。模块化的管理成为必然，很多模块管理框架应运而生。具有代表性的有： Node.js中CommonJS 基于 AMD 的 RequireJS 基于 CMD 的 SeaJS ECMAScript规定的ES Module CommonJS描述CommonJS 是Node.js中采用的一种规范，其基本原则有： 由于Node是在服务端运行，所以CommonJS的模块加载是同步进行的，所以其在浏览器中并不适用，因为浏览器中的文件都是通过网络加载的，并不适合同步加载。 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 每个模块内部有一个全局变量module，这个变量是一个对象，它的exports属性（即module.export）用于导出模块。 每个模块内部有一个全局变量require，其是一个函数，用于导入模块，参数即模块的地址。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 例子导出12345678910111213141516//module1.jslet _temp = -1let pi = 3.1415926let exchange = function(a, b)&#123; _temp = a a = b b = _temp return [a,b]&#125;module.export.pi = pimodule.export.exchange = exchange//或者这么写module.export.sum = function(a, b)&#123; return a + b&#125; 导入1234let module1 = require('./module1.js')console.log(module1.exchange(1, 2)) //[2, 1]console.log(module1.pi) //3.1415926 详细介绍module对象Node内部提供一个Module构建函数。所有的模块都是Module的实例。 查看Node源码： 123456function Module(id, parent)&#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; //...&#125; 可以发现其是一个构造器函数，其中设置了以下属性： module.id：模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回一个对象，表示调用该模块的父级块。 module.children 返回一个数组，表示该模块要用到的其他子级模块。 module.exports 表示模块对外输出的值。 实际上我们模块导入的过程就是为对应模块的module.exports对象增加成员的过程。 注意：只能为其增加成员变量，不能直接将module.exports赋予某一个值。 目录加载规则通常一个项目都有一个入口文件（或函数），比如C语言，Java中的main函数。在Node项目中，一般也会指定一个入口文件，让require方法可以通过这个入口文件，加载整个项目。 一般这个入口放在packge.json文件，并将入口文件写入main字段。如： 12345//packge.json&#123; \"name\": \"new_project\", \"main\": \"./main/index.js\"&#125; require发现参数字符串指向一个目录以后，会自动查看该目录的packge.json文件，然后加载main字段指定的入口文件。如果packge.json文件没有main字段，或者没有packge.json文件，则会加载该目录下的index.js文件或者index.node文件。 模块缓存Node会在第一次加载模块后，缓冲该模块（实际上是缓存该模块的module.exports属性）。如： 123require('./moudle1.js')require('./moudle1.js').num = 1require('./moudle1.js').num //1 上面三次导入一个模块，但是我们添加的成员变量在第三次缓冲时仍然可以访问到，证明其是被缓冲在内存中的。 我们可以通过删除require.cache的对应属性来删除模块缓冲。 删除模块缓冲12345678//删除指定模块delete require.cache[moduleName]Reflect.deleteProperty(require.cache, moduleName)// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) 模块的加载机制CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。 下面是一个模块文件lib.js。 123456789// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。 然后，加载上面的模块。 1234567// main.jsvar counter = require('./lib').counter;var incCounter = require('./lib').incCounter;console.log(counter); // 3incCounter();console.log(counter); // 3 上面代码说明，counter 输出以后，lib.js 模块内部的变化就影响不到 counter 了。 AMD描述AMD 全称为 Asynchromous Module Definition（异步模块定义）。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，它是一个在浏览器端模块化开发的规范。 AMD 模式可以用于浏览器环境并且允许异步加载模块，同时又能保证正确的顺序，也可以按需动态加载模块。 特点 AMD是依赖前置，即提前声明需要的依赖。 对依赖的加载是提前进行的，在运行前就加载所有的依赖。 用法模块通过 define 函数定义在闭包中，格式如下： 1define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]： 1define(function(require, exports, module) &#123;&#125;） factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 例子(require.js)定义模块12345678910111213141516171819define(['jquery'], function($)P&#123; var num = 555 var _version = 0.01 var showMessage = function(message)&#123; if(!message)&#123; return &#125;else&#123; $('#messageBox').html('欢迎访问' + name) &#125; &#125; return&#123; 'num':num, 'showMessage': showMessage &#125;&#125;)//_version为内部维护变量，无法被外部访问到 引入模块1234567891011121314// 配置文件require.config(&#123; baseUrl: 'js', paths: &#123; jquery: 'lib/jquery-1.11.1', &#125;&#125;);// 加载模块require(['jquery', 'script/hello'],function ($, hello) &#123; $(\"#btn\").click(function()&#123; hello.showMessage(\"test\"); &#125;);&#125;); CMD描述CMD（Common Module Definition） 是 SeaJS 在推广过程中对模块定义的规范化产出。CMD 规范的前身是 Modules/Wrappings 规范。 特点 CMD推崇依赖就近，即在依赖使用时才引入。 CMD是延迟执行的，即使用的时候才延迟执行的。 用法（SeaJS）1、seajs.config({…}); //用来对 Sea.js 进行配置。2、seajs.use([‘a’,’b’],function(a,b){…}); //用来在页面中加载一个或多个模块。3、define(function(require, exports, module){…}); //用来定义模块。Sea.js 推崇一个模块一个文件，遵循统一的写法：4、require(function(require){var a = require(“xModule”); … }); //require 用来获取指定模块的接口。5、require.async, //用来在模块内部异步加载一个或多个模块。 例如： 123456define(function(require)&#123; require.async(['aModule','bModule'],function(a,b)&#123; // 异步加载多个模块，在加载完成时，执行回调 a.func(); b.func(); &#125;) &#125;); 6、exports, //用来在模块内部对外提供接口。 例如： 123456define(function(require, exports)&#123; exports.varName01 = 'varValue'; // 对外提供 varName01 属性 exports.funName01 = function(p1,p2)&#123; // 对外提供 funName01 方法 .... &#125; &#125;); 7、module.exports, 与 exports 类似，用来在模块内部对外提供接口。例如： 123456define(function(require, exports, module) &#123; module.exports = &#123; // 对外提供接口 name: 'a', doSomething: function() &#123;...&#125;; &#125;;&#125;); 例子定义模块123456789101112131415161718192021222324252627// seajs 的简单配置seajs.config(&#123; base: \"../sea-modules/\", alias: &#123; \"jquery\": \"jquery/jquery/1.10.1/jquery.js\" &#125;&#125;);// 所有模块都通过 define 来定义define(function(require, exports, module) &#123; // 通过 require 引入依赖 var $ = require('jquery'); var Spinning = require('./spinning'); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ... //或者使用return向外提供接口 return &#123; someVal: someVal, doSomething: doSomething &#125;&#125;); 如果retunr语句是模块的唯一代码，还可以简化为： 1234define(&#123; someVal: someVal, doSomething: function() &#123;&#125;&#125;); 引入模块1234567891011121314151617181920212223//单一模式seajs.use('./a') //回调模式seajs.use('./a', function(a) &#123; a.run()&#125;); //多模块模式seajs.use(['./a', './b'], function(a, b) &#123; a.run() b.run()&#125;)//在一个模块中引入其他模块define(function(require, exports, module) &#123; //同步引入其他模块 var module1 = require('./module1') //异步引入其他模块 var module2 = require.async('./module2')&#125;) 注意： 对 module.exports 的赋值需要同步执行，不能放在回调函数里。 在html中 ，为script标签添加data-main = true确定其为主入口。data-main通常用在只有一个入口的情况，use可以用在多个入口的情况 UMD描述UMD（Universal Module Definition），AMD模块以浏览器第一的原则发展，异步加载模块。CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。 特点 兼容 AMD 和 CommonJS 规范的同时，还兼容全局引用的方式 例子1234567891011121314151617(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; //AMD define(['jquery'], factory); &#125; else if (typeof exports === 'object') &#123; //Node, CommonJS之类的 module.exports = factory(require('jquery')); &#125; else &#123; //浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery); &#125;&#125;(this, function ($) &#123; //方法 function myFunc()&#123;&#125;; //暴露公共方法 return myFunc;&#125;)); ES Module描述在 ES Module 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES Module 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES Module 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 CommonJS 和 AMD 模块，其本质是在运行时生成一个对象进行导出，称为“运行时加载”，没法进行“编译优化”，而 ES Module 不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。这称为“编译时加载”或者静态加载，即 ES Module 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES Module 模块本身，因为它不是对象。 由于 ES Module 是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ESz Module 还有以下好处： 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES Module 格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。 不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。 特点 静态编译 输出的值引用，而非值拷贝 import 只能写在顶层，因为是静态语法 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。（具体严格模式内容不再赘述） 例子导出模块123456789101112131415161718192021222324252627282930//module1.jslet pi = 3.1415926let d = 'default'let sum = function(a, b)&#123; return a + b&#125;let bactch1 = 1let bactch2 = 2let bactch3 = 3//导出已定义的变量export piexport sum//直接导出声明的变量export const e = 2.718281828459export function multiply(x, y) &#123; return x * y;&#125;;//批量导出export &#123;bactch1, bactch2, bactch3&#125;//导出默认export default d//对导出变量重命名,并且重命名为default，与上面的说法一致export &#123;d as default&#125; 注意： export default 命令用于指定模块的默认输出。export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字 export default只能导出变量，不能在后面声明变量。如： 12//错误export default const pi = 3.1415926 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 如： 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 面代码输出变量foo，值为bar，500 毫秒之后变成baz。 导入模块1234567891011//直接导入模块所有成员import * from 'module1'//批量导入模块import &#123;pi, e, sum&#125; from 'module1'//直接执行所加载的模块import 'lodash';//在一条import语句中，同时输入默认方法和其他接口import _, &#123; each, forEach &#125; from 'lodash'; 注意 export后无法直接接变量内容。如： 12//错误export 3 import()import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以import和export命令只能在模块的顶层，不能在代码块之中。如，下面的代码会报错 1234// 报错if (x === 2) &#123; import MyModual from './myModual';&#125; 但是有时候我们需要按需引入又该怎么办，ES2020提案 引入import()函数，支持动态加载模块。 import(specifier) 特点 import函数的参数specifier，指定所要加载的模块的位置。 import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import()返回一个 Promise 对象。模块作为Promise的参数返回下面是一个例子。 123456789const main = document.querySelector('main');import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 兼容性 总结目前JavaScript的模块规范就是上面谈到的四种，CommonJS、AMD、CMD、ES Module。 CommonJS 用在服务器端，AMD 和CMD 用在浏览器环境，ES Module 是作为终极通用解决方案，时下热议的vite即利用了ES Module。 比较AMD 和 CMD 的区别 执行时机： AMD 是提前执行，CMD 是延迟执行。 对依赖的处理：AMD 推崇依赖前置，CMD 推崇依赖就近。 API 设计理念：AMD 的 API 默认是一个当多个用，非常灵活，CMD 的 API 严格区分，推崇职责单一。 遵循的规范：RequireJS 遵循的是 Modules/AMD 规范，SeaJS 遵循的是 Mdoules/Wrappings 规范的 define 形式。 设计理念：SeaJS 设计理念是 focus on web, 努力成为浏览器端的模块加载器，RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。 CommonJS 和 ES Module 的区别 加载时机：CommonJS 是运行时加载（动态加载），ES Module 是编译时加载（静态加载） 加载模块：CommonJS 模块就是对象，加载的是该对象，ES Module 模块不是对象，加载的不是对象，是接口 加载结果：CommonJS 加载的是整个模块，即将所有的接口全部加载进来，ES Module 可以单独加载其中的某个接口（方法） 输出：CommonJS 输出值的拷贝，ES Module 输出值的引用 this: CommonJS 指向当前模块，ES Module 指向 undefined 参考 JavaScript 模块化总结 Module 的语法-阮一峰 import-MDN Javascript模块化编程（一）：模块的写法-阮一峰","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"AMD","slug":"AMD","permalink":"http://yoursite.com/tags/AMD/"},{"name":"CMD","slug":"CMD","permalink":"http://yoursite.com/tags/CMD/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://yoursite.com/tags/CommonJS/"},{"name":"ES Module","slug":"ES-Module","permalink":"http://yoursite.com/tags/ES-Module/"}]},{"title":"Fetch方法的使用","slug":"Fetch方法的使用","date":"2021-02-13T06:16:24.000Z","updated":"2021-02-17T05:21:09.103Z","comments":true,"path":"2021/02/13/Fetch方法的使用/","link":"","permalink":"http://yoursite.com/2021/02/13/Fetch方法的使用/","excerpt":"","text":"介绍Fetch是基于Promise开发的用于访问和操纵 HTTP 管道的一个API。其提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。 以前浏览器中的网络请求只能通过XMLHttpRequest实现（虽然大多使用的是封装过后的接口）。而Fetch则结合Promise提供了一种更加简化的发送网络请求的方式（其调用方法与axiso相似）。 用法Fetch()方法Fetch接受两个参数： Promise&lt;Response&gt; fetch(input[, init]); ?input 定义要获取的资源。这可能是：一个 USVString字符串，包含要获取资源的 URL。一些浏览器会接受 blob: 和 data: 作为 schemes.一个 Request对象。 init 可选 一个配置项对象，包括所有对请求的设置。可选的参数有： method: 请求使用的方法，如 GET、POST。 headers: 请求的头信息，形式为 Headers值的对象字面量。 body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。 mode: 请求的模式，如 cors、 no-cors 或者 same-origin。 credentials: 请求的 credentials，如 omit、same-origin 或者include。为了在当前域名内自动发送 cookie ， 必须提供这个选项， 从 Chrome 50 开始， 这个属性也可以接受 FederatedCredential 实例或是一个 PasswordCredential 实例。 cache: 请求的 cache 模式: default、 no-store、 reload 、 no-cache、 force-cache或者 only-if-cached 。redirect: 可用的 redirect 模式: follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误）, 或者 manual (手动处理重定向). 在Chrome中默认使用follow（Chrome 47之前的默认值是manual）。 referrer: 一个 [USVString](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString) 可以是no-referrer、client或一个 URL。默认是client。` referrerPolicy: 指定了HTTP头部referer字段的值。可能为以下值之一： no-referrer、no-referrer-when-downgrade、origin、origin-when-cross-origin、unsafe-url 。 integrity: 包括请求的 subresource integrity 值 （ 例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。 返回值一个 Promise对象。 例子发送带凭据的请求注意：Fetch默认是不携带凭据的请求（即使是跨域源），要将credentials: &#39;include&#39;添加到传递给 fetch()方法的init对象，才能使请求携带凭证。 123fetch('https://example.com', &#123; credentials: 'include'&#125;) 如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加 credentials: &#39;same-origin&#39;。 12345// The calling script is on the origin 'https://example.com'fetch('https://example.com', &#123; credentials: 'same-origin'&#125;) 上传 JSON 数据使用 fetch() POST JSON数据 123456789101112var url = 'https://example.com/profile';var data = &#123;username: 'example'&#125;;fetch(url, &#123; method: 'POST', // or 'PUT' body: JSON.stringify(data), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; 'Content-Type': 'application/json' &#125;)&#125;).then(res =&gt; res.json()).catch(error =&gt; console.error('Error:', error)).then(response =&gt; console.log('Success:', response)); 上传文件可以通过 HTML &lt;input type=&quot;file&quot; /&gt; 元素，FormData()和 fetch()上传文件。 123456789101112var formData = new FormData();var fileField = document.querySelector(\"input[type='file']\");formData.append('username', 'abc123');formData.append('avatar', fileField.files[0]);fetch('https://example.com/profile/avatar', &#123; method: 'PUT', body: formData&#125;).then(response =&gt; response.json()).catch(error =&gt; console.error('Error:', error)) 上传多个文件可以通过HTML &lt;input type=&quot;file&quot; mutiple/&gt; 元素，FormData()和 fetch()上传多个文件。 12345678910111213141516var formData = new FormData();var photos = document.querySelector(\"input[type='file'][multiple]\");formData.append('title', 'My Vegas Vacation');// formData 只接受文件、Blob 或字符串，不能直接传递数组，所以必须循环嵌入for (let i = 0; i &lt; photos.files.length; i++) &#123; formData.append('photo', photos.files[i]);&#125;fetch('https://example.com/posts', &#123; method: 'POST', body: formData&#125;).then(response =&gt; response.json()).then(response =&gt; console.log('Success:', JSON.stringify(response))).catch(error =&gt; console.error('Error:', error)); 自定义请求对象除了传给 fetch() 一个资源的地址，你还可以通过使用 Request()构造函数来创建一个 request 对象，然后再作为参数传给 fetch()： 123456789101112131415var myHeaders = new Headers();var myInit = &#123; method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' &#125;;var myRequest = new Request('flowers.jpg', myInit);fetch(myRequest).then(function(response) &#123; return response.blob();&#125;).then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL;&#125;); Request() 和 fetch() 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝： 1var anotherRequest = new Request(myRequest,myInit); Request对象Request构造器可以构造一个Request对象，其作为Fetch方法的参数。 该构造器接受的参数与Fetch一致： 请求地址 init对象 此处不再赘述。 此外，我们可直接通过const method = Request.method的方式来获取init属性。如： 12345const myRequest = new Request('http://localhost/flowers.jpg');const myURL = myRequest.url; // http://localhost/flowers.jpgconst myMethod = myRequest.method; // GETconst myCred = myRequest.credentials; // omit 方法Request对象有以下方法可以调用： Request.clone() 创建当前request的副本。 Request实现 Body`， 因此它也有以下方法可用: Body.arrayBuffer() 返回解决一个ArrayBuffer表示的请求主体的promise. Body.blob() 返回解决一个Blob表示的请求主体的promise. Body.formData() 返回解决一个FormData表示的请求主体的promise. Body.json() 返回解决一个JSON表示的请求主体的promise. Body.text() 返回解决一个USVString(文本)表示的请求主体的promise. 注意：这些Body功能只能运行一次; 随后的调用将通过空strings/ ArrayBuffers解析. header对象使用 Headers的接口，你可以通过 Headers()构造函数来创建一个你自己的 headers 对象。一个 headers 对象是一个简单的多名值对： 12345let content = \"Hello World\";let myHeaders = new Headers();myHeaders.append(\"Content-Type\", \"text/plain\");myHeaders.append(\"Content-Length\", content.length.toString());myHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\"); 也可以直接接受一个字面量对象来构造header对象 12345myHeaders = new Headers(&#123; \"Content-Type\": \"text/plain\", \"Content-Length\": content.length.toString(), \"X-Custom-Header\": \"ProcessThisImmediately\",&#125;); 方法 Headers.append() 给现有的header添加一个值, 或者添加一个未存在的header并赋值. Headers.delete() 从Headers对象中删除指定header. Headers.entries() 以 迭代器 的形式返回Headers对象中所有的键值对. Headers.get() 以 ByteString 的形式从Headers对象中返回指定header的全部值. Headers.has() 以布尔值的形式从Headers对象中返回是否存在指定的header. Headers.keys() 以迭代器的形式返回Headers对象中所有存在的header名. Headers.set() 替换现有的header的值, 或者添加一个未存在的header并赋值. Headers.values() 以迭代器的形式返回Headers对象中所有存在的header的值. 注意 在header已存在或者有多个值的状态下Headers.set()和 Headers.append()的使用有如下区别, Headers.set()将会用新的值覆盖已存在的值, 但是Headers.append()会将新的值添加到已存在的值的队列末尾. 如果您尝试传入名称不是有效的HTTP头名称的引用，则所有Headers方法都将引发 TypeError 。 如果头部有一个不变的Guard，则变异操作将会抛出一个 TypeError 。 在其他任何失败的情况下，他们默默地失败。 出于安全考虑，某些头只能由用户代理控制。这些头信息包括 forbidden header names 和 forbidden response header names。 一个Headers对象也有一个关联的guard，它具有不可变的值，request，request-no-cors，response或none。 这会影响 set()，delete(), 和append()`方法 改变header. Guard属性描述Guard 是 Headers对象的特性，基于不同的情况，它可以有以下取值：immutable、request、request-no-cors、response 或 none。 由于 Headers 可以在 request 请求中被发送或者在 response 请求中被接收，并且规定了哪些参数是可写的，Headers 对象中的 guard 属性。这个属性没有暴露给 Web，但是它影响到哪些内容可以在 Headers 对象中被操作。 规则当使用 Headers()constructor创建一个新的 Headers对象的时候，它的 guard 被设置成 none（默认值）。当创建 Request或 Response对象的时候，它将拥有一个按照以下规则实现的与之关联的 Headers`对象： 新对象的类型 创建时的构造函数 关联的 Headers对象的 guard Request Request() request Request Request()，mode 设置成 no-cors request-no-cors Response Response() response Response immutable immutable guard属性值的特征： none：默认的 request：从 request 中获得的 headers（Request.headers）只读 request-no-cors：从不同域（Request.mode no-cors）的 request 中获得的 headers 只读 response：从 response 中获得的 headers（Response.headers）只读 immutable：在 ServiceWorkers 中最常用的，所有的 headers 都只读。 Response 对象描述如上所述，Response实例是在 fetch() 处理完 promise 之后返回的。其呈现了对一次请求的响应数据。 我们可以通过一个构造函数来创建一个Response对象，但更多的是通过一个Fetch请求返回的Response对象。 属性 Response.headers只读 包含此 Response 所关联的 Headers对象。 Response.ok只读 包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。 Response.redirected只读 表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。 Response.status只读 包含 Response 的状态码 （例如 200 表示成功）。 Response.statusText只读 包含了与该 Response 状态码一致的状态信息（例如，OK对应 200）。 Response.type 只读 包含 Response 的类型（例如，basic、cors）。 Response.url只读 包含 Response 的URL。 Response.useFinalURL 包含了一个布尔值，来标示这是否是该 Response 的最终 URL。 Response 实现了 Body接口，所以以下属性亦可用： Body.body 只读 一个简单的 getter，用于暴露一个 ReadableStream类型的 body 内容。 Body.bodyUsed只读 包含了一个布尔值来标示该 Response 是否读取过 Body。 方法 Response.clone() 创建一个 Response 对象的克隆。 Response.error() 返回一个绑定了网络错误的新的 Response 对象。 Response.redirect() 用另一个 URL 创建一个新的 Response。 Response 实现了 Body接口，所以以下方法同样可用： Body.arrayBuffer() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 ArrayBuffer格式的 Promise 对象。 Body.blob() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 Blob 格式的 Promise 对象。 Body.formData() 读取Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 FormData 格式的 Promise 对象。 Body.json() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 JSON 格式的 Promise 对象。 Body.text() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 USVString 格式的 Promise 对象。 body对象Body代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。 一般我们也是从一个请求中得到一个body对象。当然，直接通过body构造器来创建一个body也是被允许的。 属性 Body.body 只读一个简单的getter用于暴露一个ReadableStream类型的主体内容。 Body.bodyUsed 只读一个Boolean 值指示是否body已经被标记读取。 方法 Body.arrayBuffer() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是ArrayBuffer。此操作会将bodyUsed状态改为已使用（true）。 Body.blob() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是Blob。此操作会将bodyUsed状态改为已使用（true）。 Body.formData() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是FormData表单。此操作会将bodyUsed状态改为已使用（true）。 Body.json() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是使用JSON解析body文本的结果。此操作会将bodyUsed状态改为已使用（true）。 Body.text() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是USVString（文本）。此操作会将bodyUsed状态改为已使用（true）。 比起XHR来，这些方法让非文本化的数据使用起来更加简单。 兼容性 可以看到Fetch的兼容性还是有一定的问题，Chrome42版本才开始支持从与Firefox从39版本才支持，而IE到目前位置都不支持。这是一个很大的问题。如果要在生产环境中使用，必须引入很多pollyfill，相较于使用Promise封装的XHR，这样看来优势又荡然无存，随着版本的迭代，未来肯定是Fetch的，但不是现在。 参考 使用 Fetch-MDN","categories":[{"name":"Fetch","slug":"Fetch","permalink":"http://yoursite.com/categories/Fetch/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Fetch","slug":"Fetch","permalink":"http://yoursite.com/tags/Fetch/"}]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2021-02-09T14:42:56.000Z","updated":"2021-02-09T14:42:56.794Z","comments":true,"path":"2021/02/09/浏览器缓存/","link":"","permalink":"http://yoursite.com/2021/02/09/浏览器缓存/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19ZA9Z0WgbzjI7C5/Gfj5P43JAHpmHJj+s= var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"不知道密码就别猜了，这是我得小秘密，哈哈哈\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[],"tags":[]},{"title":"about跨域","slug":"about跨域","date":"2021-02-09T14:29:31.000Z","updated":"2021-02-13T03:40:06.188Z","comments":true,"path":"2021/02/09/about跨域/","link":"","permalink":"http://yoursite.com/2021/02/09/about跨域/","excerpt":"","text":"域的概念域（Domain）作为计算机网络中一个重要的概念，其阐述的是：网络中一组计算机的逻辑集合，是活动目录中的核心单元、是活动目录的分区。其有以下特点： 域定义了安全边界，每个域均有各自的安全策略以及与其它域的信任关系，在没有授权的情况下，不允许其他域中的用户访问本域中的资源。 中可以存储上百万个对象，不同的域之间具有层次关系，可以建立域树或域林，以便于域的扩展。域树通常由一个或多个共享连续的名称空间的域组合而成，其中第一个域称作根域，其他域称为子域，如图。 域林通常由一个或多个域树组成，如图10-15所示。其中，各个域树并不共享相同的名称空间，但域林内所有域树的域都具有相同的架构、配置信息、全局目录（Global Catalog）等。 所以浏览器根据域的概念，规定了同源策略（Sameoriginpolicy），其是浏览器最重要的安全策略之一。其保证了每个网页的安全性。确保非同源站点无法相互访问资源，JavaScript交互等。具体到浏览器中，同源是指具有相同的： 协议 域名 子域 端口 这其中任何一项不同，皆被视为非同源。会受到同源策略的限制。具体的url的格式： 注意：上面的url仅写到了影响跨域的4部分，其中还有： 虚拟目录部分 文件名部分 锚点部分 参数部分 完整的目录结构如下： 在浏览器中，同源策略限制的对象有： Cookie、sessionStorage、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求 但是下面的3个请求是允许跨域请求资源的： &lt;img src=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 客户端和服务端通信jsonp原理jsonp（JSON with Padding）本身是一种hack的方法来实现跨域，其利用的原理有两个： script没有同源策略的限制。 script标签请求的数据会直接执行。这一点就排除了img和link两个标签。 具体原理是：利用script的src属性，发送带有callback回调函数的GET请求，服务端在接受数据后，将要发送的数据作为函数的参数传回client，由于script会立即执行，则可以直接拿到数据。 优缺点优点兼容性强，支持IE10以下浏览器跨域问题（CORS不支持） 缺点 仅支持GET方法（由script标签的请求性质决定） 安全性不高，易遭受攻击 实现client端原生JavaScript实现123456789&lt;script&gt; let jp = document.createElement('script') script.type= 'text/javascript' jp.src = 'http://www.jsonp.com:8080/login?user = admin &amp; callback = login' function login(res)&#123; //拿到服务端结果 &#125;&lt;/script&gt; 可以看到jsonp中的src其实并不是一个脚本地址，而是一个请求地址。 JQuery实现12345678910111213$ajax(&#123; url: 'http://www.jsonp.com:8080/login', type: get, dataType: 'jsonp', jsonCallback: 'login', data: &#123; user: 'admin' &#125;&#125;)function login(res)&#123; //拿到结果&#125; axios实现1234567import axios from 'axios'axios.jsonp('http://www.jsonp.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'login'&#125;).then(res =&gt; &#123; //拿到数据&#125;) server端返回数据： 1login(&#123;'status': true, 'user': 'admin'&#125;) CORS方案CORS（Cross-origin resource sharing），即跨域资源共享。它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。 同源安全策略 默认阻止“跨域”获取资源，即网页发送的跨域请求根本不会达到服务器即被浏览器拦截，服务器没有决定的权限。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。 CORS将不同的请求分为简单请求与复杂请求，根据请求的不同，CORS会进行不同的操作。 对于简单请求，CORS会先发送一个OPTIONS预请求。具体在后面复杂请求时进行。 首先我们区分一下简单请求与复杂请求： 简单请求简单请求必须满足三个条件： 使用的方法以下类型： GET HEAD POST 除了被用户代理自动设置的首部字段（例如 Connection ，User-Agent）和在 Fetch 规范中定义为 禁用首部名称 的其他首部，允许人为设置的字段为 Fetch 规范定义的 对 CORS 安全的首部字段集合。该集合为： Accept Accept-language Content-Type（下面有额外限制） DPR Downlink Save-Data Viewport-Width Width Content-Type的值仅限于以下三种： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象。 例子 12345678910111213141516171819202122GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin: http://foo.exampleHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61Access-Control-Allow-Origin: *Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml[XML Data] 请求中关键的是： Origin: http://foo.example 它表明请求来源是http://foo.example 响应中关键的是： Access-Control-Allow-Origin: * 其表明该资源允许被任意外域访问。但一般最好是值开放给规定的域，以保证安全： Access-Control-Allow-Origin:http://foo.example 复杂请求所有非简单请求皆为复杂请求，对于复杂请求，浏览器会首先发起一个预检请求（OPTIONS），以获取服务器是否允许该请求。 下面是一次复杂请求的过程： 第一次预请求头部： 1234567891011121314151617181920212223242526OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://foo.exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-TypeHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 在请求头部中：最重要的几个字段为： Origin: http://foo.example：表示请求的来源为http://foo.example，使服务端进行鉴别是否够允许该请求来源s。 Access-Control-Request-Method: POST：表示正式请求的方法为POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type：表示正式请求将携带两个自定义请求头部字段：X-PINGOTHER，Content-Type，服务器据此决定，该实际请求是否被允许。 在响应头部中：最为重要的几个字段为： Access-Control-Allow-Origin: http://foo.example：表示服务端允许来自http://foo.example的请求。 Access-Control-Allow-Methods: POST, GET, OPTIONS：表示服务端允许的方法为POST,GET,OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type：表示服务端允许携带自定义请求头部字段为：X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400：表示响应的有效时间为86400秒，也就是24小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。 请注意：浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。 附带身份凭证的请求在XMLHttpRequest 或 Fetch的CORS中，可以基于HTTP cookies和HTTP认证信息发送身份凭证。 但在默认情况下，浏览器不会携带身份信息。如果要使浏览器携带信息，需手动设置： 1234567891011var invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/credentialed-content/';function callOtherDomain()&#123; if(invocation) &#123; invocation.open('GET', url, true); invocation.withCredentials = true; //关键 invocation.onreadystatechange = handler; invocation.send(); &#125;&#125; 注意：不光client要设置withCredentials。 server还需要设置一个头部属性： Access-Control-Allow-Credentials: true 如果响应中缺失 Access-Control-Allow-Credentials: true（第 17 行），则响应内容不会返回给请求的发起者。 注意： 如果要使请求携带身份凭证，服务端不得设置Access-Control-Allow-Origin为*。 响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。 下面简单列举一下CORS中常用的HTTP头部字段 中间件代理描述中间件代理服务器即利用一个中间服务器转发实际服务器的请求，由于中间件服务器不需要遵循同源策略，即可以从后端服务器请求数据。实际上代理的主要作用并不是应对跨域。而是如其名，代理后端真实服务器，比如在分布式设计中，一个代理服务器可以代理后端多台真实服务器，做到具体业务和底层逻辑解耦。 实际上这种方式下，代理服务器仍然需要进行跨域配置，但是免去了后端真实服务器的跨域配置。具体流程如下： 例子在node中，一般使用express做为server容器，其中的express-http-proxy可以直接用来转发请求，作为一个中间件代理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//middleware.jsconst app = express();const http = require(\"http\");let proxy = require('express-http-proxy');//配置跨域app.use((req, res, next) =&gt; &#123; res.header('Access-Control-Allow-Origin', \"*\"); res.header('Access-Control-Allow-Headers', 'Content-Type,Content-Length,Authorization,Accept,X-Requested-With'); res.header('Access-Control-Allow-Methods','PUT,POST,GET,DELETE,OPTIONS'); res.header('X-Powered-By', '3.2.1') if(req.method === 'OPTIONS') &#123; res.send(200); &#125; else &#123; next(); &#125;&#125;);//配置代理服务器，代理/api接口app.use('/api', proxy('http://realServer.com', &#123; //过滤器 filter: function(req, res)&#123; return req.method === 'GET' &#125;, //请求路径解析 proxyReqPathResolver: function(req)&#123; return req.url+'token=123456' //请求转发路径 &#125;, //返回数据处理,如果过程有异步操作应返回Promise（可选） userResDecorator: function(proxyRes, proxyResData, userReq, userRes) &#123; //同步 data = JSON.parse(proxyResData.toString('utf8')); data.newProperty = 'exciting data'; return JSON.stringify(data); //异步 return new Promise(function(resolve) &#123; proxyResData.funkyMessage = 'oi io oo ii'; setTimeout(function() &#123; resolve(proxyResData); &#125;, 200); &#125;); &#125;,&#125;))app.listen(3000) 真实服务器不需要配置跨域，仅一个简单的server即可（这里也采用express） 12345678//server.jsconst app = express();const http = require(\"http\");app.get('/api', function(req, res)&#123; res.send('REAL SERVER MESSAGE!')&#125;) 业务中，使用代理服务器多用于业务解耦，或者负载均衡，跨域只是其中一个特点。 nginx反向代理描述使用nginx反向代理其本质与node中间件代理一样，都是使用一个中间服务器，来转发请求到实际的后端服务器中，但同样，nginx的反向代理多用来做负载均衡或业务解耦，跨域问题的解决只是其中一个特点。 例子下面那是一个简单的nginx的配置： 1234567891011121314// proxy服务器server &#123; listen 80; server_name www.middleware.com; location / &#123; proxy_pass http://www.realServer.com:8080; #关键，反向代理 proxy_cookie_domain www.realServer.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.middleware.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 跨页面通信postMessage描述window.postMessage()方法可以安全地实现跨源通信。此方法可以不考虑两个页面是否同源。只要能拿到对应窗口的引用对象，就可以使用该api进行通信。 窗口引用我们可以通过： 子窗口window.open(URL,name,features,replace) | 参数 | 描述 || :——- | :———————————————————– || URL | 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 || name | 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 和 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 || features | 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 || replace | 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。 | 1let newwin = window.open('http://www.child.com', 'child') iframe let newWin = document.getElemetnById(&#39;iframe&#39;).contentWindow 拿到窗口引用。 语法otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow：其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。 message：将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。[1] targetOrigin`：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。**如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是\\。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。** transfer可选：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 示例123//parent windowlet newWin = window.open('http://www.child.com', 'child')newWin.postMessage('hello', 'https://www.orgin.com') 在子窗口中我们可以添加message事件监听。 12345window.onmessage = function(e) &#123; console.log(e.data) //hello //返回消息 e.source.postMessage('world', e.origin)&#125; websocket通信描述 Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。 websocket本身支持跨域，不会存在CORS的限制。 WebSocket和HTTP都是应用层协议，都基于 TCP 协议。 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。 WebSocket在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 例子在前端我们使用Websocket构造器来新建一个Websocket实例。 12345678910let socket = new Websocket('ws://websocketServer.com')socket.onopen = function()&#123; //向服务器发送数据 socket.send('client-connect...')&#125;socket.onmessage = function(e)&#123; //接受服务器返回的数据 console.log(e.data) &#125; 在后端我们采用node.js，其他语言差别不大。 12345678910let express = require('express')let app = express()let Websocket = require('ws')let wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection', function(ws)&#123; ws.on('message', function(data)&#123; console.log(data) //client-connect... ws.send('server-connect...') &#125;)&#125;) document.domain + iframe该方法仅适用于主域相同，子域不同的场景。 原理两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 例子123456789101112&lt;!-- a.html --&gt;&lt;body&gt; &lt;iframe src=\"http://source.com:3000/b.html\" frameborder=\"0\" onload=\"load()\" id=\"frame\"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'source.com' function onload()&#123; //读取b.html中的变量 console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678&lt;!-- b.html --&gt;&lt;body&gt; hellob &lt;script&gt; document.domain = 'source.com' let a = 100; &lt;/script&gt;&lt;/body&gt; 两个hack方法下面的两个方法是利用一些hack的方法进行通信，往往更加麻烦，所以参考一下即可。 window.name + iframe原理window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在（这一点很重要），并且可以支持非常长的 name 值（2MB）。 例子其中a.html和b.html是同域的，都是http://localhost:3000，但b.html为a.html的iframe，则a.html与b.html可以使用window.name进行通信;而c.html是http://localhost:4000 1234567891011121314151617&lt;!-- a.html(http://localhost:3000/b.html) --&gt; &lt;iframe src=\"http://localhost:4000/c.html\" frameborder=\"0\" onload=\"load()\" id=\"iframe\"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125; &lt;/script&gt; b.html为中间代理页，与a.html同域，内容为空。 1234&lt;!-- c.html(http://localhost:4000/c.html) --&gt; &lt;script&gt; window.name = 'hello' &lt;/script&gt; 本方法利用了window.name属性在切换源后不变的性质，将数据传送到外域。但是比较复杂，需要用第三个页面进行中转，所以一般不用。 location.hash + iframe原理与window.name上一种方法相似， a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接JavaScript访问来通信。 例子其中a.html和b.html是同域的，都是http://localhost:3000，但b.html为a.html的iframe;而c.html是http://localhost:4000 123456789101112131415&lt;!-- http://www.localhost:3000/a.html --&gt;&lt;iframe id=\"iframe\" src=\"http://www.localhost:4000/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + '#user=admin'; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert('data from c.html ---&gt; ' + res); &#125;&lt;/script&gt; 12345678910&lt;!-- http://www.localhost:4000/b.html --&gt;&lt;iframe id=\"iframe\" src=\"http://www.localhost:3000/c.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt; 12345678&lt;!-- http://www.localhost:3000/c.html --&gt;&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); &#125;;&lt;/script&gt; 总结上面总结了很多方法， 但是CORS和jsonp是使用最多的跨域方法，CORS在现代开发中使用最多，但是jsonp兼容性更强，对于低版本的浏览器（比如IE10以下），可以实现跨域。 代理方法的用处不仅限于解决跨域，它有更大的作用，后期再探讨。 后面页面通信中，postMessage使用的更多，其他的hack方法仅在特定的环境下才有较好的效果。 参考 前端跨域系列（3）- 跨域方法总结 WebSockets URL组成详解 express-http-proxy express-http-proxy Cross-Origin Resource Sharing (CORS)","categories":[{"name":"通信","slug":"通信","permalink":"http://yoursite.com/categories/通信/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"通信","slug":"通信","permalink":"http://yoursite.com/tags/通信/"}]},{"title":"JavaScript宏任务，微任务与Event-loop","slug":"JavaScript宏任务，微任务与Event-loop","date":"2021-02-09T10:47:09.000Z","updated":"2021-02-16T07:35:16.880Z","comments":true,"path":"2021/02/09/JavaScript宏任务，微任务与Event-loop/","link":"","permalink":"http://yoursite.com/2021/02/09/JavaScript宏任务，微任务与Event-loop/","excerpt":"","text":"","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"宏任务","slug":"宏任务","permalink":"http://yoursite.com/tags/宏任务/"},{"name":"微任务","slug":"微任务","permalink":"http://yoursite.com/tags/微任务/"}]},{"title":"Promise的实现","slug":"Promise的实现","date":"2021-02-04T05:03:48.000Z","updated":"2021-02-09T10:43:36.364Z","comments":true,"path":"2021/02/04/Promise的实现/","link":"","permalink":"http://yoursite.com/2021/02/04/Promise的实现/","excerpt":"","text":"前面已经写过一篇文章来理解Promise及其使用方法，这里尝试来模拟Promise。 要求根据Promise/A+原理，有以下几个点需要遵守： Promise有一个Promise States，其有三种状态： pending：初始状态，可以转化为fulfilled，rejected。 fulfilled： 需要一个value作为结果。 不能转化为其他状态。 rejected： 需要一个reason作为一个原因。 不能转化为其他状态。 必须要一个then方法，接受两个参数 onFulfilled：当操作成功时发生的回调。 onRejected：当操作失败时发生的回调。 一旦promise完成，每一次调用then方法，得到的结果必须是相同的。 Promise返回的必须也是一个promise。 开发实现1，2功能首先我们实现第一个和第二个特点： 基本思路如下： 一个Promise首先要有一个status，表示当前的状态，其有三种状态： PENDING：表示当前Promise未完成，此时的回调函数会加入相应的队列 RESOLVED：表示当前Promise已经完成，且时resolve状态，直接调用成功的函数。 REJECTED：表示当前Promise已经完成，且时rejected状态，直接调用失败的函数。 然后我们要定义两个值： value：用于resolve时的返回值。 reason：用于rejected时的返回值。 上面说到当Promise状态为PENDING时，我们会把回调函数放到相应的队列，所以我们还会定义两个队列 resolvedCallQueue：存放成功的回调函数 rejectedCallQueue：存放失败的回调函数 然后我们定义Promise的resolve和rejected函数，在这两个函数中，我们会改变Promise的状态并且给value或者reason赋值，最后执行相应的函数队列。 最后我们会定义Promise的then方法。如同上面对于状态的定义，我们会根据当前Promise的状态来处理then方法传来的回调函数。 下面用ES6的class来实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Promise &#123; constructor(executer) &#123; //定义Promise状态枚举数据 this.status_enum = &#123; PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED', &#125;; //成功的返回值 this.value = undefined; //失败的返回值 this.reason = undefined; //成功的回调函数队列 this.resolvedCallQueue = []; //失败的回调函数队列 this.rejectedCallQueue = []; //当前Promise状态 this.status = this.status_enum.PENDING; //Promise完成 let resolve = (value) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.RESOLVED; this.value = value; for (let i = 0; i &lt; this.resolvedCallQueue.length; i++) &#123; this.resolvedCallQueue[i](this.value); &#125; &#125; &#125;; //Promise失败 let reject = (reason) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.REJECTED; this.reason = reason; for (let i = 0; i &lt; rejectedCallQueue.length; i++) &#123; this.rejectedCallQueue[i](this.reason); &#125; &#125; &#125;; //执行Promise函数 try &#123; executer(resolve, reject); &#125; catch (e) &#123; console.log('错误', e); reject(e); &#125; &#125; //定义then函数 then(onfulfilled, onrejected) &#123; //检测参数必须为函数 if(!onfulfilled instanceof Function || !onrejected instanceof Function)&#123; throw new Error('Uncaught TypeError: Promise resolver is not a function') &#125; //当Promise状态为RESOLVED时，进行成功回调函数 if (this.status === this.status_enum.RESOLVED) &#123; onfulfilled(this.value); &#125; //当Promise状态为REJECTED时，进行失败回调函数 if (this.status === this.status_enum.REJECTED) &#123; onrejected(this.reason); &#125; //当Promise状态为PENDING时，将其回调函数加入相应队列，在完成时会执行相应的函数队列 if (this.status === this.status_enum.PENDING) &#123; this.resolvedCallQueue.push(onfulfilled); this.rejectedCallQueue.push(onrejected); &#125; &#125;&#125; 下面用原型实现(基本原理一样，因为class本质也是原型链的语法糖)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Promise(executer) &#123; this.status_enum = &#123; PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED', &#125;; this.value = undefined; this.reason = undefined; this.resolvedCallQueue = []; this.rejectedCallQueue = []; this.status = this.status_enum.PENDING; let resolve = (value) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.RESOLVED; this.value = value; for (let i = 0; i &lt; this.resolvedCallQueue.length; i++) &#123; this.resolvedCallQueue[i](this.value); &#125; &#125; &#125;; let reject = (reason) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.REJECTED; this.reason = reason; for (let i = 0; i &lt; rejectedCallQueue.length; i++) &#123; this.rejectedCallQueue[i](this.reason); &#125; &#125; &#125;; try &#123; executer(resolve, reject); &#125; catch (e) &#123; console.log('错误', e); reject(e); &#125;&#125;Promise2.prototype.then = function then(onfulfilled, onrejected) &#123; if (this.status === this.status_enum.RESOLVED) &#123; onfulfilled(this.value); &#125; if (this.status === this.status_enum.REJECTED) &#123; onrejected(this.reason); &#125; if (this.status === this.status_enum.PENDING) &#123; this.resolvedCallQueue.push(onfulfilled); this.rejectedCallQueue.push(onrejected); &#125;&#125;; 这样，Promise的基本功能就已经实现，简单测试如下： 1234567891011121314let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('2秒！！！'); resolve(111); &#125;, 2000);&#125;);p.then((res) =&gt; &#123; console.log('p1'); console.log(res);&#125;);p.then((res) =&gt; &#123; console.log('p2'); console.log(res);&#125;); 结果： 1234567892秒！！！p1111p2111 实现1，2，3功能前面我们基本实现了Promise的基本功能，但是还是一个问题是：Promise必须返回一个Promise，上面的代码并不满足这一点。 所谓我们为了实现返回的都是Promise，我们需要重写then方法，使之返回的是一个Promise，这时，我们还是要根据当前Promise的状态来分开来处理。 但是其中心点是，必须持续执行Promise，直到其返回值不是一个thenable对象或方法，所以请是一个递归的过程。所以我们定义了一个函数cycleResolve，其接受四个参数： newPromise：新建的被用于返回的Promise target：回调函数执行的获得结果（可能仍然是一个Promise） resolve：新Promise的resolve函数 reject：新Promise的reject函数 该函数的功能是：判定返回值target是不是一个thenable对象（包括Promise），如果是，继续执行其then方法。给i贵这个过程，知道返回值不是thenable对象，然后将其值resolve出去。 注意： 只有target是一个thenable对象并且其then属性是一个函数时，才会调用其then方法，否则会直接将targetresolve出去。 一旦遇到错误，都会直接reject(e) then方法中必须使用setTimeout来使内部的操作成为宏任务，在下一个tick执行。这样才能拿到newPromise，否则会出现未初始化错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127class Promise &#123; constructor(executer) &#123; this.status_enum = &#123; PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED', &#125;; this.value = undefined; this.reason = undefined; this.resolvedCallQueue = []; this.rejectedCallQueue = []; this.status = this.status_enum.PENDING; //定义resolve方法，任务完成时调度 this.resolve = (value) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.RESOLVED; this.value = value; for (let i = 0; i &lt; this.resolvedCallQueue.length; i++) &#123; this.resolvedCallQueue[i](this.value); &#125; &#125; &#125;; //定义reject方法，任务失败时调度 this.reject = (reason) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.REJECTED; this.reason = reason; for (let i = 0; i &lt; this.rejectedCallQueue.length; i++) &#123; this.rejectedCallQueue[i](this.reason); &#125; &#125; &#125;; //执行定义Promise时传入的任务 try &#123; executer(this.resolve, this.reject); &#125; catch (e) &#123; console.log('错误', e); this.reject(e); &#125; &#125; //定义then方法 then(onfulfilled, onrejected) &#123; //新建一个Promise用于返回 let newPromise = new Promise((resolve, reject) =&gt; &#123; if (this.status === this.status_enum.RESOLVED) &#123; setTimeout(() =&gt; &#123; try &#123; let target = onfulfilled(this.value); cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;, 0); &#125; if (this.status === this.status_enum.REJECTED) &#123; //建立宏任务，方便拿到newPromise，否则会出现未初始化错误 setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;); &#125; if (this.status === this.status_enum.PENDING) &#123; this.resolvedCallQueue.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let target = onfulfilled(this.value); //将resolve函数保留的成功值传递作为参数 cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;, 0); &#125;); this.rejectedCallQueue.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); //将resolve函数保留的成功值传递作为参数 cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;); return newPromise; &#125; function cycleResolve(newPromise, target, resolve, reject) &#123; //禁止循环调用 if (newPromise === target) &#123; return reject(new TypeError('循环调用')); &#125; if ( target !== null &amp;&amp; (typeof target === 'object' || typeof target === 'function') /*确定其是一个对象*/ ) &#123; try &#123; let then = target.then; /*确定是否是一个thenable对象*/ if (typeof then === 'function') &#123; then.call( target, (newTarget) =&gt; &#123; resolvePromise(newPromise, newTarget, resolve, reject); &#125;, (e) =&gt; &#123; reject(e); &#125; ); &#125; else &#123; resolve(target); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; resolve(target); &#125; &#125; 至此，Promise的基本功能都已经完成，接下来我们完成剩下的一些细枝末节的东西，包括： 实现resolve方法 实现reject方法 实现catch方法。 实现finally方法。 实现Promise的其他方法： Promise.all([p1, p2, p3]) Promise.race([p1, p2, p3]) Promise.allSettled(p1, p2, p3) Promise.any(p1, p2, p3) 注意： 各个函数的功能不再赘述，具体查看Promise理解 下面的代码就只写对应部分，多余部分不再进行赘述。 实现catch方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960catch(onrejected) &#123; /*在class中定义catch方法*/ const newPromise = new Promise3((undefined, reject) =&gt; &#123; if (this.status === this.status_enum.REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); cycleReject(newPromise, target, reject); &#125; catch (e) &#123; console.log(e) reject(e); &#125; &#125;, 0); &#125; if (this.status === this.status_enum.PENDING) &#123; this.rejectedCallQueue.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); cycleReject(newPromise, target, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;);&#125;&#125;//循环rejectfunction cycleReject(newPromise, target, reject) &#123; //禁止循环调用 if (newPromise === target) &#123; return reject(new TypeError('循环调用')); &#125; if ( target !== null &amp;&amp; (typeof target === 'object' || typeof target === 'function') /*确定其是一个对象*/ ) &#123; try &#123; let then = target.then; /*确定是否是一个thenable对象*/ if (typeof then === 'function') &#123; then.call( target, (newTarget) =&gt; &#123; resolvePromise(newPromise, newTarget, reject); &#125;, (e) =&gt; &#123; reject(e); &#125; ); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125;else&#123; reject(target) &#125;&#125; 其实这里的操作与then方法逻辑基本一致，唯一不同的是，我们只需要捕捉reject，不捕捉resolve。 实现finallyPromise的finally的方法无论promise的结果是成功还是失败，都会执行，并且返回该promise。所以实现很简单。执行其promise的then方法来获取该promise的结果。 1234finally(callback) &#123; callback(); return this.then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;);&#125; 实现Promise.resolve方法(下面的方法是直接作为class的静态函数成员的)1234567891011121314151617static resolve(val) &#123; //如果是一个Promise if(val instanceof Promise3)&#123; return val //如果没有参数，或者为null,undefined &#125;else if(!val)&#123; return new Promise3((resolve, reject) =&gt; &#123;resolve()&#125;) //参数存在但不存在then方法 &#125;else if(val &amp;&amp; !val.then instanceof Function)&#123; return new Promise3((resolve) =&gt; &#123; resolve(val); &#125;); //参数存在且存在then方法 &#125;else if(val &amp;&amp; val.then instanceof Function)&#123; return new Promise3(val.then) &#125;&#125; 实现Promise.reject方法123456static reject(val)&#123; //直接将val作为理由返回 return new Promise((resolve,reject)=&gt;&#123; reject(val); &#125;)&#125; ## 实现Promise.all([p1, p2, p3])1234567891011121314151617static all(arr) &#123; let res = [] return new Promise((resolve, reject) =&gt; &#123; for(let i = 0, len = arr.length; i &lt; len; i++)&#123; arr[i].then((v) =&gt; &#123; res.push(v) //是否所有的promise都是resolve if(res.length === arr.length)&#123; return resolve(res) &#125; &#125;, (e) =&gt; &#123; //只要一个reject，直接reject return reject(e) &#125;) &#125; &#125;)&#125; 实现Promise.race([p1, p2, p3])1234567891011121314static race(arr) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i].then( (v) =&gt; &#123; return resolve(v) &#125;, (e) =&gt; &#123; return reject(e) &#125; ); &#125; &#125;);&#125; 实现Promise.allSettled([p1, p2, p3])12345678910111213141516171819202122232425static allSettled(arr) &#123; let res = []; let count = 0; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i].then( (v) =&gt; &#123; res.push(&#123; status: 'fulfilled', value: v, &#125;); &#125;, (e) =&gt; &#123; res.push(&#123; status: 'rejected', reason: e, &#125;); &#125; ).finally(() =&gt; &#123; //计数器必须在这里统计，因为异步操作，若放在then中，在finally中无法读取预期的值 ++count === arr.length &amp;&amp; resolve(res) &#125;); &#125; &#125;);&#125; 实现Promise.any(p1, p2, p3)123456789101112131415161718static any(arr) &#123; let res = []; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i].then( (v) =&gt; &#123; //只要有一个resolve，则直接resolve return resolve(v); &#125;, (e) =&gt; &#123; res.push(e); res.length === arr.length &amp;&amp; reject(res); &#125; ); &#125; &#125;);&#125;&#125; 最后本人能力有限，可能会出现错误，谅解。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"全面理解JavaScript作用域与闭包","slug":"全面理解JavaScript作用域与闭包","date":"2021-01-31T09:26:46.000Z","updated":"2021-02-03T09:15:12.080Z","comments":true,"path":"2021/01/31/全面理解JavaScript作用域与闭包/","link":"","permalink":"http://yoursite.com/2021/01/31/全面理解JavaScript作用域与闭包/","excerpt":"","text":"作用域pre：块语句块语句（或其他语言的复合语句）用于组合零个或多个语句。该块由一对大括号界定，可以是labelled： 块语句会生成一个块级作用域，生成块级作用域包含两种方法： 使用任意声明符号（’’, var,let,const）在函数中会生成一个块级作用域。 使用let,const在任何块语句中生成一个块级作用域。 注意：var在非函数的块语句中不会生成一个块级作用域。 介绍中都会使用var来进行举例，在变量声明中会对let和const进行说明。 介绍变量的简单说作用域就是在哪里可以访问到该变量。在JavaScript中，变量的作用域分为 全局作用域。 局部作用域。 这个全局与局部是相对的。因为在浏览器环境下，window对象被称为全局对象（在ES6中，顶层对象被规范为globalThis对象，在node中会指向global对象。）。而相对的，函数中的变量被称为局部变量。特点如下： 局部变量只能在该作用域和其子作用域中访问到。 全部变量可以在任作用域中访问到。 例子123456789101112var out = 'out-msg'//全局变量-作用域是全局作用域，可以在任何位置访问到function func()&#123; var in = 'in-msg' //局部变量-作用域是局部作用域， console.log(out) //out-msg console.log(in) //in-msg&#125; console.log(in) //VM229:1 Uncaught ReferenceError: out is not definedconsole.log(out) //out-msg 作用域链由于上面提到，全局与局部是相对的。由于window是浏览器环境中的最基础的变量，所以他被称为全局变量。而函数中（局部作用域）链中的还可以再定义函数，而内部函数仍然可以访问到外部函数中定义的变量。这样多个函数嵌套就会形成一个作用域链。 例子1234567891011121314151617var a = 'window'//可以访问到a，访问不到v3,v4,v2function fun1()&#123; var v1 = 'v1' //可以访问到a,v1，访问不到v3,v4,v2 function fun2()&#123; var v2 = 'v2' //可以访问到a,v1,v2，访问不到v3,v4 function fun3()&#123; var v3 = 'v3' //可以访问到a,v1,v2,v3，访问不到v4 function func4()&#123; //可以访问到a,v1,v2,v3,v4 &#125; &#125; &#125;&#125; 所以，这样由window-fun1-&gt;fun2-&gt;fun3-&gt;func4形成了一个作用域链。 tip： 当要使用一个变量时，系统会按照作用域链的顺序向上依次查询。所以，变量名相同时，局部变量会优先被访问。 使用var定义变量时，局部作用域只会在函数内部产生，当使用let,const时，只要是花括号内部，都会产生一个作用域。 变量申明目前JavaScript中4中声明变量的方式：无声明标志，var,let,const 无声明标志所谓不用声明标志，就是直接使用变量名进行声明，如 1234a = 1function fun()&#123; b = 2&#125; 这样申明的变量有一些特点： 无论在哪里申明（即使是在函数块中），其都是一个全局变量，即会被挂载在全局对象window上，即无声明标志无论如何都不会构成局部作用域。 varvar是ES6出现之前JavaScript中的声明标志之一（另外一个时function用来声明一个函数变量）。所以他也具有一些特征。 变量提升变量的声明与赋值在理解变量提升之前，我们要明白变量声明与变量赋值之间的关系。 变量声明是指确定这个作用域中该变量的存在。 1var v 变量赋值就是为已经声明的变量进行赋值。 1v = 'variable' 这两个操作可以一起进行。 1var v = 'variable' 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。 例子12345678bla = 2var bla;// ...// 可以隐式地（implicitly）将以上代码理解为：var bla;bla = 2; 重要的是，提升将影响变量声明，而不会影响其值的初始化。当到达赋值语句时，该值将确实被分配： 12345678910111213function do_something() &#123; console.log(bar); // undefined var bar = 111; console.log(bar); // 111&#125;// is implicitly understood as:function do_something() &#123; var bar; console.log(bar); // undefined bar = 111; console.log(bar); // 111&#125; 值得注意的是： 变量提升是在对应作用域下进行的，内层的作用域变量不会提升到外部中，所以会产生下面的问题： 123456var ov = 'out'function func()&#123; console.log(ov) var ov = 'in'&#125;func() 问结果是什么。 答：由于变量提升的按照作用域进行的，所以虽然这里外部声明了一个ov，但是在函数func内部也声明了一个ov变量，且在这个函数赋值之前就使用了，所以这里实际上等价于： 1234567var ov = 'out'function func()&#123; var ov console.log(ov) ov = 'in'&#125;func() 而单独的变量声明不赋值，在JavaScript中其默认值为undefined，所以这里打印出来的是undefined 值得注意的是： 只要是在变量还没有赋值之前进行操作，其值都是undefined。如： 12var x = y, y = 'A'console.log(x + y) //undefinedA 由于x = y时进行时，A还没有被赋值。但是由于变量提升，y是存在的，且其值为undefined，根据JavaScript的primitive算法，得x + y结果为undefinedA。 letlet声明符号是ES6引入的新的声明符号，为了解决var的一些问题。其有一下特点： 其在块语句中声明就会生成一个块级作用域（只要花括号存在）。 同一个变量名，只能被声明一次。 不会存在变量提升，取而代之的是暂时性死区。 下面依次解释： 其在块语句中声明就会生成一个块级作用域（只要花括号存在）。以前JavaScript中只有全局作用域和函数作用域。而ES6引入的let与const相当于为JavaScript引入了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。 同一个变量名，只能被声明一次。使用var时，同一个变量名，可以被多次声明。如： 123var a = 123var a = 'abc'//不会报错 但是使用let时，不允许重复声明同一个变量。 123let a = 123let a = 'abc'//VM971:2 Uncaught SyntaxError: Identifier 'a' has already been declared 不会存在变量提升，取而代之的是暂时性死区。上面提到，使用var声明变量时，会存在变量提升的现象。即相当于所有的变量，无论何处声明，其都被在最顶部声明，且默认赋值为undefined，然后在运行到声明处，在会被赋值为对应的值。所以在声明之前使用该变量，其结果都是undefined。 而使用let声明时，在声明之前，是无法使用的。从程序开始之前，到声明之间，被称为暂时性死区。如： 123console.log(a) Uncaught ReferenceError: b is not definedlet a = 123 立即执行函数（IIFE）定义一个函数后将其立即执行的形式，形如： 123456(function()&#123; var a = '100' console.log(a)&#125;)()//函数会立即执行，并输出100 其具有以下特点： 函数会立即执行 每执行一次，就会创建一个块级作用域，可以解决典型的异步问题： 12345for(var i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;, 500)&#125; 众所周知，这里的结果是：4444~，其原因就是： setTimeout是一个异步函数，当其回调函数执行的时候，for循环，已经完成了。所以后面打印出来的都是4。 用var时，不存在块级作用域，所以一个for循环中，使用的都是同一个i，导致前面的i会被后面的i所覆盖。 所以前面提到IIFE每执行一次都会创建一个快进作用域，所以可以这么解决。 12345for(var i = 0; i &lt; 5; i++)&#123; (function(i)&#123; console.log(i) &#125;)(i)&#125; 这样其结果就是：1234 但是当ES6的let出现之后，我们不再需要立即执行函数了来创建块级作用域了。直接使用let进行变量声明即可： 12345for(let i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;, 500)&#125; 其结果也是：1234 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; constconst也是ES6引入的声明符号。其基本与let一致： 每使用一次都会创建一个块级作用域。 同一个变量名，只能被声明一次。 并且，其还有一下特征： const声明一个只读的常量。一旦声明，常量的值就不能改变。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 值得注意的是：变量不可以被更改，但是其属性是可以被更改的。如： 123456789101112131415161718const obj = &#123; a: 1, b: 2&#125;obj = &#123;&#125;// SyntaxError: Missing initializer in const declarationobj.a = 3 //成功console.log(obj)\"&#123; a: 3, b: 2&#125;\" 垃圾回收机制基于最开始JavaScript设计的初衷，JavaScript的内存管理都是自动执行的，而且是不可见的。程序员基本上不需要自动管理内存。 V8内存模型要想更好的理解JavaScript的内存回收机制，要先简单理解一下JavaScript的内存模型（这里以V8为例） 首先JavaScript的变量分为两大类： 基本变量 Number Boolean String Symbol null undefined 引用变量：Object，Array，Date，RegExp 然后看一下V8的内存模型： 栈区栈区用于存储变量的名称以及内存中的地址。该地址又指向堆区、常量区或函数定义区。 例如： 在我们定义一个变量时： 12var a = 'string'var b = &#123;&#125; a为基本类型，所以他的值存储在池（常量区），所以： 在栈区建立一个单元：|变量名|内存地址|（如|a|0x1245a|） 在池（常量区）的0x1245a存储’string’ b为引用类型，其值存储在堆区，所以： 在栈区建立一个单元：|变量名|内存地址|（如|b|0x1245b|） 在堆的0x1245b的位置存储{} 值得注意的是： 变量未被初始化或者被赋值为undefined时，栈区的地址部分被置空。表示没有任何意义。 堆区用于存放引用类型的值，如上面的b，其具体的值就存储在堆区。 值得注意的是： 在堆区，预存着一个特殊对象null，其地址固定，所有的值为null的变量都指向这一块内存。 所以，需要手动释放一个变量时，只需要将该变量赋值为null，则此时其指向null，原来的内存在无引用时会被GC（garbage recycle）机制回收。 常量区与堆区相对，其存储常量的值。如上面的a变量。 常量区具有以下特征： 所有的值一旦写入无法改变。 所有相同的常量值在常量区都是惟一的。 注意：常量区的值与常量是不同的。常量区的值不可改变是指对应地址的内存内容是无法改变的。而当我们在改变常量时，实际上大概是这么个流程： 先检索常量区是否存在新的变量值。 如果存在，则直接将栈区的地址改为该常量的地址；若不存在，则在常量区新开辟一个地区，将新的变量存储到该地址，再将该常量的地址改为新的内存地址。 函数定义区函数定义区用于存放被定义的函数代码段。 值得注意的是：函数的声明有两种： 函数声明，形如 123function func()&#123; //...&#125; 这种定义的方式不会再栈区生成相应的函数名，因为此时其不是一个变量。引擎会直接在函数定义区定义这个函数，我们在调用这个函数的时候，引擎会去函数定义区搜索这个函数名进行调用。 函数引用，形如： 123var func = function()&#123; //...&#125; 这种方式会在栈区生成一个变量来保存这个函数的地址。函数代码段仍然保存在函数定义区。 两种定义方式在调用的时候会表现出一些不同。 对于第一种方式，V8引擎会在预扫描阶段进行函数提升，也就是说，你可以在函数定义之前调用该函数； 对于第二种方式，尽管引擎也会进行变量提升（因为其本身就是一个变量），但是并不会在提升的时候对变量赋值，因此不可以在定义之前调用该函数。 1234567//可以正常调用，因为引擎会提前扫描代码，将该函数存储到函数定义区f();function f()&#123;&#125;//报错，因为虽然g也进行了变量提升，但此时g的值是undefined，不能调用g();var g = function()&#123;&#125; 另外，如果函数名发生了重名，浏览器会以通过栈区变量引用的函数优先。如： 12345var f = function()&#123;&#125;function f()&#123;&#125;//会调用第一个函数f(); 之所以出现这种情况，是因为JavaScript引擎总是优先搜索栈区，所以上面的函数会优先被调用。但是如果调用发生在函数定义之前，那么就会调用通过函数声明定义的函数，代码如下： 12345//会调用下面的以函数声明定义的函数f();var f = function()&#123;&#125;//这个函数被调用function f()&#123;&#125; 究其原因，还是在调用函数时变量f的值为undefined，因此引擎才会去函数定义区搜索函数f。总的来说，引擎在调用函数时会以栈区的变量优先，如果搜索不到或为undefined，则会去函数定义区搜索。 但是两者实际上并不冲突，我们同样可以用一个变量来指向一个声明式函数，如： 12function f()&#123;&#125;var g = f; 现在变量g也拿到了函数f的内存地址，使用g同样可以访问该函数。 函数缓冲区函数缓冲区用于存放函数运行时动态申请的空间。函数运行时引擎会为其分配一片空间。当函数运行结束后，会回收其空间。只有当闭包产生的时候才会保留函数缓冲区中的数据。 垃圾回收机制JavaScript 中内存管理的主要概念是可达性（Reachability）。简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。 从上面的内存分配可以看出，每一个变量都会在栈区存储其名字和地址，地址又指向堆区或池。所以JavaScript的GC机制就是当不存在一个变量指向一个内存地址，则引擎认定该内存可以被回收。 这其中有一部分变量是一定可达的，被称为根（root），如： 全局对象 正被调用的函数的局部变量和参数 相关嵌套函数里的变量和参数 其他（引擎内部调用的一些变量） 这些根上面挂载的变量则也一定可达。 具体比如： 12345678let num = 123let cont = 11let str = 'str'let cs = 'cs'let obj = &#123; cont, cs&#125; 此时内存分配结构为： 即池和堆中的每个被分配的内存块都可以通过栈区的变量访问到。所以他们都是可达的，故不会被GC回收。 但是当我们将某一个变量赋为null时候，原来堆池中的值就变成不可达，GC就会进行回收。如： 12345678910111213let num = 123let cont = 11let str = 'str'let cs = 'cs'let obj = &#123; cont, cs&#125;num = nullcont = nullstr = nullcs = null 这个时候把所有的基础变量都置为null，则本来按照回收机制，其所有的基础变量都会被GC回收，但是由于obj中引用了cont,cs，所以虽然这两个变量被置为null了，但是内存中实际的值并没有被回收。此时其内存状况如下 可以看到由于可以从obj访问到cs,11，所以他们不会被回收。 回收算法（精简版）基本的垃圾回收算法称为“标记-清除”，定期执行以下“垃圾回收”步骤: 垃圾回收器获取根并“标记”(记住)它们。 然后它访问并“标记”所有来自它们的引用。 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。 以此类推，直到有未访问的引用(可以从根访问)为止。 除标记的对象外，所有对象都被删除。 下面是一个简单的过程（via前端面试：谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776)）： 可以看出，这实际上是一个广度遍历的过程，对整个栈区的变量构成的图进行广度遍历，并对遍历到的内存坐下标记。当遍历完成时，内存中未被遍历到的内存则证明时不可达的，则GC则可以将其回收。 剩下的内存是不可达的，则会被回收。 上面就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。 一些优化: 分代回收——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。 增量回收——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。 空闲时间收集——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。 闭包上面谈了这么多，都是为了更好的理解闭包。既然理解了内存模型和垃圾回收机制，再理解闭包就是如鱼得水了。 首先我们知道函数内的变量的生命周期只是该函数的运行过程。函数运行一旦结束，函数内的变量就会从函数缓冲区中删除掉。但是有的时候我们需要将函数中的变量永久（或长时间）保存下来，这个时候只需要在函数内部再新建一个函数，并且再内层函数中使用外层函数的变量。再将内层函数作为结果返回出来。由于此时外层函数中的变量由于被内层函数中使用，所以他们是可达的，则GC不会将其回收。如： 12345678910111213function out()&#123; let i = 0; function inner()&#123; i++ console.log(i) &#125; return inner&#125;let in = out()in() //1in() //2in() //3 这里就是一个典型的闭包。我们将使用外层函数的内部函数作为结果返回。我们调用该返回函数就可以操作到外层函数的变量。 闭包的应用用闭包模拟私有方法编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。 而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）： 123456789101112131415161718192021222324var Counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;&#125;)();console.log(Counter.value()); /* logs 0 */Counter.increment();Counter.increment();console.log(Counter.value()); /* logs 2 */Counter.decrement();console.log(Counter.value()); /* logs 1 */ 在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：Counter.increment，`Counter.decrement和Counter.value`。 该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。 这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。 你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量Counter。我们可以把这个函数储存在另外一个变量makeCounter中，并用他来创建多个计数器。 使用闭包形成一个块级作用域，完成异步回调函数（这里使用let解决更好）就像上面的IIFE中，我们使用了闭包来形成一个块级作用域，来完成异步回调函数，不至于造成异步函数执行时循环以完毕。 123456for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; (function(item)&#123; document.getElementById(item.id) = `内容-$&#123;i&#125;` &#125;)(item) &#125; 这里就是利用闭包形成了一个块级作用域。使每一次循环都有一个作用域，使在异步回调执行的时候，其值是正确的。 参考 前端面试：谈谈 JS 垃圾回收机制 Javascript垃圾回收机制 ECMAScript 6 入门 block","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"作用域","slug":"作用域","permalink":"http://yoursite.com/tags/作用域/"},{"name":"垃圾回收机制","slug":"垃圾回收机制","permalink":"http://yoursite.com/tags/垃圾回收机制/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}]},{"title":"bind,call,apply的用法及实现","slug":"bind-call-apply的用法及实现","date":"2021-01-27T09:57:04.000Z","updated":"2021-01-29T01:35:08.920Z","comments":true,"path":"2021/01/27/bind-call-apply的用法及实现/","link":"","permalink":"http://yoursite.com/2021/01/27/bind-call-apply的用法及实现/","excerpt":"","text":"bindbind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 参数thisArg 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。 当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。 如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg。 arg1, arg2, ... 当目标函数被调用时，被预置入绑定函数的参数列表中的参数。 返回值返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。 描述bind() 函数会创建一个新的绑定函数（bound function，BF）。绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语），它包装了原函数对象。调用绑定函数通常会导致执行包装函数。绑定函数具有以下内部属性： [[BoundTargetFunction]] - 包装的函数对象（即新生成的函数）。 [[BoundThis]] - 在调用包装函数时始终作为 this 值传递的值。 [[BoundArguments]] - 列表，在对包装函数做任何调用都会优先用列表元素填充参数列表。 [[Call]] - 执行与此对象关联的代码。通过函数调用表达式调用。内部方法的参数是一个this值和一个包含通过调用表达式传递给函数的参数的列表。 当调用绑定函数[[BoundTargetFunction]]时，它调用 [[BoundTargetFunction]] 上的内部方法 [[Call]]，就像这样 Call(*boundThis*, *args*)。其中，boundThis 是 [[BoundThis]]，args 是 [[BoundArguments]] 加上通过函数调用传入的参数列表。 绑定函数也可以使用 new 运算符构造，它会表现为目标函数已经被构建完毕了似的。提供的 this 值会被忽略，但前置参数仍会提供给模拟函数。 用法改变this指向（创建绑定this指向的函数）1234567891011121314let a = 'outterA'let obj = &#123; a: 'innerA'&#125;function printA()&#123; console.log(this.a)&#125;printA() //'outterA'let innerPrintA = printA.bind(obj)innerPrintA() //innerA 偏函数通俗的讲，偏函数就是指通过一个初始函数A，创建出另外的函数A1,A2，这两个函数含有了初始参数1，2。这里使用bind是利用了他的两个特点。 bind返回的是绑定函数，区别与Function.prototype.call()，Function.prototype.apply()的立即执行 其接受的是参数列表，并且会与绑定函数调用时的参数合并作用[[call]]原函数，区别于Function.prototype.apply() 123456789function add(arg1, arg2)&#123; return arg1 + arg2&#125;let addThirtynine = add.bind(null, 39)let addEleven = add.bind(null, 11)addThirtynine(3) //42addEleven(3) //14 改变setTimeout，setInterval的this指向由于setTimeout，setInterval的函调函数中this的指向总是window（即使在严格模式下）。所以可以使用bind改变回调函数中的this指向。 123456789101112131415let obj = &#123; message: '内部消息'&#125;message = '外部消息' //这种方法是吧message变量挂载在window上setTimeout(function()&#123; console.log(this.message)&#125;, 1000)//一秒后打印出：'外部消息'setTimeout(function()&#123; console.log(this.message)&#125;.bind(obj), 1000) //将this的指向改变为obj//一秒后打印出：'内部消息' 作为构造函数使用的绑定函数与偏函数用法类似，相当于为构造器提供默认参数。 1234567891011121314151617181920function Point(x, y)&#123; this.x = x this.y = y&#125;Point.prototype.toString = function()&#123; return `$&#123;this.x&#125;,$&#123;this.y&#125;`&#125;let p = new Point(1, 2)p.toString() //'1,2'let emptyObj = &#123;&#125;let YAxisPoint = Point.bind(null, 0/*x*/)let axisPoint5 = new YAxisPoint(5)axisPoint5.toString() //'0,5'axisPoint instanceof Point; // trueaxisPoint instanceof YAxisPoint; // truenew YAxisPoint(17, 42) instanceof Point; // true 快捷调用一些特定的函数被绑定在特定数据类型种，最典型的例子就是Array.prototype.slice，其只能由数组调用。实际上这个函数也接受类数组的对象(array-like object)，这个时候实际上是要改变this的调用。 一般的用法： 1234567let slice = Array.prototype.slicefunction convert()&#123; return slice.apply(arguments) //arguments是一个类数组对象&#125;convert(1,2,3,4) //[1, 2, 3, 4] 在使用bind后，由于其可以生成绑定函数，所以将要使用的函数作为this就可以不用每次都使用apply。 12345678let unboundSlice = Array.prototype.slice;let slice = Function.prototype.apply.bind(unboundSlice); //这个slice就是上面的slice.apply()的一个绑定函数function convert()&#123; return slice(arguments) //arguments是一个类数组对象&#125;convert(1,2,3,4) //[1, 2, 3, 4] 兼容性 Pollyfill法一： 123456789101112131415161718// Does not work with `new (funcA.bind(thisArg, args))`if (!Function.prototype.bind) (function()&#123; let slice = Array.prototype.slice; Function.prototype.bind = function() &#123; let thatFunc = this, thatArg = arguments[0]; let args = slice.call(arguments, 1); if (typeof thatFunc !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - ' + 'what is trying to be bound is not callable'); &#125; return function()&#123; let funcArgs = args.concat(slice.call(arguments)) //合并参数 return thatFunc.apply(thatArg, funcArgs); //绑定this指向 &#125;; &#125;;&#125;)(); 这里利用了Function.prototype.apply构造一个函数，运行及执行apply方法，达到bind的特点。 法二： 12345678910111213141516171819202122232425262728293031// Yes, it does work with `new (funcA.bind(thisArg, args))`if (!Function.prototype.bind) (function()&#123; let ArrayPrototypeSlice = Array.prototype.slice; Function.prototype.bind = function(otherThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; let baseArgs= ArrayPrototypeSlice.call(arguments, 1), baseArgsLength = baseArgs.length, fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; baseArgs.length = baseArgsLength; // reset to default base arguments baseArgs.push.apply(baseArgs, arguments); return fToBind.apply( fNOP.prototype.isPrototypeOf(this) ? this : otherThis, baseArgs ); &#125;; if (this.prototype) &#123; // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; &#125; fBound.prototype = new fNOP(); return fBound; &#125;;&#125;)(); callcall() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 注意：该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 参数thisArg 可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 arg1, arg2, ... 指定的参数列表。（与bind一样） 描述call方法相较于bind，他会生成一个绑定函数并立即调用。 用法基本方法：改变this指向123456789101112let obj = &#123; message: 'inner-message'&#125;message = 'outter-message'function log()&#123; console.log(this.message)&#125;log() //'outter-message'log.call(obj) //'inner-message' 使用 call 方法调用父构造函数使用call方法绑定this对象为自己子类中，则可以完成对父构造器的调用。达到简单的继承效果。 1234567891011121314151617function Product(name, price)&#123; this.name = name this.price = price&#125;function Food(name, price)&#123; Product.call(this, name, price) //调用父构造器，并将this绑定为Food的示例 this.category = 'food'&#125;function Toy(name, price)&#123; Product.call(this, name, price) //调用父构造器，并将this绑定为Toy的示例 this.category = 'toy'&#125; let cheese = new Food('feta', 5)let fun = new Toy('robot', 40) 为匿名函数指定this对象1234567let obj = &#123; message: 'obj-message'&#125;(function()&#123; console.log(this.message)&#125;).call(obj)//'obj-message' 兼容性 Pollyfill1234567891011121314151617181920if (!Function.prototype.call) &#123; Function.prototype.call = function () &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError( 'Function.prototype.call - what is trying to be bound is not callable' ); &#125; let func = this let that = arguments[0] let args = [] for (let i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]) &#125; that.func = func that.func(...args) delete that.func &#125;;&#125; applyapply() 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。 参数 thisArg 必选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 argsArray 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 返回值调用有指定this值和参数的函数的结果。 描述 apply 与 call() 非常相似，不同之处在于提供参数的方式。apply 使用参数数组而不是一组参数列表。apply 可以使用数组字面量（array literal），如 fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])，或数组对象， 如 fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))。 你也可以使用 arguments对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。 从 ECMAScript 第5版开始，可以使用任何种类的类数组对象，就是说只要有一个 length 属性和(0..length-1)范围的整数属性。例如现在可以使用 NodeList 或一个自己定义的类似 {&#39;length&#39;: 2, &#39;0&#39;: &#39;eat&#39;, &#39;1&#39;: &#39;bananas&#39;} 形式的对象。 需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。 用法基本方法：改变this指向123456789101112let obj = &#123; message: 'inner-message'&#125;message = 'outter-message'function log()&#123; console.log(this.message)&#125;log() //'outter-message'log.apply(obj) //'inner-message' 函数数组参数变为列表参数+使用内置函数1234let arr = [2,3,4,5,7]let max = Math.max.apply(null, arr)//7 在ES6中扩展运算符（spread）···来实现函数数组参数变为列表参数： 1234let arr = [2,3,4,5,7]let max = Math.max(...arr)//7 兼容性 Pollyfill1234567891011121314151617181920if (!Function.prototype.apply) &#123; Function.prototype.apply = function () &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError( 'Function.prototype.apply - what is trying to be bound is not callable' ); &#125; let func = this let that = arguments[0] let args = [] for (let i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]) &#125; that.func = func that.func(args) delete that.func &#125;; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"bind","slug":"bind","permalink":"http://yoursite.com/tags/bind/"},{"name":"call","slug":"call","permalink":"http://yoursite.com/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://yoursite.com/tags/apply/"}]},{"title":"JavaScript中数组与对象的遍历方法","slug":"JavaScript中数组与对象的遍历方法","date":"2021-01-26T05:48:19.000Z","updated":"2021-01-29T12:06:35.172Z","comments":true,"path":"2021/01/26/JavaScript中数组与对象的遍历方法/","link":"","permalink":"http://yoursite.com/2021/01/26/JavaScript中数组与对象的遍历方法/","excerpt":"","text":"数组for循环最传统的方法，按下标存取，也是最高效的方法 123456789101112let arr = [1,2,3,4]for(let i = 0; i &lt; arr.length; i++)&#123; console.log(arr[i])&#125;//1，2，3，4//不用每次计算len，更加高效for(let i = 0, let len = arr.length; i &lt; len; i++)&#123; console.log(arr[i])&#125;//1，2，3，4 for…of循环for...of语句创建一个迭代器(ES6引入，迭代器只会便利可枚举属性)。每一次循环都会调用迭代器的next对象。并返回当前该迭代器的值。 123456let arr = [1,2,3,4]for(let val of arr)&#123; console.log(val)&#125;//1,2,3,4 另外只要实现了迭代器的数据才能使用for...of循环。具体有：Array，Maps，Set，String，Arguments Object参数对象，Generators(生成器) for…in循环for...in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。 123456let arr = [1,2,3,4]for(let i in arr)&#123; console.log(i)&#125;//0，1，2，3 注意： for ...in循环遍历得到的结果为数据的键（数组即为下标）。 数组最好不要用for...in，因为for...in循环是为遍历对象而且设计的。 该方法也可用于String遍历下标。 for...in会顺着原型链向上遍历，原型链上所有的可遍历对象都会被遍历。比如（定义Array.prototype.max = () =&gt; {...}来获取数组中最大值，如果这么定义，那么这个属性也会被for...in纳入遍历） Array.prototype.entries()该方法一个新的 Array 迭代器对象。Array Iterator是对象，它的原型（proto:Array Iterator）上有一个next方法，可用用于遍历迭代器取得原数组的[key,value]。 12345678910var arr = [\"a\", \"b\", \"c\"];var iterator = arr.entries();console.log(iterator);/*Array Iterator &#123;&#125; __proto__:Array Iterator next:ƒ next() Symbol(Symbol.toStringTag):\"Array Iterator\" __proto__:Object*/ 用法一（直接使用Iterator的next对象）： 123456789const array1 = ['a', 'b', 'c'];const iterator1 = array1.entries();console.log(iterator1.next().value);// expected output: Array [0, \"a\"]console.log(iterator1.next().value);// expected output: Array [1, \"b\"] 用法二（二维数组按行排序）： 1234567891011121314151617181920212223242526function sortArr(arr) &#123; var goNext = true; var entries = arr.entries(); while (goNext) &#123; var result = entries.next(); if (result.done !== true) &#123; result.value[1].sort((a, b) =&gt; a - b); goNext = true; &#125; else &#123; goNext = false; &#125; &#125; return arr;&#125;var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];sortArr(arr);/*(4) [Array(2), Array(5), Array(5), Array(4)] 0:(2) [1, 34] 1:(5) [2, 3, 44, 234, 456] 2:(5) [1, 4, 5, 6, 4567] 3:(4) [1, 23, 34, 78] length:4 __proto__:Array(0)*/ 法三（使用for…of 循环）最典型： 1234567891011121314151617var arr = [\"a\", \"b\", \"c\"];var iterator = arr.entries();for (let v of iterator) &#123; console.log(v);&#125;// [0, \"a\"]// [1, \"b\"]// [2, \"c\"]for (let [index, value] of iterator) &#123; console.log(index+'---'+value);&#125;// 0-\"a\"// 1-\"b\"// 2-\"c\" Array.prototype.keys() keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。 与上面的Array.prototype.entries()相同，只是遍历的是索引键。用法与上面完全一致，本质也是迭代器。 典型用法(结合for...of)： 1234567let arr = [1,2,3,4]for(let i of arr.keys())&#123; console.log(i)&#125;//0，1，2，3 Array.prototype.values()values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值 与上面的Array.prototype.entries()相同，只是遍历的是索引键。用法与上面完全一致，本质也是迭代器。 典型用法(结合for...of)： 1234567const arr = ['a', 'b', 'c'];for (const value of arr.values()) &#123; console.log(value);&#125;//a，b，c Array.prototype.every()every()方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 其接收一个回调函数callback，callback 在被调用时可传入三个参数：元素值，元素的索引，原数组。 every 不会改变原数组。 every 和数学中的”所有”类似，当所有的元素都符合条件才会返回true。正因如此，若传入一个空数组，无论如何都会返回 true。（这种情况属于无条件正确：正因为一个空集合没有元素，所以它其中的所有元素都符合给定的条件。) 注意：若收到一个空数组，此方法在一切情况下都会返回 true。 典型用法： 123456789101112let arr = [5,6,4,7,8]arr.every((value, index, arr) =&gt; &#123; return value &gt; 3&#125;)//true（因为所有的value都大于3）arr.every((value, index, arr) =&gt; &#123; return value &gt; 5&#125;)//false（其中4,5不满足条件） every方法不会改变数组。 Pollyfill（最基础，下同）1234567891011121314151617181920212223if (!Array.prototype.every) &#123; Object.defineProperty(Array.prototype, every, &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.every ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = true; for (let [i, v] of this.entries()) &#123; if (!callback(v)) &#123; res = false; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.some()这个方法与上面的方法使用方法完全相同，但是所用相反，some()方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 其接收一个回调函数callback，callback 在被调用时可传入三个参数：元素值，元素的索引，原数组。 注意：如果用一个空数组进行测试，在任何情况下它返回的都是false。 典型用法： 12345678910111213let arr = [6,9,3,4]arr.some((value, index, arr) =&gt; &#123; return value &gt; 8&#125;)//true（因为存在一个9大于8）arr.some((value, index, arr) =&gt; &#123; return value &gt; 12&#125;)//false（因为所有的value都小于12） some方法不会改变数组。 Pollyfill1234567891011121314151617181920212223if(!Array.prototype.some)&#123; Object.defineProperty(Array.prototype, 'some', &#123; enumerable: false, value: function (callbakc) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.some ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = false; for (let [i, v] of this.entries()) &#123; if (callbakc(v, i, this)) &#123; res = true; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.filter()filter() 方法创建一个新数组, 其包含通过所提供函数实现的过滤的所有元素的结果。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：一个数组，包含所有的元素的检测结果。 1234567let arr = [1, 2, 3, 4]arr.filter((value, index, arr) =&gt; &#123; return value &gt; 2&#125;)//[3, 4] 该方法可用于剔除不合法数据，比如 1234567let arr = [1,2,3, undefined, null, 4, 5]arr.filter((value, index, arr) =&gt; &#123; return value != undefined &amp;&amp; value != null&#125;)//[1, 2, 3, 4, 5] flter方法不会改变数组。 Pollyfill12345678910111213141516171819202122if (!Array.prototype.filter) &#123; Object.defineProperty(Array.prototype, 'filter', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.filter ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = []; for (let i = 0; i &lt; this.length; i++) &#123; if (callback(this[i])) &#123; res.push(this[i]); &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.find() find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：数组中满足提供的测试函数的第一个元素的值。 1234567let arr = [1,2,3,4]arr.find((value, index, arr) =&gt; &#123; return value &gt; 2&#125;)//2（由于3，4均大于2，但是3是第一个，所以返回3的下标2） find方法不会改变数组。 Pollyfill1234567891011121314151617181920212223if (!Array.prototype.find) &#123; Object.defineProperty(Array.prototype, 'find', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.find ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = undefined; for (let i = 0; i &lt; this.length; i++) &#123; if (callback(this[i], i, this)) &#123; res = this[i]; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.findIndex()findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：数组中满足提供的测试函数的最后一个元素的值。 1234567let arr = [1,2,3,4]arr.find((value, index, arr) =&gt; &#123; return value &gt; 2&#125;)//3（由于3，4均大于2，但是4是最后一个，所以返回4的下标3） Pollyfill123456789101112131415161718192021222324if (!Array.prototype.findIndex) &#123; Object.defineProperty(Array.prototype, 'findIndex', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.findIndex ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = -1; for (let i = 0; i &lt; this.length; i++) &#123; if (callback(this[i], i, this)) &#123; res = i; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.forEach()forEach()方法对数组的每个元素执行一次给定的函数。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：undefined。 forEach() 为每个数组元素执行一次 callback 函数；与 map() 或者 reduce() 不同的是，它总是返回 undefined 值，并且不可链式调用。其典型用例是在一个调用链的最后执行副作用（side effects，函数式编程上，指函数进行 返回结果值 以外的操作）。 forEach 不会直接改变调用它的对象，但是那个对象可能会被 callback 函数改变。 示例： 12345678let arr = [1, 2, 3, 4]let res = []arr.forEach((value, index, arr) =&gt; &#123; res.push(value*2) &#125;)console.log(res) //[2,4,6,8] Pollyfill123456789101112131415161718if (!Array.prototype.forEach) &#123; Object.defineProperty(Array.prototype, 'forEach', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.forEach ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; for (let i = 0; i &lt; this.length; i++) &#123; callback(this[i], i, this); &#125; &#125;, &#125;);&#125; Array.prototype.map()map()方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。（forEach类似，区别是forEach不用返回，一起操作都在回调函数中进行） 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：一个由原数组每个元素执行回调函数的结果组成的新数组。 上面的示例重写： 12345let arr = [1, 2, 3, 4]let res = arr.map((value, index, arr) =&gt; &#123; return value * 2&#125;)console.log(res) //[2, 4, 6, 8] callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。 因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。 map不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组） 根据规范中定义的算法，如果被map调用的数组是离散的（如：arr = [emptyx2, 3]），新数组将也是离散的保持相同的索引为空。 Pollyfill1234567891011121314151617181920if (!Array.prototype.map) &#123; Object.defineProperty(Array.prototype, 'map', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.map ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = []; for (let i = 0; i &lt; this.length; i++) &#123; res.push(callback(this[i], i, this)); &#125; return res; &#125;, &#125;);&#125; Array.prototype.reduce()reduce()方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 接受：函数累计处理的结果reducer 函数接收4个参数: Accumulator (acc) (累计器) Current Value (cur) (当前值) Current Index (idx) (当前索引) Source Array (src) (源数组) callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。 返回值：函数累计处理的结果 示例： 数组里所有值的和 1234var sum = [0, 1, 2, 3].reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue;&#125;, 0);// 和为 6 累加对象数组里的值 要累加对象数组中包含的值，必须提供初始值，以便各个item正确通过你的函数。 123456var initialValue = 0;var sum = [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue.x;&#125;,initialValue)console.log(sum) // logs 6 你也可以写成箭头函数的形式： 1234567var initialValue = 0;var sum = [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce( (accumulator, currentValue) =&gt; accumulator + currentValue.x ,initialValue);console.log(sum) // logs 6 计算数组中每个元素出现的次数 12345678910111213var names = [&apos;Alice&apos;, &apos;Bob&apos;, &apos;Tiff&apos;, &apos;Bruce&apos;, &apos;Alice&apos;];var countedNames = names.reduce(function (allNames, name) &#123; if (name in allNames) &#123; allNames[name]++; &#125; else &#123; allNames[name] = 1; &#125; return allNames;&#125;, &#123;&#125;);// countedNames is:// &#123; &apos;Alice&apos;: 2, &apos;Bob&apos;: 1, &apos;Tiff&apos;: 1, &apos;Bruce&apos;: 1 &#125; Polyfillreduce 被添加到 ECMA-262 标准第 5 版，因此它在某些实现环境中可能不被支持。把下面的代码添加到脚本开头可以解决此问题，从而允许在那些没有原生支持 reduceRight 的实现环境中使用它。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Production steps of ECMA-262, Edition 5, 15.4.4.21// Reference: http://es5.github.io/#x15.4.4.21// https://tc39.github.io/ecma262/#sec-array.prototype.reduceif (!Array.prototype.reduce) &#123; Object.defineProperty(Array.prototype, 'reduce', &#123; value: function(callback /*, initialValue*/) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.reduce ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError( callback + ' is not a function'); &#125; // 1. Let O be ? ToObject(this value). var o = Object(this); // 2. Let len be ? ToLength(? Get(O, \"length\")). var len = o.length &gt;&gt;&gt; 0; // Steps 3, 4, 5, 6, 7 var k = 0; var value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &lt; len &amp;&amp; !(k in o)) &#123; k++; &#125; // 3. If len is 0 and initialValue is not present, // throw a TypeError exception. if (k &gt;= len) &#123; throw new TypeError( 'Reduce of empty array ' + 'with no initial value' ); &#125; value = o[k++]; &#125; // 8. Repeat, while k &lt; len while (k &lt; len) &#123; // a. Let Pk be ! ToString(k). // b. Let kPresent be ? HasProperty(O, Pk). // c. If kPresent is true, then // i. Let kValue be ? Get(O, Pk). // ii. Let accumulator be ? Call( // callbackfn, undefined, // « accumulator, kValue, k, O »). if (k in o) &#123; value = callback(value, o[k], k, o); &#125; // d. Increase k by 1. k++; &#125; // 9. Return accumulator. return value; &#125; &#125;);&#125; 1234567891011121314151617181920//concise method if (!Array.prototype.reduce) &#123; Object.defineProperty(Array.prototype, 'reduce', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.map ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let count = 0; for (let i = 0; i &lt; this.length; i++) &#123; count += callback(count, this[i], i, this); &#125; &#125;, &#125;); &#125; Array.prototype.reduceRight()这个方法与Array.prototype.reduce()只是执行顺序上相反（从右到左）。 reduceRight()方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 求一个数组中所有值的和1234var sum = [0, 1, 2, 3].reduceRight(function(a, b) &#123; return a + b;&#125;);// sum is 6 （虽然结果相同，但是是从右到左加） 展示 reduce 与 reduceRight 之间的区别123456var a = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;];var left = a.reduce(function(prev, cur) &#123; return prev + cur; &#125;);var right = a.reduceRight(function(prev, cur) &#123; return prev + cur; &#125;);console.log(left); // &quot;12345&quot;console.log(right); // &quot;54321&quot; PolyfillreduceRight 被添加到 ECMA-262 标准第 5 版，因此它在某些实现环境中可能不被支持。把下面的代码添加到脚本开头可以解决此问题，从而允许在那些没有原生支持 reduceRight 的实现环境中使用它。 12345678910111213141516171819202122232425262728293031// Production steps of ECMA-262, Edition 5, 15.4.4.22// Reference: http://es5.github.io/#x15.4.4.22if ('function' !== typeof Array.prototype.reduceRight) &#123; Array.prototype.reduceRight = function(callback /*, initialValue*/) &#123; 'use strict'; if (null === this || 'undefined' === typeof this) &#123; throw new TypeError('Array.prototype.reduceRight called on null or undefined'); &#125; if ('function' !== typeof callback) &#123; throw new TypeError(callback + ' is not a function'); &#125; var t = Object(this), len = t.length &gt;&gt;&gt; 0, k = len - 1, value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &gt;= 0 &amp;&amp; !(k in t)) &#123; k--; &#125; if (k &lt; 0) &#123; throw new TypeError('reduceRight of empty array with no initial value'); &#125; value = t[k--]; &#125; for (; k &gt;= 0; k--) &#123; if (k in t) &#123; value = callback(value, t[k], k, t); &#125; &#125; return value; &#125;;&#125; 下面是几种遍历方法的时间对比，可以看出传统for...耗时最少，；for...in最差。 对象for…in方法上面已经提到了for...in方法用于遍历数据的索引键。所以这个方法也可以用于遍历对象，具体方法如下： 123456789101112let obj = &#123;a : 1, b : 2, c : 3, d : 4&#125;for(let i in obj)&#123; console.log(`$&#123;i&#125;---$&#123;obj[i]&#125;`)&#125;/**a---1*b---2*c---3*d---4*/ Object.entries()Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。 参数 obj 可以返回其可枚举属性的键值对的对象。 返回值Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。 示例1234567891011121314151617181920212223242526272829const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]// array like objectconst obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]// array like object with random key orderingconst anObj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]// getFoo is property which isn't enumerableconst myObj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value() &#123; return this.foo; &#125; &#125; &#125;);myObj.foo = 'bar';console.log(Object.entries(myObj)); // [ ['foo', 'bar'] ]// non-object argument will be coerced to an objectconsole.log(Object.entries('foo')); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]// iterate through key-value gracefullyconst obj = &#123; a: 5, b: 7, c: 9 &#125;;for (const [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125; $&#123;value&#125;`); // \"a 5\", \"b 7\", \"c 9\"&#125;// Or, using array extrasObject.entries(obj).forEach(([key, value]) =&gt; &#123;console.log(`$&#123;key&#125; $&#123;value&#125;`); // \"a 5\", \"b 7\", \"c 9\"&#125;); Object.keys()Object.keys()方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。 参数 obj 要返回其枚举自身属性的对象。 返回值一个表示给定对象的所有可枚举属性（索引键）的字符串数组。 描述Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性（索引键）。这些属性的顺序与手动遍历该对象属性时的一致。 示例1234567891011121314151617181920// simple arrayvar arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // console: ['0', '1', '2']// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.keys(obj)); // console: ['0', '1', '2']// array like object with random key orderingvar anObj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.keys(anObj)); // console: ['2', '7', '100']// getFoo is a property which isn't enumerablevar myObj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function () &#123; return this.foo; &#125; &#125;&#125;);myObj.foo = 1;console.log(Object.keys(myObj)); // console: ['foo'] Object.values()Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。 参数 obj 被返回可枚举属性值的对象。 返回值一个包含对象自身的所有可枚举属性值的数组。 描述Object.values()返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。 示例12345678910111213141516171819var obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.values(obj)); // ['bar', 42]// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.values(obj)); // ['a', 'b', 'c']// array like object with random key ordering// when we use numeric keys, the value returned in a numerical order according to the keysvar an_obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.values(an_obj)); // ['b', 'c', 'a']// getFoo is property which isn't enumerablevar my_obj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function() &#123; return this.foo; &#125; &#125; &#125;);my_obj.foo = 'bar';console.log(Object.values(my_obj)); // ['bar']// non-object argument will be coerced to an objectconsole.log(Object.values('foo')); // ['f', 'o', 'o'] 本文大部分参考了MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"遍历","slug":"遍历","permalink":"http://yoursite.com/tags/遍历/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"}]},{"title":"flex布局与grid布局简介","slug":"flex布局与grid布局简介","date":"2021-01-24T07:45:23.000Z","updated":"2021-01-25T13:19:33.582Z","comments":true,"path":"2021/01/24/flex布局与grid布局简介/","link":"","permalink":"http://yoursite.com/2021/01/24/flex布局与grid布局简介/","excerpt":"","text":"flex布局flex布局可以更加简洁的实现之前使用浮动和绝对布局实现的一些布局。特别是item的展示界面等。 首先应该明确一个概念，这个概念在grid布局中也存在，就是container与item，即被布局的元素被称为item，包围这些item的元素即为container。在flex布局中，item的大小要自己设置。 flex布局相对于grid布局，简单许多，它是按照轴线的方式进行布局，按照item其规定一个主轴线main axis（默认为水平），然后对应的即为交叉轴cross axis（默认为垂直）。 所以其属性也分为容器属性和元素属性。 容器属性首先要使用flex布局，就要将容器的display属性设为flex。 注意：一旦将容器的display属性设为flex，则其item的float、clear和vertical-align属性将失效。 1. flex-direction属性flex-direction属性规定了主轴的方向。由于主轴可能有水平、垂直方向，又每个轴又可以从左到右，从上到下或相反。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2. flex-wrap属性flex-wrap属性规定了主轴是否进行换行。默认是不进行换行，又由于flex布局中，item的大小是自己规定的，所以在一行中，若item的总宽度大于父容器的宽度，则会对元素的宽度进行压缩。其有3个属性： nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，从最后一行的左边开始换行，向上换行。 3. flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4. justify-content属性justify-content属性定义了项目在主轴上的对齐方式。其有5个值。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等，两侧无间隔。 space-around：每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。 space-evently：每个项目两侧的间隔相等。间隔等于两侧的间隔。 5. align-items属性align-items属性将所有直接子节点上的align-self值设置为一个组。 align-self属性设置项目在其包含块中在交叉轴方向上的对齐方式。其有5个属性（需要注意的是这里是对每个交叉轴而言，即规定每个交叉轴上元素的对其方式，每个交叉轴上的行宽不会变，这里区别于align-content属性）： flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6. align-content属性align-content属性设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。如果项目只有一根轴线，该属性不起作用。（即每个交叉轴的宽度不是固定的，区别于上面的align-items属性）其有6个值： flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目属性这些属性用于item中。 1. order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 2. flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3. flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4. flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。（这个属性与width相斥，只有一个属性生效。） 5. flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 3. align-self属性align-self属性允许单个项目有与其他项目在交叉行不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 注意：MDN中每个属性还有另外的一些值，比如align-items还有self-atart，start等属性，但是实测在chrome中虽然不会提示错误，但是也不会生效，只有上面的属性会生效，而且VSCODE中也只会提示上面的值，所以，目前只需掌握上面的值即可 grid布局grid布局应该是目前原生最先进的布局方案，也正是因为其原生先进，所以其兼容性并不是很好。 可以看出Chrome在57版本以上才支持，而IE直接不支持。所以不是很友好。但这grid布局是以后的主流。所以可以提前了解其特点。 相同，grid布局中也分为：container容器和item项目。 容器属性1. display 属性display: grid指定一个容器采用网格布局。 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 2. grid-template-columns 属性， grid-template-rows 属性容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 123456&gt; .container &#123;&gt; display: grid;&gt; grid-template-columns: 100px 100px 100px;&gt; grid-template-rows: 100px 100px 100px;&gt; &#125;&gt; 上面代码指定了一个三行三列的网格，列宽和行高都是100px。 除了使用绝对单位，也可以使用百分比。 123456&gt; .container &#123;&gt; display: grid;&gt; grid-template-columns: 33.33% 33.33% 33.33%;&gt; grid-template-rows: 33.33% 33.33% 33.33%;&gt; &#125;&gt; repeat()：repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。如：repeat(3, 20px)，也可以定义为repeat(3, 10px 20px 30px) auto-fill 关键字：有时，项目的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。 1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; 上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。 fr 关键字：为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。 12345&gt; .container &#123;&gt; display: grid;&gt; grid-template-columns: 1fr 1fr;&gt; &#125;&gt; 上面代码表示两个相同宽度的列。 fr可以与绝对长度的单位结合使用，这时会非常方便。 12345&gt; .container &#123;&gt; display: grid;&gt; grid-template-columns: 150px 1fr 2fr;&gt; &#125;&gt; 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。 minmax() minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 12&gt; grid-template-columns: 1fr 1fr minmax(100px, 1fr);&gt; 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 auto 关键字 auto关键字表示由浏览器自己决定长度。 12&gt; grid-template-columns: 100px auto 100px;&gt; 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。 网格线的名称 grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。 123456&gt; .container &#123;&gt; display: grid;&gt; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];&gt; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&gt; &#125;&gt; 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 3. grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。 最新标准中，grid-row-gap缩写为row-gap；grid-column-gap缩写为colimn-gap。 grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。 12&gt; grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;&gt; 4. grid-template-areas 属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。 123456789&gt; .container &#123;&gt; display: grid;&gt; grid-template-columns: 100px 100px 100px;&gt; grid-template-rows: 100px 100px 100px;&gt; grid-template-areas: 'a b c'&gt; 'd e f'&gt; 'g h i';&gt; &#125;&gt; 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。 多个单元格合并成一个区域的写法如下。 1234&gt; grid-template-areas: 'a a a'&gt; 'b b b'&gt; 'c c c';&gt; 上面代码将9个单元格分成上下a、b、c三个区域。 下面是一个布局实例。 1234&gt; grid-template-areas: \"header header header\"&gt; \"main main sidebar\"&gt; \"footer footer footer\";&gt; 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。 如果某些区域不需要利用，则使用”点”（.）表示。 1234&gt; grid-template-areas: 'a . c'&gt; 'd . f'&gt; 'g . i';&gt; 上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 下面是一个经典布局（其中item的属性grid-area下面介绍）： 1234567891011121314151617181920212223242526 &lt;!--css代码--&gt;.grid &#123; display: grid; grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\"; /* background-color: rgb(247, 80, 177); */ grid-template-rows: 30px 300px 30px; grid-template-columns: 400px 50px 50px; &#125; #header&#123; grid-area: header; background-color: rgb(206, 206, 206); &#125; #main&#123; grid-area: main; background-color: rgb(235, 224, 74); &#125; #sidebar&#123; grid-area: sidebar; background-color: rgb(250, 99, 99); &#125; #footer&#123; grid-area: footer; background-color: rgb(112, 72, 255); &#125; 1234567&lt;!--html代码--&gt; &lt;div class=\"grid\"&gt; &lt;div class=\"grid-inner\" id=\"header\"&gt;&lt;/div&gt; &lt;div class=\"grid-inner\" id=\"sidebar\"&gt;&lt;/div&gt; &lt;div class=\"grid-inner\" id=\"main\"&gt;&lt;/div&gt; &lt;div class=\"grid-inner\" id=\"footer\"&gt;&lt;/div&gt; &lt;/div&gt; 效果图： 3. grid-auto-flow 属性grid-auto-flow 属性决定子元素的排列方式。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 即grid-auto-flow 属性默认值为：row 其取值可以有： 单值 row（默认值）：按行进行排列 column：按列进行排列 dense：该关键字指定自动布局算法使用一种“稠密”堆积算法，如果后面出现了稍小的元素，则会试图去填充网格中前面留下的空白。这样做会填上稍大元素留下的空白，但同时也可能导致原来出现的次序被打乱。 如果省略它，使用一种「稀疏」算法，在网格中布局元素时，布局算法只会「向前」移动，永远不会倒回去填补空白。这保证了所有自动布局元素「按照次序」出现，即使可能会留下被后面元素填充的空白。 双值 row dense：按行排列，并按稠密算法进行填补。 column dense：按列排行，并按稠密算法进行填补。 正式语法1[ row | column ] || dense 4. justify-items 属性， align-items 属性， place-items 属性justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。 1234.container &#123; justify-items: start | end | center | stretch; align-items: start | end | center | stretch;&#125; 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-items属性是align-items属性和justify-items属性的合并简写形式。 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 下面是一个例子。 1place-items: start end; 如果省略第二个值，则浏览器认为与第一个值相等。 另外这个属性还有其他的值，但是支持度并不好： 支持较好的属性： 5. justify-content 属性， align-content 属性， place-content 属性justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。 start - 对齐容器的起始边框。 end - 对齐容器的结束边框。 center - 容器内部居中。 stretch - 项目大小没有指定时，拉伸占据整个网格容器。 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性是align-content属性和justify-content属性的合并简写形式。 1place-content: &lt;align-content&gt; &lt;justify-content&gt; 如果省略第二个值，浏览器就会假定第二个值等于第一个值。 6. grid-auto-columns 属性， grid-auto-rows 属性有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行（使用grid-column-start等属性）。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 123456789.container&#123; display:flex; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125;.item8&#123; grid-row-start: 4; grid-column-start: 2;&#125; 可以看到原本container只有3行3列，但是第8个item被设定在第四行，则浏览器会自动生成第4行，这个第四行就会受grid-auto-rows属性控制。 7. grid-template 属性， grid 属性grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。 grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。 项目属性1. grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线 12345&gt; .item-1 &#123;&gt; grid-column-start: 2;&gt; grid-column-end: 4;&gt; &#125;&gt; 上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。 上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。 除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。 下面的例子是指定四个边框位置的效果。 123456.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4;&#125; 另外，这4个属性的值还可以取网格线名字，和上面的网格线名字 1234.item-1 &#123; grid-column-start: header-start; //这里是网格线名字 grid-column-end: header-end; //这里是网格线名字&#125; 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 123.item-1 &#123; grid-column-start: span 2;&#125; 上面代码表示，1号项目的左边框距离右边框跨越2个网格。 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 2. grid-column 属性， grid-row 属性grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 1234.item &#123; grid-column: &lt;start-line&gt; / &lt;end-line&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt;;&#125; 下面是一个例子。 1234567891011.item-1 &#123; grid-column: 1 / 3; grid-row: 1 / 2;&#125;/* 等同于 */.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;/* 等同于 */.item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 3. grid-area 属性grid-area属性指定项目放在哪一个区域。 123.item-1 &#123; grid-area: e;&#125; 上面代码中，1号项目位于e区域，效果如下图。 注意：需要在container中使用： 123grid-template-areas: 'a b c' 'd e f' 'g h i'; 来指定区域的位置 grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 下面是一个例子。 123.item-1 &#123; grid-area: 1 / 1 / 3 / 3;&#125; 4. justify-self 属性， align-self 属性， place-self 属性justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 1234.item &#123; justify-self: start | end | center | stretch; align-self: start | end | center | stretch;&#125; 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-self属性是align-self属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 下面是一个例子。 1place-self: center center; 如果省略第二个值，place-self属性会认为这两个值相等。 总结可以看出： flex布局与grid布局相较于原始的浮动布局，简单快捷很多。所以目前flex布局使用的较多，但是由于grid布局的兼容性并不好，所以使用的并不多。 两种布局的属性中存在很多其他W3C以规定的属性，但是浏览器很多都没有实现，Chrome虽然有对应的值，但是并没有生效。 一个问题使用flex布局进行多行布局，并使用justify-content:center/space-around-space-between时，如果最后一行的item数目少于屏幕能容纳的最大数，最后一行会出现问题，即最后一行不能左对齐，会按照其属性进行居中。 目前还没找到很好的解决办法，特别是在每行的数目不能确定的情况下，目前最普遍的方法时使用空白标签占位法，即使用每行添加最大能容纳的item数目的空白标签。这样空白标签不会显示，显性标签就会展示为左对其。但是任然还有一个问题，就是如果每行的数目减小，或者刚好能够容纳，则会出现一行(甚至两行)空白区域。虽然不影响，但是感觉仍然不是最优解。grid布局虽然能够在格式上完美解决，但是由于其兼容性，也不是很好的解决办法。目前仍在想能有什么解决办法。","categories":[{"name":"布局","slug":"布局","permalink":"http://yoursite.com/categories/布局/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/布局/"},{"name":"flex布局","slug":"flex布局","permalink":"http://yoursite.com/tags/flex布局/"},{"name":"grid","slug":"grid","permalink":"http://yoursite.com/tags/grid/"}]},{"title":"Vue插件开发4-插件的打包与引用","slug":"Vue插件开发4-插件的打包与引用","date":"2021-01-13T04:10:05.000Z","updated":"2021-01-16T06:49:24.073Z","comments":true,"path":"2021/01/13/Vue插件开发4-插件的打包与引用/","link":"","permalink":"http://yoursite.com/2021/01/13/Vue插件开发4-插件的打包与引用/","excerpt":"","text":"Vue插件的打包还是犯了一个最基础的错误，本来插件打包Vue-CLI官网给出了说明，而我还在苦苦百度。百度上的教程都是几年前的，全是照搬一套。 具体过程就是： 按照Vue插件开发1-插件原理即应用编写一个插件。 使用命令vue-cli-service build --target lib --name myLib [entry] myLib就是你的插件名字，主要是JS文件的命名。 [entry]是你的文件入口文件，即导出install函数文件 执行该命令就会生成打包完成的js文件。 dist/drag-window.common.js：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包) dist/drag-window.umd.js：一个直接给浏览器或 AMD loader 使用的 UMD 包 dist/drag-window.umd.min.js：压缩后的 UMD 构建版本 dist/drag-window.css：提取出来的 CSS 文件 (可以通过在 vue.config.js 中设置 css: { extract: false } 强制内联) js.map：source map文件是js文件压缩后，文件的变量名替换对应、变量所在位置等元信息数据文件，一般这种文件和min.js主文件放在同一个目录下。 比如压缩后原变量是map，压缩后通过变量替换规则可能会被替换成a，这时source map文件会记录下这个mapping的信息，这样的好处就是说，在调试的时候，如果有一些JS报错，那么浏览器会通过解析这个map文件来重新merge压缩后的js,使开发者可以用未压缩前的代码来调试，这样会给我们带来很大的方便！ npm插件的上传npm其实就是一个仓库。与git一样，我们使用npm install xxx的时候实际上是把其仓库中的xxx文件夹下载到本地。并再到node_modules中，我就可以直接使用import xxx from xxx的语法引入插件，实际上与我们在src下新建一个文件夹lib，然后使用import xxx from ./lib/xxx.js效果一样。 所以我们只需要 在npm注册一个npm账号。 然后新建一个文件夹使用npm init 初始化一个package.js文件。 123456789101112131415&#123; \"name\": \"drag-window\", \"version\": \"0.0.21\", \"description\": \"A plugin creating a drag window\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"darg\", \"window\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\" ], \"author\": \"mw530\", \"license\": \"MIT\"&#125; 这是一个最基本的样板，关键是private: true，然后把main.js设为生成的那个js文件。 在命令行使用npm adduser将自己的用户添加上去。 使用npm publish上传自己的文件。 注意：其中一个点是仓库必须切换为官方仓库，不能为淘宝仓库。 官方仓库：npm config set registry=http://registry.npmjs.org 淘宝仓库：npm install -g cnpm –registry=https://registry.npm.taobao.org; 插件的引用与Vue插件开发1-插件原理即应用的使用一样，只是引入的地址直接写插件命即可，如import xxx from &#39;xxx&#39;。然后使用Vue.use(xxx)。 注意样式表文件需全局直接import xxx/aaa.css，如果在&lt;style&gt;使用了使用了scope属性，则其样式表只在对应组件起效，如果不加，则会全局影响。","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue插件/"}],"tags":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/tags/Vue插件/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"Vue插件开发3-简单拖动窗口的优化","slug":"Vue插件开发3-拖动窗口的优化","date":"2021-01-13T04:02:08.000Z","updated":"2021-01-16T02:05:31.776Z","comments":true,"path":"2021/01/13/Vue插件开发3-拖动窗口的优化/","link":"","permalink":"http://yoursite.com/2021/01/13/Vue插件开发3-拖动窗口的优化/","excerpt":"","text":"思路思路一中心思想：首先算出首次拖动窗口距视窗的上面和左面的距离，然后计算出每次鼠标的偏移量（可正可负）。然后将其相加，就可得到新的偏移量。 代码思路： 设置一个变量，用于标记鼠标是否按下。 mousedown钩子函数中记录下此时的clientX1,clientY1,offsetX,offsetY。 mousemove钩子函数中记录下次此时的clientX2,clientY2，然后计算两组量： 拖动之前拖动框距文档边框的距离left1 = clientX1 - offsetX，top1 = clientY1 - offsetY 拖动的距离disX = clientX2 - clientX1，disY = clientY2 - clientY1 此时新的left2 = left + disX，top2 = top + disY 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546banMouseDown(e) &#123; console.log(\"鼠标按下\"); this.isDown = true; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); Vue.set(this.currenctPositon, \"x\", e.clientX); Vue.set(this.currenctPositon, \"y\", e.clientY); Vue.set(this.currenctPositon, \"offX\", e.offsetX); Vue.set(this.currenctPositon, \"offY\", e.offsetY);&#125;,banMouseUp() &#123; this.isDown = false; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"default\";&#125;,banMouseMove(e) &#123; debounce(this, this.handle, 20)(e); //节流函数&#125;,handle(e) &#123; if (this.isDown) &#123; console.log(e); let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); let cx = e.clientX; let cy = e.clientY; let moveX = (this.currenctPositon.x - this.currenctPositon.offX) + (cx - this.currenctPositon.x); let moveY = (this.currenctPositon.y - this.currenctPositon.offY) + (cy - this.currenctPositon.y); Vue.set(this.currenctPositon, \"x\", cx); Vue.set(this.currenctPositon, \"y\", cy); dw.style.left = moveX + \"px\"; dw.style.top = moveY + \"px\"; &#125;&#125;, 思路二然后又发现另一个思路（似乎更简单）： 中心思想：要想达到拖动效果，即要保持鼠标的位置相对于拖动框是相对静止的。而鼠标的位置相对于拖动框就是offset的值，是不会变化的。所以当鼠标发生移动时，拖动框的位置也要发生变化，才能保证offset的值是不变的。所以我们在新的一次鼠标移动(mousemove)后，新的偏移量应当赋予拖动框的left,right值。即left = clientX2 - offsetX，top = clientY2 - offsetY 代码思路： 设置一个变量，用于标志鼠标是否按下。 mousedown钩子函数中记录下此时的clientX1,clientY1,offsetX,offsetY。 mousemove钩子函数中记录下次此时的clientX2,clientY2，然后计算拖动出偏移量dOffsetX，dOffsetY，具体 left = clientX2 - offsetX top = clientY2 - offsetY 将拖动窗口的样式: style.left设置为left style.top设置为top 实测是可以使用的。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940banMouseDown(e) &#123; console.log(\"鼠标按下\"); this.isDown = true; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); Vue.set(this.currenctPositon, \"x\", e.clientX); Vue.set(this.currenctPositon, \"y\", e.clientY); Vue.set(this.currenctPositon, \"offX\", e.offsetX); Vue.set(this.currenctPositon, \"offY\", e.offsetY);&#125;, banMouseUp() &#123; this.isDown = false; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"default\"; &#125;, banMouseMove(e) &#123; debounce(this, this.handle, 20)(e); &#125;, handle(e) &#123; if (this.isDown) &#123; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); let cx = e.clientX; let cy = e.clientY; Vue.set(this.currenctPositon, \"x\", cx); Vue.set(this.currenctPositon, \"y\", cy); let moveX = this.currenctPositon.x - this.currenctPositon.offX; let moveY = this.currenctPositon.y - this.currenctPositon.offY; dw.style.left = moveX + \"px\"; dw.style.top = moveY + \"px\"; &#125; &#125;,&#125; 思路三接下来我发现了另外一个api：movementX，movementY，这个api会在mousemove时记录与上一次移动的距离，所以就在思路一的基础上可以省略求disX,disY的过程，所以有了以下代码： 123456789101112131415161718handle(e) &#123; if (this.isDown) &#123; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); let cx = e.clientX; let cy = e.clientY; Vue.set(this.currenctPositon, \"x\", cx); Vue.set(this.currenctPositon, \"y\", cy); let moveX = this.currenctPositon.x -this.currenctPositon.offX + e.movementX; let moveY = this.currenctPositon.y -this.currenctPositon.offY + e.movementY; dw.style.left = moveX + \"px\"; dw.style.top = moveY + \"px\"; &#125;&#125;, 但是由于movementX,movementY返回的是int，精度不够，所以会出现不跟手的情况；而且IE均不支持该属性，所以不是最优方案。 思路四最后我去参考了layui的方案。 12345678910111213141516171819202122232425262728293031323334353637383940 moveElem.on('mousedown', function(e)&#123; e.preventDefault(); if(config.move)&#123; dict.moveStart = true; dict.offset = [ e.clientX - parseFloat(layero.css('left')) ,e.clientY - parseFloat(layero.css('top')) ]; ready.moveElem.css('cursor', 'move').show(); &#125; &#125;);_DOC.on('mousemove', function(e)&#123; //拖拽移动 if(dict.moveStart)&#123; var X = e.clientX - dict.offset[0] ,Y = e.clientY - dict.offset[1] ,fixed = layero.css('position') === 'fixed'; e.preventDefault(); dict.stX = fixed ? 0 : win.scrollLeft(); dict.stY = fixed ? 0 : win.scrollTop(); //控制元素不被拖出窗口外 if(!config.moveOut)&#123; var setRig = win.width() - layero.outerWidth() + dict.stX ,setBot = win.height() - layero.outerHeight() + dict.stY; X &lt; dict.stX &amp;&amp; (X = dict.stX); X &gt; setRig &amp;&amp; (X = setRig); Y &lt; dict.stY &amp;&amp; (Y = dict.stY); Y &gt; setBot &amp;&amp; (Y = setBot); &#125; layero.css(&#123; left: X ,top: Y &#125;); &#125; layui采用的是一种更为常见的方式。 其关键在于其并没有直接拿offsetX，而是通过clientX - left，clientY - top来计算offset。其原因在于可能是offset属性的兼容性问题。 Feature Chrome Edge Firefox (Gecko) Internet Explorer Opera Safari Basic support (Yes) (Yes) 39.0 (39.0) 6 (Yes) (Yes) Redefined from long to double 56 ? ? ? ? ? offsetX在早期返回一个int，这对于拖动窗口有很大的影响，比如上面的movement属性，所以layui选择了更加稳定的直接获取其style.left属性。 函数节流这一部分，我觉得可加可不加，因为虽然DOM消耗很大，但是目前计算机的性能是完全足够承担一秒几十次到上百次的DOM重绘的。额可以在后期加入检测机制，如果机器性能较差，则可以节流mousemove函数。具体细节可以查看函数的节流与防抖","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue插件/"}],"tags":[{"name":"Vue插件开发","slug":"Vue插件开发","permalink":"http://yoursite.com/tags/Vue插件开发/"},{"name":"拖动窗口","slug":"拖动窗口","permalink":"http://yoursite.com/tags/拖动窗口/"}]},{"title":"Vue插件开发2-事件对象e与视窗api详解","slug":"Vue插件开发2-事件对象e与视窗api详解","date":"2021-01-13T03:57:39.000Z","updated":"2021-01-21T02:09:25.631Z","comments":true,"path":"2021/01/13/Vue插件开发2-事件对象e与视窗api详解/","link":"","permalink":"http://yoursite.com/2021/01/13/Vue插件开发2-事件对象e与视窗api详解/","excerpt":"","text":"事件参数 首先Vue没有对事件对象做修改，所以在Vue中的事件对象仍然与原生一样。 其对象属性具体又分为4类： 鼠标 / 键盘属性 属性 描述 altKey 返回当事件被触发时，”ALT” 是否被按下。 button 返回当事件被触发时，哪个鼠标按钮被点击。一个数字，表示鼠标事件发生时按下的鼠标按钮。可能的值：0：鼠标左键1：车轮按钮或中间按钮（如果有）2：鼠标右键注意： Internet Explorer 8和更早版本具有不同的返回值：1：鼠标左键2：鼠标右键4：车轮按钮或中间按钮（如果有）注意：对于左侧配置的鼠标，返回值会反转 buttons buttons属性返回一个数字，指示触发鼠标事件时按下了哪些鼠标按钮或鼠标按钮。一个数字，表示鼠标事件发生时按下的一个或多个鼠标按钮。如果按下多个按钮，则组合这些值以产生新数字（例如，如果按下左按钮（1）和右按钮（2），则返回值为1 + 2，即3） 。可能的值：1：鼠标左键2：鼠标右键4：滚轮按钮或中间按钮8：第四个鼠标按钮（通常是“浏览器返回”按钮）16：第五个鼠标按钮（通常是“浏览器转发”按钮）注意：对于左侧配置的鼠标，返回值会反转 clientX 返回当事件被触发时，鼠标指针的水平坐标。 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 ctrlKey 返回当事件被触发时，”CTRL” 键是否被按下。 metaKey 返回当事件被触发时，”meta” 键是否被按下。 relatedTarget 返回与事件的目标节点相关的节点。 screenX 返回当某个事件被触发时，鼠标指针的水平坐标。 screenY 返回当某个事件被触发时，鼠标指针的垂直坐标。 shiftKey 返回当事件被触发时，”SHIFT” 键是否被按下。 IE 属性除了上面的鼠标/事件属性，IE 浏览器还支持下面的属性： 属性 描述 cancelBubble 如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。 fromElement 对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。 keyCode 对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup 事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。 offsetX,offsetY 发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。 returnValue 如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 fasle，可以取消发生事件的源元素的默认动作。比如在a标签的事件中如果将该值设为false，则不会跳转；在submit按钮中就不会提交事件。 srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。 toElement 对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。 x,y 事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。 但是当前大部分浏览器的事件对象都已经趋近于统一，比如上图是chrome的事件对象，其中也涵盖了大部分上述所谓IE属性。 标准 Event 属性下面列出了 2 级 DOM 事件标准定义的属性。 属性 描述 bubbles 返回布尔值，指示事件是否是起泡事件类型。 cancelable 返回布尔值，指示事件是否拥有可取消的默认动作。 currentTarget 返回其事件监听器触发该事件的元素。 eventPhase 返回事件传播的当前阶段。 target 返回触发此事件的元素（事件的目标节点）。 timeStamp 返回事件生成的日期和时间。 type 返回当前 Event 对象表示的事件的名称。 这部分参数中使用较多的可能是前面几个属性，比如bubbles，cancelables 标准 Event 方法下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法： 方法 描述 initEvent() 初始化新创建的 Event 对象的属性。 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 stopPropagation() 不再派发事件。 这些方法是挂载在原型链的Event对象上的，所以直接的点击或其他事件是看不到的。 参数详解 currentTarget、srcElement与target currentTarget事件属性返回其事件侦听器触发事件的元素。 target始终返回触发事件的真实元素。（在事件冒泡中与currentTarget不同） currentTarget在直接捕捉e得到的结果为null，必须在函数中通过一个变量存储下来。 target的值会始终存储在e中，可以直接通过e查看。 srcElement与target一致，指向事件触发的元素，旧版本firefox不支持。 detail：detail属性返回一个包含事件详细信息的数字。在onclick和ondblclick上使用时，该数字表示当前的点击次数。在onmousedown和onmouseup上使用时，该数字表示当前点击次数加1。 isTrusted：isTrusted事件属性返回一个布尔值，指示事件是否可信。注意：在Chrome，Firefox和Opera中，如果事件由用户调用，则该事件是受信任的，如果由脚本调用，则不受信任。在IE中，除了使用createEvent()方法创建的事件之外，所有事件都是可信任的。 relatedTarget：relatedTarget属性返回与触发鼠标事件的元素相关的元素。relatedTarget属性可以与mouseover事件一起使用，以指示光标刚刚退出的元素，或者使用mouseout事件来指示光标刚刚输入的元素。 which：which属性返回一个数字，表示触发鼠标事件时按下了哪个鼠标按钮。（注意与button不一致） | 项目 | 描述 || :——- | :———————————————————– || 返回值： | 一个数字，表示鼠标事件发生时按下的鼠标按钮。可能的值：0：没有按钮1：鼠标左键2：滚轮按钮或中间按钮（如果有）3：鼠标右键注意：对于左侧配置的鼠标，返回值会反转。 | 视窗相关参数这里具体详解视窗相关参数： clientX,clientY：在页面（不包括浏览器bar部分）可视范围，与最左面，最上面的距离。 pageX、pageY：在整个页面范围内（包括不可视的部分），与最左面，最上面的距离。 screenX、screenY：距离显示器最左面，最上面的距离。（当窗口全屏时，即client加浏览器bar） layerX、layerY：鼠标相比较于当前坐标系的位置,即如果触发元素没有设置绝对定位或相对定位,以页面为参考点,如果有,将改变参考坐标系,从触发元素盒子模型的border区域的左上角为参考点。值得注意的是：该属性是以border边界为0，而offset是以content边界为0。 但是MDN上标注该属性为非规范属性，各个浏览器结果预期不一致，最好不要使用。 offsetX、offsetY：距离事件触发元素的左面，上面的距离。 注意：offset中，padding会被算在内。border会被算作负值。即offset是以padding作为边界的，超过这个边界即被判为负值。 DOM元素还含有一个属性用于计算该元素相对于视窗的距离：getBoundingClientRect()，该方法有4个属性： top：元素上边到视窗上边的距离; right：元素右边到视窗左边的距离; bottom：元素下边到视窗上边的距离; left：元素左边到视窗左边的距离; 注意：这些属性一旦超出视窗范围即为负数 DOM元素还带有一下一组（4个）属性： offsetLeft：返回元素相对于父级元素的左侧偏移量 offsetTop：返回元素相对于父级元素的左侧偏移量 offsetHeight：返回元素的高度（包括padding，border） offsetWidth：返回元素的宽度（包括padding，border） offsetParent：返回元素的父级元素 clientLeft：返回元素到父级元素左侧的距离（包括padding，不包括border） clientTop：返回元素到父级元素上侧的距离（包括padding，不包括border） clientHeigt：返回元素的高度（包括padding，不包括border） clientWidth：返回元素的宽度（包括padding，不包括border） scrollHeight：返回元素的滚动总高度（即总页面，包括因滚动而不在视野内的）（包括padding，不包括border） scrollWidth：返回元素的滚动宽度（即总页面，包括因滚动而不在视野内的）（包括padding，不包括border） 具体需要注意的是： 即offsetxxx包括border，其他的clientxxx，scrollxxx不包括border 这个距离与dom.style.left一样，指的是相对于外层具有定位标志（具有positon样式的元素）的祖先元素的距离。（若外层元素没有positon属性，则以ducoment为其定位元素） 通过element.style.left只能用来赋值（是字符串，需加后缀px），无法直接获取其值，必须通过上面的offsetLeft来获取其具体值。","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue插件/"}],"tags":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/tags/Vue插件/"},{"name":"事件参数","slug":"事件参数","permalink":"http://yoursite.com/tags/事件参数/"}]},{"title":"Vue插件开发1-插件原理即应用","slug":"Vue插件开发1-插件原理即应用","date":"2021-01-12T06:45:27.000Z","updated":"2021-01-14T13:49:55.819Z","comments":true,"path":"2021/01/12/Vue插件开发1-插件原理即应用/","link":"","permalink":"http://yoursite.com/2021/01/12/Vue插件开发1-插件原理即应用/","excerpt":"","text":"原理简介 插件通常用来为 Vue 添加全局功能。-Vue官网 我觉得广义上的插件，实际上就是一些可以复用的功能或组件的封装。 首先分析Vue源码： 12345678910111213141516171819202122232425//src-&gt;core-&gt;instance-&gt;index.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 我们可以法Vue实例最初是一个函数，然后在其上挂载各种属性。作为函数，我们就可以为其直接添加属性，或者向其prototype上添加参数。 Vue的插件通常包括一下几种： 添加全局方法或者 property。如：vue-custom-element 注册代码： 123456function install(Vue) &#123; Vue.customElement = function vueCustomElement(tag, componentDefinition, options = &#123;&#125;) &#123; //... &#125; //...&#125; 可以看到，这里是直接向Vue实例上添加属性方法。 使用： 1Vue.customElement() 另外，这个插件使用了Web Component这一新的属性，还得找个时间学习一下。它可以在HTML文件中直接使用自定义标签。 添加全局资源：指令/组件/过滤器/过渡等。如 vue-touch 注册代码（vue-touch）： 123456vueTouch.install = function (Vue) &#123; Vue.directive('touch', &#123; //... &#125; //...&#125; 这里是使用了Vue的directive定义了一个全局的v-touch指令。 123&lt;a v-touch:tap=\"onTap\"&gt;Tap me!&lt;/a&gt;&lt;div v-touch:swipeleft=\"onSwipeLeft\"&gt;Swipe me!&lt;/div&gt; 另外，还可以通过Vue.filter注册全局的filter来进行使用，比如 123456789let plugin = &#123;&#125;plugin.install = function(Vue, options)&#123; Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;)&#125; 则可以直接在Vue的tempelate中使用 1&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; 值得注意的是全局组件的注册，因为很多时候我们开发组件是需要组件样式支撑的。这个时候就需要全局注册组件。比如element-UI(可惜无了)，iview这种组件库就需要注册大量的全局样式。 注册代码（部分）（element-UI）： 123components.forEach(component =&gt; &#123; Vue.component(component.name, component);&#125;); 这里使用Vue.component注册全局组件，这样注册的组件可以直接在任何组件中引用而不需在script中申明。 值得注意的是，这样引入的组件即使未被引用，依然会被打包，因此，在大型组件库中尽量少使用全局注册，否则会增加打包后的js大小。 通过全局混入来添加一些组件选项。如 vue-router 注册代码： 123456789101112131415161718export function install (Vue) &#123; Vue.mixin(&#123; beforeCreate () &#123; if (isDef(this.$options.router)) &#123; this._routerRoot = this this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, '_route', this._router.history.current) &#125; else &#123; this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this &#125; registerInstance(this, this) &#125;, destroyed () &#123; registerInstance(this) &#125; &#125;)&#125; 可以看到，这里vue-router使用了Vue.minin对beforeCreate进行了混入，使该混入钩子在Vue自身的钩子之前调用。 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。比如element-UI等组件库。 注册代码： 123456789101112131415161718192021222324const install = function(Vue, opts = &#123;&#125;) &#123; locale.use(opts.locale); locale.i18n(opts.i18n); components.forEach(component =&gt; &#123; Vue.component(component.name, component); &#125;); Vue.use(InfiniteScroll); Vue.use(Loading.directive); Vue.prototype.$ELEMENT = &#123; size: opts.size || '', zIndex: opts.zIndex || 2000 &#125;; Vue.prototype.$loading = Loading.service; Vue.prototype.$msgbox = MessageBox; Vue.prototype.$alert = MessageBox.alert; Vue.prototype.$confirm = MessageBox.confirm; Vue.prototype.$prompt = MessageBox.prompt; Vue.prototype.$notify = Notification; Vue.prototype.$message = Message;&#125; 在Vue的prototype上添加很多参数方法。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router vue-router中有一个index.js与install.js，在install.js中，只提供了与Vue相关的注册函数。在index中，定义了很多自己的API。 使用插件通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成： 123456// 调用 `MyPlugin.install(Vue)`Vue.use(MyPlugin)new Vue(&#123; // ...组件选项&#125;) 也可以传入一个可选的选项对象： 1Vue.use(MyPlugin, &#123; someOption: true &#125;) Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。 Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 Vue.use()。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 Vue.use()： 123456// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时var Vue = require('vue')var VueRouter = require('vue-router')// 不要忘了调用此方法Vue.use(VueRouter) 另外，全局样式表的引入需要直接在main.js中import，这样的css样式也会被全局注册，会影响所有的组件。 开发插件Vue插件打开发其实很简单，最关键的就是其必须要暴露一个install方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 12345678910111213141516171819202122232425262728293031MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) Vue.component('my-component', Mcomponent) //常用 Vue.filter('my-filter', Mfilter) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125;export MyPlugin 应用根据上面的原理，我们只需要遵顼插件定义和使用的规则即可，其目录解构并不重要，但是为了规范，可以新建一个plugin用来存储插件文件，插件的目录解构可以自定义。另外，项目直接使用vue-cli生成一个普通的项目即可。 可以看到，在index.js文件中，我们定义了install函数，并在Vue的prototype上挂载了一个函数和一个方法，同时，也注册了一个全局的组件dwin。最后将该对象导出。 然后在main.js中，我们从index.js中引入dw，然后使用Vue.use(dw)将该组件导入。 然后我们就可以在任何组件中使用dwin组件了。 这样一个简单的组件开发就完成了，具体的打包和上传到npm仓库见这里","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue插件/"}],"tags":[{"name":"Vue插件开发","slug":"Vue插件开发","permalink":"http://yoursite.com/tags/Vue插件开发/"},{"name":"dragWindow","slug":"dragWindow","permalink":"http://yoursite.com/tags/dragWindow/"}]},{"title":"TypeScript特点2","slug":"TypeScript特点2","date":"2021-01-10T06:40:17.000Z","updated":"2021-01-11T06:52:20.742Z","comments":true,"path":"2021/01/10/TypeScript特点2/","link":"","permalink":"http://yoursite.com/2021/01/10/TypeScript特点2/","excerpt":"","text":"类型兼容性TS中的类型兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。 与Java不同，Java的强制转换是基于继承的，只有有继承关系的对象才可以进行转换。 即只要对象中的成员有包含关系，则可以进行类型转换。如， 1234567891011interface Named &#123; name: string;&#125;class Person &#123; name: string;&#125;let p: Named;// OK, because of structural typingp = new Person(); 这一点也是根据JS的灵活性设计的，JS中变量类型是自动检测的，程序员不需要专门进行规定。 对象的兼容TS结构化类型系统的基本规则是，如果x要兼容y，（所谓x兼容y，就是x可以被赋值为y），如 12345678interface Named &#123; name: string;&#125;let x: Named;// y's inferred type is &#123; name: string; location: string; &#125;let y = &#123; name: 'Alice', location: 'Seattle' &#125;;x = y; 称为x兼容y。 这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。 函数的兼容函数参数兼容函数的兼容与对象的兼容相反，函数x的参数包含函数y的参数，则x兼容y。如 12345let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // OKx = y; // Error 要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。 第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。 这里可以理解为，在函数赋值时，函数的参数可以被忽略的，（注意：函数调用的时候仍然必须赋值相等的参数，否则采用可选参数）但是限制了不能多余参数。即y中的参数s，在被赋值给x的时候直接被忽略，即 1234567//JS中函数调用的灵活性function f(a, b)&#123; //...&#125;f(1, 2); //参数b被忽略f(1, 2, 3) //多加参数c 函数返回值兼容返回参数少的函数可以被赋值为参数多的函数（这里TS称参数多的为参数少的函数的子类），即源函数可以被赋值为子类，即向下转换，如 12345let x = () =&gt; (&#123;name: 'Alice'&#125;);let y = () =&gt; (&#123;name: 'Alice', location: 'Seattle'&#125;);x = y; // OKy = x; // Error, because x() lacks a location property 类的兼容类的兼容只比较实例成员。静态部分不会被比较。（仍然是基于成员的比较，而不是Java中的继承），如 123456789101112131415class Animal &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;class Size &#123; feet: number; constructor(numFeet: number) &#123; &#125;&#125;let a: Animal;let s: Size;a = s; // OKs = a; // OK 高级类型交叉类型（Intersection Types）交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。 通俗的讲，就是包含所有成员类型的成员属性。如： 123456789101112131415161718192021222324252627function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; //将T与U成员变量混合成为新的变量，并返回该变量，返回时采用交叉类型而不是any let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person(\"Jim\"), new ConsoleLogger());var n = jim.name;jim.log(); 联合类型（Union Types）形式：A|B|C 含义： 作为参数时，仅支持A类或B类或C类，其他类型数据均不被接接受。如： 1234567function f(value: number|string)&#123; //...&#125;f(1); //正常f(\"1\"); //正常f(true); //失败 作为返回值时： 1234567891011121314151617interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;function getSmallPet(): Fish | Bird &#123; // ...&#125;let pet = getSmallPet();pet.layEggs(); // okaypet.swim(); // errors 由于返回的是A|B,所以我们只能访问A与B的交叉成员。 类型保护与区分类型（Type Guards and Differentiating Types）联合类型可以使我们接受多种特定类型的参数，但是我们要在函数内部更具参数类型执行特定的操作时又该如何判断呢。下面的写法是错误的，因为联合类型在访问任何独有参数时，都会发生错误。 123456789let pet = getSmallPet();// 每一个成员访问都会报错if (pet.swim) &#123; pet.swim();&#125;else if (pet.fly) &#123; pet.fly();&#125; 为了使代码工作，必须使用类型断言 12345678let pet = getSmallPet();if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125; 用户自定义的类型保护注意到，这种写法，我们在任何时候调用参数属性时，都必须加上类型断言。我们可以采用另外一种写法使之后的参数调用不再加上类型断言。 TS中的类型保护机制使之成为现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词： 123function isFish(pet: Fish | Bird): pet is Fish &#123; return (&lt;Fish&gt;pet).swim !== undefined;&#125; 在这个例子里， pet is Fish就是类型谓词。 谓词为 parameterName is Type这种形式， parameterName必须是来自于当前函数签名里的一个参数名。 每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型（在以后对应分支中的参数的每次调用都会被识别为该类型），只要这个类型与变量的原始类型是兼容的。 12345678// 'swim' 和 'fly' 调用都没有问题了if (isFish(pet)) &#123; pet.swim();&#125;else &#123; pet.fly();&#125; typeof类型保护实际上我们可以发现，在上面的断言函数中执行的内容就是判断参数是否为对应类型，是返回true，否返回false，所以我们在断言函数内部可以使用typeof来进行判断。 1234567891011121314151617function isNumber(x: any): x is number &#123; return typeof x === \"number\";&#125;function isString(x: any): x is string &#123; return typeof x === \"string\";&#125;function padLeft(value: string, padding: string | number) &#123; if (isNumber(padding)) &#123; return Array(padding + 1).join(\" \") + value; &#125; if (isString(padding)) &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 更进一步，对于原始类型（number, string, boolean, symbol），TS直接将typeof识别为断言函数，而不必我们每次都为原始类型类型编写一个断言。 123456789function padLeft(value: string, padding: string | number) &#123; if (typeof padding === \"number\") &#123; return Array(padding + 1).join(\" \") + value; &#125; if (typeof padding === \"string\") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 这些 typeof类型保护只有两种形式能被识别： typeof v === &quot;typename&quot;和 typeof v !== &quot;typename&quot;， &quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。 instanceof类型保护对于非原始类型，如何做到类型判断并收紧呢？TS提供了instanceof类型保护，也可以避免我们重写断言函数。 123456789101112131415161718192021222324252627282930313233interface Padder &#123; getPaddingString(): string&#125;class SpaceRepeatingPadder implements Padder &#123; constructor(private numSpaces: number) &#123; &#125; getPaddingString() &#123; return Array(this.numSpaces + 1).join(\" \"); &#125;&#125;class StringPadder implements Padder &#123; constructor(private value: string) &#123; &#125; getPaddingString() &#123; return this.value; &#125;&#125;function getRandomPadder() &#123; return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(\" \");&#125;// 类型为SpaceRepeatingPadder | StringPadderlet padder: Padder = getRandomPadder();if (padder instanceof SpaceRepeatingPadder) &#123; padder; // 类型细化为'SpaceRepeatingPadder'&#125;if (padder instanceof StringPadder) &#123; padder; // 类型细化为'StringPadder'&#125; instanceof的右侧要求是一个构造函数，TypeScript将细化为： 此构造函数的 prototype属性的类型，如果它的类型不为 any的话 构造签名所返回的类型的联合 null和undefinedTS将null，undefined视为两种不同的类型，他们不能被赋值给任何其他类型的参数。如官方文档所说： 注意，按照JavaScript的语义，TypeScript会把 null和 undefined区别对待。 string | null， string | undefined和 string | undefined | null是不同的类型。 可选参数与可选属性使用了 --strictNullChecks，可选参数会被自动地加上 | undefined: 1234567function f(x: number, y?: number) &#123; return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, 'null' is not assignable to 'number | undefined' 也就是说，可选属性可以被赋值为undefined作为占位参数，但是不能被赋值为null。 同样的，可选属性也可被赋值为undefined作为占位参数。 12345678910class C &#123; a: number; b?: number;&#125;let c = new C();c.a = 12;c.a = undefined; // error, 'undefined' is not assignable to 'number'c.b = 13;c.b = undefined; // okc.b = null; // error, 'null' is not assignable to 'number | undefined' 类型别名形如C中的typedef语法，TS提供了类型别名。 1234567891011type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入： 1type Container&lt;T&gt; = &#123; value: T &#125;; 我们也可以使用类型别名来在属性里引用自己： 12345type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125; 类型别名只能出现在申明的左侧。 字符串字面量类型字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。 12345678910111213141516171819type Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\";class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === \"ease-in\") &#123; // ... &#125; else if (easing === \"ease-out\") &#123; &#125; else if (easing === \"ease-in-out\") &#123; &#125; else &#123; // error! should not pass null or undefined. &#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, \"ease-in\");button.animate(0, 0, \"uneasy\"); // error: \"uneasy\" is not allowed here 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。 1Argument of type &apos;&quot;uneasy&quot;&apos; is not assignable to parameter of type &apos;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&apos; 数字字面量类型TypeScript还具有数字字面量类型。 123function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 &#123; // ...&#125; 我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候： 123456function foo(x: number) &#123; if (x !== 1 || x !== 2) &#123; // ~~~~~~~ // Operator '!==' cannot be applied to types '1' and '2'. &#125;&#125; 换句话说，当 x与 2进行比较的时候，它的值必须为 1，这就意味着上面的比较检查是非法的。 可辨识联合（Discriminated Unions）你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素： 具有普通的单例类型属性— 可辨识的特征。 一个类型别名包含了那些类型的联合— 联合。 此属性上的类型保护。 12345678910111213interface Square &#123; kind: \"square\"; size: number;&#125;interface Rectangle &#123; kind: \"rectangle\"; width: number; height: number;&#125;interface Circle &#123; kind: \"circle\"; radius: number;&#125; 首先我们声明了将要联合的接口。 每个接口都有 kind属性但有不同的字符串字面量类型。 kind属性称做 可辨识的特征或 标签。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起： 1type Shape = Square | Rectangle | Circle; 现在我们使用可辨识联合: 1234567function area(s: Shape) &#123; switch (s.kind) &#123; case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; &#125;&#125; Symbols这个部分也是ES6的引入一种新的原生类型，如number，string。 其特点是唯一，一个symbols是唯一独特的，无法改变的。即使两个symbol输入的key一样，这两个值仍然是完全不同的。 symbol类型的值是通过Symbol构造函数创建的。 123let sym1 = Symbol();let sym2 = Symbol(\"key\"); // 可选的字符串key Symbols是不可改变且唯一的。 1234let sym2 = Symbol(\"key\");let sym3 = Symbol(\"key\");sym2 === sym3; // false, symbols是唯一的 像字符串一样，symbols也可以被用做对象属性的键。 1234567let sym = Symbol();let obj = &#123; [sym]: \"value\"&#125;;console.log(obj[sym]); // \"value\"","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"TypeScript特点1","slug":"TypeScript特点1","date":"2021-01-09T07:18:36.000Z","updated":"2021-01-10T06:40:00.050Z","comments":true,"path":"2021/01/09/TypeScript特点1/","link":"","permalink":"http://yoursite.com/2021/01/09/TypeScript特点1/","excerpt":"","text":"基础类型VoidTS中增加了void类型，用于表示没有任何类型，一般也是用于一个函数没有返回值，但是与其他语言不同的是，TS允许一个变量直接声明为Void型（虽然这没什么用）。 1let unusable: void = undefined; void型变量只能被赋值undefined,null Null 和 Undefined这里的null与undefined与JS中基本一致，其是所有类型的子类，即所有的变量都可被赋值为null与undifined。 Nevernever表示那些永远不存在的的值的类型。从应用的角度来看，与void对比，never一般用于无法返回的函数的返回值类型。比如抛出错误的函数，死循环的函数。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; never与null、undefined一致，也是所有类型子类（比null,undefined级别更低）。 除了上述最常用的方法，never有其他用处。比如尤雨溪谈到的收窄类型 类型断言简单说，就是在对any型变量操作时跳过TS在编译时的检测，对于一个any的变量，我们在某些特定情况下知道其必定为某种特定类型，此时调用其特定的方法。我们可以跳过编译时的检测，但是其对运行没有影响。 具体，形式一：“尖括号”语法 123let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 形式二：as语法 123let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 注意，无论是否通过类型断言，没有指定属性的变量始终返回undefined，如 1234567let a : any = 145;let b = (a as string).length;console.log(a.length); //undefinedconsole.log(b); //undefined 解构解构这一部分ES6也支持 ，并且我觉得这是一个非常好的特征，可以更加灵活地进行变量的交换，拆分，合并。 数组解构下面的形式是最简单的数组解构形式 1234let input = [1, 2];let [first, second] = input;console.log(first); // outputs 1console.log(second); // outputs 2 解构用于以申明的变量(交换变量是一个很好的应用) 12// swap variables[first, second] = [second, first]; 用于函数参数 12345function f([first, second]: [number, number]) &#123; console.log(first); console.log(second);&#125;f(input); …语法获取剩余变量 123456789let [first, ...rest] = [1, 2, 3, 4];console.log(first); // outputs 1console.log(rest); // outputs [ 2, 3, 4 ]function f([first, ...second]: [number, number, number, number]) &#123; console.log(first); //1 console.log(second); //[2,3,4]&#125;f(1,2,3,4); 只要位置对应，可以解构数组任何位置元素 123456let [first] = [1, 2, 3, 4];console.log(first); // 1let [, second, , fourth] = [1, 2, 3, 4];console.log(second); // 2console.log(fourth); // 4 对象解构与数组解构原理一致，只要键名一致，就可以就行解构。如， 12345678let o = &#123; a: \"foo\", b: 12, c: \"bar\"&#125;;let &#123; a, b &#125; = o;console.log(a) //fooconsole.log(b) //12 也可以用没有申明的赋值： 1(&#123; a, b &#125; = &#123; a: \"baz\", b: 101 &#125;); 注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。 同样，我们可以使用...语法进行剩余元素提取。 12345678let o = &#123; a: \"foo\", b: 12, c: \"bar\"&#125;;let &#123;a, ...others&#125; = o;console.log(a); //fooconsole.log(others); //&#123; b: 12, c: 'bar' &#125; 属性重命名我们也可以对提取的元素进行重命名， 1let &#123; a: newName1, b: newName2 &#125; = o; 这里需要注意的是:不是表示类型，而是旧名字与新名字的间隔。 但是如果需要限制提取元素的类型，则不能进行属性重命名。 展开我们可以使用...语法来进行数组（对象的展开），如 数组展开 123let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5]; //bothPlus = [0,1,2,3,4] 对象展开 12let defaults = &#123; food: \"spicy\", price: \"$$\", ambiance: \"noisy\" &#125;;let search = &#123; name: \"me\", ...defaults &#125;; //search = &#123;name:\"me\",food:\"spicy\", price: \"$$\", ambiance: \"noisy\" &#125; 值得注意的是，在对象展开中，相同的键值对会被合并！ 接口这里的接口与传统面向对象语言中的接口有一定的差距， 在面向对象的语言中（如Java），接口是一个抽象类型，是抽象方法的集合。 而在TS中，接口更多的是对数据及其解构进行检查。 下面是一个典型的用法： 1234567891011interface LabelledValue &#123; label: string; size: int; //顺序无关&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;printLabel(myObj); //Size 10 Object 与函数参数一致，接口中允许可选属性，只读属性的存在，例如： 123456789interface SquareConfig &#123; color?: string; width?: number; //加?可选属性&#125;interface Point &#123; readonly x: number; readonly y: number; //readonly-只读属性&#125; readonly vs const readonly用于属性； const用于变量； 额外的属性检查这里有一点需要注意的是，如果是采用字面量形式参数时，会触发额外属性检查。如： 12345678910interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;); 这里会报错： script.ts(6,46): error TS2355: A function whose declared type is neither ‘void’ nor ‘any’ must return a value. script.ts(10,31): error TS2345: Argument of type ‘{ colour: string; width: number; }’ is not assignable to parameter of type ‘SquareConfig’. Object literal may only specify known properties, but ‘colour’ does not exist in type ‘SquareConfig’. Did you mean to write ‘color’? 但是我们在传参时不采用字面量对象传参，而是采用变量直接穿，则不会触发额外属性检查。 1234567891011interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let arg = &#123; colour: \"red\", width: 100 &#125;;let mySquare = createSquare(arg); 运行正常！ 函数类型当然TS中的接口也有传统面向对象语言中的抽象方法集合的功能。 123interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 与java不同，TS中的接口是可以直接被使用的，如， 12345let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125; 即直接定义变量的类为接口，在Java中这是不允许的，只有实现接口后的类才能被实例化。 接口实现这一点与java一致，接口是可以被实现的。 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; And，TS中接口可以多继承！ 函数TS中函数部分比较简单，主要仍然是格式问题 123function f(v1: int, v2: string) boolean&#123; //...&#125; 其他的细节都是JS中的内容，此处不谈。","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"2020-奋斗的一年","slug":"2020-奋斗的一年","date":"2020-12-31T15:34:10.000Z","updated":"2021-01-07T15:46:56.788Z","comments":true,"path":"2020/12/31/2020-奋斗的一年/","link":"","permalink":"http://yoursite.com/2020/12/31/2020-奋斗的一年/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"不知道密码就别猜了，这是我得小秘密，哈哈哈\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"2020","slug":"2020","permalink":"http://yoursite.com/categories/2020/"}],"tags":[{"name":"2020","slug":"2020","permalink":"http://yoursite.com/tags/2020/"},{"name":"计划","slug":"计划","permalink":"http://yoursite.com/tags/计划/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"考研遇到了问题！！！","slug":"考研遇到了问题！！！","date":"2020-04-22T10:46:58.000Z","updated":"2020-04-22T11:49:36.858Z","comments":true,"path":"2020/04/22/考研遇到了问题！！！/","link":"","permalink":"http://yoursite.com/2020/04/22/考研遇到了问题！！！/","excerpt":"","text":"回顾考研与2020想想考试复习考研已经有整整3个多月了，大概一月下旬就开始复习了！ 首先复习了两门科目 数学 英语 数学采用了看视频的方式进行了一轮复习，到四月十号左右就完成了。 英语的话由于最开始没有资料，只有几套真题，所以我直接上手真题。当然，错误率非常之高，问题只有一点：单词和短语积累不够，感觉每一道题，只要单词，短语90%理解，那基本不会错的。所以后面开始用百词斩背单词。由于之前背过，所以考研的词汇还有事多天就要背完了，当然会忘记，所以在考研的过程中，要不间断的背下去。 总体回顾的话，我感觉4月之前，也就是1,2,3月份的状态比较好，早上做英语，下午看视频学习数学，晚上复习数学。作息比较规律，至少可以做到不赖床。 四月的问题进入四月，数学的基础部分基本完成，英语也看了许多视频，把刘晓艳得语法，长难句都看了一遍。书也差不多过了一遍。但是接近四月中旬时出现了很大的问题： 问题 身体出现了问题： 最开始是牙龈出血严重，平时都能感觉口型腔内的血腥味 耳鸣开始困扰我，只要周围声音一大，耳膜就开始震动，耳朵很敏感；晚上睡觉时耳鸣严重（倒是没太影响睡眠）。后来去检测发现鼻炎严重，开始治疗鼻炎。 开始上课了，导致不得不频繁的使用电子设备，很容易分心。 看书感觉很难集中精力去想问题，看着讲义上的内容，完全不想动脑。 不节制玩游戏。 聊天过于频繁。 解决方法既然出现的问题，就必须去解决问题。否则只会被问题一点点拖垮！以我现在的状态，不配考上研究生！ 对于身体问题，只能说加紧治疗，毕竟没有更好的办法，只要不影响学习（但是我感觉最近这一系列问题的出现都是身体问题引起的）。 上完课就将电子设备放到远离自己的位置，避免手能够直接接触。 难集中精力，我觉得80%因为电子设备在旁边，所以先实行方法2，看是否还有其他原因。 立刻戒掉游戏，可以在周末玩一会。 当断不断，必受其乱！现在不是时候！ 接下来的安排既然选择了考研，我就不会退缩！所以我有以下安排来恢复状态，想想高中时一天学习14.5个小时的时候，现在这些算的了什么？！毕竟我是南实出来的人，还是练出来了吧！ 想想自己为什么考研？之前的我还不是很明确，但是现在，我觉得考研的目的很简单，就是为了实现自己的人生目标，实现阶级的跨越，在这样一个阶级越来越固化的时代，中国为底层提供了一个很好的工具，就是读书。起码读完硕士，就迈入了中薪阶层。后面在考虑是否读博士，现在的我并不很排斥继续读博士。 具体措施如下： 恢复斗志很关键，必须要恢复斗志，这是一切的来源！ 尽量隔离电子设备，学习时不看手机！ 每天计划，用纸打印表格。 每周总结，并发布到博客上。 规律作息，早上6:30起床，晚上23:30睡觉。 每周天放松，早上看书，下午玩游戏，晚上看技术文章，写总结。（作息仍然不变！） 一定要坚持下去最开始我在想考研该是有多困难啊！那么多人考不上，后来我才发现原来不是考研难，而是复习的这个过程最困难。不比高中，有人24hours的监督你来学习，时间制定好，饭做好。大部分人可能都没有高考时一半用心，所以考上的人那么少。我现在是真的体会到了他们常说的一句话，考研比的是坚持，比的是身体，比的是自律！一点没错！智商的影响只在于你是否能考上北大清华。加油，记住你对自己的定位！","categories":[{"name":"考研","slug":"考研","permalink":"http://yoursite.com/categories/考研/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://yoursite.com/tags/考研/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"Vue源码1-从初始化到响应式原理","slug":"Vue源码1-从初始化到响应式原理","date":"2020-01-08T14:09:52.000Z","updated":"2020-01-08T15:37:47.093Z","comments":true,"path":"2020/01/08/Vue源码1-从初始化到响应式原理/","link":"","permalink":"http://yoursite.com/2020/01/08/Vue源码1-从初始化到响应式原理/","excerpt":"","text":"首先介绍后面要用到的几个类： Observer类：用于将一个数据变为响应式（可被观测） Watcher类：一个依赖（一个指令对应一个依赖），一旦有一个指令用到了某个对象属性，那么就会新建一个Watcher作为订阅者。 Dep类：依赖管理器，一个对象属性对应一个Dep，其有一个内部属性subs用于存放依赖。 Vue初始化Vue原型是在src/instance/idnex.js中定义的： 12345678910111213141516171819202122232425//src/instance/idnex.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 可以看到Vue原型是一个function。在这个函数只判断了是否是new出来的，否则报警告。然后直接调用了_init()方法，这个方法是在下面的initMixin(Vue)中混入的初始化方法。下面看一下这个方法中的重要部分。 1234567891011121314151617181920212223//init.js 52-72 liens initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props //state包括data，props，methods initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; 这里按顺序进行了一下操作(最简化，不考虑分支)： 首先初始化了生命周期 initLifecycle(vm) 初始化了事件($on,$emit,$once…) initEvents(vm) 初始化了render initRender(vm) 调用了beforeCreate生命周期 callHook(vm, &#39;beforeCreate&#39;) 是初始化inject initInjections(vm) 接下来的initState中，初始化了data,props,methods。 initState(vm) 初始化provide initProvide(vm) 调用生命周期created，callHook(vm, &#39;created&#39;),如同官网所说： 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前尚不可用。 最后一步将el挂载到页面。vm.$mount(vm.$options.el) 响应式原理（以对象为例）响应式的所有文件都放在observer文件夹下： observer array.js:数组的处理相关处理 dep.js:依赖管理器类的定义及其处理 index.js:整个observer的出口 scheduler.js:调度者相关文件 traverse.js:递归遍历一个对象，以唤醒所有转换getter，使每个嵌套的属性内的对象作为“深度”依赖项收集。 watcher.js:观测者，依赖的类定义与相关处理。 还是接着上面的第6步:initState initState方法定义在state.js中，下面节选这一部分中内容： 12345678910111213141516171819202122//state.jsexport function proxy ()&#123; //代理处理 //比如当我们调用this.xxx 的时候实际上它是挂载在vm._data.xxx的，这里的代理同样使用了Object.defineProperty()来进行了代理。&#125;export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 可以看到intiState中，Vue进行了下面主要操作： initProps(vm, opts.props) initMethods(vm, opts.methods) initData(vm) initWatch(vm, opts.watch) 然后以data为例，分析对data的处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243//state.jsfunction initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 在这个函数里 首先看data是一个对象还是一个函数，对其进行对应的处理 然后判断他不能与props,methods中的属性同名，因为最终这三部分都会被挂载到vm实例上。 最后调用observe()方法来使data变为可被观测的 然后我们看observe()方法，这个方法就位于observer下的index.js中了。 1234567891011121314151617181920212223//observer/index.jsexport function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 作为整个将数据变为响应式的入口函数，它进行了一下操作： 判断传入的val如果不是一个对象或者是一个Vnode，就直接返回，不做处理 判断整个val是否有__ob__整个属性或者是不是Observer的子类，如果是的话，直接将val.__ob__返回 进行了一系列的其他的判断，比如是否应该被观测（shouldObserve这个对象定义在全局中，判 标识此时是否应该处理数据）、是否处于服务端渲染模式、是一个数组或是一个对象、是不是可扩展的、是不是Vue本身。 新建一个Observer对象，并将value传入。 继续向下看，新建Observer对象过程，Observer对象也在index中定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//observer/index.jsexport class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 可以看到Observer对象包含了三个私有属性： value：当前观测对象 dep：依赖管理器 vmCount：将这个对象作为$data的数量 再看他的构造方法中，执行流程如下： 初始化了value，dep，vmCount 并给value的加上一个(不可枚举的)__ob__属性，可以联系上面判断__ob__的操作 判断value是否是一个数组，然后执行对数组的observer操作。现不看数组。 如果不是，则代表value是一个对象，则执行walk()方法对其进行处理。 在walk()中，可以看到Vue遍历了对象的所有属性并对其调用了defineReactive方法 我们再跟进defineReactive方法中（这个方法就差不多是核心了）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; //为每一个属性建立一个依赖收集器 const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125; &#125;)&#125; 还是分析一下他的执行流程： 首先建立了一个Dep对象，即每一个属性都有一个依赖管理器用来收集用到这个属性的依赖，这一部分后面在讲。 判断这个对象属性能否被修改，及判断其configurable属性。 判断这个对下给你属性是否自带了getter与setter，如果有的话就将其缓存下来。 判断是否在函数调用时为这个对下给你属性传入了customSetter，如果有的话，则先调用getter将其值存储下来。 判断有无子对象或者是否在函数调用时确定只观测表层属性（不循环处理），如果都不满足则递归进行子属性的响应式处理。 这里就使整个响应式的核心：Object.defineProperty，在这里Vue为其定义了enumerable,configurable,get,set get()： 获取原始的属性值（通过原始getting或者直接获取） 判断Dep.target的值是否存在（这个值后面介绍Dep对象时介绍，代表的是当前的依赖），如果存在的话，就调用dep对象的depend()方法进行依赖收集。 接下来判断是否有子ob对下给你，如果有的话，也调用子的dep的depend方法进行依赖收集。同时判断对象属性原来的值是否是个数组，如果是的话，调用dependArray方法进行数组的依赖收集。 set() 获取对象属性原本的值，调用原来的getter，如果没有，就接受传入的值。 判断有没有必要更新。 判断是否有customSetter，如果有的话，就调用 如果只有getter，没有setter，则直接返回。这里是为了修复#7981的BUG，问题大概是如果一个对象属性如果被其他插件修改后只有getter，但没有setter，也就是说整个插件的原意是将其变为一个不可写入的属性，但是如果不加这一句进行判断，那么Vue会直接调用val = newVal，对其进行赋值。这不符合预期，所以加了这一句判断，直接返回不进行处理。 判断如果原来有setter的话，就调用其setter。否则就直接赋值给val。 然后同样是对子属性的处理。 这一步进行依赖派发。 至此，defineReactive方法流程介绍完毕。但是我们还留下了两个坑 依赖收集dep.depend()具体如何完成的 依赖通知dep.notify()具体如何完成的 接下来我们在进入这两个函数进行分析。 首先我们看一下Dep对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//observer/dep.js/* @flow */import type Watcher from './watcher'import &#123; remove &#125; from '../util/index'import config from '../config'let uid = 0/** * A dep is an observable that can have multiple * directives subscribing to it. * 一个dep可以有多个指令（包括\"&#123;&#123;&#125;&#125;\",\"v-text\",\"v-html\"...）订阅它。 * target属性用于表示正在处理的依赖，当确定为这个值的指令时，则将其添加到subs中（addSub函数）。 * subs属性用于存放所有的依赖，他的依赖是Watcher类 */export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this/* 这个依赖管理器Dep实例 */) &#125; &#125; notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;// The current target watcher being evaluated.// This is globally unique because only one watcher// can be evaluated at a time.Dep.target = nullconst targetStack = []export function pushTarget (target: ?Watcher) &#123; targetStack.push(target) Dep.target = target&#125;export function popTarget () &#123; targetStack.pop() Dep.target = targetStack[targetStack.length - 1]&#125; 可以看到Dep对象有三个属性， target：一个静态属性，类型是Watcher，即当前执行的依赖 id：Dep的标识符 subs：整个dep中所有的依赖，是一个Watcherd数组 然后我们直接看depend()方法： 这个函数判断dep的target是否存在，如果存在的话，则调用当前依赖的addDep方法，我们知道这个target是一个Watcher。所以我们看一下Watcher： 1234567891011121314151617181920212223242526272829303132export default class Watcher &#123; //初始化了很多属性 vm: Component; expression: string; cb: Function; id: number; deep: boolean; user: boolean; lazy: boolean; sync: boolean; dirty: boolean; active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any;&#125; addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; //调用depaddSub方法把这个指令（this）添加到这个dep中 dep.addSub(this) &#125; &#125; &#125; 可以看到在addDep中，判断这个Watcher对应的新dep中是否含有这个传进来的Dep，如果没有就其push到新dep与新depIds中，然后判断原来的dep中是否含有这个watcher，如果没有，就push进来。 这里的newDep与dep是为了灵活的动态更新视图，思考以下场景： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;span v-if=&quot;nameShow&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt; &lt;span v-if=&quot;ageShow&quot;&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt; &lt;input :value=&quot;name&quot;/&gt; &lt;input :value=&quot;age&quot;/&gt; &lt;button @click=&quot;nameShow = !nameShow&quot;&gt;切换name状态&lt;/button&gt; &lt;button @click=&quot;ageShow = !ageShow&quot;&gt;age&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&quot;Register&quot;, data () &#123; return &#123; nameShow: true, ageShow: true, name:&quot;123&quot;, age:&quot;111&quot; &#125; &#125;&#125;&lt;/script&gt; 当nameShow与ageShow都是true时，我们对表单机进行修改以修改name与age的值时，肯定会涉及到到依赖的分发。 但是当我们点击button将nameShow或ageShow的值切换为false时，视图上已经不显示对应信息，则讲道理应该不会在对这个依赖进行通知。这个newDep的存在就是为了这里。 至此，依赖收集的过程基本完成。下面看看如何进行依赖派发的： 当一个对象属性被改变时，其set方法就会被调用，由此调用dep.notify()，进行依赖派发。我们看一下dep.notify()这个函数内部： 12345678910111213141516//observer/dep.jsnotify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 可以看到首先是对subs所有的依赖进行了排序，根据官方的注释是应为：如果subs不是异步运行的话，那么他们没有在调度者中进行排序，所以我们需要对其进行排序以保证其正确按序派发。 然后这里调用每一个watcher的update方法，进行DOM的更新。看一下update()方法 12345678910update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 可以看到首先判断了这个watcher是不是懒加载的，如果是的话，将其dirty属性变为true，Vue会在调用到它时进行加载，否则看他是不是同步的，如果是的话，立即调用run()进行DOM更新操作，否则就将其推入到queueWatcher队列中，等待调度者，进行调度。（这里就不再讲调度算法，后续再讲） 再进入run()方法： 1234567891011121314151617181920212223242526272829303132//observer/watcher.js /** * Scheduler job interface. * Will be called by the scheduler. */ run () &#123; if (this.active) &#123; const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher \"$&#123;this.expression&#125;\"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125; &#125; 由官方的注释也可以看出来，这个run()是由调度者进行执行的（除非他是一个同步的watcher） run()函数的运行流程如下： 判断这个wacher是否的活动的，如果是才操作。 通过get()获取这个watcher对应的值，判断获取到的值与watcher中保存的值是否相同 如果不等，则把当前watcher中保存的值作为oldValue保存下来，将当前watcher中的value设为获取到的value，然后判断这个watcher是不是用户定义的（this.user）（根据调度者中注释，watcher分为user watcher与render watcher），如果使用定义的watcher则用try--catch预防错误，否则直接调用这个watcher的回调函数。这个回调函数就会进行真正操作，比如调用rrnder更新DOM。 数组的响应式如何实现在上面我们介绍Dep对象时，在其构造方法中，我们只看了this.walk()对对象的操作，现在我们看一下对数组的操作： 123456789101112131415161718192021export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; 如果value是一个对象，那么会判断value有没有__ptoto__对象，因为部分浏览器不支持这个属性，如果有的话，则调用protoAugment(value, arrayMethods)把arrayMethods挂载到value的__proto__上，我们再看一下arrayMethods，它放在 observer/array.js中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 可以看到 首先是以原生Array的prototype作为原型创建了一个新的对象arrayMethods。 列举出需要被修改的数组方法methodsToPatch 对methodsToPatch进行forEach循环，并给arrayMethods定义每一个列举出的方法（不可枚举），如果这些方法中要为这个数组插值，我们必须也要探测这个值是否是一个引用类型（Araay或者Object），并也要将其变为响应式，所以后面判断了如果是push,unshift,splice则拿到要插入的值inserted 判断inserted是否存在，如果存在，也使用observeArray将其变为响应式。 进行依赖收集ob.dep.notify() 返回原始方法调用后返回的结果。 然后我们再看protoAugment方法： 12345function protoAugment (target, src: Object) &#123; /* eslint-disable no-proto */ target.__proto__ = src /* eslint-enable no-proto */&#125; 可以看到很简单，就只是把第一个参数的__proto__修改为第二个参数，结合我们刚刚传入的参数，即：将这个数组的_proto_修改为arrayMethods，即上面我们分析的这个对象。 再看copyAugment方法，这个方法也很简单，是针对不支持__proto__属性的浏览器： 1234567891011/** * Augment a target Object or Array by defining * hidden properties. *//* istanbul ignore next */function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125;&#125; 即遍历所有的方法名字，并将其设置为到目标数组上的不可枚举属性。 最后我们看一下observeArray方法： 12345678/** * Observe a list of Array items. */observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125; 这里实际上就是将数组的每一个值变为响应式。 但是还有一点是：我们还可以通过下标的方式为数组赋值，但是JS中找不到方法检测整个操作，所以Vue也无法检测到，所以Vue提供了Vue.set和Vue.del这两个api，用来弥补这一点。 至此，响应式的整个流程就差不多完成了。 最后梳理以下整个流程(对象)： 这个流程主要是我通过分析源码，借助一定的网上资料整理出来的，可能其中会有错误。希望大家指出来，谢谢。","categories":[{"name":"Vue源码","slug":"Vue源码","permalink":"http://yoursite.com/categories/Vue源码/"}],"tags":[{"name":"Vue源码","slug":"Vue源码","permalink":"http://yoursite.com/tags/Vue源码/"},{"name":"响应式原理","slug":"响应式原理","permalink":"http://yoursite.com/tags/响应式原理/"}]},{"title":"JavaScript中的&，&&，|，||","slug":"JavaScript中的与或运算","date":"2020-01-07T11:51:20.000Z","updated":"2020-01-07T11:54:33.006Z","comments":true,"path":"2020/01/07/JavaScript中的与或运算/","link":"","permalink":"http://yoursite.com/2020/01/07/JavaScript中的与或运算/","excerpt":"","text":"简单区分&amp;,&amp;&amp;,|,||&amp;&amp; 位与运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右全为1才为1 || 位或运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右有一个1结果就为1 &amp;&amp;&amp;&amp; 逻辑运算符（与） — 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- 如果第一个值（转换后）为true，则返回后一个值。 如果第一个值（转换后）为false，则返回第一个值。 |||| 逻辑运算符（或）—- 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- 如果第一个值（转化后）为true，则返回第一个值。 如果第一个值（转化后）为false，则返回第二个值。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"运算符","slug":"运算符","permalink":"http://yoursite.com/tags/运算符/"}]},{"title":"Vue中动态添加路由的问题","slug":"Vue中动态添加路由的问题","date":"2020-01-06T01:52:42.000Z","updated":"2020-01-06T09:09:09.732Z","comments":true,"path":"2020/01/06/Vue中动态添加路由的问题/","link":"","permalink":"http://yoursite.com/2020/01/06/Vue中动态添加路由的问题/","excerpt":"","text":"起始前端的权限控制一直是一个可繁可简的问题，要想简单，直接写入所有路由，然后将每个路由的权限写入路由原信息中，然后在router.beforeEach中判断这个路由是否该用户的权限，进行reject()或者next()。这样做很简单，但是Vue提供了一个addRouter的api，用于动态注册路由，由此可以用这个api来根据用户角色进行动态路由注入。 问题动态注入路由后404问题一般我们将公共路由放置到路的初始化中，这其中就包括404页面，他的path一般是*,也就是匹配所有路由，因此Vue官方文档中提到： 当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: &#39;*&#39; } 通常用于客户端 404 错误。 所以我们一般将404放到静态路由的最后一个，但是当我们动态注入路由后，理论上来说，404的优先级应该比我动态注入的路由高，所以我第一使用动态注入时，所有页面跳转至404页面。开始以为是注入失败，后来将404页面删除就能够正常跳转了。 解决办法 所以我参照了element-ui-admin中的思路，没有使用*来匹配404页面，而是在router.beforeEach中，判断路由是否存在，手动跳转路由。 我在今天(2020-1-6)再次测试，发现Vue-router似乎对*进行了优化，即使将*的路由放到任意位置，包括首位，也会正确匹配路由，即当前所有路由中不存在时，才回去主动匹配*里有。当前使用的版本是：Vue(2.6.10)，Vue-router(3.1.3)，但是仅仅对*做了优化，其他通配符，比如/*并没有优化。 综合就是如果Vue-router版本够高，则可以使用*的方式来进行通配页面。 刷新路由消失的问题还有一个问题就是如果用户主动刷新浏览器，那么动态注入的路由就会生效，但是浏览器url并不会变，这个时候又会跳转至404。我这里采用的比较简答的方法就是在Vue实例初始化的时候进行重新注入。 在用户登录时将其用户标识信息存储至SessionStorage。 在Vue实例初始化时（第一次或刷新），首先应该是判断token，如果token失效，直接跳转至登录页。 如果token有效，再通过sessionStorage获取用户标识符，请求后端用户权限等级。再进行路由注入，并跳转至权限对应的页面。 因为刷新过程中整个页面的数据都会重新载入，所以我们必须使用一个持久化的容器，sessionStorage,localStorage,cookie都可以，但是我们不能将权限信息直接明文放到这些容器中，要么加密，要么只存储标识符，通过标识符再请求用户信息。 用户退出的问题使用router.addRouter的问题在于官方只提供了增加路由的api，并没有提供一个清除路由的api，这就导致如果同一个页面两个用户先后登录，那么就会出现路由重复注入，或者越级路由暴露的问题。经过查找资料，目前有两个主流的办法： 直接location.reload()刷新页面，重置整个Vue实例，路由当然也被重置。 优点 方便，一行代码解决问题。 缺点 如果页面应用过大，那么重新载入可能会花费一定的时间，会给用户不好的体验。 使用hack的方法，直接创建一个新的VueRouter，并将静态路由添加到新的路由中去，然后用新Router的matcher去替换就Router的matcher，这样相当于变相的清除了动态注入的路由。 优点 解决了上面刷新页面的问题。 缺点 官方没有提过使用该方法，所以可能会存在一定的问题，但是我发现element-ui-admin中也是使用的这个方法来实现路由清除，所以目前应该是不会有太大的问题。版本更新后就不一定了，也许后续官方就会推出清除路由的api。 附代码： 1234567891011121314151617181920//router.jsconst routes = [ /* 静态路由 */]const createRouter = () =&gt; &#123; return new VueRouter(&#123; routes &#125;);&#125;;const resetRouter = () =&gt; &#123; const newRouter = createRouter(); router &amp;&amp; (router.matcher = newRouter.matcher);&#125;;export &#123;resetRouter&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"动态路由","slug":"动态路由","permalink":"http://yoursite.com/tags/动态路由/"}]},{"title":"Vue中的插槽与keep-alive","slug":"Vue中的插槽与keep-alive","date":"2020-01-05T15:01:42.000Z","updated":"2020-01-05T15:02:43.462Z","comments":true,"path":"2020/01/05/Vue中的插槽与keep-alive/","link":"","permalink":"http://yoursite.com/2020/01/05/Vue中的插槽与keep-alive/","excerpt":"","text":"插槽初次真正接触插槽是在Elementui中的表格中在自定义列的内容时 12345678910111213&lt;el-table-column label=&quot;姓名&quot; width=&quot;180&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt;&lt;el-popover trigger=&quot;hover&quot; placement=&quot;top&quot;&gt; &lt;p&gt;姓名: &#123;&#123; scope.row.name &#125;&#125;&lt;/p&gt; &lt;p&gt;住址: &#123;&#123; scope.row.address &#125;&#125;&lt;/p&gt; &lt;div slot=&quot;reference&quot; class=&quot;name-wrapper&quot;&gt; &lt;el-tag size=&quot;medium&quot;&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;/el-tag&gt; &lt;/div&gt; &lt;/el-popover&gt; &lt;/template&gt;&lt;/el-table-column&gt; 在列中插入一个template用来放置我们自定义的内容，并且可以通过slot-scope=&quot;scope&quot;中的scope来获取这一列的row信息。 仔细看了官方文档才明白，插槽slot是用来接收父组件在调用子组件时，在子组件标签内添加添加的内容，这个内容可以时文字，标签，或是其他组件。并且可以在slot上通过v-bind绑定值传递到父组件（说起来也算是子组件向父组件传值哦~）。可以预见，在el-table-column组件中，肯定存在一个slot来接受父组件的template: 123&lt;el-table-column&gt; &lt;slot v-bind:rowRata=&quot;rowData&quot;&gt;&lt;/slot&gt;&lt;/el-table-column&gt; 值得注意的是：scope-slot,slot这两个语法在2.6.0之后都被官方废除，但是并未移除。在3.0中会被移除，取而代之的是新的v-slot指令。具体用法如下： 插槽的作用域值得重视的是，插槽总是在父组件中渲染的，引用官方的一句话： 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 这句话中的“在”字，即我们能看到的。即使是插槽这样传递到子组件中元素。 所以，插槽总是能访问父组件的数据，而不能访问子组件的数组。但是有时我们又必须访问子组件的数据怎么办呢？这就用到了v-slot（slot-scope）属性。 官方称之为 作用域插槽对于默认插槽（即default），可以通过开始的代码形式，来获取子组件的值，前提是在子组件中使用 v-bind将其绑定到slot上。 123456//父组件&lt;child&gt; &lt;template v-slot=&quot;defaultPorps&quot;&gt; &#123;&#123;defaultPorps.user.name&#125;&#125; &lt;/template&gt;&lt;child&gt; 123//子组件&lt;slot v-bind:user = &#123;&quot;name&quot;:&quot;tom&quot;&#125;&gt;&lt;/slot&gt; 还有一点值得注意的是，Vue将整个slot的所有bind值封装为一个对象，所以我们使用v-bind绑定的值仅仅是该对象的一个属性（但是我们可以通过ES6的解构方法来直接拿到属性值） 具名插槽这个就很简单的了，一个子组件可能具有多个插槽，我们可以必须为止加上名字来区分，（如果不加，比如上面的例子中，v-slot = “xxx”全称应该是 v-slot:default=”xxx”，默认名字就是default），使用方法如下： 123456//父组件中&lt;child&gt; &lt;template v-slot=&quot;slot1&quot;&gt;对应插槽1&lt;/template&gt; &lt;template v-slot=&quot;slot1&quot;&gt;对应插槽2&lt;/template&gt; &lt;template v-slot=&quot;slot1&quot;&gt;对应插槽3&lt;/template&gt;&lt;/child&gt; 123456//子组件中&lt;template&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;&lt;/template&gt; 另外v-slot也可以缩写为#，就像v-on缩写为@，v-bind缩写为: keep-alive这个属性之前没有尝试过，但是最近遇到有个组件想要在来回切换时保持状态，既保持用户观看的内容，开始是想手动记录用户的状态，后来发现Vue官方提供了这个抽象组件，正好解决了问题， keep-alive基本用法是缓存某些组件的状态，我们从Vue的生命周期函数中可以发现，在组件失活时，都会触发beforeDestroy生命周期函数，但是如果我们将其包裹在keep-alive标签下，那么这些组件在失活时，并不会调用beforeDestroy方法，而是调用activated和deactivated` 这两个生命周期钩子函数将会被对应执行。将其缓存起来。 keep-alive组件有3个porp. include - 字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max - 数字。最多可以缓存多少组件实例。 基本用法123456789101112131415161718192021222324252627//缓存所有的组件&lt;keep-alive&gt; &lt;component1&gt;&lt;/component1&gt; &lt;component2&gt;&lt;/component1&gt; &lt;component3&gt;&lt;/component1&gt;&lt;/keep-alive&gt;//缓存特定组件&lt;keep-alive inlude=&quot;component1&quot;&gt; &lt;component1&gt;&lt;/component1&gt; &lt;component2&gt;&lt;/component1&gt; &lt;component3&gt;&lt;/component1&gt;&lt;/keep-alive&gt;//不缓存特定组件&lt;keep-alive exclude=&quot;component2&quot;&gt; &lt;component1&gt;&lt;/component1&gt; &lt;component2&gt;&lt;/component1&gt; &lt;component3&gt;&lt;/component1&gt;&lt;/keep-alive&gt;//规定最多缓存2个组件&lt;keep-alive max=&quot;2&quot;&gt; &lt;component1&gt;&lt;/component1&gt; &lt;component2&gt;&lt;/component1&gt; &lt;component3&gt;&lt;/component1&gt;&lt;/keep-alive&gt; 当然，也可以配合Vue-router。来进行使用： 配合路由在使用Vue-router进行组件选择性渲染的时候，我们同样也可以使用keep-alive，因为&lt;router-view&gt;&lt;/router-view&gt;组件是一个抽象路由，并不会真正创建一个组件结构在整个文档结构中，所以keep-alive对其仍然有效。代码如下： 12345678910111213141516171819202122232425262728293031323334//router.jsimport Vue from 'vue'import Router from 'vue-router'import Home from './views/Home.vue'import Login from './views/Login.vue'import Register from \"./views/regisetr.vue\"Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'home', component: Home &#125;, &#123; path: '/about', name: 'about', componet: About &#125;, &#123; path: '/login', name: 'login', component: Login &#125;, &#123; path: '/register', name: 'register', component: Register &#125; ]&#125;) 12345678910 &lt;transition :duration=&quot;500&quot; mode=&quot;out-in&quot; enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated bounceOutDown&quot; &gt; &lt;keep-alive exclude=&quot;Login,Register&quot; max=2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 上面的代码即表示，不缓存Login,Register组件，并且最多缓存2和组件。 *值得注意的是，当同时使用transiton组件与keep-alive组件时，transiton组件必须位于外层，很容易想明白，keep-alive组件对其内部的组件进行管控，如果将transiton组件放置到其内部，即使它是抽象组件，也会被被keep-alive组件管控，导致不正常**","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"插槽","slug":"插槽","permalink":"http://yoursite.com/tags/插槽/"},{"name":"keep-alive","slug":"keep-alive","permalink":"http://yoursite.com/tags/keep-alive/"}]},{"title":"Vue中的组件传值","slug":"Vue中的组件传值","date":"2020-01-05T10:05:01.000Z","updated":"2020-01-05T10:05:43.170Z","comments":true,"path":"2020/01/05/Vue中的组件传值/","link":"","permalink":"http://yoursite.com/2020/01/05/Vue中的组件传值/","excerpt":"","text":"父 =&gt; 子父组件向子组件传值比较简单，直接使用v-bind:key = val 1234//父组件&lt;template&gt; &lt;child :name = &quot;&apos;tom&apos;&quot; :age=&quot;&apos;12&apos;&quot; /&gt;&lt;/template&gt; 12345678910//子组件&lt;template&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125; &lt;div&gt;&lt;/template&gt;&lt;sctipt&gt; props:[&quot;name&quot;,age]&lt;/sctipt&gt; 这样在子组件中可以显示父组件给子组件传的值。 值得注意的是：在子组件中可以对父组件穿的值进行检验。 123456789101112131415161718192021222324252627282930//子组件&lt;template&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125;----&#123;&#123;id&#125;&#125;----&#123;&#123;address&#125;&#125;---&#123;&#123;email&#125;&#125; &lt;div&gt;&lt;/template&gt;&lt;sctipt&gt; props:&#123; //验证为字符串 &quot;name&quot;:String, //验证为数字 &quot;age&quot;:Number, //验证为字符串或者数组 &quot;id&quot;:[String,Number], //验证为必须传递的字段，并且默认值为北京 &quot;address&quot;:&#123; required:true, default:function()&#123; return &quot;北京&quot; &#125; &#125;, //进行高级验证 &quot;email&quot;:&#123; validator: function(val)&#123; return /^([a-zA-Z]|[0-9])(\\w|\\-)+@[a-zA-Z0-9]+\\.([a-zA-Z]&#123;2,4&#125;)$/.test(val) &#125; &#125; &#125;&lt;/sctipt&gt; 子 =&gt; 父一般不推荐子组件向父组件传值，即父 =&gt; 子的单向数据流会使整个项目更加容易维护。否则无法维护项目的整体性，组件内的状态可能会发生不在预期之内的改变。 但有时又必须通过子组件来改变父组件的值，则Vue官方提供了子组件与父组件通信的方法。借用这个通信的方法可以顺势进行传值。 1234567891011121314151617181920//父组件&lt;template&gt; &lt;child @getData = getData/&gt; &#123;&#123;val&#125;&#125;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; val:&quot;父组件的值&quot; &#125; &#125;, methods:&#123; getData(val)&#123; this.val = val; &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021//子组件&lt;template&gt; &lt;button @click=&quot;sendData&quot;&gt; 向父组件传值 &lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; val:&quot;子组件的值&quot; &#125; &#125;, methods:&#123; sendData(val)&#123; this.$emit(&quot;getData&quot;,this.val); &#125; &#125;&#125;&lt;/script&gt; 即利用v-on为子组件 添加一个自定义时间，并将父组件的特定方法传入这个监听事件。 在子组件中调用this.$emit(&#39;funcName&#39;,args...)来调用父组件的方法，并利用参数将值传入至父组件。 同级组件同级组件或者跨多级组件则可以使用vuex来进行数组的传输。具体就不在这里讨论vuex。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"组件传值","slug":"组件传值","permalink":"http://yoursite.com/tags/组件传值/"}]},{"title":"Vue中异步请求更新data导致数据变为非响应式的问题","slug":"Vue中异步请求更新data导致数据变为非响应式的问题","date":"2020-01-05T04:22:40.000Z","updated":"2020-01-05T07:27:21.749Z","comments":true,"path":"2020/01/05/Vue中异步请求更新data导致数据变为非响应式的问题/","link":"","permalink":"http://yoursite.com/2020/01/05/Vue中异步请求更新data导致数据变为非响应式的问题/","excerpt":"","text":"问题最近在项目遇到一个棘手的问题，看了1天才发现是异步与Vue的数据更新机制导致了结果与预期不一致。 最开始的代码流程是这样： 通过一个请求拿到一组数据data1，包括下一个请求的关键字 在第一个请求的回掉函数中使用for循环利用上一个数组的关键字发送多个子请求得到对应的datan，并在每个子请求的回调中对data1和datan进行对比，然后给data1添加一个字段key 在第一个请求的回调中把修改后的data1赋给Vue实例的data中 产生的问题在Vue实例中的data1对象中，原来的数据都是响应式的，但是我后来添加的数据并不是响应式的，导致DOM不更新。 解决过程产生问题后我先后大概经过了3次修改来解决这个问题： 思路一：data转换为响应式的时间首先我从响应式这个角度去分析，Vue是在哪个生命周期函数内将data挂载到Vue实例中的(因该是在beforeCreate与created之间)，而我做这些操作是在mounted，所以此时data因该已经被挂载到了Vue实例中，后来我又在思考JS中存在变量提升，是不是Vue中也存在，即是否在mounted中存在譬如this.xxx = yyy这样的语句会被提升到其他语句之前执行，yyy的内存地址提前就会被写入到this.xxx的位置，然后在这个内存地址被赋值时就将其变为响应式，所以第一次data1被赋值为一个数组时他是响应式的，但是后面对这个内存地址的变量进行的操作是为数组内的对象进行赋值this.data1[i].key = val，这样的赋值是无法被Vue探测到的，所以其后添加的属性无法变为响应式。这样子似乎一切都说的通，但是关键是这种变量提升这个东西我之前从未在Vue中遇到过，我查阅资料也发现根本不存在这种机制。于是这个说法被PASS。 不过这个过程中我也复习了一下生命周期函数和Vue中数组对象的处理： Vue生命周期引用官方的一张图： 值得注意的是：data，methods等都是在beforeCreated与created之间进行的。经常使用的mounted已经是在模板已经编译完成之后了。 Vue中对数组和对象的处理对于动态更新DOM最基本的原理是定义一个变量的getter和setter，在其中触发更新DOM操作，对于数组，我们整个赋值，我们可以使用getter和setter监听，但是如果我们操作数组内部的元素，比如arr[1] = 0，这样的操作我们是无法监听到的，因此在Vue中，如果这样给data赋值，这个值并不会变为响应式，而是一个普通的值。具体有 数组 通过索引去修改数组中的值，arr[i] = val 直接修改数组的长度，arr.length = n 对象 给对象添加属性（包括data根节点，比如没有在data中初始化某个值，在后续直接使用this.data1 = {}，这样data1无法变为响应式，dev模式下console会报错） 删除对象属性，（包括data根节点） 对于以上的问题，Vue提供了vm.$set这个api来解决。 对于数组的第一个问题，可以使用以下方式来解决： vm.$set(vm.data1,index,val) 对于数组的第二个问题，可以使用数组的方法来解决： vm.data1.splice(3) //data1会被切割为0-3项 原因是Vue在内部也修改了Array原型链上的方法，使其能够被Vue监听到，包括： push() pop() shift() unshift() splice() sort() reverse() 思路二：请求异步的问题这一次我似乎意识到了可能是异步的问题，因为之前玩canvas时，也是一直结果达不到预期，结果是img标签的onload事件是一个异步事件，导致结果不对。再仔细看这次的代码，可以发现，在第一次请求回调内部，由于接下来的子请求又是异步事件，所以直接执行了最后的this.data1 = data1。在子请求回掉函数执行时，data1已经被挂载到vm.data中，此时再对其进行添加属性处理，相当于是上面的对象添加属性的问题。所以必然是非响应式的。于是我this.data1 = data1放到子请求的回调中，每接受一次回调执行一次，虽然感觉这样很消耗性能。 但是结果是，data1数组中只有一个值的属性变为了响应式，其他的数组值仍然是非响应的。。。至少结果逼近真相了。 思路三：Vue对于data赋值的性能优化在Vue中，有一个异步更新队列，在Vue检测到data的值改变时，会将其写入异步更新队列中，在下一个事件循环中去进行DOM跟新等等。并且在这个队列中，会对数据写入进行优化，比如this.data1原来等于1,接下来执行了两句赋值，this.data1 = 3;this.data1 = 1;并且这两句在同一个tick（事件循环队列）中，那么Vue就不会对data1进行操作了。 那么这里极可能是在极短的时间内对data1进行了两次赋值，Vue将这两次操作优化，第一次是整个赋值，第二个则只对修改的部分进行了变更，但是前面又说道，Vue没办法探测数据内容或对象属性的添加操作。所以第一个是响应式的，而第二个则不是响应式的。 所以唯一的解决办法就是只进行一次data1的根赋值，所以我想到了 axios.all这个api，它是在所有请求完成之后返回并进行回调函数。在该回调函数中进行数据处理，再直接将data1赋给vm实例上。 成功解决 总结还是不太够仔细，异步这样的问题不能立即看出来，导致前面走了很大的弯，还好后面分析过程比较正确，找到了我呢提所在。不过也好，重温了一下，生命周期，Vue对数组和对象的处理等等。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"},{"name":"响应式数据","slug":"响应式数据","permalink":"http://yoursite.com/tags/响应式数据/"}]},{"title":"2019年的我，21岁的人生","slug":"2019年的我，21岁的人生","date":"2020-01-04T02:59:17.000Z","updated":"2020-01-08T15:38:37.033Z","comments":true,"path":"2020/01/04/2019年的我，21岁的人生/","link":"","permalink":"http://yoursite.com/2020/01/04/2019年的我，21岁的人生/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"不知道密码就别猜了，这是我得小秘密，哈哈哈\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"2020","slug":"2020","permalink":"http://yoursite.com/tags/2020/"}]},{"title":"react中的事件绑定","slug":"react中的事件绑定","date":"2019-12-22T08:39:36.000Z","updated":"2019-12-22T09:51:52.269Z","comments":true,"path":"2019/12/22/react中的事件绑定/","link":"","permalink":"http://yoursite.com/2019/12/22/react中的事件绑定/","excerpt":"","text":"遇到的问题最近想试一下React，之前一直用Vue在写东西。稍微看了几篇教程后，就开始写，能够基本运行起来，可能是因为项目比较简单吧。但是也遇到了几个问题，首先就是React的事件绑定问题： 我第一次的写法是： 12345handleEvent()&#123; console.log(\"test\")&#125;&lt;Button onClick=\"handleEvent\"&gt; &lt;/Button&gt; 这样普通的点击事件是能够正常触发的。 this的指向问题但是当我要使用this时，这种写法就出了问题。 1234567handleEvent()&#123; this.setState(&#123; state1 : 111 &#125;)&#125;&lt;Button onClick=\"handleEvent\"&gt; &lt;/Button&gt; 这样就会报错this为undefined的。于是我就想起了之前看过的文章以及结合之前对JavaScript的函数的this分析。就明白此时函数在调用时不是被react对象直接调用的。所以该函数的this的指向为undefined。所以要想使用react对象的方法，只有将函数的this指向为react。根据之前文章对this的分析，要想绑定this，可以使用： call（一次绑定并调用） apply （一次绑定并调用） bind（永久绑定） 箭头函数 () =&gt; {}永久绑定 但是事件是要多次调用并且不是绑定时就调用，而是事件被触发时才调用，所以排除call与apply方法。所以选择bind与箭头函数为最佳(后来看官方文档时发现官方也是推荐了这两种方法来绑定this)。 所以有以下方法： 在构造函数中绑定函数的this指向 12345678910constructor(props)&#123; super(props) this.handleEvent = this.handleEvent.bind(this)&#125;handleEvent()&#123; console.log(this) //此时指向react对象&#125;&lt;Button onClick=&#123;handleEvent&#125;&gt;&lt;/Button&gt; 在事件绑定时绑定函数this 12345handleEvent()&#123; console.log(this) //此时指向react对象&#125;&lt;Button onClick=&#123;this.handleEvent.bind(this)&#125;&gt;&lt;/Button&gt; 至此，this的指向问题基本解决。 函数传参的问题接下来遇到需要传参的函数。我使用了与Vue与原始HTML同样的写法 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;this.handleEvent(\"123\")&#125;&gt;&lt;/Button&gt; 当我尝试触发事件时，发现事件触发不成功，并且在打开控制面板时发现在页面初始化时，该事件被自动触发了3次，点击按钮无法触发。于是我不禁思考JSX的语法，让我想到了EL表达式，EL表达式中的代码会被直接运行，该位置会被填充为运行后的结果。再来看这个问题就发现自己的问题了。 {}内的代码在JSX模板编译时被当成代码直接运行，而tihs.handleEvent(&quot;123&quot;)在JavaScript中不就是直接运行函数吗，所以函数在模板编译时直接被运行了，而onClick的事件则被绑定为函数的返回值，但是这个函数没有返回值，所以事件绑定失败。 所以如何解决这个问题就很简单了，只要在事件绑定的位置放置一个函数而不是函数的调用就行了,方法也有两个： bind方法传参 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;this.handleEvent.bind(this,\"123\")&#125;&gt;&lt;/Button&gt; 箭头函数 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;() =&gt; &#123;this.handleEvent(123)&#125;&#125;&gt;&lt;/Button&gt; 折腾一下在看到箭头函数时我又思考能不能不用箭头函数，直接用匿名函数实现函数的调用。像这样： 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;function(para)&#123;this.handleEvent(para)&#125;&#125;&gt;&lt;/Button&gt; 再一想发现好想更不行，匿名函数没有绑定this指向。所以也就拿不到this.handleEvent()函数了。那就试试绑定一下匿名函数的this指向，像这样： 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;function()&#123;this.handleEvent(123)&#125;.bind(this)&#125;&gt;&lt;/Button&gt; OK，事件成功绑定，但是转念一想，这么搞还不如直接bind原函数，也避开了使用箭头函数。纯属折腾吧。 获取事件对象event在Vue或者原生HTML中，event被存储在window下的event对象中，在绑定事件时将event对象传入即可获得点击事件对象。 但在React中，我们可以这么做： 当我们不需要为这个函数传参时，event对象会自动传入该函数，我们通过第一个参数获取event对象 当我们需要传参时，我们需要手动传入event对象 12345678handleEvent = (para,e) =&gt; &#123; console.log(para) console.log(e)&#125;&lt;Button onClick=&#123;(e) =&gt; &#123;this.handleEvent(123,e)&#125;&#125;&gt;&lt;/Button&gt;//或者这样&lt;Button onClick=&#123;this.handleEvent(123,e)&#125;&gt;&lt;/Button&gt; Last至此，React中的函数事件绑定基本可以搞定。写了一段时间的React，感觉相较于Vue，更灵活。刚入手的话，习惯了Vue模板文件的 &lt;template&gt; &lt;style&gt; &lt;script&gt;这种分明的设计，React中的JSX写起来感觉有点复杂。在对比anted与elemenui，感觉elementui的api简直太简单了。后期在多体验看看吧！","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"事件绑定","slug":"事件绑定","permalink":"http://yoursite.com/tags/事件绑定/"}]},{"title":"CSS伪类与伪元素","slug":"CSS伪类与伪元素","date":"2019-11-20T14:54:39.000Z","updated":"2019-11-21T07:06:34.306Z","comments":true,"path":"2019/11/20/CSS伪类与伪元素/","link":"","permalink":"http://yoursite.com/2019/11/20/CSS伪类与伪元素/","excerpt":"","text":"伪类？伪元素？之前一度认为伪类就是一组选择器，伪元素是不在DOM树的中的一些元素。但是当我看完MDN上的所有伪类与伪元素之后，才发现伪类与伪元素同属于CSS选择器的范畴，而伪元素其特殊之处在于伪元素可以选择的是一些不在DOM树中的元素，比如::selection用于选中用户用鼠标勾选的字符串；当然也可以选择在DOM树中的元素，比如::first-line用于选中元素的第一行，在特殊一点说，伪元素多用于选择一些特殊的东西，而伪类用于元素级别的选择，比如:nth:child用于选择某元素的第n个 由上面可以看出基本看做：元素级别的选择器用伪类，元素内的选择器与特殊选择器用伪元素 实际上最好的方法就是记住伪类与伪元素主要有哪些、特别是伪元素并不多。 伪类状态伪类 选择器 示例 说明 :link a:link 选择所有未访问的链接 :visited a:visited 选择所有访问过的链接 :hover a:hover 鼠标悬浮在链接上的状态 :active a:active 选择在激活状态的链接 :focus input:focus 选择获取焦点的输入框元素 :focus-within form:focus-within 用在父级元素上，当子元素获得焦点时，父元素获得对应属性(IE未实现) 结构化伪类 选择器 示例 示例说明 :first-child :first-child 选择p元素的第一个子元素 :first-of-type p:first-of-type 选择每个父元素是p元素的第一个p子元素 :last-child p:last-child 选择所有p元素的最后一个子元素 :last-of-type p:last-of-type 选择每个p元素是其母元素的最后一个p元素 :not(selector) :not§ 选择所有p以外的元素 :nth-child(n) p:nth-child(2) 选择所有p元素的第二个子元素 :nth-last-child(n) p:nth-last-child(2) 选择所有p元素倒数的第二个子元素 :nth-last-of-type(n) p:nth-last-of-type(2) 选择所有p元素倒数的第二个为p的子元素 :nth-of-type(n) p:nth-of-type(2) 选择所有p元素第二个为p的子元素 :only-of-type p:only-of-type 选择所有仅有一个子元素为p的元素 :only-child p:only-child 选择所有仅有一个子元素的p元素 :target #news:target 选择当前活动#news元素(点击URL包含锚的名字) 表单伪类 选择器 示例 示例说明 :disabled input:disabled 选择所有禁用的表单元素 :enabled input:enabled 选择没有设置 disabled 属性的表单元素 :required input:required 选择设置 required 属性的表单元素 :read-only input:read-only 选择设置 readonly 只读属性的元素 :read-write input:read-write 选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。 :checked input:checked 匹配被选中的 input 元素，input 元素包括 radio 和 checkbox :empty p:empty 匹配所有没有子元素的 p 元素 :in-range input:in-range 选择在指定区域内的元素 :out-of-range input:out-of-range 选择不在指定区域内的元素 :valid input:valid 选择条件验证正确的表单元素 :invalid input:invalid 选择条件验证错误的表单元素 :optional input:optional 选择没有 required 属性，即设置 optional 属性的表单元素 :default - 匹配默认选中的元素(提交按钮总是表单的默认按钮)。 :indeterminate - 当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。 :scope - 匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。(试验阶段) 伪元素单双冒号 选择器 作用 说明 ::before/:before 在被选元素前插入内容。 需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。 ::after/:after 在选被元素后插入内容 其用法和特性与:before相似。 ::first-letter/:first-letter 匹配元素中文本的首字母。 被修饰的首字母不在文档树中。 ::first-line/:first-line 匹配元素中第一行的文本。 这个伪元素只能用在块元素中，不能用在内联元素中。 双冒号 选择器 作用 说明 ::selection 匹配被用户选中或者处于高亮状态的部分. 在火狐浏览器使用时需要添加 -moz 前缀。 ::placeholder 匹配占位符的文本。 只有元素设置了 placeholder 属性时，该伪元素才能生效。 LAST对于伪类与伪元素，最好的不是区分它们，而是记住常用的选择器是属于伪类还是伪元素。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"伪元素","slug":"伪元素","permalink":"http://yoursite.com/tags/伪元素/"},{"name":"伪类","slug":"伪类","permalink":"http://yoursite.com/tags/伪类/"}]},{"title":"CSS3过渡与动画","slug":"CSS3过渡与动画","date":"2019-11-18T13:13:17.000Z","updated":"2019-11-19T01:23:21.050Z","comments":true,"path":"2019/11/18/CSS3过渡与动画/","link":"","permalink":"http://yoursite.com/2019/11/18/CSS3过渡与动画/","excerpt":"","text":"CSS3-过渡 CSS3中，我们为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript。 使用transition属性，CSS3会自动为属性的变化来添加过渡样式。这个属性一般可以用在:hoevr :active等伪元素切换。 transition也是一个复合属性： 1234tag&#123; transition:transition-property ransition-duration transition-timing-function transition-delay; &#125; 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 transition-property该属性用于定义需要渐变的CSS属性，比如color width等。 可选值 描述 none 没有过渡动画。 all 所有可被动画的属性都表现出过渡动画。 IDENT 性名称。由小写字母 a 到 z，数字 0 到 9，下划线（_）和破折号（-）。第一个非破折号字符不能是数字。同时，不能以两个破折号开头。 transition-duration该属性定义渐变的时间，要带单位（s,ms）。 transition-timing-function这个属性是过渡的核心。引用MDN官方的描述： CSS属性受到 transition effect的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变。 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 step-start 直接跳到结束处 step-end transition-duration steps() 步进函数将过渡时间分成大小相等的时间时隔来运行没有过度效果，而是一帧一帧的变化，integer等于几就分成几帧，阶跃函数 steps()函数steps(&lt;integer&gt;[,start| end]?) :用于指定间隔个数（该值只能是正整数） 第二个参数可选，默认是end,表示开始值保持一次，若参数为start，表示开始值不保持 end:用于指定在step中间隔数少于该有的变化次数时，因该丢弃前面的部分还是后面的部分。 123456789即每个关键帧都分成两次变化完成，则一共有七次变化。七帧 一共变化七次， div本身没有颜色，所以最终的背景无色。但是，只变化七次，有七种颜色，加上无色，一种八种状态，所以需要丢弃一种状态start 橙、黄、灰、蓝、深灰蓝、绿、无色 原理：去掉第一帧的效果，end 红、橙、黄、灰、蓝、深灰蓝、无色原理：去掉最后一帧的效果 cubic-bezier(n,n,n,n)贝塞尔曲线函数的四个值，具体原理后面研究一下再写一篇博客。 transition-delay CSS的transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 下面写个例子 12345678910div&#123; width:120px; color:red; transition:all 0.5s ease 1s; &#125;div:hover&#123; width:200px; color:blue;&#125; 这段代码设定在鼠标划过时，所有的属性在1s后开始过渡，过渡时间为0.5s，过渡方式为ease。 CSS动画CSS3中，我们可以用2个属性来定义函数。 @keyframes animation 利用这两个属性可以制作简单或复杂的CSS东阿虎 @keyframes @keyframes 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。这比转换更能控制动画序列的中间步骤。 Point： 如果一个关键帧规则没有指定动画的开始或结束状态（也就是，0%/from 和100%/to，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。 如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 如果多个关键帧使用同一个名称，以最后一次定义的为准。 @keyframes 不存在层叠样式(cascade)的情况，所以动画在一个时刻（阶段）只会使用一个的关键帧的数据。 如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 因为@keyframes 的规则不存在层叠样式(cascade)的情况，即使多个关键帧设置相同的百分值也不会全部执行。 如果某一个关键帧出现了重复的定义，且重复的关键帧中的css属性值不同，以最后一次定义的属性为准。例如： 123456@keyframes identifier &#123; 0% &#123; top: 0; left: 0px&#125; 50% &#123; top: 30px; left: 20px; &#125; 50% &#123; top: 10px; &#125; 100% &#123; top: 0; left: 30px;&#125;&#125; 上面这个例子中，50% 关键帧中设置的属性top: 10px是有效的，但是其他的属性会被忽略 关键帧中出现的 !important 关键词将会被忽略 @keyframes格式如下： @keyframes 动画名字 { ​ 阶段名:{ ​ 元素属性 ​ } } 其中阶段名可以百分比或者from/to example: 1234567@keyframes mykeyframes&#123;0% &#123;background:red;&#125;25% &#123;background:yellow;&#125;50% &#123;background:blue;&#125;100% &#123;background:green;&#125;&#125; 这样就新建了一个动画关键帧，现在我们就需要使用animation将其添加到对应的元素上。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"过渡","slug":"过渡","permalink":"http://yoursite.com/tags/过渡/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}]},{"title":"函数的防抖与节流以及一些总要的函数模式","slug":"函数的防抖与节流以及一些总要的函数模式","date":"2019-11-17T12:25:01.000Z","updated":"2021-02-17T09:41:09.241Z","comments":true,"path":"2019/11/17/函数的防抖与节流以及一些总要的函数模式/","link":"","permalink":"http://yoursite.com/2019/11/17/函数的防抖与节流以及一些总要的函数模式/","excerpt":"","text":"防抖（debounce）在学习单片机开发时，按键防抖非常重要，我们必须使用一定的方法来进行防抖，否则会造成一次按键按键的多次触发的情况。而在JavaScript中，同样会有这样的问题，即在用户进行持续性的操作时，在用户大概率完成后，在进行后续操作（请求服务器，浏览器渲染等）。如果不进行防抖操作，会导致服务器或浏览器的性能浪费。 其具体定义：是指某一操作会被频繁触发，在一定时间内，该操作只会触发一次。 下面是一个函数实现： 1234567891011function debounce(fun, delay) &#123; return function (arguments) &#123; //获取函数的作用域和变量 let that = this; let args = arguments; clearTimeout(fun.id) // 清除定时器 fun.id = setTimeout(function () &#123; fun.call(that, args) &#125;, delay) &#125;&#125; 该函数接受一个目标函数与延迟，该函数内部返回了一个函数，并将目标函数的id设为定时器的id。如果第一次调用该函数，会设置一个定时器，设定在delay毫秒后执行目标函数，但是如果在delay毫秒时间内再次调用该函数的防抖函数，那么就会清除掉目标函数的定时器，也就不会执行了。并再次设置一个定时器，循环以上步骤。 节流（Throttle）节流更是一个重要的概念，特别是在进行渲染的操作时（比如，mousemove，scoll），如果不进行节流，那么浏览器将会消耗很多性能，致使页面卡顿与操作不流畅。 具体定义：是指在一定的时间内值允许函数执行特定次数。 123456789101112131415161718192021function throttle(fun,delay)&#123; let _self = fn, timer, firstTime = true; return function()&#123; let atgs = arguments _this = this if(firstTime)&#123; _self.apply(_this, args) return firstTime = false &#125; if(timer)&#123; return false &#125; timer = setTimeout(function()&#123; clearTimeout(timer) timer = null _self.apply(_this, args) &#125;, delay||500) &#125;&#125; 该函数的核心是在：在外部先判断目标函数fun的timer属性是否为空。如果为空，则代表一次函数还未执行完，则直接返回。否则则设定目标函数的timer属性为一个定时器，在定时器的函数中将timer清空，并执行目标函数。 2021/2/17最近在读《JavaScript设计模式与开发实践》，发现除了函数的节流与防抖，还有一些高级函数模式，可以用来解决一些问题。 分时函数当一个任务需要进行大量同类操作，此时可能会造成页面的卡顿。此时，为了防止页面卡顿，我们要把单个大型任务分割成为多个小的任务，典型的场景是：大量数据插入表格。 我们把但分时函数代码如下： 12345678910111213141516171819let timeChunk = function(ary, fn, count)&#123; let obj let t let len = ary.length let start = function()&#123; for(let i = 0; i &lt; Math.min(count || 1, ary.length); i++)&#123; let obj = ary.shift() fn(obj) &#125; &#125; return function()&#123; t = setInterval(function()&#123; if(ary.length === 0)&#123; return clearInterval(t) &#125; start() &#125;, 200) &#125;&#125; 比如我们需要添加1000调信息到页面中，我们采用每次创建8个节点。 123456789101112let ary = []for(let i = 1; i &lt;= 1000; i++)&#123; ary.push(i)&#125;let renserList = timeChunk(ary, function(n)&#123; let div = document.createElement('div') dic.innerHTML = n document.body.appenChild(div)&#125;, 8)renderList() 惰性加载函数当一个任务在执行之前后悔事先执行一些预先性工作，并且这些工作在每次执行时的结果都是一样的，那我们可以在第一次得到结果后就将其凝固，在以后的每一次执行时就可以减少判断次数，提高性能。 一个典型的场景就是浏览器能力检测，常见的写法如： 12345678let addEvent = function(elem, type, handler)&#123; if(window.addEventListener)&#123; return elem.addEventListener(type, handler, false) &#125; if(window.attachEvent)&#123; return elem.attachEvent('on' + type, handler) &#125;&#125; 这个函数的缺点是，当它每次被调用的时候都会执行里面的if条件分支，虽然执行这些if分支的开销不算大，但也许有一些方法可以让程序避免这些重复的执行条件。如下面的方案就是在最开始调用一次判断，后续调用该函数时，就不会再进行判断了： 123456789101112let addEvent = (function()&#123; if(window.addEventListener)&#123; return function(elem, type, handler)&#123; elem.addEventListener(type, handler, false) &#125; &#125; if(window.attachEvent)&#123; return function(elem, type, handler)&#123; return elem.attachEvent('on' + type, handler) &#125; &#125;&#125;)() 第三种方案就是我们的懒加载函数，代码如下： 123456789101112let addEvent = function(elem, type, handler)&#123; if(window.addEventListener)&#123; addEvent = function(elem, type, handler)&#123; elem.addEventListener(type, handler, false) &#125; &#125;else if(window.attachEvent)&#123; addEvent = function(elem, type, handler)&#123; elem.attachEvent('on'+type, handler) &#125; &#125; addEvent(elem, type, handler)&#125; 这个函数在第一次调用时，会根据条件分支，对addEvent事件进行重载，并且对其进行调用一次。这个函数不必判断第一次，而是自动在第一次时重载，很妙。 这里有一个知识点是，在具名函数的执行过程中是可以对具名函数进行重新赋值的。 summary总体来说，在进行某些操作时，比如表单实时验证或者绘图的操作等，函数的防抖与节流会大幅度节省服务器与浏览器的性能！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"防抖","slug":"防抖","permalink":"http://yoursite.com/tags/防抖/"},{"name":"节流","slug":"节流","permalink":"http://yoursite.com/tags/节流/"}]},{"title":"Vue中局部修改组件样式","slug":"Vue中局部修改组件样式","date":"2019-11-17T11:52:19.000Z","updated":"2019-11-17T12:18:40.077Z","comments":true,"path":"2019/11/17/Vue中局部修改组件样式/","link":"","permalink":"http://yoursite.com/2019/11/17/Vue中局部修改组件样式/","excerpt":"","text":"Vue如何修改子组件样式在使用element-ui或者i-view这些第三方样式库时，我们有时会想只在某一个组件中局部修改库中的样式而部影响全局样式。 首先我们需要打开控制器找到对应组件的CSS样式的类名或者id 有以下几种方式 不在style样式上添加scope属性&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;el-input&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .father el-input{ color:red; } &lt;/style&gt; 这样相当于只修改father类下的el-input的属性。 使用 &gt;&gt;&gt; 穿透scope的用处scoped是Vue里面style标签的一个特殊属性，当一个style标签拥有scoped属性的时候，就相当于说明它里面的样式只作用于当前这个Vue页面，不会污染到全局的样式，从而实现了组件样式的模块化，那么它是怎么实现的呢？其实如果我们给style标签加上了scoped属性，在编译的时候，他会给我们组件里面的每一个样式加一个自定义的属性data-v-5558821a,从而通过给含有这个自定义属性的标签加上样式，从而实现了部分样式的穿透。 &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;el-input&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; .father &gt;&gt;&gt; el-input{ color:red; } &lt;/style&gt; 如果使用的是less或者sass可以将 &gt;&gt;&gt; 换为 /deep/ &lt;style scoped&gt; .father /deep/ el-input{ color:red; } &lt;/style&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"CSS3-转换","slug":"CSS3-转换","date":"2019-11-05T01:23:39.000Z","updated":"2019-11-08T09:18:21.422Z","comments":true,"path":"2019/11/05/CSS3-转换/","link":"","permalink":"http://yoursite.com/2019/11/05/CSS3-转换/","excerpt":"","text":"CSS3中的转换CSS3中的转换可以形成简单的动画，对于页面的小优化有点金的效果。 CSS3中的转换都在transform属性中定义，在该属性中定义其他函数来进行不同的转换。 CSS3的2D转换translate()该函数接受两个参数，分别是其x，y轴的偏移量，右下为正方向。 transform:translate(50px,100px); 将原元素向右、下移动50px、100px。 如果只填一个参数，则默认为x轴偏移。 transform:translate(50px); 向x轴移动50px; transform:translate(0,100px); 向y轴移动100px； rotate()该函数接受一个参数，确定偏移的角度，正值为顺时针，负值即为逆时针。 transform: rotate(30deg);//顺时针30度 transform: rotate(-30deg);//逆时针30度 scale()该函数接受两个参数，分别为x轴的倍数，y轴的倍数。 scale(2,3); 将容器宽度放大2倍，高度放大3倍。 skew()通过 skew() 方法，元素将偏斜相应的角度，注意这个偏斜与rotate(旋转)不同，skew将会绕x,y轴偏斜x,y度，观察到的肉眼的形状会改变！比如只偏斜某一轴，则原元素会变成一个平行四边形。(与其他转换一样，其内容也会做对应的变换) transform: skew(30deg); transform: skew(0deg,30deg); transform: skew(30deg,30deg); matrix()matrix() 方法把所有 2D 转换方法组合在一起。默认值为：transforms:matrix(1,0,0,1,0,0); matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 matrix原意是矩阵，所以这六个参数分别是矩阵的6个位置的值： matrix(a,b,c,d,e,f) 也就是利用这个矩阵与原容器做运算后获得新位置。 所以我们运算过后的结果就是： x’=ax+cy+e y’=bx+dy+f 移动所以根据这个式子，我们可以推算如果要对元素进行x轴移动，则x’直接增大固定数值，即改变e的值： 向x轴移动10px，y不变 matrix(1,0,0,1,10,0) 向x,y轴都移动10px matrix(1,0,0,1,10,10) 缩放缩放的实质就是奖x，y轴的数值放大n倍，即： x’=2y y’=2x 对于上面的： x’=ax+cy+e y’=bx+dy+f 可得到： nx = ax+cy+e ny = bx+dy+f 易得： a = nb = 0c = 0d = ne = 0f = 0 即，进行缩放的话，我们只需要修改a,d的值以修改宽,高的缩放程度 旋转利用极坐标，我们可以算出偏移角度与元素某点的坐标的关系。 根据原理图得： 推算可以得到： 所以，我们得： a = cosθ b = -sinθ d = sinθ e = cosθ 所以改变abde，即可实现旋转。 偏移同样由数学知识 即： b = tanθxe = tanθy 所以，skew操作只与b、e相关。 不过如果不是利用CSS3来做一些复杂的变换，可以用这种方式来减少代码。否则最好不要使用这个函数，因为它可能会使你的调试复杂困难。 transform-origin()该属性确定转换的基点位置。 example: transform-origin:20px 20px; 规定变换的基点为：(x=)20px (y=)20px 其值可以为： left center right length % CSS3的3D转换我们在2D之中，我们看过“translate，scale，rotate”这三个变换属性。在3D变换中，这三个属性被拆分3个方向的分属性： translate() translateX() translateY() translateZ() scale() scaleX() scaleY() scaleZ() ratate() rotateX() rotateY() rotateZ() 每个方向上的分量分别是沿某一轴变换。比如：translateX(120)表示沿X轴正方向移动120px。 另外3D还有几个属性： transform-styleCSS 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。 flat 设置元素的子元素位于该元素的平面中。 preserve-3d 指示元素的子元素应位于 3D 空间中。 perspective-originperspective-origin属性也可以有3参数方式，第三个值为Z值。 backface-visibilitybackface-visibility 属性定义当元素不面向屏幕时是否可见。 perspective&amp;&amp;perspective-originperspective 属性定义 3D 元素距视图的距离，以像素计。(类似于AE相机中的属性值)。 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 元素添加perspective属性后，可再添加perspec-origin控制观察位置(类似与AE中的相机的x,y位置)。 注释：perspective 属性只影响 3D 转换元素。 .father{ width:400px; height:400px; perspective:120px; perspective-origin:10px 10px; background-color:blue; margin: 60px; } .son{ margin:60px ; width:120px; height:120px; background-color:gray; transform: rotateX(30deg); } 我们观察当perspective-origin值与perspective值改变时，元素发生的变化。 可以明显看出，当perspective值改变的时候，相当于我们视觉的位置与元素的距离发生了改变。而当perspective-origin发生改变的时候，我们是视觉的x，y位置发生了改变，所以我们看到元素的形状及其位置发生了改变。 LastCSS3中的3D变换算是一门学问，下一章解析过渡的时候一起再解析一下，让自己多理解一下。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"transform","slug":"transform","permalink":"http://yoursite.com/tags/transform/"},{"name":"translate()","slug":"translate","permalink":"http://yoursite.com/tags/translate/"},{"name":"scale()","slug":"scale","permalink":"http://yoursite.com/tags/scale/"},{"name":"rotate()","slug":"rotate","permalink":"http://yoursite.com/tags/rotate/"},{"name":"skew()","slug":"skew","permalink":"http://yoursite.com/tags/skew/"},{"name":"matrix","slug":"matrix","permalink":"http://yoursite.com/tags/matrix/"}]},{"title":"CSS3-文本效果和字体","slug":"CSS3-文本效果和字体","date":"2019-11-04T07:26:39.000Z","updated":"2019-11-05T11:49:18.718Z","comments":true,"path":"2019/11/04/CSS3-文本效果和字体/","link":"","permalink":"http://yoursite.com/2019/11/04/CSS3-文本效果和字体/","excerpt":"","text":"CSS3中的文字效果及字体CSS3本来规定了较多的文字属性，但是大部分没有被实现，所以只介绍已经被实现的属性。 text-shadowtext-shadow用于创建一个文字阴影，其参数如下： 参数 说明 &lt;offset-x&gt; x轴的偏移量 &lt;offset-y&gt; y轴的偏移量 &lt;blur-radius&gt; 模糊半径 example1: text-shadow: 5px 5px 5px #FF0000; text-shadow案例利用text-shdow的叠加，可以实现多种文字特效： 火焰文字效果关键：在文字外层加上多层黄色，红色的阴影，并且模糊程度越来越大，颜色的掌控很关键。否则可能不会很逼真。 background:black; text-align:left; text-shadow: 0 -5px 4px #FF3,2px -10px 6px #fd3,-2px -15px 11px #f80,2px -25px 18px #f20; color:red; 立体凸起效果关键：将背景颜色与温习颜色设为一致，再设置一个白色的阴影，一个黑色的阴影，x轴分别偏移-1px，1px即可达到效果。 text-shadow: -1px -1px white,1px 1px #333; color:#D1D1D1; font-weight: bold; background: #CCC; 立体凹下效果关键：与凸起相似，但是将两个偏移量交换一下，即可实现凹下效果。 text-shadow: 1px 1px white,-1px -1px #333; color:#D1D1D1; font-weight: bold; background: #CCC; 描边效果关键：设置4个黑色的阴影，模糊度为0，分别向上下左右各偏移1px，即可实现描边效果。 text-shadow: -1px 0 black,0 1px black,1px 0 black,0 -1px black; color:#ffffff; background: #CCC; 外发光效果关键：不要为阴影设置x，y的偏移量，增大模糊度，即可实现。 text-shadow: 0 0 0.2em #F87,0 0 0.2em #f87; color:#d1d1d1; background: #CCC; 3D效果关键：在同一方向上多次叠加颜色更深的阴影。 color:white; font-size: 200px; text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px 10px black; 关于text-shadow对于各种文字效果，如果我们认真分析文字附加效果的颜色及光影效果，我们可以利用text-shadow模拟出很多的文字效果。 word-wrap/overflow-wrapword-wrap又叫做overflow-wrap： word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”。 稳定的谷歌 Chrome 和 Opera 浏览器版本支持这种新语法。 该属性含有一个参数，其可以有以下值： 值 说明 normal 表示在正常的单词结束处换行。 break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 CSS3 @font-face 规则以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。 使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。 当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。 您所选择的字体在新的 CSS3 版本有关于 @font-face 规则描述。 您”自己的”的字体是在 CSS3 @font-face 规则中定义的。 实例： &lt;style&gt; @font-face { font-family: myFirstFont; src: url(sansation_light.woff); } div { font-family:myFirstFont; } &lt;/style&gt; 在font-family中，还可以定义字体的其他属性： 结束通过text-shadow和自定义字体，我们可以实现多种我们想要的字体效果了！结合上一章的背景，网页肯定能换发生机！","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"text-shadow","slug":"text-shadow","permalink":"http://yoursite.com/tags/text-shadow/"},{"name":"word-wrap","slug":"word-wrap","permalink":"http://yoursite.com/tags/word-wrap/"},{"name":"overflow-wrap","slug":"overflow-wrap","permalink":"http://yoursite.com/tags/overflow-wrap/"},{"name":"font-face","slug":"font-face","permalink":"http://yoursite.com/tags/font-face/"}]},{"title":"CSS3-背景","slug":"CSS3-背景","date":"2019-10-29T01:48:59.000Z","updated":"2019-11-01T10:23:17.505Z","comments":true,"path":"2019/10/29/CSS3-背景/","link":"","permalink":"http://yoursite.com/2019/10/29/CSS3-背景/","excerpt":"","text":"backgroundCSS中，background是一个符合属性，是以下单属性的符合属性： background-color background-position background-size background-repeat background-origin background-clip background-attachment background-image 其格式如下 background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; background-colorbackground-color属性设置一个元素的背景颜色。 元素的背景是元素的总大小，包括填充和边界（但不包括边框）。 example: background-color:yellow; 其属性支持以下内容： 颜色关键值，如：red,blue… Hex颜色值，如：#bbff00… Hex含透明颜色值，如：#ffbb0036;（最后两位表示透明度，ff则为不透明，可省略，则变为普通Hex） RGB颜色值，如：rgb(255,255,255) RGBA颜色值，RGB可透明的颜色值，如：rgba(55,56,125,0.5)，透明度为0.5 特殊值： currentColor：该值是CSS3新增的一个颜色关键字，等会详细介绍。 transparent：透明背景 全局变量： inherit：继承上一级的背景颜色。（注意，该值可用于所有的CSS属性） initial：设置背景色的为默认值（每一个CSS属性都有一个默认值，有些为none，则设置没有效果），此属性可用于清除父级的继承属性。如p标签中的span标签的文字颜色继承问题。 unset：如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。换句话说这个unset关键字会优先用 inherit 的样式，其次会应该用initial的样式。 currentColor关键字CSS新增了currentColor关键字 currentColor代表了当前元素被应用上的color颜色值。 使用它可以将当前这个颜色值应用到其他属性上，或者嵌套元素的其他属性上。并且该属性会继承上级属性值。 example1: .box{ color:red; background-color:currentColor; //此时currentColor=red; height:100px; width:100px; } exmaple2: .fatherBox{ color:red; } .sonBox{ background-color:currentColor;//此时currentColor继承父级的color属性，为red } background-image其属性有以下内容： url():该函数接受一个地址作为背景图片的url，可以是本地地址，也可以是网络地址。 color值：&lt;rgb()&gt; | &lt;rgba()&gt; | &lt;hsl()&gt; | &lt;hsla()&gt; | &lt;hex-color&gt; | &lt;named-color&gt; | currentcolor | &lt;deprecated-system-color&gt; linear-gradient():该函数用于生成一个线性渐变。 radial-gradient()：该函数用于生成一个径向渐变。 repeating-linear-gradient()：该函数用于生成一个重复的线性渐变 repeating-radial-gradient()：该函数用于生成一个重复的线性渐变。 关键字：inherit(从父级继承) linear-gradient()CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于数据类型，是一种特别的数据类型。 其参数有以下几个： angle：角度，可为以下值： 角度值deg，如45deg，-120deg,方向递增方向为顺时针方向。 角度关键字，如，to left，to bottom right，这些关键字等同于相应的角度，如to top = 0deg，to right = 90deg，to bottom right = 135deg color-stop:结束位置颜色值（渐变开始位置）, 包含颜色及结束位置，如red 30%，blue 50% 只包含颜色值，如red,rgb(123,45,26)，此时每一个颜色会被设置默认的结束位置值，即按颜色均分该区域。如，red blue = red 0%,blue 100% 值得注意的是，每个颜色结束位置之间的距离就是这两个颜色渐变的距离 如： red 0%,blue 100%，那么红色与蓝色在之间的渐变距离即为100% red 0%,blue 50%,brown 100%，那么红色与蓝色之间的渐变距离则为50%，蓝色与棕色之间的渐变距离也为50%。 仔细思考一下会发现，如果两个颜色之间的渐变距离为0，那么他们之间的就不会有渐变，再利用角度的可改变与多次使用该属性，即可实现绘制图形 比如： 条形背景： background: linear-gradient(90deg,rgb(153, 153, 153) 50%,rgb(105, 105, 105) 50%); background-size: 20%; background-repeat: repeat; 切角效果 background: linear-gradient(45deg,red 10%,transparent 10%), linear-gradient(135deg,red 10%,transparent 10%), linear-gradient(-45deg,red 10%,transparent 10%), linear-gradient(-135deg,red 10%,transparent 10%); 折角效果 background:linear-gradient(-135deg,transparent 51%,rgba(0, 0, 0, 0.178)51%) no-repeat 100% 0 / 6em 6em, linear-gradient(-135deg,transparent 10%,rgb(169, 169, 233) 10%); 利用其线性切割+重复性，可以实现多种图案，只要想象力足够，唯一需要考虑的就是性能问题，如果通过其绘制过于复杂的线性动画导致页面性能损失，那也是得不偿失的。 radial-gradient()该函数接受5个属性： 参数 描述 可选值 &lt;size&gt; 整个渐变的尺寸大小，如果设置为circle,则可以在前面通过”100px”，”10%”的格式设置其半径，radius；如果设置为ellipse，则可以在前面通过”100px 200px”,”10% 20%”的格式设置其短半径与长半径的值。 绝对单位数值，如100px。相对单位数值，如20% &lt;extent-keyword&gt; 此关键字的词用于确定渐变最外侧的边与哪个边相切，或与哪个角相距。实际上也是确定半径，所以也可以通过size属性直接设置半径。 见下表 &lt;shape&gt; 渐变的形状。圆形（渐变的形状是一个半径不变的正圆）或椭圆形（轴对称椭圆）。默认值为椭圆。椭圆半径与容器的长宽比例相同。 redius：绝对单位数值，如100px；shape：’circle’,’ellipse’ &lt;position&gt; 渐变圆的圆心位置 一般在前面加上 at 关键字 ， 绝对单位数值，如100px。相对单位数值，如20% &lt;color-stop&gt; 渐变的颜色及其渐变结束位置 color:Hex值，rgb值，rgba值，颜色关键字；stop：绝对单位数值，如100px。相对单位数值，如20% 关键字 常量 描述 常量 描述 closest-side 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 closest-side 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 closest-corner 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 closest-corner 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 farthest-side 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 farthest-side 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 farthest-corner 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 farthest-corner 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 radial-gradient()基本应用example1(自己设置半径)： background-image: radial-gradient(100px 150px ellipse at 200px 250px,yellow 50%,red 70%); background-repeat: no-repeat; example2(用关键字)： background-image: radial-gradient(closest-side ellipse at 200px 250px,yellow 50%,red 70%); background-repeat: no-repeat; radial-gradient()高级应用与radial-gradient一样，如果设置两个结束颜色的渐变距离为0或为负值，则可形成径向切割，以此构成多样化的图形。 如： example1(内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%); 但是我们一般会想要多个内凹圆角，当我们简单的将多个radial-gradient堆起来就会发现前一个背景无论如何都会把后面的背景给覆盖掉。所以我们最好的办法是结合background-size,backround-position,background-repeat结合起来，形成多个不叠加的背景！ example2(两个内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 100% / 50% 100%, radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 100%; example3(四个内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 0% / 50% 50%, radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 0%/ 50% 50%, radial-gradient(100px circle at 0 100%,transparent 50%,red 50%) no-repeat 0% 100%/ 50% 50%, radial-gradient(100px circle at 100% 100%,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 50%; repeating-linear-gradient()repeating-linear-gradient() 函数用于创建重复的线性渐变 “图像”。该属性的参数与linear-gradient()相同，所以不在赘述。 由于可以重复的组成背景图形，因此用处更多，条形背景是一个典型的应用。 example1: background: repeating-linear-gradient(yellow 0%,yellow 10%,black 10%,black 20%); example2: background: repeating-linear-gradient(rgba(255, 255, 0, 0.397) 0%,rgba(255, 255, 0, 0.397) 10%,rgba(0, 0, 0, 0.26) 10%,rgba(0, 0, 0, 0.26) 20%), repeating-linear-gradient(to right,rgba(255, 255, 0, 0.397) 0%,rgba(85, 243, 36, 0.397) 10%,rgba(0, 0, 0, 0.26) 10%,rgba(0, 0, 0, 0.26) 20%); repeating-radial-gradient()repeating-radial-gradient()用于创建多个repeating-radial原点辐射。参数与repeating-radial()一致。 example1: background: repeating-radial-gradient(circle at center, rgb(146, 146, 146) 0, rgb(146, 146, 146) 2%, black 2%,black 4%); 渐变综合应用用渐变生成一个复古胶盘： .box3 { position: relative; margin: 100px; height: 400px; width: 400px; color: cadetblue; border-radius: 50%; background: linear-gradient(30deg, transparent 40%, rgba(42, 41, 40, .85) 40%) no-repeat 100% 0, linear-gradient(60deg, rgba(42, 41, 40, .85) 60%, transparent 60%) no-repeat 0 100%, repeating-radial-gradient(#2a2928, #2a2928 4px, #ada9a0 5px, #2a2928 6px); background-size:50% 100%, 100% 50%, 100% 100%; } .box3:after{ position: absolute; top: 50%; left: 50%; margin: -35px; border: solid 1px #d9a388; width: 68px; height: 68px; border-radius: 50%; box-shadow: 0 0 0 4px #da5b33, inset 0 0 0 27px #da5b33; background: #b5ac9a; content: &apos;&apos;; } background-sizebackground-size 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。 其参数有以下内容： 值 解释 &lt;length&gt; &lt;length&gt; 值，比如10px,10em…指定背景图片大小，不能为负值。 &lt;percentage&gt; &lt;percentage&gt; 值，如10%，指定背景图片相对背景区（background positioning area）的百分比。背景区由background-origin设置，默认为盒模型的内容区与内边距，也可设置为只有内容区，或者还包括边框。如果attachment 为fixed，背景区为浏览器可视区（即视口），不包括滚动条。不能为负值。 auto 以背景图片的比例缩放背景图片。 cover 缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。 contain 缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。 inherit/initial/unset 继承父级该属性的值/默认值/如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。 注意， 如果其值为&lt;length&gt;时，则可以分别设置其宽高，如： background-size: 50% 25%; 如果background有多个值，那么在background-size就可以有多个值，并且与其一一对应。 background-size: 50% 25%, contain, 3em; //有3个背景图片 background-originbackground-origin 规定了指定背景图片background-image 属性的原点位置的背景相对区域. 参数如下： 值 解释 border-box 背景图片的摆放以border区域为参考 padding-box 背景图片的摆放以padding区域为参考 content-box 背景图片的摆放以content区域为参考 下面是效果图： background-clipbackground-clip 设置元素的背景（背景图片或颜色）是否延伸到边框或padding下面。 值 解释 border-box 背景延伸至边框外沿（但是在边框下层）。 padding-box 背景延伸至内边距（padding）外沿。不会绘制到边框处。 content-box 背景被裁剪至内容区（content box）外沿。 text 背景被裁剪成文字的前景色。（实验性属性，chrome需加上-webkit-前缀） 下面是效果图： example: -webkit-background-clip: text; color: transparent; font-size: 200px; background-positionbackground-position 为每一个背景图片设置初始位置。 这个位置是相对于由 background-origin 定义的位置图层的。 参数如下： 值 解释 center 用来居中背景图片。 top, left, bottom, right 用来指定把这个项目（原文为 item）放在哪一个边缘。另一个维度被设置成 50%，所以这个项目（原文为 item）被放在指定边缘的中间位置。 &lt;length&gt; 指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。 &lt;percentage&gt; 指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。 该属性可以分别用两个值规定x,y的距离 如：example1： background-position：50px 50px; 也可以向自己规定的边的距离： example2： background-position: right 50px bottom 50px; 我们也可以使用关键词center来居中背景： example3： background-position: center; 如果我们规定一个关键词，另一个关键词则为center： example4： background-position: left; 如果我们将距离值设置为负值，那么背景就会偏离出容器内部，延时到容器的外部（不会显示出来）。 example5: 注意：background还可以拆分为background-position-x与background-position-y，用来分别设置x，y轴的距离。虽然这是一个是实验性属性，不过大部分浏览器都实现了该方法，一般不会出问题 background-repeatbackground-repeat CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。 其参数包含以下，并且每一个单参数都可以改写成双参数（x,y两个方向）的形式： 属性值 含义 双值 repeat 默认值，图像在水平方向和垂直方向都重复以填满容器 repeat repeat repeat-x 图像只在水平方向重复以填满容器 repeat no-repeat repeat-y 图像只在垂直方向重复以填满容器 no-repeat repeat space 图像向两端对齐重复以填满容器，多余空间用空白代替 space space round 图像向两端对齐重复以填满容器，多余空间通过图像拉伸来填充 round round no-repeat 不重复，图像只显示一次 no-repeat no-repeat 注意round与space的区别 round通过图片拉伸将容器内部全部填满： background-repeat: round; space将对应数量的背景填入容器，多余的空间将background-color的颜色填充。 background-repeat: space; 并且我们可以通过双值的方式，分别设置想，x，y上的重复方式 example1： background-repeat: space round; background-attachmentbackground-attachment CSS 属性决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。 属性 解释 fixed 此关键字表示背景相对于window窗口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。 local 此关键字表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。 scroll 此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。 fixed的效果：当fixed时，背景图随着容器位置的改变而改变，也就是说背景图是以window位置为基础的（可以想想象为：背景图已经铺满了window，该容器的位置会截取对应位置的一部分作为其背景图）。 local效果：当local时，背景会随着容器的的滚动而滚动，但是其基准任然是容器（随着容器的位置的改变，背景的位置并没有改变） scroll效果：当scroll时，当我们滚动容器时，背景图不会改变；而且当容器位置改变时，背景图也没有发送改变（相对于容器），也就是说，此时背景是以容器为基准的。 给容器添加滚动条height:300px; width:300px; overflow: scroll; 添加此属性后，无论容器的内容是否超过300px，滚动条都会被添加； 如果设置： height:300px; width:300px; overflow: auto; 那么，如果容器的内容超过300px，滚动条才会被添加。 overflow属性同样是一个复合属性。它是overflow-x,overflow-y两个属性的复合属性。同样的是，overflow可以写两个值： overflow: auto scroll; 设置x轴为自动，y轴为添加滚动条时。 Last背景图这一部分的样式很有意思，特别是渐变那一部分，可以组成很多有趣的图形，不过这一部分内容还是多，需要多看多实践，才能深入掌握！","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"background","slug":"background","permalink":"http://yoursite.com/tags/background/"},{"name":"background-color","slug":"background-color","permalink":"http://yoursite.com/tags/background-color/"},{"name":"background-image","slug":"background-image","permalink":"http://yoursite.com/tags/background-image/"},{"name":"background-size","slug":"background-size","permalink":"http://yoursite.com/tags/background-size/"},{"name":"background-origin","slug":"background-origin","permalink":"http://yoursite.com/tags/background-origin/"},{"name":"background-clip","slug":"background-clip","permalink":"http://yoursite.com/tags/background-clip/"},{"name":"background-position","slug":"background-position","permalink":"http://yoursite.com/tags/background-position/"},{"name":"background-repeat","slug":"background-repeat","permalink":"http://yoursite.com/tags/background-repeat/"},{"name":"background-attachment","slug":"background-attachment","permalink":"http://yoursite.com/tags/background-attachment/"}]},{"title":"CSS3-边框","slug":"CSS3-边框","date":"2019-10-19T14:09:49.000Z","updated":"2019-10-21T08:30:44.030Z","comments":true,"path":"2019/10/19/CSS3-边框/","link":"","permalink":"http://yoursite.com/2019/10/19/CSS3-边框/","excerpt":"","text":"引言之所以想到重学CSS3，是因为最近在看《CSS揭秘》一书时，在发现原来CSS3的内容有很多当时没有深入去琢磨，只是简单学习了其基础用法。下面就通过其一些高级用法来深入的研究一下CSS3的内容。 该内容分为： 边框 背景 文本效果 字体 2D、3D转换 过渡 动画 多列、用户界面（盒尺寸、轮廓） 媒体查询 CSS边框border-radiusborder-radius参数解析该属性与padding、margin相同，可以有1、2、3、4个值，所以复习一次： Example1: border-radius:10px; 四个角的弧度相同，均为10px。 Example2: border-radisu:10px 50px; 左上、右下弧度为10px，左下、右上弧度为50px。 Example3: border-radius:10px 50px 100px; 左上弧度10px，右上、左下弧度50px，右下弧度100px。 Example4: border-radius:10px 50px 100px 200px; 左上、右上、右下、左下弧度分别为：10px 50px 100px 200px; 实际上border-radius是一个简写属性，它是下面四个属性的简写： border-top-left-radius border-top-right-radius border-bottom-left-radius border-bottom-right-radius 所以也可以直接单独设置每个角的值。 border-radius参数单位border-radius参数可以为： 绝对值，比如px,em,rem等。 相对值，百分比值（参数为height、width） border-radius参数意义 这个值实际上就是这个圆角的半径值。 如果是百分比值，则通过这个容器的height\\width算出对应的值。 border-radius配置一个圆角两侧的不同弧度如上图所说，如果按照普通配置，圆角就是在容器的一角形成一个圆，将其1/4作为其圆角。 实际上我们可以分别配置一个圆角的两侧的弧度。即，将一个椭圆的1/4圆作为容器的圆角。 borde-radius:x1 x2 x3 x4/y1 y2 y3 y4; 等价于: border-top-left-radius: x1 y1; border-top-right-radius: x2 y2; border-bottom-right-radius: x3 y3; border-bottom-left-radius: x4 y4; 当然，/前后的属性可以简写： 一个值： borde-radius:x1/y1; 等价于： border-top-left-radius: x1 y1; border-top-right-radius: x1 y1; border-bottom-right-radius: x1 y1; border-bottom-left-radius: x1 y1; 两个值： borde-radius:x1 x2/y1 y2; 等价于： border-top-left-radius: x1 y1; border-top-right-radius: x2 y2; border-bottom-right-radius: x2 y1; border-bottom-left-radius: x2 y2; /前后的值是配置的是每个角的x半径、y的半径。可以为1，2，3，4个值，原理和上面一样。 border-radius高级应用基础用法-圆角.div{ height: 500px; width: 900px; border: 3px solid red; bakcground-color: brown; border-radius: 20px; } 圆形、椭圆圆形（容器的height、width必须相同，height、width的值即为圆的直径） .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-radius: 50%; } 椭圆（height、width即为该椭圆的x轴、y轴的直径） .box{ margin: 20px; height: 500px; width: 700px; border: 3px solid red; background: brown; border-radius: 50%; } 标签图形 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-bottom-right-radius: 50% 100px; border-bottom-left-radius: 50% 100px; } 烧杯 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-bottom-right-radius: 100px 100px; border-bottom-left-radius: 100px 100px; } 树叶 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-radius: 0 100% / 0 100%; } border-radius总结 实际上只要是包含圆角的图形我们都可以通过border-radius来构造，通过多个元素的+定位+圆角来构成图形。 box-shadowbox-shadow参数解析 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 基础用法： box-shadow:10px 10px 10x 10px blue; 值得注意的是： box-shadow的值允许有多组值。 example1: box-shadow: 10px 10px 10px 10px blue,20px 20px 20px 20px black; 高级应用-作为边框如果我们将blur值设为0，即不模糊，再将其h-shadow、v-shadow设置为0，即不偏移，即可将其设置边框。 example2: box-shadow: 0 0 0 10px blue； 再利用可以添加多个边框的性质，即可实现多边框。 box-shadow: 0 0 0 10px blue, 0 0 0 20px black; outlineoutline在元素外部绘制一条线。 outline:outline-color,outline-style,outline-width; 值 描述 outline-color 规定边框的颜色。 outline-style 规定边框的样式。 outline-width 规定边框的宽度。 inherit 规定应该从父元素继承 outline 属性的设置。 example: outline: greenyellow 5px solid; outline也是一个简写属性，即为：outline-color、outline-style、outline-width的简写。outline-style的风格繁多。 值 描述 none 默认。定义无轮廓。 dotted 定义点状的轮廓。 dashed 定义虚线轮廓。 solid 定义实线轮廓。 double 定义双线轮廓。双线的宽度等同于 outline-width 的值。 groove 定义 3D 凹槽轮廓。此效果取决于 outline-color 值。 ridge 定义 3D 凸槽轮廓。此效果取决于 outline-color 值。 inset 定义 3D 凹边轮廓。此效果取决于 outline-color 值。 outset 定义 3D 凸边轮廓。此效果取决于 outline-color 值。 inherit 规定应该从父元素继承轮廓样式的设置。 注意，还有一个与outline相关的属性-&gt;outline-offset，该属性可以为负值 利用outline的虚线轮廓与outline-offset可以实现缝线风格的边框。 缝线风格outline:greenyellow 2px dashed; outline-offset: -10px; border-image注意： 在大多数浏览器下，要应用border-image，必须要先设置边框border属性 当border-image存在且其第一个参数border-image-source不为none时，border-style属性将不会生效，若border-image-source为none，则border-style生效 border-image参数 值 描述 border-image-source 用在边框的图片的路径。 border-image-slice 图片边框向内偏移。 border-image-width 图片边框的宽度。 border-image-outset 边框图像区域超出边框的量。 border-image-repeat 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。 example: .box { margin: 200px; height: 500px; width: 500px; border: 100px solid transparent; background: rgb(243, 103, 103); border-image: url(&apos;/bg.png&apos;) 30% 20%/2/1 repeat; } 注意参数的格式： border-image:border-image-source border-image-slice/border-image-width/border-image-outset border-image-repeat 接下来解析一下这几个参数 border-image-source解释：第一个参数，图片地址，这个不用解释。 border-image-slice解释：第二个参数，图片边框向内偏移，即从何处裁剪背景图片。 example: border-image: url(&apos;/bg.png&apos;) 33% 20% 50% 10% repeat; //省略其他参数 该参数的个数与padding,margin相同，四参数则为上右下左的顺序，三参数则为上下、左、右，两参数则为上下、左右、一参数则全相同 border-image-width解释：第三个参数，规定border-image的宽度，被borer-width也会被相应的缩放以适应border-iamge宽度。单位为倍数，2则为被border-image-slice切割后图片的2倍，0.3则为原来的0.3倍。 example: border-image: url(&apos;/bg.png&apos;) 33%/1/0 round;//默认该参数为1 改变参数为2、0.3 border-image: url(&apos;/bg.png&apos;) 33%/2/0 round; border-image: url(&apos;/bg.png&apos;) 33%/0.2/0 round; 注意，这个参数并不会实际改变border-width中定义的宽度，如果该属性增加，则会向容器内部扩展 border-image-outset解释：该属性会将border-image向外偏移一定量。单位任然是倍数，默认为0，即占据border的位置，向外扩展0倍，1代表增加1倍，即直接与容器的border连接。向外扩展1倍。2倍则偏移两倍，则会在容器外部与边框相距边框的距离。 默认值为0： border-image: url(&apos;/bg.png&apos;) 33%/1/0 round; 变为1： border-image: url(&apos;/bg.png&apos;) 33%/1/1 round; 变为2： border-image: url(&apos;/bg.png&apos;) 33%/1/2 round; 变为0.5： border-image: url(&apos;/bg.png&apos;) 33%/1/0.5 round; 注意这里border-image向外偏移了0.5，即占据了border的一半width。 border-image-repeat解释：该属性用于如何分布border-image-slice切割后的部分该如何组合分布在边框上。它含有以下属性： 值 描述 stretch 默认值。拉伸图像来填充区域 repeat 平铺（repeated）图像来填充区域。 round 类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域。 space 类似 repeat 值。如果无法完整平铺所有图像，扩展空间会分布在图像周围 initial 将此属性设置为默认值。 inherit 从父元素中继承该属性。 特别解释一下： tretch只会将剪切过后的图片放置一张在边框位置，然后拉伸以适应边框的长度。 repeat会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽大于border-width，居中后将多余的部分隐藏在两侧。 round会将多个切割后的图片组合放在边框位置，并且组合后的图片长/宽小于border-width，然后会缩放切割图片以适应长（宽）度。 space会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽小于border-width，多余的部分会空出来，如果有背景色，则用背景色填充。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"border-radius","slug":"border-radius","permalink":"http://yoursite.com/tags/border-radius/"},{"name":"box-shadow","slug":"box-shadow","permalink":"http://yoursite.com/tags/box-shadow/"},{"name":"border-image","slug":"border-image","permalink":"http://yoursite.com/tags/border-image/"}]},{"title":"javaee之spring框架总结","slug":"javaee之spring框架总结","date":"2019-08-09T08:36:31.000Z","updated":"2019-08-09T08:38:51.988Z","comments":true,"path":"2019/08/09/javaee之spring框架总结/","link":"","permalink":"http://yoursite.com/2019/08/09/javaee之spring框架总结/","excerpt":"前言spring作为目前最流行，应用最广泛的后端框架，它有着许多优点与特色，比如应用它IOC（控制翻转）的功能以及spring内部的封装，可以与hibernate，struts进行整合，这里只是简单的介绍其主要功能。","text":"前言spring作为目前最流行，应用最广泛的后端框架，它有着许多优点与特色，比如应用它IOC（控制翻转）的功能以及spring内部的封装，可以与hibernate，struts进行整合，这里只是简单的介绍其主要功能。 springIOCIOC内部原理IOC内部使用了映射的原理： &lt;bean id = &quot;userService&quot; class=&quot;cn.itcast.UserService&quot;/&gt; 内部原理如下： //解析dom4j解析xml文件得到class属性值 String classValue = &quot;class属性值&quot;; //使用反射创建类对象 Class clazz = Class.forName(classValue); //创建类对象 UserService service = clazz.newInstance(); return service; Bean实例化类的无参构造方式&lt;bean id=&quot;user&quot; calss=&quot;cn.itcast.ioc.User&quot;&gt;&lt;/bean&gt; 类的静态工厂方法类方法： public class Bean2Factory{ public static Bean2 getBean2(){ return new Bean2(); } } 配置文件： &lt;bean id=&quot;bean2&quot; class=&quot;cn.itcast.bean.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt; 类的实例工厂方法类方法： public class Bean3Factory{ public Bean3 getBean3(){ return new Bean3(); } } 配置文件： &lt;bean id=&quot;bean3Factory&quot; class=&quot;cn.itcast.bean.Bean3Factory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;&gt; 获取实例化对象//加载配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //获取实例 User user = (User) context.getBean(&quot;user&quot;); Bean标签的常用属性 id属性：对这个bean的属性名，获取该bean的实例时所需的名字。 class属性：创建对象所在类的全路径。 name属性：功能与id属性一样，id属性不能包含特殊字符，但是在name属性值里面可以包含特殊字符。 scope属性：单实例与否。 singleton：默认值，单实例 prototype：多实例 属性注入使用构造函数注入bean： public class PropertyDemo1{ pubcli PropertyDemo1(String username){ this.username= username; } } 配置文件： &lt;bean id=&quot;demo&quot; class=&quot;cn.itcast.property.PropertyDemo1&quot;&gt; &lt;construct-arg name=&quot;username&quot; value=&quot;谁谁谁&quot;&gt;&lt;/construct-arg&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); PropertyDemo1 demo = (demo) context.getBean(&quot;demo&quot;); System.out.println(demo.username); 使用set方法注入bean： class setBookname{ private String bookname; public void setBookname(String bookname){ this.bookname = bookname; } } 配置文件： &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.property.Book&quot;&gt; &lt;property name=&quot;bookname&quot; value=&quot;嘿嘿嘿&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); setBookname book = (book) context.getBean(&quot;book&quot;); System.out.println(book.bookname); 注入对象类型属性UserDao： public class UserDao{ public test(){ System.out.print(&quot;test...&quot;); } } UserService： public class UserService{ private UserDao userDao; public void setUserDao(User userDao){ this.userDao = userDao; } } 配置文件： &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt; //id为类中的属性名 //ref值与生成的bean的id值相同 &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.userDao.test(); 注入数组，list集合，map集合，properties类型属性&lt;bean id=&quot;person&quot; class=&quot;cn.itcast.property.Person&quot;&gt; &lt;!-- 数组 --&gt; &lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- list --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;小奥&lt;/value&gt; &lt;value&gt;小金&lt;/value&gt; &lt;value&gt;小普&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- map --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aa&quot; value=&quot;lucy&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;bb&quot; value=&quot;mary&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;cc&quot; value=&quot;tom&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- properties --&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverclass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; IOC注解方式 在spring配置文件中引入约束： xmlns:context=”http://www.springframework.org/schema/context&quot; xsi:schemaLocation=” http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; 在配置文件中开启注解扫描 //base-package：需要扫描注解的包 &lt;context:component-scan base-package=”cn.itcast”&gt;&lt;/context:component-scan&gt; 创建注解对象在bean中类的上方加上注解：@Component(value=&quot;...&quot;) bean： @Component(value=&quot;user&quot;) //等价于&lt;bean id=&quot;user&quot; class=&quot;...&quot;&gt; public class User{ public test(){ System.out.println(&quot;got it!&quot;); } } 调用： public class test( ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); user.test(); //got it! } 可以了解的是，spring提供了4个注解关键字来实例化bean，其中后3个是Componnet的衍生： @Component:都可以使用 @Controller: web层 @Service: 业务层 @Repository: 持久层 注解确定单、多实例@Scope(value=&quot;prototype&quot;) //多实例 @Scope(value=&quot;singleton&quot;) //单实例 注解注入属性注入基本类型@Value(value) bean: public class test{ @Value(&quot;谁谁谁&quot;) private String username; @Value(123) private int userid; } 不过我们想向本类中注入值的情况比较少，掌握即可 注入属性对象类型 @Autowired:自动检测属性并注入，前提是这个属性对象已经通过spring创建了对象实例，配置文件方式或注释方法都可以。 Resource(name=”对象名”)，对象名是通过spring创建的实例id值或name值 创建属性实例 @Component(value=”userDao”) class userDao{ } 注入属性的两种方式 @Autowired private UserDao userDao; @Resource(name=&quot;userDao&quot;) Private UserDao userDao; 配置文件与注解混合使用可以在配置文件中声明对象的属性类，然后在对象中通过注解注入属性。 配置文件： &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; 类： @Resource(name=&quot;bean0&quot;); private Bean0 bean0; @Resource(name=&quot;bean1&quot;); private Bean0 bean1; spring中的AOP名词解释 Joinpoint(连接点)：类里面可以被增强的方法，这些方法被称为连接点。 Ponitcut(切入点)：所谓切入点是指我们要对哪些Joinpoint进行拦截。 Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Aspect(切面): 是切入点和通知（引介）的结合 增强：增强的逻辑，成为增强，包含以下类型： 前置通知：在方法之前执行 后置通知：在方法之后执行 异常通知：在方法出现异常时执行 最终通知：在后置通知之后执行 环绕通知：在方法之前和之后执行配置文件 引入xml命名空间 http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd 使用表达式配置切入点(实际增强的方法) 表达式： execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* cn.itcast.aop.Book.add(…)) execution( cn.itcast.aop.Book.(..)) execution( .*(..)) 匹配..开头的方法 execution( save(..)) AspectJ的aop操作 AspectJ不是spring的一部分，和spring一起使用aop操作。 spring2.0以后新增了对AspectJ的支持。 AspectJ可以用配置文件或注释文件。 配置对象 配置aop操作 aop:config //配置切入点 &lt;aop:pointcut expression=&quot;execution(* cn.itcast.aop.Book.*(..))&quot; id=&quot;pointcut1&quot;&gt; //配置切面，将增强用到切入点上 &lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:aspect&gt; &lt;/aop:config&gt; 值得注意的是： aop:point标签是在配置切入点，即哪些方法需要被增强，其中expression为表达式，id为自定义名称。 aop:aspect标签是在配置切面，即用哪些增强(方法)来增强切入点。 在aop:aspect内部标签表示的是增强的方式。包含以下标签： aop:before 前置通知 aop:after-returning 后置通知 aop:around 环绕通知 aop:after-throwing 异常通知 aop:after 最终通知 AspectJ的注解AOP操作 创建对象 &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt; 在spring核心配置文件中，开启aop操作 aop:aspectj-autoproxyaop:aspectj-autoproxy 在增强类上使用注解完成aop操作 @Aspect public class MyBook{ @Before(value=&quot;execution(* cn.itcast.aop.Book.*(..))&quot;) public void before1(){ System.out.print(&quot;before........&quot;); } } sping的jdbcTemplate操作 设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(“com.mysql.jdbc.Driver”); dataSource.setUrl(“jdbc.mysql:///database0”); dataSource.setUsername(“root”); dataSource.setPassword(“root”); 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); 创建sql语句，并执行jdbcTemplate中的方法 增加 String sql = “insert into user value(?,?)”;int rows = jdbcTemplate.update(sql,”lucy”,”250”); 修改 String sql = “update user set password =? where username=?”;int rows = jdbcTemplate.update(sql,”1234”,”lucy”); 删除 String sql = “delete from user where username=?”;int rows = jdbcTemplate.update(sql,”lucy”); 查询 //返回对象String sql = “select * from user where username=?”;User user jdbcTemplate.queryForObject(sql,new MyRowMapper(),”mary”);System.out.println(user); //实现RowMapperclass MyRowMapper implements RowMapper{ @Override public User mapRow(Result re, int num) throws SQLException{ String username= rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); User user = new User(); user.setUsername(username); user.setPassword(password); }} //返回list String sql = &quot;select * from user&quot;; List&lt;User&gt; list = jdbcTemplate.query(sql,new MyRowMapper()); System.out.println(list); Spring配置c3p0连接池和dao使用jdbcTemplate因为配置jdbcTemplate数据库的数据库信息实际上还是创建对象，注入属性。所以同样可以用Spring的AOP进行对象的创建。 导入c3p0以及配合的jarbao 配置c3p0连接池 dao使用jdbcTemplate 创建service和dao，配置service和dao对象，并把service注入dao对象 &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c3p0.UserService&quot;&gt; &lt;proerpty name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c3p0.UserDao&quot;&gt; 2. 创建jdbcTemplate对象 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate){ this.jdbcTemplate = jdbcTemplate; } 3. 把模板对象注入dao中 &lt;bean id=&quot;userDao&quot; class=&quot;class.itcast.c3p0.UserDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; 4. 在jdbcTemplate对象里注入dataSource private DataSource dataSource; privateSQLExceptionTranslator exceptionTranslator; private boolean lazyInit = true; public void setDataSource(DataSource dataSource){ this.dataSource = dataSource; } &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;bean&gt; spring的事务管理xml方式 在核心配置文件中配置事务管理器 配置事务增强 &lt;tx:advice id=”txadvice” transaction-manager=”transactionManager”&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;account*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; tx:advice 配置切面 aop:config &lt;aop:pointcut expression=&quot;execution(* cn.itcast.service.OrderService.*(..))&quot; id=&quot;pointcut1&quot;&gt; &lt;aop:adviser advice-ref=&quot;txadvice&quot; point=ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; 注解方式 配置事务管理器 开启事务注解 &lt;tx:annotation-driven transaction-manager=”transactionManager”/&gt; 在需要使用事务的方法所在类上面添加注解 @Transactional public class ordersService{ } Last这里的内容多是视频教学笔记中的内容加上我自己的理解，只是不是很深，只是一个最基本的用法，并且省去了配置环境的问题，比如导入jar包等等，这里面可能有很多错误或不足，因为我也是才开始接触。加油加油！","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/tags/JavaEE/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"javaee之hibernate框架总结","slug":"javaee之hibernate框架总结","date":"2019-08-08T10:09:11.000Z","updated":"2019-08-08T10:10:56.125Z","comments":true,"path":"2019/08/08/javaee之hibernate框架总结/","link":"","permalink":"http://yoursite.com/2019/08/08/javaee之hibernate框架总结/","excerpt":"前言Hibernate目前使用的还是比较多，虽然不及mybatis。 Hibernate概述Hibernate工作在javaEE三层结构中的dao层，对数据库进行crud操作，其核心思想是orm（object relational mapping，对象关系映射），并且Hibernate支持多种查询方式，包括HQL，QBC,SQL三种方式。 orm 让实体类和数据库表进行一一对应关系 让实体类首先和数据库表对应 让实体类属性 和 表里面字段对应 不需要直接操作数据库表，而操作表对应实体类对象","text":"前言Hibernate目前使用的还是比较多，虽然不及mybatis。 Hibernate概述Hibernate工作在javaEE三层结构中的dao层，对数据库进行crud操作，其核心思想是orm（object relational mapping，对象关系映射），并且Hibernate支持多种查询方式，包括HQL，QBC,SQL三种方式。 orm 让实体类和数据库表进行一一对应关系 让实体类首先和数据库表对应 让实体类属性 和 表里面字段对应 不需要直接操作数据库表，而操作表对应实体类对象 配置文件Hibernate的核心配置文件有如下要求： 必须在src下 必须为hibernate.cfg.xml 配置核心文件 引入约束 &lt;!DOCTYPE hibernate-configuration PUBLIC “-//Hibernate/Hibernate Configuration DTD 3.0//EN” “http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; 配置信息 &lt;session-factory&gt; &lt;!-- 第一部分： 配置数据库信息 必须的 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;!-- 第二部分： 配置hibernate信息 可选的--&gt; &lt;!-- 输出底层sql语句 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 输出底层sql语句格式 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- hibernate帮创建表，需要配置之后 update: 如果已经有表，更新，如果没有，创建 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 配置数据库方言 在mysql里面实现分页 关键字 limit，只能使用mysql里面 在oracle数据库，实现分页rownum 让hibernate框架识别不同数据库的自己特有的语句 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 第三部分： 把映射文件放到核心配置文件中 必须的--&gt; &lt;mapping resource=&quot;cn/itcast/entity/User.hbm.xml&quot;/&gt; &lt;/session-factory&gt; 值得注意的是： 配置数据库信息部分与jdbc部分的配置信息一致 hibernate.show_sql： 在编译时控制台输出生成的SQL语句 hibernate.format_sql : 在上面的属性开启的前提之下输出格式化之后的SQL语句 hibernate.hbm2ddl.auto : 配置数据库方言在mysql里面实现分页 关键字 limit，只能使用mysql里面在oracle数据库，实现分页rownum让hibernate框架识别不同数据库的自己特有的语句 配置映射文件映射文件是一个表与实体的配置映射 命名没有确定规则 位置也没有确定位置 引入约束 &lt;!DOCTYPE hibernate-configuration PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN” “http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 配置映射关系 &lt;class name=&quot;priv.mw.dao&quot; table=&quot;t_user&quot;&gt; &lt;id name=&quot;uid&quot; column=&quot;uid&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; column=&quot;username&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/property&gt; &lt;/class&gt; 值得注意的是： hibernate-mapping package:填写包名，如果此处填写了完整的包名，则后面class的name属性只需要填写class名字。否则class的name属性则需要填写完整的名字，及包含包名的类名。 class name：填写类名（全路径或名字） table：数据库中表名。（orm中表与类一一对应） id：每一张表必须要有一个唯一的属性。 name：类中属性的名字 column：为表中列的名字 property:表中的属性 name:类中的属性名 column：表中的列名 值得注意的是： id或property中的column是可选的，如果不填，则默认与name属性相同。 实体类的编写规则 实体类中的属性是私有的 私有属性使用公开的set和get方法 要求实体类有属性作为唯一值(一般使用id值) 实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类，其目的是Integer score = null。可以表示不存在这个值，而基本类不能为null。 主键的生成策略 native：自动增长 uuid：uuid算法 CRUDsession方式 加载核心配置文件 加载SessionFactory对象 使用SessionFactory对象创建session对象 开启事务 开始写具体逻辑，crud操作 提交事务 关闭资源 public test(){ //1. 加载hibernate核心配置文件 //这一步从src中查找hibernate.cfg.xml Configuration cfg = new Configuration(); cfg.configure(); //2. 创建SessionFactory对象 //同时读取映射文件，创建表格 SessionFactory sessionFactory = cfg.buildSessionFactory(); //3. 创建Session对象 Session session = session.openSession(); //4. 开启事物 Transaction tx = session.beginTransaction(); //5. 写入具体的crud操作 User user = new User(); user.setUsername(&quot;李雷&quot;); user.setPassword(&apos;123&apos;); user.setAddress(&quot;日本&quot;); session.save(user); //6. 提交事务 tx.commit(); //7. 关闭资源 session.close(); sessionFactory.close(); } session对象导航查询常用的方法： get():通过OID 从数据库中抓取数据，并把数据加载到一个新实例对象上。 save():执行insert语句，当数据库存在这条记录时，会抛出异常。 saveOrUpdate():如果数据库中不存在该数据，则执行insert语句，如果存在则执行更新操作。 update():当数据库中存在这条记录时，Hibernate 总会执行一条SQLUPDATE 语句；当数据库中不存这条记录时，就会抛出异常。 delete():当数据库中存在这条记录时，Hibernate 总会执行一条SQLDELETE 语句；当数据库中不存这条记录时，就会抛出异常。 load():该方法与get相同，但是不会立即去查询数据库，而是等待需要使用该数据时才去查询。比如用ID查询ID，get方法任然回去查询数据库，而load则直接返回使用的ID，不去查询数据库。 实体对象三种状态 瞬时状态(Transident):如果对象从未与Session对象关联过，称该对象处于瞬时状态（或临时状态）。 持久状态(Persisdent):如果对象与Session对象关联起来，且该对象对应到数据库记录，则称该对象处于持久化状态。比如通过get获取的对象。 游离状态(Detached)：当持久化对象的Session关闭后，这个对象就会从持久化状态改变成游离状态。 HQL方式example： Query query = session.createQuery(&quot;from Customer where name=?&quot;); query.setParameter(&quot;mw&quot;); 条件查询： from Customer c where c.cid=? and c.custName=? 模糊查询 from Customer c where s.custName like ? 排序查询 from Customer order by cid desc 分页查询 Query query = session.createQuery(“from Customer”); query.setFirstResult(0); query.setMaxReaults(3); List list = query.list(); 投影查询:查询不是所有字段值，而是部分字段的值 Query query = session.createQuery(“select cusName from Customer”); List list = query.list(); for(Object object : list){ Systom.out.println(Object); } 聚集函数使用 Query query = session.createQuery(&quot;select count(*) from Customer&quot;); object obj = query.uniqueResult(); Long lobj = (Long)obj; int count = lobj.intValue(); 内连接查询（返回list）：选取两张表的外键相同的数据返回。 Query query = session.createQuery(“from Customer c inner join c.setLinkMan”) 迫切内连接（返回对象） Query query = session.createQuery(&quot;from Customer c inner join fetch c.setLinkMan&quot;) 左外连接（返回list）：返回左侧表中的所有数据以及右侧与之外键相同的的数据。 Query query = session.createQuery(“from Customer c left outer join c.setLinkMan”); 迫切左外连接（返回对象） Query query = session.createQuery(&quot;from Customer c left outer join fetch c.setLinkMan&quot;); 右外连接：返回左右侧表中的所有数据以及左侧与之外键相同的的数据。 Query query = session.createQuery(“from Customer c right outer join s.setLinkMan”); QBC方式调用Criteria的方法实现查询 查询所有 Criteria criteria = session.createCriteria(Customer.class); List list = criteria.list(); 条件查询 Criteria criteria = session.createCriteria(Customer.class); cretera.add(Restrictions.eq(“cid”,1)); critera.add(Restrictions.eq(“custName”,”someone”)); List list = criteria.list(); cretiria.add(Restrictions.like(“custName”,”%s%”)); 排序查询 Criteria criteria = session.createCriteria(Customer.class); cretiria.addOrder(Order.desc(“cid”)); 分页查询 Criteria criteria = session.createCriteria(Customer.class); criteria.setFirstResult(0); criteria.setMaxResult(3); 统计查询 Criteria criteria = session.createCriteria(Customer.class); criteria.setProjection(Projections.rowCount()); Object obj = criteria.uniqueResult(); Long lobj = (Long) obj; int count = lobj.intValue; 离线查询：不通过session对象来创建查询对象，即可以在dao层session对象关闭后也能执行查询。一般用在多条件查询直接在service层进行离线查询。 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class); Criteria criteria = detachedCriteria.getExecutableCriteria(session); List list = criteria.list(); hibernate一对多操作这里的一对多其实就是SQL中一对多的概念，不过我们在学习如何在hibernate中来使用这个概念。 以客户，联系人为例： 创建两个实体类，客户、联系人 让连个实体之间相互表示，即将对方对象作为一个自己的一个私有属性，并设置set,get方法。 在客户实体类里面表示多个联系人 private Set setLinkMan = new HashSet(); public Set getSetLinkMan(){ return setLinkMan;} public void getSetLinkMan(Set setLinkMan){ this.setLinkMan = setLinkMan;} 在联系人实体类里面表示所属客户 private Customer customer; public Customer getCustomer(){ return customer;} public void setCustomer(Customer customer){ this.customer = customer;} 配置客户映射关系 //在客户映射文件中，表示联系人 //使用set标签表示所有联系人 //set中name为联系人中的set集合名称 //column为外键名称 //class中写联系人的实体全路径 配置联系人映射文件 //name：在联系人实体中的客户属性的名字 //class：联系人class的全路径 //column：外键名称 配置核心配置文件 resource：映射文件的路径名称 &lt;mapping resource=&quot;cn/itcast/entuty/Customer.hbm.xml&quot;&gt; &lt;mapping resource=&quot;cn/itcast/entuty/LinkMan.hbm.xml&quot;&gt; 一对多级联保存Customer customer = new Customer(); customer.setCustName(&quot;百度&quot;); customer.setCustLevel(&quot;普通客户&quot;); customer.setCustSource(&quot;网络&quot;); customer.setCustPhone(&quot;110&quot;); customer.setCustMobile(&quot;999&quot;); LinkMan linkman = new LinkMan(); linkman.setLkm_name(&quot;小宏&quot;); linkman.setLkm_gender(&quot;男&quot;); linkman.setLkm_phone(&quot;911&quot;); //2 把联系人放到客户里面 customer.getSetLinkMan().add(linkman); //3 保存客户 session.save(customer); 一对多级联删除删除某个客户，把客户里面所有的联系人删除 需在set中配置cascade属性： &lt;set name=&quot;setLinkMan&quot; cascade=&quot;save-update,delete&quot;&gt; Customer customer = session.get(CUstomer.class,3); session.delete(customer); 一对多级联更新//根据id查询Lucy联系人，客户百度 Customer baidu = session.get(Customer.class,1); //设置持久态对象 Customer lucy = session.get(LinkMan.class,2); //把联系人放入客户对象中 baidu.getSetLinkMan().add(lucy); //把客户放到联系人中 lucy.setCustomer(baidu); 值得注意的是： 在默认转态下，两个对象都会维护这个关系。所以会执行两次SQL语句。为了解决这个问题，可以在set中配置inverse属性，让某一方放弃维护。 inverse: false不放弃维护 true放弃维护 hibernate多对多实际上我们在比较少用多对多关系，会将其转化为两个一对多关系。 以用户和角色为例： 创建实体类，用户和角色 让两个实体类相互表示 一个用户有多个角色，使用set集合 Private Set setRole = new HashSet(); public Set getSetRole(){ return setRole;} public void setSetRole(Set setRole){ this.setRole = setRole;} 一个角色有多个用户，使用set集合 private Set setUser = new HashSet(); public Set getSetUser(){ return setUser;} public void setSetUser(Set setUser){ this.setUser =setUser;} 配置映射关系 在用户里面表示所有角色，使用set标签 在角色中表示所有用户，使用set标签 在核心配置文件中引入映射文件 多对多级联保存任然需要在set中配置cascade &lt;set name=&quot;setRole&quot; table=&quot;user_role&quot; cascade=&quot;save-update,delete&quot;&gt; 实体类中代码： User user1 = new User(); user1.setUser_name(&quot;lucy&quot;); user1.setUser_password(&quot;123&quot;); User user2 = new User(); user2.setUser_name(&quot;mary&quot;); user2.setUser_password(&quot;456&quot;); Role r1 = new Role(); r1.setRole_name(&quot;总经理&quot;); r1.setRole_memo(&quot;总经理&quot;); Role r2 = new Role(); r2.setRole_name(&quot;秘书&quot;); r2.setRole_memo(&quot;秘书&quot;); Role r3 = new Role(); r3.setRole_name(&quot;保安&quot;); r3.setRole_memo(&quot;保安&quot;); //2 建立关系，把角色放到用户里面 // user1 -- r1/r2 user1.getSetRole().add(r1); user1.getSetRole().add(r2); // user2 -- r2/r3 user2.getSetRole().add(r2); user2.getSetRole().add(r3); //3 保存用户 session.save(user1); session.save(user2); 多对多级联删除&lt;set name=&quot;setRole&quot; table=&quot;user_role&quot; cascade=&quot;save-update,delete&quot;&gt; User user = session.get(User.class,1); session.delete(user); 多对多级联更新User lucy = session.get(User.class,1); Role role = session.get(Role.class,1); //为用户添加角色 lucy.getSetRole().add(role); //把用户角色删除 lucy.getSetRole().remove(role); hibernate缓存hibernate为了增加查询效率，建立了缓存机制。即在查询到某个数据后，则将其存储到内存中，下一次查询时直接获取内存中的数据，不用向数据库查询，直接获取，加快查询速度。 hibernate的一级缓存默认打开的 hibernate的一级缓存使用范围，是session范围，3. hibernate的一级缓存中，存储数据必须 持久态数据 hibernate事务与SQL的事务一致，保证一系列工作的全部执行。具有以下特性： 原子性： 确保工作单元中的所有操作都成功完成; 否则，该事务被中止的故障点，操作回滚到操作之前的状态。 一致性：确保数据库正确后成功提交事务更改状态。 隔离性：事务操作彼此独立和透明。 持久性：可确保提交的事务的结果或仍然存在系统故障的情况下的作用。 try { 开启事务 提交事务}catch() { 回滚事务}finally { 关闭} public void testTx() { SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; try { sessionFactory = HibernateUtils.getSessionFactory(); session = sessionFactory.openSession(); //开启事务 tx = session.beginTransaction(); //添加 User user = new User(); user.setUsername(&quot;小马&quot;); user.setPassword(&quot;250&quot;); user.setAddress(&quot;美国&quot;); session.save(user); int i = 10/0; //提交事务 tx.commit(); }catch(Exception e) { e.printStackTrace(); //回滚事务 tx.rollback(); }finally { //关闭操作 session.close(); sessionFactory.close(); } } 通过session.beginTransaction()获取Transaction对象。 最后这个说明只是一个简单的概述，根据黑马程序员2016年版的笔记总结而来，肯定不是全部的，但是这个足够进行简单的操作。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/tags/JavaEE/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"hibernate","slug":"hibernate","permalink":"http://yoursite.com/tags/hibernate/"}]},{"title":"javaee之struts框架总结","slug":"javaee之struts框架总结","date":"2019-08-08T00:32:52.000Z","updated":"2019-08-08T10:15:24.283Z","comments":true,"path":"2019/08/08/javaee之struts框架总结/","link":"","permalink":"http://yoursite.com/2019/08/08/javaee之struts框架总结/","excerpt":"前言最近在了解后端开发框架，所以先从SSH（Struts，Spring，Hibernate）开始，因为在企业级开发中SSH任然在使用，所以还是有必要了解一下，后面再详细学习SSM（Spring MVC，Spring，mybatis），目前互联网企业中大多都在使用SSM。","text":"前言最近在了解后端开发框架，所以先从SSH（Struts，Spring，Hibernate）开始，因为在企业级开发中SSH任然在使用，所以还是有必要了解一下，后面再详细学习SSM（Spring MVC，Spring，mybatis），目前互联网企业中大多都在使用SSM。 这一期先介绍struts。 strutsstruts介绍struts是一个工作在表示层，负责与JSP页面实现交互，将用户的请求委派给相应的Action处理。 配置过滤器在web-app内添加如下内容： &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 创建action方法一 直接创建Actionpublic class Democlass{ public String execute(){ return &quot;none&quot;; } } 方法二 继承ActionSupport类（最常用）public class Democlass extends ActionSupport{ public String execute(){ return &quot;none&quot;; } } 方法三 实现接口Actionpublic class Democlass implements Action{ public String execute(){ return &quot;none&quot;; } } 配置文件配置文件必须是命名为struts.xml，并且位于src目录下。 引入dtd约束&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; 配置action&lt;package name=&quot;methoddemo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;&quot; class=&quot;cn.itcast.method.BookAction&quot; method=&quot;&quot; &gt; &lt;result name=&quot;ok&quot;&gt;hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 结构为：package-&gt;action-&gt;result package参数： name:（必填）自定义名称 namespace:（可选）命名空间 extends:（可选）该包继承自其它包，一般填struts-default abstract:（可选）该类是否是一个抽象包，抽象包中不能包含Action定义。 action参数： name：（必填）action的标识，在URL访问时后缀为该值。 class：（可选）Action的类的全路径。 method：（可选）指定请求Action时调用的方法，默认为execute方法。 converter：（可选）指定类型转换器的类。 result参数： name：（可选）指定逻辑视图的名称，默认为success。（为指定函数的返回值） type：（可选）指定访问内容的方式，主要有如下方式（默认为dispatcher） dispatcher：页面转发 redirect：页面重定向 chain：action转发 redirectAction：action重定向 global-result如果在action类的方法中，返回了一个字符串，但如果没有配置对应的result，则浏览器会返回404，但是global-result可以匹配任何action中的对应action。 注意：如果action中与global-result同时配置了相同的result。则局部result优先级更高。 &lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; &lt;global-results&gt; action获取表单数据使用ActionContext类获取ActionContext context = ActionContext.getContext(); Map&lt;String,Object&gt; map = context.getParameters(); //使用Map.Entry遍历获取的Map for(Map.Entry&lt;String, Object&gt; entry : map.entrySet()) { System.out.println(entry.getKey()+&quot;--&quot;+Arrays.toString((Object[]) (entry.getValue()))); } 使用SevletActionContext类获取该方法直接获取request对象。 HttpServletRequest request = ServletActionContext.getRequest(); //下面就是调用request了 String para1 = request.getParameter(&apos;para1&apos;); String para2 = request.getParameter(&apos;para2&apos;); String para3 = request.getParameter(&apos;para3&apos;); 使用接口获取requestpublic class Demo implements ServletRequestAware{ @Override public void setServletRequest(HttpServletRequest){ this.request = request; } } 在action中操作域对象struts的域对象与servlet的域对象一样，用于存储数据，在JSP页面中直接获取。 具体用法： request域 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(“key”,”value”); session域 HttpSession session = request.getSession(); session.setAttribute(“key”,”value”); ServletContext域 ServletContext context = ServletAction.getServletContext(); context.setAttribute(“key”,”value”); 属性封装表单提交的数据会自动封装到类实例的属性 一、直接将表单提交的属性封装到action中 在action成员中定义变量 生成变量的set,get方法 private String userName; private String password; private String address; public String getUserName(){ return this.userName; } public String setUserName(String userName){ this.userName = userName; } public String getPassword(){ return this.password; } public String setPassword(String userName){ this.password = password; } public String getAddress(){ return this.address; } public String setAddress(String userName){ this.address = address; } 模型驱动封装(重点) action实现接口ModelDriven 实现接口里面的getModel方法 在action里创建实体类对象 class Demo extends ActionSupport implements ModelDriven{ private User user = new User(); public User getModel(){ return user } } 使用模型驱动封装，一个表单只能封装一个模型驱动封装。 不能同时使用属性封装与模型驱动封装。 表达式封装使用表达式封装是指在表单提交时，name属性则为具体实例的属性（struts有自己的表示方式，比如：User.name） 在action中声明实例类 生成实例类的set与get方法 private User user; public User getUser(){ return user; } public void setUser(User user){ this.user = user } 在表单输入项的name属性里面写表达式形式 username:&lt;\\input type=”test” name=”user.userName”&gt; password:&lt;\\input type=”password” name=”user.password”&gt; address:&lt;\\input type=”text” name=”user.address”&gt; 封装到集合中封装到list集合第一步 在action声明List第二步 生成list变量的set和get方法 private List&lt;User&gt; list; public List&lt;User&gt; getList(){ return list; } public void setList(List&lt;User&gt; list){ this.list = list; } 第三步 在表单输入项中写表达式 username:&lt;input type=&quot;text&quot; name=&quot;list[0].userName&quot;&gt; password:&lt;input type=&quot;password&quot; name=&quot;list[0].password&quot;&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[0].address&quot;&gt; &lt;br/&gt;&lt;br/&gt; username:&lt;input type=&quot;text&quot; name=&quot;list[1].userName&quot;&gt; password:&lt;input type=&quot;password&quot; name=&quot;list[1].password&quot;&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[1].address&quot;&gt; 封装到Map集合第一步 声明map集合第二步 生成get和set方法 private Map&lt;String,User&gt; map; public Map&lt;String,User&gt; getMap(){ return map; } public void setMap(Map&lt;String,User&gt; map){ this.map = map; } username:&lt;input type=&quot;text&quot; name=&quot;map[one].userName&quot;/&gt; password:&lt;input type=&quot;password&quot; name=&quot;map[one].password&quot;/&gt; address:&lt;input type=&quot;text&quot; name=&quot;map[one].address&quot;/&gt; OGNL表达式与EL表达式一样，OGNL表达式可以用来操作值栈。 引用struts标签库//引用标签库 &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt; //操作 &lt;s:property value=&quot;&apos;haha&apos;.length()&quot;&gt; 值栈 在servlet中，我们把数据放到了域对象中，在页面中使用EL表达式获取；域对象同样在一定范围内，存值和取值。 在struts中也提供了一种存储机制，类似与域对象，被称为值栈，也可以存值获取值。 在action中把数据存到值栈中，在页面中获取数据。 servelet和action区别 Servlet：默认在第一次访问创建，创建一次，单实例对象。 Action：访问时创建，每次访问的时候，都会创建一个action对象。所以它是一个多实例对象。 值栈存储在action中。 获取值栈对象ActionContext context = ActionContext.getContext(); ValueStack stack1 = context.getValueStack(); 每一个action只有一个值栈对象。 值栈分为两部分： root：list集合 context：map集合（实际就是action的上下文），包含如下内容： request：HttpRequest对象的引用 session：HttpSession对象引用 application：ServletContext对象的引用 parameters：传递的相关参数 attr：域对象，使用seAttribute(“key”,”value”)存储 可以使用s:debug来查看action的结构 向值栈中存值 使用set方法 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); stack.set(“key”,”value”); 使用push方法 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); stack.push(“something”); 向值栈中存放对象 private User user = new User(); public User getUser(){ return user; } public String excute() throws Exception{ user.setUsername(&quot;lucy&quot;); user.setPassword(&quot;123&quot;); user.setAddress(&quot;美国&quot;); return &quot;success&quot;; } 向值栈中存放list集合 private List list = new ArrayList(); public List getList(){ return list; } public String excute() throws Exception{ User user1 = new User(); user1.setUsername(&quot;lucy&quot;); user1.setPassword(&quot;123&quot;); user1.setAddress(&quot;美国&quot;); User user2 = new User(); user2.setUsername(&quot;tom&quot;); user2.setPassword(&quot;12345&quot;); user2.setAddress(&quot;意大利&quot;); list.add(user1); list.add(user2); return &quot;success&quot;; } 从值栈中取值我们都是用OGNL表达式结合struts标签来获取值栈中的值。 获取字符串&lt;s:property value=&quot;username&quot;/&gt; 获取对象//方法一 &lt;s:property value=&quot;list[0].username&quot;/&gt; &lt;s:property value=&quot;list[0].password&quot;/&gt; &lt;s:property value=&quot;list[0].address&quot;/&gt; &lt;br/&gt; &lt;s:property value=&quot;list[1].username&quot;/&gt; &lt;s:property value=&quot;list[1].password&quot;/&gt; &lt;s:property value=&quot;list[1].address&quot;/&gt; //方法二 &lt;s:iterator value=&quot;list&quot;&gt; &lt;s:property value=&quot;username&quot;/&gt; &lt;s:property value=&quot;password&quot;/&gt; &lt;s:property value=&quot;address&quot;/&gt; &lt;s:iterator&gt; //方法三 &lt;s:iterator value=&quot;list&quot; var = &quot;user&quot;&gt; &lt;s:property value=&quot;#user.username&quot;/&gt; &lt;s:property value=&quot;#user.password&quot;/&gt; &lt;s:property value=&quot;#user.address&quot;/&gt; &lt;s:iterator&gt; 获取set值&lt;s:property value=&quot;key&quot;&gt; 获取push方法&lt;s:property value=&quot;[0].top&quot;&gt; 可以通过debug的方式看出，值栈实际上就是存在context中，作为其属性。 EL表达式可以不去值栈数据EL表达式实际上是增强了getAttribute方法，如果在request中获取到对应的值，则返回该值，否则再到值栈中检索。 OGBL中的#与% # 获取context中的值 &lt;s:property value=”#user.username”/&gt; 获取request中的值 &lt;s:property value=”#request.req”/&gt; % 在struts2标签中表单标签 在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别。 &lt;s:textfield name=&quot;username&quot; value=&quot;%{#request.req}&quot;&gt; struts拦截器struts的拦截器是一种AOP(面向切面编程)思想的实践，通俗的来说就是不改变源代码来实现对原来类或方法的拓展。 而在每次action启动的时，我们都会为每个action方法增加一些拦截器，在action对象创建之后，action方法之前，拦截器的方法得到执行，拦截决定是否放行，然后由下一个拦截器接手继续执行，知道所有拦截器执行完。一旦任何一个拦截器拒绝了，那么后面的拦截也都不会执行了。 拦截器与过滤器 过滤器：理论上可以过滤任意内容，包括html,jsp,servlet… 拦截器：只能拦截action 自定拦截器编写拦截器方法 继承MethodFilterInterceptor并重写其中的doIntercept方法。 public class MyFilter extends MthodsFilterInterceptor{ protected String doIntercept(ActionInvocation invocation)throws { //如果符合条件，则通过执行invocation.invoke()来放行 if(somthongright){ invocation.invoke(); }else{ //否则，不执行invocation.invoke() return &quot;null&quot;; } } } 配置拦截器在package中： 声明拦截器 //class为自定义拦截器的全路径 使用自定义的拦截器在要使用的action内部使用： //name为上面配置的name值 3.还有一点要注意，由于interceptor-ref值默认为执行struts的默认拦截器，我们修改了之后就不会执行默认拦截器了，所以我们还要执行默认拦截器。 &lt;interceptor-ref name=&quot;defultStack&quot;&gt;&lt;/interceptor-ref&gt; 这里的defaultStack是struts在对默认拦截器的一个名称定义，直接引用不能改变。 如果我们需要让某些action不进行拦截，我们可以在使用拦截器时加入属性： &lt;param name=&quot;excludeMthods&quot;&gt;login&lt;/param&gt; struts常用标签库 s:property :使用OGNL表达式获取值栈的值。 s:iterator :使用OGNL迭代获取值栈中的值。 s:iterator :查看值栈的结构和数据。 struts的表单属性，struts对HTML表单属性都有封装，但一般不用，比如&lt;s:input type=”text”&gt; 最后虽然struts目前用的最少，但是最为SSH三大框架之一，了解一下还是有利于以后的工作。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/tags/JavaEE/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"struts","slug":"struts","permalink":"http://yoursite.com/tags/struts/"}]},{"title":"javaScript深入解析3-类与行为委托","slug":"javaScript深入解析3-类与行为委托","date":"2019-07-19T14:11:44.000Z","updated":"2019-07-19T14:20:16.472Z","comments":true,"path":"2019/07/19/javaScript深入解析3-类与行为委托/","link":"","permalink":"http://yoursite.com/2019/07/19/javaScript深入解析3-类与行为委托/","excerpt":"JavaScript中“纠结的类”正如前文所说，JavaScript中并没有传统意义上的“类”，可能是因为在JavaScript这门脚本语言诞生之初，并没有人会他会有如今的成就，所以就借用了Self语言的基于原型的面向对象设计。具体可以看JavaScript的诞生","text":"JavaScript中“纠结的类”正如前文所说，JavaScript中并没有传统意义上的“类”，可能是因为在JavaScript这门脚本语言诞生之初，并没有人会他会有如今的成就，所以就借用了Self语言的基于原型的面向对象设计。具体可以看JavaScript的诞生 面向对象编程（OOP）面向对象编程是一种编程思想，其重要思维体现在： 封装性：讲一组方法，变量封装在一个“模块”中，一般来说是一个类。 继承性：继承性是面向对象技术中的另外一个重要特点，是指一个类继承另一个类的方法，类的继承。他们的关系通常是父与子的关系。 多态性：是指子类对父类的方法进行重写或重载。 对于传统的OOP语言，比如java，C++。 类意味着复制。 实例化时，他的行为会被复制到实例中；继承时，行为也会被复制到子类中。 JavaScript中的类JavaScript程序员开始大都是由其它语言程序员没经过系统学习这门语言的精髓就开始编程（因为大家认为JavaScript是一门脚本语言，是如此的简单。）所以从开始到现在，程序员们总是试图使用JavaScript来进行面向对象编程，寻找类这个东西的存在。然而不幸的是，JavaScript没有传统的类。还好我们拥有[[prototype]]这个好东西，我们才能进行所谓的面向对象编程。但这任然不是我们传统观念上的面向对象编程，即使是ES6中ECMA提供的class关键字，任然是[[prototype]]的原法糖。 detail在许多JavaScript库中都提供了类的语法糖，我们来看一下其内部是如何实现的。 类function Person(name){ this.name = name; } var tom = new Person(&apos;tom&apos;); var mike = new Person(&apos;mike&apos;); 我们可以直接用new操作符进行“类的实例化”，但是JavaScript中不存在类。所以我们实际上是新创建了一个空对象，然后将其[[prototype]]设为Person.prototype。然后将该函数的this指向新建对象，然后调用该函数，如果函数没有返回对象，就返回新建对象。 继承下面是最典型的一种继承实现方式（JavaScript中多种实现继承的方式，但大同小异）： function Person(name){ this.name = name; Person.prototype.me = function(){console.log(&apos;Person&apos;)}; } function Student(name,id){ //调用父级构造函数，相当于super Person.call(name); this.id = id; Student.prototype.onduty = function(){console.log(&apos;Studnet&apos;)}; } //&quot;继承&quot; Student.prototype = Object.create(Person.prototype); var person0 = new Person(&apos;tom&apos;); var student0 = new Student(&apos;mike&apos;,123); 我们可以看出来，所谓的继承，也就是Student.prototype = Object.create(Person.prototype)这句话，实际上是将父级类Person的[[prototype]]设置为一个空对象，该对象的[[prototype]]指向父级类Person的prototype。首先我们需要了解的是，我们有4个对象(在JavaScript中函数也是对象，可以拥有自己的属性)来储存数据： student0 student0.proto ([[prototype]]) Student Student.prototype 根据原型链的查找规则，我们在获取实例的某个属性时，会分别从：student0 —&gt; student0.proto-&gt;Student-&gt;Student.prototype查找。 看下面的图： 我们可以看到，子类的属性在实例的__proto__中，父类的属性在实例的__proto__的__proto__中，因此我们可以获取子类，父类的所有方法，我们就完成就继承。 ES6的中类上面提过，ES6中的出现了class关键字，下面我们通过ES6的方法重写一下的例子： class Person{ construct(name){ this.name = name; } speak(){ console.log(&quot;name:&quot;+this.name); } } class Student extends Person{ construct(name,id){ super(name); this.id = id; } me(){ console.log(&quot;name:&quot;+this.name); console.log(&quot;id:&quot;+this.id); } } var person0 = new Person(); var student0 = new Student(); 这个看上去漂亮多了，就像是在写传统的OOP的语言。但是实际上，它的背后任然是混乱的[[prototype]]的链。 ES6的class还有一个常用的特点，静态方法。所谓静态方法，就是直接可以在类上面直接调用的方法。 class Person{ construct(name){ this.name = name; } speak(){ console.log(&quot;name:&quot;+this.name); } static sayme(){ console.log(&apos;me&apos;); } } 想一下class背后的原理，用ES5的语法来实现以下static： Person.sayme = function(){console.log(&apos;me&apos;);} 没错，就是这么简单！只是因为这个方法是类自身的方法，并不是方法的[[prototype]]属性值。 混入(mixin)正如我们之前所说，传统的OOP意味着复制。 然而我们JavaScript中模拟的类，并不是传统的复制，而是基于原型链的“伪类”。 所以为了实现很真实的“类”，我们有了混入(mixin)这一概念。 显示混入看下面的例子： function mixin(sourceObj,tragetObj){ for(var key in sourceObj){ if(!(key in targetObj)){ targetObj[key] = sourceObj[key] } } return targetObj; } var Vehicle = { engines: 1, ignition: function(){ console.log(&quot;turn on my engine&quot;) }, drive: function(){ this.ignition(); console.log(&quot;Steering and move forward!&quot;); } }; var Car = mixin(Vehicle,{ wheel: 4, dirive: function(){ Vehicle.drive.call(this); console.log(&quot;Rolling on all&quot;+this.wheels+&quot;wheels!&quot;) } }) 没错，就是一次复制过程。现在我们也可以用： object.assign(targetObj,sourceObj); 因为这个方法的原理就是上面的mixin函数。 隐式混入思考下面代码： var something = { cool: function(){ this.greeting = &quot;hello wowld!&quot;; this.count = this.count ? this.count++ : 1; } } Something.cool(); something.greeting; //hello world something.count; //1 var Another = { cool: function(){ something.cool.call(this); } } Another.cool(); Another.greeting; //&quot;hello world&quot; Another.count; //1 (count不是共享的) 关键在于something.cool.call(this)，将something.cool函数的this指向了Another这个对象。因此，我们把Something的行为“混入”到Another中。 更合理的编程思想：行为委托类与委托的前世今生如我们前面所说，JavaScript本身是不存在类的，只是为了适应程序员们的设计习惯，我们使JavaScript中有了“类”的存在，实际上这种设计方式无疑是把吧苹果涂上橙色，在上面插上孔…然后把它装饰成橘子。但他始终都是苹果，无论我们怎么在外部伪装。既然如此，为什么我们不直接把它当成橘子来吃呢？ 如何使用行为委托看下面的例子： var Task = { setId: fucntion(id){this.id = id;}, outputID: function(){console.log(this.id)} } var someWork = Object.create(Task); someWork.prepareTask = fucntion(id,label){ this.setId(id); this.label = label; } some.outputTaskDetails = function(){ this.outputId(); console.log(this.label); } var someWork0 = Object.create(someWork); 在上面这段代码中，Task，someWork都不是类（或者函数），而是对象。我们把someWork的[[prototype]]委托给了Task。这很符合Self语言的基于原型的面向对象编程的思想。这也被成为“对象关联（OLOO）” 对象关联风格的代码还有一些不同之处。 在代码上，id和label数据成员都是直接存储someWork之上，而不是Task。 在类的思想上，我们鼓励方法的重写（多态）。也就上在子类中定义父类同名的函数。但在委托行为中恰恰相反，我们尽量避免在[[prototype]]链上存在同名函数。 Last不得不说，行为委托从语言底层来说更加适合JavaScript编程，但是越来越多的程序员习惯使用面向对象的编程思想。这迫使JavaScript不得不改变自己，比如在ES6中推出了class的语法糖，但这代表了官方的认可，也许在不久的将来，我们可以看见真正的class出现在JavaScript。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/类/"},{"name":"行为委托","slug":"行为委托","permalink":"http://yoursite.com/tags/行为委托/"}]},{"title":"javaScript深入解析2-原型及原型链","slug":"javaScript深入解析2-原型及原型链","date":"2019-07-18T12:05:44.000Z","updated":"2019-07-18T12:08:04.548Z","comments":true,"path":"2019/07/18/javaScript深入解析2-原型及原型链/","link":"","permalink":"http://yoursite.com/2019/07/18/javaScript深入解析2-原型及原型链/","excerpt":"关于原型(prototype)原型可以说是JavaScript设计中最特殊，也可以说是最精髓的设计，他遍布整个JavaScript对象。几乎也是整个JavaScript技术的核心，只有熟悉了原型，才能充分理解JavaScript中的类与委托机制了。","text":"关于原型(prototype)原型可以说是JavaScript设计中最特殊，也可以说是最精髓的设计，他遍布整个JavaScript对象。几乎也是整个JavaScript技术的核心，只有熟悉了原型，才能充分理解JavaScript中的类与委托机制了。 whatQ：什么是原型呢？ A：在所有对象中都有一个特殊的[[Prototype]]属性，其实就是对其他对象的引用。几乎所有的对象在创建时[[Prototype]]都会被赋予一个非空的值。(注意，部分浏览器将该属性暴露出来，并命名为 __proto__) Q：什么是原型链呢？ A：如上所说，每一个对象都会有一个[[Prototype]]属性，然而[[Prototype]]属性引用的也是一个对象，这个对象同样也会含有[[Prototype]]属性，这样每一个对象就如同一个链节，一起就组成了一个链，我们称之为原型链。 whyQ：为什么要设计这样一个独特的机制呢？ A：或许不应该对存在这个问题如此深究，因为这可能是第一代开发人员的灵光一现，就有了这个特征。但实际上大都认为这是一门动态编译语言，或者说是脚本语言，所以没有设计类的概念，但为了填补这个概念，就有了原型。但谁也不知道JavaScript会在接下来的几十年中发展的如此蓬勃，程序员们多么希望JavaScript有OOP的概念，于是想方设法的使用原型链来模拟类的行为，但无论如何，就现在为止，JavaScript底层是没有类的概念的，包括ES6的类，任然是原型的语法糖。 how我们了解了什么是原型，为什么会存在原型之后，就要知道我们该如何使用它了。 创建对象我们来看一下创建对象的几种方法。 var obj = {num : 0} var obj = new Object({num : 0}) 或者var obj = Object({num : 0}) var construt = function(){this.num = 0} =&gt; var obj = new construct() var obj0 = {num : 0} =&gt; var obj1 = Object.create(obj0) 这几种方法创建的对象有所不同，我们还是来解析一下： 1,2：字面量方法，创建的是一个普通对象，其[[Prototype]]指向Object(所有原型链的最终节点)。 3：new操作符： 当我们看到new操作符，一定会想到类，但是JavaScript中的new操作符与传统OOP语言中的new完全不同，JavaScript中的new只是将函数当成一个构造函数来调用。如同上一篇中所说，JavaScript中所有的函数都一样，不存在本质的构造函数，只有被new调用的函数就是构造函数。我们在回顾一下new操作符的执行过程： function C(name){ this.name = name; } var obj = new C(&apos;mw&apos;); console.log(obj); //C {name:&apos;mw&apos;} //此时obj的__proto__指向的是C.prototype 创建一个新的对象 将新对象的[[prototype]]设为C.prototype 将新对象设为函数调用的this 如果函数没有返回其他对象，则new操作符调用的函数会自动返回这个新对象 4: 使用Object.creat()函数来创建对象，实际上是创建了一个新对象，然后将其[[Prototype]]设置为对应对象，如果不加参数，则[[Prototype]]为Object对象。 var a = {num : 0}; var b = Object.create(a); console.log(b.__proto__); //{num:0,__proto__:Object} 属性获取，设置与屏蔽当我们有了一个对象，我们可能会对他们做一些操作，比如，[[get]],[[set]],或者seal,freeze等等操作。那么这个过程又是什么样的呢？ 我们提前需要了解的是：每一个对象的每一个属性都是具有属性描述： 数据属性 configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。 enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。 writable：表示能否修改属性值。默认为true。 value： 包含这个属性的数据值，读属性时，从这个位置读；写属性的时候，把新值保存在这个位置。默认为undefined。 访问器属性 configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。 enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。 get：读取属性时调用的函数。默认为undefined。 set：写入属性时调用的函数。默认为undefined。 值得注意的是： 官方来说，只能通过Reflect.defineProperty(obj,proName,proValue)，但是Firefox在最开始指定了defineGetter，defineSetter，后期Chrome，Opera，Safari也实现了该方法。 在defineProperty()中get,set不能与writable，value，同时设置。 在ES6中，将Object中的很多方法(包括defineProperty…)都放到了Reflect对象中，虽然Object任然包含该方法，但建议使用Reflect对象。 属性获取与屏蔽思考一下下面的代码： var obj = {num : 0}; var str = obj.toString(); console.log(str); //&quot;[object Object]&quot; 首先我们需要思考的是，我们并没有在obj上定义toString方法，为什么我们能够调用，并且得到一个结果(虽然并不那么漂亮)，我想你肯定猜到了，那是因为obj的原型对象Object拥有这个方法。所以，我们在或得一个对象的值时，是从链的底端开始查找，顺着原型链，一直查到顶端，如果不存在，返回undefined或者error。如果存在，则返回这个值。也就是说，我们能够在一个对象中查找到值，并不代表该对象含有该值，很有可能是该对象的原型链上的某个原型对象含有该值。 思考下面的代码： var a = {getString:function(){return &apos;from a&apos;}}; var b = Object.create(a); b.getString = function(){return &apos;from b&apos;}; console.log(b.getString()); 结果是什么呢？hava a try! 没错，结果是’from b’ 这就是我们所说的属性屏蔽，这一切的根源在于：我们是从链底查到链顶的，所以下层的同名属性会优先被获取，一旦引擎获取到该属性，则遍历结束，不会再向下查找。 属性设置与屏蔽当我们为一个对象的键赋值时，会发生三种情况： eg： var obj = {}; obj.name = &apos;value&apos; 如果在[[Prototype]]链上存在名为name的普通数据访问值，并且被标记为可写(writale:true)(默认即为true)，那就会直接在obj上添加一个名为name的新属性，它就是屏蔽属性。 如果在[[Prototype]]链上存在名为name的普通数据访问值，但是该属性被标记为只读，(writable:false)，那么无法修改已有属性或者在obj上创建屏蔽属性。如果在严格模式下，会抛出一个错误；否则会忽略该语句。总之，不会发生屏蔽。 如果在[[Prototype]]链上存在name并且它是一个setter。那就一定会调用这个setter。name不会被添加到obj上，也不会重新定义setter。 屏蔽的发生也许不像我们通常认为，还要联系对象属性的描述符来确定！我们需要记住。 隐式屏蔽正如类型转换一样，同样存在隐式屏蔽，只要操作对象的属性，都有可能发生隐式屏蔽。 比如： var obj0 = {num:0}; var obj1 = Object.create(obj0); obj1.num++ //这里发生了隐式屏蔽！！！ 只要是[[set]]，都有可能发生隐式屏蔽 修改[[Prototype]] Object.create()，该方法是最适用的方法。即在创建时就设置其prototype。 var obj0 = {num:0}; var obj1 = Object.create(obj0); //将obj0设置为obj1的prototype Object.setPrototypeOf()，该方法是ES6新增的方法。 var obj0 = {num:0}; var obj1 = Object.create(obj0); Object.setPrototypeOf(obj0,obj1); //把obj1设置为obj0的protoype 构造函数方法 var F = function(){this.a = 123}; var obj = {}; obj.prototype = new F(); 回顾一下上面new操作符，就能想明白。 检测原型链我们又该如何检测对象的原型连上存在哪些原型对象呢？ instance操作符 var obj = {}; console.log(obj instance Object); true __proto__属性，如上所说，大多数浏览器实现了__proto__(在ES6中加入了标准)，在兜底情况时，可以使用这种方法检测。 Last理解清楚原型链，我们才能清楚理解后面的委托，“类”等等。所以这一部分是基础。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"原型链","slug":"原型链","permalink":"http://yoursite.com/tags/原型链/"}]},{"title":"javaScript深入解析1-this关键字","slug":"javaScript深入解析1-this关键字","date":"2019-07-17T03:44:15.000Z","updated":"2019-07-17T03:45:24.021Z","comments":true,"path":"2019/07/17/javaScript深入解析1-this关键字/","link":"","permalink":"http://yoursite.com/2019/07/17/javaScript深入解析1-this关键字/","excerpt":"前言花了三天时间粗略看完了《你不知道的JavaScript》下部，这一部分介绍了ES6的部分内容（本书出版时ES7,8）的部分特性还未推出，因为之前已经学过ES6，所以这一遍只是温习和关注细节，感觉除了新增的特征，迭代器应该是最重要的部分，因为ES6的很多特性都用到了迭代器，包括 扩展运算符(spread)‘[…]’，泛数组的迭代(for..of循环，keys(),values(),entries()等等),其次就是Promise，这个特性用的也很多，特别是在异步操作上，配合生成器(function */)，迭代器(iterator),就是async异步函数的底层实现。 关于thisthis关键字作为JavaScript开发者必须理解的概念之一，其实并没有那么高深。 whatQ：什么是this？A：this代表的是函数运行的上下文环境。","text":"前言花了三天时间粗略看完了《你不知道的JavaScript》下部，这一部分介绍了ES6的部分内容（本书出版时ES7,8）的部分特性还未推出，因为之前已经学过ES6，所以这一遍只是温习和关注细节，感觉除了新增的特征，迭代器应该是最重要的部分，因为ES6的很多特性都用到了迭代器，包括 扩展运算符(spread)‘[…]’，泛数组的迭代(for..of循环，keys(),values(),entries()等等),其次就是Promise，这个特性用的也很多，特别是在异步操作上，配合生成器(function */)，迭代器(iterator),就是async异步函数的底层实现。 关于thisthis关键字作为JavaScript开发者必须理解的概念之一，其实并没有那么高深。 whatQ：什么是this？A：this代表的是函数运行的上下文环境。Detail： 在所有语言中，都有一个调用栈的概念，即函数被哪个对象所调用（注意JavaScript中对象的概念，几乎所有的方法，参数都有一个宿主对象，其中顶层对象在浏览器中window，在node中则为global）。所以我们再执行一个函数或调用一个变量时，默认是带有一个顶层对象前缀的，不过由于我们所有的代码都在该对象中，则可以省略，不信可以试一下： var num = 0; console.log(num); console.log(window.num); 没错，它们的结果都是0。 回归正题，所以粗略的来说，函数被调用的对象即为他的this指向(先不谈硬绑定)，最简单的例子： var obj = { num : 0, func: function(){ console.log(this.num); } } obj.func(); 执行结果是什么呢？没错，是0；因为这里的func函数由obj调用，所以this指向obj。OK,那么再看一下下面这段代码： var num = 0; var obj = { num : 1, func: function(){ console.log(this.num); } } var outterFunc = obj.func; outterFunc(); 执行结果又是什么呢？have a try!可能出乎你的意料，结果是0.So,why?思考一下我们上面的解释。 没错，也许你想通了，因为这时候的func函数并不是通过obj来调用的，所以this默认指向window，但window中num变量为0，所以结果是0. 在这之中，我们需要了解的是：在JavaScript中，函数，对象，数组，或者说所有对象即对象的子类（因为包括函数，数组皆为对象的子类）都是通过地址的形式存储，类似与C语言中的指针形式存储 思考下面代码： var func = function(){console.log(123)} 在JavaScript引擎中时如何运行完这条语句的呢？（你需要了解的是JavaScript不是一门预编译语言，而是一门解释执行的语言（即执行一句，编译一句，当然这是不完全正确的，从变量提升即可以看出来）） 查询是否存在func这个变量—否 声明这个变量 定义函数function(){console.log(123)} 将该函数存储于内存中，并取得其地址 将该地址赋值给func变量 所以func变量实际存储的是该函数的地址。所以函数实际上是没有存储作用域链中的任何信息，它总是一个独立存在的个体。这也就解释了为什么func虽然定义在obj中，但是通过某种方式提取出来后直接调用其this就指向了window。 所以你大概已经明白了了吧，思考一下下面的代码： var num = 0; function inner() { console.log(this.num) } function outter() { var num = 1; inner(); } outter(); 所以，结果是什么呢？ 我猜你肯定答对了，是0； 同样的道理，inner函数虽然在outter函数中被调用，但任然是直接调用，没有任何前缀对象，所以其this指向任然是window。 最后一个例子： var name = &quot;clever coder&quot;; var person = { name : &quot;foocoder&quot;, hello : function(sth){ var that = this; var sayhello = function(sth) { console.log(that.name + &quot; says &quot; + sth); }; sayhello(sth); } } person.hello(&quot;hello world&quot;);//foocoder says hello world 这里内层函数this指向的任然是window，有人认为是JavaScript的设计错误，但是从上面内存的角度去分析，会发现这是正确的。 why &amp; where说了这么多this，那么为什么要用this呢？又在哪里用呢？ Q：why？ A：this的使用使调用上下文对象变得更加简洁，否则，每次调用函数必须传递上下文对象，编码将及其复杂。 Q：where？ A：相信接触过OOP（面向对象编程）的同学应该熟悉这个结构(伪代码)： Class Example{ constructor(name,age) { this.name = name; this.age = age; } } declare instan = new Example(&apos;tom&apos;,23); 没错，这是一个基本类的构造，只包括了一个constructor构造器方法，其中的this指向的即是这个被实例化的对象(instan),则instan的name属性为’tom’，age属性为23。试想没有this的话，构造器该如何为实例属性赋值呢？只有显式的将instan传递给constructor函数，这将变得无比繁杂。 在js中，不仅是在类，即使是用行为委托方式编码，任然离不开this，因为总是存在对上下文对象的应用。 值得注意的是：JavaScript语言基础中并没有class的概念，即使ES6推出了class关键字，但它任然是使用原型链对类的模拟，任然是ES5部分框架class实现的语法糖 how说了那么多，还是要详细讲一下this的绑定问题： 默认绑定 独立函数调用执行默认绑定。 var a = 0; function func() { console.log(&apos;a:&apos;this.a); } func(); //a:0 如上面我们所说，这里的func是直接的函数调用，所以执行默认绑定，this指向了window对象。 值得注意的是：在strict模式下，默认绑定this为undefined var a = 0; function func() { &quot;use strict&quot; console.log(&apos;a:&apos;+this.a); } func(); //Uncaught TypeError: Cannot read property &apos;a&apos; of undefined 隐式绑定 这就是我们之前熟悉的用对象来调用函数： var obj = { num : 0, func: function(){ console.log(&apos;num:&apos;+this.num); } } obj.func(); //num:0 当含有多层对象引用的时候，只有距函数最近的一个对象为上下文对象 var obj0 = { num : 0, func: function(){ console.log(&apos;num:&apos;+this.num); } } var obj1 = { num:1, obj0:obj0 } obj1.obj0.func() //num:0 正如我们之前所说的，函数的存储与上下文对象毫无关系，所以，当我们将对象中的函数通过某种方法提取出来时，它就与原来的对象毫无关系了，其this指向则为window了（这种现象一般被称为隐式丢失）。具体可以看上面那个例子。 显示绑定 所谓显示绑定，即通过call(),apply(),以及ES6的bind()函数直接指定this的指向。 var a = 0; var obj = { a: 1 } function func() { console.log(this.a); } func.call(obj); //1 值得注意的是：call(),apply()函数的绑定是软绑定，即只在绑定这一次起作用，下一次调用时this任然执行原有绑定规则。 所以就衍生出了硬绑定，ES6之前需要手动封装硬绑定方法： function bind(fn,obj) { return function(){ return fn.apply(obj,arguments) } } //执行此方法后，函数的this指向将被永久绑定在指定对象上，无法修改。 由于这个方法需求太广泛了，所以ES6推出了官方的bind()方法，直接调用即可。 new绑定 与其他语言中构造函数的特殊性不同，在JavaScript中，构造函数是一个普通的函数，唯一的特殊点是它在执行new操作符后自动调用，并且开始执行一系列操作： 创建一个新的对象 这个新对象会被执行[[prototype]]连接(会在实例与Object原型之间在建立一层Prototype)。 这个对象将会被绑定到对应的函数的this。 如果函数没有返回其他对象，那么new表达式中函数调用会自动返回这个新对象。 第四步解释： function Fun() { reuturn { b:2 } } var instan = new Foo() //{b:2} 优先级 如果是new绑定，则this按上面的规则绑定对象。 如果是显示绑定，则this指向显示绑定的对象。 如果有隐式绑定，则this绑定在调用对象上。 否则执行默认绑定，非严格模式下为window，严格模式下位undefined。 箭头函数 =&gt;在ES6中，新加了一种声明函数的方式，箭头函数(=&gt;) ()=&gt;{} 等价于 function(){} 关于箭头函数的特性就不具体细讲，他与this相关的就是：箭头函数的this决定于外层作用域来决定： //arrayFunc var a = 0; //定义全局变量a function fun() { return (arrayFunc = ()=&gt;{ console.log(this.a); })()//这是一个立即执行函数，也可以在外围多调用一次 } var obj = { a : 1, func: fun() } fun.call(obj);//将fun的this指向obj //1 由于fun的this指向obj，而箭头函数的this根据外围函数的this决定，所以arrayFunc的this也指向obj，则a为1。 //normal var a = 0; function fun() { return (function normalFunc(){ console.log(this.a); })() } var obj = { a : 1, func: fun() } fun.call(obj); //0 这里普通函数的this根据调用的对象来确定，由于它是单独调用的，所以this指向window，则a为0。 Lastthis的用法相当重要，不管是自己原生开发，或是用框架，特别是使用框架时，由于一般框架会有一个App实例，我们的操作都在这个实例之中进行，所以会无数次用到this，所以我们必须学通。下一期写一下Protype原型链，也是JavaScript中相当重要的一个内容。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"this关键字","slug":"this关键字","permalink":"http://yoursite.com/tags/this关键字/"}]},{"title":"Promise理解","slug":"Promise理解","date":"2019-06-28T13:57:55.000Z","updated":"2021-01-29T07:22:03.607Z","comments":true,"path":"2019/06/28/Promise理解/","link":"","permalink":"http://yoursite.com/2019/06/28/Promise理解/","excerpt":"唠唠叨叨最近考试比较多，终于快结束了，间隙时间，我第一遍看了《你不知道的JavaScript》的上中篇，说实话，可能是因为译本的原因，也可能是知识比较深入，我感觉比较难理解，有时感觉一小节讲完，发现他的中心观点只有一句话。但总的来说，这是套值得深入研读的书籍，暑假我将再次研读。","text":"唠唠叨叨最近考试比较多，终于快结束了，间隙时间，我第一遍看了《你不知道的JavaScript》的上中篇，说实话，可能是因为译本的原因，也可能是知识比较深入，我感觉比较难理解，有时感觉一小节讲完，发现他的中心观点只有一句话。但总的来说，这是套值得深入研读的书籍，暑假我将再次研读。 Promise的神秘面纱ES6的知识点着实比较庞大，除了对Number，Array等的扩展。Promise这个概念也很吸引人。比如著名的axios就是采用Promise来封装的。 我在《你不知道的JavaScript》中看到一个比较形象的比喻，当你去买一个汉堡包，你先把钱给服务员，然后服务员会给你一个凭证，在这个汉堡包被完成之前，凭证即代表了你的汉堡包。一段时间过后，服务员通知你结果。但这是服务员可能会对你说：‘Sorry Sir,hamburger has sold out…’这种失败的结果即为Promise中的reject。但大多数情况下，我们期望并得到的结果是一个汉堡包 （ solved）。 也就是说：Promise是一个容器，里面保存着未来才会结束的事件（通常是一个一步操作）的结果。 Promise的特点 Promise的状态不收外界的影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise的基本用法 12345678910111213141516//定义promisevar promise = new Promise(function(resolve,reject) &#123; var res = asycFunc(); if(res.code 满足条件)&#123; resolved(res.data); &#125;else&#123; reject(res.data) &#125;&#125;)//调用promise//1(不推荐). promise.then(res =&gt; &#123;show(res)&#125;,err=&gt;(handleError(err)))//2(推荐). promise.then(res =&gt; &#123;show(res)&#125;).catch(err =&gt; &#123;handleError(err)&#125;) 第二种的好处在于，1.采用链式的写法可以捕获前一个then抛出的错误，而一then中同时写resolve与reject无法做到。2.在语法上更人性化，类似于try…catch…语法。但实际catch = then(null,rejection).都是捕获产生的错误，包括rejected，Error；对于错误，还有一点值得注意的是，reject或者resolve即代表这个promise状态的冻结。类似于函数的return，这两个语句一旦发生，其后面所有的语句都将无效。即使是抛出错误，也无法再被catch所捕获。 Promise的链式玩法 前面的then…catch…其实已经是链式的写法了。 Promise有3个函数可以链式调用。分别是 then(func(reslved,rejected){...}): 为Promise实例添加状态改变时的回调函数。 catch(func(err){...}): 用于指定发生错误时的回调函数。包括rejected也被他处理。 finally(func(){...}): 无论状态如何，是否抛出错误。都将执行该回调。 但其能够一直链式调用的原因是：这3个函数每次调用都会产生一个新的Promise对象，并且这个新的promise会将旧的promise返回值作为参数，这个对象又包含了这3个方法，所以可以一直链式调用。 Promise的高级玩法（模式） Promise.all([p1,p2,…]) 说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为： a. 所有的Promise的值变为resolved时，该对象才返回resolved，并返回所有的结果。b. 一旦有一个Promise对象返回rejected，则整个对象返回rejected，并返回错误原因。 由Promise封装的axios中，有axios.all([re1,re2,…])方法 Promise.race([p1,p2,…]) 说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为： a. 当第一个Promise返回resolved时，整个Promise状态变为resolved，并返回第一个Promise resolved的结果，一旦有任何一个Promise决议为拒绝，他就会拒绝。 值得注意的 Promise.all在传入空数组时，会立即返回resolved；但Promise.race会被一直挂起。所以不要想Promise.race中传递空数组。希望ECMA会尽快修改这一点。 一些骚操作 在《你不知道JavaScript》一书中，提出来一些ES6标准之外的Promise模式之外的一些扩展模式，比如： Promise.none([...]):与Promise.all的情况互换，即所有的Promise都rejected才rejected。反之则返回resolved。 Promise.any([...]):与race相对，该模式忽略rejected，得到第一个resolved。 Promise.first([...]):这个模式类似与any([…])的竞争，，即只要第一个Promise完成，他就会忽略有序的任何拒绝和完成。 Promise.last([...]):这个类似与first([…]，但确实最后一个完成胜出。 示例：Promise.first([...])的实现 //polyfill安全的guard检查 if(!Promise.first){ Promise.first = function(prs){ //返回最终的Promise对象 return new Promise(function(resolve,reject){ //把所有的Promise循环一次 prs.forEach(function(pr){ //把值规整化，并且不管哪个先完成，就决议组Promise Promise.resolve(pr).then(resolve); }) }) } } Promise的实际应用 异步加载图片 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; 异步Ajax 1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 最后Promise着实避免了回调函数的一些缺陷，并且它的使用也越来越广泛，包括后面的async异步函数，也是利用Promise来完成的，因此，这里简单的了解一下Promise还是很有必要的。 2021年1月18日补充概念 其在新建时就开始立即执行，一旦完成，其状态就会”凝固“。 “凝固”过后其状态就不会发生改变，并且与事件不同的是，其可以随之被监听，即： 1234567891011const p1 = new Promise(resolve, reject)&#123; setTimeout(()=&gt;&#123;resolve(1)&#125;, 3000)&#125;p1.then((res) =&gt; &#123; console.log(`$&#123;res&#125;--第一次获取`)&#125;)p1.then((res) =&gt; &#123; console.log(`$&#123;res&#125;--第二次获取`)&#125;) 第一个结果为：1—第一次获取 第二个结果为：1—第二次获取 注意：这两次执行都会在3秒过后执行，并且都会执行；这里区别于普通事件，一旦错过，就无法再监听到了。但是Promise在操作完成后会凝固状态，无论后面在什么时候进行监听（定义其then函数）都会被执行。 以实现的接口 Promise.all([p1, p2, p3])，其返回结果分为两种： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 注意：注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [\"hello\", Error: 报错了] Promise.race([p1, p2, p3])：上面代码中，只要p1、p2、p3之中有一个实例率先改变状态（无论是fulfilled还是reject），p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 下面这个即利用这个特性完成请求超时： 12345678910const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); Promise.allSettled(p1, p2, p3)：方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。 123456789101112const resolved = Promise.resolve(42);const rejected = Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123; console.log(results);&#125;);// [// &#123; status: 'fulfilled', value: 42 &#125;,// &#123; status: 'rejected', reason: -1 &#125;// ] Promise.any(p1, p2, p3)：该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。（与all相反） 1234567891011const promises = [ fetch('/endpoint-a').then(() =&gt; 'a'), fetch('/endpoint-b').then(() =&gt; 'b'), fetch('/endpoint-c').then(() =&gt; 'c'),];try &#123; const first = await Promise.any(promises); console.log(first);&#125; catch (error) &#123; console.log(error);&#125; Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。 捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。 12345678Promise.any(promises).then( (first) =&gt; &#123; // Any of the promises was fulfilled. &#125;, (error) =&gt; &#123; // All of the promises were rejected. &#125;); 下面是一个例子。 1234567891011var resolved = Promise.resolve(42);var rejected = Promise.reject(-1);var alsoRejected = Promise.reject(Infinity);Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123; console.log(result); // 42&#125;);Promise.any([rejected, alsoRejected]).catch(function (results) &#123; console.log(results); // [-1, Infinity]&#125;); Promise.resolve()：有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function (value) &#123; console.log(value); // 42&#125;); 上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出42。 参数不是具有then()方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。 123456const p = Promise.resolve('Hello');p.then(function (s) &#123; console.log(s)&#125;);// Hello 上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。 Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 Promise.reject()：会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 12345Promise.reject('出错了').catch(e =&gt; &#123; console.log(e === '出错了')&#125;)// true 上面代码中，Promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。 目前Chrome(87)中的以实现上述方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"杂记兼第一个开源项目","slug":"杂记兼第一个开源项目","date":"2019-05-19T16:00:30.000Z","updated":"2019-05-19T16:02:46.292Z","comments":true,"path":"2019/05/20/杂记兼第一个开源项目/","link":"","permalink":"http://yoursite.com/2019/05/20/杂记兼第一个开源项目/","excerpt":"碎碎念最近过完了第一遍《JavaScript高级程序设计》，有两个感觉 JavaScript体系还是很巨大，值得深入挖掘 这本书太过老旧，我看了一下第一版是在2012年发行，最近一次修订是在2019年，但这一次修订并没有大范围修改书中的内容，仅仅添加了部分ES6的内容，并且ES6还是不是正式版，其中的ArrayType在正式版ES6中并没有实现。","text":"碎碎念最近过完了第一遍《JavaScript高级程序设计》，有两个感觉 JavaScript体系还是很巨大，值得深入挖掘 这本书太过老旧，我看了一下第一版是在2012年发行，最近一次修订是在2019年，但这一次修订并没有大范围修改书中的内容，仅仅添加了部分ES6的内容，并且ES6还是不是正式版，其中的ArrayType在正式版ES6中并没有实现。 虽然如此，总体来说这本书还是非常有价值的，深入的讲解了JavaScript，包括组成部分，ECMAScript+BOM+DOM,HTMLDOM与XML的关系这些以前比较少了解的东西，还有原型链，作用域，实现继承等老生常谈的东西。感觉这本书还是要多刷几次，暑假回家配合《你不知道的JavaScript》二刷，去研究更细微的东西。 第一个开源项目：PageWindow一直在学习，做工程项目，想想也该是时候做一点开源项目，让明年面试更有利一点~ 这个项目使我一直想做的，其实很简单，就是实现页面上模拟windows窗口，好像目前是有这种东西，但我是想将其封装成一个UI库。进而实现伪多任务。 这里主要就是涉及DOM操作。包括鼠标操作比较多： mousedown mouseup mousemove click 第一个demo遇到就是阻止冒泡与阻止默认事件 阻止冒泡 e.stopPropagation() 标准W3C方法 e.cancelBubble = true IE专用，但chrome，firefox也实现了属性 阻止默认事件 e.preventDefault() 标准W3C e.returnValue = false IE专用，但chrome，firefox也实现了属性","categories":[{"name":"pageWindow","slug":"pageWindow","permalink":"http://yoursite.com/categories/pageWindow/"}],"tags":[{"name":"pageWindow","slug":"pageWindow","permalink":"http://yoursite.com/tags/pageWindow/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"项目实际问题一:对象深浅拷贝问题","slug":"项目实际问题一-对象深浅拷贝问题","date":"2019-05-18T00:32:35.000Z","updated":"2021-01-29T06:59:19.562Z","comments":true,"path":"2019/05/18/项目实际问题一-对象深浅拷贝问题/","link":"","permalink":"http://yoursite.com/2019/05/18/项目实际问题一-对象深浅拷贝问题/","excerpt":"第一次经手比较大型的项目，总结第一个问题：对象的深拷贝问题。之前没注意这个问题，写完代码发现总是与自己的想法不符合，经调试才发现是对象的深浅拷贝问题。 原理的话也很简单，对象作为基本类型之外的引用类型，在栈内存中保存着引用变量的名字，而这个变量保存的实际是一个地址，这个地址指向堆内存，实际这个变量的值是保存在堆内存中。 所以当我们直接用 “=” 进行变量copy时，实际copy的是对内存中的地址。copy之后改变原变量的值同样会使新变量的值进行改变。所以有时候我们需要进行深拷贝来在堆内存中开辟一个新的内存空间来放置副本，切断新旧变量之间的联系。","text":"第一次经手比较大型的项目，总结第一个问题：对象的深拷贝问题。之前没注意这个问题，写完代码发现总是与自己的想法不符合，经调试才发现是对象的深浅拷贝问题。 原理的话也很简单，对象作为基本类型之外的引用类型，在栈内存中保存着引用变量的名字，而这个变量保存的实际是一个地址，这个地址指向堆内存，实际这个变量的值是保存在堆内存中。 所以当我们直接用 “=” 进行变量copy时，实际copy的是对内存中的地址。copy之后改变原变量的值同样会使新变量的值进行改变。所以有时候我们需要进行深拷贝来在堆内存中开辟一个新的内存空间来放置副本，切断新旧变量之间的联系。 方法对象的深拷贝适用于所有类型的对象（含数组） JSON.parse(JSON.stringfy(Object)) Point:这是最简单的进行深拷贝的方法，其原理是先将其转换为JSON字符串，此时就不在存在原变量的堆地址，而是以字符串-基本变量保存在栈地址中。再将其转换回对象，则是一个完全与原变量无关的新变量。但是该方法会丢失对象所有的函数属性，undefined，以及会重置原型对象为Object(),或Array(),如果没修改多原型对象，则没有影响。 递归遍历对象 12345678910111213141516function deepClone(obj)&#123; if(typeof obj == 'object')&#123; let newObject = &#123;&#125;; let keys = Object.keys(obj); let values = Object.values(obj); for(value of values)&#123; if(typeof value == 'object')&#123; value = deepClone(value); //递归调用deepClone &#125; &#125; for(let i = 0; i&lt; keys.length ;i++)&#123; newObject[keys[i]] = values[i]; &#125; return newObject; &#125;&#125; } 使用lodash库中的cloneDeep()函数，其原理与上述原理一样，但健壮性更高。 适用于简单对象 Object.assign() eg: const obj = { a: 1 }; const copy = Object.assign({}, obj); console.log(copy); // { a: 1 } Point:该方法只适用于由基本数据类型组成的对象，不能用于对象键或值包含引用类型，否则任然是浅拷贝。同时，该函数会忽略undefined与null值（可以用来过滤无效值） 使用于简单数组 Array.slice(startPositong,endPositon) Array.contact(arr1,arr2) array.splice(startPositon,delteteNum,addArr1,addArr2...) 数组的迭代方法：Array.every(),Array.filter(),Array.map() Point:使用以上方法，必须是由基本数据类型组成的数组，数组项不能包含引用类型，否则任然是浅拷贝！！！ Final以上方法都只会转化可枚举项，对于不可枚举项，都是默认忽略的。 综上，JSON.parse(JSON.stringfy(obj))应该算是最简单且最易用的方法了，并且原生代码的效率相较于JS也会有优势，所以，如果仅仅为了深拷贝，没有其他需求，该方法是比较好的方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"深拷贝","slug":"深拷贝","permalink":"http://yoursite.com/tags/深拷贝/"}]},{"title":"项目部署引发的知识","slug":"项目部署引发的知识","date":"2019-04-09T13:38:21.000Z","updated":"2019-04-21T15:35:43.718Z","comments":true,"path":"2019/04/09/项目部署引发的知识/","link":"","permalink":"http://yoursite.com/2019/04/09/项目部署引发的知识/","excerpt":"项目部署之前一直在写东西，都没怎么部署过项目，特别是Linux系统下，本来之前买服务器是想买一个Linux的服务器的，然而，学生党只配用Windows，万恶的阿里云。现在又可以买Linux的了，然而我又不想重新布属我的项目。今天再部署Linux时，才发现完全不会。枯了~ git命令开发最常用命令 git status //查看项目状态 git add . //把所有修改文件推送到stage中 git commit -m des(描述) git push //推送到默认分支 git push origin master(本地分支名) : master(远程仓库名) 常用命令 git config –global user.name “Tocy” //配置用户名 git config –global user.email zyvj@qq.com //配置邮箱 git clone 仓库地址 //将远程仓库拉至本地 git add 文件名 //将某一文件提交至stage git diff //查看当前目录的所有修改 git remote add [short_name] [url] //添加远程仓库 git branch //列出所有分支 -* 本地 -r 远程 -a 本地与远程 git branch [branch-name] //新建一个分支 git checkout -b [branch-name] //新建并切换到该分支 git branch -d [branch-name] //删除该分支 git checkout [file] //恢复暂存区的指定文件到工作区 git checkout . //恢复暂存区的所有文件到工作区","text":"项目部署之前一直在写东西，都没怎么部署过项目，特别是Linux系统下，本来之前买服务器是想买一个Linux的服务器的，然而，学生党只配用Windows，万恶的阿里云。现在又可以买Linux的了，然而我又不想重新布属我的项目。今天再部署Linux时，才发现完全不会。枯了~ git命令开发最常用命令 git status //查看项目状态 git add . //把所有修改文件推送到stage中 git commit -m des(描述) git push //推送到默认分支 git push origin master(本地分支名) : master(远程仓库名) 常用命令 git config –global user.name “Tocy” //配置用户名 git config –global user.email zyvj@qq.com //配置邮箱 git clone 仓库地址 //将远程仓库拉至本地 git add 文件名 //将某一文件提交至stage git diff //查看当前目录的所有修改 git remote add [short_name] [url] //添加远程仓库 git branch //列出所有分支 -* 本地 -r 远程 -a 本地与远程 git branch [branch-name] //新建一个分支 git checkout -b [branch-name] //新建并切换到该分支 git branch -d [branch-name] //删除该分支 git checkout [file] //恢复暂存区的指定文件到工作区 git checkout . //恢复暂存区的所有文件到工作区 Linux安装node.js 到根目录 cd ~ 建一个文件夹 mkdir deploy 下载node包 wget https://nodejs.org/dist/v10.11.0/node-v10.11.0-linux-x64.tar.xz 解压node包 tar zf node-v10.11.0-linux-x64.tar.xz 重命名包 cd node-v10.11.0-linux-x64.tar.xz/bin &amp;&amp; ls 查看node,npm的版本 ./node -v ./npm -v 设置环境变量 vim ~/.bash_profile 在文件尾部添加以下内容 export NODE_HOME=/deploy/node-v8.11.3-linux-x64 export PATH=$PATH:$NODE_HOME/bin 退出vim: 按 esc 输入:wq enter 退出 保存profile文件 source /etc/profile 将目录软链接到全局环境下（命令后面的/usr/local/bin/node是固定的） ln -s /deploy/node-v8.11.3-linux-x64/bin/node /usr/local/bin/node ln -s /deploy/node-v8.11.3-linux-x64/bin/npm /usr/local/bin/npm 检验安装是否成功 node -vnpm -v 安装Nginx 安装yum npm install yum 安装依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 下载Nginx //创建一个文件夹 cd /usr/local mkdir nginx cd nginx //下载tar包 wget http://nginx.org/download/nginx-1.13.7.tar.gz tar -xvf nginx-1.13.7.tar.g 安装Nginx //进入nginx目录 cd /usr/local/nginx //执行命令 ./configure //执行make命令 make //执行make install命令 make install Nginx常用命令 //测试配置文件 安装路径下的/nginx/sbin/nginx -t //启动命令 安装路径下的/nginx/sbin/nginx //停止命令 安装路径下的/nginx/sbin/nginx -s stop 或者 : nginx -s quit //重启命令 安装路径下的/nginx/sbin/nginx -s reload //查看进程命令 ps -ef | grep nginx Nginx虚拟域名配置及测试验证 //编辑nginx.conf sudo vim /usr/local/nginx/conf/nginx.conf //增加行 include vhost/*.conf //保存退出 ：wq enter //在/usr/local/nginx/conf目录新建vhost文件夹 mkdir vhost //创建每个域名的配置 sudo vim jimisun.com.conf //节点中增加入响应的配置 端口转发 或者访问文件系统 Nginx启动 //进入nginx安装目录 cd sbin sudo ./nginx 测试访问 http://ip地址","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Vue-review-router","slug":"Vue-review-router","date":"2019-03-20T14:36:33.000Z","updated":"2019-03-20T14:38:10.841Z","comments":true,"path":"2019/03/20/Vue-review-router/","link":"","permalink":"http://yoursite.com/2019/03/20/Vue-review-router/","excerpt":"最基本的一个路由展示域 在Vue控制域中写入router规定的标签 Go to Login //该项为路由的链接，默认为a标签 Go to Register//该项为路由的链接，默认为a标签 //该项为渲染路由组件的位置 以下步骤一般不能交换，因为存在相互依赖关系","text":"最基本的一个路由展示域 在Vue控制域中写入router规定的标签 Go to Login //该项为路由的链接，默认为a标签 Go to Register//该项为路由的链接，默认为a标签 //该项为渲染路由组件的位置 以下步骤一般不能交换，因为存在相互依赖关系 创建组件模板 const login = {template:&apos;&lt;h1\\&gt;这是一个登录框&lt;/h1\\&gt;&apos;}; const register = {template:&apos;&lt;h1\\&gt;这是一个注册框&lt;/h1\\&gt;&apos;}; 创建一个routes对象作为VueRouter的参数 const routes = [ {path:&apos;/login&apos;,component:login}, {path:&apos;/register&apos;,component:register} ] 创建一个VueRouter实例，并将上面的routes作为参数，值得注意的是，这里的参数名字是routes，下面是使用ES6的写法简写对象名 const router = new VueRouter({ routes }) 创建Vue实例，值得注意的是，这之中的路由参数为router，下面是使用ES6的写法简写对象名 const vm = new Vue({ el:&apos;#app&apos;, router }) 路由重定向需要添加的是,在创建routes对象时 //创建一个routes对象 const routes = [ //这里是重要点，给需要添加默认路由的加路由加上redirect属性，其值为要转向的路由地址 {path:&apos;/&apos;,redirect:&quot;/login&quot;}, {path:&apos;/login&apos;,component:login}, {path:&apos;/register&apos;,component:register} ] 子路由的使用JavaScript： &lt;script&gt; //创建模板 const teacher = {template:&quot;#teacher&quot;}; const student = {template:&quot;#student&quot;} const teacherName = {template:&quot;&lt;h1&gt;这是老师的名字&lt;/h1&gt;&quot;} const studentName = {template:&quot;&lt;h1&gt;这是学生的名字&lt;/h1&gt;&quot;} const teacherId = {template:&quot;&lt;h1&gt;这是老师的序号&lt;/h1&gt;&quot;} const studentId = {template:&quot;&lt;h1&gt;这是学生的序号&lt;/h1&gt;&quot;} //创建父级routes对象 routes = [ { path:&apos;/student&apos;, component:student, //注意这里子路由的申明的方式 children:[ {path:&apos;name&apos;,component:studentName}, {path:&apos;id&apos;,component:studentId} ] }, { path:&apos;/teacher&apos;, component:teacher, children:[ {path:&apos;name&apos;,component:teacherName}, {path:&apos;id&apos;,component:teacherId} ] } ] //创建VueRouter实例 const router = new VueRouter({ routes }) //创建Vue实例 const vm = new Vue({ el:&quot;#app&quot;, router }) &lt;/script&gt; body &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/student&quot;&gt;student&lt;/router-link&gt; &lt;router-link to=&quot;/teacher&quot;&gt;teacher&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; //注意这里在模板中申明子路由的link和view &lt;template id=&quot;teacher&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/teacher/name&quot;&gt;这是老师的名字 &lt;/router-link&gt; &lt;router-link to=&quot;/teacher/id&quot;&gt;这是老师的id&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; //注意这里在模板中申明子路由的link和view &lt;template id=&quot;student&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/student/name&quot;&gt;这是学生的名字 &lt;/router-link&gt; &lt;router-link to=&quot;/student/id&quot;&gt;这是学生的id&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 带名视图body &lt;div id=&quot;app&quot;&gt; //注意下面的router-view中都是带有name属性的 &lt;h1&gt;这里是默认视图&lt;/h1&gt; &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;h1&gt;这里只显示学生的视图&lt;/h1&gt; &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;h1&gt;这里只显示老师的视图&lt;/h1&gt; &lt;router-view name=&quot;tea&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=&quot;default&quot;&gt; &lt;div&gt; &lt;h1&gt;这是默认的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;stu&quot;&gt; &lt;div&gt; &lt;h1&gt;这是学生的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;tea&quot;&gt; &lt;div&gt; &lt;h1&gt;这是老师的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; js部分 //创建模板 const defaultView = {template:&quot;#default&quot;}; const stuView = {template:&quot;#stu&quot;}; const teaView = {template:&quot;#tea&quot;}; //创建路由参数,这里是关键，component的value可以是一个对象，该对象的键值就是视图的名字和模板对应的名字 const routes = [ { path:&quot;/&quot;, components:{ default:defaultView, stu:stuView, tea:teaView } } ] //创建路由实例 const router = new VueRouter({ routes }) //创建Vue实例 const vm = new Vue({ el:&quot;#app&quot;, router })","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"VueRouter","slug":"VueRouter","permalink":"http://yoursite.com/tags/VueRouter/"}]},{"title":"webpack中ES6代码的压缩问题","slug":"webpack中ES6代码的压缩问题","date":"2019-03-16T03:06:14.000Z","updated":"2019-03-17T14:19:55.978Z","comments":true,"path":"2019/03/16/webpack中ES6代码的压缩问题/","link":"","permalink":"http://yoursite.com/2019/03/16/webpack中ES6代码的压缩问题/","excerpt":"问题webpack中ES6代码压缩问题： 在使用webpack插件uglifyjs-webpack-plugin压缩JS代码时，发现该插件只能压缩ES5-的代码，遇到ES6，就会报错ERROR in xxx.js from UglifyJs,遂查找解决办法。","text":"问题webpack中ES6代码压缩问题： 在使用webpack插件uglifyjs-webpack-plugin压缩JS代码时，发现该插件只能压缩ES5-的代码，遇到ES6，就会报错ERROR in xxx.js from UglifyJs,遂查找解决办法。 原理解决办法原理如上所说，uglifyjs-webpack-plugin该插件仅支持ES5-的JS代码。 解决办法1. 不使用ES6语法这个办法理论上可行，但是面对ES6那么多方便快捷的语法，不使用的话会大大降低开发的进度，所以一般不使用该方法。 2. 使用babel-loader将ES6转化为ES5代码该方法是网上流行最广的解决办法，具体是： 安装es2015插件 npm install --save babel-preset-es2015 安装babel-loader npm install babel-loader 也许是我环境的问题，网上的教程上都没这一步，但是，如果不安装babel-loader，就会报错ERROR in Entry module not found: Error: Can&#39;t resolve &#39;babel-loader&#39; in........., 这一步需要注意的是： babel-loader必须与babel-core版本相同，否则会报错Error: Cannot find module &#39;@babel/core&#39;,这一点需要自己到package.json中查看babel-loader,与babel-core的版本来确定。（比如，babel-core版本是：6.23.3那么你装的babel-loader必须是7.1.5以下的版本，否则loader就与core不匹配了，注意如果直接npm install babel-loader，默认是安装8.0.0的，所以不兼容） 配置webpack.congfig.js 在rules里加入对js代码的过滤 { test: /\\.js$/, loader: &apos;babel-loader&apos;, options:{ presets:[&quot;es2015&quot;] }, exclude:[/node_modules/] } 建.babelrc文件 在项目根目录新建一个文件名为.babelrc的文件，填入以下内容： { &quot;presets&quot;: [&quot;es2015&quot;] } 这是网上流传最广的办法，不过步骤繁琐，麻烦，下面介绍最优解决方案 3.使用uglifyes-webpack-plugin插件其实上面的坑都是我一个一个经历的，网上的解决办法都是不完整，当我踩完所有坑，感觉这个方法太繁琐了。然后我就准备去深入了解一下uglifyjs-webpack-plugin这个插件，结果无意间发现uglify有一个专门针对ES6的插件uglifyes-webpack-plugin，哇，一试就知道有多爽，完全没有那么多步骤： 安装： npm install uglifyes-webpack-plugin webpack.config.js： const UglifyEsPlugin = require(&quot;uglifyes-webpack-plugin&quot;); plugins:[ new MiniCssExtractPlugin({ //css压缩 filename:&apos;[name][hash].css&apos;, chunkFilename:&apos;[id].[hash].css&apos; }) ], optimization:{ minimizer :[ new UglifyEsPlugin({}), //直接引用 new OptimizeCSSAssetsPligin({}) //css压缩 ] 其实就一句话：new UglifyEsPlugin({}),,与uglifyjs-webpack-plugin的使用一样简单。 需要注意的是uglifyes-webpack-plugin与uglify-es-webpack-plugin并不是同一个插件，前者是官方的，也就是与uglifyjs-webpack-plugin一个维护者的，而后者已被弃用并不再维护 Point 该插件默认就会将ES6代码改成ES5代码，并且有压缩，混淆等功能，与uglifyjs-webpack-plugin基本一致，下面是他的一些重要的API： test:匹配的文件，默认/.js($|?)/i，接受正则表达式 mangle:是否混淆代码，默认为true sourceMap：是否启用SourceMap,默认为false compress: 自定义压缩选项，内容是一个对象，默认{}，该选项下的子选项很重要，提一下 sequences：是否使用逗号运算符来连接连续的表达式，默认true properties：是否优化属性读取方式：a[“foo”] → a.foo，默认true dead_code：是否丢弃不可达代码，默认true drop_debugger：是否丢弃调试语句，默认true unsafe：是否优化危险代码，默认false conditionals：是否优化 if-else 条件语句，默认true comparisons：是否优化比较代码，默认true evaluate：是否直接计算常量的值，默认true booleans：优化布尔表达式，默认true loops：是否优化循环代码，默认true unused：是否丢弃不使用的变量，函数，默认true。这里需要注意，如果你的函数本来就是一个DOM触发事件函数，请关闭此选项，否则，该函数将会被丢弃！！！ hoist_funs：是否提升函数的申明，默认true hoist_vars：是否提升变量的申明，默认false if_return：是否优化优化if/return 和 if/continue join_vars：是否将加入变量申明，默认true cascade：优化连续语句，将 x, x 转成 x，x = something(), x 转成 x = something()——声明变量，默认true side_effects：丢弃副作用声明，默认true warnings：警告潜在的危险优化/代码，默认true global_defs：定义全局变量，默认{} extractComments：是否要删除注释，默认false，接受boolean，正则，函数，对象。 include： 要转化的文件，默认无，接受字符串，正则 exclude：在test验证通过后不转化的文件，默认空，接受字符串，正则 相较于uglifyjs-webpack-plugin，uglify-es-webpack-plugin功能要相对少一些，但基本也能满足要求 附uglifyjs-webpack-plugin常用API： test：测试匹配的文件，接受String|RegExp|Array&lt;String|RegExp&gt;,默认/.js(?.*)?$/i cache: 是否启用文件缓存 ，接受Boolean|String,默认false parallel:是否启用多进程来提高构建速度，接受Boolean|Number，默认false sourceMap: 是否启用SourceMap(将错误信息映射值模块源文件)，开启可能会降低编译速度，接受Boolean，默认false uglifyOptions：压缩选项 extractComments：是否保留注释，接受Boolen,String,RegEXp,function,Object,默认false warningsFilter:允许过滤uglify-js警告。返回true以保持警告，否则为false。接受Function&lt;(warning, source) -&gt; Boolean&gt; Default: () =&gt; true 最后是UglifyJS的官网。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Image对象的complete与onload()事件(以及Canvas的drawImage()函数)","slug":"Image对象的complete与onload()事件(以及Canvas的drawImage()函数)","date":"2019-03-12T11:45:26.000Z","updated":"2019-03-12T11:53:08.590Z","comments":true,"path":"2019/03/12/Image对象的complete与onload()事件(以及Canvas的drawImage()函数)/","link":"","permalink":"http://yoursite.com/2019/03/12/Image对象的complete与onload()事件(以及Canvas的drawImage()函数)/","excerpt":"问题之前基本看完了canvas的API，准备做一个小游戏，emmm，然后今天就遇到了问题，我本来以为是canvas的问题，但是仔细分析之后才发现是JS中的问题：","text":"问题之前基本看完了canvas的API，准备做一个小游戏，emmm，然后今天就遇到了问题，我本来以为是canvas的问题，但是仔细分析之后才发现是JS中的问题： 回顾关于HTML与JS的关系可以从网页的加载顺序来看，当浏览器打开网页的时候，网页由上至下的解析该网页，然后开始构建DOM树(Document Object Model)(属于JavaScript)，也就是说将HTML的每一个标签构建成一个相应的对象，但是DOM整体就是一个对象，每一个标签是其的一个子对象，对比与JSX有些相似,遇到JS或CSS时利用相应引擎进行解析。从这里就可以理解出，在网页完成加载后，每一个标签就成为了DOM这个对象里的一个子对象，我们使用相应的方法，比如Document.getElementById(“xxx”)就可以获取相应的对象，并进行操作。 Image()对象由上可知，Image()也是一个节点对象，只是是否渲染至页面上的问题。 Image对象的属性 属性 描述 属性 描述 align 设置或返回与内联内容的对齐方式。 align 设置或返回与内联内容的对齐方式。 alt 设置或返回无法显示图像时的替代文本。 alt 设置或返回无法显示图像时的替代文本。 border 设置或返回图像周围的边框。 border 设置或返回图像周围的边框。 complete 返回浏览器是否已完成对图像的加载。 complete 返回浏览器是否已完成对图像的加载。 height 设置或返回图像的高度。 height 设置或返回图像的高度。 hspace 设置或返回图像左侧和右侧的空白。 hspace 设置或返回图像左侧和右侧的空白。 id 设置或返回图像的 id。 id 设置或返回图像的 id。 isMap 返回图像是否是服务器端的图像映射。 isMap 返回图像是否是服务器端的图像映射。 longDesc 设置或返回指向包含图像描述的文档的 URL。 longDesc 设置或返回指向包含图像描述的文档的 URL。 lowsrc 设置或返回指向图像的低分辨率版本的 URL。 lowsrc 设置或返回指向图像的低分辨率版本的 URL。 name 设置或返回图像的名称。 name 设置或返回图像的名称。 src 设置或返回图像的 URL。 src 设置或返回图像的 URL。 useMap 设置或返回客户端图像映射的 usemap 属性的值。 useMap 设置或返回客户端图像映射的 usemap 属性的值。 vspace 设置或返回图像的顶部和底部的空白。 vspace 设置或返回图像的顶部和底部的空白。 width 设置或返回图像的宽度。 width 设置或返回图像的宽度。 标准属性 属性 描述 className 设置或返回元素的 class 属性。 title 设置或返回元素的 title。 Image对象的事件句柄 事件句柄 描述 onabort 当用户放弃图像的装载时调用的事件句柄。 onerror 在装载图像的过程中发生错误时调用的事件句柄。 onload 当图像装载完毕时调用的事件句柄。 浅谈图片加载complete属性：图片显示出来之后其属性由false变为true在这个属性上，IE与其他浏览器有所不同，IE是根据图片的src属性是否是一个有效的图片地址值。即，在IE下，只有当image()对象的src值为一个正确的图片地址时，complete值才为true，否则一直为false，但是在其他浏览器下，当image()对象呗定义完成的时候，其complete值就为true，不会检测其src属性的有效性 也就是说：complete这个属性在IE系浏览器与其他浏览器的判断方式不一样，所以对于适配性来说，最好不用 onload()回调事件onload()是当图像装载完毕后调用的函数。关键是如何才算是装载完毕，经测试， 当我们直接在HTML中定义一个标签，并且在其中规定其onload事件，只有当src属性填写正确时，才算是装载完成，否则onload事件一直不触发，直至修改其src值为有效图片地址的时候才算是装载完成。 当我们在JS代码中手动生成一个Image()对象时，无论其src值是否被赋值为有效的图片地址，其onload事件总会触发，即当我们手动生成一个 Image 对象时，一旦其被生成，则认定为装载完成，立即调用onload事件。至于原因，我还没弄明白，看来需要深入的去了解一下浏览器机制，才能明白这一点。 Canvas中悟到的Image对象的用发法 ctx.drawImage(img,x,y)中的Img应当是一个Image对象，可以是从DOM树中获取的Image()子对象，也可以是一个自己定义的Image()对象，不管是这两者中的哪一者，再绘制到画板上时，都必须将绘制语句写到该对象的onload()函数中，其原因在于，Image()的定义是一个异步执行的操作，也就是说，在执行到let img = new Image()时，JS引擎不会等待该语句执行完毕在继续执行，而是直接继续执行，在对象定义完成时，就会自动调用其onlaod.onerror,onabort回调事件。那么问题就是，可能在对象还没有定义完成的时候，已经执行到了ctx.drawImage()这一条语句，所以绘制不出任何效果(而且大部分情况下，JS语句的执行都是快于对象的定义，所以基本上都绘制不出图形)。所以所有的Canvas图形绘制都必须是在onload中进行的。 问题又出现了，那如果要就行较大型的图形绘制，我不可能把所有代码都写到一个函数里吧，所以再写多个函数时就要多次调用onload事件，但是一个图片的onload事件只能执行一次。所以我想到了一种错误的方法，在不同寒暑表中多次载入同一张图片，并分别调用其回调函数onload，结果当然是失败了。这种情况下onload事件的顺序是无法确定的，即使你是前后分别执行，因为onload函数是异步进行的，现在惟一的办法就是把这张图片统一载入，然后想办法将下面的代码都建立在onlaod函数执行的前提下。然后我找到了一种方法： let img = new Image(); img.addEventListener(‘onload’,’start’,’true’); function start(){ draw1(); draw2(); } fucntion draw1(){ ctx.drawImage(); ... } fucntion draw1(){ ctx.drawImage(); ... } 上面这么写的好处在于，所有的函数后在onload回调函数之后执行了，确保了绘图的正确性。 Last but not least 我在网上搜了很久，在讲解onload()事件时基本就一篇文章，被抄了无数次，但是我试验却发现和文章中的结果完全不一样。文章中写到，即使是在JS代码中定义一个Image()对象时，只要src不赋值，其onload事件就不会触发，但是~像我上面实验的那样，我试验了很多次，都是那样的结果，测试了Chrome，Firefox，IE，Edge，每个浏览器的测试都一样。可能是那篇文章已经是很久之前的了，但是这些同学从未自己试过，直接就抄过去了。所以实践才是真理啊。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"canvas基础","slug":"canvas基础","date":"2019-03-10T13:56:25.000Z","updated":"2019-03-10T14:25:16.783Z","comments":true,"path":"2019/03/10/canvas基础/","link":"","permalink":"http://yoursite.com/2019/03/10/canvas基础/","excerpt":"创建canvas画布css: canvas{ border:3px solid blue; } html: &lt;canvas width=&quot;700&quot; height=&quot;700&quot; id=&quot;myCanvas&quot;&gt; 您的浏览器不支持canvas，请更换浏览器访问！ &lt;/canvas&gt; Javascript: &lt;script&gt; let canvas = document.getElementById(&quot;myCanvas&quot;); let ctx = canvas.getContext(&quot;2d&quot;); &lt;/script&gt;","text":"创建canvas画布css: canvas{ border:3px solid blue; } html: &lt;canvas width=&quot;700&quot; height=&quot;700&quot; id=&quot;myCanvas&quot;&gt; 您的浏览器不支持canvas，请更换浏览器访问！ &lt;/canvas&gt; Javascript: &lt;script&gt; let canvas = document.getElementById(&quot;myCanvas&quot;); let ctx = canvas.getContext(&quot;2d&quot;); &lt;/script&gt; Point: canvas标签是一个双标签，其内部写的是当浏览器不支持canvas时显示的内容，可以插入其他元素，比如文字，图片等。 canvas画布的宽高因该在其标签内定义，不能在其CSS内定义，否则其绘制的图像会按照300*150发生缩放。 所有绘图行为都在script标签中进行。 let ctx = canvas.getContext(“2d”); 所有canvas的API都是定义在该对象上的，其中参数可以是2D，或者3D. Canvas绘制图像canvas的绘制图形有两种方式： context.fill() fill()指的是填充，其默认颜色是黑色，可以在使用fill()之前使用fillStyle()方法改变填充颜色，如果是闭合图像，那么就直接填充。如果是非闭合的路径，则fill()先帮其闭合，然后填充。 ctx.fillStyle = &quot;red&quot;;//设置填充色 ctx.fillRect(10,10,100,100);//绘制一个填充矩形 context.stroke() stroke()方法会实际的绘制出moveTo()和lineTo()方法的路径。默认颜色是黑色，在绘制之前，可以使用strokeStyle()进行设置。 ctx.strokeStyle = &quot;red&quot;;//设置边框填充色 ctx.strokeRect(10,10,100,100);//绘制空心矩形 绘制矩形绘制基本矩形ctx.fillRect(x,y,height,width)//实心矩形 ctx.strokeRect(x,y,height,width)//空心边框 x:起点的x坐标(即左上角的x坐标) y:起点的y坐标(即左上角的y坐标) height:矩形的高 width:矩形的宽 改变颜色ctx.fillStyle = &quot;red&quot;;//设置填充颜色 ctx.fillRect(10,10,100,100); ctx.strokeStyle = &quot;red&quot;;//设置边框颜色 ctx.strokeRect(200,200,100,100); Point: ctx.fillStyle = “red”用来设置填充颜色 ctx.strokeStyle = “red”用来设置边框颜色 这些描述都要放在绘制图形之前声明 擦除矩形区域 ctx.clearRect(x,y,height,width) ctx.clearRect(50,50,200,200)//绘制一个矩形区域并擦除该区域之前的内容 绘制圆形绘制基本圆实心圆 ctx.arc(x,y,radius,starAngle,endAngle,anticlockwise) x:圆心的x坐标 y:圆心的y坐标 radius:半径 startAngle:开始角度 endAngle:结束角度 anticlockwise:旋转方向，true:逆时针(可选参数，默认为false) false:顺时针 ctx.fillStyle = &quot;red&quot;; //设置填充色 ctx.arc(200,200,50,0,Math.PI*2,true);//绘制圆形 ctx.fill();//填充 空心圆ctx.beginPath() ctx.arc(200,200,50,0,Math.PI*2,true); ctx.strokeStyle = &quot;red&quot;; ctx.closePath(); ctx.stroke(); Point 上面用到了路径，实际ctx.arc()相当于是一个lineTo()的一个集合。利用其绘制出一个圆形，最后要关闭(ctx.cloePath())，以及要(stroke())才能完全绘制出该图形。 非完整圆如果要绘制一个非完整的圆，比如一个实心半圆，该如何绘制呢？ 答案是使用arc方法中的startAngle和endAngle来改变。 ctx.fillStyle = &quot;red&quot;; ctx.arc(200,200,50,0,Math.PI,true); 空心圆形 ctx.beginPath(); ctx.strokeStyle = &quot;red&quot;; ctx.arc(400,400,100,0,Math.PI); ctx.closePath(); ctx.stroke(); 绘制线段 moveTo(x,y):把画笔移动至画布的制定位置，不创建线条 lineTo(x,y):添加一个点(x,y) stroke():按照之前添加的点绘制路径 ctx.strokeStyle = &quot;red&quot;;//设置填充色 ctx.moveTo(0,0);//将画笔移动至(0,0) ctx.lineTo(100,100);//添加一个点(100,100) ctx.stroke();//按点绘制路径 Point 如果没有在第一次指定moveTo(x,y)，则第一个lineTo(x,y) == moveTo(x,y) 如果在lineTo()后没有使用moveTo()方法，则依次连接，eg： ctx.moveTo(0,0); ctx.lineTo(10,10); ctx.lineTo(20,20); ctx.lineTo(30,30); ctx.stroke(); 则画出后是一段从点(0,0)=&gt;(10,10)=&gt;(20,20)=&gt;(30,30)的一段折线。 ctx.beginPath():开始一段路径 ctx.closePath()：闭合路径，即canvas会自动将未闭合的线段的首尾连接起来。 eg(一个三角形): ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(10,10); ctx.lineTo(20,20); ctx.closePath(); ctx.stroke(); 案例(六边形)： var n = 0; var dx = 150;//路径开始x坐标 var dy = 150;//路径开始y坐标 var s = 100;//边长 ctx.beginPath();//路径开始 ctx.fillStyle = &apos;pink&apos;;//设置填充色 ctx.strokeStyle = &apos;rgb(0,0,100)&apos;;//设置边框颜色 var dig = Math.PI / 3;//计算偏移角度 for (var i = 0; i &lt; 6; i++) { var x = Math.sin(i * dig);//计算以下个点的x坐标的增量 var y = Math.cos(i * dig);//计算下一个点的y坐标的增量 ctx.lineTo(dx + x * s, dy + y * s);//绘制下一个点 //console.log( x ,y ) } ctx.closePath();//闭合整个路径 ctx.fill();//设置填充 ctx.stroke();//绘制路径 Point 这个例子用了一点数学知识，主要是： for (var i = 0; i &lt; 6; i++) { var x = Math.sin(i * dig);//计算以下个点的x坐标的增量 var y = Math.cos(i * dig);//计算下一个点的y坐标的增量 ctx.lineTo(dx + x * s, dy + y * s);//绘制下一个点 //console.log( x ,y ) } 其原理是利用了简单的沟股定理，计算下一个点的坐标 线性渐变 let lg = ctx.createLinearGradient(xStart,yStart,xEnd,yEnd) lg.addColorStop(offset,color) xSart:渐变开始点的x坐标 yStart：渐变开始点的y坐标 xEnd：渐变结束点的x坐标 yEnd：渐变结束点的y坐标 offset:设定的颜色离渐变结束点的偏移量 color:绘制的颜色 eg: let lg = ctx.createLinearGradient(0,0,100,200); lg.addColorStop(0,”#E55D87”); lg.addColorStop(1,”#5FC3E4”); ctx.fillStyle = lg; ctx.fillRect(0,0,200,200); Point 线性渐变仅仅是相当于设置填充色，在定义完填充色之后，我们还需要将填充设置为该线性渐变(ctx.fillStyle = gl) 由于线性渐变仅仅是设置填充色，所以具体的背景容器还需要我们自己设置，比如设置一个矩形作为容器ctx.fillRect(0,0,200,200) 由于渐变背景的坐标是相对于画布，而图形的坐标也是相对于画布，所以在定义背景时，需要注意与图形的坐标搭配以达到需要的效果 径向渐变 let rg = ctx.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd) rg.addCOlorStop(offset,color); xSart:发散开始的圆心x坐标 yStart：发散开始的圆心y坐标 radiusStart：发散开始圆的半径 xEnd：发散结束圆心的x坐标 yEnd：发散结束圆心的y坐标 radiusEnd：发散结束圆的半径 offset：设定的颜色结束点的偏移量(0-1) color:绘制颜色 var g1 = ctx.createRadialGradient(200, 150, 0, 200, 150, 200); g1.addColorStop(0.1, ‘#F09819’); g1.addColorStop(1, ‘#EDDE5D’); ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(200, 150, 100, 0, Math.PI * 2, true); ctx.closePath(); ctx.fill(); 图形变形缩放 scale(x,y) x:x坐标轴按x比例缩放 y:y坐标轴按y比例缩放 前面参数的是按倍数来衡量的(0.5=&gt;50%,1=&gt;100%,2=&gt;200%) eg: ctx.strokeStyle = &quot;red&quot;; ctx.scale(2,2); ctx.strokeRect(5,5,25,15); ctx.scale(2,2); ctx.strokeRect(5,5,25,15); ctx.scale(2,2); ctx.strokeRect(5,5,25,15); Point 缩放一个图形，先使用ctx.scale(x,y)对画布进行缩放处理，后面再创建要缩放的工具ctx.strokeRect(5,5,25,15);。 缩放的原点都是在(0,0)位置。 旋转 ratate(angle) angle:旋转的角度，以弧度计。 eg: ctx.strokeStyle = &quot;red&quot;; // ctx.strokeRect(5,5,200,200); ctx.rotate(20*Math.PI/180);//旋转5° ctx.strokeRect(5,5,200,300); Point: 默认的旋转中心是在(0,0)位置。下面介绍如何改变旋转中心。 平移 translate(x,y) x:坐标原点向x轴平移x y:坐标原点想y轴平移y eg1(以矩形中心为原点旋转)： ctx.strokeStyle = &quot;red&quot;; //以(0,0)为原点绘制一个起点为(200,200)，边长为200的正方形 ctx.strokeRect(200,200,200,200); //移动原点至(300,300)，即上面矩形的中心位置 ctx.translate(300,300); //将画布进行一个45°的旋转，得到一个旋转后的图形 ctx.rotate(45*Math.PI/180); //将原点坐标改为(0,0) ctx.translate(-300,-300); //绘制出旋转后的矩形 ctx.strokeRect(200,200,200,200); eg2(以矩形中心为原点缩放图形): ctx.strokeStyle = &quot;red&quot;; ctx.strokeRect(200,200,100,100); ctx.translate(250,250); ctx.scale(2,2); ctx.translate(-250,-250); ctx.strokeRect(200,200,100,100); Point 上面提到的，scale,rotate方法的操作都是对画布而言的，貌似整的canvas的思维都是这样，需要我们有反向思考的能力。 组合图形 globalCompositeOperation = type 后绘制的图形如何与之前的图像叠加渲染，取决与type。下面是type的种类： source-over(默认):在原图形之上绘制(覆盖)。 destination-over:在原图形之下绘制。 source-in:显示原有图形和新图形的交集，新图形在上，所以颜色为新图形颜色 destination-in:显示原图形和新图形的交集，原图形在上，所以颜色为原图形的颜色 source-out:只显示新图形的非交集部分 destination-out:只显示旧图形的非交集部分 source-atop:显示原图形和交集部分，新图形在上，所以交集部分为新图形颜色 destination-atop：显示新图形和交集部分，新图形在上，所以交集部分为新图形颜色 lighter：显示原有图形和新图形，交集部分做颜色叠加 copy:只显示新图形 eg: ctx.globalCompositeOperation = &quot;lighter&quot;; ctx.fillStyle = &quot;red&quot;; ctx.fillRect(50,50,200,200); ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(100,100,200,200); Point 该属性与上面的ctx.translate(x,y)一样，一旦作用，就对下面的元素都起作用，如果要还原，请在此使用该属性还原。 阴影 shadowOffsetX:设置或返回阴影距形状的水平距离(默认值为0)-shadowOffsetY:设置或返回阴影形状的垂直距离(默认值为0) shadowColor:设置或返回阴影的颜色 shadowBlur:设置或返回阴影的模糊级别(值越大越模糊) eg: ctx.shadowOffsetX=20; ctx.shadowColor=”blue”; ctx.shadowBlur = 50; ctx.fillStyle = “red”; ctx.fillRect(100,100,200,200); ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.fillStyle = &quot;yellow&quot;; ctx.fillRect(400,400,100,100); Point 相同的是，阴影属性也是对一下的所有图形都生效。要取消阴影效果，必须重置: ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; 图像操作 drawImage(img,x,y):在画布上定位图像 drawImage(img,x,y,width,height):在画布上定位图像，并规定图像的宽度和高度 drawImage(img,sx,sy,swidth,sheight,x,y,width,height) img:规定要使用的图像，画布或视频 sx(可选):开始剪切的x坐标位置 sy(可选):开始剪切的y坐标位置 swidth(可选):被剪切的图像的宽度 sheight(可选):被剪切的图像的高度 x:在画布上放置img的x坐标位置 y:在画布上放置img的y坐标位置 width(可选):要使用的图像的宽度。(拉伸或压缩) height(可选)：要使用的图像的高度。(拉伸或压缩) eg: let img = new Image(); img.src = &quot;expi.jpg&quot;; img.onload = function(){ ctx.drawImage(img,100,100,200,200,200,200,200,200); } Point img因该是一个img对象，img = new Image()或者是一个Image的DOM标签document.getElementById(&quot;img&quot;)(实际也是一个Image对象，因为在HTML中，每创建一个img标签，就会自动创建一个Image对象。) 在使用该标签时，应当使用，Image对象的回调函数onload,否则不能渲染成功，其原因是: let img = new Image(); img.src = &quot;expi.jpg&quot;; 这个过程中，对img.src赋值的时候，可能还没有赋值完成，就进行了ctx.drawImage语句，由于还没赋值完成，此使img.src还是空，所以无法渲染出来。 图像平铺 createPattern(image,type) type: no-repeat:不平铺 repeawt-x:按x轴方向平铺 repeat-y:按y轴方向平铺 repeat：全方向平铺 eg: let img = new Image; img.src = “beauty.png”; img.onload = function(){ let pattern = ctx.createPattern(img,”repeat-x”); ctx.fillStyle = pattern; ctx.fillRect(10,10,500,500); } Point 相同的是，必须要配合Image的oload回调函数来使用，道理同上。 图像剪切 clip() 该函数的使用方法： 创建剪切区域:ctx.rect(x,y,width,heigth) 设置剪切部分的填充色:ctx.fillStyle = “pink” 进行填充:ctx.fill(); 进行剪切:ctx.clip(); eg: ctx.fillStyle = &quot;yellow&quot;; ctx.fillRect(0,0,300,300); ctx.rect(100,100,500,500); ctx.fillStyle = &quot;pink&quot;; ctx.fill(); ctx.clip(); ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(0,0,200,200); Point -一旦剪切了某个区域，则之后的所有绘图都会被限制在被剪切区域内进行（不能访问画布上的其他区域）。我们也可以在使用clip()方法之前通过使用save()方法将之前的画布保存下来,并在任意时间使用restored()方法。 绘制文字 fillText(text,x,y):绘制实心文字 x:文字的中心点x坐标 y：文字的中心点y坐标 strokeText():绘制文字描边(空心文字) textAlign：设置或返回文字内容的当前对齐方式(注意：其都是相对于该文字对象的中心)，其值有： start:默认。文本在指定的位置开始。 end:文本在指定的位置结束。 left:文本左对齐。 center:文本的中心被放置在指定的位置。 right:文本右对齐。 textBaseline：设置会返回在绘制文本时使用的当前文字基线,其值有： Bottom：文本基线是 em 方框的底端。 Top：文本基线是 em 方框的顶端。 Middle：文本基线是 em 方框的正中。 Alphabetic：默认。文本基线是普通的字母基线。 hanging：文本基线是悬挂基线。 font:设置或返回文本内容的当前文字属性 eg: ctx.font = &quot;40px Arial&quot;; ctx.textAlign = &quot;center&quot;; ctx.fillText(&quot;Hello World&quot;,200,200); ctx.strokeText(&quot;Hello World&quot;,200,300); console.log(ctx.textBaseline);","categories":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/categories/Canvas/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"JavaScript中的.与[]的区别","slug":"JavaScript中的.与[]的区别","date":"2019-03-03T04:17:00.000Z","updated":"2019-03-03T05:04:01.331Z","comments":true,"path":"2019/03/03/JavaScript中的.与[]的区别/","link":"","permalink":"http://yoursite.com/2019/03/03/JavaScript中的.与[]的区别/","excerpt":"叨叨一下最近在看ES6，感觉很有意思啊。然后就遇到了这个问题，.(点)与[] (方括号)的区别。","text":"叨叨一下最近在看ES6，感觉很有意思啊。然后就遇到了这个问题，.(点)与[] (方括号)的区别。 正文这个问题是在遍历器(Iterator)这一部分发现的，其中对于不存在遍历器的数据结构，比如一个对象。我们可以自定义一个遍历器，就可以实现forEach,for…in…等方法。然后就出现下面这段语句： var arrlike = { 0:a, 1:b, 2:c } arrlike.[Symbol.iterator](){ //遍历器内容，略 } 问题就在：arrlike.[Symbol.iterator]()，如果Symbol是对象arrlike的一个属性，那么为什么不能用arrlike.Symbol…的方法来获取该属性。 下面就说一下这两个的区别： 相同: .与[]都可以获取元素的属性。 不同: 中括号运算符可以用字符串变量的内容作为属性名。点运算符不能。 中括号运算符可以用纯数字为属性名。点运算符不能。 中括号运算符可以用js的关键字和保留字作为属性名。点运算符不能。 说回上面的arrlike.[Symbol.iterator](),Symbol.iterator是一个JS内置的一个关键字，然后这个属性返回的是一个函数。 然后后面的括号就是执行该函数。 function fun1(){return &quot;yes&quot;} console.log(func1) //function... console.log(func1()) //yes LastES6还是真的有意思，加油鸭！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JSP实战项目:学生信息管理系统的总结","slug":"JSP实战项目-学生信息管理系统的总结","date":"2019-02-09T04:38:11.000Z","updated":"2019-02-09T09:26:53.927Z","comments":true,"path":"2019/02/09/JSP实战项目-学生信息管理系统的总结/","link":"","permalink":"http://yoursite.com/2019/02/09/JSP实战项目-学生信息管理系统的总结/","excerpt":"前言简单学习了一下JSP，不知道以后老师怎么教的，不过我是感觉到JSP的真谛还是Java，无论是按照MVC或者三层模式，一般Control层都是servlet来写，Model层都是用纯java来写，当然，在JSP文件中，也是可以进行这些操作的，毕竟在JSP的&lt;%…%&gt;中完全可以写java代码，而servlet的本质就是java的一个类。但是一般在开始时总是界面与逻辑分开，否则整个项目结构混乱，代码冗余。所以我觉的学JSP本质还是学java，学servlet。","text":"前言简单学习了一下JSP，不知道以后老师怎么教的，不过我是感觉到JSP的真谛还是Java，无论是按照MVC或者三层模式，一般Control层都是servlet来写，Model层都是用纯java来写，当然，在JSP文件中，也是可以进行这些操作的，毕竟在JSP的&lt;%…%&gt;中完全可以写java代码，而servlet的本质就是java的一个类。但是一般在开始时总是界面与逻辑分开，否则整个项目结构混乱，代码冗余。所以我觉的学JSP本质还是学java，学servlet。 正文整个项目差不多就包含学生信息的增删改，准备添加一个文件上传，不过还没添加，嘿嘿嘿。后面再说。 在这个过程中我遇到了不少问题，下面我就想起什么就讲什么吧~ 前端部分 前端完美居中之flex布局： 在登陆界面这种只需要一个div完美居中的情况，flex布局是在一个不错的方法： body{ display:flex;//设置body为flex布局 justify-content:center; //设置布局主轴上的对齐方式为居中 align-items:center;//设置另一轴的对齐方式为居中 } 这种布局下，body里的内容就会完美居中。 另外在回顾一下flex布局里的所有属性： 容器属性 flex-direction: 决定主轴的方向，即项目排列的方向，有四个可能的值：row(默认)|row-reverse|column|column-reverse flex-wrap:默认情况下，item排列在一条线上，即主轴上，flex-wrap决定当排列不下时是否换行以及换行的方式，可能的值nowrap(默认)|wrap|wrap-reverse flex-flow:flex-direction和flex-wrap的简写形式，如：row wrap|column wrap-reverse等。默认值为row nowrap，即横向排列 不换行。 justify-content:决定item在主轴上的对齐方式，可能的值有flex-start（默认），flex-end，center，space-between，space-around。 align-items:决定了item在交叉轴上的对齐方式，可能的值有flex-start|flex-end|center|baseline|stretch align-content:该属性定义了当有多根主轴时，即item不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，定义了align-content后，align-items属性将失效。 容器属性 order：order的值是整数，默认为0，整数越小，item排列越靠前。 flex-grow：定义了当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大；可能的值为整数，表示不同item的放大比例 flex-shrink：定义了当容器空间不足时，item是否缩小。默认值为1，表示当空间不足时，item自动缩小，其可能的值为整数，表示不同item的缩小比例。 flex-basis：表示项目在主轴上占据的空间，默认值为auto，其可为具体数值(px)。 flex：flex属性是flex-grow、flex-shrink和flex-basis三属性的简写总和。 align-self： align-self属性允许item有自己独特的在交叉轴上的对齐方式，它有六个可能的值：auto|flex-start|flex-end|center|baseline|stretch。默认值为auto。 前端onsubmit属性 这个属性真有点用~这个属性是用在submit按钮上的，他可以在你提交表单之前进行数据的审核。在审核通过后再上传，如果审核不通过，则不提交。具体代码如下。 //表单部分 &lt;input type=&quot;submit&quot; value=&quot;提交&quot; onsubmit=&quot;return check()&quot;&gt; //JS部分 function check(){ //执行判断，注意要返回一个boolean值，该值来确定是否需要提交表单 } Jquery的ajax请求 由于原生JS的ajax请求有点负载，所以我还是采用了jquery。所以还是具体介绍一下jquery的ajax请求。 1. $(“#id”).load(url,data,function(response,status,xhr)) 这种请求方法可以直接将请求到的数据添加到指定元素中（其本质还是get()方式）。 url：（必选）请求的地址 data:（可选）要发送的数据,采用键值存储发送，多个数据时采用花括号：{key1:value1,key2:value2} function():（可选），在服务器反馈后执行的函数。 response：服务器返回的数据 status：服务器返回的status值 xhr：服务器返回的xhr对象 2. $.get(url,data,function(response,status,xhr) 这个基本的get请求，get()只请求数据，不对数据做任何处理。 但是jquery将jsonp也封装进了get方法中，所以我们再调用get方法时，可以使用jsonp进行传输，但一般是是直接传字符串: $.get(url,data,function(data,status,xhr){}) 如果需要使用JSONP来请求，需要再声明： $.get(url,data.function(data,status,xhr){},&quot;JSONP&quot;) 关于JSON与JSONP，可以看一下这一篇文章，还是比较易懂。 3. $.get(url,data,function(response,status,xhr) 回顾一下，get与post： get: 数据追加到url中传输，因此保密性较差，直接可视化，不适用于账户，密码等信息的传输。 由于url的限制，也不适用于较长数据的传输，一般url的数据量在1KB左右。 由于使用url直接传输，因此传输效率会比post方式高。 post： post是将数据封装为HTTP消息发送给服务器，这样做有以下优点： 数据传输量相较于get()方法得到提升，一般文件传输都是利用该方法 数据保密性得到一定性的保护，无法直接获取，但需要注意的是，通过抓包，任然可以获得post提交的所有数据。所以我们在传输密码时，一般是通过加密传输，不传明文密码。这一点，在HTTPS中得到了较好的解决。但是HTTPS需要申请且价格昂贵，所以目前对于数据的加密任是最好方法。 4.$.ajax({ type:”get”,url:”url”,data:””,async:true,function(data,status,xhr){} }) 注意：async即异步，一般默认是true，即，你删掉async这个选项，则默认为true，还记得ajax的含义么： Asynchronous JavaScript and XML 第一个就是async，所以如果是false，就没意义了对吧，不过也许有的情况有用，了解到就好。 5. $.getJSON(url,data,function(response,status,xhr) 我觉得这是jquery中最好用的一个方法了，因为他将请求到的JSON字符串直接转换为JSON对象了，直接用key和value属性就可以使用了，舒服的板~ JS的cookies的使用 之前一直是使用的localStorage或者sessionStorage来存储数据，使用这个就很便捷，直接使用key来取value值就行了，我好像还有一个专门的文章来介绍，不过最终好像还是cookies使用的较多一点，可能是兼容性的原因，然年后我发现cookies的使用比localStorage要复杂一些，所以还是看一下： 设置cookie： function setCookie(cname,cvalue,exdays) { var d = new Date();//实例化一个时间 d.setTime(d.getTime()+(exdays*24*60*60*1000));//设置过期时间的变量 var expires = &quot;expires=&quot;+d.toUTCString();//将Date()对象转化为数组 document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;//设置cookie } 获取cookie值： function getCookie(cname) { var name = cname + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;);//分割cookie字符串 for(var i=0; i&lt;ca.length; i++) { var c = ca[i].trim();//去除空格 if (c.indexOf(name)==0) return c.substring(name.length,c.length); }//搜索是否存在该cookie，是则返回值 return &quot;&quot;; } 注意：可以看出，JS的cookie的API设计似乎没有localStorage那么友好，毕竟很多年前的东西了。所以document.cookie是直接获得整个cookie，以键值对用”=”连接起来，具体获得对应的值还需要我们自己来处理字符串，emmmm，从体验上来说，没有那么友好，但还有一点值得注意的是，document.cookie是一个方法，当你对他进行赋值操作的时候。他是直接识别”=”添加键值，而对其进行取值的时候，是以字符串返回所有的cookie值。 上面获取cookie的方法不是唯一的，因为处理字符串的方式不是唯一的，包括正则也是不错的方法 后端部分 关于MVC的理解我觉得也是学到的一部分，即将视图，模型，控制分离，而且无论是哪种设计方式，最终目的是保证层次的清晰。这样无论是对一次开发还是重构，都是及其重要的。 另外对于JSP这门后端语言，我觉得要理解其精髓，还是要学习servlet，java。因为model，controller层，一般都是采用servlet或者java来开发，似乎很少有用JSP来写逻辑层面的东西的。 在开发时我遇到了一个BUG卡了我好几天，搜索也没有结果，知道我理解其原因，啧啧啧： 我用java写好后端数据库交互层后，直接写了mian函数进行测试，成功！但是在我使用JSP文件发送ajax请求时，后端文件报错，无法找到sql驱动文件，我检查了sql文件，确实是在Java Resource的library中，并且直接运行java文件也通过了。。。搜索了很久，突然想到既然是javaweb程序，是不是在调用库文件时时使用的WebContent-&gt;WEB-INF-&gt;lib下的库文件，而不是调用java的库文件。我直接将sql驱动添加到javaweb的库中。nice，运行成功！ 关于eclipse的问题，在测试的某一段时间，发现整个工程没有更新了，修改了代码也没有用，以前也发生过，一般重启一下server就ok了，可这次重启也没用，没办法，清除缓存把，我直接清除了工程的缓存。然后。。。就是java程序无法运行，一直报错：无法找到main函数入口。在网上看到很多这种情况，但一般都说是classpath设置不对，但我另一个工程却可以运行，所以明显不是这种情况，然后我看到了这篇文章我按照第二条的方法，发现我有个库文件报错，直接移除，ok，解决（可是这和我的main函数有什么关系呢？？？） 最后在java那些库文件的语法方面我就不再BB了，反正是固定的API，按文档写就OK（其实是我懒，哈哈哈）~~~ 最后 最后我觉得我还是有个大问题，那就是变量的命名问题。。。This is a problem。很多不规范，这个在我以后的实践中尽量解决，比如~写个文档啊，哈哈哈。 所以这个项目就告一段落，前端的框架看一下就开学了~~~只能开学去看Python的GUI编程了~","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"实战","slug":"实战","permalink":"http://yoursite.com/tags/实战/"}]},{"title":"JSP数据库处理","slug":"JSP数据库处理","date":"2019-01-31T08:50:58.000Z","updated":"2019-01-31T09:44:46.171Z","comments":true,"path":"2019/01/31/JSP数据库处理/","link":"","permalink":"http://yoursite.com/2019/01/31/JSP数据库处理/","excerpt":"JSP的数据库操作经过这两天的操作，我觉得还是要看视频或者买书或者看官方文档学习，网上的资料缺点太多，写的过于简单，甚至兼容性也有问题。所以，搞了一天，终于，把数据库搞出来了~","text":"JSP的数据库操作经过这两天的操作，我觉得还是要看视频或者买书或者看官方文档学习，网上的资料缺点太多，写的过于简单，甚至兼容性也有问题。所以，搞了一天，终于，把数据库搞出来了~ 源码分析sql.java package student.servlet; import java.sql.*; public class sql { public static void Update(){ Statement stmt = null; Connection connection = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } String name=&quot;root&quot;; String pwd=&quot;957837&quot;; String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;; try { connection = DriverManager.getConnection(url,name,pwd); System.out.print(&quot;数据库连接成功！&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { stmt = connection.createStatement(); String sqlString = &quot;insert into blog values(5,&apos;https&apos;,&apos;hhhhh&apos;,&apos;2015-8-9&apos;)&quot;; int lines = stmt.executeUpdate(sqlString); System.out.print(&quot;插入成功&quot;+lines+&quot;受影响&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { if(stmt != null) { stmt.close(); } connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public static void Select() { Statement stmt = null; Connection connection = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } String name=&quot;root&quot;; String pwd=&quot;957837&quot;; String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;; try { connection = DriverManager.getConnection(url,name,pwd); System.out.print(&quot;数据库连接成功&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { stmt = connection.createStatement(); String sqlString = &quot;select * from blog&quot;; ResultSet res = stmt.executeQuery(sqlString); System.out.println(&quot;查询数据库成功&quot;); while(res.next()) { int num= res.getInt(&quot;order_id&quot;); String title = res.getString(&quot;title&quot;); System.out.println(num); System.out.println(title); } } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { if(stmt != null) { stmt.close(); } connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public static void main(String[] args){ // Update(); Select(); } } 代码分析： 对于连接数据库这种操作，一般不在JSP中操作，而是用javabean来操作，也就是说在创建一个java文件，将其作为数据库处理的文件，然后再JSP文件中连接该文件进行操作。 引入数据库驱动，首先要去网上下载一个数据库驱动，不同的数据库系统驱动不同，这个是由数据库厂商提供的。下载完之后，就将其copy到Web App Libraries文件夹中。然后就可以使用该Class了。 然后就是： Statement connection = DriverManager.getConnection(url,name,pwd) 使用该句来连接数据库（注意：在Java文件中，该句需要添加try…catch…）。 增删改数据库: Statement stmt = connection.createStatement(); String sql = “insert…”; //该方法返回的是受影响的行数 int res = connection.executeUpdate(sql) 查数据库：查数据唯一不同的是执行语句： String sql =”…”; ResultSet res = connection.executeQuery(sql); while(res.next()) { int num= res.getInt(&quot;...&quot;); String title = res.getString(&quot;...&quot;); System.out.println(num); System.out.println(title); } 注意：在获取数据库内容时，使用:ResultSet res =connection.executeQuery(sql),这个res是一个表的集合。可以类比遇一个Iterator 使用一个while循环来使用获取全部的数据。 res该对象含有：next(),hasNext()等方法来获取下一个。主要的还是get方法。但是获取不同类型的数据需要用不同的get方法：getInt(“name”);getString(“”)…like this。 最后需要注意的是，连接完数据库后，要把链接关闭。 stmt.close(); connection(); 这两个都要被关闭！ ##Last but important##就上面这几句代码，emmmm，在网上找了一天，现在才发现，网上的资料的参差不齐，终归还是要看文档，不行就看书，then，看视频。经验，哈哈哈。还有6天，做一个Demo吧，哈哈哈。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"JSP基础部分","slug":"JSP基础部分","date":"2019-01-30T13:46:43.000Z","updated":"2019-01-30T14:43:15.712Z","comments":true,"path":"2019/01/30/JSP基础部分/","link":"","permalink":"http://yoursite.com/2019/01/30/JSP基础部分/","excerpt":"JSP这几天把JSP基本部分看了，方便记忆，还是回顾一下。文件部分有一点复杂，所以后面直接单独解析一下。","text":"JSP这几天把JSP基本部分看了，方便记忆，还是回顾一下。文件部分有一点复杂，所以后面直接单独解析一下。 日期处理其实日期处理部分还是JAVA中的Date()对象提供的。只是之前学习JAVA是没认真看，哈哈哈。 获取时间eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*, javax.servlet.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;显示当前时间与日期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示当前时间与日期&lt;/h1&gt; &lt;% Date date = new Date(); out.print( &quot;&lt;h2 align=\\&quot;center\\&quot;&gt;&quot; +date.toString()+&quot;&lt;/h2&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 提示：任然是实例化Date对象，然后对该对象进行操作，其中该对象有以下方法： 序号 方法 &amp; 描述 boolean after(Date date)如果比给定的日期晚，则返回true，否则返回false boolean before(Date date)如果比给定的日期早，则返回true，否则返回false Object clone( )获取当前对象的一个副本 int compareTo(Date date)如果与给定日期相等，则返回0，如果比给定日期早，则返回一个负数，如果比给定日期晚，则返回一个正数 int compareTo(Object obj)与 compareTo(Date) 方法相同，如果 obj 不是Date类或其子类的对象，抛出ClassCastException异常 boolean equals(Object date)如果与给定日期相同，则返回true，否则返回false long getTime( )返回从1970年1月1日凌晨至此对象所表示时间的毫秒数 int hashCode( )返回此对象的哈希码 void setTime(long time)使用给定参数设置时间和日期，参数time表示从1970年1月1日凌晨至time所经过的毫秒数 String toString( )将此对象转换为字符串并返回这个字符串 日期的比较 使用getTime()方法得到毫秒数，然后比较毫秒数就行了。 使用before()，after()，equals()方法。比如，new Date(99,2,12).before(new Date(99,2,18))返回true。 使用compareTo()方法，这个方法在Comparable接口中定义，在Date中实现。 使用SimpleDateFormat格式化日期eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;%@ page import=&quot;javax.servlet.*,java.text.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;显示当前时间与日期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示当前时间与日期&lt;/h1&gt; &lt;% Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd HH:mm:ss&quot;); out.print( &quot;&lt;h2 align=\\&quot;center\\&quot;&gt;&quot; + ft.format(dNow) + &quot;&lt;/h2&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; SimpleDateFormat格式码 字符 描述 示例G 时代标识符 AD y 4位数年份 2001 M 月 July or 07 d 日 10 h 12小时制， A.M./P.M. (1~12) 12 H 24小时制 22 m 分钟 30 s 秒 55 S 毫秒 234 E 星期 Tuesday D 一年中的某天 360 F 一个月中某星期的某天 2 (second Wed. in July) w 一年中的某星期 40 W 一个月中的某星期 1 a A.M./P.M. 标记 PM k 一天中的某个小时 (1~24) 24 K 一天中的某个小时，A.M./P.M. (0~11) 10 z 时区 Eastern Standard Time ‘ 文本分隔 Delimiter “ 单引号 ` 页面重定向页面重定向是指在client访问a.jsp时，根据据需要，a.jsp页面将请求重定向至另一个页面。注意这一个过程中，a.jsp的所有内容都不会返回至client，而是直接将请求引导至新页面，也就是说client会进行二次访问，新页面的加载还是又client来完成。 eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;页面重定向&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;页面重定向&lt;/h1&gt; &lt;% // 重定向到新地址,关键部分 String site = new String(&quot;http://www.runoob.com&quot;); response.setStatus(response.SC_MOVED_TEMPORARILY); response.setHeader(&quot;Location&quot;, site); %&gt; &lt;/body&gt; &lt;/html&gt; 还有一个类似的请求转发，而请求转发是在接手到client的请求后，在server端进行请求，然后再这个请求的基础上将新内容返回。也就是说，该种方法只经历了1次请求，并且转发只能是转发到本次请求的服务器，而重定向则可以定向到其他服务器。(进过我的测试暂时是这样) 我在看这一部分时，想在重定向或者焕发之前给client一些提示，但是由于该页面的内容内容根本不会写入到response中，所以是不能实现的，在网上查找了一圈的资料，基本都是说使用前端来实现跳转，才能给客户端反馈。 比如: out.print(&quot;&lt;script&gt; alert(&quot;即将跳转至百度！&quot;); window.href=&quot;http:www.baidu.com&quot;; &lt;/script&gt;&quot;) 所以，如果使用重定向或者是转发，是不能给客户端提示的，如果要提示，就要用前端实现跳转。 JSP点击量统计在菜鸟上，对于统计量方法的实现，时使用application对象来存储一对键值，在访问时动态变化，实现访问量统计。所以我们看一下applicant这个对象，它有以下特点： 在服务器启动时自动创建，在服务器关闭时自动销毁 一个网站仅有一个application，也就是说所有的客户共享一个application。 所以如果服务器遇到宕机，那么这个量就被销毁了，所以最保险的方法是将其储存到数据库中，并定期刷新。保证不会频繁访问数据库，又可以最大化的保存数据。 eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;访问量统计&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Integer hitsCount = (Integer)application.getAttribute(&quot;hitCounter&quot;); if( hitsCount ==null || hitsCount == 0 ){ /* 第一次访问 */ out.println(&quot;欢迎访问菜鸟教程!&quot;); hitsCount = 1; }else{ /* 返回访问值 */ out.println(&quot;欢迎再次访问菜鸟教程!&quot;); hitsCount += 1; } application.setAttribute(&quot;hitCounter&quot;, hitsCount); %&gt; &lt;p&gt;页面访问量为: &lt;%= hitsCount%&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; JSP自动刷新我其实觉得这个功能可以在前端实现，不过也许有些时候必须要使用后端实现呢，所以还是看一下，其实就一句： response.setIntHeader(&quot;Refresh&quot;, 5); eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;自动刷新实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;自动刷新实&lt;/h2&gt; &lt;% // 设置每隔5秒刷新一次 response.setIntHeader(&quot;Refresh&quot;, 5); // 获取当前时间 Calendar calendar = new GregorianCalendar(); String am_pm; int hour = calendar.get(Calendar.HOUR); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); if(calendar.get(Calendar.AM_PM) == 0) am_pm = &quot;AM&quot;; else am_pm = &quot;PM&quot;; String CT = hour+&quot;:&quot;+ minute +&quot;:&quot;+ second +&quot; &quot;+ am_pm; out.println(&quot;当前时间为: &quot; + CT + &quot;\\n&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 通过这个栗子可以看出效果，当然，对于日期的刷新，不肯能用这个东西，肯定是局部的ajax来实现。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"JSP中的表单编码问题","slug":"JSP中的表单编码问题","date":"2019-01-28T12:13:29.000Z","updated":"2019-01-28T12:35:17.410Z","comments":true,"path":"2019/01/28/JSP中的表单编码问题/","link":"","permalink":"http://yoursite.com/2019/01/28/JSP中的表单编码问题/","excerpt":"JSP的编码才看了几天的JSP，把最重要的表单提交看了一下，遇到了中文编码的问题，然后我查了一下JSP的默认代码是：ISO-8859-1重新设编码的语句共有下面几句：","text":"JSP的编码才看了几天的JSP，把最重要的表单提交看了一下，遇到了中文编码的问题，然后我查了一下JSP的默认代码是：ISO-8859-1重新设编码的语句共有下面几句： pageEncoding=”UTF-8” contentType=”text/html;charset=UTF-8” request.setCharacterEncoding(“UTF-8”) response.setCharacterEncoding(“UTF-8”) pageEncoding=”UTF-8” 是在第一阶段，转换阶段（即将JSP文件转化为servlet文件的过程中使用该局代码提示的编码） contentType=”text/html;charset=UTF-8” 是用在第二阶段，将servle渲染为html时，使用该语句的编码 request.setCharacterEncoding(“UTF-8”) 是用来指定对浏览器发送来的数据以特定的字符集进行重新编码，常用于对 POST 请求参数进行解码。 response.setCharacterEncoding(“UTF-8”) 是用来在服务器将响应返回到浏览器前，对响应使用指定字符集进行重新编码。一旦使用了该种方式，即使该响应页面指定了具体的 contentType，也将失效。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"编码","slug":"编码","permalink":"http://yoursite.com/tags/编码/"}]},{"title":"Python3_CGI编程踩坑日记","slug":"Python3-CGI编程踩坑日记","date":"2019-01-14T12:25:07.000Z","updated":"2019-01-14T14:02:46.626Z","comments":true,"path":"2019/01/14/Python3-CGI编程踩坑日记/","link":"","permalink":"http://yoursite.com/2019/01/14/Python3-CGI编程踩坑日记/","excerpt":"Hard-start这是学习Python的第六天，也是进入Python高级编程的第一天，嗯，对，然后我就遇见了Big Problem，甚至到现在都还有一个问题没有解决。","text":"Hard-start这是学习Python的第六天，也是进入Python高级编程的第一天，嗯，对，然后我就遇见了Big Problem，甚至到现在都还有一个问题没有解决。 Problem I met Apache的安装问题 在得之要使用Apache之后，我直接就百度Apache，然后再官网首页 结果下载下来直接用不了，解压了发现文件不对。然后一搜教程才发现文件下载错了。 应该在这里下载： 终于完成填了第一个坑！ Apache配置问题 要启用CGI，必需修改配置文件。而这个配置不仅仅是是一个地方，是n个地方： ServerRoot配置 ServerRoot “” 主要用于指定Apache的安装路径，此选项参数值在安装Apache时系统会自动把Apache的路径写入。Windows安装时，该选项的值为Windows安装的路径，Linux安装时该选项值为编译时选择的路径 找到： Define SRVROOT &quot;${SRVROOT}&quot; ServerRoot &quot;${SRVROOT}4&quot; 改为： Define SRVROOT &quot;D:\\web\\Apache24&quot; ServerRoot &quot;D:\\web\\Apache24&quot; 其中”${SRVROOT}”应改为你你安装Apache的目录。 Listen 配置 Listen主要侦听web服务端口状态，默认为：80，即侦听所有的地址的80端口，注意这里也可以写成IP地址的侦听形式，不写即默认的地址：0.0.0.0 找到： Listen:80 改为： Listen:8080 一般不为80，因为容易占用，改为其他好一点。比如我改为8080。 CGI配置 找到： AddHandler cgi-script .cgi .pl 改为： AddHandler cgi-script .cgi .pl .py 这里是增加对Python的支持。 找到： &lt;Directory &quot;/${SRVROOT}&quot;&gt; AllowOverride none Require all denied &lt;/Directory&gt; 改为： &lt;Directory &quot;D:\\web\\Apache24\\cgi-bin&quot;&gt; AllowOverride None Options Indexes FollowSymLinks ExecCGI Require all granted Require host ip &lt;/Directory&gt; 注意这里/${SRVROOT}任然还是Apache的安装地址。 Python解释器 我就这么按照runoob上代码粘贴下来，like this： #!/usr/bin/python3 print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是来自菜鸟教程的第一CGI程序&lt;/h2&gt;&apos;) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) 然后就出现了500错误，下面是log里的提示： [Mon Jan 14 11:31:58.626473 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。 : [client ::1:52212] couldn&apos;t create child process: 720002: hello.py [Mon Jan 14 11:31:58.660452 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。 : [client ::1:52212] AH01223: couldn&apos;t spawn child process: D:/web/Apache24/cgi-bin/hello.py 百度了半天，突然想起Apache如何载入编译器呢，然后直接百度上面代码的第一行： #!/usr/bin/python3 然后才知道这是Linux下Python的解释器位置，我枯了。然后我找到了自己Python3的安装位置，却发现没有exe文件，我又枯了。但是用sys自己的命令： import sys sys.path 得到了就是这个位置。不管了，直接写吧！于是得到了这一段代码： #!D:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python.exe 没错，就是这么长，不知道自己当时怎么安装的。我又枯了。 结果成功解析了！！！ 但是！！！ 又乱码了，检查了py文件的编码，发现py默认是utf-8啊。然后终于在网上找到了解决办法。没错，是print()函数的问题。 又大佬看print()源码使用Unicode，果然乱码了，然后引入了这一段代码： import io sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) 即：将print()函数改为utf-8编码输出，终于留了一张图： 附上正常获取text，textarea的代码，其他的都一样。 (text.html): &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/cgi-bin/text.py&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt; &lt;input tyep = &apos;text&apos; name = &apos;name&apos;/&gt; &lt;textarea name=&quot;personinform&quot;&gt;个人信息&lt;/textarea&gt; &lt;input type=&apos;submit&apos; value=&apos;提交&apos;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; (text.py): #!D:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python.exe import io import sys import cgi, cgitb sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) form = cgi.FieldStorage() name = form.getvalue(&apos;name&apos;) personinform= form.getvalue(&apos;personinform&apos;) print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;) print(name) print(personinform) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) 下面是get从url来获取键值的方法： #!D:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python.exe import io import sys import cgi, cgitb sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) form = cgi.FieldStorage() name = form.getvalue(&apos;name&apos;) number = form.getvalue(&apos;number&apos;) print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;) print(name,number) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) last problem(unsolved) 最后一个问题就是CGI的文件上传问题。由上面的代码可以知道，所有接受的数据都来自： cgi.FieldStorage() 网上的教程都这么获得数据： import cgi, os import cgitb; cgitb.enable() form = cgi.FieldStorage() # 获取文件名 fileitem = form[&apos;filename&apos;] # 检测文件是否上传 if fileitem.filename: # 设置文件路径 fn = os.path.basename(fileitem.filename) open(&apos;/tmp/&apos; + fn, &apos;wb&apos;).write(fileitem.file.read()) message = &apos;文件 &quot;&apos; + fn + &apos;&quot; 上传成功&apos; else: message = &apos;文件没有上传&apos; 但是问题在于， fileitem.filename == none 我直接输出 fielitem fileitem = MiniFielStorage(&apos;filename&apos;,&apos;test.txt&apos;) #test.txt为上传的文件名 所以fileitem.filename始终为none。所以一直解决不了，查了各种资料，不过官方文档里有类似的解释，但是还是没有解决办法。明天再看吧~~~难受啊，马飞~","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"CGI","slug":"CGI","permalink":"http://yoursite.com/tags/CGI/"}]},{"title":"欢迎2019-假如我年少有为","slug":"欢迎2019-假如我年少有为","date":"2019-01-13T12:08:09.000Z","updated":"2020-01-08T15:38:47.126Z","comments":true,"path":"2019/01/13/欢迎2019-假如我年少有为/","link":"","permalink":"http://yoursite.com/2019/01/13/欢迎2019-假如我年少有为/","excerpt":"不知道怎么开始这一篇文章，首先应该是欢迎2019吧，又度过了一年。真要回忆这一年，我竟然没有多少印象。我尽力去回忆，尽力去把这一年的日子换算成有价值的东西。不知道我什么时候变得如此的现实，一切似乎都不能是白过的。","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"不知道密码就别猜了，这是我得小秘密，哈哈哈\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"2019","slug":"2019","permalink":"http://yoursite.com/tags/2019/"}]},{"title":"周报(0)","slug":"周报(0)","date":"2018-12-01T04:10:17.000Z","updated":"2019-01-12T15:31:43.707Z","comments":true,"path":"2018/12/01/周报(0)/","link":"","permalink":"http://yoursite.com/2018/12/01/周报(0)/","excerpt":"LeetCode： 简单思路：令i从0开始向后跑寻找与下标为length-1不相等的数，找到之后将那个数放到length的位置上，并且令length长度加1，最后返回length就行了。","text":"LeetCode： 简单思路：令i从0开始向后跑寻找与下标为length-1不相等的数，找到之后将那个数放到length的位置上，并且令length长度加1，最后返回length就行了。代码部分： int removeDuplicates(int* nums, int numsSize) { if(numsSize==0){ return 0; } int length = 1; for(int i=0;i&lt;numsSize;i++){ if(nums[i]!=nums[length-1]){ nums[length++]=nums[i]; } } return length; } Java学习部分内容重写与重载重写：在子类中1. 参数列表必须完全与被重写方法的相同 2. 返回类型必须与被重写方法的返回类型相同 3. 访问权限不能比父类中被重写的方法的访问权限更低。例如，父类的一个方法被申明为public，那么该子类中重写该方法就不能申明为protected。 4. 父类的成员方法只能被它的子类重写 5. 申明为final的方法不能被重写 6. 申明为static的方法不能被重写，但是能够被再次申明 7. 子类与父类在同一个包中，那么子类可以重写父类的所有方法，除了声明为private与final的方法 8. 子类与父类不在一个包中，那么子类只能够重写父类的声明为public和protected的非final方法 9. 构造方法不能被重写 10. 如果不能继承一个方法，则不能重写这个方法 super1. 在父类的某一方法被重写后，如果需要调用原父类的方法，需在该方法前加super关键字 重载 ：在同一个类中1. 被重载的方法必须改变参数列表（参数个数或类型不一样） 2. 被重载的方法可以改变返回类型 3. 被重载的方法可以改变访问修饰符 4. 被重载的方法可以声明新的或更广的检查异常 5. 方法能够在同一个类中或者一个子类中被重载 6. 无法以返回值类型作为重载函数的区分标准 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 来自 http://www.runoob.com/java/java-override-overload.html 2.多态：同一个行为具有多个不同表现形式或形态的能力。 向上转型：子类引用的对象转换为父类类型称为向上转型。 重写式多态：也叫运行时多态，这种多态通过动态绑定技术来实现，是指在执行期间判断所引用的对象的实际类型调用起相应的方法。 Animal animal = new Cat(); //向上转型 1. 向上转型时，子类单独定义的方法会丢失。比如上面Dog类中定义的run方法，当animal引用指向Dog类实例时是访问不到run方法的，animal.run()会报错。 2. 子类引用不能指向父类对象。Cat c = (Cat)new Animal()这样是不行的。 向上转型后方法引用的优先级问题： 继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 注意：此时的（super）O 指的是O的父类。以下面的8为例： b.show(C) 由于b的引用对象为B，所以可以调用的方法有：show(B)，show(A) （this.show(O)） 又b的类型也为B，所以方法也先在B中选择，发现没有show(C)方法 （super.show(O)） 在B的父类，即A中查找show(C)方法，任然没有查找到 （this.show(super)O） 原式为：b.show（C），又C的父类为B，所以该式变为：b.show(b)，并且在B中查找，找到了该方法，于是执行该方法，得到结果：B and B 实例class A { public String show(D obj) { return (“A and D”); } public String show(A obj) { return (&quot;A and A&quot;); } } class B extends A{ public String show(B obj){ return (“B and B”); } public String show(A obj){ return (&quot;B and A&quot;); } } class C extends B{ } class D extends B{ } public class Demo { public static void main(String[] args) { A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(&quot;1--&quot; + a1.show(b)); System.out.println(&quot;2--&quot; + a1.show(c)); System.out.println(&quot;3--&quot; + a1.show(d)); System.out.println(&quot;4--&quot; + a2.show(b)); System.out.println(&quot;5--&quot; + a2.show(c)); System.out.println(&quot;6--&quot; + a2.show(d)); System.out.println(&quot;7--&quot; + b.show(b)); System.out.println(&quot;8--&quot; + b.show(c)); System.out.println(&quot;9--&quot; + b.show(d)); } }//结果：//1–A and A//2–A and A//3–A and D//4–B and A//5–B and A//6–A and D//7–B and B//8–B and B//9–A and D 从4向后的解析原理：当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。Animal animal = new Cat(); //向上转型 Animal为引用对象Cat为引用变量 首先，a2是类型为A的引用类型，它指向类型为B的对象。A确定可调用的方法：show(D obj)和show(A obj)。a2.show(b) ==&gt; this.show(b)，这里this指的是B。 然后.在B类中找show（B obj），找到了，可惜没用，因为show（B obj）方法不在可调用范围内，this.show(O)失败，进入下一级别：super.show(O)，super指的是A。 在A 中寻找show（B obj)，失败，因为没用定义这个方法。进入第三级别：this.show((super)O)，this指的是B。在B中找show（（A）O）,找到了：show(A obj)，选择调用该方法。 输出：B and A 上面的例子简单的介绍了多态的意义，同一个行为具有不同的表现形式或形态的能力。 多态（重写式）实现的条件： 1. 继承（实现） 2. 重写 3. 向上转型 重载式多态：也叫编译时多态，也就是说这种多态在编译时已经确定好了。在调用这种方法时，通过传入不同的参数得到不同的结果。 此处重载式多态有不同的说法，部分观点认为：重载不属于多态，认为多态仅仅指的是在程序运行时根据不同的输入，而方法有不同的响应称之为多态；但重载指的是：在一个类里，方法名字相同，而参数不同。也就是说在程序编译时就确定了该方法的响应。所以不能称之为多态。关于这个部分，我还没有更深的理解，所以暂时保留意见。","categories":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/categories/周报/"}],"tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/周报/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"JavaScript数组（二，ES6部分）","slug":"JavaScript数组（二，ES6部分）","date":"2018-11-02T10:06:23.000Z","updated":"2018-11-02T10:08:09.215Z","comments":true,"path":"2018/11/02/JavaScript数组（二，ES6部分）/","link":"","permalink":"http://yoursite.com/2018/11/02/JavaScript数组（二，ES6部分）/","excerpt":"前言上次介绍了ES5之前发布的JS的数组方法，这次再看一下ES5中发布的JS方法。","text":"前言上次介绍了ES5之前发布的JS的数组方法，这次再看一下ES5中发布的JS方法。 正文 indexOf()和lastIndexOf() 描述： indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。 应用： 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。 exp: var arr = [1,3,5,7,7,5,3,1]; console.log(arr.indexOf(5)); //2（5在该数组的第2位） console.log(arr.lastIndexOf(5)); //5(从后向前，5在数组的第5位) console.log(arr.indexOf(5,2)); //2（从第二位开始检索，任然2在第5位） console.log(arr.lastIndexOf(5,4)); //2（从倒数第四位开始检索，5在倒数第四位） console.log(arr.indexOf(&quot;5&quot;)); //-1（数组中没有字符&quot;5&quot;，所以返回-1） forEach() 描述： 对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。 应用： 用于遍历数组，获得数组成员的内容，索引，及其数组本身 var arr = [1, 2, 3, 4, 5]; arr.forEach(function(x, index, a){ console.log(x + ‘|’ + index + ‘|’ + (a === arr)); }); // 输出为： // 1|0|true // 2|1|true // 3|2|true // 4|3|true // 5|4|true map() 描述： 遍历一个数组，并且经过处理后返回一个新的数组。 原型： arr.map(function(currentValue，index，arr),thisValue) currentValue 必须 当前元素值 index 可选 当前元素的索引值 arr 可选 当前元素属于的数组对象。 exp:通过map方法返回数组元素的平方 var arr = [1, 2, 3, 4, 5]; var arr2 = arr.map(function(item){ return item*item; }); console.log(arr2); //[1, 4, 9, 16, 25] 注意，map()方法不会改变原数组，而是返回一个新的数组，注意function中药返回值，否则为空数组 exp2: var arr = [1,2,3,7,9]; var arr2 = arr.map(function(x,index,a){ x=x+1; }); console.log(arr2);//[undifined,undifined,undifined,undifined,undifine] console.log(arr);//[1,2,3,7,9] 即使在map()的函数中改变currentValue的值，原数组的职业不会改变。而如果没有返回值，则该数组为undefined。 filter() 描述： “过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 原型：array.filter(function(currentValue,index,arr), thisValue) currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 exp： var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; var arr2 = arr.filter(function(x, index) { return index % 3 === 0 || x &gt;= 8; }); console.log(arr2); //[1, 4, 7, 8, 9, 10] 该方法的注意事项和上一个方法差不多，也是不会改变原数组，并且必须要有返回值，否则数组为undefined。 every() 描述： 判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 原型：array.filter(function(currentValue,index,arr), thisValue) currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 应用： 检测数组所有元素是否都符合指定条件（通过函数提供）。 exp： var arr = [1, 2, 3, 4, 5]; var arr2 = arr.every(function(x) { return x &lt; 10; }); console.log(arr2); //true var arr3 = arr.every(function(x) { return x &lt; 3; }); console.log(arr3); // false some() 描述： 判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 应用： some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。 exp： var arr = [1, 2, 3, 4, 5]; var arr2 = arr.some(function(x) { return x &lt; 3; }); console.log(arr2); //true var arr3 = arr.some(function(x) { return x &lt; 1; }); console.log(arr3); // false 注意： some() 方法会依次执行数组的每个元素： 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。 reduce()和 reduceRight() 描述： 这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 原型（以reduce为例）： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 currentIndex 可选。当前元素的索引 arr 可选。当前元素所属的数组对象。 exp： var values = [1,2,3,4,5]; var sum = values.reduceRight(function(total, currentValue, currentIndex, arr){ return total + currenValue; },10); console.log(sum); //25 最后这是ES6中提供的数组方法，对于ES6，我还没有认真研究，不过这些方法还是挺实用的，对于低版本的浏览器可能会不支持。感觉开发中还是要针对需求使用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript数组","slug":"JavaScript数组","date":"2018-10-25T16:22:49.000Z","updated":"2018-10-26T13:48:01.919Z","comments":true,"path":"2018/10/26/JavaScript数组/","link":"","permalink":"http://yoursite.com/2018/10/26/JavaScript数组/","excerpt":"JavaScript数组复习一下数组，发现有些方法都忘记了 定义数组的方式 采用直接量创建 var MyArray = [];//创建空数组 var MyArray = [1,2,3];//创建数字型数组 var MyArray = [“A”,”B”,”C”];//创建字符型数组 var MyArray = [{id:1},{id:2},{id:3}];//创建对象型数组 采用构造函数创建 var MyArray = new Array(); MyArray[0] = 0; MyArray[1] = “A”; var MyArray = new Array(5); var MyArray = new Array(5,4,3,2,1);","text":"JavaScript数组复习一下数组，发现有些方法都忘记了 定义数组的方式 采用直接量创建 var MyArray = [];//创建空数组 var MyArray = [1,2,3];//创建数字型数组 var MyArray = [“A”,”B”,”C”];//创建字符型数组 var MyArray = [{id:1},{id:2},{id:3}];//创建对象型数组 采用构造函数创建 var MyArray = new Array(); MyArray[0] = 0; MyArray[1] = “A”; var MyArray = new Array(5); var MyArray = new Array(5,4,3,2,1); 属性 constructor 描述：返回对创建此对象的数组函数的引用。 应用1：用于判断元素类型 exp： &lt;script type=&quot;text/javascript&quot;&gt; var test=new Array(); if (test.constructor==Array) { document.write(&quot;This is an Array&quot;); } if (test.constructor==Boolean) { document.write(&quot;This is a Boolean&quot;); } if (test.constructor==Date) { document.write(&quot;This is a Date&quot;); } if (test.constructor==String) { document.write(&quot;This is a String&quot;); } &lt;/script&gt; 输出： This is an Array 应用2：用于获取构造函数的原形 exp: &lt;script type=&quot;text/javascript&quot;&gt; function employee(name,job,born) { this.name=name; this.job=job; this.born=born; } var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985); document.write(bill.constructor); &lt;/script&gt; 输出： function employee(name, job, born) {this.name = name; this.job = job; this.born = born;} length 描述：设置或返回数组中元素的数目 应用：设置或返回数组中元素的数目 exp： &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;John&quot; arr[1] = &quot;Andy&quot; arr[2] = &quot;Wendy&quot; document.write(&quot;Original length: &quot; + arr.length) document.write(&quot;&lt;br /&gt;&quot;) arr.length=5 document.write(&quot;New length: &quot; + arr.length) &lt;/script&gt; 输出： Original length: 3 New length: 5 prototype 描述：使您有能力向对象添加属性和方法 应用：向对象添加属性和方法 exp: //定义一个employee对象 function employee(name,job,born) { this.name=name; this.job=job; this.born=born; } //实例化一个employee var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985); employee.prototype.salary=null; bill.salary=20000; document.write(bill.salary); &lt;/script&gt; 值得注意的是：prototyp是面向对象编程的重要属性。在W3C的解释中，可以知道函数也是一个对向（具体函数与对象的关系后续再详细讨论），每个函数对象都具有一个子对象prototype。Prototype 表示了该函数的原型，prototype表示了一个类的属性的集合。当通过new来生成一个类的对象时，prototype对象的属性就会成为实例化对象的属性。 方法 contact() 描述：连接两个或更多的数组，并返回结果 应用：连接n个数组 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; var arr2 = new Array(3) arr2[0] = &quot;James&quot; arr2[1] = &quot;Adrew&quot; arr2[2] = &quot;Martin&quot; var arr3 = new Array(2) arr3[0] = &quot;William&quot; arr3[1] = &quot;Franklin&quot; //执行连接操作 document.write(arr.concat(arr2,arr3)) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin,William,Franklin join() 描述：把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 应用：创建一个数组，然后把它的所有元素放入一个字符串 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr.join(&quot;.&quot;)) &lt;/script&gt; 输出： George.John.Thomas 注意：join(separator)中separator为间隔符，若为空择默认为逗号。 pop() 描述：pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值 应用：创建一个数组，然后删除数组的最后一个元素 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr) document.write(&quot;&lt;br /&gt;&quot;) document.write(arr.pop()) document.write(&quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas Thomas George,John push() 描述：push() 方法可把它的参数顺序添加到 arrayObject 的尾部。 它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。 arrayObject.push(newelement1,newelement2,....,newelementX) newelement1（必选）- 要添加的第一个元素 newelement2（可选）- 要添加的第二个元素 newelementX（可选）- 要添加的第X个元素 应用：创建一个数组，并通过添加一个元素来改变其长度 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.push(&quot;James&quot;) + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas 4 George,John,Thomas,James reverse() 描述：用于颠倒数组中元素的顺序（该方法会改变原来的数组，而不会创建新的数组） 应用：创建一个数组，然后颠倒其元素的顺序 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.reverse()) &lt;/script&gt; 输出： George,John,Thomas Thomas,John,George shift() 描述:用于把数组的第一个元素从其中删除，并返回第一个元素的值(如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject) 应用：创建一个数组，并删除数组的第一个元素。请注意，这也将改变数组的长度 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.shift() + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas George John,Thomas slice() 描述：slice() 方法可从已有的数组中返回选定的元素 arrayObject.slice(start,end) start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end: 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 应用：创建一个新数组，然后显示从其中选取的元素 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) //截取数组的2-4位（注意数组下标从0开始） document.write(arr.slice(2,4) + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin Thomas,James George,John,Thomas,James,Adrew,Martin sort() 描述：用于对数组的元素进行排序 arrayObject.sort(sortby) sortby 可选。规定排序顺序。必须是函数。 返回值为对数组的引用。请注意，数组在原数组上进行排序，不生成副本 参数说明：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。若 a 等于 b，则返回 0。若 a 大于 b，则返回一个大于 0 的值。 应用：创建一个数组，并按字母顺序进行排序 exp1： &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.sort()) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin Adrew,George,James,John,Martin,Thomas exp2:实现对多位数的排序（利用排序函数作为参数） &lt;script type=&quot;text/javascript&quot;&gt; function sortNumber(a,b) { return a - b } var arr = new Array(6) arr[0] = &quot;10&quot; arr[1] = &quot;5&quot; arr[2] = &quot;40&quot; arr[3] = &quot;25&quot; arr[4] = &quot;1000&quot; arr[5] = &quot;1&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.sort(sortNumber)) &lt;/script&gt; 如果不写该函数作为参数，只会对多位数的第一位以ASCII码进行排序，无法实现多位数排序 splice() 描述：splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 该方法会改变原始数组 arrayObject.splice(index,howmany,item1,…..,itemX) index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX 可选。向数组添加的新项目。 请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 应用： exp1:创建一个新数组，并向其添加/删除一个元素 &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) //从第二个位置修改，&quot;howmany&quot;参数为0择不删除，第三个参数为要添加的元素 arr.splice(2,0,&quot;William&quot;) document.write(arr + &quot;&lt;br /&gt;&quot;) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin George,John,William,Thomas,James,Adrew,Martin exp2：删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素 var arr = new Array(6) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" arr[3] = \"James\" arr[4] = \"Adrew\" arr[5] = \"Martin\" document.write(arr + \"\") arr.splice(2,1,\"William\") document.write(arr) 输出： George,John,Thomas,James,Adrew,Martin George,John,William,James,Adrew,Martin exp3:删除从 index 2 (“Thomas”) 开始的三个元素，并添加一个新元素 (“William”) 来替代被删除的元素 var arr = new Array(6) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" arr[3] = \"James\" arr[4] = \"Adrew\" arr[5] = \"Martin\" document.write(arr + \"\") arr.splice(2,3,\"William\") document.write(arr) 输出： George,John,Thomas,James,Adrew,Martin George,John,William,Martin unshift 描述：可向数组的开头添加一个或更多元素，并返回新的长度 arrayObject.unshift(newelement1,newelement2,….,newelementX) newelement1 必需。向数组添加的第一个元素。 newelement2 可选。向数组添加的第二个元素。 newelementX 可选。可添加若干个元素。 说明：unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。 请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。 请注意，unshift() 方法无法在 Internet Explorer 中正确地工作！ 应用：创建一个数组，并把一个元素添加到数组的开头，并返回数组的新长度 exp: var arr = new Array() arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" document.write(arr + \"\") document.write(arr.unshift(\"William\") + \"\") document.write(arr) 输出： George,John,Thomas 4 William,George,John,Thomas 一些不常用的方法 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 valueOf() 返回数组对象的原始值 说明以上内容均来自W3Cschool，我是为了加深印象，巩固一下知识点。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JS代码段所放位置的区别","slug":"JS代码段所放位置的区别","date":"2018-10-19T14:27:14.000Z","updated":"2018-10-19T16:44:07.515Z","comments":true,"path":"2018/10/19/JS代码段所放位置的区别/","link":"","permalink":"http://yoursite.com/2018/10/19/JS代码段所放位置的区别/","excerpt":"前言在很久之前就遇到了这个问题，由于代码段放的位置不对导致代码段无法生效。所以这次就简单写一下代码段不同位置的区别。 正文","text":"前言在很久之前就遇到了这个问题，由于代码段放的位置不对导致代码段无法生效。所以这次就简单写一下代码段不同位置的区别。 正文 JavaScriptJS是一种解释性脚本（不进行预编译） 高级语言的两种翻译方式： 编译 以基本的C语言为例，大部分语言是直接通过编译器将高级语言编译成为机器可以懂的机器语言（二进制文件 .exe）。但是也有不一样的，比如JAVA这种跨平台语言，它是将高级语言先编译成为JAVA虚拟机能够识别的class文件，在不同的平台上再编译为相应的机器语言，实现跨平台。 解释 解释性脚本脚本不需要编译，在执行时才进行解释。解释性脚本语言有专门的解释器，不过每次执行时都需要编译，所以效率比较低。 JavaScript也有自己的解释器–JavaScript引擎，他是浏览器的一部分。 HTML 语言的执行顺序作为一门解释性脚本语言，它的执行顺序是从前到后顺序执行。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Html页面内容执行顺序&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var userId = $(&apos;#hiddenUserId&apos;).val(); var contextPath = $(&apos;#hiddenContextPath&apos;).val(); var userName = $(&apos;#hiddenUserName&apos;).val(); alert(userName); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 按照顺序执行，先解析该文档为HTML文档，接着解析head部分的script脚本，head部分的style样式，接着渲染body部分，接着解析body中的script脚本。 按照以上顺序，我就可以理解为什么我上一次引用的验证码脚本以及vue框架放在HTML中head部分时，无法生效。原因是在于如果将脚本放在head中，script脚本执行时DOM树还没有被渲染，所以脚本是无法执行对DOM进行修改的。而如果将脚本放在body尾部，执行此脚本时，DOM树已被渲染完毕，所以可执行修改操作。 结论1.head中所放的JavaScript代码段主要功能应该是不会在页面加载时就进行执行的脚本功能，即后续通过其他操作触发的（比如onclik按键触发），这类脚本可以预先解释，在需要时再执行 2.body后面放的脚本应该是页面加载时就要触发的脚本，比如对DOM数内容的初始化（向上面的验证码系统，vue的脚本） 特殊情况以下情况可以改变JS代码的执行顺序 window.onload:等到页面中的所有内容加载完成后才会执行。 $(document).ready():页面中所有的DOM结构绘制完成后就能够执行。 script脚本中，大部分浏览器支持async和defer属性。 async表示的意思是异步加载JavaScript文件，它的下载过程可以在HTML的解析过程中进行，加载完成之后立即执行这个文件的代码，执行文件代码的过程中会阻塞HTML的解析，它不保证文件加载的顺序。 defer表示的意思是在HTML文档解析之后在执行加载完成的JavaScript文件，JavaScript文件的下载过程可以在HTML的解析过程中进行，它是按照script标签的先后顺序来加载文件的。 参考资料： 1.把JavaScript文件放在文档的头部还是尾部 2.CSS、JS 放置位置与前端性能的关系？ 3.HTML页面的加载顺序","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"node-js基本用法解析","slug":"node-js基本用法解析","date":"2018-09-22T07:18:33.000Z","updated":"2018-09-25T13:34:51.186Z","comments":true,"path":"2018/09/22/node-js基本用法解析/","link":"","permalink":"http://yoursite.com/2018/09/22/node-js基本用法解析/","excerpt":"前言 为什么会想到搞一下node呢，emmmm，主要是之前想收图片，每个人4张，一共几十个人，如果都通过qq发过来那简直市场噩梦（虽然我最后还是经历了这擦会给你噩梦），所以下定决心要搞一下后端的东西，PHP，ASP学习成本有点高，速成还是有点难，所以我想到了node.js这个神奇的东西，用js的语言来写后端的东西，nice哦。所以就有了这篇文章。","text":"前言 为什么会想到搞一下node呢，emmmm，主要是之前想收图片，每个人4张，一共几十个人，如果都通过qq发过来那简直市场噩梦（虽然我最后还是经历了这擦会给你噩梦），所以下定决心要搞一下后端的东西，PHP，ASP学习成本有点高，速成还是有点难，所以我想到了node.js这个神奇的东西，用js的语言来写后端的东西，nice哦。所以就有了这篇文章。 正文EventEmitter模块这个模块可以说是node中一个核心的模块，包括fs，http，net等模块的事件都是继承自该模块，若不使用继承的方法，其基本用法是： //引入events模块 var eventEmitter = require(&apos;events&apos;); //创建eventEmitter var events = new events.EventEmitter(); event.on(&apos;some_event1&apos;,function(){ console.log(&quot;监听器1执行&quot;); }) event.addListener(&apos;some_event2&apos;,function(){ console.log(&quot;监听器2执行&quot;); }) event.removeListener(&apos;some_event1&apos;,function(){ console.log(&quot;监听器1移除&quot;); }) event.emit(&apos;some_event1&apos;); 这是一些基本的用法，不过这个方法在平时不怎么用，所以了解一下就ok了。 文件系统fs异步与同步由于node是基于JS，所以异步与同步是不可回避的一个问题，在之前的博文中，我们也解析过JS的异步与同步操作，这里不再赘述。而node中文件操作是同时支持异步与同步操作，具体区别这里也不再赘述。 异步与同步代码var fs = require(&apos;fs&apos;); //异步读取 fs.readFile(&apos;input.txt&apos;,function(err,data){ if(err){ return console.error(err); } console.log(&apos;异步读取&apos;+data.toString()); }); //同步读取 var data = fs.readFileSync(&apos;input.txt&apos;); console.log(&quot;同步读取：&quot;+dataString()); console.log(&apos;文件操作完毕&apos;); 注意这里是展示同步与异步的代码区别，一般是在操作代码后加上“Sync”(同步)，但一般我们并不使用这种同步的方法，因为在文件大一点的时候这会严重影响代码执行的效率。 打开文件语法格式 fs.open(path,flag,callback) 参数 path-文件路径 flag-文件打开的模式 callback-回调函数，该函数带有两个参数（err,fd），err-&gt;错误，fd-fileData，文件内容及信息 下面是flag的参数及其说明 获取文件信息语法格式 fs.stat(path,callback) 参数 path-文件路径 call-回调函数 var fs = require(&apos;fs&apos;); fs.stat(&apos;/Users/liuht/code/itbilu/demo/fs.js&apos;, function (err, stats) { console.log(stats.isFile()); //true }) 下面是该类中的方法： 写入文件语法格式 fs.writeFile(file,data[,option],callback) 参数 file-文件名或文件描述 data-要写入的数据，可以是字符串（String）或缓冲变量（Buffer）对象 option-该参数是一个对象，包含{encoding,mode,flag}。默认为{utf8,0666,w} callback-回调函数（仅包含err，在写入失败时返回） var fs = require(&apos;fs&apos;); console.log(&apos;准备写入文件&apos;); fs.writeFile(&apos;input.txt&apos;,&apos;我是通过fs.file写入的内容&apos;,function(err){ return console.log(err); } console.log(&apos;数据写入成功！&apos;); console.log(&apos;读取写入的数据!&apos;); fs.readFile(&apos;input.txt&apos;,function(err,data){ if(err){ return console.log(err);} console.log(&apos;读取文件内容：&apos;+data.toString()); }); }); 这是代码执行效果： $ node file.js 准备写入文件 数据写入成功！ 读取写入的数据！ 异步读取文件数据: 我是通 过fs.writeFile 写入文件的内容 读取文件语法格式 fs.readFile(fd,buffer,offset,length,position,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 buffer - 数据写入的缓冲区。 offset - 缓冲区写入的写入偏移量。 length - 要从文件中读取的字节数。 position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。 callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。 var fs = require(&quot;fs&quot;); var buf = new Buffer.alloc(1024); console.log(&quot;准备打开已存在的文件！&quot;); fs.open(&apos;input.txt&apos;, &apos;r+&apos;, function(err, fd) { if (err) { return console.error(err); } console.log(&quot;文件打开成功！&quot;); console.log(&quot;准备读取文件：&quot;); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){ if (err){ console.log(err); } console.log(bytes + &quot; 字节被读取&quot;); // 仅输出读取的字节 if(bytes &gt; 0){ console.log(buf.slice(0, bytes).toString()); } }); }); 下面是代码执行效果： $ node file.js 准备打开已存在的文件！ 文件打开成功！ 准备读取文件： 25 字节被读取 This is a test inputtxt 关闭文件fs.close(fd,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 callback - 回调函数，没有参数。 fs.close(fd, function(err){ if (err){ console.log(err); } console.log(&quot;文件关闭成功&quot;); 截取文件fs.ftruncate(fd,len,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 len - 文件内容截取的长度。 callback - 回调函数，没有参数（但含有err参数）。 fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){ if (err){ console.log(err); } // 仅输出读取的字节 if(bytes &gt; 0){ console.log(buf.slice(0, bytes).toString()); } 删除文件fs.unlink(path,callback) 参数 path-路径 callback-回调函数，没有参数（但含有err参数） 实例 var fs = require(&apos;fs&apos;); console.log(&apos;开始删除文件！&apos;); fs.unlink(&apos;input.txt&apos;,function(err){ if(err){ return console.log(err); } console.log(&quot;删除成功！&quot;); }) 创建目录fs.mkdir(path,[,mode],callback) 参数 path - 文件路径。 mode - 设置目录权限，默认为 0777。 callback - 回调函数，没有参数。 实例 var fs = require(&apos;fs&apos;); console.log(&apos;创建目录 /tmp/test/&apos;); fs.mkdir(&quot;/tmp/test/&quot;,function(err){ if(err){ return console.log(err); } console.log(&apos;目录创建成功&apos;); }) 这是执行效果 $ node file.js 创建目录 /tmp/test/ 目录创建成功。 ###读取目录###语法 fs.readdir(path,callback) 参数 path - 文件路径。 callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。 实例 var fs = require(&quot;fs&quot;); console.log(&quot;查看 /tmp 目录&quot;); fs.readdir(&quot;/tmp/&quot;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); 执行效果 $ node file.js 查看 /tmp 目录 input.out output.out test test.txt ###删除目录### 语法 fs.rmdir(path,callback) 实例 var fs = require(&quot;fs&quot;); // 执行前创建一个空的 /tmp/test 目录 console.log(&quot;准备删除目录 /tmp/test&quot;); fs.rmdir(&quot;/tmp/test&quot;,function(err){ if (err) { return console.error(err); } console.log(&quot;读取 /tmp 目录&quot;); fs.readdir(&quot;/tmp/&quot;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); }); 执行效果： $ node file.js 准备删除目录 /tmp/test 读取 /tmp 目录 …… 文件模块还有很多方法，具体可以参见node.js官方文档 http模块http模块一般是使用createServer方法来创建服务器，下面是不使用html文件的代码： //获取http方法并定义到变量 var http = require(&apos;http&apos;); http.createServer(function(req,res){ res.writeHead(400,{&apos;Content-Type&apos;:&apos;text/html&apos;}) res.end(&quot;This is a test&quot;); }).listen(3000); console.log(&quot;server running at http://127.0.0.1:3000/&quot;); 这个代码执行后会在网页上显示This is a test 的字样。 下面是使用html文件来作为网页显示： var http = require(&apos;require&apos;); var fs = require(&apos;fs&apos;); var url = require(&apos;&apos;); //创建服务器 http.createServer(function(req,res){ //解析请求，包括文件名 var pathname = url.parse(req.url).pathname; //从文件系统中请求文件内容 console.log(&apos;request for&apos;+pathname+&apos;received&apos;); fs.readFile(pathname.substr(1),function(err,data){ if(err){ console.lor(err); //发送404（未查找到文件）HTTP状态码并规定解析文件为html文件 res.writeHead(404,{&apos;Content-Type&apos;:&apos;text/html&apos;}); }else{ //发送200（正常）HTTP状态码并规定解析文件为html res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;}); //响应文件内容 res.write(data.toString()); }) res.end(); }).listen(3000); console.log(&quot;Server running at http://127.0.0.1:3000/&quot;); index文件： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 执行上面JS代码，并在浏览器中填入：http://127.0.0.1:8080/index.html，就会显示出index.html网页内容。 url及post和get请求url是指请求的地址，其中不仅包含路径，还了可以包含多个参数，如下图，网址‘http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&#39; 以下代码可以从url中获取相关的参数： var http = require(&apos;http&apos;); var url = require(&apos;url&apos;); var util = require(&apos;util&apos;); http.createServer(function(req,res){ res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;;&apos;charset=utf-8&apos;}); res.end(util.inspect(url.parse(req.url,true))); }).listen(3000); 其效果： 其中util模块是一个工具模块，提供了很多功能，其中util.inspect(object[,options]),这里option的选项很多，这里不再展开叙述。其作用是一个将任意对象转换 为字符串的方法,通常用于调试和错误输出。 将url中的属性值提取出来， var http = require(&apos;http&apos;); var url = require(&apos;url&apos;); var util = require(&apos;util&apos;); http.createServer(function(req,res){ res.writeHead(200,{&apos;Conten-Type&apos;:&apos;text/plain&apos;}); var params = url.parse(req.url,true).query; res.write(&quot;网站名：&quot;+params.name); res.write(&quot;\\n&quot;); res.write(&quot;网站URL：&quot;params.url); res.end(); }).listen(3000); 效果： 获取表单数据 var http = require(&apos;http&apos;); var querystring = require(&apos;querystring&apos;); var postHTML = &apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;&apos; + &apos;&lt;body&gt;&apos; + &apos;&lt;form method=&quot;post&quot;&gt;&apos; + &apos;网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;&apos; + &apos;网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;&apos; + &apos;&lt;input type=&quot;submit&quot;&gt;&apos; + &apos;&lt;/form&gt;&apos; + &apos;&lt;/body&gt;&lt;/html&gt;&apos;; http.createServer(function (req, res) { var body = &quot;&quot;; req.on(&apos;data&apos;, function (chunk) { body += chunk; }); req.on(&apos;end&apos;, function () { // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/html; charset=utf8&apos;}); if(body.name &amp;&amp; body.url) { // 输出提交的数据 res.write(&quot;网站名：&quot; + body.name); res.write(&quot;&lt;br&gt;&quot;); res.write(&quot;网站 URL：&quot; + body.url); } else { // 输出表单 res.write(postHTML); } res.end(); }); }).listen(3000); 其效果如图： 将表单提交的数据利用express框架获取表单内容var express = require(&apos;express&apos;); var app = express(); //将文件夹public设为express公开文件夹(express模块已经将fs方法至于其中，因此在设置公开文件夹时不需再引用fs模块)。 app.use(express.static(&apos;public&apos;)); app.get(&apos;/index.html&apos;,function(req,res){ res.sendFile(_dirname+&apos;/&apos;+&apos;index.html&apos;); }) app.get(&apos;/process_get&apos;,function(req,res){ var response = { &quot;first_name&quot;:req.query.first_name, &quot;last_name&quot;:req.query.last_name }; console.log(response); res.end(JSON.stringify(response)); }); var server = app.listen(8081,function(req,res){ var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port); }); html代码： &lt;html&gt; &lt;body&gt; &lt;form action=&quot;http://127.0.0.1:8081/process_get&quot; method=&quot;GET&quot;&gt; First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt; &lt;br&gt; Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 效果如图： express模块是一个web应用框架，他提供了很多强大的功能来更简单的创建web应用。 利用express及multer来实现文件的上传multer模块主要处理表单文件的上传。 var express = require(&apos;express&apos;); var multer = require(&apos;multer&apos;); var app = express(); app.use(express.static(&apos;public&apos;)); // 通过 filename 属性定制 var storage = multer.diskStorage({ destination: function (req, file, cb) { cb(null, &apos;/web开发/测试/upload&apos;); // 保存的路径，备注：需要自己创建 }, filename: function (req, file, cb) { // 将保存文件名设置为 字段名 + 时间戳+后缀，比如 logo-1478521468943 cb(null, file.fieldname + &apos;-&apos; + Date.now()+&apos;.jpg&apos;); } }); // 通过 storage 选项来对 上传行为 进行定制化 var upload = multer({ storage: storage }) //var upload = multer({dest : &apos;upload/&apos; }); //var upload = multer({storage:storage}); app.get(&apos;/index&apos;,function(req,res){ res.send(_dirname+&quot;/&quot;+&quot;index.html&quot;); }) //single中的第二个参数代表可以接受几个文件，2代表可以接受两个文件 app.post(&apos;/upload&apos;,upload.single(&apos;pics，2&apos;),function(req,res){ res.send(&quot;ok&quot;); }) var server=app.listen(3030,function(){ var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) }) 上面这段代码可以实现文件的上传并将其放在规定的文件夹及其规律化的命名： html代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!-- &lt;span&gt;first item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;first_item&quot;&gt;&lt;br/&gt; &lt;span&gt;second item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;second_item&quot;&gt;&lt;br/&gt; --&gt; &lt;span&gt;file&lt;/span&gt;&lt;input type=&quot;file&quot; name=&quot;pics&quot;&gt;&lt;br/&gt; &lt;/be/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 最后终于把这个简单的文章写完了，这只是node的冰山一角，node还有很多模块及其方法，想要精通段时间内几乎是不可能的，后面还是要继续努力xio习啊！ 引用 菜鸟教程 Nodejs进阶：基于express+multer的文件上传","categories":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/categories/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"千万不要躺太久-三和大神的生活","slug":"千万不要躺太久-三和大神的生活","date":"2018-08-30T11:45:44.000Z","updated":"2018-08-31T14:40:51.424Z","comments":true,"path":"2018/08/30/千万不要躺太久-三和大神的生活/","link":"","permalink":"http://yoursite.com/2018/08/30/千万不要躺太久-三和大神的生活/","excerpt":"三和大神“三和大神”是一群平凡而又特殊的工人，平凡在于他们也是干活领工资，也在人才市场找工作。特殊在于他们的工作信仰与普通的工人不同，他们的理念是“干一天，玩三天”，只要身上有钱，就不去工作，什么时候口袋空了，什么时候就去工作。","text":"三和大神“三和大神”是一群平凡而又特殊的工人，平凡在于他们也是干活领工资，也在人才市场找工作。特殊在于他们的工作信仰与普通的工人不同，他们的理念是“干一天，玩三天”，只要身上有钱，就不去工作，什么时候口袋空了，什么时候就去工作。 三和大神的贫瘠生活经济的贫瘠“干一天玩三天”，这就是三和大神所信奉的生活状态，那这一天挣多少呢？ –大约86元人民币 接下来的三天就可以过着自由的生活，安逸的躺在十几元的廉价旅馆中，把已经发霉的被子盖在身上，闻着各种习以为常的异味，连着WiFi刷着破损的手机，吃着4元一碗的挂逼面，喝着1元一瓶的挂逼水，或者是在1元一小时的网吧中玩上两天。在身上已经没有钱够吃一碗挂逼面时，又站起来去到“人才市场”干一天。 精神的贫瘠干完这一天又回到那家小旅馆，躺下…… 这样一个又一个的循环，他们生活里毫无波澜，仿佛一滩没有生命的死水，唯一能激起一圈涟漪的应该就是兜里没有钱时，又要去干一天的无奈。他们希望通过网络弥补现实生活的贫瘠，在手机中看着这个明星又出轨了，那个人扶老奶奶又被讹了，他们手指迅速点击着屏幕，批判这个明星的生活作风太差，指责这个社会的黑暗，没有好人了。或者在游戏中虐一下对手，或者嘲讽一下对手，或者夸耀一下自己，将自己想象为游戏角色，以此拾得自己早已丢失在生活中自豪感。 然后又到了工作的那一天，他们将自己的精神冻结起来，以一种自我麻痹的状态完成工作，然后又回到网络上，拾回自己的精神，他们不敢把自己的精神带回到现实生活，因为他们不敢面对那个真实的自己，那个一无所有的自己，那个毫无地位的自己。 感情的贫瘠在“三和大神”的行列中，感情似乎是一件不可望更不可及的东西，没有亲人或者亲人根本不联系，更别提爱情，不想要更不需要，一人吃饱全家喝足的状态，这样毫无牵挂，似乎完全没有必要再在社会中跌跟头了，一直躺在地上就挺舒服。 他们为什么到这一步？每个人自来到这个世界，都不甘于低于别人，那为什么“三和大神”会甘于这样的生活？ 对生活失去希望宋春江，27岁迈入大神的行列，中专学习的服装和电脑，本以为毕业后可以找个好工作，有个温馨的家庭，平静的生活。可学校分配的工作是做流水线工人，早上7点工作到晚上11点甚至更晚。刚毕业那会还觉得有机会，七八年后，他已不再想过日子，这期间他也从流水线工人变成了标准的“三合大神”。过着“干一天玩三天”的生活。是什么让他成为了“三和大神”？—失去生活的希望 流水线的工作，无限制的循环一件事情，似乎完全看不见自己的未来，还是带着每日全身的疲倦，与其如此，不如过着“三和大神”的生活来的实在，累一天“舒服”三天。 误入歧途 东东，22岁，来自农村，因为上班时打瞌睡被老板娘说了几句就辞职来到三和，住进了15元一晚的宾馆。开始“三和大神”的生活。 躺下太久就站不起来了！ 对于“三和大神”，我感到的不是同情，而是可怜，甚至是可笑，所有的一切不过都是自己不想站起来的原因罢了！不过是自己懒惰的借口！我们不得不承认社会的不公，你也许永远无法成为王健林，马云，但你是可以靠自己的努力让你过上普通人的生活。觉得自己的工作没希望就换个有希望的工作，找不到就去学习。这中国这片土地上永远不缺可供学习的地方。唯一缺的是愿意一心一意去学习的人。所谓的“三和大神”不过是那些受不了现实的打击或承受不了现实的打磨，倒在路上的一群人！他们甘愿倒在半路！他们甘愿走在社会的最低层！那么这就是不会被同情的，因为是他们自己选择了自己的道路，不是别人，更不是这个社会！“讨厌长期劳动，喜欢日结”不过是自己不愿努力的掩饰罢了，就如同“讨厌站起来，喜欢躺在在床上”一样可笑。 我们都一样人性相同其实他们与我们有什么不同？哪一个人不希望每天轻轻松松，什么都不干，不去承受，不去负担。这种人性的弱点是始终存在的。即使是再伟大的人，也会有偷懒的想法。古代的皇帝，每天翻阅奏章，管理国家大事，几乎所有的大事都会通过皇帝的脑袋，难道他不想随便完成然后去后宫吃喝玩乐？如今的富商哪一个不是每天满满的日程，用尽心思的去经营自己的生意，难道他们不想停下来休息一下？芸芸众生谁不辛苦？谁生活在温室中？谁不想停下来“躺在地上”？但我们没有那么做，因为“躺下太久，就站不起来了”！ 选择不同但我们的选择不同，我们选择了站起来，继续前进。现实一次又一次的将我们击倒，但仍然有人站起来，继续前进！“三和大神”就是被击倒后站不起来的那一群人。他们倒下后发现原来躺着是这么舒服啊，那就别站起来了，干脆做他一场黄粱大梦，或在梦中，或在网络中。 请不要躺太久！请不要躺太久，以至于忘记如何站立！不管自己的梦想是否遥远，都请一直走下去，因为至少你可以更清晰的看见自己的梦想啊。","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"社会","slug":"社会","permalink":"http://yoursite.com/tags/社会/"},{"name":"见解","slug":"见解","permalink":"http://yoursite.com/tags/见解/"}]},{"title":"开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）","slug":"开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）","date":"2018-08-25T01:01:03.000Z","updated":"2018-08-25T11:50:13.614Z","comments":true,"path":"2018/08/25/开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）/","link":"","permalink":"http://yoursite.com/2018/08/25/开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）/","excerpt":"前言这个小项目花了我大概10天的时间（每天5h左右），可以说是很慢了，主要是JS的很多知识点不熟悉，边研究边开发。而且数据库部分仍然时使用本地存储，也就是说这个案例是无法投入到实际使用中，但后面我会去研究一下mysql，在服务器端部署一个小型的数据库，估计不会花太长时间，另外觉得node.js挺有意思，hexo就是基于node.js，将JS用于与计算机系统的直接沟通，That`s cool，本来我的原计划是将博客信息存储在本地文件中，比如直接在本地存储一个JSON文件用来存储一篇博客，后来发现这个是实现不了的，因为浏览器内核无法与系统直接沟通，内核是在浏览器提供的一个BOX中运行，无法直接操作系统文件，emmmm，可能这也是为系统安全把，不然随便一个恶意网页就可以操作你的文件，This is unimaginative。也是因为这个所以才有了node.js的诞生的吧！","text":"前言这个小项目花了我大概10天的时间（每天5h左右），可以说是很慢了，主要是JS的很多知识点不熟悉，边研究边开发。而且数据库部分仍然时使用本地存储，也就是说这个案例是无法投入到实际使用中，但后面我会去研究一下mysql，在服务器端部署一个小型的数据库，估计不会花太长时间，另外觉得node.js挺有意思，hexo就是基于node.js，将JS用于与计算机系统的直接沟通，That`s cool，本来我的原计划是将博客信息存储在本地文件中，比如直接在本地存储一个JSON文件用来存储一篇博客，后来发现这个是实现不了的，因为浏览器内核无法与系统直接沟通，内核是在浏览器提供的一个BOX中运行，无法直接操作系统文件，emmmm，可能这也是为系统安全把，不然随便一个恶意网页就可以操作你的文件，This is unimaginative。也是因为这个所以才有了node.js的诞生的吧！ 正文BB了那么久，咳咳，进入正题。 首页 布局过后首页上半部分是这样，和当初的设计差不多。整个上半部分是一个轮播图。 var i=0; setInterval(function(){ if(i&lt;4) { i++; $(document).ready(function(){ $(&quot;.item&quot;).eq(i).fadeIn(2000).siblings().fadeOut(2000); }); } else { $(document).ready(function(){ $(&quot;.item&quot;).eq(3).fadeIn(2000).siblings().fadeOut(2000); }); i=-1; } //console.log(i); }, 4000); 用了jquery的fadeIn,fadeOut方法，由于没有按钮使代码很简单，只用了十多行代码。唯一有问题的最后一张图片与第一张总是相差设定时间的2倍，想了许多办法没有解决，我就直接班另一张图片插入到最后一张与第一张的间隔之间，这样就实现图片的播放速度是均匀的，但问题是不循环播放的，有一张图片要多出现一次。 顶部分别是home，catalogue，和login的链接，左半部分有博主本人的logo。 点击logo可以将其大部分隐藏到屏幕外侧，like this， 再次点击边缘部分，可再次点击召唤出logo &lt;- &lt;-其原理也很简单，只是利用了jquery的动画方法， animate（） 布局方面整个上半部分设计简单，只用了原生的CSS与html完成。 下半部分是文章展示部分，我是在首页设置了几篇置顶文章，具体方法是直接在在html文档中写入写入这一部分代码，不是JS后期插入到文档中，然后下面是使用JS写入的文章部分，这些文章都是存储在数据库中的部分，并且可以在article页面查看。具体实现方式是在写入博客时将博客的title，date，tags，article写入到一个对象中，再JSON化写入本地（这里JSON化的原因在上期关于localStorage的介绍中已经写到，主要原因是localStorage只能存储string要想保留格式，JSON化是一种比较好的办法）。然后在首页读取数据再JSON.parse，在格式插入到文档中。 另外在首页还需要解决问题就是将文章序号传输到文章展示页面，因为当点击文章标题或more时，需要跳转至文章展示页面，展示该文章。我所想到的解决办法是在添加文章到首页文档流中时就把序号写入放置该文章的div的id的尾部，传输到展示页面时再通过this关键字读取id关键字（在测试中我也发现this无法获取class属性的值，原因我正在探索中，后面会出一起专门关于this的文章），并通过charAt()获取该序号，然后通过URL传值的方法将其传递到展示页面。 展示页面 文章展示页面提供问文章的全面展示，并且提供评论功能。（本来是打算在首页也只展示文章的部分，后来感觉有点麻烦，看后面有时间了再实现）。 接上面首页传输文章序号到展示页面，展示页面通过函数解析序号，这个函数我实用的网上的一个模板，代码如下。 UrlParm = function() { // url参数 var data, index; (function init() { data = []; index = {}; var u = window.location.search.substr(1); if (u != &apos;&apos;) { var parms = decodeURIComponent(u).split(&apos;&amp;&apos;); for (var i = 0, len = parms.length; i &lt; len; i++) { if (parms[i] != &apos;&apos;) { var p = parms[i].split(&quot;=&quot;); if (p.length == 1 || (p.length == 2 &amp;&amp; p[1] == &apos;&apos;)) {// p | p= data.push([&apos;&apos;]); index[p[0]] = data.length - 1; } else if (typeof(p[0]) == &apos;undefined&apos; || p[0] == &apos;&apos;) { // =c | = data[0] = [p[1]]; } else if (typeof(index[p[0]]) == &apos;undefined&apos;) { // c=aaa data.push([p[1]]); index[p[0]] = data.length - 1; } else {// c=aaa data[index[p[0]]].push(p[1]); } } } } })(); return { // 获得参数,类似request.getParameter() parm : function(o) { // o: 参数名或者参数次序 try { return (typeof(o) == &apos;number&apos; ? data[o][0] : data[index[o]][0]); } catch (e) { } }, //获得参数组, 类似request.getParameterValues() parmValues : function(o) { // o: 参数名或者参数次序 try { return (typeof(o) == &apos;number&apos; ? data[o] : data[index[o]]); } catch (e) {} }, //是否含有parmName参数 hasParm : function(parmName) { return typeof(parmName) == &apos;string&apos; ? typeof(index[parmName]) != &apos;undefined&apos; : false; }, // 获得参数Map ,类似request.getParameterMap() parmMap : function() { var map = {}; try { for (var p in index) { map[p] = data[index[p]]; } } catch (e) {} return map; } } }(); 有点长，权当备份一下，后面在分析这个函数。 展示页面解析到文章序号后，展示函数直接通过读取数据库读取到数据添加到文档流中。 评论部分的实现也比较简单，通过读取文档中用户输入的信息并将其重新写入该文章数据库中的JSON中，展示时自动展示出来。 目录页面 目录页面展示了所有通过JS放入数据库的文章（不包括首页置顶文章）。 这里的实现就是直接遍历数据库中的博客文章信息，因为当时存储时是格式命名的，所以遍历很简单，再把title循环添加到文档流中就ok了。 登录及后台管理页面 登录页面使用MD5加密方式，与本地存储的密匙（未来的密匙存储在服务器端）进行对比。 这里是在登录过后显示页面，首先这里布局还是用了frame框架，我暂时还没想到更好的替代办法，虽然frame在H5已被抛弃。 在写博客页面，用户将自己的文章内容输入，然后提交，文章内容会被JSON化后被保存到数据库，下次进入首页时就会直接被展示出来。 删改页面也是遍历数据库，直接修改数据库内容就好了，还是比较简单了，具体过程就不再赘述。 最后的工具页面是我想没事可以自己开发一些简单的工具，比如什么颜色拾取等等，这也是后话。 最后其实这个小项目还是比较简单，代码量也不是很大，主要是练一下手，熟悉以一下前端的一些知识，当然这个小项目还有很多不足需要满足，包括在代码规范等等,方便后面的深入学习。当然后面在学习玩数据库后会把本地数据库改为服务器端的数据库，使之可以实际运行。","categories":[{"name":"博客开发系列","slug":"博客开发系列","permalink":"http://yoursite.com/categories/博客开发系列/"}],"tags":[{"name":"博客开发","slug":"博客开发","permalink":"http://yoursite.com/tags/博客开发/"},{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/前端开发/"}]},{"title":"关于JS单线程，异步执行的理解","slug":"关于JS单线程，异步执行的理解","date":"2018-08-22T02:13:24.000Z","updated":"2018-08-22T04:20:53.093Z","comments":true,"path":"2018/08/22/关于JS单线程，异步执行的理解/","link":"","permalink":"http://yoursite.com/2018/08/22/关于JS单线程，异步执行的理解/","excerpt":"前言在这几天的开发过程中，遇到了不少问题，阻塞最久的应该就是一段JS代码没有按照我以为的执行顺序去执行，想想好像也没有具体的了解JS的执行过程，所以花了一整天的时间来了解了一下JS的执行机制。","text":"前言在这几天的开发过程中，遇到了不少问题，阻塞最久的应该就是一段JS代码没有按照我以为的执行顺序去执行，想想好像也没有具体的了解JS的执行过程，所以花了一整天的时间来了解了一下JS的执行机制。 问题代码for(var i=0;i&lt;=3;i++){ $(document).ready(function){ console.log(i); }); 出现问题的代码简化过后大概是这个样式，我的预期是输出1，2，3，但输出的结果却为3,3,3，我开始以为是JS单线程执行的缘故，所以Jquery代码被放在了callback queue（任务队列）的最后执行，但我查询资料后发现仅发现浏览器会为定时器，ajax等多开线程，jquery应该不算，正在我疑惑之时，我打开了Jquery的官方文档，看到了 $(document).ready(function(){});的定义：文档准备完成后，内部的匿名函数作为document(ready)的回调函数进行执行，而此时for早已进行玩了。这就解释了为什么都是3,3,3。 正文从浏览器谈起浏览器的进程与线程浏览器是多进程的 Browser进程：负责浏览器的主进程（协调，主控）。 第三方插件进程：每一个插件对应一个进程。 GPU进程：用于绘制3D图形等。 浏览器渲染进程 （render进程，浏览器内核）：每一个Tab页面一个进程，这个进程渲染我们所看到的每个页面。 浏览器渲染进程是多线程的前面我们说到我们所看到的页面都是有渲染进程进行渲染的，而他又是多线程的： GUI渲染线程（浏览器内核） 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发进程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 进入正题，JS的执行过程js的同步任务和异步任务 所有同步任务（能够立即被执行，不消耗时间的任务，如变量核函数的初始化，时间的绑定等等不需要回调函数的任务）都在主线程中执行，形成执行栈（stack），heap（堆）用来存储变量，对象等。 所有异步任务（一半会有操作，如点击事件，定时事件，具有回调函数的事件）运行在事件触发线程中，当异步任务有结果是，其回调函数（Callback Function）就会被放到任务队列中，等待执行。 当执行栈中同步任务执行完毕后， JS引擎就会从任务队列中（callback queue）中查找任务放入执行栈中，这个过程就被称之为事件循环event loop。 从上面的解释中可以看到JS引擎始终是在执行栈中单线程执行任务，当执行栈空时，接下来的任务才回从任务队列中读取下一任务。 何为异步 所谓的异步，就是在其他线程（事件触发线程，异步http请求线程等）的辅助下，JS线程实现异步处理任务。举个栗子： consloe.log(&quot;a&quot;) setTimeout(function() { console.log(&quot;b&quot;) }, 0) console.log(&quot;c&quot;) 模拟其运行过程： 1.consloe.log(&quot;a&quot;)// JS引擎发现这是一个同步任务，立即执行打印出a; 2.setTimeout(function() { console.log(&quot;b&quot;) }, 0)//JS引擎只想此处时发现这是一个异步任务，所以直接交由定时触发线程。 JS引擎继续向下执行，与此同时，定时触发线程接收到该事件，解析代码过后， 将在0毫秒实际是4毫秒，因为在上面我们讲到，W3C规定定时引擎的最低时间为4毫秒）后向JS引擎发送 回调函数，并将其推到任务队列中等待执行。 3.console.log(&quot;c&quot;)//再向定时引擎发送定时事件后立即执行该代码。打印出c。 4.定时引擎将console.log(&quot;b&quot;)推入任务队 列，在console.log（&quot;c&quot;）运行完成后，执行栈空，再将其推入执行栈，然后执console.log(&quot;c&quot;)， 打印出c,因此这段代码输出的结果为a,c,b,而不是a,b,c. 注意，即使setTimeout不是4毫秒后，而是0毫秒后返回回调函数，执行结果任然是a,c,b。因为这是一个排队的过程，console.log(“b”)任是排在console.log(“c”)之后的。 由此，一个异步任务就在JS引擎与其他线程的共同作用下完成了。 参考资料从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 js的单线程和异步 JavaScript单线程和异步机制 最后这只是一个简单的理解，其中还有许多部分可能没有完善，等以后有更深的理解时再来完善吧。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"}]},{"title":"利用SS（Shadowsocks）快速搭建一个vpn","slug":"利用SS（Shadowsocks）快速搭建一个vpn","date":"2018-08-20T10:43:57.000Z","updated":"2018-08-20T12:06:34.774Z","comments":true,"path":"2018/08/20/利用SS（Shadowsocks）快速搭建一个vpn/","link":"","permalink":"http://yoursite.com/2018/08/20/利用SS（Shadowsocks）快速搭建一个vpn/","excerpt":"前言前几天玩kali时发现需要下一个插件，但是需要科学上网，无奈打开之前的vpn软件，发现几乎都关闭了服务，于是我就诞生了自己搭建一个vpn的想法，于是在参考了网上的教程后，折腾了一上午终于成功了。 正文一，购买服务器（vps）国外的服务器提供商比较多，比如DigtaOcean，Vultr，Amazon等等，我选择了Vultr，因为它提供的vps价格最低的一款仅2.5$/月（后来才发现是个坑，后人谨记），其实DigtaOcean也还不错，绑定信用卡就送10刀，而他价格最低的一款vps价格为5刀，相当于是说送你两个月的体验时间，Amazon好像开可以免费体验一年，所以选择服务器时要多方考虑一下，","text":"前言前几天玩kali时发现需要下一个插件，但是需要科学上网，无奈打开之前的vpn软件，发现几乎都关闭了服务，于是我就诞生了自己搭建一个vpn的想法，于是在参考了网上的教程后，折腾了一上午终于成功了。 正文一，购买服务器（vps）国外的服务器提供商比较多，比如DigtaOcean，Vultr，Amazon等等，我选择了Vultr，因为它提供的vps价格最低的一款仅2.5$/月（后来才发现是个坑，后人谨记），其实DigtaOcean也还不错，绑定信用卡就送10刀，而他价格最低的一款vps价格为5刀，相当于是说送你两个月的体验时间，Amazon好像开可以免费体验一年，所以选择服务器时要多方考虑一下，地点我们尽量选在米国，具体速度我没有测试过。注意：千万不要选择2.5刀那款服务器，因为它只有一个ipv6的地址，是无法用来搭建的（具体原因我没有深入探索，但估计也是，不是所有的服务都兼容ipv6，购买这款服务器时官方也会有提示），所以我们选择5刀的那款，系统选择Ubuntu，当然其他的也是可以的。但我们在后面还是把enable ipv6勾上，为我们分配一个ipv6的地址。label和hostname是你自己的信息。至此，服务器的购买就完成了，等待服务器初始化和开机。 二，连接服务器此时，我们可以在你的控制面板里看到你服务器端的ip地址以及用户名和密码。然后我们需要远程连接到你的服务器，这里我们选择Xshell这款软件。点击文件，新建。在主机输入我们在控制面板中看到的IPV4的地址，之后会提示我们输入用户名及密码，这些信息也都在控制面板中，我就不再截图。 之后我们就会连接上我们的服务器。 然后就输几行代码就ok了。 apt-get install python-pip pip install shadowsocks 两行代码就安装好了ShadowSocks,下面就是配置SS文件 nano /etc/shadowsocks.json nano相比于vim更对Linux新手友好。之后将下面这段代码改为你的账户后粘贴进去。 { “server”:”0.0.0.0”, “server_port”:8388, “local_address”: “127.0.0.1”, “local_port”:1080, “password”:”mypassword”, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”: false } 多账户： { “server”:”0.0.0.0”, “port_password”:{ “8381”:”xxxxxxx”, “8382”:”xxxxxxx”, “8383”:”xxxxxxx”, “8384”:”xxxxxxx” }, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”: false } | 字段 | 说明 || server | ss服务监听地址，0.0.0.0允许所有人访问，如果只是自己用，可以改成自己使用端的ip || server_port | ss服务监听端口 || local_address | 本地的监听地址 || local_port | 本地的监听端口 || password | 密码 || timeout | 超时时间，单位秒 || method | 加密方法，默认是aes-256-cfb || fast_open | 使用TCP_FASTOPEN, true / false || workers | workers数，只支持Unix/Linux系统 | 然后启动服务 ssserver -c /etc/shadowsocks.json -d start 如果需要关闭服务 ssserver -c /etc/shadowsocks.json -d stop 至此，我们服务器端就配置好了，现在就是需要下载shadowsocks连接就ok了。 客户端的使用由于SS在天朝已经GG了，官网已经打不开了，只在github中更新，所以，在这里下载以及查看官方文档。！client 下载完客户端后，输入我们的服务器IP，刚刚在SS中设置端口及密码，点击确定就可以连接到我们的vpn了。 然后就查找学习资料吧~","categories":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://yoursite.com/categories/Shadowsocks/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://yoursite.com/tags/Shadowsocks/"},{"name":"vpn","slug":"vpn","permalink":"http://yoursite.com/tags/vpn/"}]},{"title":"对于JS中localStorage的理解","slug":"对于JS中localStorage的理解","date":"2018-08-20T07:13:20.000Z","updated":"2018-08-20T08:36:46.437Z","comments":true,"path":"2018/08/20/对于JS中localStorage的理解/","link":"","permalink":"http://yoursite.com/2018/08/20/对于JS中localStorage的理解/","excerpt":"前言最近在开发博客的过程中，遇到了数据储存的问题，由于我服务器中还未安装sql，加上我对数据库的操作还不是很熟悉，所以先把数据放入了localStorage中，所以我就具体了解了一下这个本地数据库。 正文前端的存储数据的三种方式前端一般数据存储的方式有三种： cookies sessionStorage localStorage","text":"前言最近在开发博客的过程中，遇到了数据储存的问题，由于我服务器中还未安装sql，加上我对数据库的操作还不是很熟悉，所以先把数据放入了localStorage中，所以我就具体了解了一下这个本地数据库。 正文前端的存储数据的三种方式前端一般数据存储的方式有三种： cookies sessionStorage localStorage 简单介绍一下这三种方式的异同： cookies与localStorage可以是永久存储（cookies可设置失效时间；用户不主动清除） sessionStorage与localStorage属于H5引入的新标签，在IE8，Chrome4.0等以上才能执行；并且存储空间更大（5MB/站点）相对于cookies（4KB/站点）。具体localStorage的解析 localStorage的优势与局限优势 相对于cookies拓展了空间大小。 相对于sessionStorage，可永久存储信息。 局限 由于是H5引入的属性，可能一些老版的浏览器不支持该属性。 localStorage所存储的信息被限定被string类型，但由于有JSON等对象转换算法，所以也无所谓了。 另外我在网上了解到，localStorage无法被爬虫抓取到，这一点我目前没有深入探究。 localStorage的使用判断浏览器是否支持 localStorage属性if(！window.localStorage){ alert(&quot;您的浏览器不支持localStorage&quot;) return false} else{ //执行代码 } localStorage的写入三种方法： var data=window.localStorage; data[&quot;name&quot;] = MJ;//关键字name写入 data.age = 20;//关键字age的写入 data.setItem = [&quot;shcool&quot;,清华大学];//关键字school写入 注意：前面是将localStorage属性放入了data变量，同样可以不放入变量，直接调用，所以前面的代码等同于: localStorage[&quot;name&quot;]=MJ; localStorage.age=20; localStorage.setItem(&quot;school&quot;,清华大学); localStorage的读取三种方法： var name = localStorage[&quot;name&quot;]; var age = localStorage.age; var school = localStorage.getItem(&quot;school&quot;); 同样想写入方法一样，也可以将localStorage放入变量中在调用。 值得注意的是，官方更推荐使用，setItem与getItem语法，其原因未具体说明，我猜测可能是为了与JS中的对象区分开，更加语言话，不产生混淆 localStorage的删改localStorage改关键字的值其实就是重新为其赋值，即： localStorage.setItem(&quot;name&quot;,MW); var nameAfter=localStorage.getItem(&quot;name&quot;); //nameAfter===MW-&gt;true localStorage的删除： localStorage.clear();//删除改站点的所有localStorage数据 localStorage.removeItem(&quot;name&quot;); //此时localStorage.name-&gt;nudifined 关于存储的数据仅为string的解决办法（JSON数据类型转换）一，写入时转换为JSON格式输入 var person={ name = &quot;MJ&quot;, age = 20, maritalStatus = true } localStorage.setItem(&quot;person&quot;,JSON.string(person)); 二，读取时转换为JS变量 var person =JSON.parse(localStorage.getItem(&quot;person&quot;)); typof(person.age) //typeof检查变量类型为number typeof(person.maritalStstus)//boolean 最后本来写之前感觉有很多注意要写，但写起来感觉哪些之前感觉是注意点的地方其实只是一个普通的点，所以感觉写起来感觉没有太重要的点，但需要注意的点还是有滴，比如三种存储的异同，localStorage存储的数据仅为string等等。ok，就这样把！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"localStorage","slug":"localStorage","permalink":"http://yoursite.com/tags/localStorage/"}]},{"title":"Apicloud不同页面传值","slug":"Apicloud不同页面传值","date":"2018-08-13T11:00:52.000Z","updated":"2018-08-13T13:26:24.749Z","comments":true,"path":"2018/08/13/Apicloud不同页面传值/","link":"","permalink":"http://yoursite.com/2018/08/13/Apicloud不同页面传值/","excerpt":"前言 标准开头，前一段时间因为需要开发一个简单的app,所以接触了一下Apicloud,因为没有native应用的开发知识，所以采用了Apicloud的web应用开发。其中不同页面的传值问题我具体研究一段时间，因为之前一直传值不成功。 正文方法一：api.execScript","text":"前言 标准开头，前一段时间因为需要开发一个简单的app,所以接触了一下Apicloud,因为没有native应用的开发知识，所以采用了Apicloud的web应用开发。其中不同页面的传值问题我具体研究一段时间，因为之前一直传值不成功。 正文方法一：api.execScript 这个方法本来的功能是用来不同页面的函数的传递，当然，也可以用来传递值，将这个值作为函数的参数就可以传递到其他页面。具体： index1： //name是该页面函数的参数，作为参数传递到另一个页面 var str=&quot;test(&quot;+name+&quot;)&quot;; api.exeScript({ name:&quot;index2&quot;, script:str}); index2: //index2页面代码 function test(name){ alert(name); } 方法：api.addEventListener&amp;&amp;api.sendEvent这个是利用广播事件传递参数。 index1:发送广播 api.sendEvent({ name:&apos;myEvent&apos;, extra:{key1:&apos;value&apos;,key2:&apos;key2&apos;} }); index2:接受广播 api.addEventListener({ name:&apos;myEvent&apos;}, function(ret){ if(ret&amp;&amp;ret.value){ var value = ret.value; alert(value.key1+&apos;,&apos;+value.key2); } }); 方法三 :api.LocalStorage这个方法很简单，采用了本地数据存储的方法来交换数据。 index1: $api.setStorage(&apos;name&apos;,&apos;value&apos;);//数据存储 index2: $api.getStorage(&apos;name&apos;);//取出name值 另外： $api.rnStorage(&apos;name&apos;);//清除name值 $api.clearStorage(&apos;name&apos;);//清除所有本地数据 方法四 ：api.openWin&amp;api.openFrame&amp;api.openFrameGroup最后最简单的是采用打开窗口时可以顺带传值。 index1: //打开新窗口 api.openWin({ name:index2, url:index2.html, pageParam: { key : value, } }); //打开frame组 api.openFrameGroup({ name: &apos;group1&apos;, rect: { //frame的位置 x: 0, y: 0, w: &apos;auto&apos;, h: &apos;auto&apos; }, frames: [{ //frame组 name: &apos;frame1&apos;, url: &apos;frame1.html&apos;, bgColor: &apos;#fff&apos; }, { name: &apos;frame2&apos;, url: &apos;frame2.html&apos;, bgColor: &apos;#fff&apos; }] }, function(ret, err) { //回调函数 var index = ret.index; }); index2: apiready=function(){ var test=api.pageParam.key; alert(test); }","categories":[{"name":"Apicloud","slug":"Apicloud","permalink":"http://yoursite.com/categories/Apicloud/"}],"tags":[{"name":"Apicloud","slug":"Apicloud","permalink":"http://yoursite.com/tags/Apicloud/"}]},{"title":"开发一个简单的个人博客（1）UI设计","slug":"代码开发一个简单的个人博客（1）UI设计","date":"2018-08-13T08:55:46.000Z","updated":"2018-08-25T00:51:43.963Z","comments":true,"path":"2018/08/13/代码开发一个简单的个人博客（1）UI设计/","link":"","permalink":"http://yoursite.com/2018/08/13/代码开发一个简单的个人博客（1）UI设计/","excerpt":"前言本来早该写这个博客，因为前一段时间一直在学习各种框架，为这个开发做准备。所以一直拖到现在才开始这个系列的文章，估计这个系列文章会持续4-5期，来写下我开发这个网站的全过程。我会尽力开发到理想状态，具体效果在月底估计会出来。","text":"前言本来早该写这个博客，因为前一段时间一直在学习各种框架，为这个开发做准备。所以一直拖到现在才开始这个系列的文章，估计这个系列文章会持续4-5期，来写下我开发这个网站的全过程。我会尽力开发到理想状态，具体效果在月底估计会出来。 正文UI设计 在具体开发开发之前，我先概括的设计出来一个几个用户界面，包括主页，文章界面，后台用户界面。具体设计软件时使用Axure。 主页界面 主页是采用了比较简洁通用的设计样式，顶部是采用了稍隐藏式的顶部栏样式，顶部栏左侧是Tags,Home链接；左侧是后台界面的登录按钮。其次整个上部是一个轮播图，右侧是一个作者介绍，包括简书，github等的链接，头像，头像左侧准备设计一个按钮，点击时头像隐藏到右侧。 在底部没有采用过多的装饰，作者权限以及在有条件下可以开发一个浏览人数（图片上未展示）。文章界面文章界面上部是没有做改动，与主页界面一样，唯一不同的是轮播图改为静态图片展示，为了更好的阅读体验。其次在界面左侧引用了百度的分享控件，用来分享。在底部，我准备自己开发一个简单的评论系统，并不打算采用第三方评论系统。方案在后面写出。 后台界面 最后的后台用户界面，具体选项目前只准备了写博客与删除博客，以及使用工具的选项。具体美化可以在后期自我发挥~","categories":[{"name":"博客开发系列","slug":"博客开发系列","permalink":"http://yoursite.com/categories/博客开发系列/"}],"tags":[{"name":"博客开发","slug":"博客开发","permalink":"http://yoursite.com/tags/博客开发/"},{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/前端开发/"}]},{"title":"《亮剑》精神-军人的尊严","slug":"《亮剑》精神","date":"2018-07-25T11:12:33.000Z","updated":"2018-08-31T14:40:25.887Z","comments":true,"path":"2018/07/25/《亮剑》精神/","link":"","permalink":"http://yoursite.com/2018/07/25/《亮剑》精神/","excerpt":"近来3天读完了《亮剑》一书。说来奇怪，平时读书无不是强忍困意的煎熬，唯独这本书，里面的情节，人物，仿佛有莫大的吸引力。把我带入那个战火纷飞的年代……","text":"近来3天读完了《亮剑》一书。说来奇怪，平时读书无不是强忍困意的煎熬，唯独这本书，里面的情节，人物，仿佛有莫大的吸引力。把我带入那个战火纷飞的年代……我对李云龙的理解，仅限于电视剧中的那个形象，鲁莽，草率，但却勇敢，敢作敢当，思维已与常人。甚至当我刚读到原著时，我也这么认为，因为电视剧几乎是忠于原文，没有做改动，确是都梁笔下的那个李云龙。 但也是当我读到后来我才发现，电视剧未免有些片面，只塑造了一个能征善战的李云龙，这恐怕不是都梁的本意，也是由于敏感原因，导演无法将都梁笔下的那个李云龙活生生塑造出来。不过在我看来，李云龙这个人物的关键就在于后面的部分，前面的部分塑造了他的英勇，而后面李云龙的改变与他的坚持正是这个人物的灵魂所在。他在成长，却也有他坚持的信条！ 当他岳父谈及党内出现错误之时，他严厉的表示反对，因为他认为他跟及的共产党是不可能犯错误的，错在岳父根深蒂固的资产阶级思想。甚至在他的岳父岳母被拉到农村进行改造之时他仍认为这是他们的错误所对应的惩罚。 他信念的动摇是在赵刚死之后，作为搭档十几年的老战友，他相信赵刚是不会犯这种错误的，但他还是不明白到底是谁的错，他要去打死害死赵刚的人，被田雨制止，从这里他开始了他的思考，到底是谁的错误，使这些原本无罪的人受到非人的待遇。 当时他已是一军之长，管理着一个军的庞大队伍，而这一个军队却被两派所谓的左系革命派骑在头上，当其中一派要求得到他的支持时，他装病躲进来医院，以此来避开，而新来的副军长马天生确实一个极其“聪明”之人，他在李云龙“养病”之时，选着了其中一方支持，而另一方却得到省军区的支持。两派系随之进入了军事级别的斗争，若不是书中描述，我怎么也不会想到两个工人组成的团体可以在一座城市中兵戎相见，动辄就是大炮相见，甚至想要夺取军库，拿取大型榴弹炮，而这种榴弹炮的攻击半径几乎是半个城市。 李云龙不敢抵抗，因为一旦抵抗，毫无疑问，下场和赵刚没有区别。李云龙是个聪明人，他一忍再忍，企图想到一个两全其美的办法，但还没等到他想出来，他的一个师部就被革命派占领，军事机密，武器全落入他人之手，他明白只意味着什么，一旦不加以制止，整个城市都将毁于一旦。 李云龙还是那个李云龙，他亮剑了。就如同他在平安城下的那句“开炮！”。他开始下达了命令。这命令也代表这李云龙的灭亡，一颗流星的陨落，一个时代的结束。 最终，李云龙在他家里的阁楼上用那把楚云飞送他的勃朗宁手枪结束了自己的一生。 赵刚在临终的信中写着死亡也是一种反抗，他是对自己信条的坚持，所不同的是，李云龙坚持的是他的军人尊严！宁死不屈的精神！ 原文中对李云龙自杀前用了大量的文笔，无非是为了诠释，李云龙一生戎马，可倾尽一生，也无法想出，到底是谁的错，毛主席不会错，共产党不会错，那可能就是他李云龙的错误吧。","categories":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/categories/读书/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"},{"name":"感情","slug":"感情","permalink":"http://yoursite.com/tags/感情/"}]},{"title":"在ESC服务器上搭建静态网站","slug":"ecsAndWebsite","date":"2018-07-22T14:14:41.000Z","updated":"2018-07-25T14:12:41.473Z","comments":true,"path":"2018/07/22/ecsAndWebsite/","link":"","permalink":"http://yoursite.com/2018/07/22/ecsAndWebsite/","excerpt":"开始前面在连接上服务器后，紧接着我想测试一下服务器的网站搭建，下面就把简单的教程贴出来。 1.首先要要在服务器管理页面对服务器进行配置（我最开始就是忘了配置服务器的端口，结果怎么都不对!!!）由于我们HTTP的对应端口是80，所以我们在安全组规则中添加对80端口的开放。","text":"开始前面在连接上服务器后，紧接着我想测试一下服务器的网站搭建，下面就把简单的教程贴出来。 1.首先要要在服务器管理页面对服务器进行配置（我最开始就是忘了配置服务器的端口，结果怎么都不对!!!）由于我们HTTP的对应端口是80，所以我们在安全组规则中添加对80端口的开放。 添加好之后: 2.我的windows服务器中是没有自带IIS的，所以先从IIS的安装开始，点击左下角的服务器管理图标进入服务器管理页面。 3.在服务器管理中点击角色并点击右面的添加角色。 4.进入添加角色向导。 5.钩选Web服务器(IIS),点击安装。 6.点击安装后会弹出是否添加，点击“添加必需的功能”。 7.然后会弹出角色服务，由于我们搭建的静态网页，所以勾选常见的HTTTP功能，如果需要构建动态网站，可够相爱U呢引用程序开发下的相应功能。 8.然后等待角色安装完成。 9.然后就可以输入服务器的公网IP查看是否成功安装IIS服务。看到上面这张图就代表安装成功了。 10.添加应用池。 11.添加站点，注意，IP地址要选择全部未分配 *12.最后是默认文档的修改，服务器中默认的主页是default.htm,你可以把它改成你的主页名。 13.在浏览器输入你的ip地址。查看你的网页。 结尾至此，一个静态网站就搭建好了。其中容易发生错误的点主要有： 安全规则没有配置或者没有配置正确。 创建新站点的IP地址要选择全部未分配。 借鉴资料： 部分图片取自csdn博主bestself_iot的文章IIS 静态页面网站搭建","categories":[{"name":"website","slug":"website","permalink":"http://yoursite.com/categories/website/"}],"tags":[{"name":"esc","slug":"esc","permalink":"http://yoursite.com/tags/esc/"},{"name":"website","slug":"website","permalink":"http://yoursite.com/tags/website/"}]},{"title":"xhellAnEcsd","slug":"xhellandcsd","date":"2018-07-22T03:51:30.000Z","updated":"2018-07-25T14:14:05.082Z","comments":true,"path":"2018/07/22/xhellandcsd/","link":"","permalink":"http://yoursite.com/2018/07/22/xhellandcsd/","excerpt":"关于ecs服务器的连接问题最近看阿里云有一个学生优惠，就申请了一个优惠的ecs服务器，一个月9.9,2G内存，40G云盘，血赚不亏。","text":"关于ecs服务器的连接问题最近看阿里云有一个学生优惠，就申请了一个优惠的ecs服务器，一个月9.9,2G内存，40G云盘，血赚不亏。然后我就开始配置服务器，发现这个廉价的服务器是没办法更换操作系统的，自带的是一个Windows Server 2008 32位。然后我就开始准备连接服务器。阿里云自带有连接服务，但每天都要登陆网页会很麻烦。 然后我就下载了xshell，但一直连接不上，查看服务器端口配置，发现ssh端口22是打开的。后来我在网上查了很多资料，发现还是连接不上。最后我才意识到可能是操作系统的问题。果然我查询了sxhell支持的操作系统。得到如下结果： xshell等软件仅支持Linux，UNIX，centos等。 对于windows系统，需要用RDCMan或者windows自带的远程桌面连接。","categories":[{"name":"ecs","slug":"ecs","permalink":"http://yoursite.com/categories/ecs/"}],"tags":[{"name":"ecs","slug":"ecs","permalink":"http://yoursite.com/tags/ecs/"},{"name":"xshell","slug":"xshell","permalink":"http://yoursite.com/tags/xshell/"}]},{"title":"第一篇博客啊","slug":"blog","date":"2018-07-19T16:36:22.000Z","updated":"2018-07-20T03:25:25.931Z","comments":true,"path":"2018/07/20/blog/","link":"","permalink":"http://yoursite.com/2018/07/20/blog/","excerpt":"","text":"这是我的第一篇博客啊！折腾了3天了，不过算起来也只是几个小时，还没弄好，心态有点爆炸啊，js也几天没有学了。这是百度的链接emmmm,暂时就这样！123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;fuck you&quot;); return 0;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"}]}]}