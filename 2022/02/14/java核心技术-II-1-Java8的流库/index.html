<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>java核心技术-ii-1-java8的流库 | My Wonderland</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="JavaJava核心技术Java8的流库" />
  
  
  
  
  <meta name="description" content="迭代与流与集合相比，流提供了一种可以让我们在更高的概念级别上指定任务的数据视图。 流提供了几种操作函数，其调用要比一般的迭代更加简洁。并且其可以链式调用，每一次调用都返回一个新的流对象。 如：统计一个List中长度大于12的单词数量。 迭代123456int count &#x3D; 0;for(String w : words)&amp;#123;    if(w.length() &gt; 12)&amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="java核心技术-II-1-Java8的流库">
<meta property="og:url" content="http://yoursite.com/2022/02/14/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-1-Java8%E7%9A%84%E6%B5%81%E5%BA%93/index.html">
<meta property="og:site_name" content="My Wonderland">
<meta property="og:description" content="迭代与流与集合相比，流提供了一种可以让我们在更高的概念级别上指定任务的数据视图。 流提供了几种操作函数，其调用要比一般的迭代更加简洁。并且其可以链式调用，每一次调用都返回一个新的流对象。 如：统计一个List中长度大于12的单词数量。 迭代123456int count &#x3D; 0;for(String w : words)&amp;#123;    if(w.length() &gt; 12)&amp;#123;">
<meta property="article:published_time" content="2022-02-14T15:22:15.000Z">
<meta property="article:modified_time" content="2022-02-14T03:55:00.833Z">
<meta property="article:author" content="Michael Wang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java核心技术">
<meta property="article:tag" content="Java8的流库">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="My Wonderland" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>

  
<script src="/js/bootstrap.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    
<link rel="stylesheet" href="/css/dialog.css">

  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

<meta name="generator" content="Hexo 4.2.1"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Home</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">Categories</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-java核心技术-II-1-Java8的流库" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      java核心技术-II-1-Java8的流库
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2022/02/14/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-1-Java8%E7%9A%84%E6%B5%81%E5%BA%93/" class="article-date">
	  <time datetime="2022-02-14T15:22:15.000Z" itemprop="datePublished">2022-02-14</time>
	</a>

      
    <a class="article-category-link" href="/categories/Java/">Java</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="迭代与流"><a href="#迭代与流" class="headerlink" title="迭代与流"></a>迭代与流</h1><p>与集合相比，流提供了一种可以让我们在更高的概念级别上指定任务的数据视图。</p>
<p>流提供了几种操作函数，其调用要比一般的迭代更加简洁。并且其可以链式调用，每一次调用都返回一个新的流对象。</p>
<p>如：统计一个List中长度大于12的单词数量。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String w : words)&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.length() &gt; <span class="number">12</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>
<h3 id="流与集合的差异"><a href="#流与集合的差异" class="headerlink" title="流与集合的差异"></a>流与集合的差异</h3><ol>
<li>流并不存储其元素。这些元素可能存储在底层的集合中，或者是按需生成的。</li>
<li>流的操作并不会修改其数据源。如<code>filter</code>方法不会从流中移除元素，二十会生成一个新的流，其中不包含过滤掉的元素。</li>
<li>流的操作是尽可能惰性执行的。这意味着直至需要其结果时，操作才会执行。例如，如果只是想查找前5个单词而不是所有的单词，那么<code>filter</code>方法会在匹配到第5个单词后就停止过滤。因此，我们甚至可以操作无限流。</li>
</ol>
<h1 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h1><h2 id="从集合Collections接口创建流"><a href="#从集合Collections接口创建流" class="headerlink" title="从集合Collections接口创建流"></a>从集合<code>Collections</code>接口创建流</h2><p>对于实现了<code>Collection</code>接口的类。可以使用<code>Stream.of</code>方法来获得一个接口。详见<a href="https://michaelwang.top/2022/01/24/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-I-9-%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">java核心技术-I-9-集合</a></p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">"apple"</span>);</span><br><span class="line">arrayList.add(<span class="string">"banana"</span>);</span><br><span class="line">arrayList.add(<span class="string">"pear"</span>);</span><br><span class="line">Stream stream = arrayList.stream();</span><br></pre></td></tr></table></figure>
<h2 id="从数组生成Stream"><a href="#从数组生成Stream" class="headerlink" title="从数组生成Stream"></a>从数组生成<code>Stream</code></h2><h3 id="用所有元素生成Stream"><a href="#用所有元素生成Stream" class="headerlink" title="用所有元素生成Stream"></a>用所有元素生成<code>Stream</code></h3><p>如果要用所有的数组元素来生成一个<code>Stream</code>，则可以使用<code>Stream.of</code></p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>&#125;; </span><br><span class="line">Stream stream1 = Stream.of(arr);</span><br></pre></td></tr></table></figure>
<h3 id="用部分数组元素（连续）生成Stream"><a href="#用部分数组元素（连续）生成Stream" class="headerlink" title="用部分数组元素（连续）生成Stream"></a>用部分数组元素（连续）生成<code>Stream</code></h3><p>如果只需要数组的一部分元素（连续）生成<code>Stream</code>，则可以使用<code>Array.stream(array, from, to)</code>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>&#125;; </span><br><span class="line">Stream stream2 = Arrays.stream(arr, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="直接从基本元素生成Stream"><a href="#直接从基本元素生成Stream" class="headerlink" title="直接从基本元素生成Stream"></a>直接从基本元素生成<code>Stream</code></h2><p>可以通过<code>Stream.of</code>来将基本元素转变为<code>Stream</code>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream stream2 = Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="创建一个空流"><a href="#创建一个空流" class="headerlink" title="创建一个空流"></a>创建一个空流</h2><p>可以通过<code>Stream.empty()</code>来生成一个不包含任何元素的流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; silence = Stream.empty();</span><br></pre></td></tr></table></figure>
<h2 id="创建一个无限流"><a href="#创建一个无限流" class="headerlink" title="创建一个无限流"></a>创建一个无限流</h2><p>可以通过<code>Stream.generate(FunctionInterface)</code>来获取一个无线流，其来源是参数中的函数式接口。</p>
<p>如-通过一个字符串创建流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; echos = Stream.generate(() -&gt; <span class="string">"Echo"</span>);</span><br></pre></td></tr></table></figure>
<p>如-通过随机函数来获取一个包含无限随机数的流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; echos = Stream.generate(Math::random);</span><br></pre></td></tr></table></figure>
<h2 id="创建一个无线的序列流"><a href="#创建一个无线的序列流" class="headerlink" title="创建一个无线的序列流"></a>创建一个无线的序列流</h2><p>可以通过<code>Stream.iterate(Iterable)</code>来通过迭代器创建一个指定的序列流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br></pre></td></tr></table></figure>
<h2 id="创建一个长度仅为0或1的流"><a href="#创建一个长度仅为0或1的流" class="headerlink" title="创建一个长度仅为0或1的流"></a>创建一个长度仅为0或1的流</h2><p>通过<code>Stream.ofNullable(T t)</code>方法可以创建一个长度仅为0或1的流。当参数t为null时，则长度为0，否则长度为1，即是包含该对象。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>值得注意的是，在执行流的操作的时候，我们并没有修改流背后的集合。但是如果手动修改了流的集合（指在流操作外部修改，在流操作，比如<code>forEach</code>中，则会报错），那么流的操作就会变成不可预知的。JDK文档称之为不干涉性。</p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="filter-Predicate-lt-T-gt"><a href="#filter-Predicate-lt-T-gt" class="headerlink" title="filter(Predicate&lt;T&gt;)"></a><code>filter(Predicate&lt;T&gt;)</code></h2><p><code>filter</code>函数会按照参数中的函数式接口来过滤所有元素。然后将符合条件的元素组合为新的流返回。</p>
<p>如-过滤所有长度大于12的单词：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = ...;</span><br><span class="line">Stream&lt;String&gt; longWords = words.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>注意<code>filter</code>的参数为一个<code>Predicate&lt;T&gt;</code>函数式接口。即从T到Boolean的函数。</p>
<h2 id="map-FunctionInterface"><a href="#map-FunctionInterface" class="headerlink" title="map(FunctionInterface)"></a><code>map(FunctionInterface)</code></h2><p><code>map(FunctionInterface)</code>会对流中的每个元素应用参数的函数式接口。并且将所有的结果组合为一个新的流返回。</p>
<p>如-截取所有单词的首字母：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = ...;</span><br><span class="line">Stream&lt;String&gt; firstLetter = words.stream().map(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h2 id="flatMap-FunctionInterface"><a href="#flatMap-FunctionInterface" class="headerlink" title="flatMap(FunctionInterface)"></a><code>flatMap(FunctionInterface)</code></h2><p><code>flatMap(FunctionInterface)</code>是对流中的每个元素应用参数的函数式接口（其都返回一个流），然后将每个参数的返回值组合为一个流。</p>
<p>如<code>codePoints(&quot;boat&quot;)</code>返回的流是<code>[&quot;b&quot;, &quot;o&quot;, &quot;a&quot;, &quot;t&quot;]</code></p>
<p>所以<code>Stream&lt;Stream&lt;String&gt;&gt; result = words.stream().map(w -&gt; codePoints(w))</code>会返回一个流的嵌套。<code>[...[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]</code></p>
<p>而使用<code>Stream&lt;Stream&lt;String&gt;&gt; result = words.stream().flatMap(w -&gt; codePoints(w))</code>会返回一个所有子流的组合流，即<code>[..., &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</code></p>
<h2 id="stream-limit-n"><a href="#stream-limit-n" class="headerlink" title="stream.limit(n)"></a><code>stream.limit(n)</code></h2><p><code>stream.limit(n)</code>会截取流中的前n个元素（如果其长度小于n，则会返回流中的全部元素组成的新流）。</p>
<p>这个方法可以用于裁剪无限流。</p>
<p>如-获取100个随机数的流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; randoms = Streams.generate(Math::random).limit(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h2 id="stream-skip-n"><a href="#stream-skip-n" class="headerlink" title="stream.skip(n)"></a><code>stream.skip(n)</code></h2><p><code>stream.skip(n)</code>方法正好相反，其会丢弃前n个元素。</p>
<p>如-跳过单词表中的前5个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; newWords = words.stream().skip(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h2 id="stream-takeWhile-predicate"><a href="#stream-takeWhile-predicate" class="headerlink" title="stream.takeWhile(predicate)"></a><code>stream.takeWhile(predicate)</code></h2><p><code>stream.takeWhile(predicate)</code>会在谓词为真时获取该元素。</p>
<p>如-收集分割字符串中的所有数字元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; initialDigits = codePoints(str).takeWhile(s -&gt; <span class="string">"0123456789"</span>.contains(s));</span><br></pre></td></tr></table></figure>
<h2 id="stream-takeWhile-predicate-1"><a href="#stream-takeWhile-predicate-1" class="headerlink" title="stream.takeWhile(predicate)"></a><code>stream.takeWhile(predicate)</code></h2><p><code>takeWhile</code>方法正好相反，他会在条件为真的时候丢弃元素。</p>
<p>如-收集分割字符串中的所有<strong>非数字元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; initialDigits = codePoints(str).dropWhile(s -&gt; <span class="string">"0123456789"</span>.contains(s));</span><br></pre></td></tr></table></figure>
<h2 id="Stream-concat-Stream-stream1-Stream-stream1"><a href="#Stream-concat-Stream-stream1-Stream-stream1" class="headerlink" title="Stream.concat(Stream stream1, Stream stream1)"></a><code>Stream.concat(Stream stream1, Stream stream1)</code></h2><p>与字符串一样，<code>conact</code>方法可以将两个流的元素连接在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.concat(codePoints(<span class="string">"hello"</span>), codeoPints(<span class="string">"world"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="stream-disinct"><a href="#stream-disinct" class="headerlink" title="stream.disinct()"></a><code>stream.disinct()</code></h2><p><code>stream.disinct()</code>会将原流中的重复元素剔除之后，返回一个新的无重复元素的流。</p>
<p>如：剔除重复字母</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>).disinct();</span><br><span class="line"><span class="comment">//["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>
<h2 id="stream-sorted-comparator"><a href="#stream-sorted-comparator" class="headerlink" title="stream.sorted(comparator)"></a><code>stream.sorted(comparator)</code></h2><p>与其他集合排序一样，流的排序也是接受一个<code>comparator</code>。其会根据这个<code>comparator</code>，返回排序后的元素。</p>
<p>如-将最长的字符串排在前面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; longsFirst = words.stream().sorted(Comparator.comparing(String::length).reverse());</span><br></pre></td></tr></table></figure>
<h2 id="stream-peek-FunctionInterface"><a href="#stream-peek-FunctionInterface" class="headerlink" title="stream.peek(FunctionInterface)"></a><code>stream.peek(FunctionInterface)</code></h2><p><code>stream.peek(FunctionInterface)</code>的即预览这个流的元素，但是并不会将其取出。（其本质是生成一个新的流，然后获取新流中的元素，所以原来的流并无变化）然后对这个元素应用参数的函数式接口。</p>
<p>如-打印流中的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>).peek(e -&gt; System.out.println(<span class="string">"item-"</span> + e));</span><br></pre></td></tr></table></figure>
<h1 id="简单约简（注意以前方法均返回Option对象，将在下一章介绍）"><a href="#简单约简（注意以前方法均返回Option对象，将在下一章介绍）" class="headerlink" title="简单约简（注意以前方法均返回Option对象，将在下一章介绍）"></a>简单约简（注意以前方法均返回<code>Option</code>对象，将在下一章介绍）</h1><p>通过约简可以获得通过前面处理的流的指定结果。约简是一种<strong>终结操作</strong>，他们会将流约简为可以在程序中使用的非流值。</p>
<p>其有以下API：</p>
<h2 id="stream-max-comparator"><a href="#stream-max-comparator" class="headerlink" title="stream.max(comparator)"></a><code>stream.max(comparator)</code></h2><p>通过比较器返回流中最大的元素。</p>
<h2 id="stream-min-comparator"><a href="#stream-min-comparator" class="headerlink" title="stream.min(comparator)"></a><code>stream.min(comparator)</code></h2><p>通过比较器返回流中最小的元素。</p>
<h2 id="stream-findFirst"><a href="#stream-findFirst" class="headerlink" title="stream.findFirst()"></a><code>stream.findFirst()</code></h2><p>返回流中的第一个元素。如果流为空，则返回空的<code>Option</code>对象。</p>
<h2 id="stream-findAny"><a href="#stream-findAny" class="headerlink" title="stream.findAny()"></a><code>stream.findAny()</code></h2><p>返回流中的任意一个元素。如果流为空，则返回空的<code>Option</code>对象。</p>
<h2 id="stream-anyMatch-predicate"><a href="#stream-anyMatch-predicate" class="headerlink" title="stream.anyMatch(predicate)"></a><code>stream.anyMatch(predicate)</code></h2><p>流中的是否存在一个元素满足给定谓词。</p>
<h2 id="stream-allMatch-predicate"><a href="#stream-allMatch-predicate" class="headerlink" title="stream.allMatch(predicate)"></a><code>stream.allMatch(predicate)</code></h2><p>流中是否所有元素是否都满足给定谓词。</p>
<h2 id="stream-noneMatch-predicate"><a href="#stream-noneMatch-predicate" class="headerlink" title="stream.noneMatch(predicate)"></a><code>stream.noneMatch(predicate)</code></h2><p>流中是否没有元素满足给定谓词。</p>
<h1 id="Optional类型"><a href="#Optional类型" class="headerlink" title="Optional类型"></a><code>Optional</code>类型</h1><p><code>Optional&lt;T&gt;</code>对象是一种包装器对象，其可能包装了T对象或者没有包装任意对象。其被视为更安全的方式，用来替代类型T的引用。</p>
<h2 id="获取Optional值"><a href="#获取Optional值" class="headerlink" title="获取Optional值"></a>获取<code>Optional</code>值</h2><p>其有3个方法来获取<code>Opitons</code>的值。</p>
<h3 id="Opions-orElse-T-t"><a href="#Opions-orElse-T-t" class="headerlink" title="Opions.orElse(T t)"></a><code>Opions.orElse(T t)</code></h3><p>该方法会在options存在值的时候返回该值，否则返回传递的t。</p>
<h3 id="Options-orElseGet-FunctionInterface"><a href="#Options-orElseGet-FunctionInterface" class="headerlink" title="Options.orElseGet(FunctionInterface)"></a><code>Options.orElseGet(FunctionInterface)</code></h3><p>该方法会在options存在值的时候返回该值，否则返回传递的函数参数调用的结果。</p>
<h3 id="Options-orElseThrow-exceptionSupplier"><a href="#Options-orElseThrow-exceptionSupplier" class="headerlink" title="Options.orElseThrow(exceptionSupplier)"></a><code>Options.orElseThrow(exceptionSupplier)</code></h3><p>该方法会在options存在值的时候返回该值，否则抛出传递参数的异常。</p>
<h2 id="消费Optional值"><a href="#消费Optional值" class="headerlink" title="消费Optional值"></a>消费<code>Optional</code>值</h2><p>除了直接获取optional包装的值，还可以接受一个函数接口，让函数接口直接处理该函数。</p>
<h3 id="optional-ifPresent-Consumer-action"><a href="#optional-ifPresent-Consumer-action" class="headerlink" title="optional.ifPresent(Consumer action)"></a><code>optional.ifPresent(Consumer action)</code></h3><p> 该方法会在值存在的情况下，将其传递给参数函数。否则不会有任何效果。</p>
<h2 id="optional-ifPresentOrElse-Consumer-action-Runnable-emptyAction"><a href="#optional-ifPresentOrElse-Consumer-action-Runnable-emptyAction" class="headerlink" title="optional.ifPresentOrElse(Consumer action, Runnable emptyAction)"></a><code>optional.ifPresentOrElse(Consumer action, Runnable emptyAction)</code></h2><p>该方法会在值存在的情况下，将其传递给第一个参数函数；否则会调用第二个空的处理方法。</p>
<h2 id="管道化Optional值"><a href="#管道化Optional值" class="headerlink" title="管道化Optional值"></a>管道化<code>Optional</code>值</h2><p>管道化即获取optional的值，但不消费。可以使用与管道相似的方法来操作<code>Optional</code>对象，同时返回一个新的<code>0ptional</code>对象。此时可以将<code>Optional</code>对象看为一个长度为0或1的流。</p>
<p>其有以下3个API：</p>
<h3 id="optional-map-FunctionInterface"><a href="#optional-map-FunctionInterface" class="headerlink" title="optional.map(FunctionInterface)"></a><code>optional.map(FunctionInterface)</code></h3><p>通过参数函数处理原<code>optional</code>对象的值。然后返回新的<code>Oprtional</code>对象。</p>
<h3 id="optional-filter-predicate"><a href="#optional-filter-predicate" class="headerlink" title="optional.filter(predicate)"></a><code>optional.filter(predicate)</code></h3><p>若原<code>Optional</code>的值满足给定谓词，就返回一个新的一样值的<code>Optional</code>对象，否则，返回一个空的<code>Optional</code>对象。</p>
<h3 id="Optional-or-supplier"><a href="#Optional-or-supplier" class="headerlink" title="Optional.or(supplier)"></a><code>Optional.or(supplier)</code></h3><p>如果当前<code>Optional</code>对象不为空，则产生当前的<code>Optional</code>，否则由<code>supplier</code>产生一个<code>Optional</code>。</p>
<h2 id="用flatMap构建Optional值的函数"><a href="#用flatMap构建Optional值的函数" class="headerlink" title="用flatMap构建Optional值的函数"></a>用<code>flatMap</code>构建<code>Optional</code>值的函数</h2><p><code>flatMap</code>会在<code>Optional</code>包装部位空时，产生将<code>mapper</code>应用于当前<code>Optional</code>值所产生的结果，或者在当前<code>Optional</code>为空时，返回一个空<code>Optional</code>。</p>
<p>由于<code>Opional&lt;T&gt;</code>是一个包装类型，所以无法直接调用T的相关方法。而可以使用<code>flatMap</code>来直接获取到包装类内部的值。并且调用其方法，然后返回。</p>
<p>如：</p>
<p>类型S有一个f方法来产生一个<code>Optional&lt;T&gt;</code>对象。</p>
<p>类型T有一个g方法来产生一个<code>Optional&lt;U&gt;</code>对象。</p>
<p>为我们无法使用<code>s.f().g()</code>来获得<code>Optional&lt;U&gt;</code>对象。</p>
<p>但是我们可以使用下面的方式来获取该对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;U&gt; res = s.f().flatMap(T::g);</span><br></pre></td></tr></table></figure>
<h2 id="将Optional转换为流"><a href="#将Optional转换为流" class="headerlink" title="将Optional转换为流"></a>将<code>Optional</code>转换为流</h2><p>通过<code>optional.stream()</code>可以将<code>Optional</code>值转变为一个长度为0或1的流。</p>
<h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><ul>
<li><code>Optional</code>类型的便利永远都不应该为null；</li>
<li>不要使用<code>Optional</code>类型的域。因为其代价是额外多出来一个对象。在累的内部，使用null表示缺失的域更易于操作。</li>
<li>不要在集合中放置<code>Optional</code>对象，并且不要将他们作为map的key。应该直接收集其中的值。</li>
</ul>
<h1 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h1><p>当处理完流之后，通常需要查看其结果。则可以通过以下方法来查看内部元素。</p>
<h2 id="stream-iterator"><a href="#stream-iterator" class="headerlink" title="stream.iterator"></a><code>stream.iterator</code></h2><p>可以使用<code>stream.iterator</code>来生成一个迭代器，则可以按照普通的迭代器方法来查看内部元素。</p>
<h2 id="stream-forEach-Comsumer-action"><a href="#stream-forEach-Comsumer-action" class="headerlink" title="stream.forEach(Comsumer action)"></a><code>stream.forEach(Comsumer action)</code></h2><p>可以通过<code>stream.forEach</code>来直接遍历流中的元素。</p>
<h2 id="stream-forEachOrdered-Comsumer-action"><a href="#stream-forEachOrdered-Comsumer-action" class="headerlink" title="stream.forEachOrdered(Comsumer action)"></a><code>stream.forEachOrdered(Comsumer action)</code></h2><p>使用该方法遍历时，此时会完全按照流中的顺序。但会丧失并行处理的部分甚至全部优势。</p>
<h2 id="stream-toArray-Constructor"><a href="#stream-toArray-Constructor" class="headerlink" title="stream.toArray(Constructor)"></a><code>stream.toArray(Constructor)</code></h2><p>调用此方法会返回一个数组，如果不传递参数，则返回<code>Object[]</code>，需要强转。其参数为对应类型的构造函数，此时可以返回对应类型的数组。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Object[] objArr = s.toArray();</span><br><span class="line">Integer[] intArr = s.toArray(Ingeter::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<h2 id="stream-toList"><a href="#stream-toList" class="headerlink" title="stream.toList()"></a><code>stream.toList()</code></h2><p>此方法会返回一个<code>List</code>用于查看内容。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; strings = stream1.toList();</span><br></pre></td></tr></table></figure>
<h2 id="stream-collect-Collector-collector"><a href="#stream-collect-Collector-collector" class="headerlink" title="stream.collect(Collector collector)"></a><code>stream.collect(Collector collector)</code></h2><p>可以通过该方法将流中的元素收集到指定的集合中。其中<code>Collector collector</code>一般是通过<code>Collectors.toXXX()</code>或者<code>Collectors.toCollection(XXX:new)</code>来获取。</p>
<p>如：</p>
<p>1-收集到List（与上面的API作用相同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = stream.collect(Collections.toList());</span><br></pre></td></tr></table></figure>
<p>2-收集到Set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; res = stream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>
<p>3-收集到指定的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; res = stream.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
<h3 id="收集到字符串"><a href="#收集到字符串" class="headerlink" title="收集到字符串"></a>收集到字符串</h3><p>还可以通过<code>stream.collect</code>收集到一个字符串。关键是<code>collector</code>必须是一个<code>Collectors.join()</code>产生的。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String res = stream.collect(Collectors.join());			<span class="comment">//不加间隔符</span></span><br><span class="line">String res = stream.collect(Collectors.join(<span class="string">","</span>));			<span class="comment">//间隔符为,</span></span><br></pre></td></tr></table></figure>
<p>如果流中除字符串外还包含其他对象，那么我们需要先将其转化为字符串。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String res = stream.map(Object::toString).collect(Collectors.join(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure>
<h2 id="收集到映射表"><a href="#收集到映射表" class="headerlink" title="收集到映射表"></a>收集到映射表</h2><p>假设流中的对象是一个<code>Person</code>对象，而我们要将其收集到映射表中，<code>key</code>为<code>Person.id</code>；<code>value</code>为<code>Person.name</code>。</p>
<p>则可以使用<code>Collectors.toMap()</code>方法。该方法接受两个参数，用来产生映射表的键和值。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; idToName = people.collect(Collectors.toMap(Person::getId, Person::getName));</span><br></pre></td></tr></table></figure>
<p>如果需要获取对象本身，则使用<code>Funciton.identity()</code>。即返回的是流中的类型元素T。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; idToPerson = people.collect(Collectors,toMap(Person::getId, Function.identity));</span><br></pre></td></tr></table></figure>
<h3 id="嵌套集合"><a href="#嵌套集合" class="headerlink" title="嵌套集合"></a>嵌套集合</h3><p>假如要收集每个国家支持的语言。则我们需要一个<code>Map&lt;String, Set&lt;String&gt;&gt;</code>，此时我们由该如何直接从流中获取呢。</p>
<p>此时的<code>Collectors.map</code>需要3个参数：</p>
<ul>
<li>key值。</li>
<li>指定value的值。</li>
<li>组合set的函数</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryLang = locales.collect(</span><br><span class="line">	Collecotors.toMap(</span><br><span class="line">    	locale::getDisplayCountry,</span><br><span class="line">        l -&gt; Collectors.singleton(l.getDisplayLanguage()),</span><br><span class="line">        (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> union = <span class="keyword">new</span> HasSet&lt;String&gt;(a);</span><br><span class="line">            union.addAll(b);</span><br><span class="line">            <span class="keyword">return</span> union;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果需要使用<code>TreeMap</code>，则需要将其构造器<code>TreeMap::new</code>指定为第4个参数。</p>
<h1 id="组群和分组"><a href="#组群和分组" class="headerlink" title="组群和分组"></a>组群和分组</h1><p>上面嵌套集合的方式可以使用组群和分区更简洁的解决。</p>
<h2 id="Collectors-groupingBy"><a href="#Collectors-groupingBy" class="headerlink" title="Collectors.groupingBy()"></a><code>Collectors.groupingBy()</code></h2><p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Locale&gt;&gt; countryToLocales = locales.collect(</span><br><span class="line">	Collectors.groupingBy(Locale::getCountry)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中函数<code>Locale::getCountry</code>是组群的分类函数。</p>
<h2 id="Collectors-partitioningBy"><a href="#Collectors-partitioningBy" class="headerlink" title="Collectors.partitioningBy()"></a><code>Collectors.partitioningBy()</code></h2><p>当分类函数是一个断言函数（即返回Boolean值的函数），流的元素可能分为两个列表。该函数返回true的元素和其他元素。</p>
<p>如：将<code>locale</code>分成了使用英语和使用其他所有语言的两类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Locale&gt;&gt; englishAndOther = locales.collect(</span><br><span class="line">	Collectors.partitioningBy(l -&gt; l.getLanguage().equals(<span class="string">"en"</span>))</span><br><span class="line">);</span><br><span class="line">List&lt;Locale&gt; englishLocales = englishAndOther.get(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h1 id="下游收集器"><a href="#下游收集器" class="headerlink" title="下游收集器"></a>下游收集器</h1><p><code>groupingBy</code>方法会产生一个映射表，其每个值都是一个列表。如果想要以某种方式来处理这些列表，则需要下游收集器。</p>
<h2 id="Collectors-counting"><a href="#Collectors-counting" class="headerlink" title="Collectors.counting()"></a><code>Collectors.counting()</code></h2><p><code>Collectors.counting()</code>会产生收集到的元素的个数。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, lOng&gt; countryToLocaleCounts = locales.collect(groupBy(Locale::getCountry, Collectors.counting()));</span><br></pre></td></tr></table></figure>
<p>可以对每个国家有多少个local进行计数。</p>
<h2 id="Collectors-summing-Int-Long-Double"><a href="#Collectors-summing-Int-Long-Double" class="headerlink" title="Collectors.summing(Int|Long|Double)()"></a><code>Collectors.summing(Int|Long|Double)()</code></h2><p>上面的方法会返回收集到的数据的和。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; stateToPopulation = cities.collect(</span><br><span class="line">	groupingBy(City::getState, Collectors.summingInt(city::getPopulation));</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>可以计算城市流中每个州的人口总和。</p>
<h2 id="Collectors-maxBy-amp-amp-Collectors-minBy"><a href="#Collectors-maxBy-amp-amp-Collectors-minBy" class="headerlink" title="Collectors.maxBy&amp;&amp;Collectors.minBy"></a><code>Collectors.maxBy</code>&amp;&amp;<code>Collectors.minBy</code></h2><p>以上两个方法会接受一个比较器，并分别产生下游元素中的最大值和最小值。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Optional&lt;City&gt;&gt; stateToLargestCity =  cities.collect(</span><br><span class="line">	groupingBy(</span><br><span class="line">        City::getState,</span><br><span class="line">    	Collectors.maxBy(Comparator.comparing(City::getPopulation))</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Collectors-collectAndThen"><a href="#Collectors-collectAndThen" class="headerlink" title="Collectors.collectAndThen"></a><code>Collectors.collectAndThen</code></h2><p>该收集器会在收集器后面添加一个最终处理步骤。例如，我们想要知道有多少种不同的结果，那么就可以将他们收集到一个集合中，然后计算其尺寸：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; stringCountByStartingLetter = strings.collect(</span><br><span class="line">	groupingBy(s -&gt;  s.charAt(<span class="number">0</span>),</span><br><span class="line">              Collectors.collectAndThen(toSet(), Set::size)</span><br><span class="line">              )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Collectors-mapping"><a href="#Collectors-mapping" class="headerlink" title="Collectors.mapping"></a><code>Collectors.mapping</code></h2><p><code>Collectors.mapping</code>与<code>Collectors.collectAndThen</code>相反，他会将参数函数应用于收集到的每个元素，并将其结果传递给下游收集器。</p>
<p>如：按照首字母进行收集，咋子每个分组内部，计算字符串的长度并将其传递给下游收集器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, Set&lt;Integer&gt;&gt; stringLengthByStartingLetter = strings.collect(</span><br><span class="line">	groupingBy(</span><br><span class="line">    	s -&gt; s.charAt(<span class="number">0</span>),</span><br><span class="line">        Collectors.mapping(String::length, toSet())</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Collectors-flatMap"><a href="#Collectors-flatMap" class="headerlink" title="Collectors.flatMap"></a><code>Collectors.flatMap</code></h2><p>此处作用也是一致，可以将每个组结果返回的结果进行铺平。</p>
<h2 id="Collectors-filtering"><a href="#Collectors-filtering" class="headerlink" title="Collectors.filtering"></a><code>Collectors.filtering</code></h2><p><code>Collectors.filtering</code>会将过滤器应用到每个组上的元素中，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;City&gt;&gt; largeCitiesByState = cities.collect(</span><br><span class="line">	groupingBy(City::getState,</span><br><span class="line">              filtering(c -&gt; c.getPopulation() &gt; <span class="number">5000000</span>),</span><br><span class="line">               toSet()</span><br><span class="line">              )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="TIPS-1"><a href="#TIPS-1" class="headerlink" title="TIPS"></a>TIPS</h2><p>将收集器组合起来是一种很强大的方式，但是它也可能会导致产生非常复杂的表达式。最佳用法是与<code>groupingBy</code>和<code>partitioningBy</code>一起处理下游的映射表中的值。否则，应该直接在流上应用诸如<code>map</code>、<code>reduce</code>、<code>count</code>、<code>max</code>和<code>min</code>这样的方式。</p>
<h1 id="约简操作"><a href="#约简操作" class="headerlink" title="约简操作"></a>约简操作</h1><p><code>reduce</code>方法是一种用于从流中计算某个值的通用机制。其有3个重载。</p>
<h2 id="Optional-lt-T-gt-reduce-BinaryOperator-lt-T-gt-accumulator"><a href="#Optional-lt-T-gt-reduce-BinaryOperator-lt-T-gt-accumulator" class="headerlink" title="Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);"></a><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</code></h2><p>其接受一个二元表达式，其第一个操作符为上一次调用该表达式的返回值（首次为第一个元素）。</p>
<p>如：对一个流求和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values = ...;</span><br><span class="line">Options&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y);		<span class="comment">//v1 + v2 + v3+...</span></span><br><span class="line">Options&lt;Integer&gt; sum = values.reduce(Intger::sum);			<span class="comment">//效果一样</span></span><br></pre></td></tr></table></figure>
<h2 id="T-reduce-T-identity-BinaryOperator-lt-T-gt-accumulator"><a href="#T-reduce-T-identity-BinaryOperator-lt-T-gt-accumulator" class="headerlink" title="T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);"></a><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</code></h2><p>与上面用法相同，只是首次的元素会被替换为<code>identity</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values = ...;</span><br><span class="line">Options&lt;Integer&gt; sum = values.reduce(<span class="number">1</span>, (x, y) -&gt; x + y);		<span class="comment">//1 + v1 + v2 + v3 +...</span></span><br></pre></td></tr></table></figure>
<h2 id="lt-U-gt-U-reduce-U-identity-BiFunction-lt-U-super-T-U-gt-accumulator-BinaryOperator-lt-U-gt-combiner"><a href="#lt-U-gt-U-reduce-U-identity-BiFunction-lt-U-super-T-U-gt-accumulator-BinaryOperator-lt-U-gt-combiner" class="headerlink" title="&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);"></a><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</code></h2><p>这种形式用于当我们需要统计流中元素的某个属性进行约简操作时。其中<code>BiFunction</code>用于累加操作，而<code>accumulator</code>用于合并并行处理的结果。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = words.reduce(<span class="number">0</span>, </span><br><span class="line">                       (total, word) -&gt; total + word.length, </span><br><span class="line">                       (total1, total2) -&gt; total1 + total2</span><br><span class="line">                      );</span><br></pre></td></tr></table></figure>
<h1 id="基本类型流"><a href="#基本类型流" class="headerlink" title="基本类型流"></a>基本类型流</h1><p>与基本类型的包装类相似，流对于基本类型也有对应的基本类型流：</p>
<ul>
<li><code>IntStream</code>：Integer, Short, Char, Byte, Boolean</li>
<li><code>LongStream</code>：Long</li>
<li><code>DoubleStream</code>：Double, Float</li>
</ul>
<p>与对象流一样，我们还可以使用静态的<code>generate</code>和<code>iterate</code>方法。</p>
<p>此外，<code>IntStream</code>和<code>LongStream</code>有静态方法<code>range</code>和<code>rangeClosed</code>，可以生成步长为1的整数范围（后者包含上限）。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream zeroToNinetyNine = IntStream.range(<span class="number">0</span>, <span class="number">100</span>);	<span class="comment">//0-99</span></span><br><span class="line">IntStream zeroToHundred = IntStream.range(<span class="number">0</span>, <span class="number">100</span>);	<span class="comment">//0-100</span></span><br></pre></td></tr></table></figure>
<h2 id="基本流与对象流的转化"><a href="#基本流与对象流的转化" class="headerlink" title="基本流与对象流的转化"></a>基本流与对象流的转化</h2><h3 id="对象流转基本流"><a href="#对象流转基本流" class="headerlink" title="对象流转基本流"></a>对象流转基本流</h3><p>可以使用<code>stream</code>的<code>mapToInt</code>，<code>mapToLong</code>，<code>mapToDouble</code>来将其转换为基本流，可以将原流中的属性转化为新的基本流。</p>
<p>如：将单词的长度转化为新的<code>IntStream</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = ...;</span><br><span class="line">IntStream lengths = words.mapToInt(String::length);</span><br></pre></td></tr></table></figure>
<h3 id="基本流转对象流"><a href="#基本流转对象流" class="headerlink" title="基本流转对象流"></a>基本流转对象流</h3><p>可以使用<code>boxed</code>方法转化为对象流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integers = IntStream.range(<span class="number">0</span>, <span class="number">100</span>).boxed();</span><br></pre></td></tr></table></figure>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><code>toArray</code>方法会返回对应的基本类型数组。（注意：虽然上面提到<code>IntStream</code>可以存储<code>Integer, Short, Char, Byte, Boolean</code>，但是仍然返回的是<code>intt[]</code>）。</li>
<li>产生可选结果的方法会返回一个<code>OptionalInt</code>、<code>OptionalLong</code>或<code>OptionalDouble</code>。这些方法与<code>Optional</code>相似，但是具有<code>getAsInt</code>，<code>getAsLong</code>、<code>getAsDouble</code>方法，而不是<code>get</code>方法。</li>
<li>具有分别返回总和、平均值、最大值和最小值的sum、max和min方法。对象流没有定义这些方法。</li>
<li><code>summaryStatistics</code>方法会产生一个类型为<code>IntSummaryStatistics</code>、<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code>的对象，他们可以同hi报告流的总和、数量、平均值、最大值和最小值。</li>
</ul>
<h1 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h1><p>流时并行处理块操作变的容易。整个过程几乎是自动的。</p>
<h2 id="创建并行流"><a href="#创建并行流" class="headerlink" title="创建并行流"></a>创建并行流</h2><h3 id="Collection-parallelStream"><a href="#Collection-parallelStream" class="headerlink" title="Collection.parallelStream()"></a><code>Collection.parallelStream()</code></h3><p>可以使用<code>Collection.parallelStream()</code>方法从任何集合中获取一个并行流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; parallelWords = words.parallelStream();</span><br></pre></td></tr></table></figure>
<h3 id="stream-parallel"><a href="#stream-parallel" class="headerlink" title="stream.parallel()"></a><code>stream.parallel()</code></h3><p>对于现有的流，可以通过<code>stream.parallel()</code>来获取一个并行流。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; parallelWords = Stream.of(wordArray).parallel();</span><br></pre></td></tr></table></figure>
<h2 id="相关注意点"><a href="#相关注意点" class="headerlink" title="相关注意点"></a>相关注意点</h2><p>只要在终结方法执行时流处于并行模式，所有的中间流操作都将被并行化。</p>
<p>只要是并行就会存在竞态的问题。</p>
<p>如下面的例子就是有问题的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortWords = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br><span class="line">words.parallelStream().forEach(</span><br><span class="line">	s -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">12</span>) shortWords[s.length()]++;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>因为<code>shortWords</code>会被传递到多个线程中，这就会存在竞态的问题，所以不能得到预期的结果。</p>
<p>排序并不排斥高效的并行处理。例如，当计算<code>Stream.map(fun)</code>时，流可以被划分为n部分，它们会被并行的处理。然后结果会按照顺序重新组装起来。</p>
<h3 id="stream-unordered"><a href="#stream-unordered" class="headerlink" title="stream.unordered"></a><code>stream.unordered</code></h3><p>当然，如果不需要排序的需求，并行操作的性能将会得到很大的提升。此时可以通过<code>stream.unordered</code>方法来标记对顺序没有要求。</p>
<p>例如<code>stream.instinct</code>就会从中获得更高效率，原因是不用考虑哪一个相同的元素将会被保留。</p>
<h2 id="TIPS-2"><a href="#TIPS-2" class="headerlink" title="TIPS"></a>TIPS</h2><ul>
<li>并行化会导致大量的开销，只有面对非常大的数据集才划算。</li>
<li>只有在底层的数据源可以被有效地分割为多个部分时，将流并行化才有意义。</li>
<li>并行流使用的线程池可能会因诸如文件I/O或者网络访问这样的操作被阻塞而饿死。</li>
</ul>
<p>只有面对海量的内存数据和运算密集处理，并行流才会工作最佳。</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>


<script src="/js/vdonate.js"></script>

<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'http://39.106.203.62:7777/mm_facetoface_collect_qrcode_1532532148519.png',
  alipayImage: 'http://39.106.203.62:7777/1532532158487.jpg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>Post author:  </strong>Michael Wang</a>
          </li>
          <li class="post-copyright-link">
          <strong>Post link:  </strong>
          <a href="/2022/02/14/java核心技术-II-1-Java8的流库/" target="_blank" title="java核心技术-II-1-Java8的流库">http://yoursite.com/2022/02/14/java核心技术-II-1-Java8的流库/</a>
          </li>
          <li class="post-copyright-license">
            <strong>Copyright Notice:   </strong>
            All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            unless stating additionally.
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/02/16/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-6-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          java核心技术-II-6-日期和时间API
        
      </div>
    </a>
  
  
    <a href="/2022/02/14/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-II-2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java核心技术-II-2-输入与输出</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代与流"><span class="nav-number">1.</span> <span class="nav-text">迭代与流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代"><span class="nav-number">1.1.</span> <span class="nav-text">迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流"><span class="nav-number">1.2.</span> <span class="nav-text">流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流与集合的差异"><span class="nav-number">1.2.1.</span> <span class="nav-text">流与集合的差异</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流的创建"><span class="nav-number">2.</span> <span class="nav-text">流的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从集合Collections接口创建流"><span class="nav-number">2.1.</span> <span class="nav-text">从集合Collections接口创建流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从数组生成Stream"><span class="nav-number">2.2.</span> <span class="nav-text">从数组生成Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用所有元素生成Stream"><span class="nav-number">2.2.1.</span> <span class="nav-text">用所有元素生成Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用部分数组元素（连续）生成Stream"><span class="nav-number">2.2.2.</span> <span class="nav-text">用部分数组元素（连续）生成Stream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接从基本元素生成Stream"><span class="nav-number">2.3.</span> <span class="nav-text">直接从基本元素生成Stream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个空流"><span class="nav-number">2.4.</span> <span class="nav-text">创建一个空流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个无限流"><span class="nav-number">2.5.</span> <span class="nav-text">创建一个无限流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个无线的序列流"><span class="nav-number">2.6.</span> <span class="nav-text">创建一个无线的序列流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个长度仅为0或1的流"><span class="nav-number">2.7.</span> <span class="nav-text">创建一个长度仅为0或1的流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意"><span class="nav-number">2.8.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作"><span class="nav-number">3.</span> <span class="nav-text">操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#filter-Predicate-lt-T-gt"><span class="nav-number">3.1.</span> <span class="nav-text">filter(Predicate&lt;T&gt;)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-FunctionInterface"><span class="nav-number">3.2.</span> <span class="nav-text">map(FunctionInterface)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flatMap-FunctionInterface"><span class="nav-number">3.3.</span> <span class="nav-text">flatMap(FunctionInterface)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-limit-n"><span class="nav-number">3.4.</span> <span class="nav-text">stream.limit(n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-skip-n"><span class="nav-number">3.5.</span> <span class="nav-text">stream.skip(n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-takeWhile-predicate"><span class="nav-number">3.6.</span> <span class="nav-text">stream.takeWhile(predicate)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-takeWhile-predicate-1"><span class="nav-number">3.7.</span> <span class="nav-text">stream.takeWhile(predicate)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream-concat-Stream-stream1-Stream-stream1"><span class="nav-number">3.8.</span> <span class="nav-text">Stream.concat(Stream stream1, Stream stream1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-disinct"><span class="nav-number">3.9.</span> <span class="nav-text">stream.disinct()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-sorted-comparator"><span class="nav-number">3.10.</span> <span class="nav-text">stream.sorted(comparator)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-peek-FunctionInterface"><span class="nav-number">3.11.</span> <span class="nav-text">stream.peek(FunctionInterface)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#简单约简（注意以前方法均返回Option对象，将在下一章介绍）"><span class="nav-number">4.</span> <span class="nav-text">简单约简（注意以前方法均返回Option对象，将在下一章介绍）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-max-comparator"><span class="nav-number">4.1.</span> <span class="nav-text">stream.max(comparator)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-min-comparator"><span class="nav-number">4.2.</span> <span class="nav-text">stream.min(comparator)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-findFirst"><span class="nav-number">4.3.</span> <span class="nav-text">stream.findFirst()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-findAny"><span class="nav-number">4.4.</span> <span class="nav-text">stream.findAny()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-anyMatch-predicate"><span class="nav-number">4.5.</span> <span class="nav-text">stream.anyMatch(predicate)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-allMatch-predicate"><span class="nav-number">4.6.</span> <span class="nav-text">stream.allMatch(predicate)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-noneMatch-predicate"><span class="nav-number">4.7.</span> <span class="nav-text">stream.noneMatch(predicate)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Optional类型"><span class="nav-number">5.</span> <span class="nav-text">Optional类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取Optional值"><span class="nav-number">5.1.</span> <span class="nav-text">获取Optional值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Opions-orElse-T-t"><span class="nav-number">5.1.1.</span> <span class="nav-text">Opions.orElse(T t)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Options-orElseGet-FunctionInterface"><span class="nav-number">5.1.2.</span> <span class="nav-text">Options.orElseGet(FunctionInterface)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Options-orElseThrow-exceptionSupplier"><span class="nav-number">5.1.3.</span> <span class="nav-text">Options.orElseThrow(exceptionSupplier)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消费Optional值"><span class="nav-number">5.2.</span> <span class="nav-text">消费Optional值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#optional-ifPresent-Consumer-action"><span class="nav-number">5.2.1.</span> <span class="nav-text">optional.ifPresent(Consumer action)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#optional-ifPresentOrElse-Consumer-action-Runnable-emptyAction"><span class="nav-number">5.3.</span> <span class="nav-text">optional.ifPresentOrElse(Consumer action, Runnable emptyAction)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道化Optional值"><span class="nav-number">5.4.</span> <span class="nav-text">管道化Optional值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#optional-map-FunctionInterface"><span class="nav-number">5.4.1.</span> <span class="nav-text">optional.map(FunctionInterface)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#optional-filter-predicate"><span class="nav-number">5.4.2.</span> <span class="nav-text">optional.filter(predicate)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional-or-supplier"><span class="nav-number">5.4.3.</span> <span class="nav-text">Optional.or(supplier)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用flatMap构建Optional值的函数"><span class="nav-number">5.5.</span> <span class="nav-text">用flatMap构建Optional值的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将Optional转换为流"><span class="nav-number">5.6.</span> <span class="nav-text">将Optional转换为流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIPS"><span class="nav-number">5.7.</span> <span class="nav-text">TIPS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#收集结果"><span class="nav-number">6.</span> <span class="nav-text">收集结果</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-iterator"><span class="nav-number">6.1.</span> <span class="nav-text">stream.iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-forEach-Comsumer-action"><span class="nav-number">6.2.</span> <span class="nav-text">stream.forEach(Comsumer action)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-forEachOrdered-Comsumer-action"><span class="nav-number">6.3.</span> <span class="nav-text">stream.forEachOrdered(Comsumer action)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-toArray-Constructor"><span class="nav-number">6.4.</span> <span class="nav-text">stream.toArray(Constructor)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-toList"><span class="nav-number">6.5.</span> <span class="nav-text">stream.toList()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-collect-Collector-collector"><span class="nav-number">6.6.</span> <span class="nav-text">stream.collect(Collector collector)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#收集到字符串"><span class="nav-number">6.6.1.</span> <span class="nav-text">收集到字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#收集到映射表"><span class="nav-number">6.7.</span> <span class="nav-text">收集到映射表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套集合"><span class="nav-number">6.7.1.</span> <span class="nav-text">嵌套集合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组群和分组"><span class="nav-number">7.</span> <span class="nav-text">组群和分组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-groupingBy"><span class="nav-number">7.1.</span> <span class="nav-text">Collectors.groupingBy()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-partitioningBy"><span class="nav-number">7.2.</span> <span class="nav-text">Collectors.partitioningBy()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#下游收集器"><span class="nav-number">8.</span> <span class="nav-text">下游收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-counting"><span class="nav-number">8.1.</span> <span class="nav-text">Collectors.counting()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-summing-Int-Long-Double"><span class="nav-number">8.2.</span> <span class="nav-text">Collectors.summing(Int|Long|Double)()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-maxBy-amp-amp-Collectors-minBy"><span class="nav-number">8.3.</span> <span class="nav-text">Collectors.maxBy&amp;&amp;Collectors.minBy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-collectAndThen"><span class="nav-number">8.4.</span> <span class="nav-text">Collectors.collectAndThen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-mapping"><span class="nav-number">8.5.</span> <span class="nav-text">Collectors.mapping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-flatMap"><span class="nav-number">8.6.</span> <span class="nav-text">Collectors.flatMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-filtering"><span class="nav-number">8.7.</span> <span class="nav-text">Collectors.filtering</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIPS-1"><span class="nav-number">8.8.</span> <span class="nav-text">TIPS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#约简操作"><span class="nav-number">9.</span> <span class="nav-text">约简操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional-lt-T-gt-reduce-BinaryOperator-lt-T-gt-accumulator"><span class="nav-number">9.1.</span> <span class="nav-text">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#T-reduce-T-identity-BinaryOperator-lt-T-gt-accumulator"><span class="nav-number">9.2.</span> <span class="nav-text">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lt-U-gt-U-reduce-U-identity-BiFunction-lt-U-super-T-U-gt-accumulator-BinaryOperator-lt-U-gt-combiner"><span class="nav-number">9.3.</span> <span class="nav-text">&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本类型流"><span class="nav-number">10.</span> <span class="nav-text">基本类型流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本流与对象流的转化"><span class="nav-number">10.1.</span> <span class="nav-text">基本流与对象流的转化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象流转基本流"><span class="nav-number">10.1.1.</span> <span class="nav-text">对象流转基本流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本流转对象流"><span class="nav-number">10.1.2.</span> <span class="nav-text">基本流转对象流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特点"><span class="nav-number">10.2.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并行流"><span class="nav-number">11.</span> <span class="nav-text">并行流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建并行流"><span class="nav-number">11.1.</span> <span class="nav-text">创建并行流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-parallelStream"><span class="nav-number">11.1.1.</span> <span class="nav-text">Collection.parallelStream()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stream-parallel"><span class="nav-number">11.1.2.</span> <span class="nav-text">stream.parallel()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关注意点"><span class="nav-number">11.2.</span> <span class="nav-text">相关注意点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stream-unordered"><span class="nav-number">11.2.1.</span> <span class="nav-text">stream.unordered</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIPS-2"><span class="nav-number">11.3.</span> <span class="nav-text">TIPS</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2022 My Wonderland All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/scripts.js"></script>





  
<script src="/js/dialog.js"></script>










	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            My Wonderland
          </div>
          <div class="panel-body">
            Copyright © 2022 Michael Wang All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <a id="mwSearch"><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>