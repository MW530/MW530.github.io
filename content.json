{"meta":{"title":"My Wonderland","subtitle":"This is it!","description":"Something is going happen if you try to fight for it!","author":"Michael Wang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2018-07-19T16:20:13.000Z","updated":"2018-07-20T16:11:53.116Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"简介Michael Wang 目前在学习前端知识，一只想变成大佬的菜鸡。赏一首诗盖说夫妻之缘，伉俪情深，恩深义重。论谈共被之因，幽怀合卺之欢。 凡为夫妻之因，前世三生结缘，始配今生夫妇。夫妻相对，恰似鸳鸯，双飞并膝，花颜共坐；两德之美，恩爱极重，二体一心。 三载结缘，则夫妇相和；三年有怨，则来仇隙。若结缘不合，想是前世怨家。反目生怨，故来相对。妻则一言数口，夫则反目生嫌。似猫鼠相憎，如狼羊一处。 既以二心不同，难归一意，快会及诸亲，以求一别，物色书之，各还本道。愿妻娘子相离之后，重梳蝉鬓，美扫娥眉，巧逞窈窕之姿，选聘高官之主，弄影庭前，美效琴瑟合韵之态。 解怨释结，更莫相憎；一别两宽，各生欢喜。三年衣粮，便献柔仪。伏愿娘子千秋万岁。 听一首歌"},{"title":"目录","date":"2018-07-19T16:19:34.000Z","updated":"2018-07-19T16:23:27.276Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-19T16:19:53.000Z","updated":"2018-07-19T16:22:20.068Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于java的脚本语言hair的开发思路3-执行","slug":"基于java的脚本语言hair的开发思路3-执行","date":"2021-09-30T13:15:30.000Z","updated":"2021-10-09T13:01:15.949Z","comments":true,"path":"2021/09/30/基于java的脚本语言hair的开发思路3-执行/","link":"","permalink":"http://yoursite.com/2021/09/30/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80hair%E7%9A%84%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF3-%E6%89%A7%E8%A1%8C/","excerpt":"","text":"执行经过上面的操作，我们已经根据程序生成了一个抽象语法树。此时我们需要让程序达到其预期的结果。即需要我们翻译为Java可执行的代码。实际上执行的过程很简单，既然我们已经生成了抽象语法树。我们只需要将每个节点的结果得到，最后得到根节点的结果，即为该程序的结果。所以这实际上也是一个树的遍历工作，从左边的叶节点开始遍历。依次得到上层的非叶节点的值。 针对不同的节点，我们的实现方法不同，但是我们都将其定义为eval方法，意为evaluate，即得到结果。 下面简单介绍几种类型的节点的实现： 实现基本节点针对一些基本节点，比如 二元运算： 12345678910111213141516/* * For a binary operation, the operation symbol will be considered to process different operation. */public Object eval(Environment env) &#123; String op = operator(); if (\"=\".equals(op)) &#123; ASTree rightTree = right(); Object rightVal = rightTree.eval(env); return computeAssign(env, rightVal); &#125; else &#123; Object left = left().eval(env); Object right = right().eval(env); return computeOp(left, op, right); &#125;&#125; if语句： 123456789101112131415/* * For a if statement, condition will eval first to decide whether the if block be executed. */public Object eval(Environment env) &#123; Object c = condition().eval(env); if (c instanceof Integer &amp;&amp; ((Integer)c).intValue() != FALSE) return thenBlock().eval(env); else &#123; ASTree b = elseBlock(); if (b == null) return 0; else return b.eval(env); &#125;&#125; 实际上这里就是递归的执行元素的eavl方法，实际上就是遍历ast的过程。 注意这里就是脚本语言与编译语言的区别，脚本语言会直接遍历ast执行。而预编译语言会先对源码进行编译，生成可执行程序或中间二进制代码，比如C语言编译会生成对应平台的可执行程序。java会通过Java虚拟机产生javac二进制文件，以此来解决跨平台的问题。 正是因为这个预编译的过程中，会对源码进行一定的分析和运算，将可运算先运算出来，使得预编译程序的效率会远高于脚本语言。","categories":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/categories/hair/"}],"tags":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/tags/hair/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://yoursite.com/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"},{"name":"语法分析","slug":"语法分析","permalink":"http://yoursite.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"基于java的脚本语言hair的开发思路2-语法分析","slug":"基于java的脚本语言hair的开发思路2-语法分析","date":"2021-09-26T07:42:25.000Z","updated":"2021-10-09T13:01:32.199Z","comments":true,"path":"2021/09/26/基于java的脚本语言hair的开发思路2-语法分析/","link":"","permalink":"http://yoursite.com/2021/09/26/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80hair%E7%9A%84%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"","text":"语法分析在经过上一步的词法分析之后，我们已经将程序字符串分以上三种token。要想让程序运行起来，我们还必须将其构造为抽象语法树(Abstract Syntax Tree)。 它是用来表示程序结构的树形结构。其中树的节点也分为不同的类型。 具体的树节点类型后面介绍。 在我们得到AST之后，想要得到结果，就很简单了：我们只需要自底而上活得每个树节点的对应的值。其根节点的值就是最终的程序结果。 所以问题的关键是如何通过token队列来获得AST。这里我们首先引入BNF的概念。 BNFBNF即巴科斯范式，其是一种描述语法的一种形式体系，是一种典型的元语言（相当于一种伪代码来描述语法规则）。其规则如下： 字符本身： “xxx” - 表示xxx字符本身。如：”function”表示匹配function字符。 [xxx]表示xxx模式出现0次或1次。 {xxx}表示xxx模式至少出现0次。 (xxx)表示括号内的模式为一个整体。 xxx|yyy表示匹配xxx或yyy模式。 后来BNF也做了很多扩展，我们这里仅使用以上5种模式。 整个匹配过程中包含两个过程，即： 创建匹配模式实例。 使用该模式匹配token串。 下面分别介绍： 创建匹配模式对于一个匹配模式，就是一个Parser对象。其有两个成员变量： elements：用于存放模式匹配的子模式，即子树模式结构。 factory：用于创建该模式对应的树节点。 接下来我们看看具体的创建代码： 其调用栈如下顺序： 第一步：通过rule()最外层API创建模式，其有两个重载，分别对应是否传入匹配到的树节点类型。 1234567891011/* * Create an empty Parser without a parameter. */public static Parser rule() &#123; return rule(null); &#125;/* * Create a Parser with a ASTree parameter, caution that this Parser is a single node with the parameter. */public static Parser rule(Class&lt;? extends ASTree&gt; clazz) &#123; return new Parser(clazz);&#125; Parser的构造方法，也有两个重载，其中第一个是用于构建模式树的根节点；而第二个适用于直接接受一个Parser并将其成员变量复制过来，其主要是用在maybe方法的实现中。 1234567891011121314151617protected List&lt;Element&gt; elements;protected Factory factory;/* * This constructor is used for first create Parser. */public Parser(Class&lt;? extends ASTree&gt; clazz) &#123; reset(clazz);&#125;/* * This constructor is used for chain call. */protected Parser(Parser p) &#123; elements = p.elements; factory = p.factory;&#125; 接下来的reset方法其实就是初始化（或者重置）Parser的成员：elements和factory 12345678/* * Reset the parser, elements and factory are all need to be reset. */public Parser reset(Class&lt;? extends ASTree&gt; clazz) &#123; elements = new ArrayList&lt;Element&gt;(); factory = Factory.getForASTList(clazz); return this;&#125; 然后就是Factory对象的getForASTList静态方法，这里的两个方法比较重要，主要是如何来构建一个factory。首先会从外部传来的class来构建一个Factory。我们后面再看get方法，首先来分析f == null时的情况。 这里就直接通过new方法来构建一个新的factory，值得注意的是这里实现了本来是make0方法。 注意：这个方法是用在匹配token串，使用该方法创建对应的AST节点。 这里的逻辑是：判断传入的arg的长度是等于1。如果等于1则返回其第一个元素。否则的话就利用org返回一个新的ASTList。 12345678910111213141516171819202122protected static Factory getForASTList(Class&lt;? extends ASTree&gt; clazz) &#123; /** * Get the class with the ASTree class transferred by user. */ Factory f = get(clazz, List.class); /** * If user did not transferred the class, * we implement the make0 method and new a factory which make a normal ASTree object. */ if (f == null) f = new Factory() &#123; protected ASTree make0(Object arg) throws Exception &#123; List&lt;ASTree&gt; results = (List&lt;ASTree&gt;)arg; if (results.size() == 1) return results.get(0); else return new ASTList(results); &#125; &#125;; return f;&#125; 接下来我们来看get方法。这里主要是如何利用传入的class来构建这个factory。首先如果是没有传入class，则直接返回class。 如果class != null时，则会有两种情况： 首先判断这个class有没有create方法（factoryName为字符串creatr），如果有的话就获取这个方法，然后实现了make0方法。 其次判断是否有构造器，如果有的话，make0方法就会直接利用该构造函数来新建一个该对象。 123456789101112131415161718192021222324252627282930313233343536373839protected static Factory get(Class&lt;? extends ASTree&gt; clazz, Class&lt;?&gt; argType)&#123; /** * If user transferred no class, get method return null. */ if (clazz == null) return null; try &#123; /** * Judge whether the class transferred by user has a \"create\" function. * If true, we just use the function to create the ASTree. */ final Method m = clazz.getMethod(factoryName, new Class&lt;?&gt;[] &#123; argType &#125;); return new Factory() &#123; protected ASTree make0(Object arg) throws Exception &#123; return (ASTree)m.invoke(null, arg); &#125; &#125;; &#125; catch (NoSuchMethodException e) &#123;&#125; /** * If the class has not a \"create\" function. * We judge whether the class has a constructor. * If true, we use the constructor to create the ASTree. */ try &#123; final Constructor&lt;? extends ASTree&gt; c = clazz.getConstructor(argType); return new Factory() &#123; protected ASTree make0(Object arg) throws Exception &#123; return c.newInstance(arg); &#125; &#125;; &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(e); &#125;&#125; 值得注意的是Parser对象还有很对方法用来对应BNF的规则： number：用于向Parser的elements添加number型AToken（这里的AToken是在Parser中的内部类，属于模式AST类）。 identifier：用于向Parser的elements添加identifier型AToken。 string：用于向Parser的elements添加srting型AToken。 sep：用于向Parser的elements添加用于间隔型AToken，在BNF中对应字符串本身。 ast：用于向Parser的elements添加基本的树结构，常用于直接传递其他模式串作为子串。 or：用于向Parser的elements添加分支结构的树结构，对应BNF的|。 maybe：用于向Parser的elements添加可省略的模式。 option：用于向Parser的elements添加可省略的模式，对应BNF的[]。 repeat： 用于向Parser的elements添加可重复的模式，对应BNF的{}。 expression：用于向Parser的elements添加以Express为树节点的模式。 下面是一个简单的模式的创建： 1Parser classNew = rule(NewStmnt.class).sep(\"new\").identifier(reserved).sep(\"(\").option(args).sep(\")\"); 其主要是匹配新建对象时的语法，如： 1new Obj(111, 222) 可以看到rule首先接受了一个NewStmnt.class参数，这就意味着，当这个模式匹配成功时，其创建的节点是NewStmnt类型的。 然后sep(&quot;new&quot;)即匹配new这个字符。 identifier(reserved)即匹配保留字，即变量名等。 option(args)即表示匹配可以省略的arguments，这里的args也是在前面定义的一个模式，匹配诸如：222,&quot;uuu&quot;之类的参数模式。 匹配token串在Parser中定义了诸多子类即模式节点，这些节点自己定义了parser方法用于解析对应的token是否匹配。 我们上面构建语法规则实际上形成了一个树，其节点就是之前定义在Parser内部的各种子类。 但其主要依然是一个递归的过程，首先会从队列中peek一个token（peek是不会让该token出队的），然后从匹配树的根部开始向下遍历，查找到其叶节点，然后匹配，如果通过则将调用其factory的make方法，来构建一个对应class的叶节点并且将其推入其elements中。 这里给出了一部分的结构（定义类的结构），我们模拟一下其解析过程： 123456class Myclass&#123; a = 1 constructor(param1)&#123; a = param1 &#125;&#125; 首先我们会通过Lexer会生成一个queue： StrToken:”class”-&gt;IdToken:Myclass-&gt;StrToken:”a”-&gt;… peek一个token，即第一个StrToken。 遍历树：从program-&gt;classDef-&gt;”class”，匹配成功。（若第一次没有匹配成功，将会在树上进行回溯）。 新建一个ClassDef对象的树节点。 接下来再peek一个token，即IdToken:Myclass 再从classDef的第二个节点开始匹配，发现也匹配成功。 创建一个Name树节点并将其加入刚才ClassDef的elements中。 后面也是如此，一次递归，失败就回溯；成功就继续匹配。 下面附上目前版本定义的规则（包括类，数组）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package parser;import static parser.Parser.rule;import java.util.HashSet;import parser.Parser.*;import scanner.Lexer;import token.Token;import ast.*;import entity.Function;import exception.ParseException;public class BasicParser &#123; HashSet&lt;String&gt; reserved = new HashSet&lt;String&gt;(); Operators operators = new Operators(); Parser expr0 = rule(); Parser primary = rule(PrimaryExpr.class) .or(rule().sep(\"(\").ast(expr0).sep(\")\"), rule().number(NumberLiteral.class), rule().identifier(Name.class, reserved), rule().string(StringLiteral.class) ); Parser factor = rule().or(rule(NegativeExpr.class).sep(\"-\").ast(primary), primary); Parser expr = expr0.expression(BinaryExpr.class, factor, operators); Parser statement0 = rule(); Parser block = rule(BlockStmnt.class) .sep(\"&#123;\").option(statement0) .repeat(rule().sep(\";\", Token.EOL).option(statement0)) .sep(\"&#125;\"); Parser simple = rule(PrimaryExpr.class).ast(expr); /** * Function Parser */ Parser param = rule().identifier(reserved); Parser params = rule(ParameterList.class).ast(param).repeat(rule().sep(\",\").ast(param)); Parser paramList = rule().sep(\"(\").maybe(params).sep(\")\"); Parser function = rule(FunctionStmnt.class).sep(\"function\").identifier(reserved).ast(paramList).ast(block); /** * InnerFunction Parser */ Parser innerFunction = rule(InnerFunc.class).sep(\"func\").ast(paramList).ast(block); Parser args = rule(Arguments.class).ast(expr).repeat(rule().sep(\",\").ast(expr));// Parser postfix = rule().sep(\"(\").maybe(args).sep(\")\"); Parser postfix = rule().or(rule(Dot.class).sep(\".\").identifier(reserved), rule().sep(\"(\").ast(args).sep(\")\"), rule(Squarebracket.class).sep(\"[\").ast(expr).sep(\"]\") ); Parser statement = statement0.or( rule(IfStmnt.class).sep(\"if\").sep(\"(\").ast(expr).sep(\")\").ast(block).option(rule().sep(\"else\").ast(block)), rule(WhileStmnt.class).sep(\"while\").sep(\"(\").ast(expr).sep(\")\").ast(block), simple); /** * class Parser */ Parser constructor = rule(Construtor.class).sep(\"constructor\").ast(paramList).ast(block); /** * The order can not be changed. Or constructor maybe regard as simple parser. */ Parser classEle = rule().or(constructor, function, simple); Parser classBody = rule(ClassBody.class).sep(\"&#123;\").option(classEle). repeat(rule().sep(\";\", Token.EOL).option(classEle)).sep(\"&#125;\"); Parser classDef = rule(ClassStmnt.class).sep(\"class\").identifier(reserved).option(rule().sep(\"extends\").identifier(reserved)).ast(classBody); Parser classNew = rule(NewStmnt.class).sep(\"new\").identifier(reserved).sep(\"(\").option(args).sep(\")\"); /** * Array Parsers */ Parser arrayDef = rule(ArrayStmnt.class).sep(\"[\").ast(expr).repeat(rule().sep(\",\").ast(expr)).sep(\"]\"); /** * final program Parser. */ Parser program = rule().or(classDef, statement, rule(NullStmnt.class)) .sep(\";\", Token.EOL); public BasicParser() &#123; reserved.add(\")\"); reserved.add(\";\"); reserved.add(\"&#125;\"); reserved.add(\"]\"); reserved.add(Token.EOL); operators.add(\"=\", 1, Operators.RIGHT); operators.add(\"==\", 2, Operators.LEFT); operators.add(\"&gt;\", 2, Operators.LEFT); operators.add(\"&lt;\", 2, Operators.LEFT); operators.add(\"+\", 3, Operators.LEFT); operators.add(\"-\", 3, Operators.LEFT); operators.add(\"*\", 4, Operators.LEFT); operators.add(\"/\", 4, Operators.LEFT); operators.add(\"%\", 4, Operators.LEFT); /** * avoid cycle reference, so we repair some Parser here. */ primary.repeat(postfix); primary.insertChoice(innerFunction); primary.insertChoice(classNew); primary.insertChoice(arrayDef); simple.option(rule().sep(\")\").option(args).sep(\")\")); &#125; public ASTree parse(Lexer lexer) throws ParseException &#123; return program.parse(lexer); &#125;&#125; 其中reserved即为保留字符，不会被识别为标识符等。 operators即为操作符，主要用在BinaryExpress即二元表达式中。 add函数的参数第一个是操作符，第二个是优先级，第三个是左先计算还是右先计算。","categories":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/categories/hair/"}],"tags":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/tags/hair/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://yoursite.com/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"},{"name":"语法分析","slug":"语法分析","permalink":"http://yoursite.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"基于java的脚本语言hair的开发思路1-词法分析","slug":"基于java的脚本语言hair的开发思路1-词法分析","date":"2021-09-21T07:23:07.000Z","updated":"2021-09-26T07:47:32.008Z","comments":true,"path":"2021/09/21/基于java的脚本语言hair的开发思路1-词法分析/","link":"","permalink":"http://yoursite.com/2021/09/21/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80hair%E7%9A%84%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"","text":"申明：本脚本语言前面的开发思路基本是《两周自制脚本语言》中Stone语言的模型，后期将逐渐分离，添加更多特征。这本书作为入门读物确实不错，但是其设计规范还是有待商榷，一是没有给出一个确定的项目架构、二是部分的结构的成分不够规范（比如token的定义，运算优先级的处理等）。 词法分析一个程序片段被编译器解析的时候是一个很长的字符串。我们的目标是通过一定的手段分析将这个字符串分开来。 而这个被分割后的子字符串我们一般称为Token，Token有很多类型。在V8中定义的部分代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#define BINARY_OP_TOKEN_LIST(T, E) \\ E(T, NULLISH, \"??\", 3) \\ E(T, OR, \"||\", 4) \\ E(T, AND, \"&amp;&amp;\", 5) \\ E(T, BIT_OR, \"|\", 6) \\ E(T, BIT_XOR, \"^\", 7) \\ E(T, BIT_AND, \"&amp;\", 8) \\ E(T, SHL, \"&lt;&lt;\", 11) \\ E(T, SAR, \"&gt;&gt;\", 11) \\ E(T, SHR, \"&gt;&gt;&gt;\", 11) \\ E(T, MUL, \"*\", 13) \\ E(T, DIV, \"/\", 13) \\ E(T, MOD, \"%\", 13) \\ E(T, EXP, \"**\", 14) \\ E(T, ADD, \"+\", 12) \\ E(T, SUB, \"-\", 12)#define EXPAND_BINOP_ASSIGN_TOKEN(T, name, string, precedence) \\ T(ASSIGN_##name, string \"=\", 2)#define EXPAND_BINOP_TOKEN(T, name, string, precedence) \\ T(name, string, precedence)#define TOKEN_LIST(T, K) \\ \\ /* BEGIN PropertyOrCall */ \\ /* BEGIN Member */ \\ /* BEGIN Template */ \\ /* ES6 Template Literals */ \\ T(TEMPLATE_SPAN, nullptr, 0) \\ T(TEMPLATE_TAIL, nullptr, 0) \\ /* END Template */ \\ \\ /* Punctuators (ECMA-262, section 7.7, page 15). */ \\ /* BEGIN Property */ \\ T(PERIOD, \".\", 0) \\ T(LBRACK, \"[\", 0) \\ /* END Property */ \\ /* END Member */ \\ T(QUESTION_PERIOD, \"?.\", 0) \\ T(LPAREN, \"(\", 0) \\ /* END PropertyOrCall */ \\ T(RPAREN, \")\", 0) \\ T(RBRACK, \"]\", 0) \\ T(LBRACE, \"&#123;\", 0) \\ T(COLON, \":\", 0) \\ T(ELLIPSIS, \"...\", 0) \\ T(CONDITIONAL, \"?\", 3) \\ /* BEGIN AutoSemicolon */ \\ T(SEMICOLON, \";\", 0) \\ T(RBRACE, \"&#125;\", 0) \\ /* End of source indicator. */ \\ T(EOS, \"EOS\", 0) \\ /* END AutoSemicolon */ \\ \\ /* BEGIN ArrowOrAssignmentOp */ \\ T(ARROW, \"=&gt;\", 0) \\ /* BEGIN AssignmentOp */ \\ /* IsAssignmentOp() relies on this block of enum values being */ \\ /* contiguous and sorted in the same order! */ \\ T(INIT, \"=init\", 2) /* AST-use only. */ \\ T(ASSIGN, \"=\", 2) \\ BINARY_OP_TOKEN_LIST(T, EXPAND_BINOP_ASSIGN_TOKEN) \\ /* END AssignmentOp */ \\ /* END ArrowOrAssignmentOp */ \\ \\ /* Binary operators sorted by precedence. */ \\ /* IsBinaryOp() relies on this block of enum values */ \\ /* being contiguous and sorted in the same order! */ \\ T(COMMA, \",\", 1) \\ \\ /* Unary operators, starting at ADD in BINARY_OP_TOKEN_LIST */ \\ /* IsUnaryOp() relies on this block of enum values */ \\ /* being contiguous and sorted in the same order! */ \\ BINARY_OP_TOKEN_LIST(T, EXPAND_BINOP_TOKEN) \\ \\ T(NOT, \"!\", 0) \\ T(BIT_NOT, \"~\", 0) \\ K(DELETE, \"delete\", 0) \\ K(TYPEOF, \"typeof\", 0) \\ K(VOID, \"void\", 0) \\ \\ /* BEGIN IsCountOp */ \\ T(INC, \"++\", 0) \\ T(DEC, \"--\", 0) \\ /* END IsCountOp */ \\ /* END IsUnaryOrCountOp */ \\ \\ /* Compare operators sorted by precedence. */ \\ /* IsCompareOp() relies on this block of enum values */ \\ /* being contiguous and sorted in the same order! */ \\ T(EQ, \"==\", 9) \\ T(EQ_STRICT, \"===\", 9) \\ T(NE, \"!=\", 9) \\ T(NE_STRICT, \"!==\", 9) \\ T(LT, \"&lt;\", 10) \\ T(GT, \"&gt;\", 10) \\ T(LTE, \"&lt;=\", 10) \\ T(GTE, \"&gt;=\", 10) \\ K(INSTANCEOF, \"instanceof\", 10) \\ K(IN, \"in\", 10) \\ \\ /* Keywords (ECMA-262, section 7.5.2, page 13). */ \\ K(BREAK, \"break\", 0) \\ K(CASE, \"case\", 0) \\ K(CATCH, \"catch\", 0) \\ K(CONTINUE, \"continue\", 0) \\ K(DEBUGGER, \"debugger\", 0) \\ K(DEFAULT, \"default\", 0) \\ /* DELETE */ \\ K(DO, \"do\", 0) \\ K(ELSE, \"else\", 0) \\ K(FINALLY, \"finally\", 0) \\ K(FOR, \"for\", 0) \\ K(FUNCTION, \"function\", 0) \\ K(IF, \"if\", 0) \\ /* IN */ \\ /* INSTANCEOF */ \\ K(NEW, \"new\", 0) \\ K(RETURN, \"return\", 0) \\ K(SWITCH, \"switch\", 0) \\ K(THROW, \"throw\", 0) \\ K(TRY, \"try\", 0) \\ /* TYPEOF */ \\ K(VAR, \"var\", 0) \\ /* VOID */ \\ K(WHILE, \"while\", 0) \\ K(WITH, \"with\", 0) \\ K(THIS, \"this\", 0) \\ \\ /* Literals (ECMA-262, section 7.8, page 16). */ \\ K(NULL_LITERAL, \"null\", 0) \\ K(TRUE_LITERAL, \"true\", 0) \\ K(FALSE_LITERAL, \"false\", 0) \\ T(NUMBER, nullptr, 0) \\ T(SMI, nullptr, 0) \\ T(BIGINT, nullptr, 0) \\ T(STRING, nullptr, 0) \\ \\ /* BEGIN Callable */ \\ K(SUPER, \"super\", 0) \\ /* BEGIN AnyIdentifier */ \\ /* Identifiers (not keywords or future reserved words). */ \\ T(IDENTIFIER, nullptr, 0) \\ K(GET, \"get\", 0) \\ K(SET, \"set\", 0) \\ K(ASYNC, \"async\", 0) \\ /* `await` is a reserved word in module code only */ \\ K(AWAIT, \"await\", 0) \\ K(YIELD, \"yield\", 0) \\ K(LET, \"let\", 0) \\ K(STATIC, \"static\", 0) \\ /* Future reserved words (ECMA-262, section 7.6.1.2). */ \\ T(FUTURE_STRICT_RESERVED_WORD, nullptr, 0) \\ T(ESCAPED_STRICT_RESERVED_WORD, nullptr, 0) \\ /* END AnyIdentifier */ \\ /* END Callable */ \\ K(ENUM, \"enum\", 0) \\ K(CLASS, \"class\", 0) \\ K(CONST, \"const\", 0) \\ K(EXPORT, \"export\", 0) \\ K(EXTENDS, \"extends\", 0) \\ K(IMPORT, \"import\", 0) \\ T(PRIVATE_NAME, nullptr, 0) \\ \\ /* Illegal token - not able to scan. */ \\ T(ILLEGAL, \"ILLEGAL\", 0) \\ T(ESCAPED_KEYWORD, nullptr, 0) \\ \\ /* Scanner-internal use only. */ \\ T(WHITESPACE, nullptr, 0) \\ T(UNINITIALIZED, nullptr, 0) \\ T(REGEXP_LITERAL, nullptr, 0) 可以看到V8定义了很多token类型，符号、关键字都被分开来定义。 但是作为一门简单的脚本语言，书中简单的将Token分为了3大类： Number Token：整形Token。 String Token：字符串Token。 Identifier Token: 标识符、关键字、变量名、运算符等。（除Number， String以外的单词）。 每种Token我们定义了一个类，其存储的主要信息有行号和实值（数字，字符串，标识符）。 最主要对于代码的解析我们用到了Java的正则匹配。而在V8中是自己写了匹配规则。 我们简单介绍一下： java的正则表达式Pattern类pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。下面是他的所有成员： 名称 解释 返回值 compile(String regex, ?int flags) Pattern类没有构造函数，都是通过该函数来获得匹配实体。其中regex是正则表达式，flags是模式，比如是否匹配换行等，一般使用Patter提供的静态变量来传递。 Pattern：由传入正则表达式编译形成的patter实体。 match(String regex, CharSequence input) 通过传入的regex创建匹配实体并且尝试匹配input。 boolean：是否成功匹配。 quote(String s) 将返回一个仅匹配s的正则表达式。（实际上是在s前后分别\\Q和\\E）。 String：一个仅可匹配s的一个字符串。 CANON_EQ: int 表示当两个字符严格相等时才匹配。主要是对于Unicode字符而言。（不重要，不再赘述）。 / CASE_INSENSITIVE:int 是否大小写敏感，默认是，传入该变量则表示不敏感（也可在regex中插入?i表示此意）。 / COMMENTS:int 是否忽略regex中的空格，不是//s，而是空格或者tab等（也可在regex中插入?x表示此意）。 / DOTALL:int 表示点(.)是否可以匹配所有字符，包括结束符。（也可在regex中插入?s表示此意）。 / LITERAL:int 表示启用字面值解析模式。 指定此标志后，指定模式的输入字符串就会作为字面值字符序列来对待。输入序列中的元字符或转义序列不具有任何特殊意义。 / MULTILINE:int 默认情况下，输入的字符串被看作是一行，即便是这一行中包好了换行符也被看作一行。当匹配“^”到“$”之间的内容的时候，整个输入被看成一个一行。启用多行模式之后，包含换行符的输入将被自动转换成多行，然后进行匹配。 / UNIX_LINES:int 表示仅以\\n为换行，\\r\\n将不会被识别为换行。（也可在regex中插入?d表示此意）。 / 所以基本只会使用compile这个函数和以下的几个静态变量。 示例12private String regexPat = \"\\\\abc\"private Pattern pattern = Pattern.compile(regexPat); Matcher 类Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 下面是其成员： 方法 说明 public MatchResult toMatchResult() 将匹配结果以MatchResult的形式返回 public Matcher usePattern(Pattern newPattern) 修改Matcher对象的Pattern，用以进行新的模式匹配。 public Matcher reset() 重置匹配器的状态。 public Matcher reset(CharSequence input) 重置匹配器的状态，重置目标字符串的值为input。 public int start() 返回当前匹配到的字符串在原目标字符串中的起始索引位置 public int start(int group) 返回当前匹配到的字符串中group组在目标字符串的起始索引位置 public int end() 返回当前匹配的字符串的最后一个字符在原目标字符串中的offset（偏移量），这个需要大家注意一下。 public int end(int group) 返回当前匹配的字符串中group组的最后一个字符在原目标字符串中的offset（偏移量），这个需要大家注意一下。 public String group() 返回匹配到的所有字符串，结合find函数使用。 public String group(int group) 返回匹配到的字符串中的对应index的group组的字符串。 public String group(String name) 返回被named-capturing组捕获的字符串，关于named-capturing group（命名捕获组）是JDK1.7新增的功能，可以将正则表达式中的组进行命名。 public int groupCount() 返回当前Matcher对象捕获的组的个数。 public boolean matches() 将整个目标字符串与正则表达式进行匹配，只有完全匹配才能返回true，否则false。 public boolean find() 对目标字符串进行正则匹配，通过while可以多次执行find方法，获取多次的匹配结果，代码编写方式类似于iterator.next()。 public boolean find(int start) 在指定的索引位置对目标字符串进行正则匹配。 public boolean lookingAt() 目标字符串的起始字符串与正则表达式匹配返回true，否则返回false。 public static String quoteReplacement(String s) 返回字符串s字面意义的替代字符串。 public Matcher appendReplacement(StringBuffer sb, String replacement) 向sb中追加replacement字符串，replacement字符串中可以包含匹配器中的分组参数，如1，2。 public StringBuffer appendTail(StringBuffer sb) 将Matcher匹配后的尾部字符串追加至sb中。 public String replaceAll(String replacement) 将目标字符串中所有满足正则匹配的字符串替换为replacement。 public String replaceFirst(String replacement) 将目标字符串中第一个满足正则匹配的字符串替换为replacement。 public Matcher region(int start, int end) 设置目标字符串的匹配范围。 public int regionStart() 返回匹配器区域的起始点索引位置。 public int regionEnd() 返回匹配器区域的结束点索引位置。 public boolean hasTransparentBounds() TransparentBounds标志位：查询TransparentBounds标志位true public Matcher useTransparentBounds(boolean b) 设置TransparentBounds标志位的值true public boolean hasAnchoringBounds() AnchoringBounds标志位：查询AnchoringBounds标志位的值，此标志位默认为true。在应用正则表达式的时候，我们可以指定目标字符串的检索范围，也就是说在目标字符串的子字符串中应用正则表达式。但此时会有一个问题，那就是 ^ 和 $ 应该匹配整个字符串的开头和结尾呢？ 还是检索范围的起始和结束位置呢？Java 为我们提供了足够的灵活性，我们可以通过下面的方法来查看和设置，默认值是匹配检索范围的起始和结束位置。 public Matcher useAnchoringBounds(boolean b) 设置AnchoringBounds标志位的值true public boolean hitEnd() public boolean requireEnd() boolean match(int from, int anchor) int getTextLength() 返回目标字符串的长度。 CharSequence getSubSequence(int beginIndex, int endIndex) 获取目标字符串的子字符串。 char charAt(int i) 返回目标字符串中索引为i的字符 PatternSyntaxExceptionPatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。 捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组： ((A)(B(C))) (A) (B(C)) (C) 可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。 还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。 正则表达式语法有一个需要注意的点： Java中的转移字符为两个反斜杠\\\\,这与其他语言不同。即当我们需要对一个字符进行转义的时候，我们需要在前面写两个\\。 如：一般的我们需要匹配换行符\\n这个符号的时候，我们只需要这么写：\\n。 而在Java中，我们需要这么写：\\\\n。 下面是匹配的字符： 字符 说明 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， n匹配字符 n。\\n 匹配换行符。序列 \\\\\\\\ 匹配 \\\\ ，\\\\( 匹配 (。 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\\n”或”\\r”之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\\n”或”\\r”之前的位置匹配。 * 零次或多次匹配前面的字符或子表达式。例如，zo 匹配”z”和”zoo”。 等效于 {0,}。 + 一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。 ? 零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。 {n} n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。 {n,} n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。 {n,m} m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。 ? 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。 . 匹配除”\\r\\n”之外的任何单个字符。若要匹配包括”\\r\\n”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式。 (pattern) 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”\\(“或者”\\)”。 (?:pattern) 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (\\ ) 组合模式部件的情况很有用。例如，’industr(?:y\\ ies) 是比 ‘industry\\ industries’ 更经济的表达式。 (？=pattern) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95\\ 98\\ NT\\ 2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 (?!pattern) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95\\ 98\\ NT\\ 2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 x\\ y 匹配 x 或 y。例如，’z\\ food’ 匹配”z”或”food”。’(z\\ f)ood’ 匹配”zood”或”food”。 [xyz] 字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。 [^xyz] 反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。 [a-z] 字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。 [^a-z] 反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。 \\b 匹配一个字边界，即字与空格间的位置。例如，”er\\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。 \\B 非字边界匹配。”er\\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。 \\cx 匹配 x 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。 \\d 数字字符匹配。等效于 [0-9]。 \\D 非数字字符匹配。等效于 [^0-9]。 \\f 换页符匹配。等效于 \\x0c 和 \\cL。 \\n 换行符匹配。等效于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等效于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r \\v] 等效。 \\S 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。 \\t 制表符匹配。与 \\x09 和 \\cI 等效。 \\v 垂直制表符匹配。与 \\x0b 和 \\cK 等效。 \\w 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。 \\W 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。 \\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\\x41”匹配”A”。”\\x041”与”\\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。 \\num 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\\1”匹配两个连续的相同字符。 \\n 标识一个八进制转义码或反向引用。如果 \\n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 \\nm 标识一个八进制转义码或反向引用。如果 \\nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \\nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \\nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。 \\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 \\un 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。 \\p{Punct} 匹配任何标点字符。 下面我们看一下主要的regexPat： 123public static String regexPat = \"\\\\s*((//.*)|([0-9]+)|(\\\"(\\\\\\\\\\\"|\\\\\\\\\\\\\\\\|\\\\\\\\n|[^\\\"])*\\\")\" +\"|[A-Z_a-z][A-Z_a-z0-9]*|==|&lt;=|&gt;=|&amp;&amp;|\\\\|\\\\||\\\\p&#123;Punct&#125;)?\"; 接下来我们按上面的规则来分析这个解析表达式： 1\"\\\\s*((//.*)|([0-9]+)|(\\\"(\\\\\\\\\\\"|\\\\\\\\\\\\\\\\|\\\\\\\\n|[^\\\"])*\\\")|[A-Z_a-z][A-Z_a-z0-9]*|==|&lt;=|&gt;=|&amp;&amp;|\\\\|\\\\||\\\\p&#123;Punct&#125;)?\"; 我们经过格式化。可以得到以下结果： 123456789101112131415161718192021222324252627282930\\\\s* 匹配空格( group(1) ( &#x2F;&#x2F;.* 匹配注释-group(2) ) | ( [0-9]+ 匹配数字-group(3) ) | ( \\&quot;(\\\\\\\\\\&quot;|\\\\\\\\\\\\\\\\|\\\\\\\\n|[^\\&quot;])*\\&quot; 匹配字符串-group(4) ) | [A-Z_a-z][A-Z_a-z0-9]* 匹配标识符，identifier | &#x3D;&#x3D; 匹配&#x3D;&#x3D; | &lt;&#x3D; 匹配&lt;&#x3D; | &gt;&#x3D; 匹配&gt;&#x3D; | &amp;&amp; 匹配&amp;&amp; | \\\\ 匹配\\ | \\\\| 匹配| | \\\\p&#123;Punct&#125; 匹配任何标点字符)? 匹配0次或1次 可以看出，我们将其分割开来，还是比较容易看懂的。所以此时我们再看匹配的Java代码： 1234567891011121314151617private void addToken(int lineNumber, Matcher matcher) &#123; String m = matcher.group(1); //最外层匹配项 // System.out.println(m); if(m != null) &#123; //not a space if(matcher.group(2) == null) &#123; //not a comment Token token; if(matcher.group(3) != null) &#123; //数字Token，例如123 token = new NumToken(lineNumber, Integer.parseInt(m)); &#125;else if(matcher.group(4) != null) &#123; //字符串匹配，例如 \"123\" token = new StrToken(lineNumber, toStringLiteral(m)); &#125;else &#123; //id匹配，例如while token = new IdToken(lineNumber, m); &#125; queue.add(token); &#125; &#125;&#125; 即可以完全和Java代码匹配出来。 总体思路所以词法分析的主要流程很简答： 将代码读取出来为stream，按行读取。 使用正则表达式匹配每一行的代码，将其识别为对应的单词（token）。 将识别出的token加入到Lexer的ArrayList中。","categories":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/categories/hair/"}],"tags":[{"name":"hair","slug":"hair","permalink":"http://yoursite.com/tags/hair/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://yoursite.com/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"},{"name":"词法分析","slug":"词法分析","permalink":"http://yoursite.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"java的正则表达式","slug":"java的正则表达式","date":"2021-09-19T01:00:40.000Z","updated":"2021-09-19T01:43:39.051Z","comments":true,"path":"2021/09/19/java的正则表达式/","link":"","permalink":"http://yoursite.com/2021/09/19/java%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"APIPattern类pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 示例12private String regexPat = \"\\\\abc\"private Pattern pattern = Pattern.compile(regexPat); Matcher 类Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxExceptionPatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。 捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组： ((A)(B(C))) (A) (B(C)) (C) 可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。 还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。 正则表达式语法","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Tensorflow2.0-data模块的使用","slug":"Tensorflow2-0-data模块的使用","date":"2021-09-04T12:06:03.000Z","updated":"2021-09-07T13:26:17.640Z","comments":true,"path":"2021/09/04/Tensorflow2-0-data模块的使用/","link":"","permalink":"http://yoursite.com/2021/09/04/Tensorflow2-0-data%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Tensorflow-dataTesorflow官方提供了一些数据集来供我们使用。其地址为Tensorflow-data，我们可以在这里查看数据集的详细细节Tensorflow-data-catalog。 其API地址为API。 简单使用Tensorflow-data有137个API，一般不会全部使用。我们需要了解的第一个API是： tfds.load：从本地或网络载入数据集，并生成tf.data.Dataset对象。 其基本形式为： 1234567891011121314151617tfds.load( name: str, *, split: Optional[Tree[splits_lib.Split]] = None, data_dir: Optional[str] = None, batch_size: tfds.typing.Dim = None, shuffle_files: bool = False, download: bool = True, as_supervised: bool = False, decoders: Optional[TreeDict[decode.Decoder]] = None, read_config: Optional[tfds.ReadConfig] = None, with_info: bool = False, builder_kwargs: Optional[Dict[str, Any]] = None, download_and_prepare_kwargs: Optional[Dict[str, Any]] = None, as_dataset_kwargs: Optional[Dict[str, Any]] = None, try_gcs: bool = False) tfds.load实际上是一个对内建三个方法的语法糖： 新建一个DatasetBuilder： 1builder = tfds.builder(name, data_dir=data_dir, **builder_kwargs) 为这个build下载或准备（本地则不需要下载）数据集： 1builder.download_and_prepare(**download_and_prepare_kwargs) 载入tf.data.Dataset对象： 12345678ds = builder.as_dataset( split=split, as_supervised=as_supervised, shuffle_files=shuffle_files, read_config=read_config, decoders=decoders, **as_dataset_kwargs,) 说完我们再来看每个参数解析： 名字 类型 说明 必须 默认值 name String 数据集的名称，我们可以在Tensorflow-data-catalog查看数据集的名字。注意这里的名字是蛇形命名法，即：a_b_c的下划线分割的形式。 是 / split String/tuple 如何分割数据集，主要有’train’, ‘test’两个是符串以及其tuple构成。如：1: ‘train’, ‘test’，分别表示只载入训练数据，或只载入测试数据。2: [‘train’, ‘test’]，表示载入训练集和测试集，此时第一个参数会返回一个list，我们可以用(train_data, test_data)来解构list。3: ‘train[:120]’, ‘train[:75%]’, ‘test[25%:100%]’, ‘train[:4shard]’：如同python的list截取一样的格式，只不过这里可以是绝对值、者百分比值或者分片。片是tensorflow中的一个概念，数据集在下载时即定义好了一共多少个片，我们可以用info.splits[&#39;train&#39;].num_shards来查看总片数。4: ‘train+test’, ‘train[:25%]+test’: 这种格式会把训练集和测试集合并在一起返回，其中每一部分都可以用列表截断。值得注意的是：每个数据集支持的split的格式不同，需要我们具体来使用。 否 数据集定义的划分模式 data_dir String 写入/读取数据集的地址，我们可以更改这个地址。 否 win下：C:\\Users\\[user]\\tensorflow_datasets batch_size Int 设置一个batch的大小，这里的batch主要是针对较大的数据集，不可能将所有的数据全部读进内存，我们会一次读取一个batch进内存运算。 否 不划分batch shuffle_files Boolean 是否需要打乱输入数据 否 False download Boolean 是否是从远程下载 否 True as_supervised Boolean 是否是监督模式，如果是True的话， tf.data.Dataset decoders read_config with_info builder_kwargs download_and_prepare_kwargs as_dataset_kwargs try_gcs","categories":[{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://yoursite.com/categories/Tensorflow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://yoursite.com/tags/Tensorflow/"},{"name":"Tensorflow-data","slug":"Tensorflow-data","permalink":"http://yoursite.com/tags/Tensorflow-data/"}]},{"title":"西瓜书总结3-线性模型","slug":"西瓜书总结3-线性模型","date":"2021-09-02T14:30:41.000Z","updated":"2021-09-03T13:42:21.926Z","comments":true,"path":"2021/09/02/西瓜书总结3-线性模型/","link":"","permalink":"http://yoursite.com/2021/09/02/%E8%A5%BF%E7%93%9C%E4%B9%A6%E6%80%BB%E7%BB%933-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"基本形式线性模型（linear model）顾名思义即通过线性函数来进行预测的模型。 大部分机器学习算法的本质都是寻找一个函数来将输入进行处理得到预测结果。这里最简单的线性模型是这样，最复杂的神经网络模型也是如此。 线性模型的一般形式为： f(x) = w1x1+w1x1+…+wdxd+b 向量形式则为： f(x) = wTx + b 其中w = (w1; w1; …;wd;)， w和b学得之后，模型就得以确定。 线性模型形式简单、易于构造，但却蕴含着机器学习中一些重要的思想。许多更为强大的非线性模型可在线性模型的基础上通过引入层级结构更高或高维映射而得。 线性回归","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"西瓜书","slug":"西瓜书","permalink":"http://yoursite.com/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"},{"name":"线性模型","slug":"线性模型","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"}]},{"title":"西瓜书总结2-模型评估与选择","slug":"西瓜书总结2-模型评估与选择","date":"2021-08-30T11:27:49.000Z","updated":"2021-09-02T14:15:26.926Z","comments":true,"path":"2021/08/30/西瓜书总结2-模型评估与选择/","link":"","permalink":"http://yoursite.com/2021/08/30/%E8%A5%BF%E7%93%9C%E4%B9%A6%E6%80%BB%E7%BB%932-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/","excerpt":"","text":"经验误差与过拟合概念错误率：分类错误的样本数占样本总数的比例。 精度：1 - 错误率。 训练误差（经验误差）：学习器在训练集上的误差。 泛化误差：学习器在新样本上的误差。 过拟合：把训练样本自身的一些特点当作了所有潜在样本都具有的一般特征。一般无法彻底避免，只能缓解。 欠拟合：与过拟合相反，即对训练样本的一般性质未学习好。 评估方法留出法留出法（hold-out）直接将数据集D划分为两个互斥的集合，其中一个集合用作训练集S，另一个作为测试集T。即D=S∪T，S∩T=Ø。 其缺点在于少了一部分数据，所以训练出来的模型必然会有一定的偏差。 交叉验证法交叉验证法（cross validation）先将数据集D划分为k个大小相似的互斥子集，即D=D1∪D2∪…∪Dk，Di∩Dj=Ø(i ≠ j)。每个子集都尽可能保持数据分布的一致性，即从D通过分层采样获得。然后每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集；这样可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值。通常将其称为“k折交叉验证”。k的最常用取值为10，此时称为10折交叉验证。 其缺点在于时间复杂度会提升，k折即需要训练k次，在高复杂度的算法中，就会有较大影响。 自助法自助法是基于自助采样法（bootstrap sampling）。其过程为：每次随机从D中挑选出一个样本，将其“拷贝”到D1（注意是拷贝，即D1中的数据仍然可以在下一次采样中采集到），这个过程重复执行m次后，我们就得到了包含m个样本的数据集D1。 显然，D中的一部分样本会在D1中出现多次，也可能一次都不出现。 做一个简单的估计，某一样本x在m次采样中都不出现的概率为：(1 - 1//m)m，取极限可得其大概为 1/e = 0.368。即，初始样本集D中约有36.8%的样本未出现在采样集D中D1中，所以我们将D1作为训练集，D/D1作为测试集。这样，实际的评估模型与期望评估的模型都使用了m个训练样本。而仍然有1/3的数据样本没出现在训练集中，可以用于测试。 该方法一般用于样本数量较小，难以有效划分训练集/测试集时。 缺点：改变了初始数据集的分布，这会引入估计偏差。 性能度量性能度量是指衡量模型泛化能力的评价标准。 错误率与精度见上文 查准率、查全率与F1 真实情况 预测情况 正例 反例 正例 TP(真正例) FN(假反例) 反例 FP(假正例) TN(真反例) 则查准率 P与查全率R分别为： P = TP / (TP + FP) R = TP / (TP + FN) 即查准率为预测正例中真实也正例的比例。 查全率为真实情况为正例中预测也为正例的比例。 查准率和查全率是一对矛盾的度量。 P-R图中面积越小则性能越好。 平衡点（BEP）为 查准率 = 查全率时的取值。 F1 = (2 P R)/ (P + R) = (2 * TP) / (样本总数 + TP - TN) 更一般的形式Fβ： Fβ = [(1 + β2) P R] / [(β2 * P) + P] 实际上F1是基于查准率与查全率的调和平均（harmonic mean）： 1 / F1 = (1 / 2) * (1 / P + 1 / R) 同样，Fβ则是加权调和平均： 1 / Fβ = 1 / (1 + β2) * (1 / P + β2 / R) ROC与AUCROC全称为“受试者工作特征”（Receiver Operating Characteristic）曲线。 其纵轴为“真正例率”（True Positive Rate，简称TPR） 横轴为“假正例率”（False Positive Rate，简称FPR） 即： TPR = TP / (TP + FN) FPR = FP / (TN + FP) AUC(Area Under ROC Curve)即ROC曲线下的面积。 代价敏感错误率与代价曲线一般对于不同的类别，我们错误的预测会造成不同的后果。例如把患者诊断为健康人和把健康人预测为病人，显然前者的后果更加严重。基于此，我们给出以下表格来定义不同的样本之间错误预测的代价： 真实情况 预测情况 第0类 第1类 第0类 0 cost01 第1类 cost10 0 所谓代价敏感错误率即要最小化所有样本预测的cost均值最小化。即： 注：假定上表中的第0类为正例，第1类为反例，令D+与D-分别代表样例集D的正例子集和反例子集 在非均等代价下，ROC曲线不能直接反映出学习器的期望总和代价，而代价曲线（cost curve）可以达到该目的。 其横轴为正概率代价： 其中p是样例为正例的概率。 纵轴是取值为[0, 1]的归一化代价。 其中FPR为上面提到的假正例率， FNR = 1 - TPR是假反例率","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"西瓜书","slug":"西瓜书","permalink":"http://yoursite.com/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"},{"name":"模型评估与选择","slug":"模型评估与选择","permalink":"http://yoursite.com/tags/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/"}]},{"title":"聚类的几种算法简述","slug":"聚类的几种算法简述","date":"2021-08-11T15:40:33.000Z","updated":"2021-08-11T17:21:41.712Z","comments":true,"path":"2021/08/11/聚类的几种算法简述/","link":"","permalink":"http://yoursite.com/2021/08/11/%E8%81%9A%E7%B1%BB%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0/","excerpt":"","text":"聚类聚类是无监督学习中应用最广泛的算法。聚类会将数据集中的样本划分为若干个不同的子集，每个子集称为一个簇。 原型聚类原型聚类假设聚类结构能通过一组原型刻画。通常情况下，该类算法先对原型进行初始化，然后对原型进行迭代更新求解。 k均值算法（k-means）该算法的目的是最小化每个簇中每个样本到对应原型的距离。 但是直接求解的话会是一个NP难问题，较难求解，因此我们仍然采用迭代更新的贪心算法来求解可能的最近似解。值得注意的是，这样并不一定能求得最优解。 其算法大致思想如下： 初始化簇的数目K和一组原型向量（从样本中随机选择K个） 迭代每个样本和原型向量，为每个样本找到其距离最近的簇，并将其划为到对应的簇中。 重新计算每个簇对应的原型向量 检查新的原型向量和原来的原型向量是否相等，如果全部更新就停止迭代，即找到了最近似解。 python代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- coding: utf-8 -*-\"\"\"Created on Tue Aug 10 15:17:10 2021@author: mw530\"\"\"import numpy as npimport pandas as pdclass ProBasedClusterin: clusterNum = 3 data = None dataLen = 0 clusterVector = [] clusterSplit = [] def __init__(self, data, clusterNum = 3): self.clusterNum = clusterNum self.data = data self.dataLen = data.shape[0] randArray = self.uniqueRandInt(clusterNum, 0, self.data.shape[0]) for i in range(clusterNum): self.clusterVector.append(data[randArray[i]]) self.clusterSplit.append([]) def uniqueRandInt(self, num, low, high): randArray = [] currNum = 0 while currNum &lt; num: randInt = np.random.randint(low, high) if randInt not in randArray: randArray.append(randInt) currNum += 1 return randArray def eucDistance(self, x, y): return np.sqrt(np.sum((x - y)**2)) def train(self): vectorChangeNum = -1 cycle = 0 while vectorChangeNum != 0: cycle += 1 vectorChangeNum = 0 for i in range(self.clusterNum): self.clusterSplit[i] = [] # 将每个样本分到对应的簇 for i in range(self.dataLen): minDis = 9999999 clusterIndex = -1 for j in range(self.clusterNum): dis = self.eucDistance(self.data[i], self.clusterVector[j]) if(dis &lt; minDis): minDis = dis clusterIndex = j self.clusterSplit[clusterIndex].append(self.data[i]) # print(self.clusterSplit) print(\"##############################\") #计算每个簇的新原型向量 for i in range(self.clusterNum): vector = np.mean(self.clusterSplit[i], axis=0) if not (vector == self.clusterVector[i]).all(): vectorChangeNum += 1 self.clusterVector[i] = vector print(\"第\", cycle, \"次遍历\", \"有\", vectorChangeNum, \"个原型向量不同\") if vectorChangeNum == 0: print(\"找到最佳原型向量，共循环\", cycle, \"次\") return self.clusterSplit def loadData(name): path = './data/' + name file = open(path, 'r') csv = pd.read_csv(file) arr = np.array(csv) return arrdata = loadData('cetics_game.csv')# print(data[1:20, :])clustering = ProBasedClusterin(data)clusterSplit = clustering.train()# print(clusterSplit) 学习向量量化（Learning Vector Quantization）该算法仍然属于原型聚类，因此与K均值相似。也是试图使用一组原型向量来刻画聚类结构。但是该算法假设每个样本有一个标记，学习算法的过程会利用样本的这些监督信息来辅助聚类。 其算法大致思想如下: 初始化学习率 μ，原型向量的个数K，K个原型向量（从样本中随机选择） 从样本集随机选择一个样本x，迭代每个原型向量，找到距离x最近的原型向量p。 根据公式p = p ± μ * (x - p) 更新该原型向量。（如果x与p标记相同为＋，否则为-） 注意该算法的迭代一般就人为确定循环次数。 python代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# -*- coding: utf-8 -*-\"\"\"Created on Tue Aug 10 18:34:25 2021@author: mw530\"\"\"import numpy as npimport pandas as pdclass LearningVectorQuan: protoVecNum = 0 eTa = 0.5 data = None dataLen = 0 labels =None protoVector = [] protoLabels = [] cycleNum = 1000 def __init__(self, data, labels, protoVecNum = 3, eTa = 0.5, cycleNum = 1000): self.protoVecNum = protoVecNum self.eTa = eTa self.cycleNum = cycleNum self.data = data self.labels = labels self.dataLen = self.data.shape[0] randInt = self.uniqueRandInt(self.protoVecNum, 0, self.dataLen - 1) for i in randInt: self.protoVector.append(self.data[i]) self.protoLabels.append(self.labels[i]) def uniqueRandInt(self, num, low, high): randArray = [] currNum = 0 while currNum &lt; num: randInt = np.random.randint(low, high) if randInt not in randArray: randArray.append(randInt) currNum += 1 return randArray def eucDistance(self, x, y): return np.sqrt(np.sum((x - y)**2)) def train(self): for i in range(self.cycleNum): randIndex = np.random.randint(0, self.dataLen - 1) randData = self.data[randIndex] randLabel = self.labels[randIndex][0] minIndex = -1 minDis = 9999999 for j in range(self.protoVecNum): dis = self.eucDistance(randData, self.protoVector[j]) if dis &lt; minDis: minDis = dis minIndex = j if randLabel == self.labels[minIndex]: self.protoVector[minIndex] = self.protoVector[minIndex] + self.eTa * (randData - self.protoVector[minIndex]) else: self.protoVector[minIndex] = self.protoVector[minIndex] - self.eTa * (randData - self.protoVector[minIndex]) return self.protoVector def loadData(name): path = './data/' + name file = open(path, 'r') csv = pd.read_csv(file) arr = np.array(csv) return arr[:, :-1], arr[:, -1:]data, labels = loadData('cetics_game.csv')# print(data, labels)clustering = LearningVectorQuan(data, labels)clusterSplit = clustering.train()print(np.array(clusterSplit).shape) 高斯混合聚类（高斯分布即正态分布）与以上两种算法不同，该算法使用的概率模型来表达聚类原型。 密度聚类该算法亦称为“基于密度的聚类”，此类算法假设聚类结构能够通过样本分布的紧密程度确定。并基于可连接样本不断扩展聚类簇以获得最终的聚类结果。 DBSCAN是一种著名的密度聚类算法，它基于一组“邻域”参数（ε，MinPts）来刻画样本分布的紧密程度。给定数据集D，有一下几个概念需要了解。 ε-邻域：对于xi∈D，其ε-邻域包括样本集D中与xi距离不大于ε的所有样本。 核心对象：若xi的ε-邻域中至少包含MinPts个样本，则xi为一个核心对象。 密度直达：若xi位于xj的ε-邻域中，且xj是一个核心对象，则称xi由xj密度直达。 密度可达：对于xi和xj，若存在样本序列p1, p2, p3, … , pn，其中p1 = xi, pn = xj, 且pi+1由pi密度直达，则称xj由xi密度直达。 密度相连：对xi与xj，若存在xk使得xi与xj均由xk密度可达，则称xi与xj密度相连。 该算法的核心思想如下： 算法先根据给定的邻域参数（ε， MinPts）找出所有的核心对象 以任一核心对象为出发点，找出由其密度可达的样本生成聚类簇，直到所有核心对象均被访问过。 层次聚类层次聚类（hierarchical clustering）试图在不同层次上对数据集进行划分，从而形成树状的聚类结构。数据集的划分可以采用自底向上的聚类策略，也可以采用自顶而下的分拆策略。 AGNES是以这种采用自底向上聚类策略的层次聚类算法。 其算法思想如下： 它先将数据集中的每个样本看作一个初始聚类簇。 然后再算法运行的每一步中找出距离最近的两个聚类进行合并，该过程不断重复，直到达到预设的聚类簇个数。 注意：以上的代码都是自己手写的，可能会有不足。","categories":[{"name":"聚类","slug":"聚类","permalink":"http://yoursite.com/categories/%E8%81%9A%E7%B1%BB/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"聚类","slug":"聚类","permalink":"http://yoursite.com/tags/%E8%81%9A%E7%B1%BB/"}]},{"title":"机器学习1-决策树算法","slug":"机器学习1-决策树算法","date":"2021-07-13T08:03:13.000Z","updated":"2021-09-14T08:42:29.215Z","comments":true,"path":"2021/07/13/机器学习1-决策树算法/","link":"","permalink":"http://yoursite.com/2021/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法回忆总述首先决策树算法的一个核心思想是通过一些方法将数据递归的划分为一个树状结构。其算法流程大致如下： 读取数据 注意CSV是文本格式，读取时是r；Excel是二进制文件，读取时是rb 根据标准计算最优属性，一般选择香农熵，其流程如下： 递归每一个属性，计算该属性的总熵值，总熵值为每个值得熵得和 先统计该属性得所有不重复值的数据条数 根据公式：ent = (-item/count)*np.log2(item/count) 计算每个属性值的熵值 ， 其中item为该属性值的数据数量、count为该属性的数据数量 将上面的每个属性值的ent相加，就得到该属性的总熵值 根据最优属性划分数据 根据划分得到的数据构建决策树，接下来有几种可能： 如果最优属性的label唯一，那么则该属性的值即为该树节点的值 如果不是唯一的，则根据属性值来将其划分为对应的数据字典（例如： {属性值1：[数据1-1， 数据1-2，…]}），然后遍历该字典： 如果该属性值的list的label唯一，则该属性的该值几位一个节点，由此构造节点。 否则对该属性递归该过程来构建树。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"决策树算法","slug":"决策树算法","permalink":"http://yoursite.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/"}]},{"title":"Node学习5-进程机制","slug":"Node学习5-进程机制","date":"2021-05-03T03:06:49.000Z","updated":"2021-05-23T05:56:09.775Z","comments":true,"path":"2021/05/03/Node学习5-进程机制/","link":"","permalink":"http://yoursite.com/2021/05/03/Node%E5%AD%A6%E4%B9%A05-%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6/","excerpt":"","text":"服务端模型得变迁Web服务器的架构已经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。 石器时代：同步最早的服务器，其执行模型是同步的，它的服务模式是一次只为一次请求服务，所有的请求都得按次序等待服务。这意味着除了当前的请求被处理外，其余请求都处于等待被处理的状态。其处理性能相当低下，假设每次响应服务耗时为N秒，则这类服务的QPS为1/N。 这种架构如今已基本被淘汰，只在一些无并发需要的应用中存在。 青铜时代：复制进程为了解决同步架构的并发问题，衍生出了复制多个进程以提高并发量的模式。每个进程为一个连接服务。但这种模式的消耗非常高，因为新建进程的代价是很高的，包括内存上下文的分配。因为再复制进程的同时也会复制进程内部的状态，也就是说同样的状态会在内存中存储多份，造成来个浪费。 假设通过进程复制和预复制的方式搭建的服务器有资源的限制，且进程的上限为M，那么这一类服务的QPS为M/N。 白银时代：多线程为了解决创建进程代价过大的问题，多线程的概念被引入，线程相当于一个简化版的进程，其没有自己的系统资源，所以在创建，废除时，其代价都比进程小的多。但是值得注意的是，不同进程的线程切换会造成上下文的切换，当过多的不同进程的线程进行切换时，消耗仍然很大。虽然其有缺点，但线程仍然是当代操作系统的重要组成部分。 如果忽略多线程上下问切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为N*L/N。 黄金时代：事件驱动多线程的服务模型服役了很长一段时间，Apache就是采用多线程/多进程模式来实现的，当并发量增长到上万时，内存耗用的问题就会暴露出来，即为著名的C10k问题。 为了解决高并发的问题，基于事件驱动的服务模型出现了，像Node和Nginx均是基于事件驱动的方式实现的：即一个线程为所有请求服务，请求到来时触发事件，这与每个请求由一个线程服务的模式完全不同。采用单线程避免了不必要的内存开销和上下文切换问题。 但是这种基于单线程的模式虽然解决了上面的问题，但是其无法高效的利用多核CPU的问题，则为这个模式的问题之所在。所以当我们解决掉这个问题时，那么性能的提升是相当可观的。 多进程架构面对单线程对多核利用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程的各自利用一个CPU，以此实现多核CPU的利用。基于Node提供的child_process模块可以实现多进程的调用。我们创建一个简单的服务端代码： 123456789let http = require('http')const port = 5000 + Math.round(1 + Math.random() * 1000)http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-type': 'text/plain'&#125;) res.end(\"Hello World\\n\")&#125;).listen(port, '127.0.0.1')console.log('server on 127.0.0.1:'+port) 通过node work.js启动它，它会见监听5000到6000之间的一个随机端口。将下面的代码保存为master.js，并通过node master.js启动它： 123456let fork = require('child_process').forklet cpus = require('os').cpus()for(let i = 0; i &lt; cpus.length; i++)&#123; fork('./work.js')&#125; 这段代码会根据当前机器上的CPU的数量复制出当前Node进程数。 会得到如下的结果： 1234server on 127.0.0.1:5123server on 127.0.0.1:5481server on 127.0.0.1:5065server on 127.0.0.1:5516 如下图即为典型的Master-Work模式，又称为主从模式，其广泛用于并行处理业务的模式，具备较好的可伸缩性和稳定性。图中的进程分为两类：主进程和工作进程。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它趋向于稳定。工作进程负责具体的业务处理。 注意通过fork()复制的进程都是一个独立的进程，每个进程都是一个独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10MB的内存。 child_process模块创建子进程异步创建子进程child_process.exec(command[, options][, callback])该方法可以直接异步执行命令（不是JavaScript代码，而是shell命令），options参数可以控制各种条件，比如工作目录，编码等；第三个参数用于设置失败的回调。 该命令衍生shell，然后在shell中执行command，并缓冲任何产生的输出。穿给command字符串会被shell直接处理，特殊字符串（因shell而异）需要被相应地处理： 12345exec('\"/目录/空 格/文件.sh\" 参数1 参数2');// 使用双引号，使路径中的空格不会被解释为多个参数的分隔符。exec('echo \"\\\\$HOME 变量为 $HOME\"');// $HOME 变量在第一个实例中会被转义，但是第二个则不会。 所以对于用户的输入，一定要经过无害化处理才能使用这个函数，因为其可以触发任何命令，很危险! 示例123456789101112const process = require('child_process')let cmd = 'console.log(123456)'process.exec('echo 132',&#123;encoding: 'GBK'&#125;, (error, stdout, stderr) =&gt; &#123; if (error) &#123; console.error(`执行的错误: $&#123;error&#125;`); return; &#125; console.log(`stdout: $&#123;stdout&#125;`); console.error(`stderr: $&#123;stderr&#125;`); &#125;) 值得注意的是：标准输出是在回调的stdout参数中，而不会直接打印在当前控制台中。 源码我们简单看一下其源码： 123456function exec(command, options, callback) &#123; const opts = normalizeExecArgs(command, options, callback); return module.exports.execFile(opts.file, opts.options, opts.callback);&#125; 可以看到其首先是调用了normalizeExecArgs()这个函数，我们再看一下内部： 12345678910111213141516function normalizeExecArgs(command, options, callback) &#123; if (typeof options === 'function') &#123; callback = options; options = undefined; &#125; // Make a shallow copy so we don't clobber the user's options object. options = &#123; ...options &#125;; options.shell = typeof options.shell === 'string' ? options.shell : true; return &#123; file: command, options: options, callback: callback &#125;;&#125; 可以可能首先是做了一个判断，即忽略options功能的实现。 然后是对options做了浅拷贝防止修改用户的options对象。因为后面需要对options.shell进行处理，即是否使用默认的shell.exe。详见下面： shell 的要求Shell 需要能理解 -c 开关。 如果 shell 是 &#39;cmd.exe&#39;，则它需要能理解 /d /s /c 开关，且命令行解析需要能兼容。 默认的 Windows shell尽管微软指定在根环境中 %COMSPEC% 必须包含 &#39;cmd.exe&#39; 的路径，但子进程并不总是遵循相同的要求。 因此，在可以衍生 shell 的 child_process 函数中，如果 process.env.ComSpec 不可以，则使用 &#39;cmd.exe&#39; 作为后备。 然后直接返回了一个对象，并且将command重命名为file（这里我没有看到哪里将command转换为file，但是exeFile确实只接受File，疑惑） 跳出这个函数，看exe()函数，可以发现其仍然是调用了exeFile()函数，我们下面再来看这个函数的源码。 child_process.execFile(file[, args][, options][, callback])该函数预child_process.exe()相似，都是执行命令。但仍然有些许不同。 该方法第一个参数接受一个命令文件（名字或路径），而不是命令的字符串。 child_process.execFile() 函数类似于 child_process.exec()，但默认情况下不会衍生 shell。 指定的可执行文件 file 会被直接衍生作为新的进程，使其比 child_process.exec() 稍微更高效。 由于没有衍生 shell，因此不支持 I/O 重定向和文件通配等行为。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218function execFile(file /* , args, options, callback */) &#123; let args = []; let callback; let options; // Parse the optional positional parameters.解析参数 let pos = 1; if (pos &lt; arguments.length &amp;&amp; ArrayIsArray(arguments[pos])) &#123; args = arguments[pos++]; &#125; else if (pos &lt; arguments.length &amp;&amp; arguments[pos] == null) &#123; pos++; &#125; if (pos &lt; arguments.length &amp;&amp; typeof arguments[pos] === 'object') &#123; options = arguments[pos++]; &#125; else if (pos &lt; arguments.length &amp;&amp; arguments[pos] == null) &#123; pos++; &#125; if (pos &lt; arguments.length &amp;&amp; typeof arguments[pos] === 'function') &#123; callback = arguments[pos++]; &#125; if (!callback &amp;&amp; pos &lt; arguments.length &amp;&amp; arguments[pos] != null) &#123; throw new ERR_INVALID_ARG_VALUE('args', arguments[pos]); &#125; options = &#123; encoding: 'utf8', timeout: 0, maxBuffer: MAX_BUFFER, killSignal: 'SIGTERM', cwd: null, env: null, shell: false, ...options &#125;; // Validate the timeout, if present.验证参数 validateTimeout(options.timeout); // Validate maxBuffer, if present. validateMaxBuffer(options.maxBuffer); options.killSignal = sanitizeKillSignal(options.killSignal); //关键-产生子进程 const child = spawn(file, args, &#123; cwd: options.cwd, env: options.env, gid: options.gid, shell: options.shell, signal: options.signal, uid: options.uid, windowsHide: !!options.windowsHide, windowsVerbatimArguments: !!options.windowsVerbatimArguments &#125;); let encoding; const _stdout = []; const _stderr = []; if (options.encoding !== 'buffer' &amp;&amp; Buffer.isEncoding(options.encoding)) &#123; encoding = options.encoding; &#125; else &#123; encoding = null; &#125; let stdoutLen = 0; let stderrLen = 0; let killed = false; let exited = false; let timeoutId; let ex = null; let cmd = file; function exithandler(code, signal) &#123; if (exited) return; exited = true; if (timeoutId) &#123; clearTimeout(timeoutId); timeoutId = null; &#125; if (!callback) return; // merge chunks let stdout; let stderr; if (encoding || ( child.stdout &amp;&amp; child.stdout.readableEncoding )) &#123; stdout = ArrayPrototypeJoin(_stdout, ''); &#125; else &#123; stdout = Buffer.concat(_stdout); &#125; if (encoding || ( child.stderr &amp;&amp; child.stderr.readableEncoding )) &#123; stderr = ArrayPrototypeJoin(_stderr, ''); &#125; else &#123; stderr = Buffer.concat(_stderr); &#125; if (!ex &amp;&amp; code === 0 &amp;&amp; signal === null) &#123; callback(null, stdout, stderr); return; &#125; if (args.length !== 0) cmd += ` $&#123;ArrayPrototypeJoin(args, ' ')&#125;`; if (!ex) &#123; // eslint-disable-next-line no-restricted-syntax ex = new Error('Command failed: ' + cmd + '\\n' + stderr); ex.killed = child.killed || killed; ex.code = code &lt; 0 ? getSystemErrorName(code) : code; ex.signal = signal; &#125; ex.cmd = cmd; callback(ex, stdout, stderr); &#125; function errorhandler(e) &#123; ex = e; if (child.stdout) child.stdout.destroy(); if (child.stderr) child.stderr.destroy(); exithandler(); &#125; function kill() &#123; if (child.stdout) child.stdout.destroy(); if (child.stderr) child.stderr.destroy(); killed = true; try &#123; child.kill(options.killSignal); &#125; catch (e) &#123; ex = e; exithandler(); &#125; &#125; if (options.timeout &gt; 0) &#123; timeoutId = setTimeout(function delayedKill() &#123; kill(); timeoutId = null; &#125;, options.timeout); &#125; if (child.stdout) &#123; if (encoding) child.stdout.setEncoding(encoding); child.stdout.on('data', function onChildStdout(chunk) &#123; const encoding = child.stdout.readableEncoding; const length = encoding ? Buffer.byteLength(chunk, encoding) : chunk.length; const slice = encoding ? StringPrototypeSlice : (buf, ...args) =&gt; buf.slice(...args); stdoutLen += length; if (stdoutLen &gt; options.maxBuffer) &#123; const truncatedLen = options.maxBuffer - (stdoutLen - length); ArrayPrototypePush(_stdout, slice(chunk, 0, truncatedLen)); ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout'); kill(); &#125; else &#123; ArrayPrototypePush(_stdout, chunk); &#125; &#125;); &#125; if (child.stderr) &#123; if (encoding) child.stderr.setEncoding(encoding); child.stderr.on('data', function onChildStderr(chunk) &#123; const encoding = child.stderr.readableEncoding; const length = encoding ? Buffer.byteLength(chunk, encoding) : chunk.length; stderrLen += length; if (stderrLen &gt; options.maxBuffer) &#123; const truncatedLen = options.maxBuffer - (stderrLen - length); ArrayPrototypePush(_stderr, chunk.slice(0, truncatedLen)); ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr'); kill(); &#125; else &#123; _stderr.push(chunk); &#125; &#125;); &#125; child.addListener('close', exithandler); child.addListener('error', errorhandler); return child;&#125; 这个函数相对还是比较长，有217行。但是结构相当清晰： L 2-4：定义参数变量 L 7-26：解析参数（由于定义了可选参数，所以需要这样解析） L 28-46：定义options并验证参数合法性 L 48-57（关键）：调用spawn()函数产生子进程 Rest：剩下的代码都是为child添加close和error事件和其准备工作 Last：返回child。 在 Windows 上衍生 .bat 和 .cmd 文件child_process.exec() 和 child_process.execFile()之间区别的重要性可能因平台而异。 在 Unix 类型的操作系统（Unix、Linux、macOS）上，child_process.execFile()可以更高效，因为默认情况下不会衍生 shell。 但是在 Windows 上， .bat 和 .cmd 文件在没有终端的情况下不能自行执行，因此无法使用 child_process.execFile()启动。 当在 Windows 上运行时，要调用 .bat 和 .cmd 文件，可以使用设置了 shell 选项的 child_process.spawn()、或 child_process.exec()、或衍生 cmd.exe 并将 .bat 或 .cmd 文件作为参数传入（也就是 shell 选项和 child_process.exec()所做的）。 在任何情况下，如果脚本的文件名包含空格，则需要加上引号。 child_process.spawn(command[, args][, options])可以看到，最后创建进程的工作，都是由这个方法实现的，但是其与exec()有较大的不同，否则也不会设计两个API，一直存在这么久。 spawn()与exec()的不同： exec()的command是包含参数的，而spawn命令的参数是作为函数的第二个参数传入的。 exec()是将处理函数作为回调传入内部，而spawn实现了emitter，可以直接在外部监听事件。还可以准确的监听close等事件，exec()则只能统一监听error事件。 示例123456789101112131415const &#123; spawn &#125; = require('child_process');const ls = spawn('ls', ['-lh', '/usr']);//需要显式的监听ls.stdout.on('data', (data) =&gt; &#123; console.log(`stdout: $&#123;data&#125;`);&#125;);ls.stderr.on('data', (data) =&gt; &#123; console.error(`stderr: $&#123;data&#125;`);&#125;);ls.on('close', (code) =&gt; &#123; console.log(`子进程退出，退出码 $&#123;code&#125;`);&#125;); 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function spawn(file, args, options) &#123; //解析参数 options = normalizeSpawnArguments(file, args, options); //验证timeout validateTimeout(options.timeout); //验证signal validateAbortSignal(options.signal, 'options.signal'); //验证并转换killSignal信号，这里嵌套太深而且不重要，就不再深究 const killSignal = sanitizeKillSignal(options.killSignal); //新建子进程，重要 const child = new ChildProcess(); //这里实际是记录log，而不是debug debug('spawn', options); //初始化子进程参数 child.spawn(options); //子进程超时的操作 if (options.timeout &gt; 0) &#123; let timeoutId = setTimeout(() =&gt; &#123; if (timeoutId) &#123; try &#123; child.kill(killSignal); &#125; catch (err) &#123; child.emit('error', err); &#125; timeoutId = null; &#125; &#125;, options.timeout); child.once('exit', () =&gt; &#123; if (timeoutId) &#123; clearTimeout(timeoutId); timeoutId = null; &#125; &#125;); &#125; //是否有killSignal参数，即终止进程的信号值，有的话添加abort事件 if (options.signal) &#123; const signal = options.signal; if (signal.aborted) &#123; process.nextTick(onAbortListener); &#125; else &#123; signal.addEventListener('abort', onAbortListener, &#123; once: true &#125;); child.once('exit', () =&gt; signal.removeEventListener('abort', onAbortListener)); &#125; function onAbortListener() &#123; abortChildProcess(child, killSignal); &#125; &#125; //返回子进程 return child;&#125; 这个函数中最重要的就是const child = new ChildProcess();这一部分，我们再看一下这个类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function ChildProcess() &#123; FunctionPrototypeCall(EventEmitter, this); this._closesNeeded = 1; this._closesGot = 0; this.connected = false; this.signalCode = null; this.exitCode = null; this.killed = false; this.spawnfile = null; //重要，新建进程 this._handle = new Process(); this._handle[owner_symbol] = this; this._handle.onexit = (exitCode, signalCode) =&gt; &#123; if (signalCode) &#123; this.signalCode = signalCode; &#125; else &#123; this.exitCode = exitCode; &#125; if (this.stdin) &#123; this.stdin.destroy(); &#125; this._handle.close(); this._handle = null; if (exitCode &lt; 0) &#123; const syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn'; const err = errnoException(exitCode, syscall); if (this.spawnfile) err.path = this.spawnfile; err.spawnargs = ArrayPrototypeSlice(this.spawnargs, 1); this.emit('error', err); &#125; else &#123; this.emit('exit', this.exitCode, this.signalCode); &#125; // If any of the stdio streams have not been touched, // then pull all the data through so that it can get the // eof and emit a 'close' event. // Do it on nextTick so that the user has one last chance // to consume the output, if for example they only want to // start reading the data once the process exits. process.nextTick(flushStdio, this); maybeClose(this); &#125;;&#125;ObjectSetPrototypeOf(ChildProcess.prototype, EventEmitter.prototype);ObjectSetPrototypeOf(ChildProcess, EventEmitter);//...ChildProcess.prototype.spawn = function(options) &#123; //...&#125;//...ChildProcess.prototype.kill = function(sig) &#123; //...&#125;//...ChildProcess.prototype.ref = function() &#123; if (this._handle) this._handle.ref();&#125;;ChildProcess.prototype.unref = function() &#123; if (this._handle) this._handle.unref();&#125;;// 可以看到这实际上就是一个原生的JS类，其在构造函数中定义了很多内部变量，其中最重要的是this._handle = new Process();来真实的新建一个进程。而这个类则是从C++底层导出的，所以我们不再向下深入。 在定义完类之后，Node立即为其添加了event模块，用于用户对其进行操作。 其中spawn()也很重要，注意每层的对象都有spawn()函数，其用来得到最后的输出结果。 child_process.fork(modulePath[, args][, options])child_process.fork() 方法是 child_process.spawn()的特例，专门用于衍生新的 Node.js 进程。 与 child_process.spawn() 一样返回 ChildProcess对象。 返回的 ChildProcess会内置额外的通信通道，允许消息在父进程和子进程之间来回传递。 详见 subprocess.send()。 记住，衍生的 Node.js 子进程独立于父进程，但两者之间建立的 IPC 通信通道除外。 每个进程都有自己的内存，带有自己的 V8 实例。 由于需要额外的资源分配，因此不建议衍生大量的 Node.js 子进程。 默认情况下， child_process.fork() 会使用父进程的 process.execPath来衍生新的 Node.js 实例。 该方法应该比较常用的，因为我们在做web的负载均衡或者多核CPU利用时，一般其他的server也是Node，所以通过该API可以直接生成新的进程。 示例1234567//前面的主从的例子let fork = require('child_process').forklet cpus = require('os').cpus()for(let i = 0; i &lt; cpus.length; i++)&#123; fork('./work.js')&#125; 同步创建子进程下面的函数会同步创建，执行进程，并且将会阻塞 Node.js 事件循环、暂停任何其他代码的执行，直到衍生的进程退出。阻塞这些调用对于简化通用的脚本任务和简化应用程序配置在启动时的加载或处理都非常有用。 child_process.execFileSync(file[, args][, options])child_process.execFileSync() 方法通常与 child_process.execFile() 相同，但该方法在子进程完全关闭之前不会返回。 当遇到超时并且已发送 killSignal 时，该方法也需等到进程完全退出后才返回。 如果子进程拦截并处理了 SIGTERM 信号但未退出，则父进程仍将等待子进程退出。 这个函数也是和execFile()的调用栈差不多。 exeFilr()-&gt;spawnSync（lib）-&gt;spawnSync()(internal)-&gt;spawn_sync.spawn(options)(C++内建模块) child_process.execSync(command[, options])child_process.execSync() 方法通常与 child_process.exec() 相同，但该方法在子进程完全关闭之前不会返回。 当遇到超时并且已发送 killSignal 时，该方法也需等到进程完全退出后才返回。 如果子进程拦截并处理了 SIGTERM 信号但未退出，则父进程会等待直到子进程退出。 源码12345678910111213141516function execSync(command, options) &#123; const opts = normalizeExecArgs(command, options, null); const inheritStderr = !opts.options.stdio; const ret = spawnSync(opts.file, opts.options); if (inheritStderr &amp;&amp; ret.stderr) process.stderr.write(ret.stderr); const err = checkExecSyncError(ret, opts.args, command); if (err) throw err; return ret.stdout;&#125; 可以看到这个函数就没有调用exeFileSync()，而是直接调用的spawnSync()函数。下面我们再看spawnSync() child_process.spawnSync(command[, args][, options])child_process.spawnSync() 方法通常与 child_process.spawn() 相同，但在子进程完全关闭之前该函数不会返回。 当遇到超时并且已发送 killSignal 时，该方法也需等到进程完全退出后才返回。 如果进程拦截并处理了 SIGTERM 信号但未退出，则父进程会等待直到子进程退出。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function spawnSync(file, args, options) &#123; options = &#123; maxBuffer: MAX_BUFFER, ...normalizeSpawnArguments(file, args, options) &#125;; debug('spawnSync', options); // Validate the timeout, if present. validateTimeout(options.timeout); // Validate maxBuffer, if present. validateMaxBuffer(options.maxBuffer); // Validate and translate the kill signal, if present. options.killSignal = sanitizeKillSignal(options.killSignal); options.stdio = getValidStdio(options.stdio || 'pipe', true).stdio; if (options.input) &#123; const stdin = options.stdio[0] = &#123; ...options.stdio[0] &#125;; stdin.input = options.input; &#125; // We may want to pass data in on any given fd, ensure it is a valid buffer for (let i = 0; i &lt; options.stdio.length; i++) &#123; const input = options.stdio[i] &amp;&amp; options.stdio[i].input; if (input != null) &#123; const pipe = options.stdio[i] = &#123; ...options.stdio[i] &#125;; if (isArrayBufferView(input)) &#123; pipe.input = input; &#125; else if (typeof input === 'string') &#123; pipe.input = Buffer.from(input, options.encoding); &#125; else &#123; throw new ERR_INVALID_ARG_TYPE(`options.stdio[$&#123;i&#125;]`, ['Buffer', 'TypedArray', 'DataView', 'string'], input); &#125; &#125; &#125; //主要，调用internal的spawnSync的函数 return child_process.spawnSync(options);&#125; 上面都是对参数进行验证和处理。最后只是调用了child_process.spawnSync(options)函数，我们再看一下这个函数。 12345678910111213141516171819202122function spawnSync(options) &#123; const result = spawn_sync.spawn(options); if (result.output &amp;&amp; options.encoding &amp;&amp; options.encoding !== 'buffer') &#123; for (let i = 0; i &lt; result.output.length; i++) &#123; if (!result.output[i]) continue; result.output[i] = result.output[i].toString(options.encoding); &#125; &#125; result.stdout = result.output &amp;&amp; result.output[1]; result.stderr = result.output &amp;&amp; result.output[2]; if (result.error) &#123; result.error = errnoException(result.error, 'spawnSync ' + options.file); result.error.path = options.file; result.error.spawnargs = ArrayPrototypeSlice(options.args, 1); &#125; return result;&#125; 这里最重要的就是第一条语句，即调用了spawn_sync.spawn(options)函数，这个函数也是从C++导入的内部模块。 所以对于Process模块，JavaScript层面只做了参数的验证，处理，以及返回数据。（因为JavaScript的能力就止于此了），其内部具体的逻辑，都是在C++平台来处理的。而这一部分，是由libuv进行处理的，因为涉及到跨平台处理不同。 总结 名称 执行类型 同步/异步 事件处理方式 exec 命令 异步 callback回调/event监听 execFile 命令（文件） 异步 callback回调/event监听 Fork JavaScript模块 异步 event监听 execSync 命令 同步 / execFileSync 命令（文件） 同步 / 进程间通信再Master-Work中模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。对于child_process模块，创建好了子进程，然后与父子进程间通信是十分容易的。 由于Node中的进程模块实现了EventEmitter，所以可以直接使用事件监听的方式来进行通信。 用法对应的子进程有5个事件，其中包括通信的message事件。 事件 触发时间 返回 close 进程关闭 1. code 子进程自行退出时的退出码。2. signal子进程被终止的信号。 disconnect 调用父进程中的 subprocess.disconnect()或子进程中的 process.disconnect() 后会触发 &#39;disconnect&#39; 事件。 / error 1. 无法衍生进程； 2. 无法杀死进程； 3. 向子进程发送消息失败。 err 错误 exit 当子进程结束后时会触发 &#39;exit&#39; 事件。 1. code子进程自行退出时的退出码。 2. signal 子进程被终止的信号。 message 当子进程使用 process.send()发送消息时会触发 &#39;message&#39; 事件。 1. message 一个已解析的 JSON 对象或原始值。 2. sendHandle一个 net.Socket或 net.Server 对象，或 undefined。 通过Process.end()方法，可以向子进程发送消息，而主进程可以通过message事件监听子进程的消息。 而子进程可以通过内置对象process的send()方法，和同样的事件监听来与父进程通信。 示例1234567891011121314151617181920//master.jsconst cp = require('child_process')const n = cp.fork(__dirname + '/sub.js')n.on('message', (m) =&gt; &#123; console.log(`进程消息：$&#123;m&#125;`)&#125;)setTimeout(() =&gt; &#123; work.send('父进程发送消息来了')&#125;, 3000)//work.jsprocess.on('message', (m) =&gt; &#123; console.log(`进程消息：$&#123;m&#125;`)&#125;)setTimeout(() =&gt; &#123; process.send('子进程发送消息来了')&#125;, 2000) 原理为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息。 IPC的全程时Inter-Process-Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间的通信技术有很多，如管道通信、共享存储、消息传递、socket等。Node中实现IPC通信的是管道（pipe）技术。但这个管道与传统的管道有一些不同，在Node中管道是一个抽象层的称呼，具体实现细节由libuv提供，在Windows下由命名管道（named pipe）实现，*nix下则采用Unix Domain Socket。表现在应用层上的进程通信只有简单的message事件和send()方法，接口十分简洁。 句柄传递一般来说，NodeJS用于后端服务器的开发，所以多进程一般用于调动多核CPU来提高并发，那么不同的进程能否监听同一个端口来实现提高并发的目的呢？ 1234567891011121314151617181920212223//work.jsconst http = require('http')http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-Type': 'text/pain'&#125;) res.end('Hello World')&#125;).listen(8888, '127.0.0.1')//master.jsconst fork = requrie('child_process').forkfor(let i = 0; i &lt; 2; i++)&#123; for('./work.js')&#125;得到的错误如下：​```bashevents.js:187 throw er; // Unhandled 'error' event ^Error: listen EADDRINUSE: address already in use 127.0.0.1:8888 很明显，不同的进程启动同一个端口的server，肯定会引起端口占用的问题。 最开始为了解决这个问题，我们的想法是代理。即主进程对外接受所有的网络请求，再将这些请求分别代理到不同端口的进程上。 通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。但是由于进程每接受到一个连接，将会用掉一个我呢见描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程地过程就会用掉两个文件描述符。操作系统地文件描述符是有限的，代理方案浪费掉一倍地文件描述符地做法影响了系统地扩展能力。 为了解决上述问题，Node在V0.5.9加入了进程间发送句柄地功能。sned()方法除了能通过IPC发送数据外，还能够发送句柄，第二个可选参数即为句柄。 句柄即一种用来标识资源地引用，它地内部包含了指向对象地文件描述符。比如句柄可以来吧标识一个socket对象，一个UDP套接字，一个管道等。因此，我们可以通过发送句柄来达到更高地多核利用效率。下面是一个例子（传递一个HTTP句柄）： 123456789101112131415161718192021222324252627282930313233343536373839//master.jsconst &#123; fork &#125; = require('child_process');const net = require('net');const os = require('os');const workers = [];for (let i = 0, len = os.cpus().length; i &lt; len; i++) &#123; const worker = fork('./work.js'); workers.push(worker); console.log('创建新进程：'+worker.pid)&#125;const server = net.createServer();server.listen(9527, () =&gt; &#123; workers.forEach(worker =&gt; &#123; worker.send('SERVER', server); &#125;); //关闭主服务器 server.close();&#125;);//work.jsconst http = require('http');// 创建每个协助进程的 http 服务器，不监听任何端口号const httpServer = http.createServer((req, res) =&gt; &#123; res.end(`Hello world by $&#123;process.pid&#125;\\n`);&#125;);process.on('message', (msg, tcpServer) =&gt; &#123; // 如果是 master 传递来的 tcp server if (msg === 'SERVER') &#123; // 新连接建立的时候触发 tcpServer.on('connection', socket =&gt; &#123; // 把 tcp server 的连接转给 http server 处理 httpServer.emit('connection', socket); &#125;); &#125;&#125;); 可以看到，我们在主进程发送完句柄之后，即关闭监听，也就是说，将所有的请求处理都交给子进程，这样可以做到权责分明。结构图如下： 同端口监听的原理句柄的发送与还原目前子进程对象的send()方法可以发送的句柄类型包括如下几种： net.Socket：TCP套接字。 net.Server：TCP服务器，任意建立在TCP服务上的应用层服务都可以进行传递。 net.Native：C++层面的TCP套接字或IPC管道。 dgram.Socket：UDP套接字。 dgram.Native：C++层面的UDP套接字。 send()方法在将消息发送到IPC管道之前，会将消息组装称为两个对象，一个参数是handle，另一个是message。 我们简单看一下其源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//暴露用于调用的API，主要用来解析参数，后面调用_send()来进行发送target.send = function(message, handle, options, callback) &#123; if (typeof handle === 'function') &#123; callback = handle; handle = undefined; options = undefined; &#125; else if (typeof options === 'function') &#123; callback = options; options = undefined; &#125; else if (options !== undefined) &#123; validateObject(options, 'options'); &#125; options = &#123; swallowErrors: false, ...options &#125;; if (this.connected) &#123; return this._send(message, handle, options, callback); &#125; const ex = new ERR_IPC_CHANNEL_CLOSED(); if (typeof callback === 'function') &#123; process.nextTick(callback, ex); &#125; else &#123; process.nextTick(() =&gt; this.emit('error', ex)); &#125; return false; &#125;;//实际调用的API target._send = function(message, handle, options, callback) &#123; assert(this.connected || this.channel); //消息为空 if (message === undefined) throw new ERR_MISSING_ARGS('message'); // Non-serializable messages should not reach the remote // end point; as any failure in the stringification there // will result in error message that is weakly consumable. // So perform a final check on message prior to sending. if (typeof message !== 'string' &amp;&amp; typeof message !== 'object' &amp;&amp; typeof message !== 'number' &amp;&amp; typeof message !== 'boolean') &#123; throw new ERR_INVALID_ARG_TYPE( 'message', ['string', 'object', 'number', 'boolean'], message); &#125; // Support legacy function signature if (typeof options === 'boolean') &#123; options = &#123; swallowErrors: options &#125;; &#125; let obj; // Package messages with a handle object //注意：这里处理含有handle参数的情况 if (handle) &#123; // This message will be handled by an internalMessage event handler //新的message将会含有一个type属性用来标识handle的类型 message = &#123; cmd: 'NODE_HANDLE', type: null, msg: message &#125;; //判断handle种类 if (handle instanceof net.Socket) &#123; message.type = 'net.Socket'; &#125; else if (handle instanceof net.Server) &#123; message.type = 'net.Server'; &#125; else if (handle instanceof TCP || handle instanceof Pipe) &#123; message.type = 'net.Native'; &#125; else if (handle instanceof dgram.Socket) &#123; message.type = 'dgram.Socket'; &#125; else if (handle instanceof UDP) &#123; message.type = 'dgram.Native'; &#125; else &#123; throw new ERR_INVALID_HANDLE_TYPE(); &#125; // Queue-up message and handle if we haven't received ACK yet. if (this._handleQueue) &#123; ArrayPrototypePush(this._handleQueue, &#123; callback: callback, handle: handle, options: options, message: message.msg, &#125;); return this._handleQueue.length === 1; &#125; obj = handleConversion[message.type]; // convert TCP object to native handle object handle = ReflectApply(handleConversion[message.type].send, target, [message, handle, options]); // If handle was sent twice, or it is impossible to get native handle // out of it - just send a text without the handle. if (!handle) message = message.msg; // Update simultaneous accepts on Windows if (obj.simultaneousAccepts &amp;&amp; process.platform === 'win32') &#123; handle.setSimultaneousAccepts(true); &#125; &#125; else if (this._handleQueue &amp;&amp; !(message &amp;&amp; (message.cmd === 'NODE_HANDLE_ACK' || message.cmd === 'NODE_HANDLE_NACK'))) &#123; // Queue request anyway to avoid out-of-order messages. ArrayPrototypePush(this._handleQueue, &#123; callback: callback, handle: null, options: options, message: message, &#125;); return this._handleQueue.length === 1; &#125; 可以看到这里在接收到参数之后，会构建一个新的message对象，其中含有handle的类型。然后将其推入_handleQueue中，后面由Node进行发送。 实际上发送到IPC管道中的是该句柄的文件描述符，文件描述符实际上是一个整数值。这个message对象在写入到IPC管道时会通过JSON.stringify()进行序列化。所以最终发送到IPC管道中的信息都是字符串。send()能发送消息和句柄不代表它能够发送任意对象。 连接了IPC管道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才出发message事件将消息作为消息体传递给应用层。在这个过程中，消息对象还要被过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件interalMessage。如果message.cmd值为NODE_HANDLE，它将取出message.type值和得到的为文件描述符一起还原出一个对应的对象。这个过程如图。 端口的共同监听在了解句柄传递背后的原理之后，我们继续探索为何发送句柄后，多个进程可以监听到同一个端口。其原因就在于：我们启动独立的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。 Node底层对每个端口监听都设置了SO_REUSEADDR选项，这个选项的含义是不同的进程可以就相同的网卡和端口进行监听，这个服务器套接字可以被不同的进程复用。 但是由于独立启动的进程互相之间不知道文件描述符，所以监听相同的端口时就会失败。但对于send()发送的句柄还原出来的服务而言，他们的文件描述符时相同的，所以可以监听到相同的端口不会引发异常。 多个应用监听同一个端口时，文件描述符同一时间智能被某一个进程所用。也就是说一个连接只能由一个进程处理，这些进程服务是抢占式的。 集群稳定之路进程事件在进程除了message事件外，Node还定义了以下事件： error：当子进程无法被创建或无法被杀死或无法发送消息时会触发该事件。 exit：子进程退出时触发该事件，如果是正常退出，整个事件的第一个参数为推出码，否则为null。如果是通过kill()方法杀死的，会得到第二个参数，它标识杀死进程时的信号。 close：在子进程的标准输入输出流终止时触发该事件，参数与exit相同。 disconnect：在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。 自动重启有了父子进程之间的相关事件之后，就可以在这些关系之间创建出需要的机制。至少我们嫩巩固通过子进程的exit事件来获知其退出的消息。同时利用这个事件，当一个子进程退出时，可以重新启动一个进程来继续服务。 1234567891011121314151617181920212223242526272829let fork = require('child_process').forklet cpus = require('os').cpus()let server = require('http').createServer()server.listen(1337)let works = &#123;&#125;let createWork = function()&#123; let worker = fork(__dirname + '/worker.js') worker.on('exit', function()&#123; console.log('work' + worker.pid + 'exited.') delete workers[worker.pid] createWork() &#125;) //句柄转发 worker.send('server', server) workers[worker.pid] = worker console.log('Create worker. pid:'+worker.pid) for(let i = 0; i &lt; cpus.length; i++)&#123; createServer() &#125; process.on('exit', function()&#123; for(let pid in workers)&#123; workers[pid].kill() &#125; &#125;)&#125; 结果如下： 12345678910111213PS D:\\Test\\Node&gt; node reStart.jsCreate worker. pid:11436Create worker. pid:14868Create worker. pid:16240Create worker. pid:11044//杀死11436C:\\Users\\Administrator&gt;taskkill -F /pid 11436成功: 已终止 PID 为 11436 的进程。//自动新增进程work11436exited.Create worker. pid:15608 负载均衡多个进程的同时服务一个工作时，必须要保证每个进程都得到适量的工作，这种保证多个单元工作量公平的策略叫做负载均衡。 Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一顿工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。 这种机制一般来说是公平的，但是需要明白的是，一个进程的繁忙分为CPU繁忙和I/O繁忙两个部分构成。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够能够抢到较多的进程，形成负载不均衡的情况。 在此Node在v0.11中提供了一种的新的策略使得负载均衡更加合理，即轮转调度算法。轮转调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) % n 个进程来发送连接。在cluster模块中启用它。 Cluster模块前面介绍的child_process模块，如果完全使用该模块来完成一个集群，那么还是有一定的难度，所以Node提供了cluster模块用于更方便的实现集群。 工作原理工作进程由 child_process.fork() 方法创建，因此它们可以使用 IPC 和父进程通信，从而使各进程交替处理连接服务。 cluster 模块支持两种分发连接的方法。 第一种方法（也是除 Windows 外所有平台的默认方法）是循环法，由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程，在分发中使用了一些内置技巧防止工作进程任务过载。 第二种方法是，主进程创建监听 socket 后发送给感兴趣的工作进程，由工作进程负责直接接收连接。 理论上第二种方法应该是效率最佳的。 但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。 可能会出现八个进程中有两个分担了 70% 的负载。 因为 server.listen() 将大部分工作交给主进程完成，因此导致普通 Node.js 进程与 cluster 工作进程差异的情况有三种： server.listen({fd: 7}) 因为消息会被传给主进程，所以父进程中的文件描述符 7 将会被监听并将句柄传给工作进程，而不是监听文件描述符 7 指向的工作进程。 server.listen(handle) 显式地监听句柄，会导致工作进程直接使用该句柄，而不是和主进程通信。 server.listen(0) 正常情况下，这种调用会导致 server 在随机端口上监听。 但在 cluster 模式中，所有工作进程每次调用 listen(0) 时会收到相同的“随机”端口。 实质上，这种端口只在第一次分配时随机，之后就变得可预料。 如果要使用独立端口的话，应该根据工作进程的 ID 来生成端口号。 Node.js 不支持路由逻辑。 因此在设计应用时，不应该过分依赖内存数据对象，例如 session 和登陆等。 由于各工作进程是独立的进程，它们可以根据需要随时关闭或重新生成，而不影响其他进程的正常运行。 只要有存活的工作进程，服务器就可以继续处理连接。 如果没有存活的工作进程，现有连接会丢失，新的连接也会被拒绝。 Node.js 不会自动管理工作进程的数量，而应该由具体的应用根据实际需要来管理进程池。 虽然 cluster 模块主要用于网络相关的情况，但同样可以用于其他需要工作进程的情况。 使用将上面的代码改写为cluster的方式： 这里的setupMaster方法： setupMaster 用于修改默认的 ‘fork’ 行为。 一旦调用，将会按照 cluster.settings 进行设置。 所有的设置只对后来的 .fork() 调用有效，对之前的工作进程无影响。 唯一无法通过 .setupMaster() 设置的属性是传给 .fork() 的 env 属性。 其接受的参数为cluster.settings对象： execArgv &lt;string[]&gt; 传给 Node.js 可执行文件的字符串参数列表。默认值: process.execArgv。 exec 工作进程的文件路径。默认值: process.argv[1]。 args &lt;string[]&gt; 传给工作进程的字符串参数。默认值: process.argv.slice(2)。 cwd 工作进程的当前工作目录。默认值: undefined（从父进程继承）。 serialization 指定用于在进程之间发送消息的序列化类型。可能的值为 ‘json’ 和 ‘advanced’。有关更多详细信息，请参见child_process 的高级序列化。默认值: false。 silent 是否需要发送输出到父进程的 stdio。默认值: false。 stdio 配置衍生的进程的 stdio。 由于 cluster 模块运行依赖于 IPC，这个配置必须包含 ‘ipc’。如果提供了这个选项，则覆盖 silent。 uid 设置进程的用户标识符。参见 setuid(2)。 gid 设置进程的群组标识符。参见 setgid(2)。inspectPort | 设置工作进程的检查端口。这可以是一个数字、或不带参数并返回数字的函数。默认情况下，每个工作进程都有自己的端口，从主进程的 process.debugPort 开始递增。windowsHide 隐藏衍生的进程的控制台窗口（通常在 Windows 系统上会创建）。默认值: false。 12345678910let cluster = require('cluster')cluster.setupMaster(&#123; exec: 'worker.js'&#125;)let cpus = require('os').cpus()for(let i = 0; i &lt; cpus.length; i++)&#123; cluster.fork()&#125; 事件同样，cluster模块提供了一些事件监听： disconnect事件 exit事件 fork事件 listening事件 message事件 online事件：当衍生一个新的工作进程后，工作进程应当响应一个上线消息。 setup事件：每当 .setupMaster() 被调用时触发。 引用本文大部分参考《深入浅出nodejs》以及Node官网","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"进程机制","slug":"进程机制","permalink":"http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6/"}]},{"title":"VSCODE-插件开发1","slug":"VSCODE-插件开发1","date":"2021-04-28T12:23:38.000Z","updated":"2021-04-29T17:23:12.000Z","comments":true,"path":"2021/04/28/VSCODE-插件开发1/","link":"","permalink":"http://yoursite.com/2021/04/28/VSCODE-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911/","excerpt":"","text":"createTextEditorDecorationType(options: DecorationRenderOptions]): TextEditorDecorationType：创建一个新的装饰器。 Parameter Description options: DecorationRenderOptions 装饰类型渲染的选项 Returns Description TextEditorDecorationType 一个新的装饰器实体","categories":[{"name":"VS CODE插件","slug":"VS-CODE插件","permalink":"http://yoursite.com/categories/VS-CODE%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"VS CODE插件","slug":"VS-CODE插件","permalink":"http://yoursite.com/tags/VS-CODE%E6%8F%92%E4%BB%B6/"}]},{"title":"Node学习4-Buffer","slug":"Node学习4-Buffer","date":"2021-04-28T01:31:30.000Z","updated":"2021-04-29T08:56:35.848Z","comments":true,"path":"2021/04/28/Node学习4-Buffer/","link":"","permalink":"http://yoursite.com/2021/04/28/Node%E5%AD%A6%E4%B9%A04-Buffer/","excerpt":"","text":"BufferBuffer 对象用于表示固定长度的字节序列。 从V3.0开始，该对象就继承自Uint8Array（从V3.0版本加入的特性），且继承时带上了涵盖额外用例的方法。只要支持 Buffer 的地方，Node.js API 都可以接受普通的 Uint8Array 模块结构Buffer是一个典型的JavaScript与C++结合的模块，它将性能部分用C++实现，将非性能相关的部分用JavaScript实现。 之前说过，Buffer所占的内存不过是V8分配的，属于堆外内存。由于V8垃圾回收性能的影响，将通用的操作对象用更高效和专用的内存分配回收来管理是个不错的思路。 Buffer内存分配在最开始的Node版本中，是采用了slab分配机制，并且使用构造函数来新建一个Buffer，如： 12let bf = new Buffer(100)//新建一个长度为100的Buffer 并且在内部判断是否大于8KB来使用slab算法。 但是自V5.10版本开始时，新增了Buffer.alloc(size)。在V5.12新增了Buffer.allocUnsafe(size)。并且在与V6.0版本废除该API。 在Node启动的时候，Buffer 模块会预分配一个内部的大小为 Buffer.poolSize （默认为8KB）的 Buffer 实例，作为快速分配的内存池，用于使用 Buffer.allocUnsafe() 创建新的 Buffer 实例、或 Buffer.from(array)、或 Buffer.concat()、或弃用的 new Buffer(size) 构造器但仅当 size 小于或等于 Buffer.poolSize &gt;&gt; 1（Buffer.poolSize 除以二再向下取整）。 Buffer.alloc(size[, fill[, encoding]])该API最大的特点是，永远不会使用内部的Buffer池，而是直接分配。我们来查看其源代码： 1234567891011121314/** * Creates a new filled Buffer instance. * alloc(size[, fill[, encoding]]) */Buffer.alloc = function alloc(size, fill, encoding) &#123; assertSize(size); //有初始化的Buffer，则先申请unsafeBuffer，再填充 if (fill !== undefined &amp;&amp; fill !== 0 &amp;&amp; size &gt; 0) &#123; const buf = createUnsafeBuffer(size); return _fill(buf, fill, 0, buf.length, encoding); &#125; //无填充的话直接新建FastBuffer，FastBuffer是Uint8Array的子类 return new FastBuffer(size);&#125;; 可以看到，这里会判断是否有填充，如果没有填充或者size&lt;0，则直接返回一个FastBuffer。这里的FastBuffer时Uint8Array的一个子类，源代码如下： 12345678class FastBuffer extends Uint8Array &#123; // Using an explicit constructor here is necessary to avoid relying on // `Array.prototype[Symbol.iterator]`, which can be mutated by users. // eslint-disable-next-line no-useless-constructor constructor(bufferOrLength, byteOffset, length) &#123; super(bufferOrLength, byteOffset, length); &#125;&#125; 我们再看如果有填充并且长度不为0，则调用createUnsafeBuffer返回一个未初始化的数组，我们再来看一下其源代码： 12345678910111213// A toggle used to access the zero fill setting of the array buffer allocator// in C++.// |zeroFill| can be undefined when running inside an isolate where we// do not own the ArrayBuffer allocator. Zero fill is always on in that case.let zeroFill = getZeroFillToggle();function createUnsafeBuffer(size) &#123; zeroFill[0] = 0; try &#123; return new FastBuffer(size); &#125; finally &#123; zeroFill[0] = 1; &#125;&#125; 可以看到看到这里的定义是为了解决当运行在一个我们没有一个ArrayBuffer的分配器的独立容器时，zeroFill可能为undefined时，所以调用getZeroFillToggle来直接获取zeroFill，用来解决这个问题。 可以看到整个过程中，没有使用到缓冲池pool的代码。正因如此，这种方式，要比下面的两个API慢得多。 Buffer.allocUnsafe(size)以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，可能包含敏感数据。 该API会在size小于Buffer.poolSize的一半的时使用内部的缓冲池。让我们来看一下该API的代码： 12345678/** * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer * instance. If `--zero-fill-buffers` is set, will zero-fill the buffer. */Buffer.allocUnsafe = function allocUnsafe(size) &#123; assertSize(size); return allocate(size);&#125;; 可以看到内部先判断大小，然后直接返回allocate整个函数的返回值，我们再看allocate函数。 1234567891011121314151617function allocate(size) &#123; if (size &lt;= 0) &#123; return new FastBuffer(); &#125; //如果分配的大小小于4KB if (size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)) &#123; //剩下的缓冲池不足，则新建一个缓冲池 if (size &gt; (poolSize - poolOffset)) createPool(); const b = new FastBuffer(allocPool, poolOffset, size); poolOffset += size; alignPool(); return b; &#125; return createUnsafeBuffer(size);&#125; 可以看到这里就很明显有一个对于缓冲池的判断，如果小于size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)，即默认小于4KB，则再判断缓冲池是否够，不够就新建一个pool然后缓冲池偏移。这里本质上还是一个slab算法，我们后面再讲。 但是当不满足size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)时，会调用createUnsafeBuffer，这个函数即Buffer.alloc()有填充时处理的情况，即直接调用C++内存分配，不从缓冲池分配。 Buffer.allocUnsafeSlow(size)以这种方式创建的 Buffer 实例的底层内存是未初始化的。 Buffer 的内容是未知的，可能包含敏感数据。 刚才提到了，Buffer.allocUnsafe(size)在分配的内存小于4KB时，会使用内部的缓冲池。 这可以避免垃圾回收机制因创建太多独立的 Buffer 而过度使用。 通过消除跟踪和清理尽可能多的单个 ArrayBuffer 对象的需要，该方法可以提高性能和内存使用率。 但是当我们不想从缓冲池中分配内存，而是直接在内存中保有一小块内存时，就可以使用这个API来创建一个非内存池的Buffer。 下面我们来看一下其源代码： 123456789/** * Equivalent to SlowBuffer(num), by default creates a non-zero-filled * Buffer instance that is not allocated off the pre-initialized pool. * If `--zero-fill-buffers` is set, will zero-fill the buffer. */Buffer.allocUnsafeSlow = function allocUnsafeSlow(size) &#123; assertSize(size); return createUnsafeBuffer(size); &#125;; 可以看到代码很简单，先判断大小，然后直接调用allocUnsafeSlow，从内存直接分配。 slab算法当我们使用Buffer.allocUnsafe(size)且内存小于4KB时，就会使用内部的缓冲池，而这个缓冲池的设计就是一个slab算法。所以下面简单介绍一下这个算法。 slab算法是一种动态内存管理机制，最早诞生于SunOS系统中，目前在一些*nix系统中有广泛的应用，如FreeBSD和Linux。 简而言之，slab就是一块申请好的固定大小的内存区域。slab区域具有如下的3中状态： full：完全分配状态。 partial：部分分配状态。 empty：没有被分配状态。 下面我们看一下创建缓冲池的代码： 1234567function createPool() &#123; poolSize = Buffer.poolSize; allocPool = createUnsafeBuffer(poolSize).buffer; markAsUntransferable(allocPool); poolOffset = 0;&#125;createPool(); 可以看到实际上就是在定义后立即调用，内部调用了createUnsafeBuffer预先申请一个Buffer.poolSize的缓冲池。并且将poolOffset设置为0，即没被占用。 我们回顾之前的allocate函数： 1234567891011121314151617function allocate(size) &#123; if (size &lt;= 0) &#123; return new FastBuffer(); &#125; //如果分配的大小小于4KB if (size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)) &#123; //剩下的缓冲池不足，则新建一个缓冲池 if (size &gt; (poolSize - poolOffset)) createPool(); const b = new FastBuffer(allocPool, poolOffset, size); poolOffset += size; alignPool(); return b; &#125; return createUnsafeBuffer(size);&#125; 会发现，其在分配完缓冲池后，会做两件事： poolOffset += size：增加偏移量。 alignPool()：居中缓冲池。 第一个时间不用详细解释，即将刚才分配的内存添加到全局的poolOffset中取。 而第二个函数，我们看看其源代码： 1234567function alignPool() &#123; // Ensure aligned slices if (poolOffset &amp; 0x7) &#123; poolOffset |= 0x7; poolOffset++; &#125;&#125; 这段代码运用了两个位运算，实际上第一个判断是判断poolOffset是否超过了缓冲池的一半，如果没有，则将其定位在缓冲池一半的位置（结合上面判断新建的Buffer的大小是否小于缓冲池的一半）。即实现函数的名字：居中缓冲池。 所以，这种slab算法会造成内存的浪费，因为如果pool的前一部分非常小，只有几个字节，但是由于会进行居中缓冲池的操作，最后这个Buffer仍然会占据Buffer.poolSize &gt;&gt;&gt; 1大小的内存。 （这里我不确定是不是slab算法，因为上面的根据源代码总结出的算法与Linux中slab算法有较大的差距，而很多文章都说Node中Buffer就是slab算法，待我后续确定） Buffer 与字符编码Buffer对象可以与字符串之间进行相互转换。 字符串转Buffer字符串转Buffer主要是通过Buffer.from()函数实现： 这个函数有多个重载函数，可以实现从字符串，数组和对象的到Buffer的转换，具体参见Node官网 示例1234567891011121314151617181920212223console.log(Buffer.from('fhqwhgads', 'utf8'));// 打印: &lt;Buffer 66 68 71 77 68 67 61 64 73&gt;console.log(Buffer.from('fhqwhgads', 'utf16le'));// 打印: &lt;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00&gt;const buf1 = Buffer.from('buffer');const buf2 = Buffer.from(buf1);buf1[0] = 0x61;console.log(buf1.toString());// 打印: aufferconsole.log(buf2.toString());// 打印: bufferclass Foo &#123; [Symbol.toPrimitive]() &#123; return 'this is a test'; &#125;&#125;const buf = Buffer.from(new Foo(), 'utf8');// 打印: &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt; Node.js当前支持的编码如下： &#39;utf8&#39;: 多字节编码的 Unicode 字符。 许多网页和其他文档格式都使用 UTF-8。 这是默认的字符编码。 当将 Buffer 解码为不专门包含有效 UTF-8 数据的字符串时，则会使用 Unicode 替换字符 U+FFFD � 来表示这些错误。 &#39;utf16le&#39;: 多字节编码的 Unicode 字符。 与 &#39;utf8&#39; 不同，字符串中的每个字符都会使用 2 个或 4 个字节进行编码。 Node.js 仅支持 UTF-16 的小端序变体。 &#39;latin1&#39;: Latin-1 代表 ISO-8859-1。 此字符编码仅支持从 U+0000 到 U+00FF 的 Unicode 字符。 每个字符使用单个字节进行编码。 超出该范围的字符会被截断，并映射成该范围内的字符。 使用以上方法之一将 Buffer 转换为字符串，称为解码；将字符串转换为 Buffer，称为编码。 Node.js 还支持以下两种二进制转文本的编码。 对于二进制转文本的编码，其命名约定是相反的：将 Buffer 转换为字符串通常称为编码，而将字符串转换为 Buffer 则称为解码。 &#39;base64&#39;: Base64 编码。 当从字符串创建 Buffer 时，此编码也会正确地接受 RFC 4648 第 5 节中指定的 “URL 和文件名安全字母”。 base64 编码的字符串中包含的空格字符（例如空格、制表符和换行）会被忽略。 &#39;hex&#39;: 将每个字节编码成两个十六进制的字符。 当解码仅包含有效的十六进制字符的字符串时，可能会发生数据截断。 请参见下面的示例。 还支持以下传统的字符编码： &#39;ascii&#39;: 仅适用于 7 位 ASCII 数据。 当将字符串编码为 Buffer 时，这等效于使用 &#39;latin1&#39;。 当将 Buffer 解码为字符串时，则使用此编码会在解码为 &#39;latin1&#39; 之前额外取消设置每个字节的最高位。 通常，当在编码或解码纯 ASCII 文本时，应该没有理由使用这种编码，因为 &#39;utf8&#39;（或者，如果已知的数据始终为纯 ASCII，则为 &#39;latin1&#39;）会是更好的选择。 这仅为传统的兼容性而提供。 &#39;binary&#39;: &#39;latin1&#39; 的别名。 有关此编码的更多背景，请参阅二进制字符串。 该编码的名称可能会引起误解，因为此处列出的所有编码都是在字符串和二进制数据之间转换。 对于在字符串和 Buffer 之间进行转换，通常 &#39;utf-8&#39; 是正确的选择。 &#39;ucs2&#39;: &#39;utf16le&#39; 的别名。 UCS-2 以前是指 UTF-16 的一种变体，该变体不支持代码点大于 U+FFFF 的字符。 在 Node.js 中，始终支持这些代码点。 Buffer不支持的编码Node目前支持的编码格式依然比较少，包括在中国常用的GBK, GB2312, BIG-5等。为此，Buffer提供了一个Buffer.isEncoding()方法来判断编码是否被Node支持。 对于不支持的编码类型，可以借助Node生态圈中的模块完成转换，iconv和iconv-lite两个模块都可以支持更多的编码类型的转换，包括Windwos 125系列、ISO-8859系列、IBM/DOS代码页系列、Macintosh系列、KO18系列，以及Latin1、US-ASCII、也支持宽字节编码GBK和GB2312。 iconv-lite使用纯JavaScript实现，iconv则通过C++调用libiconv库完成。前者比后者更轻量无须编译和处理环境依赖直接使用。在性能方面，由于转码都是消耗CPU，再V8的高性能下，少了C++到JavaScript的层次转换，纯JavaScript的性能比C++表现得更好。具体使用参见： node-iconv iconv-lite 字符串拼接Buffer在使用中，通常是以一段一段得方式传输。例如下面得代码： 123456789101112let fs = require('fs')let rs = fs.createReaderStream('test.md')let data = ''rs.on(\"data\", function(chunk)&#123; data += chunk&#125;)rs.on(\"end\", function()&#123; console.log(data)&#125;) 上面这段代码常见于国外，用于流读取得师范，data事件中得获取得chunk对象即为Buffer对象。对于初学者而言，容易将Buffer当作字符串来理解，所以在接受上面示例时不会觉得有任何异常。 但是一旦流中出现宽字符时，问题就会暴露出来。如果你在通过Node开发得网站上看到�乱码符号，那么问题多半来自这里： 1data += chunk 这段代码里隐藏了toString()操作，它等价于下面得代码： 1data = data.toString() + chunk.toString() 值得注意的是：外国人得语境通常是英文环境，没有宽字符，在他们的场景中，这个toString()不会造成任何问题。但是对于宽字符的中文，却会形成问题。 其主要原因在于，每次data事件发生时，其读取的长度不一定为指定宽字符长度的整倍数，比如UTF-8中，每个字符的长度为3个字节，但是如果我们一次读取的字节为10个字节，那么前两个字符会被正常显示，但是第三个字符只录入了1/3，所以其无法正常显示，最后会被显示为�。 解决办法setEncoding()可读流还有一个设置编码的方法setEncoding()，示例如下： 1readable.setEncoding(encoding) 该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。为此，我们改进之前的程序： 12let rs = fs.createReadStream('test.md', &#123;highWaterMark: 11&#125;)rs.setEncoding('utf8') 再次执行，即可得到正常的结果，说明输出不再受Buffer大小的影响了。 这里我们可以稍微看一下这个函数的源代码（src/lib/internal/streams/readable.js）： 123456789101112131415161718192021// Backwards compatibility.Readable.prototype.setEncoding = function(enc) &#123; if (!StringDecoder) StringDecoder = require('string_decoder').StringDecoder; const decoder = new StringDecoder(enc); this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8. this._readableState.encoding = this._readableState.decoder.encoding; const buffer = this._readableState.buffer; // Iterate over current buffer to convert already stored Buffers: let content = ''; for (const data of buffer) &#123; content += decoder.write(data); &#125; buffer.clear(); if (content !== '') buffer.push(content); this._readableState.length = content.length; return this;&#125;; 可以看到，内部新建了一个StringDecoder，每次data事件发生时，decoder对象会将对得到的Buffer到String的转码，然后传递给调用者。 其中string_decoder之所以能够解决这个问题，是因为其会判断当前编码的单个字符宽度w，当第一次data事件触发的时候，就会只截取前面kw个字节的长度（k\\w &lt; total）多余的（total - k*w）个字符会被保存下来，与下次data事件传过来的字节一直再进行解析。 但是setEncoding的问题在于，其只能支持上述Buffer支持的编码，仍然不能支持GKB等编码。如果遇到这些编码，仍然会出现问题。 数组拼接我们可以将接收到的字节存储在数组中，然后通过iconv-lite等工具再来进行转码： 示例123456789101112let chunks = []let size = 0rs.on('data', function(chunk)&#123; chunks.push(chunk) size += chunk.length&#125;)rs.on('end', function()&#123; let buf = Buffer.concat(chunks, size) let str = iconv.decode(buf, 'GBK') console.log(str)&#125;) 正常的拼接方法是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度，然后调用Buffer.concat方法生成一个合并的Buffer对象。 Buffer与性能Buffer在文件I/O和网络I/O时运用广泛，尤其在网络传输中，它的性能举足轻重。在应用中，如果不是特别大的内容，我们都会使用字符串，但一旦在网络中传输，都需要转换为字符串，以二进制数据进行传输。在web应用中，从字符串到Buffer的转换时时刻刻都在发生，所以提高字符串到Buffer的转换效率，可以大幅度提高网络吞吐量。 下面是net模块的makeSyncWrite函数，在实际中，它是最后处理数据的： 1234567891011121314151617function makeSyncWrite(fd) &#123; return function(chunk, enc, cb) &#123; if (enc !== 'buffer') chunk = Buffer.from(chunk, enc); this._handle.bytesWritten += chunk.length; const ctx = &#123;&#125;; writeBuffer(fd, chunk, 0, chunk.length, null, undefined, ctx); if (ctx.errno !== undefined) &#123; const ex = errors.uvException(ctx); ex.errno = ctx.errno; return cb(ex); &#125; cb(); &#125;;&#125; 可以看到chunk = Buffer.from(chunk, enc);，如果chunk不是Buffer，则将其转换为Buffer。 所以，Node底层仍然是使用Buffer.from()来进行字符串到Buffer的转换，所以，如果是动态的字符串，我们提前转换与Node自动转换区别不大，但是如果是静态的字符串，比如各种错误提示，此时将其提前转换为Buffer，在高并发时，将大幅度提高服务器CPU的利用率。 总结对于经常写JavaScript代码的人，很容易混淆String与Buffer，实际上它们有诸多不同： String长度不定，而Buffer在定义的时候就规定了长度，之后无法改变（可以使用Buffer.concat()变相的增加长度）。 Buffer存储的是二进制数据，字符串与Buffer之间存在编码问题。 在V3版本后，Buffer即为Uint8Array的子类，所以其本质是一个数组。 String的内存由V8引擎分配、回收，而Buffer的内存由Node自己负责，不受其内存限制。 引用本文参考 《深入浅出nodejs》 Node官网 Node源码","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Buffer","slug":"Buffer","permalink":"http://yoursite.com/tags/Buffer/"}]},{"title":"NodeJS学习3-内存控制","slug":"NodeJS学习3-内存控制","date":"2021-04-27T01:13:46.000Z","updated":"2021-04-27T06:15:49.426Z","comments":true,"path":"2021/04/27/NodeJS学习3-内存控制/","link":"","permalink":"http://yoursite.com/2021/04/27/NodeJS%E5%AD%A6%E4%B9%A03-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/","excerpt":"","text":"V8的内存分配在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB），在这样的限制下，将会导致Node无法直接操作大内存对象。比如无法将一个2GB的文件读入内存中进行字符串分析处理，即使物理内存大于2GB，这样在单个Node进程的情况下，计算机的内存资源无法得到充足的使用。 造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上都是通过V8自己的方式来进行分配和管理的。V8这套内存管理机制在浏览器的应用场景下使用起来是绰绰有余，足以胜任前端页面中的所有需求。但在Node中，却限制了开发者随心所欲使用大内存的想法。 原因表层原因在于，V8最初为浏览器设计，不大可能设计大内存使用的场景。对于一个网页（在浏览器中，一个tab有一个JS线程），1.5GB已经足够使用。从官方的说法来说，以1.5GB的垃圾回收堆内存为例，V8做一次垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1s以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端无法接受，前端浏览器同样无法接受。 当然，这个限制也不是不能改变，V8依然在启动时提供可选参数来使用更多内存。 12node --max-old-space-size = 1700 //老生代，单位为MBnode --max-new-space-size = 1024 //新生代，单位为KB 但是注意，这个参数在运行中是无法改变的，一旦启动，内存分配就无法改变，这一点，确实限制了Node的发挥。 V8的垃圾回收机制之前在分析闭包的那篇文章中，全面理解JavaScript作用域与闭包，虽然详细分析了V8的内存结构，但是并没有详细分析垃圾回收机制,这里详细看一下。 V8主要的垃圾回收算法V8的垃圾回收策略主要基于分布式垃圾回收机制。在自动垃圾回收的演变过程中，人们发现暂时没有一种垃圾回收算法能够胜任所有的场景。因为在实际应用中，对象的生存周期长短不一，不同的算法只能针对特定情况具有最好的效果。为此，统计学在垃圾回收算法中产生了较大的作用，现在的垃圾回收算法按对象的存活时间将内存的垃圾回收进行不同的分代。然后分别对不同的内存施以更高效的算法。 V8的内存分代在V8中，主要讲内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象主要为存活时间较长或或者常驻内存的对象。 所以V8的堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提到的改变Node的内存限制就是用以改变新生代和老生代的内存空间的大小。 Scavenge算法在分代的基础上，新生代中的对象主要是通过Scavenge算法进行垃圾回收的。在Scavenge的具体实现中，主要采用了Cheney算法，该算法由C.J.Cheney于1970年首次发表在ACM论文上。 Cheney算法是一种采用复制的方法实现的垃圾回收算法。它讲堆的内存一分为二，每一部分空间成为semispace。在这两个semispace中，只有一个处于使用中，另一个处于空闲中。处于使用状态的semispace称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间进行分配。当开始机型垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，二非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的工程中，就是通过讲存活对象在两个semispace空间之间进行复制。 Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制决定的。但是Scavenge由于只复制存活的对象，并且对于生命周期短的场景只占少部分，所以它在时间效率上有优异的表现。 由于Scavenge是典型的空间换时间的算法，所以无法大规模的应用到所有的垃圾回收机制中。但是可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。所以，V8的堆内存分配应当如下： 实际使用的堆是新生代的两个semispace空间大小和老生代所使用的内存大小之和。 新生代向老生代的转换在V8中，在两种情况下，新生代的对象会转变为老生代的对象（对象晋升）： 当一个对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，会检查它的内存来判断这个对象是否已经经历过一次Scavenge回收，如果经历过了，将该对象从From空间复制到老生代空间中，如果没有，则复制到To空间中。 当要从From空间复制一个对象到To空间时，如果To空间的内存占用使用超过了25%，则这个对象直接晋升到老生代空间中。这个限制的原因在于当这次Scavenge回收完成后，这个To空间将会变成From空间，接下来的内存分将会在这个空间中进行。如果占比过高，会影响后续的内存分配。 Mark-Sweep &amp; Mark-Compact在老生代的对象中，由于存活对象占较大的比例，再采用Scavenge算法就会出现两个问题： 存活的对象较多，复制存活对象的效率会降低。 浪费另一半内存的弊端在这个就先会放大。 为此，V8再老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。 Mark-SweepMark-Sweep即标记清楚，它分为标记和清楚两个阶段。其核心在于，Mark-Sweep再标记阶段遍历堆中的所有对象，并标记活着的对象，再随后的清楚阶段中，只清楚没有被标记的对象。 可以看出，Scavenge中只复制或者的对象，而Mark-Sweep只清除死亡的对象。 而活对象在新生代中只占小部分，死对象在老生代只占较少部分，所以这两种算法刚好能够发挥最大性能。示意图如下（黑色表示死亡的对象）： 缺点Mark-Sweep最大问题在于一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后面的内存分配造成问题，因为可能会出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就提前触发垃圾回收，而这次回收是不必要的。 Mark-Compact为了解决上面Mark-Sweep的碎片问题，在Mark-Sweep上的基础上提出了Mark-Compact，即标记整理。他们的差别在，Mark-Compact会在对象被标记为死亡后，在整理的过程中，将活着的对象向一端移动，移动完成后，直接清理掉边界外的内存。示意图如下（白色各自为存活对象，深色格子为死亡对象，浅色对象为存活对象移动后留下的空间）： 完成移动后，就可以直接清除最右边的存活对象后面的内存区域完成回收。 但是由于Mark-Sweep与Mark-Compact的时间复杂度有很大差距，所以V8采用了结合使用的方式。将其对比如下： 参数/回收算法 Mark-Sweep Mark-Compact Scavenge 速度 较慢 很慢 较快 碎片 有 无 无 空间开销 少 少 双倍空间 发生移动 否 是 是 具体上，V8主要使用Mark-Sweep，在空间不足以对从新生代晋升过来的对象进行分配时才使用Mark-Compact。 Incremental Marking为了避免出现JavaScript逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都要讲应该逻辑暂停下来，带执行完毕垃圾回收后再恢复执行应用的逻辑，这种行为被称为”全停顿“（stop-the-world）。在V8的分布式垃圾回收中，一次小垃圾的回收只影响新生代，由于新生代默认配置得比较少，且存活对象较多，全堆垃圾回收（full垃圾回收）得标记、清理、整理等动作造成得停顿就会比较可怕，需要设法改善。 为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是将回收的时间拆分为多个小”步进“，每做完一个”步进“，就让JavaScript应用逻辑执行一会，垃圾回收与应用逻辑交替执行直到标记阶段完成。 经过改进，垃圾回收的最大停顿时间可以减少到原来的1/6左右。 V8后续还引入了延迟清理（lazy sweeping）与增量式整理（incremental compaction），让清理与整理的动作也变为增量式的。同时还引入了并行标记和并行清理，进一步利用多核性能降低每次的停顿动作。 查看日志我们可以通过在Node启动的时候加上trace_gc来查看Node的垃圾回收日志。 1node --trace_gc app.js 下面贴出一部分运行时日志示例： 12345[14632:000002A161C54EC0] 395853 ms: Scavenge 21.0 (24.3) -&gt; 19.8 (22.0) MB, 1.4 / 0.0 ms (average mu = 0.995, current mu = 0.962) allocation failure [14632:000002A161C54EC0] 395862 ms: Scavenge 20.5 (22.0) -&gt; 20.1 (22.3) MB, 2.0 / 0.0 ms (average mu = 0.995, current mu = 0.962) allocation failure [14632:000002A161C54EC0] 395870 ms: Scavenge 20.7 (22.3) -&gt; 20.4 (22.5) MB, 1.9 / 0.0 ms (average mu = 0.995, current mu = 0.962) allocation failure[14632:000002A161C54EC0] 395879 ms: Scavenge 21.1 (22.5) -&gt; 20.5 (22.8) MB, 2.3 / 0.0 ms (average mu = 0.995, current mu = 0.962) allocation failure [14632:000002A161C54EC0] 395915 ms: Mark-sweep 21.0 (22.8) -&gt; 14.1 (20.0) MB, 10.8 / 0.0 ms (+ 0.3 ms in 3 steps since start of marking, biggest step 0.1 ms, walltime since start of marking 30 ms) (average mu = 1.000, current mu = 1.000) finalize incremental marking via task GC in old space requested 通过垃圾回收日志，可以了解垃圾回收的运行状态，找出垃圾回收的哪些阶段比较耗时，触发的原因是什么。 在启动的时候加上--prof参数可以得到V8运行时的性能分析数据。期中也包含垃圾回收时占用的时间。 1node --prof app.js 这将会在文件根目录生成一个xxx-v8.log文件，从这个文件可以读到每个内存的动作（包括shared libraries, code-creation, sfi, tick等），但是仍然不是很好读，下面是一段示例代码： 123456789101112131415161718192021222324252627282930313233v8-version,7,7,299,13,-node.16,0shared-library,C:\\\\Program Files\\\\nodejs\\\\node.exe,0x7ff76b1a0000,0x7ff76cfc1000,0shared-library,C:\\\\Windows\\\\SYSTEM32\\\\ntdll.dll,0x7ffcc8750000,0x7ffcc8945000,0shared-library,C:\\\\Windows\\\\System32\\\\KERNEL32.DLL,0x7ffcc6dd0000,0x7ffcc6e8d000,0shared-library,C:\\\\Windows\\\\System32\\\\KERNELBASE.dll,0x7ffcc60c0000,0x7ffcc6388000,0shared-library,C:\\\\Windows\\\\System32\\\\WS2_32.dll,0x7ffcc7270000,0x7ffcc72db000,0shared-library,C:\\\\Windows\\\\System32\\\\RPCRT4.dll,0x7ffcc6920000,0x7ffcc6a4b000,0...code-creation,Builtin,3,156659,0x7ff76bede690,86,Constructcode-creation,Builtin,3,156665,0x7ff76bede6f0,78,ConstructVarargscode-creation,Builtin,3,156672,0x7ff76bede750,1028,ConstructWithSpreadcode-creation,Builtin,3,156678,0x7ff76bedeb70,1080,ConstructWithArrayLikecode-creation,Builtin,3,156685,0x7ff76bedefb0,142,ConstructForwardVarargscode-creation,Builtin,3,156692,0x7ff76bedf050,142,ConstructFunctionForwardVarargscode-creation,Builtin,3,156699,0x7ff76bedf0f0,328,JSConstructStubGenericcode-creation,Builtin,3,156706,0x7ff76bedf250,244,JSBuiltinsConstructStubcode-creation,Builtin,3,156712,0x7ff76bedf350,947,FastNewObject...sfi-move,0x3a2b6497110,0xde45da4bb8sfi-move,0x3a2b6497160,0xde45da3f50sfi-move,0x3a2b64971b0,0xde45da3fa0sfi-move,0x3a2b6497200,0xde45da3ff0...tick,0x7ffcc87efb14,66266607,0,0x0,6tick,0x7ffcc87efb14,66283096,0,0x0,6tick,0x7ffcc87efb14,66298653,0,0x0,6tick,0x7ffcc87efb14,66314624,0,0x0,6tick,0x7ffcc87efb14,66330633,0,0x0,6tick,0x7ffcc87efb14,66346563,0,0x0,6tick,0x7ffcc87efb14,66362684,0,0x0,6tick,0x7ffcc87efb14,66378772,0,0x0,6tick,0x7ffcc87efb14,66394645,0,0x0,6tick,0x7ffcc87efb14,66410815,0,0x0,6 我们可以通过V8提供的API： 1node --prof-process isolate-0xnnnnnnnnnnnn-v8.log &gt; processed.txt 生成profile文件，下面是例子（部分）： 123456789101112131415161718192021Statistical profiling result from .\\isolate-000001A24906A4A0-14888-v8.log, (4214 ticks, 0 unaccounted, 0 excluded). [Shared libraries]: ticks total nonlib name 4141 98.3% C:\\Windows\\SYSTEM32\\ntdll.dll 71 1.7% C:\\Program Files\\nodejs\\node.exe [JavaScript]: ticks total nonlib name 1 0.0% 50.0% LazyCompile: *resolve path.js:130:10 1 0.0% 50.0% LazyCompile: *nextPart fs.js:1433:31 [C++]: ticks total nonlib name [Summary]: ticks total nonlib name 2 0.0% 100.0% JavaScript 0 0.0% 0.0% C++ 9 0.2% 450.0% GC 4212 100.0% Shared libraries 也可以采用其他第三方工具进行分析，具体不在细讲。 解决办法V8的这些限制在浏览器端看起来很合理，一个页面很少能占用超多2GB内存，但是在服务端，这就显得捉襟见肘了，为此，Node开发了Buffer，Stream等模块，来弥补V8的不足，后面会陆续详解。 引用本文大部分参考《深入浅出nodejs》以及Node官网","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"内存控制","slug":"内存控制","permalink":"http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/"}]},{"title":"NodeJS学习2-异步的原理和应用","slug":"NodeJS学习2-异步的原理和应用","date":"2021-04-24T11:38:03.000Z","updated":"2021-04-27T06:15:13.345Z","comments":true,"path":"2021/04/24/NodeJS学习2-异步的原理和应用/","link":"","permalink":"http://yoursite.com/2021/04/24/NodeJS%E5%AD%A6%E4%B9%A02-%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/","excerpt":"","text":"内部原理理想的非阻塞异步I/O完美的异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需要在I/O完成后通过回调将数据传递给应用程序即可。 幸运的是：Linux下的AIO就是通过信号或回调来传递数据。 不幸的是：只有Linux下有，而且它还有缺陷-AIO仅支持I/O内核中的O_DIRECT方式读取，导致无法使用系统缓存。 现实的异步I/O现实更加骨感，但是要达成I/O的目标，并非难事。前面我们将场景限定在了单线程的状态下，实际上使用多线程来模拟异步，就会轻松达成效果了。通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据及性能传递，就轻松实现了异步I/O。 最初的Node在*nix平台下采用了libeio，libeio实质上依然采用的线程池与阻塞I/O模拟异步I/O。配合libev实现I/O部分，实现了异步I/O。在Node v0.9.3以后，自行实现了线程池来完成异步I/O。 而在Windows平台下，IOCP在某种程度上提供了较为理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调。用户无须考虑轮询。但是它的内部依然是线程池原理，不同之处在于这些线程池是由系统内核接受管理。 由于Windows平台和in平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的Node与下层的系定义线程池IOCP之间各自独立。Node会在编译期间判断平台，选择性编译\\nix或是win目录下的源文件到目标程序中。 而在*nix平台，对线程池也有不同的方案： The event loop follows the rather usual single threaded asynchronous I/O approach: all (network) I/O is performed on non-blocking sockets which are polled using the best mechanism available on the given platform: epoll on Linux, kqueue on OSX and other BSDs, event ports on SunOS and IOCP on Windows. As part of a loop iteration the loop will block waiting for I/O activity on sockets which have been added to the poller and callbacks will be fired indicating socket conditions (readable, writable hangup) so handles can read, write or perform the desired I/O operation. 即： Linux平台下使用epoll OSX和其他BSDs使用kqueue SunOS使用event ports Windows使用IOCP 值得注意的是： 这里的I/O不仅仅只限于磁盘文件的读写。*nix将计算机抽象了一番，磁盘文件，硬件，套接字等几乎所有的计算机资源都被抽象成为了文件，因此这里描述的阻塞和非阻塞的情况同样适用于套接字等。 平时我们提及到Node是单线程的，这里单线程仅仅只是JavaScript执行在单线程中。在Node中，无论是*nix或者windows平台，内部完成I/O任务的另有线程池。 执行原理事件循环之前在JavaScript宏任务，微任务与Event-loop简单介绍过事件循环的概念。 其在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为一个Tick，每个Tick的过程就是查看是否有事件待处理。如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行他们。然后进入下一个循环，如果不再有事件处理，就退出进程。 观察者在每一个Tick中，都是通过观察者来判断是否有事件需要处理。 每个事件循环有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。 浏览器采用了类似的机制。事件可能来自用户的点击或者加载某个文件时产生，而这些产生的事件都有对应的观察者。在Node中，事件主要来源于网络请求，文件I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O观察者等。观察者将事件进行了分类。 事件循环是一个经典的生产者/消费者模型。异步I/O，网络请求等则是网络事件的请求者，源源不断的为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。 这里用到了观察者模式，在设计模式5-发布-订阅模式（观察者模式）详细介绍过。 请求对象在异步请求回调中，从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做请求对象。 下面以fs.open()作为例子，来看一下其源代码： 1234567891011121314151617181920212223function open(path, flags, mode, callback) &#123; path = getValidatedPath(path); if (arguments.length &lt; 3) &#123; callback = flags; flags = 'r'; mode = 0o666; &#125; else if (typeof mode === 'function') &#123; callback = mode; mode = 0o666; &#125; else &#123; mode = parseFileMode(mode, 'mode', 0o666); &#125; const flagsNumber = stringToFlags(flags); callback = makeCallback(callback); const req = new FSReqCallback(); req.oncomplete = callback; binding.open(pathModule.toNamespacedPath(path), flagsNumber, mode, req);&#125; fs.open()是根据指定的路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初始操作。从代码可以看出，JavaScript层面的代码时通过调用C++核心模块进行下层的操作。其执行流程如下： 这里是JavaScript典型的调用方法： 从JavaScript调用Node的核心模块 核心模块调用C++内建模块 内建模块通过libuv进行系统调用 在libuv中，实质上调用了uv_fs_open()方法。在uv_fs_open()方法中，调用了uv_fs_req_init，将传入的参数添加到uv_fs_t请求对象上。从JavaScript层传入的参数和当前方法都被封装在这个请求对象中，其中我们最为关注的回调函数被设置在这个对象的cb上属性上： 12345678910111213INLINE static void uv_fs_req_init(uv_loop_t* loop, uv_fs_t* req, uv_fs_type fs_type, const uv_fs_cb cb) &#123; uv_req_init(loop, (uv_req_t*) req); req-&gt;type = UV_FS; req-&gt;loop = loop; req-&gt;flags = 0; req-&gt;fs_type = fs_type; req-&gt;result = 0; req-&gt;ptr = NULL; req-&gt;path = NULL; req-&gt;cb = cb;&#125; 对象封装完毕后，在Windows下，则调用QUEUE_FS_TP_JOB()=&gt;uv__req_register()=&gt;QUEUE_INSERT_TAIL()方法将这个uv_fs_t对象推入，线程池中等待执行，该方法的代码如下： 1QUEUE_INSERT_TAIL(&amp;(loop)-&gt;active_reqs, &amp;(req)-&gt;active_queue); 该方法接受2个参数： &amp;(loop)-&gt;active_reqs：要执行的方法的引用。 &amp;(req)-&gt;active_queue：事件循环队列。 至此，JavaScript调用立即返回，由JavaScript底层发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前的后续操作。当前的I/O操作在线程池中等待执行，不断是否阻塞I/O，都不会影响JavaScript线程的后续操作，如此就达到了异步的目的。 （在libuv0.1中，Windows使用的是QueueUserWorkItem()API，而在Unix使用的是默认4个的线程池，而在1.0版本中，在Windows与Unix统一了标准，都是用了线程池，更新公告如下：） Threadpool changes ~~~~~~ In libuv 0.10 Unix used a threadpool which defaulted to 4 threads, while Windows used the QueueUserWorkItem API, which uses a Windows internal threadpool, which defaults to 512 threads per process. In 1.0, we unified both implementations, so Windows now uses the same implementation Unix does. The threadpool size can be set by exporting the UV_THREADPOOL_SIZE environment variable. See :c:ref:threadpool. 请求对象时异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。 执行回调 组装好请求对象，送入I/O线程池等待执行，实际上完成了异步I/O第一部分，回调通知是第二部分。 线程池中的I/O操作调用完毕之后，会将获取的结果存储在req-&gt;result属性上，然后调用PostQueuedCompletionStatus()通知IOCP，告知当前对象操作已经完成： 1PostQueuedCompletionStatus(loop-&gt;iocp, 0, 0, NULL); PostQueuedCompletionStatus()方法的作用是向IOCP提交执行状态，并将线程归还给线程池。通过PostQueuedCompletionStatus()方法提交的状态，可以通过GetQueueCompletionStatus()提取。 在这个过程中，其实还动用了事件循环的I/O观察者。在每次Tick的执行中，它会调用IOCP相关的GetQueueCompletionStatus()方法检测线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中没然后将其作为事件处理。 I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出cb属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。 事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。 非I/O的异步API定时器setTimeout()和setInterval()与浏览器中的API是一致的，分别用于单词和多次定时器执行任务。他们的实现与异步I/O相似，只是不需要I/O线程池的参与。调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树。每次Tick执行时，会从红黑树迭代取出定时器对象，检查是否超过定时时间，如果超过，就会形成一个事件，它的回调函数会立即执行。 众所周知，定时器并不是那么准确其原因也在于事件循环，虽然事件循环非常快，但是如果某个循环占用的时间比较多，那么下次循环时，它也许已经超时很久了。 process.nextTick()process.nextTick() 会添加 callback 到下一个时间点队列。 在 JavaScript 堆栈上的当前操作运行完成之后，且允许事件循环继续之前，此队列会被完全耗尽。 此方法与setTimeout比起来，更加轻量级，因为不需要动用红黑树，创建定时器对象和迭代等操作。其代码如下： 12345678910111213141516171819202122232425262728293031323334// `nextTick()` will not enqueue any callback when the process is about to// exit since the callback would not have a chance to be executed.function nextTick(callback) &#123; validateCallback(callback); if (process._exiting) return; let args; switch (arguments.length) &#123; case 1: break; case 2: args = [arguments[1]]; break; case 3: args = [arguments[1], arguments[2]]; break; case 4: args = [arguments[1], arguments[2], arguments[3]]; break; default: args = new Array(arguments.length - 1); for (let i = 1; i &lt; arguments.length; i++) args[i - 1] = arguments[i]; &#125; if (queue.isEmpty()) setHasTickScheduled(true); const asyncId = newAsyncId(); const triggerAsyncId = getDefaultTriggerAsyncId(); const tickObject = &#123; [async_id_symbol]: asyncId, [trigger_async_id_symbol]: triggerAsyncId, callback, args &#125;; if (initHooksExist()) emitInit(asyncId, 'TickObject', triggerAsyncId, tickObject); queue.push(tickObject);&#125; 每次调用process.nextTick()方法只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。 setIMmediate()setImmediate()方法与process.nextTick()方法类似，都是将回调函数延迟执行。但是两者之间还是有一定的区别： process.nextTick()方法优先级要高于setImmediate()。 process.nextTick()的回调函数保存在一个数组中，setImmediate()的回调函数函数保存在链表中。 process.nextTick()在每轮循环中执行链表中的一个回调函数，而setImmediate()在每轮循环中执行链表中的一个回调函数。 其优先级不同的原因在于：事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每轮循环中，idle观察者先于I/O观察者，I/O观察者先于check观察者。 例子1234567891011121314151617181920process.nextTick(function()&#123; console.log('nexiTick延迟执行1')&#125;)process.nextTick(function()&#123; console.log('nexiTick延迟执行2')&#125;)setImmediate(function()&#123; console.log('setImmediate延迟执行1') process.nextTick(function()&#123; console.log('强势插入') &#125;)&#125;)setImmediate(function()&#123; console.log('setImmediate延迟执行2')&#125;)console.log('正常执行') 结果如下： 正常执行nexiTick延迟执行1nexiTick延迟执行2setImmediate延迟执行1强势插入setImmediate延迟执行2 异步编程的优势与难点优势Node带来的最大特性莫过于事件驱动的非阻塞模型。非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。 Node利用事件循环的方式，JavaScript线程池像一个分配任务和处理结果的管家，I/O线程池中的各个I/O线程都是小二。负责完成分配来的任务，小二与管家之间互不依赖，所以可以保持整体的高效率。但是由于JavaScript是单线程，所以，这个系统的极限就是JavaScript线程。换言之，Node为了解决编程模型中阻塞I/O的性能问题，采用了单线程模型，这导致Node更像是一个处理I/O密集问题的能手，而CPU密集型取决于管家的能耐如何。 而通过C++写出来的V8虽然相较于原生C++多了一个编译过程。但是性能仍然可以逼近顶尖。 难点异常处理在传统的同步编程中，通常使用Java的try/catch/final语句块来进行异常捕获。但是这对于异步编程并不适用。因为在之前提到过，异步I/O主要分为两个阶段：请求提交和处理结果。这两个阶段中间有事件循环机制，两者彼此不相关联。异步方法则通常在第一个阶段请求后立即返回，因为异常不一定发生在这个阶段，try...catch...不会生效。 在Node中为了解决这个问题，一般形成了一个约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步回调没有抛出。在这个约定中，我们在编写的异步方法上。也必须取遵循这样几个原则： 原则一：必须执行调用者传入的回调函数。 原则二：正确传递回异常供调用者判断。 示例代码中： 123456789let async = function(callback)&#123; process.nextTick(function()&#123; let res = something if(error)&#123; return callback(error) &#125; callback(null, res) &#125;)&#125; 另外可能出现的错误写法是： 12345678try&#123; req.body = JSON.parse(buf, options.receiver) callback()&#125;catch (err)&#123; err.body = buf err.status = 400 callback(err)&#125; 上述代码的意图是捕获是捕获JSON.parse()中可能出现的异常，但是却不小心包含了用户传递的回调函数。这意味着如果回调函数中有异常抛出，将会进入catch()代码块中执行，于是回调函数将会被执行两次。这样显然不是预期的结果，可能导致业务混乱。正确的代码应为✔： 12345678try&#123; req.body = JSON.parse(buf, options.reviver)&#125;catch (err)&#123; err.body = buf err.status = 400 return callback(err) //直接return，不再执行下面的操作&#125;callback() 另外还有一种方法就是将错误时执行的回调一并传递给异步函数，在异步函数出错时直接调用错误的回调函数就行了，而且现在普遍采用这种方式，典型的比如Promise.then(suc, fail)，或者Axios等框架的设计。 简单的例子如下： 12345678910let async = function(success, fail)&#123; process.nextTick(function()&#123; try&#123; let res = something success(res) &#125;catch(err)&#123; fail(err) &#125; &#125;)&#125; 如果需要更多参数，可以把函数参数设置为一个对象，现在普遍是这么做的。 函数嵌套过深这也是Node开发被人诟病最多的地方。在现代前端工程化开发中，由于采用Node作为支持，特别是在网络请求中，经常会出现嵌套过深的问题，如： 1234567891011import &#123;req1, req2, req3&#125; from 'api.js'req1().then(res1 =&gt; &#123; let param1 = res1.param req2(param).then(res2 =&gt; &#123; let param2 = res2.param req3(param).then(res3 =&gt; &#123; //DO SOMETHING WITH res3 &#125;) &#125;)&#125;) 这样的问题目前仍然困扰着开发人员。 async函数解决办法但是ES6的async函数为我们提供了一个解决该问题的途径，它可以使我们像编写同步代码一样编写异步代码，其本质是Promise的语法糖。 async函数在定义的时候需要使用async关键词，如下： 123async function req1()&#123; //REQ&#125; async函数会返回一个Promise对象，可以使用then方法获取结果。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 具体的用法可以参考ECMAScript 6 入门 用async可以将上面请求的代码改写为: 12345678import &#123;req1, req2, req3&#125; from 'api.js'async function handleReq()&#123; let param1 = await req1() let param2 = await req2(param1) let param3 = await req3(param2) return param3&#125; 目前的问题有两个（第一个也许不算）： await命令只能在async函数中使用，而async返回的是一个promise对象，也就是说，我们必须最后再调用一个then()方法用于获取结果。（或许这不算什么问题，至少让嵌套次数减少到一次） 兼容性问题： 可以看出，IE完全不支持，chrome也到55版本才支持，所以兼容性是一个很大的问题。 但是如果在工程化的前端开发中，由于多了预编译过程，所以使用ES6的语法会被转义为ES5的可接受代码。比如vue-cli中，在初始化项目时就包含了babel。 阻塞代码在Node中还有一个问题是，没有sleep()这样的线程沉睡功能，能用做延时操作的只有setInterval和setTimeout。但这两个函数并不能阻塞后面的代码执行。 很多人会使用while方式实现阻塞，但是由于Node时单线程，所以使用while会持续占用CPU进行判断，这与真正的线程沉睡相差甚远我，完全破环了事件循环的调度。官方推荐的是使用setTimeout来实现，但是问题在于，setTimeout无法阻塞后面的代码运行。 setTimeout实现实现如下： 12345setTimeout(() =&gt; &#123; //TO DO AFTER 3 SECOND&#125;, 3000)otherFunc1()otherFunc2() 这里虽然定时器内的代码会被延迟执行，但是后面的otherFunc1()，otherFunc2()都会立即执行，这样不符合我们印象中的sleep() setTimeout配合async实现刚才我们讲过async会一直等待await后的语句执行完毕，才会执行后面的语句，所以我们可以利用这个点实现sleep功能。 123456789101112131415function sleep(interval) &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, interval); &#125;)&#125;// 用法async function one2FiveInAsync() &#123; for(let i = 1; i &lt;= 5; i++) &#123; console.log(i); await sleep(1000); &#125;&#125;one2FiveInAsync(); 当然，还有一个问题就是，我们使用sleep()的函数必须定义为async函数，也就是说，外部调用该函数时，也必须定义为async，或者处理Promise。 异步编程的解决方案事件发布订阅模式事件监听器模式是一种广泛应用于异步编程的模式，是回调函数的事件化，又称为发布订阅模式。具体实现可以参见之前写过的设计模式5-发布-订阅模式（观察者模式）。 Node自身提供的event模块是发布订阅模式的一个简单实现，Node中的部分模块抖继承自它，这个模块比前端浏览器中的大量DOM事件简单，不存在事件冒泡，也不存在preventDefault()，stopPropagation()和stopImmediatePropagatiom()等控制事件传递的方法（在14.5版本中，已经写出了Event类，实现了event.bubbles,event.cancelBubble()等方法，但是还没有实现，等待后面官方实现吧）。它具有addListener/om()，once()，removeListener()，removeAllListeners()和emit()等基本的事件监听模式的方法实现。时间发布/订阅模式的操作比较简单，示例代码如下： 12345678910111213const EventEmitter = require('events');class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter();//订阅myEmitter.on('event', () =&gt; &#123; console.log('触发事件');&#125;);//发布myEmitter.emit('event'); 事件发布订阅模式一般来说有两个用处： 业务逻辑解耦，事件发布者无须关注订阅的监听器如何实现业务逻辑，甚至不用关心有多少个监听器的存在，数据通过消息的方式可以很灵活地传递。 另一个角度来看，事件监听模式也是一种钩子（hook）机制，利用钩子导出内部数据或者状态给外部的调用者。 期中HTTP请求时经典场景： 1234567891011121314151617181920212223242526272829303132333435const postData = querystring.stringify(&#123; 'msg': '你好世界'&#125;);const options = &#123; hostname: 'nodejs.cn', port: 80, path: '/upload', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(postData) &#125;&#125;;const req = http.request(options, (res) =&gt; &#123; console.log(`状态码: $&#123;res.statusCode&#125;`); console.log(`响应头: $&#123;JSON.stringify(res.headers)&#125;`); res.setEncoding('utf8'); res.on('data', (chunk) =&gt; &#123; console.log(`响应主体: $&#123;chunk&#125;`); &#125;); res.on('end', () =&gt; &#123; console.log('响应中已无数据'); &#125;);&#125;);//监听事件req.on('error', (e) =&gt; &#123; console.error(`请求遇到问题: $&#123;e.message&#125;`);&#125;);// 将数据写入请求主体。req.write(postData);req.end(); 在HTTP请求的代码种，程序员只需要将视线放在error，data，end这些业务事件点上即可，至于内部的流程如何，无需过多关注。 值得一提的是：Node对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性而考虑的。 如果对一个事件添加超过了10个监听器，将会得到一条警告。这一处设计于Node自身单线程运行有关，设计设认为太多的监听器太多可能导致内存泄漏，所以会存在这样一条警告。 1(node:4004) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 event listeners added to [MyEmitter]. Use emitter.setMaxListeners() to increase limit 调用emitter.setMaxListeners()，参数设为0或者Infinity表示不限制监听器的数量。另一方面，由于时间发布会引起一系列监听器执行，如果事件相关的监听器过多，可能存在过多占用CPU的情景。 为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误出发了error事件，EventEmitter会检查是否有对error事件添加过监听器。如果添加了，这个错误会交由监听器处理，否则这个错误会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter示例应该对error事件进行处理。 Promise/Deferred模式使用时间的方式时，执行流程需要被余预先设定。即便是分支，也需要预先设定，这是由发布/订阅模式的运行机制所决定的。下面为普通的Ajax调用： 12345$.get('/api', &#123; success: onSuccess, error: onError, complete: onComplete&#125;) 在上面的异步调用中，必须严谨的设置目标。那么是否有一种先执行异步调用，延迟传递处理的方式呢？答案就是Promise/Deferred模式。 Promise/Deferred模式最早在JavaScript框架中出现于Dojo的代码中，被广为所知则是来自jQuery1.5版本，该版本几乎重写了Ajax部分，是的调用Ajax可以通过错如下的形式。 1234$.get('./api') .success(onSuccess) .error(onError) .complete(onComplete) 这使得即使不调用success()，error()等方法，Ajax也会执行。 在原始的API中，一个事件只能处理一个回调，而通过Deffered对象，可以对事件加入任意的业务处理逻辑，示例代码如下： 123$.get('/api') .success(onSuccess1) .success(onSuccess2) Promise/Deffered模式在2009年时被Kris Zyp抽象为一个提案，发布在CommonJS规范中。随着使用Promise/Deffered模式的应用逐渐增多，Promise/Deffered提案已经抽象出Promise/A、Promise/B、Promise/D等典型的模式。随后Promise/A规范已经成为EcmaScript的官方规范。ES6中的Promise规范即为Promise/A规范。 具体的Promise原理和手写可以看我的这两篇文章： Promise的实现 Promise理解 引用本文大部分参考《深入浅出nodejs》以及Node官网","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"NodeJS学习1-模块机制","slug":"NodeJS学习1-模块机制","date":"2021-04-22T11:28:08.000Z","updated":"2021-04-24T11:37:00.730Z","comments":true,"path":"2021/04/22/NodeJS学习1-模块机制/","link":"","permalink":"http://yoursite.com/2021/04/22/NodeJS%E5%AD%A6%E4%B9%A01-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/","excerpt":"","text":"CommonJS规范commonJS制定了一套模块的规范，来解决当时JavaScript中没有完善的模块机制，但是现在ES Module已经比较成熟了，在前端工程化开发中大部分都是用的ES Module来进行模块的导入导出。 由于内容比较多，之前在JavaScript中的模块导入导出中已经介绍过基本用法。详细的内容可以看这里。 Node的模块实现Node中，模块总的分为两类： 核心模块：由Node提供的模块 文件模块：由用户编写的模块 这两类模块都会经过以下三个步骤： 路径分析 文件定位 编译执行 注意： 核心模块部分在Node源代码中就被编译为了二进制文件。Node在启动时即被载入到内存中，所以这部分核心模块在引入的时候，文件定位和编译执行这两个步骤可以省略掉，所以其加载速度要快于文件模块。文件模块则是在运行时动态加载的，需要完整的路径分析，文件定位和编译执行过程，所以起运行速度要慢于核心模块。 Node是默认缓存加载为第一优先级，无论是核心模块还是文件模块。require()方法对相同模块的二次加载一律采用缓存优先的方式。 路径分析由于require()函数接受多种标识符，所以不同标识符也有不同的分析方法。大致分为以下几类： 核心模块，如：http, fs, path等 以.或..开始的相对路径文件模块 以/开始的绝对路径文件模块 非核心路径的文件模块，如自定义的connect模块 核心模块核心模块的优先级仅次于缓存加载，其在Node中的源代码编译过程中已经编译为了二进制代码，其加载速度最快。 由于其优先级高于自定义模块，所以我们定义一个标识符与核心模块相同的自定义模块是无法被成功加载的。 路径形式的文件模块以.或..开始的标识符，都会被当作文件模块来处理。并且在初次加载时会将其转换为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。 自定义模块自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种页数的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。这与CommonJS中规定的node_modules的模块文件夹有关，但是在Node中的自定义模块的查找是一个与JavaScript中原型链查找相似，Node首先查找当前目录下的node_modules文件夹下是否存在该模块（注意这里的文件名在下面讲），然后查看父级目录下的node_modules是否存在该模块，再查看父级目录的父级目录是否存在node_modules，形成了一个链。只要在更近一层中发现该模块，即不再向外查找。 由于这种递归式的查找，所以其速度是最慢的。 模块路径： 模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。其本质就是前面提到的，当前目录下的mode_modules文件夹，父级目录下的mode_modules文件夹，父级目录的父级目录下的node_modules。 所以当我们新建一个js文件（该文件可以放在任意目录下），然后输入console.log(module.paths)。 执行该文件后就会得到一个类似下面数组的输出： 123456[ '/home/aa/bb/node_modules', '/home/aa/node_modules', '/home/node_modules', 'node_modules'] 文件定位文件扩展名分析require()函数接受不包含扩展名的文件标识符。这种情况下，Node会按.js，.json，node的次序补足扩展名，依次尝试。 在尝试的过程中，需要调用fs模块同步阻塞式的判断文件是否存在，由于Node是单线程的，所以这里可能会引起一点性能问题。所以，在使用node，json文件时，加上扩展名，会稍微提高一点速度。另外就是可以使用缓存机制，也可以大幅度的环节Node单线程阻塞调用的缺陷。 目录分析和包在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有发现对应文件，但是确得到了一个目录，这在引入自定义模块和组个模块路径进行查找时经常出现。此时，Node会将该目录作为一个包来处理。 此时，Node会在当前目录下查找package.json文件（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象。从中取得mian属性指定的文件进行定位。如果文件名缺少扩展名，将会重复上面的扩展名分析过程。 如果mian属性指定的文件名错误，或者和没有package.json文件，Node会将index当作默认文件名，然后依次尝试查找index.js,index.json,index.node。 如果上面的过程都没有定位到任何文件，则定义模块进入下一个模块路径（上一级路径）进行查找。 如果所有路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。 模块编译在Node中，每个文件模块都是一个对象，它的定义如下： 12345678910function Module(id, parent)&#123; this.id = id this.exports = &#123;&#125; if(parent &amp;&amp; parent.children)&#123; parend.child.push(this) &#125; this.filename = null this.loaded = false this.children = []&#125; 编译和执行时引入文件模块的最后一个阶段。定位到具体文件后，Node会新建一个模块对象，然后根据路径载入并编译。具体不同的文件会有不同的处理方法： js文件：通过fs模块同步读取文件后编译执行。 node文件：用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生效的文件。 json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果。 其余扩展名文件：它们会被当作js文件载入。 JavaScript模块的编译在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function(exports, require, __filename, __dirname){\\n，在尾部添加了\\n})，则一个正常的JavaScript文件会被包装成如下的样子： 123456(function(exports, require, module, __filename, __dirname)&#123; let math = require('math') export.area = function(radius)&#123; return math.PI * radius * radius &#125;&#125;) 即形成了一个闭包，这样每个模块文件之间都进行了作用域隔离。包装过后的代码会通过vm原生的runInThisContext()方法执行（类似于eval，只是具有明确的上下文，不污染全局），返回一个function对象。在这一个过程后，模块就会具有exports属性,require方法，module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个funciton执行。 注意：模块中的exports是module.export的一个形参传递，所以我们必须向module.export添加对象，否则无法添加导出属性。 C/C++模块的编译Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和*nix平台下分别有不同的实现，通过libnv兼容层进行了封装。 实际上，.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译产生的，所以这里只有加载和执行过程。在执行过程中，模块的exports对象与.node魔窟啊产生联系，然后返回给调用者。 C/C++模块给Node使用者带来的优势主要是执行效率方面的，劣势则是C/C++模块的编写门槛比JavaScript高。 JSON文件的编译.json文件的编译是3种编译方式中最简单的。Node利用fs模块同步读取JSON文件文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋值给模块对象的exports，以供外部调用。 JSON文件在用做项目的配置文件时比较有用。如果你定义了一个JSON文件作为配置，那就不必调用fs模块去异步读取和解析，直接调用require()即可引入。 核心模块Node的核心模块在编译成为可执行文件的过程中被编译进了二进制文件，核心模块也分为C/C++编写的和JavaScript编写的两部分，期中C/C++文件存放在Node项目中的src目录下，JavaScript文件存放在lib目录下。 JavaScript核心模块的编译过程在编译所有C/C++文件之前，编译程序需要将所有的JavaScript模块文件编译为C/C++代码，但此时并不会将其编译为可以执行的C/C++代码，而是将其以字符串的形式存储在数组中。具体过程如下： 转存为C/C++代码Node采用了V8自带的js2c.py工具，将所有内置的JavaScript代码（src/node.js和lib/*.js）转换为C++里的数组，生成node_natives.h头文件中。 在这个过程中，JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。 编译JavaScript核心模块lib目录下的所有文件也没有定义require,module,exports这些变量。所以也需要经历文件模块的编译过程。但与文件模块不同的是：获取源代码的位置，核心模块在启动时就被载入内存，所以调用时是直接从内存中取；而文件模块还需要从磁盘中读取。这个速度差别很大。 在代码实现中是通过process.binding(&#39;natives&#39;)取出，编译成功的模块缓存到NativeModule._cache对象中，文件模块则缓存到Module._cache上。 123456789function NativeModule(id)&#123; this.fileName = id + '.js' this.id = id this.exports = &#123;&#125; this.loading = false&#125;NativeModule._source = process.binding('navives')NativeModule._cache = &#123;&#125; C/C++模块的编译过程在核心模块中，大致分为两类： 全部由C/C++编写，我们称为内建模块。 由C/C++完成核心部分，其他部分则由JavaScript实现包装或向外导出。 第二种情况下 一 般是以C/C++完成核心功能，由JavaScript实现包装或向外导出，这样可以平衡脚本语言与静态语言的开发速度与运行效率。 内建模块的组织形式在Node中，内建模块的内部结构定义如下，其在node.h中： 1234567891011struct node_module &#123; int nm_version; unsigned int nm_flags; void* nm_dso_handle; const char* nm_filename; node::addon_register_func nm_register_func; node::addon_context_register_func nm_context_register_func; const char* nm_modname; void* nm_priv; struct node_module* nm_link;&#125;; 每个内建模块在定义之后，都通过NODE_MODULE宏定义到node命名空间中，模块的具体初始化方法挂在为结构的register_func成员： 12345678910#define NODE_MODLE(modname, regfunc)&#123; extern \"C\"&#123; NODE_MODULE_EXPORT node::node_module_struct modname ## _module= &#123; NODE_STANDARD_MODULE_STUFF, regfunc, NODE_STRINGFY(modename) &#125; &#125;&#125; node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有： node_buffer node_crypto node_evals node_fs node_http_parser node_os node_zlib node_timer_wrap node_udp_wrap node_pipe_wrap node_cares_wrap node_tty_wrap node_process_wrap node_fs_event_wrap node_signal_watcher 这些内建模块通过Node提供的get_buildin_module()方法从node_module_list数组中取出这些模块。 内建模块的优势： 由C/C++编写，所以性能上由于脚本语言。 直接被加载收到内存中，速度快于从磁盘中查找。 内建模块的导入导出通常来说，在Node中，由JavaScript编写的核心模块依赖于C/C++编写的内建模块。而文件模块一般依赖于核心模块，而不是直接调用内建模块。 Node在启动时候，会生成一个全局变量process，并会提供一个Binding()方法用来协助内建模块。 C/C++扩展模块C/C++扩展模块是属于文件模块得一类。C/C++模块通过预编译为.node文件，在调用process.dlopen()方法来加载执行。 注意：.node文件实际上是编译过后得二进制文件，所以在不同平台下是不同的，在Windows下，其就是一个.dll文件，在*nix下，其是一个.so文件，加一个.node是为了看起来更自然。 在dlopen()中，实现了分平台加载.so，.dll的方法。 所以一个不同的.node文件是无法混用的，必须重新在其平台下编译成正确的.node文件。 前提条件 GYP项目生成工具：Node编译工具，可以通过npm install -g node-gyp命令安装。 V8引擎C++库：V8是Node自身动力来源之一。它自身由C++写成，可以实现JavaScript与C++互相调用。 libuv库：libuv也是Node自身的动力来源之一。其是一个跨平台的一层封装，通过它去调用一些底层操作，比自己在各个平台下编写实现要高效得多。libuv封装得功能包括事件循环、文件操作等。 Node内部库：写C++模块时，免不了要做一些面向对象得编程工作，而Node自身提供了一些C++代码，比如node::ObjectWrap类可以用来包装你的自定义类，它可以帮助实现对象回收等工作。 其他库：其他存在deps目录下的库在编写扩展模块时也许可以帮助你，比如zlib,openssl,http_parser等。 C/C++扩展模块的编写与核心模块的编写不同，普通的扩展模块不需要无须将源代码编译进Node，而是通过dlopen()方法动态加载。所以在编写普通模块时，无须将源代码写入node命名空间，也不需要提供头文件。 例子编写JavaScript写法： 123exports.sayHello = function()&#123; return 'Hello world'&#125; C++写法： 12345678910111213141516171819202122232425// hello.cc#include &lt;node.h&gt;namespace demo &#123;using v8::FunctionCallbackInfo;using v8::Isolate;using v8::Local;using v8::Object;using v8::String;using v8::Value;void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); args.GetReturnValue().Set(String::NewFromUtf8( isolate, \"Hello world\").ToLocalChecked());&#125;void Initialize(Local&lt;Object&gt; exports) &#123; NODE_SET_METHOD(exports, \"sayHello\", Method);&#125;NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)&#125; // 命名空间示例 编译在不同的平台都可以使用GYP工具进行编译。 首先需要编写.gyp项目文件。node-gyp约定.gyp文件为bidning.gyp，其内容示例如下： 123456789101112131415161718&#123; 'target': [ &#123; 'target_name': 'hello', 'source': [ 'src/hello.cc' ], 'condition': [ [ 'OS == \"win\"', &#123; 'libraries': ['-lnode.lib'] &#125; ] ] &#125; ]&#125; 然后调用 1$ node-gyp configure 接下来会生成一些其他文件，在*nix平台下，会生成Makefile等文件；在Windows下，则会生成vcxproj等文件。 1node-gyp build 此时gyp会根据平台，分别进行make或vcbuild进行编译。编译完成后，hello.node文件会生成了build/Release目录下。 注意： Node.js 使用了静态链接库，比如 V8、libuv 和 OpenSSL。 所有的插件都需要链接到 V8，也可能链接到任何其他的依赖项。 通常情况下，只要简单地引入相应的 #include &lt;...&gt; 声明（如 #include &lt;v8.h&gt;），则 node-gyp 将会自动地定位到相应的头文件。 但是也有一些注意事项需要留意： 当 node-gyp 运行时，它将会检测指定的 Node.js 发行版本，并下载完整的源代码包或只是头文件。 如果下载了完整的源代码，则插件将会具有对完整的 Node.js 依赖项的完全访问权限。 如果只下载了 Node.js 的头文件，则只有 Node.js 公开的符号可用。 可以使用 --nodedir 标志指向本地的 Node.js 源代码镜像来运行 node-gyp。 如果使用此选项，则插件将有权访问全部依赖项。 注意：工具之间存在兼容性问题，最开始我在实验时的版本是: Visual Studio -2019 Node.js -12.14.0 node-gym -8.0.0 python -3.9 结果一直报语法错误，示例如下： 12345678910111213 Hello.ccD:\\Test\\Node\\native\\Hello.cc(16,25): error C2039: \"ToLocalChecked\": 不是 \"v8::Local&lt;v8::String&gt;\" 的成员 [D:\\Test\\Node\\native\\build\\hello.vcxproj]C:\\Users\\Administrator\\AppData\\Local\\node-gyp\\Cache\\12.14.0\\include\\node\\v8.h(1311): message : 参见“v8::Local&lt;v8::String&gt;”的声明 [D:\\Test\\Node\\native\\build\\hello.vcxproj]gyp ERR! build error gyp ERR! stack at ChildProcess.onExit (C:\\Users\\Administrator\\AppData\\Roaming\\nvm\\v12.14.0\\node_modules\\node-gyp\\lib\\build.js:194:23)gyp ERR! stack at ChildProcess.emit (events.js:210:5)gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12)gyp ERR! System Windows_NT 10.0.19042gyp ERR! command \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js\" \"build\"gyp ERR! cwd D:\\Test\\Node\\nativegyp ERR! node -v v12.14.0gyp ERR! node-gyp -v v8.0.0gyp ERR! not ok 网上貌似错误经验不多，我折腾了很久，最后决定换以下node版本，这里使用了nvm版本切换工具。转为最新的15.5.1版本，然后就成功构建了。 C/C++扩展模块的加载得到hello.node文件后，直接通过require()方法来进行标识符解析，路径解析，文件定位，然后加载执行即可。 示例123//main.jsconst hello = require('./build/Release/hello.node')console.log(hello.sayHello()) 调用流程实际上，require()在引入.node文件的过程中，实际上经历了4个层面上的调用。 加载.node文件实际上经历了两个步骤： 调用uv_dlopen()方法去打开动态链接库。 调用uv_dlsym方法找到动态链接库中通过NODE_MODULE宏定义的方法地址。 这两个步骤都是通过libuv库进行封装的： 在*nix平台下实际上调用的是dlfcn.h头文件中定义的dlopen()和dlsym()两个方法； 在Windows平台则是通过LoadLibraryExW()和GetProcAddress()这两个方法实现的。他们分别加载.so和.dll文件（即.node文件） 即我们一般不直接调用process.dlopen()，而是通过require()来获取编写的Node模块。在process.md中写到： process.dlopen(module, filename[, flags]) * module {Object} * filename {string} * flags {os.constants.dlopen} \\Default:** os.constants.dlopen.RTLD_LAZY The process.dlopen() method allows dynamically loading shared objects. It is primarily used by require() to load C++ Addons, and should not be used directly, except in special cases. In other words, [require()][] should be preferred over process.dlopen() unless there are specific reasons such as custom dlopen flags or loading from ES modules. 所以最后总结一下Node中各种模块之间的关系则为： 引用本文大部分参考《深入浅出nodejs》 以及： C++ 插件 node-gyp","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"模块","slug":"模块","permalink":"http://yoursite.com/tags/%E6%A8%A1%E5%9D%97/"}]},{"title":"设计模式6-命令模式与组合模式","slug":"设计模式6-命令模式与组合模式","date":"2021-04-21T02:06:08.000Z","updated":"2021-04-24T14:45:51.743Z","comments":true,"path":"2021/04/21/设计模式6-命令模式与组合模式/","link":"","permalink":"http://yoursite.com/2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"命令模式定义命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 主要解决在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 优缺点优点 通过引入中间件（抽象接口）降低系统的耦合度。 扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。 可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。 缺点 可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。 命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。 实现主要角色 抽象命令类（abstract command）：声明执行的接口，拥有执行命令的抽象方法execute()。 具体命令类（concrete command）：是抽象类的具体实现类，它拥有接收者对象，并通过调用接受者的功能来完成命令要执行的操作。 接收者（receiver）：执行命令功能的相关操作，是具体命令对象业务的真正实现者。 调用者（invoker）：是请求的发送者，他通常拥有很多的命令对象，并通过访问命令对象来执行相关操作，它不直接访问接收者。 代码这里以一个 抽象命令接口 1234//Order.javapublic interface Order &#123; void execute();&#125; 具体命令类 123456789101112//BuyStock.javapublic class BuyStock implements Order &#123; private Stock abcStock; public BuyStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.buy(); &#125;&#125; 123456789101112//BuyStock.javapublic class BuyStock implements Order &#123; private Stock abcStock; public BuyStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.buy(); &#125;&#125; 请求类 12345678910111213141516//Stock.javapublic class Stock &#123; private String name = \"ABC\"; private int quantity = 10; public void buy()&#123; System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] bought\"); &#125; public void sell()&#123; System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] sold\"); &#125;&#125; 命令调用类 12345678910111213141516171819//Broker.javaimport java.util.ArrayList;import java.util.List; public class Broker &#123; private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); public void takeOrder(Order order)&#123; orderList.add(order); &#125; public void placeOrders()&#123; for (Order order : orderList) &#123; order.execute(); &#125; orderList.clear(); &#125;&#125; 使用 Broker 类来接受并执行命令。 1234567891011121314151617public class CommandPatternDemo &#123; public static void main(String[] args) &#123; Stock abcStock = new Stock(); //新建具体命令 BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); //创建执行类 Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); //执行 broker.placeOrders(); &#125;&#125; 图解 JavaScript中的命令模式在JavaScript中，我们无须那么麻烦的创建类。由于函数在JS中作为一等公民，本身就可以作为参数进行传递。所以不一定要将其封装在execute方法中，而是直接将其作为字面量对象的成员进行传递。 比如按钮点击事件的添加： 12345678910111213141516171819202122let bindClick = function(button, func)&#123; button.onClick = func&#125;let MenuBar = &#123; refresh: function()&#123; console.log('刷新子菜单') &#125;&#125;let SubMenu = &#123; add: function()&#123; console.log('添加子菜单') &#125;, del: function()&#123; consle.log('删除子菜单') &#125;&#125;bindClick(button1, MenuBar.refresh)bindClick(button2, SubMenu.add)bindClick(button3, SubMenu.del) 组合模式定义组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 主要解决它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 宏命令宏命令包含了一组具体的子命令对象，不管是宏命令，还是子命令，都有一个execute方法负责执行命令。 1234567891011121314151617181920212223242526272829303132333435363738let CloseDoorCommand = &#123; execute: function()&#123; console.log('关门') &#125;&#125;let openPCCommand = &#123; execute: function()&#123; consoloe.log('开电脑') &#125;&#125;let openQQCommand = &#123; execute: function()&#123; console.log('登录QQ') &#125;&#125;let MacroCommand = function()&#123; return &#123; commandList : [], add: function(command)&#123; this.commandList.push(command) &#125;, execute: function()&#123; for(let c of this,commandList)&#123; c.execute() &#125; &#125; &#125;&#125;let macroCommand = MacroCommand()macroCommand.add(CloseDoorCommand)macroCommand.add(openPCCommand)macroCommand.add(openQQCommand)macroCommand.execute() 在组合模式中，请求在树中传递总是遵循一种逻辑。 请求从树最顶端的对象向下传递，如果当前请求的对象是叶对象（普通子命令），也对象自身会对请求做出相应的处理；如果当前请求的对象是组合对象（宏命令），组合对象则会遍历它下属的子节点，将请求传递给这些子节点。 图解","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"命令模式","slug":"命令模式","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"name":"组合模式","slug":"组合模式","permalink":"http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"}]},{"title":"Node节点的操作","slug":"Node节点的操作","date":"2021-03-22T07:41:53.000Z","updated":"2021-03-23T12:34:17.660Z","comments":true,"path":"2021/03/22/Node节点的操作/","link":"","permalink":"http://yoursite.com/2021/03/22/Node%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"DOM操作Node 是一个接口，各种类型的 DOM API 对象会从这个接口继承。它允许我们使用相似的方式对待这些不同类型的对象；比如, 继承同一组方法，或者用同样的方式测试。 这里我们不谈其属性，只关注Node节点的操作。 Node.appendChild()Node.appendChild(aChild)方法将一个节点附加到指定父节点的子节点列表的末尾处。 值得注意的是： 该方法只接受一个参数 其参数必须是一个Node，不能接受DOMString对象 如果aChild已存在文档中，则该方法会先remove该节点，再在目标位置插入节点 其会返回插入的子节点（aChild） 兼容性如下，可以说是最起始一部分操作方法了。 ParentNode.append() ParentNode.append 方法在 ParentNode的最后一个子节点之后插入一组 Node对象或 DOMString对象。 被插入的 DOMString对象等价为 Text节点。 与appendChild不同的是： 允许追加 DOMString 对象，而 Node.appendChild() 只接受 Node 对象。 没有返回值，而 Node.appendChild() 返回追加的 Node 对象。 可以追加多个节点和字符串，而 Node.appendChild() 只能追加一个节点。 这个方法的兼容性相对差一些，但是功能全面。 Node.insertBefore()Node.insertBefore() 方法在参考节点之前插入一个拥有指定父节点的子节点。函数返回被插入过的子节点。 注意： 如果给定的子节点是对文档中现有节点的引用，insertBefore() 会将其从当前位置移动到新位置 语法1var insertedNode = parentNode.insertBefore(newNode, referenceNode); insertedNode 被插入节点(newNode) parentNode 新插入节点的父节点 newNode 用于插入的节点 referenceNode newNode 将要插在这个节点之前 如果 referenceNode 为 null 则 newNode 将被插入到子节点的末尾。 兼容性 Node.removeChildNode.removeChild() 方法从DOM中删除一个子节点。返回删除的节点。 语法12345let oldChild = node.removeChild(child);//ORelement.removeChild(child); child 是要移除的那个子节点. node 是child的父节点. oldChild保存对删除的子节点的引用. oldChild === child. 注意： 被移除的这个子节点仍然存在于内存中,只是没有添加到当前文档的DOM树中,因此,你还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量比如上例中的oldChild来保存这个节点的引用. 如果使用上述语法中的第二种方法, 即没有使用 oldChild 来保存对这个节点的引用, 则认为被移除的节点已经是无用的, 在短时间内将会被内存管理回收. Node.replaceChild()Node.replaceChild() 方法用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。 语法1let node = parentNode.replaceChild(newChild, oldChild); newChild 用来替换 oldChild 的新节点。如果该节点已经存在于 DOM 树中，则它首先会被从原始位置删除。 oldChild 被替换掉的原始节点。 兼容性 Node.cloneNodeNode.cloneNode()方法返回调用该方法的节点的一个副本. 语法1var dupNode = node.cloneNode(deep); node 将要被克隆的节点 dupNode 克隆生成的副本节点 deep 可选 是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身. 注意: 在 DOM4 规范中(实现于Gecko 13.0(Firefox 13.0 / Thunderbird 13.0 / SeaMonkey 2.10))，deep是一个可选参数。如果省略的话，参数的默认值为 true，也就是说默认是深度克隆。如果想使用浅克隆, 你需要将该参数设置为 false。 在最新的规范里，该方法的行为已经改变了，其默认值变成了 false。虽然该参数仍旧是可选的，但是你必须要为该方法设置 deep 参数，无论是为了向前还是向后兼容考虑。假如开发者没设置参数的话，Gecko 28.0 (Firefox 28 / Thunderbird 28 / SeaMonkey 2.25 / Firefox OS 1.3)) 版本的控制台会发出警告。从 Gecko 29.0 (Firefox 29 / Thunderbird 29 / SeaMonkey 2.26)) 开始该方法默认为浅复制而不是深度复制。 值得注意的是： 克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如onclick=&quot;alert(1)&quot;),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件。 在使用Node.appendChild()或其他类似的方法将拷贝的节点添加到文档中之前,那个拷贝节点并不属于当前文档树的一部分,也就是说,它没有父节点。 如果deep参数设为false,则不克隆它的任何子节点.该节点所包含的所有文本也不会被克隆,因为文本本身也是一个或多个的Text节点。 兼容性 注意:为了防止一个文档中出现两个ID重复的元素,使用cloneNode()方法克隆的节点在需要时应该指定另外一个与原ID值不同的ID Node.containsNode.contains()返回的是一个布尔值，来表示传入的节点是否为该节点的后代节点。 语法1node.contains( otherNode ) node 是否包含otherNode节点. otherNode 是否是node的后代节点. 如果 otherNode 是 node 的后代节点或是 node 节点本身.则返回true , 否则返回 false. 兼容性 Node.isEqualNode Node.isEqualNode()方法可以判断两个节点是否相等。当两个节点的类型相同，定义特征(defining characteristics)相同（对元素来说，即 id，孩子节点的数量等等），属性一致等，这两个节点就是相等的。一些具体的数据指出：多数时候的比较是根据节点的类型来的。 语法1var isEqualNode = node.isEqualNode(otherNode); otherNode: 比较是否相等的节点. 注意：这里的equal与===不同，用===比较时，比较的是node的唯一id。而这里是鸭子比较法。 Node.hasChildNodeshasChildNodes方法返回一个布尔值,表明当前节点是否包含有子节点. 总结有三种方法可以判断当前节点是否有子节点。 node.firstChild !== null node.childNodes.length &gt; 0 node.hasChildNodes() 附加可以使用element标签的innerHTML与innerText属性。以及insertAdjacentHTML方法来修改元素内部的值。 element.innerHTMLElement.innerHTML 属性设置或获取HTML语法表示的元素的后代。 注意：如果一个 , , 或 节点有一个文本子节点，该节点包含字符 (&amp;), (&lt;), 或(&gt;), innerHTML 将这些字符分别返回为&amp;, &lt; 和 &gt; 。使用Node.textContent 可获取一个这些文本节点内容的正确副本。 语法12const content = element.innerHTML;element.innerHTML = htmlString; DOMString包含元素后代的HTML序列。设置元素的 innerHTML 将会删除所有该元素的后代并以上面给出的 htmlString 替代。 注意： SyntaxError ​ 当 HTML 没有被正确标记时，设置 innerHTML 将会抛出语法错误。 NoModificationAllowedError ​ 当父元素是 Document 时，设置 innerHTML 将会提示不允许修改。 安全问题用 innerHTML 插入文本到网页中并不罕见。但这有可能成为网站攻击的媒介，从而产生潜在的安全风险问题。 12345678const name = \"John\";// assuming 'el' is an HTML DOM elementel.innerHTML = name; // harmless in this case// ...name = \"&lt;script&gt;alert('I am John in an annoying alert!')&lt;/script&gt;\";el.innerHTML = name; // harmless in this case 尽管这看上去像 cross-site scripting 攻击，结果并不会导致什么。HTML 5 中指定不执行由 innerHTML 插入的script标签。 然而，有很多不依赖&lt;script&gt;标签去执行，innerHTML 去设置你无法控制的字符串时，这仍然是一个安全问题。例如： 12const name = \"&lt;img src='x' onerror='alert(1)'&gt;\";el.innerHTML = name; // shows the alert 于这个原因，当插入纯文本时，建议不要使用 innerHTML 。取而代之的是使用 Node.textContent或者element.innerText，它不会把给定的内容解析为 HTML，它仅仅是将原始文本插入给定的位置。 兼容性 HTMLElement.innerTextinnerText 属性表示一个节点及其后代的“渲染”文本内容。与innerText一样，其可以作为一个getter，其作为一个getter的时候，获取的内容与用户光标选中后复制的内容差不多 Note: innerText 很容易与Node.textContent混淆, 但这两个属性间实际上有很重要的区别. 大体来说, innerText 可操作已被渲染的内容， 而 textContent 则不会. Node.textContentNode 接口的 textContent 属性表示一个节点及其后代的文本内容。 返回值textContent 的值取决于具体情况： 如果节点是一个 document，或者一个 DOCTYPE ，则 textContent 返回 null。 如果节点是个 CDATA section、注释、processing instruction或者 text node，textContent 返回节点内部的文本内容，例如 Node.nodeValue。 对于其他节点类型，textContent 将所有子节点的 textContent 合并后返回，除了注释和processing instructions。（如果该节点没有子节点的话，返回一个空字符串。） 注意：在节点上设置 textContent 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。 与 innerText 的区别 textContent 会获取所有元素的内容，包括&lt;script&gt;和&lt;style&gt;元素，然而 innerText 只展示给人看的元素。 textContent 会返回节点中的每一个元素。相反，innerText 受 CSS 样式的影响，并且不会返回隐藏元素的文本， 此外，由于 innerText 受 CSS 样式的影响，它会触发回流（ reflow ）去确保是最新的计算样式。（回流在计算上可能会非常昂贵，因此应尽可能避免。） 与 textContent 不同的是, 在 Internet Explorer (小于和等于 11 的版本) 中对 innerText 进行修改， 不仅会移除当前元素的子节点，而且还会永久性地破坏所有后代文本节点。在之后不可能再次将节点再次插入到任何其他元素或同一元素中。 兼容性 参考MDN","categories":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/categories/DOM/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"HTTP缓存","slug":"HTTP缓存","date":"2021-03-11T02:52:31.000Z","updated":"2021-03-11T04:26:24.396Z","comments":true,"path":"2021/03/11/HTTP缓存/","link":"","permalink":"http://yoursite.com/2021/03/11/HTTP%E7%BC%93%E5%AD%98/","excerpt":"","text":"http缓存概念http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源（是否使用缓存还需其他策略进行验证）。 常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。 http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。 http缓存的分类强缓存定义强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。 优缺点优点 直接使用本地缓存，不发送请求，因此响应速度快 缺点 可能无法及时更新服务器资源，造成站点资源的滞后更新 header字段强缓存是通过http返回头部重的Expires或者Cache-Control两个字段来控制的。 Expires该字段会返回一个绝对时间，表示该资源的失效时间，在这个时间之前，都可以直接使用缓存，即命中缓存。 比如上面的图即表示在2021年3月11日03:28:54之前该缓存都有效，即服务器可以使用强缓存，不再请求服务器。 但是这样的绝对时间也会存在问题，即浏览器在校验时间的时候，是根据client的本地时间来确定的，当本地时间与服务器差距较大时，可能存在问题。所以衍生了Cache-Control Cache-Control由于上面的问题，Cache-Control返回的就是一个相对时间，以秒为单位。由于是相对时间，并且开始就是和客户端时间相比的，所以即使客户端与服务端时间存在误差，也不会存在误差问题。 其可以是键值对或者一个单值： 单值是一个数字，如：Cache-Control:3600，代表缓存的有效期为3600s。 键值对包含以下属性： max-age 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 * 60）天，第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。 s-maxage 同 max-age，覆盖 max-age、Expires，但仅适用于共享缓存，在私有缓存中被忽略。 public 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。 private 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。 no-cache 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。 no-store 禁止缓存，每次请求都要向服务器重新获取数据。 must-revalidate指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。 比如上面的Cache-Control的max-control为max-age=600，即600s，10mins的有效期 协商缓存（当强缓存不满足的时候）协商缓存即还需要向服务器发送一个请求，根据服务器的返回消息来决定是否使用缓存。即如果命中，则http返回304，浏览器从缓存中加载资源。其是根据返回信息的HTTP头部的Last-Modify/If-Modify-Since或Etag/If-None-Match来决定是否命中协商缓存。 优缺点优点 时效性更高，根据服务器的返回消息决定是否使用缓存。 缺点 载入速度相对会降低，因为会向服务器发送请求。 header字段Last-Modify/If-Modify-Since浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。 当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。 ETag/If-None-Match与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。 ETag生成因子以Apache为例，ETag生成靠以下几种因子 文件的i-node编号，此i-node非彼iNode。是Linux/Unix用来识别文件的编号。是的，识别文件用的不是文件名。使用命令’ls –I’可以看到。 文件最后修改时间 文件大小生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。所以，理论上ETag也是会重复的，只是概率小到可以忽略。 Last-Modified相对与Etag的问题 Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。 Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。 Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 总结 参考 一文读懂http缓存（超详细） HTTP缓存机制","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"经典1-在浏览器地址栏输入URL后回车，背后所经历的步骤","slug":"经典1-在浏览器地址栏输入URL后回车，背后所经历的步骤","date":"2021-03-05T02:17:36.000Z","updated":"2021-03-11T08:57:22.494Z","comments":true,"path":"2021/03/05/经典1-在浏览器地址栏输入URL后回车，背后所经历的步骤/","link":"","permalink":"http://yoursite.com/2021/03/05/%E7%BB%8F%E5%85%B81-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%9B%9E%E8%BD%A6%EF%BC%8C%E8%83%8C%E5%90%8E%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"在浏览器地址栏输入URL后回车，背后所经历的步骤浏览器层面0、URL解析现在几乎所有浏览器都实现了地址栏快捷搜索的功能，所以这里需要判断用户输入的到底是关键词还是地址，然后进行不同的操作。 关键字使用浏览器内置的搜索引擎地址与关键词来拼接得到最终的URL。 URL对URL进行补全，编码转换等工作。 例如：用户在输入URL时，一般都不会携带协议与端口。当用户输入baidu.com的时候，浏览器会将其补全为： https://baidu.com:80。 chrome默认是补全https协议 其他操作浏览器还会进行其他操作，比如 历史记录缓存检查这一步即可以让我们直接访问之前访问过的URL。 访问限制有些浏览器会对部分网站进行拦截。 1、缓存检查根据浏览器缓存原则，其会优先检查本地是否已经有缓存文件，然后再向服务器发送请求，具体流程如下： 2.1、 浏览器检查DNS缓存（DNS查询1）浏览器检查自己是否有该域名的DNS的缓存。 操作系统层面2.2、 操作系统检查DNS缓存（DNS查询2）如果浏览器查询DNS失败，则调用系统的API进行DNS查询，系统则会先检查自己的本地缓存文件。 2.3、 路由器检查DNS缓存（DNS查询3）系统在本地文件中没有发现改DNS条目的时候，请求会依次向上请求，其中路由器也会保有自己的DNS表，也会进行查询。 2.4、ISP(Internet Service Provider) DNS缓存即互联网服务提供商（移动、联通、典型等）的DNS缓存服务器。 2.5、根域名服务器查询DNS缓存根域名服务是最高层次的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。 如果上面几步都没有查询到对应的DNS缓存，则请求会被发送到根域名服务器查询。 2.6、顶级域名服务器查询（如：org域名服务器、com域名服务器、deu域名服务器）在多数情况下，根域名服务器并不会直接返回IP地址，而是告诉请求应该去请求哪一个顶级服务器（即告诉该顶级服务器的IP地址，系统再请求顶级服务器拿到目标IP地址） 注意：应用层的DNS（域名系统）在传输层采用的是UDP协议。下面是运输层与应用的对应： 建立TCP链接由于HTTP协议是建立在TCP协议之上，所以客户端与服务器之间需要先建立TCP连接，然后再在TCP连接之上发送HTTP请求。 注意：在五层协议中： 应用层 传输层 网络层 数据链路层 物理层 中，上面4层都会有一个头部head来对正文进行封装，物理层传输的数据单位是bit，所以流程大概如下： 在服务器接受到数据包后，会对报文进行一层一层的去头部，并在每层进行处理，主要是在传输层，TCP协议会进行连接确定，即三次握手过程。 第一次 第一次握手：建立连接时，客户端发送syn包（初始序号seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。注意：这个请求不能带数据，但是会消耗一个序号。 第二次 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包（即把报文中的SYN和ACK都设为1），此时服务器进入SYN_RECV状态。 第三次 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 HTTP请求客户端请求由于HTTP是无状态的，所以HTTP只能一次一次的进行。在客户端与服务器建立TCP连接后，客户端开始发送HTTP请求，此处URL的请求是GET方式的。 服务器返回接受请求在HTTP请求到达服务器之后，一般会有一些容器来监听HTTP请求，具体的容器有： Apache Nginx IIS 这些容器会开启一个子进程来处理这个请求。 处理请求接受HTTP报文后，会对其进行解析，获得其中的一些参数（请求方法、域名、路径、来源等），然后对其中的一些参数进行验证： 验证是否接受此方法 验证请求的地址是否正确 等 重定向如果服务器对该请求地址配置了HTTP重定向，则会返回301永久重定向响应，浏览器会根据响应，重新发送HTTP请求到重定向地址。 浏览器层面（接受HTTP请求）浏览器在接受到服务器的响应消息后，会对资源进行分析。 首先是分析Response header，根据状态码做具体的动作。 如果进行了压缩（比如gzip），还需要进行解压。 然后对相应资源做缓存。 然后根据响应资源里的MIME类型去解析响应内容（比如HTML，JSON等） 渲染页面（如果响应是HTML文件）浏览器渲染过程很复杂，其基本流程为： HTML解析（构建DOM树）1. 解码（encoding）传输回来的其实一些二进制数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML代码。 2.预解析（pre-parsing）预解析做的事情是提前加载资源，减少处理事件，系统会识别一些请求资源的属性，比如img标签，video的src属性，并将其加入到请求队列中。 3. 符号化（Tokenization）符号化就是词法分析的过程，将HTML代码解析成为符号，HTML符号包括，开始标签、结束标签、属性名和属性值。 4. 构建树 注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。 在上一步符号化中，解析器获得这些标记，然后以合适的方法创建DOM对象并把这些符号插入到DOM对象中。 CSS解析（构建CSSOM树）当CSS被下载后，CSS解析器就会处理任何CSS，根据语法规范解析出所有的CSS并进行标记化，然后我们得到一个规则表。 CSS匹配规则在匹配一个节点对应的CSS规则时，是按照从右到左的顺序，例如div p { font-size :14px }，会先寻找所有的p标签然后判断它的父元素是否为div。 所以我们在写选择器的时候，尽量用id和class，不要用太多层级的选择器。 渲染树这个过程是一个DOM树与CSS规则树合并的过程。 注意：渲染树会忽略那些不需要渲染的节点，比如设置了display:none的节点。 计算通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把rem转化为px。 级联浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做specificity的公式，这个公式会通过： !important 内联样式 id、class、标签名 的顺序来计算准确的样式。 渲染阻塞在JavaScript宏任务，微任务与Event-loop中，简单介绍了浏览器进程，其中一点是JavaScript线程与GUI渲染线程无法同时进行，遇到JavaScript标签，就会暂停DOM树的解析。 所以如果要对DOM树进行操作或者不阻塞页面，应当将script标签放在body标签的底部，或者使用defer与async，下面是defer与async的区别： 布局与绘制确定渲染树中的所有节点的几何属性，位置，大小等。最后输入一个盒模型，然后遍历渲染树，将其渲染在屏幕中。 合并渲染层将以上绘制的所有图片合并，最终输出一张图片。 回流与重绘回流（reflow）当浏览器发现某个部分发生变化并且影响了布局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。 因为回流可能导致整个dom树的重新构造，所以会影响性能。 重绘(repaint)当浏览器发现某个部分发生变化但是没有影响布局的时候，比如：改变某个元素的背景色，文字颜色等，就会发生重回。 每次重绘后，浏览器还需合并渲染层并输出到屏幕上。 回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。 比如： display:none 会触发回流，而 visibility:hidden 只会触发重绘。 因为： display:none会脱离文档流，不占据页面空间； visibility:hidden,只是隐藏内容，并没有脱离文档流，会占据页面的空间。 JavaScript编译执行这里涉及到编译原理的过程，大概是： 1. 词法分析JavaScript脚本加载完成后，会首先进入词法分析阶段，首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。具体有： 分词，例如将var a = 2，分成var、a、=，2这样的词法单元。 解析：将词法单元转换为抽象语法树AST。 代码生成，将抽象语法树转换成机器指令。 2. 预编译JavaScript中有三种运行环境： 全局环境 函数环境 eval （ES6的let，const会生成块级作用域） 每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。 参考 在浏览器输入 URL 回车之后发生了什么（超详细版） 计算机网络-谢希仁","categories":[{"name":"经典面试题","slug":"经典面试题","permalink":"http://yoursite.com/categories/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"经典面试题","slug":"经典面试题","permalink":"http://yoursite.com/tags/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"设计模式5-发布-订阅模式（观察者模式）","slug":"设计模式5-发布-订阅模式","date":"2021-03-02T08:01:39.000Z","updated":"2021-03-08T01:18:53.320Z","comments":true,"path":"2021/03/02/设计模式5-发布-订阅模式/","link":"","permalink":"http://yoursite.com/2021/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"发布-订阅模式（观察者模式）定义其定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变的时候，所有依赖它的对象都会得到通知。 主要解决一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 在JavaScript中，其主要有以下两个用处： 可以广泛应用于异步编程之中，这是一种代替回调函数的方案。 发布-订阅模式可以取代对象之间的硬编码通知机制，一个对象不用再显示地调用另外一个对象的某个接口。 实现在web开发中，我们其实已经用到了发布-订阅模式，其就是DOM事件。 DOM事件例如我们给一个按钮绑定一个点击事件： 12345function click()&#123; console.log('click')&#125;document.getElmentById('button').addEventListener('click', click, false) 实际上这个事件绑定的过程也是一个发布订阅模式。我们预先将依赖添加到发布者，当发布者事件变化，即点击事件发生的时候，我们再触发该依赖。这就是一个发布订阅模式的触发过程。 简单实现除了DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布-订阅者模式可以用于任何JavaScript代码中。 首先我们要明确三个部分 指定发布者。 为发布者添加一个 缓存列表用于缓存回调函数，以用于通知订阅者。 最后发布消息的时候，发布者遍历整个缓存列表，依次触发里面存放的回调函数。 下面来进行简单的开发 123456789101112131415161718192021let publisher = &#123;&#125; //发布者publisher.cacheList = [] //缓存列表，存放订阅者的回调函数publisher.listen = function(fn)&#123; //订阅消息 this.cacheList.push(fn) //将订阅者函数添加进缓存列表&#125;publisher.trigger = function()&#123; //发布消息 for(let i = 0, len = this.cacheList.length; i &lt; len; i++)&#123; this.[cacheList].apply(this, arguments) &#125;&#125;//简单测试publisher.listen(function(time, msg)&#123; console.log(time+'的消息为'+msg)&#125;)publisher.trigger(1, '你是猪')publisher.trigger(2, '你是狗') 发布订阅者+关键字在上面的例子中，虽然能够实现发布订阅这个功能，但是还有一个问题是不同的订阅者可能需要订阅对不同的消息，所以我们需要给消息加上一个key，以表示消息的类型。 实际上只是需要将消息队列定义为对象，以表示不同的key；在发布消息时，按照key来触发消息。 12345678910111213141516171819202122232425262728293031323334353637383940let publisher = &#123;&#125; //发布者publisher.cacheList = &#123;&#125; //缓存列表，存放回调函数publisher.listen = function(key, fn)&#123; if(!this.cacheList[key])&#123; //如果还没有订阅过此类的消息，给该类消息创建一个缓存列表 this.cacheList[key] = [] &#125; this.cacheList[key].push(fn)&#125;publisher.trigger = function()&#123; let key = Array.prototype.shift.call(arguments) //发布消息 let fns = this.cacheList[key] //取出对应的消息类型 if(!fns || fns.length === 0)&#123; //如果没有订阅该消息，则返回 return false &#125; for(let i = 0, len = fns.length; i &lt; len; i++)&#123; fns[i].apply(this, arguments) //arguments是发布消息时附送的参数 &#125;&#125;//测试publiser.listen('消息类型1', function(msg)&#123; console.log('消息类型1：'+msg)&#125;)publiser.listen('消息类型2', function(msg)&#123; console.log('消息类型2：'+msg)&#125;)publisher.trigger('消息类型1', '你是猪')//消息类型1：你是猪publisher.trigger('消息类型2', '你是狗')//消息类型2：你是狗 为任何对象添加发布订阅者实际上发布者订阅者模式可以为任何对象添加，我们只需要将主要的三个属性添加到对象，即可使对象拥有发布订阅模式。 123456789101112131415161718192021let installEvent = function(obj)&#123; obj.cacheList = &#123;&#125; obj.listen = function(key, fn)&#123; if(!this.cacheList[key])&#123; //如果还没有订阅过此类的消息，给该类消息创建一个缓存列表 this.cacheList[key] = [] &#125; this.cacheList[key].push(fn) &#125; obj.trigger = function()&#123; let key = Array.prototype.shift.call(arguments) //发布消息 let fns = this.cacheList[key] //取出对应的消息类型 if(!fns || fns.length === 0)&#123; //如果没有订阅该消息，则返回 return false &#125; for(let i = 0, len = fns.length; i &lt; len; i++)&#123; fns[i].apply(this, arguments) //arguments是发布消息时附送的参数 &#125; &#125;&#125; 取消订阅的事件有时候我们需要取消订阅的事件，现在我们来实现这个功能。 12345678910111213141516let remove = function(key, fn)&#123; let fns = this.cacheList[key] if(!fns)&#123; return false &#125; if(!fn)&#123; fns &amp;&amp; (fns.length = 0) &#125;else&#123; for(let i =fns.length; i &gt; 0; i--)&#123; let _fn = fns[i] if(_fn === fn)&#123; fns.splice(i, 1) //删除订阅者的回调函数 &#125; &#125; &#125;&#125; 全局的发布-订阅对象对于每一个需要实现发布订阅模式的对象，都需要在对象上添加相同的四个属性，虽然理论上没有性能损失不大，但是我们还是可以建立一个全局的发布订阅对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let Event = (function()&#123; let cacheList = &#123;&#125; let listen, trigger, remove listen = function(key, fn)&#123; if(!cacheList[key])&#123; cacheList[key] = [] &#125; cacheList[key].push(fn) &#125; trigger = function()&#123; let key = Array.prototype.shift.call(arguments) let fns = cacheList[key] if(!fns || fns.length === 0)&#123; return false &#125; for(let i = 0,fn; fn = fns[i++];)&#123; fn.apply(this, arguments) &#125; &#125; remove = function(key, fn)&#123; let fns = cacheList[key] if(!fns)&#123; return false &#125; if(!fn)&#123; fns &amp;&amp; (fns.length = 0) &#125;else&#123; for(let l = fns.length - 1; l &gt;= 0; l--)&#123; let _fn = fns[l] if(_fn === fn)&#123; fns.splice(l, i) &#125; &#125; &#125; &#125; return &#123; listen, trigger, remove &#125;&#125;)()Event.listen('类型1', function(name)&#123; console.log('类型1：'name)&#125;)Event.trigger('类型1', '垃圾')//类型1：垃圾 全局事件的问题全局事件虽然可以解决开销，但是却出现了其他问题：命名冲突。 越来越多的发布订阅的添加，极其可能出现命名冲突的问题，由此我们如果使用全局事件，则必须使用命名空间来解决问题。 关于离线事件在异步事件中，极可能出现我们添加监订阅不够及时，使得事件已经触发了。这样就会出现预期之外的错误了。所以在这种需求中，我们需要实现离线事件。此种情况，我们可以建立一个离线事件的堆栈，当发布的时候还没有对象来订阅此事件，则暂时将其存放至离线栈，等有对象来订阅此对象的时候，我们将遍历堆栈并且依次执行这些函数。 实现下面我们将上面两点结合起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124let Event = (function()&#123; let global = sthi, Event, _default = 'default' Event = function()&#123; let _listen, _trigger, _remove, _slice = Array.prototype.slice, _shift = Array.prototype.shift, _unshift = Array.prototype.unshift, namespaceCache = &#123;&#125;, _create, find, each = function(ary, fn)&#123; let ret for(let i = 0, len = ary.length; i &lt; len; i++)&#123; let n = ary[i] ret = fn.call(n, i, n) &#125; return ret &#125; _listen = function(key, fn, cache)&#123; if(!cache[key])&#123; cache[key] = [] &#125; cache[key].push(fn) &#125; _remove = function(key, fn, cache)&#123; if(cache[key])&#123; if(fn)&#123; for(let i = cache[key].length; i &gt;= 0; i--)&#123; if(cache[key][i] === fn)&#123; cache[key].splice(i, 1) &#125; &#125; &#125;else&#123; cache[key] = [] &#125; &#125; &#125; _trigger = function()&#123; let cache = _shift.call(arguments), key = _shift.call(arguments), args = arguments, _self = this, stack = cache[key] if(!stack || !stack.length)&#123; return &#125; return each(stack, function()&#123; return this.apply(_self, args) &#125;) &#125; _create = function(namespace)&#123; let namespace = namespace || _default let cache = &#123;&#125;, offlineStack = [], ret = &#123; listen: function(key, fn, cache)&#123; _listen(key, fn, cache) if(offlineStack == null)&#123; return &#125; if(last === 'last')&#123; offlineStack.length &amp;&amp; offlineStack.pop() &#125;else&#123; each(offlineStack, function()&#123; this() &#125;) &#125; offlienStack = null &#125;, one: function(key, fn, last)&#123; _remove(key, cache) this.listen(key, fn, last) &#125;, remove: function(key, fn)&#123; _remove(key, cache, fn) &#125;, trigger: function()&#123; let fn, args, _self = this _unshift.call(arguments, cache) args = arguments fn = function()&#123; return _trigger.apply(_self, args) &#125; if(offlineStack)&#123; return offlineStack.push(fn) &#125; return fn() &#125; &#125; return namespace ? (namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret) : ret &#125; return &#123; create: _create, one: function(key, fn, last)&#123; let event = this.create() event.one(key, fn, last) &#125;, remove: function(key, fn)&#123; let event = this.create() event.remove(key, fn) &#125;, list: function(key, fn, last)&#123; let event = this.create() event.listen(key, fn, last) &#125;, trigger: function()&#123; let event = this.create() event.trigger.apply(this, arguments) &#125; &#125; &#125; return Event&#125;)() JavaScript中的发布订阅模式值得注意的是，之前我们编写的发布订阅模式，和一些其他的语言（比如Java）中的实现还是有区别的。在Java中实现一个自己的发布订阅模式，通常会把订阅者自身当作引用传入发布者对象中，同时订阅者对象还需提供一个名为诸如update的方法，供发布者对象在适合的时候调用。而在JavaScript中，我们用注册回调函数的形式来代替传统的发布订阅模式，更加方便。 参考 《JavaScript设计模式与开发实践》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"发布-订阅模式","slug":"发布-订阅模式","permalink":"http://yoursite.com/tags/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式4-迭代器模式","slug":"设计模式4-迭代器模式","date":"2021-03-01T02:30:22.000Z","updated":"2021-03-01T04:07:07.647Z","comments":true,"path":"2021/03/01/设计模式4-迭代器模式/","link":"","permalink":"http://yoursite.com/2021/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"迭代器模式定义迭代器模式是指提供一种方法顺序访问一个集合对象中的各个元素，而不需要暴露该对象的内部表示。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 主要解决不需要关心对象内部表示来遍历整个对象。 内部迭代器内部迭代器是指事先定义好迭代器的迭代规则，他完全接受整个迭代过程，外部只需要一次初始调用。 实现我们实现一个each内部迭代器，接受两个参数： arr：要被迭代的数组 fn：迭代规则函数 fn在每一次数组循环时都会执行 123456789101112131415161718const each = function(arr, fn)&#123; for(let i = 0, len = arr.length; i &lt; len; i++)&#123; fn(i, arr[i]) &#125;&#125;//调用each([1,2,3], function(index, item)&#123; console.log(index, item)&#125;)/**结果*0 1*1 2*2 3*/ 内部迭代器的缺点就是无法很好的组合个迭代，只有在一个迭代规则中嵌入另外一个迭代器，这样未必显得代码冗余，影响代码可读性。所以产生了外部迭代器。 外部迭代器外部迭代器一般会提供一个next类似的函数，没调用一次，就会返回该次迭代的结果。我们可以在外部拿到结果，进行跟多的操作。 下面我们简单实现一个外部迭代器的原型： 12345678910111213141516171819202122232425262728293031323334const Iterator = function(obj)&#123; let current = 0 let maxLen = obj.length let next = function()&#123; if(current &lt; maxLen)&#123; current++ return &#123; value: obj[current], done: false &#125; &#125;else&#123; return &#123; value: undefined, done: true &#125; &#125; &#125; return &#123; next, len: maxLen &#125;&#125;let arr = [1,2,3]let iterator_arr = Iterator(arr)iterator_arr.next()/**&#123;* value: 1,* done: false*&#125;*/ 上面的函数实现了ES6提供的Iterator接口最基本的部分。我们可以在外部拿到迭代结果，现在我们可以同时拿到两个迭代器的结果而不用嵌套迭代器。 见到那写一下两个迭代器元素的比较： 123456789let compare = function(iterator1, iterator2)&#123; //比较元素长度 if(iterator1.length !== iterator2.length)&#123; return false &#125; while(!iterator1.next().done &amp;&amp; !iterator2.next().done &amp;&amp; iterator1.next().value !== iterator2.next().value)&#123; return false &#125;&#125; JavaScript中遍历迭代器说到底还是对某种数据结构进行遍历的的一个接口。在一般的高级语言中，对于特殊的数据结构，比如数组都会封装一个方法进行遍历。而在JavaScript中，表示集合类的数据结构中，包括ES6增加的Map和Set，一共就有4种： Object Array Set Map 对于数组和对象，我在JavaScript中数组与对象的遍历方法中，进行了详细的探讨。 在那篇文章中，实际上都是数组或对象的内部迭代器的实例，比如的数组的forEach等方法。 而在ES6中，提供了原生的Iterator接口来实现外部迭代器，而在Java等语言中，早就提供了该接口。 IteratorIteratorIterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环（详见下文）。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。 ES6 规定， 默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。 Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。 属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。 如： 123456789101112const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; 上面代码中，对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。 ES6中有一些对象已经原生实现了Iterator 接口： Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 值得注意的是Object并没有原生实现iterator，原因是： 对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。 当我们对一个数组完成赋值，其Symbol.iterator属性就随之生成了。比如下面的例子： 1234567let arr = ['a', 'b', 'c']let ite = arr[Symbol.iterator]()iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 调用 Iterator 接口的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。 （1）解构赋值对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set = new Set().add('a').add('b').add('c');let [x,y] = set;// x='a'; y='b'let [first, ...rest] = set;// first='a'; rest=['b','c']; （2）扩展运算符 扩展运算符（…）也会调用默认的 Iterator 接口。 12345678// 例一var str = 'hello';[...str] // ['h','e','l','l','o']// 例二let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd'] 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。 1let arr = [...iterable]; （3）yield* yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; （4）其他场合 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])） Promise.all() Promise.race() Iterator 接口与 Generator 函数Symbol.iterator()方法的最简单实现，还是使用Generator 函数。 1234567891011121314151617181920212223let myIterable = &#123; [Symbol.iterator]: function* () &#123; yield 1; yield 2; yield 3; &#125;&#125;;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; * [Symbol.iterator]() &#123; yield 'hello'; yield 'world'; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// \"hello\"// \"world\" 上面代码中，Symbol.iterator()方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。 for…of 循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。 for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 示例12345678910111213141516171819202122232425262728//数组const arr = ['red', 'green', 'blue'];for(let v of arr) &#123; console.log(v); // red green blue&#125;//Setvar engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkit//Mapvar es6 = new Map();es6.set(\"edition\", 6);es6.set(\"committee\", \"TC39\");es6.set(\"standard\", \"ECMA-262\");for (var [name, value] of es6) &#123; console.log(name + \": \" + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 参考 《JavaScript设计模式与开发实践》 Iterator 和 for…of 循环","categories":[{"name":"迭代器模式","slug":"迭代器模式","permalink":"http://yoursite.com/categories/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"http://yoursite.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式3-代理模式","slug":"设计模式3-代理模式","date":"2021-02-27T06:32:20.000Z","updated":"2021-02-28T13:22:51.727Z","comments":true,"path":"2021/02/27/设计模式3-代理模式/","link":"","permalink":"http://yoursite.com/2021/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式定义当目标对象不方便直接访问或者访问者不满住要求的时候，提供一个代理对象来控制对目标对象的访问。访问者实际上访问的是代理对象。代理对象对请求做出一些处理之后，再把请求转交给目标对象。 主要解决在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 优缺点优点 职责清晰。 高扩展性。 智能化。 缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 远程代理（主要针对Java）远程代理可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。 Copy-on-Write 代理定义 Copy-on-write (CoW or COW), sometimes referred to as implicit sharing or shadowing, is a resource-management technique used in computer programming to efficiently implement a “duplicate” or “copy” operation on modifiable resources. 写时复制（copy-on-write，简称 CoW 或 COW），也叫隐式共享（implicit sharing）或隐藏（shadowing），是计算机编程中的一种资源管理技术，用于高效地复制或拷贝可修改资源 If a resource is duplicated but not modified, it is not necessary to create a new resource; the resource can be shared between the copy and the original. Modifications must still create a copy, hence the technique: the copy operation is deferred to the first write. By sharing resources in this way, it is possible to significantly reduce the resource consumption of unmodified copies, while adding a small overhead to resource-modifying operations. 具体的，如果复制了一个资源但没有改动，就没必要创建这个新的资源，此时副本能够与原版共享同一资源，在修改时仍需要创建副本。因此，关键在于：将拷贝操作推迟到第一次写入的时候。通过这种方式来共享资源，能够显著减少无改动副本的资源消耗，而只是略微增加了资源修改操作的开销 实例但是在JavaScript种，以前还不好对这种代理进行很好的描述，因为以前JavaScript并没有对对象属性进行监听的方法（实际上也只有obj.defineProperty），在ES6引入了Proxy之后，我们可以很方便的实现COW代理。下面给出简单实现： 123456789101112131415161718let person = &#123; name: 'tom', num: 123&#125;let p_person = new Proxy(person, &#123; get: function(target, proKey, receiver)&#123; return target[proKey] &#125;, set: function(target, propKey, value, receiver)&#123; //深拷贝一个对象 let newObj = deep_clone(target) //修改新对象的值 newObj[proKey] = value //替换proxy对象为新对象 p_preson = newObj &#125;&#125;) 上面的例子中，充分利用了JavaScript弱类型语言的特征，在最开始时将p_person赋值为Proxy对象，在执行get操作时，直接返回被访问对象的值；在执行set操作时，在对被访问对象执行深拷贝，并把p_person赋值为新对象。 但是这样存在一些问题： Proxy对象同样会占用空间，如果确定目标对象大概率会被改动，并且目标对象并不是很大，建议直接deep_clone。 Proxy对象内部的定义比较复杂，每一个对象都要重复该过程。所以我们封装一个函数，来执行这个过程。 1234567891011121314151617181920212223let person = &#123; name: 'tom', num: 123&#125;function produce_p(obj)&#123; let new_obj = new Proxy(obj, &#123; get: function (target, propKey, receiver) &#123; return target[propKey]; &#125;, set: function (target, propKey, value, receiver) &#123; //深拷贝一个对象 let newObj = deep_clone(target) //修改新对象的值 newObj[proKey] = value //替换proxy对象为新对象 new_obj = newObj &#125;, &#125;) return new_obj&#125;let person_p = produce_p(person) //代理对象 这样我们就解决了第二个问题，第一个问题是无法解决的，需要我们自行解决。 保护（Protect or Access）代理定义保护代理模式(Access Proxy), 也叫Protect Proxy. 这种代理用于对真实对象的功能做一些访问限制, 在代理层做身份验证. 通过了验证, 才调用真实的主体对象的相应方法。 这种限制，应该分为两种： 对访问来源做限制 对访问内容做限制 实例但是JavaScript中目前不能对一种进行限制（使用透明代理），我们使用ProxyAPI来实现对访问内容进行限制： 123456789101112131415//加入我们要对sex进行读限制，对person进行写限制let content = &#123; person: 'tom', place: 'park', sex: 'male'&#125;let content_p = new Proxy(content, &#123; get: function(target, propKey, receiver)&#123; return proKey === 'sex' ? false : target[proKey] &#125;, set(target, propKey, value, receiver)&#123; proKey === 'person' ? '' : target[proKey] = value &#125;&#125;) 同样的，我们也可以对content_p进行封装，创建一个工厂，以进行更好复用代码。 如果实际要对访问来源做限制，只能使用非透明的方式，即读写必须通过函数来进行操作。 1234567891011121314151617181920212223242526let content = &#123; person: 'tom', place: 'park', sex: 'male'&#125;let source1 = &#123; name: 'source1'&#125;let source2 = &#123; name: 'source2'&#125;function get(obj, prop)&#123; //限制来自于source1的访问 if(this.name === 'source1' || prop === 'sex')&#123; return false &#125;else&#123; return obj[prop] &#125;&#125;//模拟从source1来源下访问contentget.call(source1, content, 'sex')//false 缓存(Cache)代理定义缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算的时候，如果传递进来的参数与之前的一致，则直接返回结果，减少运算。 实例下面是一个对乘积进行缓存的代理： 123456789101112131415161718let mult = function&#123; let res = 1 for(let i = 0, len = arguments.length; i &lt; len; i++)&#123; res *= arguments[i] &#125; return res&#125;let proxy_mult = (function()&#123; let cache = &#123;&#125; return function()&#123; let args = Array.prototype.join.call(arguments) if(args in cache)&#123; return cahe[args] &#125; return cache[args] = mult.apply(this, arguments) &#125;&#125;)() 同样的，我们可以对proxy_mult进行封装，创建一个工厂，来生成函数工厂。 12345678910111213141516171819202122232425262728293031323334//计算乘积函数let mult = function&#123; let res = 1 for(let i = 0, len = arguments.length; i &lt; len; i++)&#123; res *= arguments[i] &#125; return res&#125;//计算加和函数let plus = function&#123; let res = 1 for(let i = 0, len = arguments.length; i &lt; len; i++)&#123; res += arguments[i] &#125; return res&#125;let proxyProxy = function(fn)&#123; let cache = &#123;&#125; return function()&#123; let args = Array.prototype.join.call(arguments) if(args in cache)&#123; return cahe[args] &#125; return cache[args] = fn.apply(this, arguments) &#125;&#125;let proxyMult = proxyProxy(mult)let proxyPlus = proxyProxy(plus)proxyMult(1,2,3,4) //24proxyPlus(1,2,3,4) //10 虚拟代理定义虚拟代理作为创建开销大的对象的代表，经常会直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理地来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。 实例合并请求减少开销这个用法其实和函数的节流效果一致，将多次操作合并为一次，以减少消耗，特别是网络请求。 比如文件同步时，虽然我们和设计checkbox来合并请求，但是并不是每个用户都会按我们设计的逻辑来进行操作。他们可能仍然一个一个的同步，这样会加大服务器的负担。所以我们可以把一段时间内的请求存储下来，每隔一段时间进行同步。以减少服务器的负担。 1234567891011121314151617181920let syncFile = function(id)&#123; //同步&#125;let proxySyncFile = (function()&#123; let ids = [] let timer return function(id)&#123; ids.push(id) if(timer)&#123; return &#125; timer = setTimeout(function()&#123; syncFile(ids.join()) claerTimeout(timer) timer = null cache.length = 0 &#125;, 2000) &#125;&#125;)() 惰性加载这个作用就是虚拟代理最初的用法。 比如我们有一个库名叫composite，其作用是 查询页面内图片的的OCR文字(picOcr) 建立页面的虚拟DOM(virtualDOM) 进行大数计算(bigNumberCalc) 用webGL绘制一个游戏(webGLGame) 可以想象，这个库的每个功能都是比较困难，所以其代码量都比较大，并且我们并不一定会使用到其所有功能，假如picOcr是最常用的模块，我们直接加载该模块。所以我们可以将其他的模块做成懒加载，需要使用时再加载。 1234567891011121314151617181920const composite = &#123; picOcr : function()&#123; //直接加载 &#125;, virtualDOM: function()&#123; let vd = _load('virtualDOM') composite.virtualDOM = vd composite.virtualDOM(arguments) &#125;, bigNumberCalc: function()&#123; //逻辑相同 &#125;, webGLGame: function()&#123; //逻辑相同 &#125;, _load: function(name)&#123; //加载模块 return get(name) &#125;&#125; 当然，上面的设计是最简单的模块设计方式，有很多问题，但是这不是我们讨论的重点，我们这里讨论的重点是延迟加载部分，可以看到 virtualDOM模块最初是没有被加载的，在调用的时候我们才通过网络加载，最后覆盖原始对象，下次调用时就是直接调用实际代码了。 但实际上这不是好的方案，好的延迟加载方案是： 在库被加载完成后，通过异步网络同时加载需要的模块，这样用户在调用其他模块时，也不会感觉到延迟，同时不会阻塞页面。 其他代理在代理模式中，还有其他的模式，但是在JavaScript中并不是常用的，比如： 防火墙代理控制网络资源的访问，保护服务器资源的安全。 远程代理为一个对象在不同的地址空间提供局部代表。在JavaScript中，远程代理可以是另一个虚拟机中的对象。 智能引用代理取代了简单的指针，它在访问对象的同时执行一些附加操作，比如计算一个对象被引用的次数。 ES6的Proxy在ES6之前，JavaScript只能通过Object.defineProperty来进行数据代理。并且还无法做到对对象属性的代理监听。以至于Vue不得不设计一个Vue.prototype.set来监听对象属性的修改。但是ES6的的ProxyAPI在编程语言的层面上提供了代理，这样使得我们这一章的代理模式的实现变得极其简单。下面简单介绍其用法。 ES6提供原生的Proxy构造函数，用来生成Proxy实例。 1let proxy = new Proxy(target, handler) Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，- target参数表示所要拦截的目标对象。 handler参数也是一个对象，用来定制拦截行为。 如果handler没有做任何拦截为{}，则直接通向原对象。 示例123456789101112131415161718192021let stu = &#123; name: 'tom', number: 123, sex: 'male'&#125;let handler = &#123; get: function(target, propKey, receiver)&#123; if(propKey === 'sex')&#123; return false &#125; return target[propKey] &#125;, set: function(target, propKey, value, receiver)&#123; if(propKey === name)&#123; return false &#125; target[propKey] = value &#125;&#125;let stu_p = new Proxy(stu, handler) 上面代理拦截了get和set方法，拦截了获取stu对象的sex属性、设置stu的name属性。 其中handler中，支持的拦截属性有13种： get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[&#39;foo&#39;]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 简单介绍上面的参数分别为： target：目标对象，即被代理的对象 propKey： 操作的属性键名 value：操作的属性值 receiver：代理对象 propKey：属性键名 propDesc：属性的描述，详见Object.defineProperty() proto：原型对象 Vue3中的响应式完全依赖了这个API，所以其是非常有用的。用起来也简单。还是需要深入理解。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"代理模式","slug":"代理模式","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式2-策略模式","slug":"设计模式2-策略模式","date":"2021-02-24T01:55:03.000Z","updated":"2021-02-24T06:47:25.675Z","comments":true,"path":"2021/02/24/设计模式2-策略模式/","link":"","permalink":"http://yoursite.com/2021/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式定义定义一系列的算法，把它们一个个封装起来，并且使他们可以相互替换。 主要解决在多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护的问题。 奖金的例子很多公司的年终奖的是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为S的员工年终奖有4倍工资，绩效为A的员工年终奖有3倍工资，绩效为B的员工年终奖有2倍工资。假如需要一段代码来计算对应员工的年终奖。 最基础写法我们直观想到的就是用if...else或者switch...case的方法来写。如下 123456789let calculateBonus = function(performanceLevel, salary)&#123; if(performanceLevel === 'S')&#123; return salary * 4 &#125;else if(performanceLevel === 'A')&#123; return salary * 3 &#125;else if(performanceLevel === 'B')&#123; return salary * 2 &#125;&#125; 虽然代码简单，但是这段代码有很多问题： 过多的if...else语句，代码结构不好 calculateBonus函数缺乏弹性，如果增加一种新的绩效C，或者修改现有等级的奖金逻辑，就必须深入函数内部进行修改，这违背了开放-封闭原则 算法复用性差，如果需要在程序的其他地方重用这些算法就只能重新写（cpoy）一份相似的。 所以我们现在尝试一步步重构代码。 使用组合函数重构代码这里我们将不同的绩效的计算代码抽出来，形成对应的计算函数，在计算奖金里调用这些函数进行计算。 123456789101112131415161718192021let performanceS = function(salary)&#123; return salary * 4&#125;let performanceA = function(salary)&#123; return salary * 3&#125;let performanceB = function(salary)&#123; return salary * 2&#125;let calcalateBonus = function(perfomanceLevel, salary)&#123; if(performanceLevel === 'S')&#123; return performanceS(salary) &#125;else if(performanceLevel === 'A')&#123; return performanceA(salary) &#125;else if(performanceLevel === 'B')&#123; return performanceB(salary) &#125;&#125; 但是这段代码对于最大的问题还没有解决： 过多的if...else语句，代码结构不好 calculateBonus函数缺乏弹性，如果增加一种新的绩效C，或者修改现有等级的奖金逻辑，就必须深入函数内部进行修改，这违背 使用策略模式重构代码一个策略模式的程序至少由两部分组成。 第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。 第二部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这一点，说明Context中要维持对某个策略对象的引用。 使用传统面向对象语言的算法12345678910111213141516171819202122232425262728293031323334353637let performanceS = function()&#123;&#125;performanceS.prototype.calculate = function(salary)&#123; return salary * 4&#125;let performanceA = function()&#123;&#125;performanceS.prototype.calculate = function(salary)&#123; return salary * 3&#125;let performanceB = function()&#123;&#125;performanceS.prototype.calculate = function(salary)&#123; return salary * 2&#125;let Bonus =function()&#123; this.salary = null this.strategy = null&#125;Bonus.prototype.setSalary = function(salary)&#123; this.salary = salary&#125;Bonus.prototype.setStrategy = function(strategy)&#123; this.strategy = strategy&#125;Bonus.prototype.getBonus = function()&#123; if(!this.strategy)&#123; throw new Error('未设置strategy属性') &#125; return this.strategy.calculate(this.salary)&#125; 根据上面的模式，我们将计算具体奖金的方法封装。然后定义Bonus来调用封装的方法来计算具体的奖金。 但是对于JavaScript，我们的实现可以更简单一些。 JavaScript版本的策略模式我们可以直接使用字面量对象来封装strategy。然后通过Context来计算奖金。 1234567891011121314151617181920//定义策略let strategy = &#123; S: function(salary)&#123; return salary * 4 &#125;, A: function(salary)&#123; return salary * 3 &#125;, B: function(salary)&#123; return salary * 2 &#125;&#125;//定义Contextlet calculateBonus = function(level, salary)&#123; return srtategy[level](salary)&#125;console.log(calculateBonus('S', 20000)) //输出：80000console.log(calculateBonus('A', 10000)) //输出：30000 表单验证表单验证与上面计算奖金的算法类似，都是由多个相似的规则组成。加入现在有以下规则： 用户名不能为空 密码长度不能少于6位 手机号码必须符合格式 基本写法1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;body&gt; &lt;form id='registerForm'&gt; 请输入用户名：&lt;input type='text' name='userName'/&gt; 请输入密码：&lt;input type='text' name='password'/&gt; 请输入手机号：&lt;input type='text' name='phoneNumber'/&gt; &lt;button&gt; 提交 &lt;/button&gt; &lt;/form&gt; &lt;script&gt; let registerForm = document.getElementBuId('registerForm') registerForm.onsubmit = function()&#123; if(registerForm.userName.value === '')&#123; alter('用户名不能为空') return false &#125; if(registerForm.password.valu.length &lt; 6)&#123; alter('密码不能少于6位') return false &#125; if(!/(!1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value))&#123; alert('手机号码格式不正确') return false &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这是最常见的编写方式，其缺点也与奖金计算的最初版本一样。 registerForm.onsubmit函数比较庞大，包含了很多if...else语句。 registerForm.onsubmit缺乏弹性，如果增加校验规则必须深入函数内部进行修改，违背了开放-封闭原则。 算法复用性差，如果在程序中增加另外一个表单，我们仍然需要写完全相同的算法。 用策略模式重构表单校验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//校验规则let stategies = &#123; isNonEmpty: function(value, errorMsg)&#123; if(value === '')&#123; return errorMsg &#125; &#125;, minLength: function(value, length, errorMsg)&#123; if(value.length &lt; length)&#123; return errorMsg &#125; &#125;, isMobile: function(value, errorMsg)&#123; if(!/(!1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value))&#123; return errorMsg &#125; &#125;&#125;//校验类let Validator = function()&#123; this.cache = [] //保存校验规则&#125;Validator.prototype.add = function(dom, rule, errorMsg)&#123; let ary = rule.split(':') //把strategies和参数分开 this.cache.push(function()&#123; //把校验规的步骤用空函数包装起来，并且放入cache let strategy = ary.shift() //用户挑选的strategy ary.unshift(dom.value) //把input的value添加进参数列表 ary.push(errorMsg) //把errorMsg添加进参数列表 return strategies[strategy].aplly(dom, ary) &#125;)&#125;Validator.prototype.start = function()&#123; for(let i = 0; validatorFunc; validatorFunc = this.cache[i++])&#123; let msg = validatorFunc() //开始校验，并取得校验后的返回值 if(msg)&#123; //如果有确切的返回值，说明校验没有通过 return msg &#125; &#125;&#125;//Context类let validatorFunc = function()&#123; let validator = new Validator() //添加一些校验规则 validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空') validator.add(registerForm.password, 'minLength:6', '密码长度不能少于6位') validator.add(registerForm.phoneNumer, 'isNonEmpty', '用户名不能为空') let errorMsg = validator.start() //获得校验结果 return errotMsg //返回校验结果&#125;let registerForm = document.getElementById('registerForm')registerForm.onsubmit = function()&#123; let errorMsg = validatorFunc() //如果errorMsg有确切的返回值，说明未通过校验 if(errorMsg)&#123; alert(errorMsg) return false //🚫表单提交 &#125;&#125; 策略模式的优缺点优点： 策略模式利用了组合、委托和多态的技术和思想，可以有效的避免多重条件选择语句。 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得他们易于切换，易于理解，易于扩展。 在策略模式的算法也可以服用在系统中的其他地方，从而有效的避免代码的冗余。 在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 缺点： 会增加许多的策略类或者策略对象。 策略模式的最大特点就是将同类操作封装在一个对象中，然后再其他类中调用该对象中对应的操作。 参考《JavaScript设计模式与开发实践》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"http://yoursite.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式1-单例模式","slug":"设计模式1-单例模式","date":"2021-02-22T02:19:56.000Z","updated":"2021-02-24T06:44:36.111Z","comments":true,"path":"2021/02/22/设计模式1-单例模式/","link":"","permalink":"http://yoursite.com/2021/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式最近在写Vue插件，发现自己通过直观想法写的东西总是与别人的插件有一定的差距。我也明白别人的库中用了一种或多种设计模式，使代码结构更加恰当等等。之前就说要学习一下设计模式，被搁置到现在，现在买了《JavaScript设计模式与开发实践》，后面会陆续将自己的学习过程通过博客记录。 单例模式定义保证一个类仅有一个实例，并提供一个访问它的全局访问点。 描述单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象。 实现传统单例模式JavaScript语言原生设计的时候并没有设计类的概念，并且对象是可以直接通过字面量来新建对象，不一定需要通过类来实例化对象。所以在JavaScript中的单例模式与Java等面向对象语言稍有不同。下面通过传统的面向对象语言的方式来设计单例模式。 简单实现要实现标准的单例模式，无非是要用一个变量来标志当前是否已经为某个类创建过对象，如果创建过，则在下一次创建的时候直接返回该对象。 123456789101112131415161718let Singleton = function(name)&#123; this.name = name&#125;Singleton.instance = nullSingleton.prototype.getName =function()&#123; alert(this.name)&#125;Singleton.getInstance = function(name)&#123; if(!instance)&#123; this.instance = new Singleton(name) &#125; return this.instance&#125;let a = Singleton.getInstance('name1')let b = Singleton.getInstance('name2') 或者使用闭包将instance标志放在闭包中： 1234567891011121314151617let Singleton = function(name)&#123; this.name = name&#125;Singleton.prototype.getName = function()&#123; alert(this.name)&#125;Singleton.getInstance = (function()&#123; let instance = null return function(name)&#123; if(!instance)&#123; instance = new Singleton(name) &#125; &#125; return instance&#125;)() 通过这种方式，我们只能通过getInstance方法来获得该对象。这样增加了该方法的不透明性，不能通过new来创建对象，下面来编写一个头i摩纳哥的单例类。 透明的单例类下面来实现一个透明类，来实现一个CreateDiv单例类，他的作用是是负责在页面中创建唯一的div节点，代码如下： 1234567891011121314151617181920212223let CreateDiv =(function()&#123; let instance; let CreateDiv =function(html)&#123; if(instance)&#123; return instance &#125; this.html = html this.init() return instance = this &#125; CreateDiv.prototype.init = function()&#123; let div = document.createElement('div') div.innerHTML = this.html document.body.appendChild(div) &#125; return CreateDiv&#125;)()let a = new CreateDiv('name1')let b = new CreateDiv('name2')a === b //true 这个构造方法虽然完成了一个透明的单例类，但是它同样有一些缺点，即违背了“单一职责原理” 单一职责原则（SRP：Single responsibility principle）又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定一个类应该只有一个发生变化的原因。 用代理实现单例模式为了实现单一职责原理，我们要引入代理类的方式，把负责管理单例的代码分离出去。 1234567891011121314151617181920212223242526var CreateDiv = function(html)&#123; this.html = html this.init()&#125;CreateDiv.prototype.init = function()&#123; let div = document.createElement('div') div.innerHTML = this.html document.body.appendChild(div)&#125;//代理类，可以处理各种类let proxyCreateDiv = (function()&#123; let instance return function(fn, html)&#123; if(!instance)&#123; instance = new fn(html) &#125; return instance &#125;&#125;)()let a = new ProxySingletonCreateDiv(CreateDiv, 'name1')let b = new ProxySingletonCreateDiv(CreateDiv, 'name2')a === b //true 上面的代码中，我们将业务代码与管理逻辑分开到两个类中，实现了单一职责原理。 JavaScript中的单例模式由于JavaScript是一门原生无类(class-free)语言，也是正因如此，生搬硬套单例模式的概念并无意义。 单例模式的核心是：确保只有一个实例，并提供全局访问。 全局变量不是单例模式，但在JavaScript中，我们经常会把全局变量当成单例来使用。 当我们使用字面量对象在全局作用域下创建对象a时，对象a确实是独一无二的，并且也是可以在任意位置上访问。这样满足单例模式的两个条件。 但是这样会污染全局变量，我们可以使用两种方法： 使用命名空间。 使用闭包封装私有变量。 惰性单例所谓惰性单例就是在需要的时候才创建。实际上上面的单例模式就已经是惰性单例了，在为初始化之前都是null，只有在new的时候才进行创建。 下面用一个实际应用场景，就是登录框的设计：在用户未点击之前，登录框不会显示，点击时才会出现登录框。 这里有几种处理方式： 提前将登录框插入到文档中，并将其display属性设置为none，在点击时将display属性设置为block。这样性能问题就是，这个登录框可能永远用不到，这样就浪费了性能。 在用户点击时，使用JavaScript将登录加入文档流；在用户登录成功或者×时，将其从文档流中删除。这样的性能问题也有，就是第一次生成的登陆框实际是可以保存，方便以后使用。 所以最佳方案就是最开始不生成登录框，等用户点击时生成，并且这之后将其display属性设为none，方便以后使用，这样也就是我们的单例模式。 所以最后的代码如下（已经将业务代码与管理代码分离）： 12345678910111213141516171819202122232425262728293031//获取对应对象单例let getSingle = function(fn)&#123; let result //使用一个闭包来保存result return function()&#123; return result || (result = fn.apply(this, arguments)) &#125;&#125;//创建登录框并返回let createLoginLayer = function()&#123; let div = document.createElement('div') div.innerHTML = '登录框' document.body.appendChild(div) return div&#125;//创建函数的单例let createSingleLoginLayer = getSingle(createLoginLayer)//点击事件监听document.getElementById('loginBtn').onclick = function()&#123; let loginLayer = createSingleLoginLayer() loginLayer.style.display = 'block'&#125;//取消事件监听document.getElementById('cancelBtn').onclick = function()&#123; let loginLayer = createSingleLoginLayer() loginLayer.style.display = 'none1&#125; 总结单例模式是一个比较重要的单例模式，在进行底层开发或者注重性能的任务中，单例模式可以节省很多消耗，提高性能。 参考 《JavaScript设计模式与开发实践》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"JavaScript中的模块导入导出","slug":"JavaScript中的模块导入导出","date":"2021-02-14T10:47:09.000Z","updated":"2021-03-09T14:02:07.383Z","comments":true,"path":"2021/02/14/JavaScript中的模块导入导出/","link":"","permalink":"http://yoursite.com/2021/02/14/JavaScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"模块的概念 （Modular design） 所谓的模块化设计，简单地说就是将产品的某些要素组合在一起，构成一个具有特定功能的子系统，将这个子系统作为通用性的模块与其他产品要素进行多种组合，构成新的系统，产生多种不同功能或相同功能、不同性能的系列产品。 这是在整个设计行业对模块化的定义。对于编程语言中的模块化设计，其基本思路就是将有相同功能的部分代码封装在一起，形成一个通用的，可复用的模块，使之在其它系统中可以重复利用，并不会对模块内部产生影响。所以设计模式中模块化设计的三大特征也要遵循： 相对独立性 互换性 通用性 换做在编程语言中，相对独立性即要使私有成员无法被外部访问并暴露给外部指定的方法。通用性在程序设计中多被称为可复用性，而模块设计的原则和目的也是可复用性。模块可以减少我们对重复代码的编写，提高开发的效率。 JavaScript对模块的需求最初JavaScript是作为网页开发的脚本而开发，Brendan Eich 可能也不会想到当初十几天开发出的一个脚本语言如今会焕发如此的生命力，也正是因为开发周期如此之短，使之缺点在当今工程化的JavaScript中被极大的放大。其中一个就是模块的概念，JavaScript原生并没有模块的概念，就如同没有原生的类一样（尽管ES6推出了所谓的类）。为此，开发者想出了很多方法从语言层面来模拟模块化。 初期的模块化在各类框架，插件没有流行，JavaScript仅作为一门脚本语言的时候，开发人员想出了一些方法来对项目中一些方法集合进行封装，形成类似于模块的模式。 原生写法描述模块就是实现特定功能的一组方法。 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 例子1234567function m1()&#123; //...&#125;function m2()&#123; //...&#125; 缺点 “污染”了全局变量，无法保证不与其他模块发生变量名冲突 模块成员之间看不出直接关系。 对象写法描述为了解决上面的“全局变量污染的问题”，又利用了对象这一数据类型，使一个模块成为一个对象，模块的成员作为对象的成员变量。 例子12345678910111213var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 缺点 私有变量被直接暴露给外部，如上面的_count应该是一个保留的私有变量，但是在外部我们也是可以访问到的。 立即执行函数（IIFE）写法描述又为了解决无法保有私有成员的问题（其本质是JavaScript没有局部作用域的问题，具体看这里），这里利用了立即执行函数形成一个闭包的同时也形成了一个局部作用域，这个作用域内的变量在外部是无法访问到的。这样就解决了上面的私有便变量的问题。 例子123456789101112131415161718var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); 这里module1形成了一个闭包，返回一个对象，我们只能访问到对象暴露的m1和m2方法，内部的_count是无法被访问到了。 优点 提高性能：通过 IIFE 的参数传递常用全局对象 window、document，在作用域内引用这些全局对象。JavaScript 解释器首先在作用域内查找属性，然后一直沿着链向上查找，直到全局范围，因此将全局对象放在 IIFE 作用域内可以提升js解释器的查找速度和性能； 压缩空间：通过参数传递全局对象，压缩时可以将这些全局对象匿名为一个更加精简的变量名； 缺点 不能很好的管理依赖，缺少一个依赖管理者。比如依赖的调用顺序，在没有管理者时，我们必须自己确定调用顺序，比如： 我们要调用module1的mock方法， 而module1又依赖module2 module2又依赖module3 module4又依赖module3 我们则必须按这个顺序加载脚本文件 12345678&lt;script src='./module4'&gt;&lt;/script&gt;&lt;script src='./module3'&gt;&lt;/script&gt;&lt;script src='./module2'&gt;&lt;/script&gt;&lt;script src='./module1'&gt;&lt;/script&gt;&lt;script&gt; module1.mock()&lt;/script&gt; 立即执行函数（IIFE）的衍生写法放大模式描述如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。 例子123456789var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1); 上面的代码为module添加了一个m3属性。并将新的模块实体返回。 宽放大模式描述对于上面的放大模式，存在一定的问题。由于在浏览器中，所有的资源都是异步加载的，所以上面的参数可能不存在，所以我们必须要考虑这种情况，增强代码的健壮性。 例子1234567var module1 = ( function (mod)&#123; //... return mod;&#125;)(window.module1 || &#123;&#125;); 上面的代码相当于是给函数参数设置了一个默认参数为{}，当window.module1不存在的时候，在对{}空对象进行操作。 现代模块设计恩格斯说：“社会一旦有技术上的需要，则这种需要会比十所大学更能把科学院推向前进。”随着进入大前端时代，网站的规模越来越大，逻辑层面越来越复杂。模块化的管理成为必然，很多模块管理框架应运而生。具有代表性的有： Node.js中CommonJS 基于 AMD 的 RequireJS 基于 CMD 的 SeaJS ECMAScript规定的ES Module CommonJS描述CommonJS 是Node.js中采用的一种规范，其基本原则有： 由于Node是在服务端运行，所以CommonJS的模块加载是同步进行的，所以其在浏览器中并不适用，因为浏览器中的文件都是通过网络加载的，并不适合同步加载。 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 每个模块内部有一个全局变量module，这个变量是一个对象，它的exports属性（即module.export）用于导出模块。 每个模块内部有一个全局变量require，其是一个函数，用于导入模块，参数即模块的地址。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 例子导出12345678910111213141516//module1.jslet _temp = -1let pi = 3.1415926let exchange = function(a, b)&#123; _temp = a a = b b = _temp return [a,b]&#125;module.export.pi = pimodule.export.exchange = exchange//或者这么写module.export.sum = function(a, b)&#123; return a + b&#125; 导入1234let module1 = require('./module1.js')console.log(module1.exchange(1, 2)) //[2, 1]console.log(module1.pi) //3.1415926 详细介绍module对象Node内部提供一个Module构建函数。所有的模块都是Module的实例。 查看Node源码： 123456function Module(id, parent)&#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; //...&#125; 可以发现其是一个构造器函数，其中设置了以下属性： module.id：模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回一个对象，表示调用该模块的父级块。 module.children 返回一个数组，表示该模块要用到的其他子级模块。 module.exports 表示模块对外输出的值。 实际上我们模块导入的过程就是为对应模块的module.exports对象增加成员的过程。 目录加载规则通常一个项目都有一个入口文件（或函数），比如C语言，Java中的main函数。在Node项目中，一般也会指定一个入口文件，让require方法可以通过这个入口文件，加载整个项目。 一般这个入口放在packge.json文件，并将入口文件写入main字段。如： 12345//packge.json&#123; \"name\": \"new_project\", \"main\": \"./main/index.js\"&#125; require发现参数字符串指向一个目录以后，会自动查看该目录的packge.json文件，然后加载main字段指定的入口文件。如果packge.json文件没有main字段，或者没有packge.json文件，则会加载该目录下的index.js文件或者index.node文件。 模块缓存Node会在第一次加载模块后，缓冲该模块（实际上是缓存该模块的module.exports属性）。如： 123require('./moudle1.js')require('./moudle1.js').num = 1require('./moudle1.js').num //1 上面三次导入一个模块，但是我们添加的成员变量在第三次缓冲时仍然可以访问到，证明其是被缓冲在内存中的。 我们可以通过删除require.cache的对应属性来删除模块缓冲。 删除模块缓冲12345678//删除指定模块delete require.cache[moduleName]Reflect.deleteProperty(require.cache, moduleName)// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) 模块的加载机制CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。 下面是一个模块文件lib.js。 123456789// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。 然后，加载上面的模块。 1234567// main.jsvar counter = require('./lib').counter;var incCounter = require('./lib').incCounter;console.log(counter); // 3incCounter();console.log(counter); // 3 上面代码说明，counter 输出以后，lib.js 模块内部的变化就影响不到 counter 了。 AMD描述AMD 全称为 Asynchromous Module Definition（异步模块定义）。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，它是一个在浏览器端模块化开发的规范。 AMD 模式可以用于浏览器环境并且允许异步加载模块，同时又能保证正确的顺序，也可以按需动态加载模块。 特点 AMD是依赖前置，即提前声明需要的依赖。 对依赖的加载是提前进行的，在运行前就加载所有的依赖。 用法模块通过 define 函数定义在闭包中，格式如下： 1define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]： 1define(function(require, exports, module) &#123;&#125;） factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 例子(require.js)定义模块12345678910111213141516171819define(['jquery'], function($)P&#123; var num = 555 var _version = 0.01 var showMessage = function(message)&#123; if(!message)&#123; return &#125;else&#123; $('#messageBox').html('欢迎访问' + name) &#125; &#125; return&#123; 'num':num, 'showMessage': showMessage &#125;&#125;)//_version为内部维护变量，无法被外部访问到 引入模块1234567891011121314// 配置文件require.config(&#123; baseUrl: 'js', paths: &#123; jquery: 'lib/jquery-1.11.1', &#125;&#125;);// 加载模块require(['jquery', 'script/hello'],function ($, hello) &#123; $(\"#btn\").click(function()&#123; hello.showMessage(\"test\"); &#125;);&#125;); CMD描述CMD（Common Module Definition） 是 SeaJS 在推广过程中对模块定义的规范化产出。CMD 规范的前身是 Modules/Wrappings 规范。 特点 CMD推崇依赖就近，即在依赖使用时才引入。 CMD是延迟执行的，即使用的时候才延迟执行的。 用法（SeaJS）1、seajs.config({…}); //用来对 Sea.js 进行配置。2、seajs.use([‘a’,’b’],function(a,b){…}); //用来在页面中加载一个或多个模块。3、define(function(require, exports, module){…}); //用来定义模块。Sea.js 推崇一个模块一个文件，遵循统一的写法：4、require(function(require){var a = require(“xModule”); … }); //require 用来获取指定模块的接口。5、require.async, //用来在模块内部异步加载一个或多个模块。 例如： 123456define(function(require)&#123; require.async(['aModule','bModule'],function(a,b)&#123; // 异步加载多个模块，在加载完成时，执行回调 a.func(); b.func(); &#125;) &#125;); 6、exports, //用来在模块内部对外提供接口。 例如： 123456define(function(require, exports)&#123; exports.varName01 = 'varValue'; // 对外提供 varName01 属性 exports.funName01 = function(p1,p2)&#123; // 对外提供 funName01 方法 .... &#125; &#125;); 7、module.exports, 与 exports 类似，用来在模块内部对外提供接口。例如： 123456define(function(require, exports, module) &#123; module.exports = &#123; // 对外提供接口 name: 'a', doSomething: function() &#123;...&#125;; &#125;;&#125;); 例子定义模块123456789101112131415161718192021222324252627// seajs 的简单配置seajs.config(&#123; base: \"../sea-modules/\", alias: &#123; \"jquery\": \"jquery/jquery/1.10.1/jquery.js\" &#125;&#125;);// 所有模块都通过 define 来定义define(function(require, exports, module) &#123; // 通过 require 引入依赖 var $ = require('jquery'); var Spinning = require('./spinning'); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ... //或者使用return向外提供接口 return &#123; someVal: someVal, doSomething: doSomething &#125;&#125;); 如果retunr语句是模块的唯一代码，还可以简化为： 1234define(&#123; someVal: someVal, doSomething: function() &#123;&#125;&#125;); 引入模块1234567891011121314151617181920212223//单一模式seajs.use('./a') //回调模式seajs.use('./a', function(a) &#123; a.run()&#125;); //多模块模式seajs.use(['./a', './b'], function(a, b) &#123; a.run() b.run()&#125;)//在一个模块中引入其他模块define(function(require, exports, module) &#123; //同步引入其他模块 var module1 = require('./module1') //异步引入其他模块 var module2 = require.async('./module2')&#125;) 注意： 对 module.exports 的赋值需要同步执行，不能放在回调函数里。 在html中 ，为script标签添加data-main = true确定其为主入口。data-main通常用在只有一个入口的情况，use可以用在多个入口的情况 UMD描述UMD（Universal Module Definition），AMD模块以浏览器第一的原则发展，异步加载模块。CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。 特点 兼容 AMD 和 CommonJS 规范的同时，还兼容全局引用的方式 例子1234567891011121314151617(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; //AMD define(['jquery'], factory); &#125; else if (typeof exports === 'object') &#123; //Node, CommonJS之类的 module.exports = factory(require('jquery')); &#125; else &#123; //浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery); &#125;&#125;(this, function ($) &#123; //方法 function myFunc()&#123;&#125;; //暴露公共方法 return myFunc;&#125;)); ES Module描述在 ES Module 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES Module 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES Module 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 CommonJS 和 AMD 模块，其本质是在运行时生成一个对象进行导出，称为“运行时加载”，没法进行“编译优化”，而 ES Module 不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。这称为“编译时加载”或者静态加载，即 ES Module 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES Module 模块本身，因为它不是对象。 由于 ES Module 是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ESz Module 还有以下好处： 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES Module 格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。 不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。 特点 静态编译 输出的值引用，而非值拷贝 import 只能写在顶层，因为是静态语法 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。（具体严格模式内容不再赘述） 例子导出模块123456789101112131415161718192021222324252627282930//module1.jslet pi = 3.1415926let d = 'default'let sum = function(a, b)&#123; return a + b&#125;let bactch1 = 1let bactch2 = 2let bactch3 = 3//导出已定义的变量export piexport sum//直接导出声明的变量export const e = 2.718281828459export function multiply(x, y) &#123; return x * y;&#125;;//批量导出export &#123;bactch1, bactch2, bactch3&#125;//导出默认export default d//对导出变量重命名,并且重命名为default，与上面的说法一致export &#123;d as default&#125; 注意： export default 命令用于指定模块的默认输出。export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字 export default只能导出变量，不能在后面声明变量。如： 12//错误export default const pi = 3.1415926 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 如： 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 面代码输出变量foo，值为bar，500 毫秒之后变成baz。 导入模块1234567891011//直接导入模块所有成员import * from 'module1'//批量导入模块import &#123;pi, e, sum&#125; from 'module1'//直接执行所加载的模块import 'lodash';//在一条import语句中，同时输入默认方法和其他接口import _, &#123; each, forEach &#125; from 'lodash'; 注意 export后无法直接接变量内容。如： 12//错误export 3 import()import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以import和export命令只能在模块的顶层，不能在代码块之中。如，下面的代码会报错 1234// 报错if (x === 2) &#123; import MyModual from './myModual';&#125; 但是有时候我们需要按需引入又该怎么办，ES2020提案 引入import()函数，支持动态加载模块。 import(specifier) 特点 import函数的参数specifier，指定所要加载的模块的位置。 import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import()返回一个 Promise 对象。模块作为Promise的参数返回下面是一个例子。 123456789const main = document.querySelector('main');import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 兼容性 总结目前JavaScript的模块规范就是上面谈到的四种，CommonJS、AMD、CMD、ES Module。 CommonJS 用在服务器端，AMD 和CMD 用在浏览器环境，ES Module 是作为终极通用解决方案，时下热议的vite即利用了ES Module。 比较AMD 和 CMD 的区别 执行时机： AMD 是提前执行，CMD 是延迟执行。 对依赖的处理：AMD 推崇依赖前置，CMD 推崇依赖就近。 API 设计理念：AMD 的 API 默认是一个当多个用，非常灵活，CMD 的 API 严格区分，推崇职责单一。 遵循的规范：RequireJS 遵循的是 Modules/AMD 规范，SeaJS 遵循的是 Mdoules/Wrappings 规范的 define 形式。 设计理念：SeaJS 设计理念是 focus on web, 努力成为浏览器端的模块加载器，RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。 CommonJS 和 ES Module 的区别 加载时机：CommonJS 是运行时加载（动态加载），ES Module 是编译时加载（静态加载） 加载模块：CommonJS 模块就是对象，加载的是该对象，ES Module 模块不是对象，加载的不是对象，是接口 加载结果：CommonJS 加载的是整个模块，即将所有的接口全部加载进来，ES Module 可以单独加载其中的某个接口（方法） 输出：CommonJS 输出值的拷贝，ES Module 输出值的引用 this: CommonJS 指向当前模块，ES Module 指向 undefined 参考 JavaScript 模块化总结 Module 的语法-阮一峰 import-MDN Javascript模块化编程（一）：模块的写法-阮一峰","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"AMD","slug":"AMD","permalink":"http://yoursite.com/tags/AMD/"},{"name":"CMD","slug":"CMD","permalink":"http://yoursite.com/tags/CMD/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://yoursite.com/tags/CommonJS/"},{"name":"ES Module","slug":"ES-Module","permalink":"http://yoursite.com/tags/ES-Module/"}]},{"title":"Fetch方法的使用","slug":"Fetch方法的使用","date":"2021-02-13T06:16:24.000Z","updated":"2021-02-17T05:21:09.103Z","comments":true,"path":"2021/02/13/Fetch方法的使用/","link":"","permalink":"http://yoursite.com/2021/02/13/Fetch%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"介绍Fetch是基于Promise开发的用于访问和操纵 HTTP 管道的一个API。其提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。 以前浏览器中的网络请求只能通过XMLHttpRequest实现（虽然大多使用的是封装过后的接口）。而Fetch则结合Promise提供了一种更加简化的发送网络请求的方式（其调用方法与axiso相似）。 用法Fetch()方法Fetch接受两个参数： Promise&lt;Response&gt; fetch(input[, init]); ?input 定义要获取的资源。这可能是：一个 USVString字符串，包含要获取资源的 URL。一些浏览器会接受 blob: 和 data: 作为 schemes.一个 Request对象。 init 可选 一个配置项对象，包括所有对请求的设置。可选的参数有： method: 请求使用的方法，如 GET、POST。 headers: 请求的头信息，形式为 Headers值的对象字面量。 body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。 mode: 请求的模式，如 cors、 no-cors 或者 same-origin。 credentials: 请求的 credentials，如 omit、same-origin 或者include。为了在当前域名内自动发送 cookie ， 必须提供这个选项， 从 Chrome 50 开始， 这个属性也可以接受 FederatedCredential 实例或是一个 PasswordCredential 实例。 cache: 请求的 cache 模式: default、 no-store、 reload 、 no-cache、 force-cache或者 only-if-cached 。redirect: 可用的 redirect 模式: follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误）, 或者 manual (手动处理重定向). 在Chrome中默认使用follow（Chrome 47之前的默认值是manual）。 referrer: 一个 [USVString](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString) 可以是no-referrer、client或一个 URL。默认是client。` referrerPolicy: 指定了HTTP头部referer字段的值。可能为以下值之一： no-referrer、no-referrer-when-downgrade、origin、origin-when-cross-origin、unsafe-url 。 integrity: 包括请求的 subresource integrity 值 （ 例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。 返回值一个 Promise对象。 例子发送带凭据的请求注意：Fetch默认是不携带凭据的请求（即使是跨域源），要将credentials: &#39;include&#39;添加到传递给 fetch()方法的init对象，才能使请求携带凭证。 123fetch('https://example.com', &#123; credentials: 'include'&#125;) 如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加 credentials: &#39;same-origin&#39;。 12345// The calling script is on the origin 'https://example.com'fetch('https://example.com', &#123; credentials: 'same-origin'&#125;) 上传 JSON 数据使用 fetch() POST JSON数据 123456789101112var url = 'https://example.com/profile';var data = &#123;username: 'example'&#125;;fetch(url, &#123; method: 'POST', // or 'PUT' body: JSON.stringify(data), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; 'Content-Type': 'application/json' &#125;)&#125;).then(res =&gt; res.json()).catch(error =&gt; console.error('Error:', error)).then(response =&gt; console.log('Success:', response)); 上传文件可以通过 HTML &lt;input type=&quot;file&quot; /&gt; 元素，FormData()和 fetch()上传文件。 123456789101112var formData = new FormData();var fileField = document.querySelector(\"input[type='file']\");formData.append('username', 'abc123');formData.append('avatar', fileField.files[0]);fetch('https://example.com/profile/avatar', &#123; method: 'PUT', body: formData&#125;).then(response =&gt; response.json()).catch(error =&gt; console.error('Error:', error)) 上传多个文件可以通过HTML &lt;input type=&quot;file&quot; mutiple/&gt; 元素，FormData()和 fetch()上传多个文件。 12345678910111213141516var formData = new FormData();var photos = document.querySelector(\"input[type='file'][multiple]\");formData.append('title', 'My Vegas Vacation');// formData 只接受文件、Blob 或字符串，不能直接传递数组，所以必须循环嵌入for (let i = 0; i &lt; photos.files.length; i++) &#123; formData.append('photo', photos.files[i]);&#125;fetch('https://example.com/posts', &#123; method: 'POST', body: formData&#125;).then(response =&gt; response.json()).then(response =&gt; console.log('Success:', JSON.stringify(response))).catch(error =&gt; console.error('Error:', error)); 自定义请求对象除了传给 fetch() 一个资源的地址，你还可以通过使用 Request()构造函数来创建一个 request 对象，然后再作为参数传给 fetch()： 123456789101112131415var myHeaders = new Headers();var myInit = &#123; method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' &#125;;var myRequest = new Request('flowers.jpg', myInit);fetch(myRequest).then(function(response) &#123; return response.blob();&#125;).then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL;&#125;); Request() 和 fetch() 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝： 1var anotherRequest = new Request(myRequest,myInit); Request对象Request构造器可以构造一个Request对象，其作为Fetch方法的参数。 该构造器接受的参数与Fetch一致： 请求地址 init对象 此处不再赘述。 此外，我们可直接通过const method = Request.method的方式来获取init属性。如： 12345const myRequest = new Request('http://localhost/flowers.jpg');const myURL = myRequest.url; // http://localhost/flowers.jpgconst myMethod = myRequest.method; // GETconst myCred = myRequest.credentials; // omit 方法Request对象有以下方法可以调用： Request.clone() 创建当前request的副本。 Request实现 Body`， 因此它也有以下方法可用: Body.arrayBuffer() 返回解决一个ArrayBuffer表示的请求主体的promise. Body.blob() 返回解决一个Blob表示的请求主体的promise. Body.formData() 返回解决一个FormData表示的请求主体的promise. Body.json() 返回解决一个JSON表示的请求主体的promise. Body.text() 返回解决一个USVString(文本)表示的请求主体的promise. 注意：这些Body功能只能运行一次; 随后的调用将通过空strings/ ArrayBuffers解析. header对象使用 Headers的接口，你可以通过 Headers()构造函数来创建一个你自己的 headers 对象。一个 headers 对象是一个简单的多名值对： 12345let content = \"Hello World\";let myHeaders = new Headers();myHeaders.append(\"Content-Type\", \"text/plain\");myHeaders.append(\"Content-Length\", content.length.toString());myHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\"); 也可以直接接受一个字面量对象来构造header对象 12345myHeaders = new Headers(&#123; \"Content-Type\": \"text/plain\", \"Content-Length\": content.length.toString(), \"X-Custom-Header\": \"ProcessThisImmediately\",&#125;); 方法 Headers.append() 给现有的header添加一个值, 或者添加一个未存在的header并赋值. Headers.delete() 从Headers对象中删除指定header. Headers.entries() 以 迭代器 的形式返回Headers对象中所有的键值对. Headers.get() 以 ByteString 的形式从Headers对象中返回指定header的全部值. Headers.has() 以布尔值的形式从Headers对象中返回是否存在指定的header. Headers.keys() 以迭代器的形式返回Headers对象中所有存在的header名. Headers.set() 替换现有的header的值, 或者添加一个未存在的header并赋值. Headers.values() 以迭代器的形式返回Headers对象中所有存在的header的值. 注意 在header已存在或者有多个值的状态下Headers.set()和 Headers.append()的使用有如下区别, Headers.set()将会用新的值覆盖已存在的值, 但是Headers.append()会将新的值添加到已存在的值的队列末尾. 如果您尝试传入名称不是有效的HTTP头名称的引用，则所有Headers方法都将引发 TypeError 。 如果头部有一个不变的Guard，则变异操作将会抛出一个 TypeError 。 在其他任何失败的情况下，他们默默地失败。 出于安全考虑，某些头只能由用户代理控制。这些头信息包括 forbidden header names 和 forbidden response header names。 一个Headers对象也有一个关联的guard，它具有不可变的值，request，request-no-cors，response或none。 这会影响 set()，delete(), 和append()`方法 改变header. Guard属性描述Guard 是 Headers对象的特性，基于不同的情况，它可以有以下取值：immutable、request、request-no-cors、response 或 none。 由于 Headers 可以在 request 请求中被发送或者在 response 请求中被接收，并且规定了哪些参数是可写的，Headers 对象中的 guard 属性。这个属性没有暴露给 Web，但是它影响到哪些内容可以在 Headers 对象中被操作。 规则当使用 Headers()constructor创建一个新的 Headers对象的时候，它的 guard 被设置成 none（默认值）。当创建 Request或 Response对象的时候，它将拥有一个按照以下规则实现的与之关联的 Headers`对象： 新对象的类型 创建时的构造函数 关联的 Headers对象的 guard Request Request() request Request Request()，mode 设置成 no-cors request-no-cors Response Response() response Response immutable immutable guard属性值的特征： none：默认的 request：从 request 中获得的 headers（Request.headers）只读 request-no-cors：从不同域（Request.mode no-cors）的 request 中获得的 headers 只读 response：从 response 中获得的 headers（Response.headers）只读 immutable：在 ServiceWorkers 中最常用的，所有的 headers 都只读。 Response 对象描述如上所述，Response实例是在 fetch() 处理完 promise 之后返回的。其呈现了对一次请求的响应数据。 我们可以通过一个构造函数来创建一个Response对象，但更多的是通过一个Fetch请求返回的Response对象。 属性 Response.headers只读 包含此 Response 所关联的 Headers对象。 Response.ok只读 包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。 Response.redirected只读 表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。 Response.status只读 包含 Response 的状态码 （例如 200 表示成功）。 Response.statusText只读 包含了与该 Response 状态码一致的状态信息（例如，OK对应 200）。 Response.type 只读 包含 Response 的类型（例如，basic、cors）。 Response.url只读 包含 Response 的URL。 Response.useFinalURL 包含了一个布尔值，来标示这是否是该 Response 的最终 URL。 Response 实现了 Body接口，所以以下属性亦可用： Body.body 只读 一个简单的 getter，用于暴露一个 ReadableStream类型的 body 内容。 Body.bodyUsed只读 包含了一个布尔值来标示该 Response 是否读取过 Body。 方法 Response.clone() 创建一个 Response 对象的克隆。 Response.error() 返回一个绑定了网络错误的新的 Response 对象。 Response.redirect() 用另一个 URL 创建一个新的 Response。 Response 实现了 Body接口，所以以下方法同样可用： Body.arrayBuffer() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 ArrayBuffer格式的 Promise 对象。 Body.blob() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 Blob 格式的 Promise 对象。 Body.formData() 读取Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 FormData 格式的 Promise 对象。 Body.json() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 JSON 格式的 Promise 对象。 Body.text() 读取 Response对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 USVString 格式的 Promise 对象。 body对象Body代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。 一般我们也是从一个请求中得到一个body对象。当然，直接通过body构造器来创建一个body也是被允许的。 属性 Body.body 只读一个简单的getter用于暴露一个ReadableStream类型的主体内容。 Body.bodyUsed 只读一个Boolean 值指示是否body已经被标记读取。 方法 Body.arrayBuffer() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是ArrayBuffer。此操作会将bodyUsed状态改为已使用（true）。 Body.blob() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是Blob。此操作会将bodyUsed状态改为已使用（true）。 Body.formData() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是FormData表单。此操作会将bodyUsed状态改为已使用（true）。 Body.json() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是使用JSON解析body文本的结果。此操作会将bodyUsed状态改为已使用（true）。 Body.text() 使Response挂起一个流操作并且在完成时读取其值，它返回一个Promise对象，其resolve参数类型是USVString（文本）。此操作会将bodyUsed状态改为已使用（true）。 比起XHR来，这些方法让非文本化的数据使用起来更加简单。 兼容性 可以看到Fetch的兼容性还是有一定的问题，Chrome42版本才开始支持从与Firefox从39版本才支持，而IE到目前位置都不支持。这是一个很大的问题。如果要在生产环境中使用，必须引入很多pollyfill，相较于使用Promise封装的XHR，这样看来优势又荡然无存，随着版本的迭代，未来肯定是Fetch的，但不是现在。 参考 使用 Fetch-MDN","categories":[{"name":"Fetch","slug":"Fetch","permalink":"http://yoursite.com/categories/Fetch/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Fetch","slug":"Fetch","permalink":"http://yoursite.com/tags/Fetch/"}]},{"title":"about跨域","slug":"about跨域","date":"2021-02-09T14:29:31.000Z","updated":"2021-03-25T15:02:01.331Z","comments":true,"path":"2021/02/09/about跨域/","link":"","permalink":"http://yoursite.com/2021/02/09/about%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"域的概念域（Domain）作为计算机网络中一个重要的概念，其阐述的是：网络中一组计算机的逻辑集合，是活动目录中的核心单元、是活动目录的分区。其有以下特点： 域定义了安全边界，每个域均有各自的安全策略以及与其它域的信任关系，在没有授权的情况下，不允许其他域中的用户访问本域中的资源。 中可以存储上百万个对象，不同的域之间具有层次关系，可以建立域树或域林，以便于域的扩展。域树通常由一个或多个共享连续的名称空间的域组合而成，其中第一个域称作根域，其他域称为子域，如图。 域林通常由一个或多个域树组成，如图10-15所示。其中，各个域树并不共享相同的名称空间，但域林内所有域树的域都具有相同的架构、配置信息、全局目录（Global Catalog）等。 所以浏览器根据域的概念，规定了同源策略（Sameoriginpolicy），其是浏览器最重要的安全策略之一。其保证了每个网页的安全性。确保非同源站点无法相互访问资源，JavaScript交互等。具体到浏览器中，同源是指具有相同的： 协议 域名 子域 端口 这其中任何一项不同，皆被视为非同源。会受到同源策略的限制。具体的url的格式： 注意：上面的url仅写到了影响跨域的4部分，其中还有： 虚拟目录部分 文件名部分 锚点部分 参数部分 完整的目录结构如下： 在浏览器中，同源策略限制的对象有： Cookie、sessionStorage、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求 但是下面的3个请求是允许跨域请求资源的： &lt;img src=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 客户端和服务端通信jsonp原理jsonp（JSON with Padding）本身是一种hack的方法来实现跨域，其利用的原理有两个： script没有同源策略的限制。 script标签请求的数据会直接执行。这一点就排除了img和link两个标签。 具体原理是：利用script的src属性，发送带有callback回调函数的GET请求，服务端在接受数据后，将要发送的数据作为函数的参数传回client，由于script会立即执行，则可以直接拿到数据。 优缺点优点兼容性强，支持IE10以下浏览器跨域问题（CORS不支持） 缺点 仅支持GET方法（由script标签的请求性质决定） 安全性不高，易遭受攻击 实现client端原生JavaScript实现123456789&lt;script&gt; let jp = document.createElement('script') script.type= 'text/javascript' jp.src = 'http://www.jsonp.com:8080/login?user = admin &amp; callback = login' function login(res)&#123; //拿到服务端结果 &#125;&lt;/script&gt; 可以看到jsonp中的src其实并不是一个脚本地址，而是一个请求地址。 JQuery实现12345678910111213$ajax(&#123; url: 'http://www.jsonp.com:8080/login', type: get, dataType: 'jsonp', jsonCallback: 'login', data: &#123; user: 'admin' &#125;&#125;)function login(res)&#123; //拿到结果&#125; axios实现1234567import axios from 'axios'axios.jsonp('http://www.jsonp.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'login'&#125;).then(res =&gt; &#123; //拿到数据&#125;) server端返回数据： 1login(&#123;'status': true, 'user': 'admin'&#125;) CORS方案CORS（Cross-origin resource sharing），即跨域资源共享。它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。 同源安全策略 默认阻止“跨域”获取资源，即网页发送的跨域请求根本不会达到服务器即被浏览器拦截，服务器没有决定的权限。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。 CORS将不同的请求分为简单请求与复杂请求，根据请求的不同，CORS会进行不同的操作。 对于简单请求，CORS会先发送一个OPTIONS预请求。具体在后面复杂请求时进行。 首先我们区分一下简单请求与复杂请求： 简单请求简单请求必须满足三个条件： 使用的方法以下类型： GET HEAD POST 除了被用户代理自动设置的首部字段（例如 Connection ，User-Agent）和在 Fetch 规范中定义为 禁用首部名称 的其他首部，允许人为设置的字段为 Fetch 规范定义的 对 CORS 安全的首部字段集合。该集合为： Accept Accept-language Content-Type（下面有额外限制） DPR Downlink Save-Data Viewport-Width Width Content-Type的值仅限于以下三种： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象。 例子 12345678910111213141516171819202122GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin: http://foo.exampleHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61Access-Control-Allow-Origin: *Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml[XML Data] 请求中关键的是： Origin: http://foo.example 它表明请求来源是http://foo.example 响应中关键的是： Access-Control-Allow-Origin: * 其表明该资源允许被任意外域访问。但一般最好是值开放给规定的域，以保证安全： Access-Control-Allow-Origin:http://foo.example 复杂请求所有非简单请求皆为复杂请求，对于复杂请求，浏览器会首先发起一个预检请求（OPTIONS），以获取服务器是否允许该请求。 下面是一次复杂请求的过程： 第一次预请求头部： 1234567891011121314151617181920212223242526OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://foo.exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-TypeHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 在请求头部中：最重要的几个字段为： Origin: http://foo.example：表示请求的来源为http://foo.example，使服务端进行鉴别是否够允许该请求来源s。 Access-Control-Request-Method: POST：表示正式请求的方法为POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type：表示正式请求将携带两个自定义请求头部字段：X-PINGOTHER，Content-Type，服务器据此决定，该实际请求是否被允许。 在响应头部中：最为重要的几个字段为： Access-Control-Allow-Origin: http://foo.example：表示服务端允许来自http://foo.example的请求。 Access-Control-Allow-Methods: POST, GET, OPTIONS：表示服务端允许的方法为POST,GET,OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type：表示服务端允许携带自定义请求头部字段为：X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400：表示响应的有效时间为86400秒，也就是24小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。 请注意：浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。 附带身份凭证的请求在XMLHttpRequest 或 Fetch的CORS中，可以基于HTTP cookies和HTTP认证信息发送身份凭证。 但在默认情况下，浏览器不会携带身份信息。如果要使浏览器携带信息，需手动设置： 1234567891011var invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/credentialed-content/';function callOtherDomain()&#123; if(invocation) &#123; invocation.open('GET', url, true); invocation.withCredentials = true; //关键 invocation.onreadystatechange = handler; invocation.send(); &#125;&#125; 注意：不光client要设置withCredentials。 server还需要设置一个头部属性： Access-Control-Allow-Credentials: true 如果响应中缺失 Access-Control-Allow-Credentials: true（第 17 行），则响应内容不会返回给请求的发起者。 注意： 如果要使请求携带身份凭证，服务端不得设置Access-Control-Allow-Origin为*。 响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。 下面简单列举一下CORS中常用的HTTP头部字段 中间件代理描述中间件代理服务器即利用一个中间服务器转发实际服务器的请求，由于中间件服务器不需要遵循同源策略，即可以从后端服务器请求数据。实际上代理的主要作用并不是应对跨域。而是如其名，代理后端真实服务器，比如在分布式设计中，一个代理服务器可以代理后端多台真实服务器，做到具体业务和底层逻辑解耦。 实际上这种方式下，代理服务器仍然需要进行跨域配置，但是免去了后端真实服务器的跨域配置。具体流程如下： 例子在node中，一般使用express做为server容器，其中的express-http-proxy可以直接用来转发请求，作为一个中间件代理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//middleware.jsconst app = express();const http = require(\"http\");let proxy = require('express-http-proxy');//配置跨域app.use((req, res, next) =&gt; &#123; res.header('Access-Control-Allow-Origin', \"*\"); res.header('Access-Control-Allow-Headers', 'Content-Type,Content-Length,Authorization,Accept,X-Requested-With'); res.header('Access-Control-Allow-Methods','PUT,POST,GET,DELETE,OPTIONS'); res.header('X-Powered-By', '3.2.1') if(req.method === 'OPTIONS') &#123; res.send(200); &#125; else &#123; next(); &#125;&#125;);//配置代理服务器，代理/api接口app.use('/api', proxy('http://realServer.com', &#123; //过滤器 filter: function(req, res)&#123; return req.method === 'GET' &#125;, //请求路径解析 proxyReqPathResolver: function(req)&#123; return req.url+'token=123456' //请求转发路径 &#125;, //返回数据处理,如果过程有异步操作应返回Promise（可选） userResDecorator: function(proxyRes, proxyResData, userReq, userRes) &#123; //同步 data = JSON.parse(proxyResData.toString('utf8')); data.newProperty = 'exciting data'; return JSON.stringify(data); //异步 return new Promise(function(resolve) &#123; proxyResData.funkyMessage = 'oi io oo ii'; setTimeout(function() &#123; resolve(proxyResData); &#125;, 200); &#125;); &#125;,&#125;))app.listen(3000) 真实服务器不需要配置跨域，仅一个简单的server即可（这里也采用express） 12345678//server.jsconst app = express();const http = require(\"http\");app.get('/api', function(req, res)&#123; res.send('REAL SERVER MESSAGE!')&#125;) 业务中，使用代理服务器多用于业务解耦，或者负载均衡，跨域只是其中一个特点。 nginx反向代理描述使用nginx反向代理其本质与node中间件代理一样，都是使用一个中间服务器，来转发请求到实际的后端服务器中，但同样，nginx的反向代理多用来做负载均衡或业务解耦，跨域问题的解决只是其中一个特点。 例子下面那是一个简单的nginx的配置： 1234567891011121314// proxy服务器server &#123; listen 80; server_name www.middleware.com; location / &#123; proxy_pass http://www.realServer.com:8080; #关键，反向代理 proxy_cookie_domain www.realServer.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.middleware.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 跨页面通信postMessage描述window.postMessage()方法可以安全地实现跨源通信。此方法可以不考虑两个页面是否同源。只要能拿到对应窗口的引用对象，就可以使用该api进行通信。 窗口引用我们可以通过： 子窗口window.open(URL,name,features,replace) | 参数 | 描述 || :——- | :———————————————————– || URL | 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 || name | 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 和 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 || features | 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 || replace | 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。 | 1let newwin = window.open('http://www.child.com', 'child') iframe let newWin = document.getElemetnById(&#39;iframe&#39;).contentWindow 拿到窗口引用。 语法otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow：其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。 message：将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。[1] targetOrigin`：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。**如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是\\。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。** transfer可选：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 示例123//parent windowlet newWin = window.open('http://www.child.com', 'child')newWin.postMessage('hello', 'https://www.orgin.com') 在子窗口中我们可以添加message事件监听。 12345window.onmessage = function(e) &#123; console.log(e.data) //hello //返回消息 e.source.postMessage('world', e.origin)&#125; websocket通信描述 Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。 websocket本身支持跨域，不会存在CORS的限制。 WebSocket和HTTP都是应用层协议，都基于 TCP 协议。 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。 WebSocket在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 例子在前端我们使用Websocket构造器来新建一个Websocket实例。 12345678910let socket = new Websocket('ws://websocketServer.com')socket.onopen = function()&#123; //向服务器发送数据 socket.send('client-connect...')&#125;socket.onmessage = function(e)&#123; //接受服务器返回的数据 console.log(e.data) &#125; 在后端我们采用node.js，其他语言差别不大。 12345678910let express = require('express')let app = express()let Websocket = require('ws')let wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection', function(ws)&#123; ws.on('message', function(data)&#123; console.log(data) //client-connect... ws.send('server-connect...') &#125;)&#125;) document.domain + iframe该方法仅适用于主域相同，子域不同的场景。 原理两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 例子123456789101112&lt;!-- a.html --&gt;&lt;body&gt; &lt;iframe src=\"http://source.com:3000/b.html\" frameborder=\"0\" onload=\"load()\" id=\"frame\"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'source.com' function onload()&#123; //读取b.html中的变量 console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678&lt;!-- b.html --&gt;&lt;body&gt; hellob &lt;script&gt; document.domain = 'source.com' let a = 100; &lt;/script&gt;&lt;/body&gt; 两个hack方法下面的两个方法是利用一些hack的方法进行通信，往往更加麻烦，所以参考一下即可。 window.name + iframe原理window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在（这一点很重要），并且可以支持非常长的 name 值（2MB）。 例子其中a.html和b.html是同域的，都是http://localhost:3000，但b.html为a.html的iframe，则a.html与b.html可以使用window.name进行通信;而c.html是http://localhost:4000 1234567891011121314151617&lt;!-- a.html(http://localhost:3000/b.html) --&gt; &lt;iframe src=\"http://localhost:4000/c.html\" frameborder=\"0\" onload=\"load()\" id=\"iframe\"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125; &lt;/script&gt; b.html为中间代理页，与a.html同域，内容为空。 1234&lt;!-- c.html(http://localhost:4000/c.html) --&gt; &lt;script&gt; window.name = 'hello' &lt;/script&gt; 本方法利用了window.name属性在切换源后不变的性质，将数据传送到外域。但是比较复杂，需要用第三个页面进行中转，所以一般不用。 location.hash + iframe原理与window.name上一种方法相似， a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接JavaScript访问来通信。 例子其中a.html和b.html是同域的，都是http://localhost:3000，但b.html为a.html的iframe;而c.html是http://localhost:4000 123456789101112131415&lt;!-- http://www.localhost:3000/a.html --&gt;&lt;iframe id=\"iframe\" src=\"http://www.localhost:4000/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + '#user=admin'; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert('data from c.html ---&gt; ' + res); &#125;&lt;/script&gt; 12345678910&lt;!-- http://www.localhost:4000/b.html --&gt;&lt;iframe id=\"iframe\" src=\"http://www.localhost:3000/c.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt; 12345678&lt;!-- http://www.localhost:3000/c.html --&gt;&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); &#125;;&lt;/script&gt; 总结上面总结了很多方法， 但是CORS和jsonp是使用最多的跨域方法，CORS在现代开发中使用最多，但是jsonp兼容性更强，对于低版本的浏览器（比如IE10以下），可以实现跨域。 代理方法的用处不仅限于解决跨域，它有更大的作用，后期再探讨。 后面页面通信中，postMessage使用的更多，其他的hack方法仅在特定的环境下才有较好的效果。 参考 前端跨域系列（3）- 跨域方法总结 WebSockets URL组成详解 express-http-proxy express-http-proxy Cross-Origin Resource Sharing (CORS)","categories":[{"name":"通信","slug":"通信","permalink":"http://yoursite.com/categories/%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"通信","slug":"通信","permalink":"http://yoursite.com/tags/%E9%80%9A%E4%BF%A1/"}]},{"title":"JavaScript宏任务，微任务与Event-loop","slug":"JavaScript宏任务，微任务与Event-loop","date":"2021-02-09T10:47:09.000Z","updated":"2021-03-11T08:49:44.762Z","comments":true,"path":"2021/02/09/JavaScript宏任务，微任务与Event-loop/","link":"","permalink":"http://yoursite.com/2021/02/09/JavaScript%E5%AE%8F%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8EEvent-loop/","excerpt":"","text":"浏览器进程（chrome）chrome中有5个主要进程： 浏览器进程（Browser Process）：顶层进程，负责浏览器各进程工作，Tab外的工作由它负责。 UI Thread：负责浏览器按钮、地址栏。 storage Thread：负责文件访问。 渲染器进程（Renderer Process）：浏览器内核，负责Tab内的所有工作。 Main Thread ：构建dom树 -&gt; 加载资源 -&gt; js下载与执行 -&gt; 样式计算 -&gt; 构建布局树 -&gt; 绘制 -&gt; 创建层树。（注：Main不是一个线程，而是多个线程的集合，为了方便介绍先聚合一下，后面展开讲）。 Worker Thread: Web Worker 运行在这个线程，可能存在多个。 Compositor Thread: 合成器，将层合成帧，分成多个磁贴。 Raster Thread: 栅格化磁贴后交给GPU。 网络进程（Network Process）：负责真正的发送http请求，接收和发送网络请求。 插件控制进程（Plugin Process）：控制所有的插件。 GPU进程（GPU Process）：其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3DCSS的效果，只是随后网页、Chrome的UI界面都选择采取GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome也引入了GPU进程。 Main线程Main线程是一些线程的集合，主要用于整个网页的工作。 其包括： GUI渲染线 程： 负责渲染工作，包括解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 注意：GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存等到JS引擎空闲时立即被执行。 JS引擎线程： JS引擎线程负责解析Javascript脚本，运行代码（比如Chrome的V8)。 一个Tab页内中无论什么时候都只有一个JS线程在运行JS。 因为GUI渲染线程与JS引擎线程是互斥的，所以当JS执行的时间过长，页面的渲染也会阻塞。 事件触发线程： 主要用来控制事件循环，添加回调事件到队列中。 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会被添加到事件线程中。 当对应的事件符合触发条件并被触发时，该线程会把事件添加到队列的队尾，等待JS引擎的处理 注：由于JS单线程的关系，所以这些队列中的事件都得等JS引擎空闲了才会被执行 定时触发器线程： setInterval与setTimeout执行的线程。 由于js引擎是单线程的，如果由js来计时会影响计时准确性，因此额外使用一个线程来计时并触发定时。 但是需要注意的是： setInterval与setTimeout的计时并不是很准确的，其误差在（10~20ms）： 再chrome底层中规定setInterval的最低时间为4ms。 windows等系统底层的时间并不是完全准确的，普通的时间API误差在10~15ms（部分情况）。 由于JavaScript引擎是单线程，即使回调完全准确的将任务加入执行队列，但是前面的任务的执行时间仍然会增加回调任务的误差。 异步http请求线程： XMLHttpRequest连接后会新开一个线程。 将检测到状态变更时，如果设置有回调函数，该线程就产生状态变更事件。 当然，实际做请求工作的还是 Network Process。 JavaScript单线程JavaScript的一大特点就是单线程设计，这一特点也造成了JavaScript的众多特性。这样设计可以使程序的开发更加简单，因为其不会涉及线程的通信，管理，比如在操作DOM的时候，如果是多线程，就需要组织各个线程的先后关系，但是单线程就不会涉及这些问题。这也使得JavaScript成为了一门入门比较简单的语言。 同步与异步而JavaScript的任务又分为同步任务和异步任务。 同步任务是指直接按照代码顺序将其加入到执行栈中任务。 而异步任务是指需要一定的时间才能完成，并且这段时间的操作不是JavaScript线程能够控制的，这个时候则需要其他线程予以辅助。比如上面的定时触发器线程，异步http请求线程等。都可以帮助JavaScript完成定时器和http请求的异步任务。而上面的事件触发线程则用来在异步任务完成时，将回调函数添加到执行栈中。其基本过程如图： 执行栈（Execution Stack）当我们调用一个方法的时候，js会生成一个与这个方法相对应的执行环境，也叫执行上下文，这个执行环境存在着这个方法的私有作用域、参数、this对象等等。因为js是单线程的，同一时间只能执行一个方法，所以当一系列的方法被依次调用的时候，js会先解析这些方法，把其中的任务按照执行顺序排队到一个地方，这个地方叫做执行栈。 事件表格（Event Table）JavaScript保有的一中数据结构，它会存储所有的延迟事件（回调函数）。在对应异步操作完成过后，会由事件触发线程将对应的回调函数添加到事件队列中等待执行。 事件队列（Event queue）当我们发出一个ajax请求或其他异步操作的时候，他并不会立刻返回结果，为了防止浏览器出现假死或者空白，主线程会把这个异步任务挂起(pending)，继续执行执行栈中的其他任务，等异步任务返回结果后，js会将这个异步任务按照执行顺序，加入到与执行栈不同的另一个队列，也就是事件队列。 Event-loop Event-loop Definitions： To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each agent has an associated event loop, which is unique to that agent. 翻译：为了协调事件、用户交互、脚本、渲染、网络等等，用户代理必须使用本节中描述的事件循环。每个代理都有一个相关的事件循环，该事件循环对该代理来说是唯一的。 每个Event-loop包含： 正在运行任务，它可以是一个任务或者null。并且在最初的时候，其是一个null。其实为了处理可重入性。 一个微任务队列，这是一个微任务队列，起初是空的。 有一个标志微任务检查点的布尔值。 HTML Living Standard Agent Definitions： An agent comprises a set of ECMAScript execution contexts, an execution context stack, a running execution context, an Agent Record, and an executing thread. Except for the executing thread, the constituents of an agent belong exclusively to that agent. 翻译：代理包括一组ECMAScript执行上下文、一个执行上下文堆栈、一个正在运行的执行上下文、一个代理记录和一个正在执行的线程。除执行线程外，代理的组成部分专属于该代理。 HTML Living Standard 所谓事件循环，就是浏览器中（此处只谈浏览器，不涉及Node）各项任务（同步任务，异步任务）的执行次序之间的协调。其基本过程如下图： 其基本过程： 主线程运行的时候会生成堆（heap）和栈（stack）； js从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中； 当程序调用外部的API时，比如ajax、setTimeout等，会将此类异步任务挂起，继续执行执行栈中的任务，等异步任务返回结果后，再按照执行顺序排列到事件队列中； 主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到事件队列中。 主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个过程是循环往复的… …。 这个过程被称为“Event Loop 事件循环”。 宏任务、微任务首先需要明确的是：宏任务和微任务都是异步任务，其不同在于回调执行的时机。 在标准中，任务是分为task和microtask，任务和微任务。全文中提到宏任务（Macro task）的只有两处： Unlike other algorithms in this and other specifications, which behave similar to programming-language function calls, spin the event loop is more like a macro, which saves typing and indentation at the usage site by expanding into a series of steps and operations. 翻译：与本规范和其他规范中的其他算法(其行为类似于编程语言函数调用)不同，spin事件循环更像是一个宏，它通过展开成一系列步骤和操作来节省使用站点上的输入和缩进。 可能是由于这一处，我们多用macro task来描述task。 而在HTML Standard中，对于task的解释为： 形式上，一个task是一个包含如下内容的结构体： steps：完成该任务需要的一系列步骤。 A source：任务源之一，用于对相关任务进行分组和序列化。 A document：与任务相关联的文档，对于不在窗口事件循环中的任务，则为空。 A script evaluation environment settings object set：一组环境设置对象，用于在任务期间跟踪脚本评估。 对于microtask定义有： A microtask is a colloquial way of referring to a task that was created via the queue a microtask algorithm. 翻译：微任务是指通过微任务算法队列创建的任务。 从执行顺序上来看两者的不同： 可以明确的是微任务是在一个宏任务结束后进行，此时即为上文提到的checkpoint，查看是否存在可执行的微任务。 具体宏任务和微任务为： 宏任务 整体script setTimeout setInterval setImmediate 其他 微任务 Promise的then方法（注意Promise内部的内容是同步内容，立即执行） process.nextTick， MutationObserver 几个简单例子定时器、Promise123456789101112131415161718192021setTimeout(function()&#123; console.log('定时器开始') &#125;); new Promise(function(resolve)&#123; console.log('马上执行for循环'); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125; &#125;).then(function()&#123; console.log('执行then函数') &#125;); console.log('代码执行结束');/** 马上开始for循环* 代码执行结束* 执行then函数* 定时器开始*/ 解释： 执行到setTimeout，先由Event Table保留其回调函数。并且在其延迟任务完成后由事件触发线程将其加入到Event Queue。 执行到new Promise，由于其函数参数是同步的，所以立即执行。打印：马上执行for循环。并将then方法的回调加入到微任务队列。 执行到console.log(&#39;代码执行结束&#39;);，同步代码。直接打印：代码执行结束 第一个事件循环结束，到checkpoint，检查是否有微任务，发现then方法回调，直接打印：执行then函数。 第二轮事件循环开始，执行第一个宏任务，setTimeout的回调进入执行栈，即执行 console.log(&#39;定时器开始&#39;)，直接打印：定时器开始 定时器、Promise、async123456789101112131415161718192021222324252627282930313233343536async function async1 () &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2 () &#123; console.log('async2');&#125;console.log('script start');setTimeout(function () &#123; console.log('setTimeout');&#125;, 0);async1();new Promise(function (resolve) &#123; console.log('promise1'); resolve();&#125;).then(function () &#123; console.log('promise2');&#125;);console.log('script end');//输出顺序：// script start // async1 start // async2 // promise1 // script end // async1 end// promise2// setTimeout 对于async函数，本质是基于Promise，所以： 12345678910111213async function async1 () &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;//等价于function async1 () &#123; console.log('async1 start'); Promise.resolve(async2()).then(() =&gt; &#123; console.log('async1 end'); &#125;)&#125; 这样就容易理解前面的答案了，根据Promise参数函数为同步，then方法为微任务，可以很容易推的结果。 最后说实话，这一部分仍然没有很好的理解，主要是官方的文档解释的比较抽象并且没有定性的解释，加之我的英语不行，不能很好的理解整个流程，只能简单的确定执行次序。这一部分还需要在后面深入的理解。 参考 JS引擎的执行机制（event loop），宏任务和微任务 HTML Standard","categories":[{"name":"JavaScrit","slug":"JavaScrit","permalink":"http://yoursite.com/categories/JavaScrit/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"宏任务","slug":"宏任务","permalink":"http://yoursite.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"},{"name":"微任务","slug":"微任务","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"}]},{"title":"Promise的实现","slug":"Promise的实现","date":"2021-02-04T05:03:48.000Z","updated":"2021-02-09T10:43:36.364Z","comments":true,"path":"2021/02/04/Promise的实现/","link":"","permalink":"http://yoursite.com/2021/02/04/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"前面已经写过一篇文章来理解Promise及其使用方法，这里尝试来模拟Promise。 要求根据Promise/A+原理，有以下几个点需要遵守： Promise有一个Promise States，其有三种状态： pending：初始状态，可以转化为fulfilled，rejected。 fulfilled： 需要一个value作为结果。 不能转化为其他状态。 rejected： 需要一个reason作为一个原因。 不能转化为其他状态。 必须要一个then方法，接受两个参数 onFulfilled：当操作成功时发生的回调。 onRejected：当操作失败时发生的回调。 一旦promise完成，每一次调用then方法，得到的结果必须是相同的。 Promise返回的必须也是一个promise。 开发实现1，2功能首先我们实现第一个和第二个特点： 基本思路如下： 一个Promise首先要有一个status，表示当前的状态，其有三种状态： PENDING：表示当前Promise未完成，此时的回调函数会加入相应的队列 RESOLVED：表示当前Promise已经完成，且时resolve状态，直接调用成功的函数。 REJECTED：表示当前Promise已经完成，且时rejected状态，直接调用失败的函数。 然后我们要定义两个值： value：用于resolve时的返回值。 reason：用于rejected时的返回值。 上面说到当Promise状态为PENDING时，我们会把回调函数放到相应的队列，所以我们还会定义两个队列 resolvedCallQueue：存放成功的回调函数 rejectedCallQueue：存放失败的回调函数 然后我们定义Promise的resolve和rejected函数，在这两个函数中，我们会改变Promise的状态并且给value或者reason赋值，最后执行相应的函数队列。 最后我们会定义Promise的then方法。如同上面对于状态的定义，我们会根据当前Promise的状态来处理then方法传来的回调函数。 下面用ES6的class来实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Promise &#123; constructor(executer) &#123; //定义Promise状态枚举数据 this.status_enum = &#123; PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED', &#125;; //成功的返回值 this.value = undefined; //失败的返回值 this.reason = undefined; //成功的回调函数队列 this.resolvedCallQueue = []; //失败的回调函数队列 this.rejectedCallQueue = []; //当前Promise状态 this.status = this.status_enum.PENDING; //Promise完成 let resolve = (value) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.RESOLVED; this.value = value; for (let i = 0; i &lt; this.resolvedCallQueue.length; i++) &#123; this.resolvedCallQueue[i](this.value); &#125; &#125; &#125;; //Promise失败 let reject = (reason) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.REJECTED; this.reason = reason; for (let i = 0; i &lt; rejectedCallQueue.length; i++) &#123; this.rejectedCallQueue[i](this.reason); &#125; &#125; &#125;; //执行Promise函数 try &#123; executer(resolve, reject); &#125; catch (e) &#123; console.log('错误', e); reject(e); &#125; &#125; //定义then函数 then(onfulfilled, onrejected) &#123; //检测参数必须为函数 if(!onfulfilled instanceof Function || !onrejected instanceof Function)&#123; throw new Error('Uncaught TypeError: Promise resolver is not a function') &#125; //当Promise状态为RESOLVED时，进行成功回调函数 if (this.status === this.status_enum.RESOLVED) &#123; onfulfilled(this.value); &#125; //当Promise状态为REJECTED时，进行失败回调函数 if (this.status === this.status_enum.REJECTED) &#123; onrejected(this.reason); &#125; //当Promise状态为PENDING时，将其回调函数加入相应队列，在完成时会执行相应的函数队列 if (this.status === this.status_enum.PENDING) &#123; this.resolvedCallQueue.push(onfulfilled); this.rejectedCallQueue.push(onrejected); &#125; &#125;&#125; 下面用原型实现(基本原理一样，因为class本质也是原型链的语法糖)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Promise(executer) &#123; this.status_enum = &#123; PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED', &#125;; this.value = undefined; this.reason = undefined; this.resolvedCallQueue = []; this.rejectedCallQueue = []; this.status = this.status_enum.PENDING; let resolve = (value) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.RESOLVED; this.value = value; for (let i = 0; i &lt; this.resolvedCallQueue.length; i++) &#123; this.resolvedCallQueue[i](this.value); &#125; &#125; &#125;; let reject = (reason) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.REJECTED; this.reason = reason; for (let i = 0; i &lt; rejectedCallQueue.length; i++) &#123; this.rejectedCallQueue[i](this.reason); &#125; &#125; &#125;; try &#123; executer(resolve, reject); &#125; catch (e) &#123; console.log('错误', e); reject(e); &#125;&#125;Promise2.prototype.then = function then(onfulfilled, onrejected) &#123; if (this.status === this.status_enum.RESOLVED) &#123; onfulfilled(this.value); &#125; if (this.status === this.status_enum.REJECTED) &#123; onrejected(this.reason); &#125; if (this.status === this.status_enum.PENDING) &#123; this.resolvedCallQueue.push(onfulfilled); this.rejectedCallQueue.push(onrejected); &#125;&#125;; 这样，Promise的基本功能就已经实现，简单测试如下： 1234567891011121314let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('2秒！！！'); resolve(111); &#125;, 2000);&#125;);p.then((res) =&gt; &#123; console.log('p1'); console.log(res);&#125;);p.then((res) =&gt; &#123; console.log('p2'); console.log(res);&#125;); 结果： 1234567892秒！！！p1111p2111 实现1，2，3功能前面我们基本实现了Promise的基本功能，但是还是一个问题是：Promise必须返回一个Promise，上面的代码并不满足这一点。 所谓我们为了实现返回的都是Promise，我们需要重写then方法，使之返回的是一个Promise，这时，我们还是要根据当前Promise的状态来分开来处理。 但是其中心点是，必须持续执行Promise，直到其返回值不是一个thenable对象或方法，所以请是一个递归的过程。所以我们定义了一个函数cycleResolve，其接受四个参数： newPromise：新建的被用于返回的Promise target：回调函数执行的获得结果（可能仍然是一个Promise） resolve：新Promise的resolve函数 reject：新Promise的reject函数 该函数的功能是：判定返回值target是不是一个thenable对象（包括Promise），如果是，继续执行其then方法。给i贵这个过程，知道返回值不是thenable对象，然后将其值resolve出去。 注意： 只有target是一个thenable对象并且其then属性是一个函数时，才会调用其then方法，否则会直接将targetresolve出去。 一旦遇到错误，都会直接reject(e) then方法中必须使用setTimeout来使内部的操作成为宏任务，在下一个tick执行。这样才能拿到newPromise，否则会出现未初始化错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127class Promise &#123; constructor(executer) &#123; this.status_enum = &#123; PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED', &#125;; this.value = undefined; this.reason = undefined; this.resolvedCallQueue = []; this.rejectedCallQueue = []; this.status = this.status_enum.PENDING; //定义resolve方法，任务完成时调度 this.resolve = (value) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.RESOLVED; this.value = value; for (let i = 0; i &lt; this.resolvedCallQueue.length; i++) &#123; this.resolvedCallQueue[i](this.value); &#125; &#125; &#125;; //定义reject方法，任务失败时调度 this.reject = (reason) =&gt; &#123; if (this.status === this.status_enum.PENDING) &#123; this.status = this.status_enum.REJECTED; this.reason = reason; for (let i = 0; i &lt; this.rejectedCallQueue.length; i++) &#123; this.rejectedCallQueue[i](this.reason); &#125; &#125; &#125;; //执行定义Promise时传入的任务 try &#123; executer(this.resolve, this.reject); &#125; catch (e) &#123; console.log('错误', e); this.reject(e); &#125; &#125; //定义then方法 then(onfulfilled, onrejected) &#123; //新建一个Promise用于返回 let newPromise = new Promise((resolve, reject) =&gt; &#123; if (this.status === this.status_enum.RESOLVED) &#123; setTimeout(() =&gt; &#123; try &#123; let target = onfulfilled(this.value); cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;, 0); &#125; if (this.status === this.status_enum.REJECTED) &#123; //建立宏任务，方便拿到newPromise，否则会出现未初始化错误 setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;); &#125; if (this.status === this.status_enum.PENDING) &#123; this.resolvedCallQueue.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let target = onfulfilled(this.value); //将resolve函数保留的成功值传递作为参数 cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;, 0); &#125;); this.rejectedCallQueue.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); //将resolve函数保留的成功值传递作为参数 cycleResolve(newPromise, target, resolve, reject); &#125; catch (e) &#123; console.log(e); reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;); return newPromise; &#125; function cycleResolve(newPromise, target, resolve, reject) &#123; //禁止循环调用 if (newPromise === target) &#123; return reject(new TypeError('循环调用')); &#125; if ( target !== null &amp;&amp; (typeof target === 'object' || typeof target === 'function') /*确定其是一个对象*/ ) &#123; try &#123; let then = target.then; /*确定是否是一个thenable对象*/ if (typeof then === 'function') &#123; then.call( target, (newTarget) =&gt; &#123; resolvePromise(newPromise, newTarget, resolve, reject); &#125;, (e) =&gt; &#123; reject(e); &#125; ); &#125; else &#123; resolve(target); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; resolve(target); &#125; &#125; 至此，Promise的基本功能都已经完成，接下来我们完成剩下的一些细枝末节的东西，包括： 实现resolve方法 实现reject方法 实现catch方法。 实现finally方法。 实现Promise的其他方法： Promise.all([p1, p2, p3]) Promise.race([p1, p2, p3]) Promise.allSettled(p1, p2, p3) Promise.any(p1, p2, p3) 注意： 各个函数的功能不再赘述，具体查看Promise理解 下面的代码就只写对应部分，多余部分不再进行赘述。 实现catch方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960catch(onrejected) &#123; /*在class中定义catch方法*/ const newPromise = new Promise3((undefined, reject) =&gt; &#123; if (this.status === this.status_enum.REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); cycleReject(newPromise, target, reject); &#125; catch (e) &#123; console.log(e) reject(e); &#125; &#125;, 0); &#125; if (this.status === this.status_enum.PENDING) &#123; this.rejectedCallQueue.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let target = onrejected(this.reason); cycleReject(newPromise, target, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;);&#125;&#125;//循环rejectfunction cycleReject(newPromise, target, reject) &#123; //禁止循环调用 if (newPromise === target) &#123; return reject(new TypeError('循环调用')); &#125; if ( target !== null &amp;&amp; (typeof target === 'object' || typeof target === 'function') /*确定其是一个对象*/ ) &#123; try &#123; let then = target.then; /*确定是否是一个thenable对象*/ if (typeof then === 'function') &#123; then.call( target, (newTarget) =&gt; &#123; resolvePromise(newPromise, newTarget, reject); &#125;, (e) =&gt; &#123; reject(e); &#125; ); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125;else&#123; reject(target) &#125;&#125; 其实这里的操作与then方法逻辑基本一致，唯一不同的是，我们只需要捕捉reject，不捕捉resolve。 实现finallyPromise的finally的方法无论promise的结果是成功还是失败，都会执行，并且返回该promise。所以实现很简单。执行其promise的then方法来获取该promise的结果。 1234finally(callback) &#123; callback(); return this.then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;);&#125; 实现Promise.resolve方法(下面的方法是直接作为class的静态函数成员的)1234567891011121314151617static resolve(val) &#123; //如果是一个Promise if(val instanceof Promise3)&#123; return val //如果没有参数，或者为null,undefined &#125;else if(!val)&#123; return new Promise3((resolve, reject) =&gt; &#123;resolve()&#125;) //参数存在但不存在then方法 &#125;else if(val &amp;&amp; !val.then instanceof Function)&#123; return new Promise3((resolve) =&gt; &#123; resolve(val); &#125;); //参数存在且存在then方法 &#125;else if(val &amp;&amp; val.then instanceof Function)&#123; return new Promise3(val.then) &#125;&#125; 实现Promise.reject方法123456static reject(val)&#123; //直接将val作为理由返回 return new Promise((resolve,reject)=&gt;&#123; reject(val); &#125;)&#125; ## 实现Promise.all([p1, p2, p3])1234567891011121314151617static all(arr) &#123; let res = [] return new Promise((resolve, reject) =&gt; &#123; for(let i = 0, len = arr.length; i &lt; len; i++)&#123; arr[i].then((v) =&gt; &#123; res.push(v) //是否所有的promise都是resolve if(res.length === arr.length)&#123; return resolve(res) &#125; &#125;, (e) =&gt; &#123; //只要一个reject，直接reject return reject(e) &#125;) &#125; &#125;)&#125; 实现Promise.race([p1, p2, p3])1234567891011121314static race(arr) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i].then( (v) =&gt; &#123; return resolve(v) &#125;, (e) =&gt; &#123; return reject(e) &#125; ); &#125; &#125;);&#125; 实现Promise.allSettled([p1, p2, p3])12345678910111213141516171819202122232425static allSettled(arr) &#123; let res = []; let count = 0; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i].then( (v) =&gt; &#123; res.push(&#123; status: 'fulfilled', value: v, &#125;); &#125;, (e) =&gt; &#123; res.push(&#123; status: 'rejected', reason: e, &#125;); &#125; ).finally(() =&gt; &#123; //计数器必须在这里统计，因为异步操作，若放在then中，在finally中无法读取预期的值 ++count === arr.length &amp;&amp; resolve(res) &#125;); &#125; &#125;);&#125; 实现Promise.any(p1, p2, p3)123456789101112131415161718static any(arr) &#123; let res = []; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i].then( (v) =&gt; &#123; //只要有一个resolve，则直接resolve return resolve(v); &#125;, (e) =&gt; &#123; res.push(e); res.length === arr.length &amp;&amp; reject(res); &#125; ); &#125; &#125;);&#125;&#125; 最后本人能力有限，可能会出现错误，谅解。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"全面理解JavaScript作用域与闭包","slug":"全面理解JavaScript作用域与闭包","date":"2021-01-31T09:26:46.000Z","updated":"2021-03-25T15:12:42.800Z","comments":true,"path":"2021/01/31/全面理解JavaScript作用域与闭包/","link":"","permalink":"http://yoursite.com/2021/01/31/%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/","excerpt":"","text":"作用域pre：块语句块语句（或其他语言的复合语句）用于组合零个或多个语句。该块由一对大括号界定，可以是labelled： 块语句会生成一个块级作用域，生成块级作用域包含两种方法： 使用任意声明符号（’’, var,let,const）在函数中会生成一个块级作用域。 使用let,const在任何块语句中生成一个块级作用域。 注意：var在非函数的块语句中不会生成一个块级作用域。 介绍中都会使用var来进行举例，在变量声明中会对let和const进行说明。 介绍变量的简单说作用域就是在哪里可以访问到该变量。在JavaScript中，变量的作用域分为 全局作用域。 局部作用域。 这个全局与局部是相对的。因为在浏览器环境下，window对象被称为全局对象（在ES6中，顶层对象被规范为globalThis对象，在node中会指向global对象。）。而相对的，函数中的变量被称为局部变量。特点如下： 局部变量只能在该作用域和其子作用域中访问到。 全部变量可以在任作用域中访问到。 例子123456789101112var out = 'out-msg'//全局变量-作用域是全局作用域，可以在任何位置访问到function func()&#123; var in = 'in-msg' //局部变量-作用域是局部作用域， console.log(out) //out-msg console.log(in) //in-msg&#125; console.log(in) //VM229:1 Uncaught ReferenceError: out is not definedconsole.log(out) //out-msg 作用域链由于上面提到，全局与局部是相对的。由于window是浏览器环境中的最基础的变量，所以他被称为全局变量。而函数中（局部作用域）链中的还可以再定义函数，而内部函数仍然可以访问到外部函数中定义的变量。这样多个函数嵌套就会形成一个作用域链。 例子1234567891011121314151617var a = 'window'//可以访问到a，访问不到v3,v4,v2function fun1()&#123; var v1 = 'v1' //可以访问到a,v1，访问不到v3,v4,v2 function fun2()&#123; var v2 = 'v2' //可以访问到a,v1,v2，访问不到v3,v4 function fun3()&#123; var v3 = 'v3' //可以访问到a,v1,v2,v3，访问不到v4 function func4()&#123; //可以访问到a,v1,v2,v3,v4 &#125; &#125; &#125;&#125; 所以，这样由window-fun1-&gt;fun2-&gt;fun3-&gt;func4形成了一个作用域链。 tip： 当要使用一个变量时，系统会按照作用域链的顺序向上依次查询。所以，变量名相同时，局部变量会优先被访问。 使用var定义变量时，局部作用域只会在函数内部产生，当使用let,const时，只要是花括号内部，都会产生一个作用域。 变量申明目前JavaScript中4中声明变量的方式：无声明标志，var,let,const 无声明标志所谓不用声明标志，就是直接使用变量名进行声明，如 1234a = 1function fun()&#123; b = 2&#125; 这样申明的变量有一些特点： 无论在哪里申明（即使是在函数块中），其都是一个全局变量，即会被挂载在全局对象window上，即无声明标志无论如何都不会构成局部作用域。 varvar是ES6出现之前JavaScript中的声明标志之一（另外一个时function用来声明一个函数变量）。所以他也具有一些特征。 变量提升变量的声明与赋值在理解变量提升之前，我们要明白变量声明与变量赋值之间的关系。 变量声明是指确定这个作用域中该变量的存在。 1var v 变量赋值就是为已经声明的变量进行赋值。 1v = 'variable' 这两个操作可以一起进行。 1var v = 'variable' 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。 例子12345678bla = 2var bla;// ...// 可以隐式地（implicitly）将以上代码理解为：var bla;bla = 2; 重要的是，提升将影响变量声明，而不会影响其值的初始化。当到达赋值语句时，该值将确实被分配： 12345678910111213function do_something() &#123; console.log(bar); // undefined var bar = 111; console.log(bar); // 111&#125;// is implicitly understood as:function do_something() &#123; var bar; console.log(bar); // undefined bar = 111; console.log(bar); // 111&#125; 值得注意的是： 变量提升是在对应作用域下进行的，内层的作用域变量不会提升到外部中，所以会产生下面的问题： 123456var ov = 'out'function func()&#123; console.log(ov) var ov = 'in'&#125;func() 问结果是什么。 答：由于变量提升的按照作用域进行的，所以虽然这里外部声明了一个ov，但是在函数func内部也声明了一个ov变量，且在这个函数赋值之前就使用了，所以这里实际上等价于： 1234567var ov = 'out'function func()&#123; var ov console.log(ov) ov = 'in'&#125;func() 而单独的变量声明不赋值，在JavaScript中其默认值为undefined，所以这里打印出来的是undefined 值得注意的是： 只要是在变量还没有赋值之前进行操作，其值都是undefined。如： 12var x = y, y = 'A'console.log(x + y) //undefinedA 由于x = y时进行时，A还没有被赋值。但是由于变量提升，y是存在的，且其值为undefined，根据JavaScript的primitive算法，得x + y结果为undefinedA。 letlet声明符号是ES6引入的新的声明符号，为了解决var的一些问题。其有一下特点： 其在块语句中声明就会生成一个块级作用域（只要花括号存在）。 同一个变量名，只能被声明一次。 不会存在变量提升，取而代之的是暂时性死区。 下面依次解释： 其在块语句中声明就会生成一个块级作用域（只要花括号存在）。以前JavaScript中只有全局作用域和函数作用域。而ES6引入的let与const相当于为JavaScript引入了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。 同一个变量名，只能被声明一次。使用var时，同一个变量名，可以被多次声明。如： 123var a = 123var a = 'abc'//不会报错 但是使用let时，不允许重复声明同一个变量。 123let a = 123let a = 'abc'//VM971:2 Uncaught SyntaxError: Identifier 'a' has already been declared 不会存在变量提升，取而代之的是暂时性死区。上面提到，使用var声明变量时，会存在变量提升的现象。即相当于所有的变量，无论何处声明，其都被在最顶部声明，且默认赋值为undefined，然后在运行到声明处，在会被赋值为对应的值。所以在声明之前使用该变量，其结果都是undefined。 而使用let声明时，在声明之前，是无法使用的。从程序开始之前，到声明之间，被称为暂时性死区。如： 123console.log(a) Uncaught ReferenceError: b is not definedlet a = 123 立即执行函数（IIFE）定义一个函数后将其立即执行的形式，形如： 123456(function()&#123; var a = '100' console.log(a)&#125;)()//函数会立即执行，并输出100 其具有以下特点： 函数会立即执行 每执行一次，就会创建一个块级作用域，可以解决典型的异步问题： 12345for(var i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;, 500)&#125; 众所周知，这里的结果是：555~，其原因就是： setTimeout是一个异步函数，当其回调函数执行的时候，for循环，已经完成了。所以后面打印出来的都是4。 用var时，不存在块级作用域，所以一个for循环中，使用的都是同一个i，导致前面的i会被后面的i所覆盖。 所以前面提到IIFE每执行一次都会创建一个快进作用域，所以可以这么解决。 12345for(var i = 0; i &lt; 5; i++)&#123; (function(i)&#123; console.log(i) &#125;)(i)&#125; 这样其结果就是：1234 但是当ES6的let出现之后，我们不再需要立即执行函数了来创建块级作用域了。直接使用let进行变量声明即可： 12345for(let i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;, 500)&#125; 其结果也是：1234 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; constconst也是ES6引入的声明符号。其基本与let一致： 每使用一次都会创建一个块级作用域。 同一个变量名，只能被声明一次。 并且，其还有一下特征： const声明一个只读的常量。一旦声明，常量的值就不能改变。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 值得注意的是：变量不可以被更改，但是其属性是可以被更改的。如： 123456789101112131415161718const obj = &#123; a: 1, b: 2&#125;obj = &#123;&#125;// SyntaxError: Missing initializer in const declarationobj.a = 3 //成功console.log(obj)\"&#123; a: 3, b: 2&#125;\" 垃圾回收机制基于最开始JavaScript设计的初衷，JavaScript的内存管理都是自动执行的，而且是不可见的。程序员基本上不需要自动管理内存。 V8内存模型要想更好的理解JavaScript的内存回收机制，要先简单理解一下JavaScript的内存模型（这里以V8为例） 首先JavaScript的变量分为两大类： 基本变量 Number Boolean String Symbol BigInt null undefined 引用变量：Object，Array，Date，RegExp 然后看一下V8的内存模型： 栈区栈区用于存储变量的名称以及内存中的地址。该地址又指向堆区、常量区或函数定义区。 例如： 在我们定义一个变量时： 12var a = 'string'var b = &#123;&#125; a为基本类型，所以他的值存储在池（常量区），所以： 在栈区建立一个单元：|变量名|内存地址|（如|a|0x1245a|） 在池（常量区）的0x1245a存储’string’ b为引用类型，其值存储在堆区，所以： 在栈区建立一个单元：|变量名|内存地址|（如|b|0x1245b|） 在堆的0x1245b的位置存储{} 值得注意的是： 变量未被初始化或者被赋值为undefined时，栈区的地址部分被置空。表示没有任何意义。 堆区用于存放引用类型的值，如上面的b，其具体的值就存储在堆区。 值得注意的是： 在堆区，预存着一个特殊对象null，其地址固定，所有的值为null的变量都指向这一块内存。 所以，需要手动释放一个变量时，只需要将该变量赋值为null，则此时其指向null，原来的内存在无引用时会被GC（garbage recycle）机制回收。 常量区与堆区相对，其存储常量的值。如上面的a变量。 常量区具有以下特征： 所有的值一旦写入无法改变。 所有相同的常量值在常量区都是惟一的。 注意：常量区的值与常量是不同的。常量区的值不可改变是指对应地址的内存内容是无法改变的。而当我们在改变常量时，实际上大概是这么个流程： 先检索常量区是否存在新的变量值。 如果存在，则直接将栈区的地址改为该常量的地址；若不存在，则在常量区新开辟一个地区，将新的变量存储到该地址，再将该常量的地址改为新的内存地址。 函数定义区函数定义区用于存放被定义的函数代码段。 值得注意的是：函数的声明有两种： 函数声明，形如 123function func()&#123; //...&#125; 这种定义的方式不会再栈区生成相应的函数名，因为此时其不是一个变量。引擎会直接在函数定义区定义这个函数，我们在调用这个函数的时候，引擎会去函数定义区搜索这个函数名进行调用。 函数引用，形如： 123var func = function()&#123; //...&#125; 这种方式会在栈区生成一个变量来保存这个函数的地址。函数代码段仍然保存在函数定义区。 两种定义方式在调用的时候会表现出一些不同。 对于第一种方式，V8引擎会在预扫描阶段进行函数提升，也就是说，你可以在函数定义之前调用该函数； 对于第二种方式，尽管引擎也会进行变量提升（因为其本身就是一个变量），但是并不会在提升的时候对变量赋值，因此不可以在定义之前调用该函数。 1234567//可以正常调用，因为引擎会提前扫描代码，将该函数存储到函数定义区f();function f()&#123;&#125;//报错，因为虽然g也进行了变量提升，但此时g的值是undefined，不能调用g();var g = function()&#123;&#125; 另外，如果函数名发生了重名，浏览器会以通过栈区变量引用的函数优先。如： 12345var f = function()&#123;&#125;function f()&#123;&#125;//会调用第一个函数f(); 之所以出现这种情况，是因为JavaScript引擎总是优先搜索栈区，所以上面的函数会优先被调用。但是如果调用发生在函数定义之前，那么就会调用通过函数声明定义的函数，代码如下： 12345//会调用下面的以函数声明定义的函数f();var f = function()&#123;&#125;//这个函数被调用function f()&#123;&#125; 究其原因，还是在调用函数时变量f的值为undefined，因此引擎才会去函数定义区搜索函数f。总的来说，引擎在调用函数时会以栈区的变量优先，如果搜索不到或为undefined，则会去函数定义区搜索。 但是两者实际上并不冲突，我们同样可以用一个变量来指向一个声明式函数，如： 12function f()&#123;&#125;var g = f; 现在变量g也拿到了函数f的内存地址，使用g同样可以访问该函数。 函数缓冲区函数缓冲区用于存放函数运行时动态申请的空间。函数运行时引擎会为其分配一片空间。当函数运行结束后，会回收其空间。只有当闭包产生的时候才会保留函数缓冲区中的数据。 垃圾回收机制JavaScript 中内存管理的主要概念是可达性（Reachability）。简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。 从上面的内存分配可以看出，每一个变量都会在栈区存储其名字和地址，地址又指向堆区或池。所以JavaScript的GC机制就是当不存在一个变量指向一个内存地址，则引擎认定该内存可以被回收。 这其中有一部分变量是一定可达的，被称为根（root），如： 全局对象 正被调用的函数的局部变量和参数 相关嵌套函数里的变量和参数 其他（引擎内部调用的一些变量） 这些根上面挂载的变量则也一定可达。 具体比如： 12345678let num = 123let cont = 11let str = 'str'let cs = 'cs'let obj = &#123; cont, cs&#125; 此时内存分配结构为： 即池和堆中的每个被分配的内存块都可以通过栈区的变量访问到。所以他们都是可达的，故不会被GC回收。 但是当我们将某一个变量赋为null时候，原来堆池中的值就变成不可达，GC就会进行回收。如： 12345678910111213let num = 123let cont = 11let str = 'str'let cs = 'cs'let obj = &#123; cont, cs&#125;num = nullcont = nullstr = nullcs = null 这个时候把所有的基础变量都置为null，则本来按照回收机制，其所有的基础变量都会被GC回收，但是由于obj中引用了cont,cs，所以虽然这两个变量被置为null了，但是内存中实际的值并没有被回收。此时其内存状况如下 可以看到由于可以从obj访问到cs,11，所以他们不会被回收。 回收算法（精简版）基本的垃圾回收算法称为“标记-清除”，定期执行以下“垃圾回收”步骤: 垃圾回收器获取根并“标记”(记住)它们。 然后它访问并“标记”所有来自它们的引用。 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。 以此类推，直到有未访问的引用(可以从根访问)为止。 除标记的对象外，所有对象都被删除。 下面是一个简单的过程（via前端面试：谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776)）： 可以看出，这实际上是一个广度遍历的过程，对整个栈区的变量构成的图进行广度遍历，并对遍历到的内存坐下标记。当遍历完成时，内存中未被遍历到的内存则证明时不可达的，则GC则可以将其回收。 剩下的内存是不可达的，则会被回收。 上面就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。 一些优化: 分代回收——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。 增量回收——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。 空闲时间收集——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。 闭包上面谈了这么多，都是为了更好的理解闭包。既然理解了内存模型和垃圾回收机制，再理解闭包就是如鱼得水了。 首先我们知道函数内的变量的生命周期只是该函数的运行过程。函数运行一旦结束，函数内的变量就会从函数缓冲区中删除掉。但是有的时候我们需要将函数中的变量永久（或长时间）保存下来，这个时候只需要在函数内部再新建一个函数，并且再内层函数中使用外层函数的变量。再将内层函数作为结果返回出来。由于此时外层函数中的变量由于被内层函数中使用，所以他们是可达的，则GC不会将其回收。如： 12345678910111213function out()&#123; let i = 0; function inner()&#123; i++ console.log(i) &#125; return inner&#125;let in = out()in() //1in() //2in() //3 这里就是一个典型的闭包。我们将使用外层函数的内部函数作为结果返回。我们调用该返回函数就可以操作到外层函数的变量。 闭包的应用用闭包模拟私有方法编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。 而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）： 123456789101112131415161718192021222324var Counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;&#125;)();console.log(Counter.value()); /* logs 0 */Counter.increment();Counter.increment();console.log(Counter.value()); /* logs 2 */Counter.decrement();console.log(Counter.value()); /* logs 1 */ 在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：Counter.increment，`Counter.decrement和Counter.value`。 该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。 这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。 你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量Counter。我们可以把这个函数储存在另外一个变量makeCounter中，并用他来创建多个计数器。 使用闭包形成一个块级作用域，完成异步回调函数（这里使用let解决更好）就像上面的IIFE中，我们使用了闭包来形成一个块级作用域，来完成异步回调函数，不至于造成异步函数执行时循环以完毕。 123456for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; (function(item)&#123; document.getElementById(item.id) = `内容-$&#123;i&#125;` &#125;)(item) &#125; 这里就是利用闭包形成了一个块级作用域。使每一次循环都有一个作用域，使在异步回调执行的时候，其值是正确的。 参考 前端面试：谈谈 JS 垃圾回收机制 Javascript垃圾回收机制 ECMAScript 6 入门 block","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"作用域","slug":"作用域","permalink":"http://yoursite.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"垃圾回收机制","slug":"垃圾回收机制","permalink":"http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"bind,call,apply的用法及实现","slug":"bind-call-apply的用法及实现","date":"2021-01-27T09:57:04.000Z","updated":"2021-01-29T01:35:08.920Z","comments":true,"path":"2021/01/27/bind-call-apply的用法及实现/","link":"","permalink":"http://yoursite.com/2021/01/27/bind-call-apply%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"bindbind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 参数thisArg 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。 当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。 如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg。 arg1, arg2, ... 当目标函数被调用时，被预置入绑定函数的参数列表中的参数。 返回值返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。 描述bind() 函数会创建一个新的绑定函数（bound function，BF）。绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语），它包装了原函数对象。调用绑定函数通常会导致执行包装函数。绑定函数具有以下内部属性： [[BoundTargetFunction]] - 包装的函数对象（即新生成的函数）。 [[BoundThis]] - 在调用包装函数时始终作为 this 值传递的值。 [[BoundArguments]] - 列表，在对包装函数做任何调用都会优先用列表元素填充参数列表。 [[Call]] - 执行与此对象关联的代码。通过函数调用表达式调用。内部方法的参数是一个this值和一个包含通过调用表达式传递给函数的参数的列表。 当调用绑定函数[[BoundTargetFunction]]时，它调用 [[BoundTargetFunction]] 上的内部方法 [[Call]]，就像这样 Call(*boundThis*, *args*)。其中，boundThis 是 [[BoundThis]]，args 是 [[BoundArguments]] 加上通过函数调用传入的参数列表。 绑定函数也可以使用 new 运算符构造，它会表现为目标函数已经被构建完毕了似的。提供的 this 值会被忽略，但前置参数仍会提供给模拟函数。 用法改变this指向（创建绑定this指向的函数）1234567891011121314let a = 'outterA'let obj = &#123; a: 'innerA'&#125;function printA()&#123; console.log(this.a)&#125;printA() //'outterA'let innerPrintA = printA.bind(obj)innerPrintA() //innerA 偏函数通俗的讲，偏函数就是指通过一个初始函数A，创建出另外的函数A1,A2，这两个函数含有了初始参数1，2。这里使用bind是利用了他的两个特点。 bind返回的是绑定函数，区别与Function.prototype.call()，Function.prototype.apply()的立即执行 其接受的是参数列表，并且会与绑定函数调用时的参数合并作用[[call]]原函数，区别于Function.prototype.apply() 123456789function add(arg1, arg2)&#123; return arg1 + arg2&#125;let addThirtynine = add.bind(null, 39)let addEleven = add.bind(null, 11)addThirtynine(3) //42addEleven(3) //14 改变setTimeout，setInterval的this指向由于setTimeout，setInterval的函调函数中this的指向总是window（即使在严格模式下）。所以可以使用bind改变回调函数中的this指向。 123456789101112131415let obj = &#123; message: '内部消息'&#125;message = '外部消息' //这种方法是吧message变量挂载在window上setTimeout(function()&#123; console.log(this.message)&#125;, 1000)//一秒后打印出：'外部消息'setTimeout(function()&#123; console.log(this.message)&#125;.bind(obj), 1000) //将this的指向改变为obj//一秒后打印出：'内部消息' 作为构造函数使用的绑定函数与偏函数用法类似，相当于为构造器提供默认参数。 1234567891011121314151617181920function Point(x, y)&#123; this.x = x this.y = y&#125;Point.prototype.toString = function()&#123; return `$&#123;this.x&#125;,$&#123;this.y&#125;`&#125;let p = new Point(1, 2)p.toString() //'1,2'let emptyObj = &#123;&#125;let YAxisPoint = Point.bind(null, 0/*x*/)let axisPoint5 = new YAxisPoint(5)axisPoint5.toString() //'0,5'axisPoint instanceof Point; // trueaxisPoint instanceof YAxisPoint; // truenew YAxisPoint(17, 42) instanceof Point; // true 快捷调用一些特定的函数被绑定在特定数据类型种，最典型的例子就是Array.prototype.slice，其只能由数组调用。实际上这个函数也接受类数组的对象(array-like object)，这个时候实际上是要改变this的调用。 一般的用法： 1234567let slice = Array.prototype.slicefunction convert()&#123; return slice.apply(arguments) //arguments是一个类数组对象&#125;convert(1,2,3,4) //[1, 2, 3, 4] 在使用bind后，由于其可以生成绑定函数，所以将要使用的函数作为this就可以不用每次都使用apply。 12345678let unboundSlice = Array.prototype.slice;let slice = Function.prototype.apply.bind(unboundSlice); //这个slice就是上面的slice.apply()的一个绑定函数function convert()&#123; return slice(arguments) //arguments是一个类数组对象&#125;convert(1,2,3,4) //[1, 2, 3, 4] 兼容性 Pollyfill法一： 123456789101112131415161718// Does not work with `new (funcA.bind(thisArg, args))`if (!Function.prototype.bind) (function()&#123; let slice = Array.prototype.slice; Function.prototype.bind = function() &#123; let thatFunc = this, thatArg = arguments[0]; let args = slice.call(arguments, 1); if (typeof thatFunc !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - ' + 'what is trying to be bound is not callable'); &#125; return function()&#123; let funcArgs = args.concat(slice.call(arguments)) //合并参数 return thatFunc.apply(thatArg, funcArgs); //绑定this指向 &#125;; &#125;;&#125;)(); 这里利用了Function.prototype.apply构造一个函数，运行及执行apply方法，达到bind的特点。 法二： 12345678910111213141516171819202122232425262728293031// Yes, it does work with `new (funcA.bind(thisArg, args))`if (!Function.prototype.bind) (function()&#123; let ArrayPrototypeSlice = Array.prototype.slice; Function.prototype.bind = function(otherThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; let baseArgs= ArrayPrototypeSlice.call(arguments, 1), baseArgsLength = baseArgs.length, fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; baseArgs.length = baseArgsLength; // reset to default base arguments baseArgs.push.apply(baseArgs, arguments); return fToBind.apply( fNOP.prototype.isPrototypeOf(this) ? this : otherThis, baseArgs ); &#125;; if (this.prototype) &#123; // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; &#125; fBound.prototype = new fNOP(); return fBound; &#125;;&#125;)(); callcall() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 注意：该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 参数thisArg 可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 arg1, arg2, ... 指定的参数列表。（与bind一样） 描述call方法相较于bind，他会生成一个绑定函数并立即调用。 用法基本方法：改变this指向123456789101112let obj = &#123; message: 'inner-message'&#125;message = 'outter-message'function log()&#123; console.log(this.message)&#125;log() //'outter-message'log.call(obj) //'inner-message' 使用 call 方法调用父构造函数使用call方法绑定this对象为自己子类中，则可以完成对父构造器的调用。达到简单的继承效果。 1234567891011121314151617function Product(name, price)&#123; this.name = name this.price = price&#125;function Food(name, price)&#123; Product.call(this, name, price) //调用父构造器，并将this绑定为Food的示例 this.category = 'food'&#125;function Toy(name, price)&#123; Product.call(this, name, price) //调用父构造器，并将this绑定为Toy的示例 this.category = 'toy'&#125; let cheese = new Food('feta', 5)let fun = new Toy('robot', 40) 为匿名函数指定this对象1234567let obj = &#123; message: 'obj-message'&#125;(function()&#123; console.log(this.message)&#125;).call(obj)//'obj-message' 兼容性 Pollyfill1234567891011121314151617181920if (!Function.prototype.call) &#123; Function.prototype.call = function () &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError( 'Function.prototype.call - what is trying to be bound is not callable' ); &#125; let func = this let that = arguments[0] let args = [] for (let i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]) &#125; that.func = func that.func(...args) delete that.func &#125;;&#125; applyapply() 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。 参数 thisArg 必选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 argsArray 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 返回值调用有指定this值和参数的函数的结果。 描述 apply 与 call() 非常相似，不同之处在于提供参数的方式。apply 使用参数数组而不是一组参数列表。apply 可以使用数组字面量（array literal），如 fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])，或数组对象， 如 fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))。 你也可以使用 arguments对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。 从 ECMAScript 第5版开始，可以使用任何种类的类数组对象，就是说只要有一个 length 属性和(0..length-1)范围的整数属性。例如现在可以使用 NodeList 或一个自己定义的类似 {&#39;length&#39;: 2, &#39;0&#39;: &#39;eat&#39;, &#39;1&#39;: &#39;bananas&#39;} 形式的对象。 需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。 用法基本方法：改变this指向123456789101112let obj = &#123; message: 'inner-message'&#125;message = 'outter-message'function log()&#123; console.log(this.message)&#125;log() //'outter-message'log.apply(obj) //'inner-message' 函数数组参数变为列表参数+使用内置函数1234let arr = [2,3,4,5,7]let max = Math.max.apply(null, arr)//7 在ES6中扩展运算符（spread）···来实现函数数组参数变为列表参数： 1234let arr = [2,3,4,5,7]let max = Math.max(...arr)//7 兼容性 Pollyfill1234567891011121314151617181920if (!Function.prototype.apply) &#123; Function.prototype.apply = function () &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError( 'Function.prototype.apply - what is trying to be bound is not callable' ); &#125; let func = this let that = arguments[0] let args = [] for (let i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]) &#125; that.func = func that.func(args) delete that.func &#125;; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"bind","slug":"bind","permalink":"http://yoursite.com/tags/bind/"},{"name":"call","slug":"call","permalink":"http://yoursite.com/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://yoursite.com/tags/apply/"}]},{"title":"JavaScript中数组与对象的遍历方法","slug":"JavaScript中数组与对象的遍历方法","date":"2021-01-26T05:48:19.000Z","updated":"2021-10-12T14:41:01.068Z","comments":true,"path":"2021/01/26/JavaScript中数组与对象的遍历方法/","link":"","permalink":"http://yoursite.com/2021/01/26/JavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"数组for循环最传统的方法，按下标存取，也是最高效的方法 123456789101112let arr = [1,2,3,4]for(let i = 0; i &lt; arr.length; i++)&#123; console.log(arr[i])&#125;//1，2，3，4//不用每次计算len，更加高效for(let i = 0, let len = arr.length; i &lt; len; i++)&#123; console.log(arr[i])&#125;//1，2，3，4 for…of循环for...of语句创建一个迭代器(ES6引入，迭代器只会便利可枚举属性)。每一次循环都会调用迭代器的next对象。并返回当前该迭代器的值。 123456let arr = [1,2,3,4]for(let val of arr)&#123; console.log(val)&#125;//1,2,3,4 另外只要实现了迭代器的数据才能使用for...of循环。具体有：Array，Maps，Set，String，Arguments Object参数对象，Generators(生成器) for…in循环for...in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。 123456let arr = [1,2,3,4]for(let i in arr)&#123; console.log(i)&#125;//0，1，2，3 注意： for ...in循环遍历得到的结果为数据的键（数组即为下标）。 数组最好不要用for...in，因为for...in循环是为遍历对象而且设计的。 该方法也可用于String遍历下标。 for...in会顺着原型链向上遍历，原型链上所有的可遍历对象都会被遍历。比如（定义Array.prototype.max = () =&gt; {...}来获取数组中最大值，如果这么定义，那么这个属性也会被for...in纳入遍历） Array.prototype.entries()该方法一个新的 Array 迭代器对象。Array Iterator是对象，它的原型（proto:Array Iterator）上有一个next方法，可用用于遍历迭代器取得原数组的[key,value]。 12345678910var arr = [\"a\", \"b\", \"c\"];var iterator = arr.entries();console.log(iterator);/*Array Iterator &#123;&#125; __proto__:Array Iterator next:ƒ next() Symbol(Symbol.toStringTag):\"Array Iterator\" __proto__:Object*/ 用法一（直接使用Iterator的next对象）： 123456789const array1 = ['a', 'b', 'c'];const iterator1 = array1.entries();console.log(iterator1.next().value);// expected output: Array [0, \"a\"]console.log(iterator1.next().value);// expected output: Array [1, \"b\"] 用法二（二维数组按行排序）： 1234567891011121314151617181920212223242526function sortArr(arr) &#123; var goNext = true; var entries = arr.entries(); while (goNext) &#123; var result = entries.next(); if (result.done !== true) &#123; result.value[1].sort((a, b) =&gt; a - b); goNext = true; &#125; else &#123; goNext = false; &#125; &#125; return arr;&#125;var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];sortArr(arr);/*(4) [Array(2), Array(5), Array(5), Array(4)] 0:(2) [1, 34] 1:(5) [2, 3, 44, 234, 456] 2:(5) [1, 4, 5, 6, 4567] 3:(4) [1, 23, 34, 78] length:4 __proto__:Array(0)*/ 法三（使用for…of 循环）最典型： 1234567891011121314151617var arr = [\"a\", \"b\", \"c\"];var iterator = arr.entries();for (let v of iterator) &#123; console.log(v);&#125;// [0, \"a\"]// [1, \"b\"]// [2, \"c\"]for (let [index, value] of iterator) &#123; console.log(index+'---'+value);&#125;// 0-\"a\"// 1-\"b\"// 2-\"c\" Array.prototype.keys() keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。 与上面的Array.prototype.entries()相同，只是遍历的是索引键。用法与上面完全一致，本质也是迭代器。 典型用法(结合for...of)： 1234567let arr = [1,2,3,4]for(let i of arr.keys())&#123; console.log(i)&#125;//0，1，2，3 Array.prototype.values()values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值 与上面的Array.prototype.entries()相同，只是遍历的是索引键。用法与上面完全一致，本质也是迭代器。 典型用法(结合for...of)： 1234567const arr = ['a', 'b', 'c'];for (const value of arr.values()) &#123; console.log(value);&#125;//a，b，c Array.prototype.every()every()方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 其接收一个回调函数callback，callback 在被调用时可传入三个参数：元素值，元素的索引，原数组。 every 不会改变原数组。 every 和数学中的”所有”类似，当所有的元素都符合条件才会返回true。正因如此，若传入一个空数组，无论如何都会返回 true。（这种情况属于无条件正确：正因为一个空集合没有元素，所以它其中的所有元素都符合给定的条件。) 注意：若收到一个空数组，此方法在一切情况下都会返回 true。 典型用法： 123456789101112let arr = [5,6,4,7,8]arr.every((value, index, arr) =&gt; &#123; return value &gt; 3&#125;)//true（因为所有的value都大于3）arr.every((value, index, arr) =&gt; &#123; return value &gt; 5&#125;)//false（其中4,5不满足条件） every方法不会改变数组。 Pollyfill（最基础，下同）1234567891011121314151617181920212223if (!Array.prototype.every) &#123; Object.defineProperty(Array.prototype, 'every', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.every ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = true; for (let [i, v] of this.entries()) &#123; if (!callback(v)) &#123; res = false; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.some()这个方法与上面的方法使用方法完全相同，但是所用相反，some()方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 其接收一个回调函数callback，callback 在被调用时可传入三个参数：元素值，元素的索引，原数组。 注意：如果用一个空数组进行测试，在任何情况下它返回的都是false。 典型用法： 12345678910111213let arr = [6,9,3,4]arr.some((value, index, arr) =&gt; &#123; return value &gt; 8&#125;)//true（因为存在一个9大于8）arr.some((value, index, arr) =&gt; &#123; return value &gt; 12&#125;)//false（因为所有的value都小于12） some方法不会改变数组。 Pollyfill1234567891011121314151617181920212223if(!Array.prototype.some)&#123; Object.defineProperty(Array.prototype, 'some', &#123; enumerable: false, value: function (callbakc) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.some ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = false; for (let [i, v] of this.entries()) &#123; if (callbakc(v, i, this)) &#123; res = true; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.filter()filter() 方法创建一个新数组, 其包含通过所提供函数实现的过滤的所有元素的结果。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：一个数组，包含所有的元素的检测结果。 1234567let arr = [1, 2, 3, 4]arr.filter((value, index, arr) =&gt; &#123; return value &gt; 2&#125;)//[3, 4] 该方法可用于剔除不合法数据，比如 1234567let arr = [1,2,3, undefined, null, 4, 5]arr.filter((value, index, arr) =&gt; &#123; return value != undefined &amp;&amp; value != null&#125;)//[1, 2, 3, 4, 5] flter方法不会改变数组。 Pollyfill12345678910111213141516171819202122if (!Array.prototype.filter) &#123; Object.defineProperty(Array.prototype, 'filter', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.filter ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = []; for (let i = 0; i &lt; this.length; i++) &#123; if (callback(this[i])) &#123; res.push(this[i]); &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.find() find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：数组中满足提供的测试函数的第一个元素的值。 1234567let arr = [1,2,3,4]arr.find((value, index, arr) =&gt; &#123; return value &gt; 2&#125;)//2（由于3，4均大于2，但是3是第一个，所以返回3的下标2） find方法不会改变数组。 Pollyfill1234567891011121314151617181920212223if (!Array.prototype.find) &#123; Object.defineProperty(Array.prototype, 'find', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.find ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = undefined; for (let i = 0; i &lt; this.length; i++) &#123; if (callback(this[i], i, this)) &#123; res = this[i]; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.findIndex()findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：数组中满足提供的测试函数的最后一个元素的值。 1234567let arr = [1,2,3,4]arr.find((value, index, arr) =&gt; &#123; return value &gt; 2&#125;)//3（由于3，4均大于2，但是4是最后一个，所以返回4的下标3） Pollyfill123456789101112131415161718192021222324if (!Array.prototype.findIndex) &#123; Object.defineProperty(Array.prototype, 'findIndex', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.findIndex ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = -1; for (let i = 0; i &lt; this.length; i++) &#123; if (callback(this[i], i, this)) &#123; res = i; break; &#125; &#125; return res; &#125;, &#125;);&#125; Array.prototype.forEach()forEach()方法对数组的每个元素执行一次给定的函数。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：undefined。 forEach() 为每个数组元素执行一次 callback 函数；与 map() 或者 reduce() 不同的是，它总是返回 undefined 值，并且不可链式调用。其典型用例是在一个调用链的最后执行副作用（side effects，函数式编程上，指函数进行 返回结果值 以外的操作）。 forEach 不会直接改变调用它的对象，但是那个对象可能会被 callback 函数改变。 示例： 12345678let arr = [1, 2, 3, 4]let res = []arr.forEach((value, index, arr) =&gt; &#123; res.push(value*2) &#125;)console.log(res) //[2,4,6,8] Pollyfill123456789101112131415161718if (!Array.prototype.forEach) &#123; Object.defineProperty(Array.prototype, 'forEach', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.forEach ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; for (let i = 0; i &lt; this.length; i++) &#123; callback(this[i], i, this); &#125; &#125;, &#125;);&#125; Array.prototype.map()map()方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。（forEach类似，区别是forEach不用返回，一起操作都在回调函数中进行） 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 返回：一个由原数组每个元素执行回调函数的结果组成的新数组。 上面的示例重写： 12345let arr = [1, 2, 3, 4]let res = arr.map((value, index, arr) =&gt; &#123; return value * 2&#125;)console.log(res) //[2, 4, 6, 8] callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。 因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。 map不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组） 根据规范中定义的算法，如果被map调用的数组是离散的（如：arr = [emptyx2, 3]），新数组将也是离散的保持相同的索引为空。 Pollyfill1234567891011121314151617181920if (!Array.prototype.map) &#123; Object.defineProperty(Array.prototype, 'map', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.map ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let res = []; for (let i = 0; i &lt; this.length; i++) &#123; res.push(callback(this[i], i, this)); &#125; return res; &#125;, &#125;);&#125; Array.prototype.reduce()reduce()方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 接受：函数累计处理的结果reducer 函数接收4个参数: Accumulator (acc) (累计器) Current Value (cur) (当前值) Current Index (idx) (当前索引) Source Array (src) (源数组) callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。 返回值：函数累计处理的结果 示例： 数组里所有值的和 1234var sum = [0, 1, 2, 3].reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue;&#125;, 0);// 和为 6 累加对象数组里的值 要累加对象数组中包含的值，必须提供初始值，以便各个item正确通过你的函数。 123456var initialValue &#x3D; 0;var sum &#x3D; [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue.x;&#125;,initialValue)console.log(sum) &#x2F;&#x2F; logs 6 你也可以写成箭头函数的形式： 1234567var initialValue &#x3D; 0;var sum &#x3D; [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce( (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue.x ,initialValue);console.log(sum) &#x2F;&#x2F; logs 6 计算数组中每个元素出现的次数 12345678910111213var names &#x3D; [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Tiff&#39;, &#39;Bruce&#39;, &#39;Alice&#39;];var countedNames &#x3D; names.reduce(function (allNames, name) &#123; if (name in allNames) &#123; allNames[name]++; &#125; else &#123; allNames[name] &#x3D; 1; &#125; return allNames;&#125;, &#123;&#125;);&#x2F;&#x2F; countedNames is:&#x2F;&#x2F; &#123; &#39;Alice&#39;: 2, &#39;Bob&#39;: 1, &#39;Tiff&#39;: 1, &#39;Bruce&#39;: 1 &#125; Polyfillreduce 被添加到 ECMA-262 标准第 5 版，因此它在某些实现环境中可能不被支持。把下面的代码添加到脚本开头可以解决此问题，从而允许在那些没有原生支持 reduceRight 的实现环境中使用它。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Production steps of ECMA-262, Edition 5, 15.4.4.21// Reference: http://es5.github.io/#x15.4.4.21// https://tc39.github.io/ecma262/#sec-array.prototype.reduceif (!Array.prototype.reduce) &#123; Object.defineProperty(Array.prototype, 'reduce', &#123; value: function(callback /*, initialValue*/) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.reduce ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError( callback + ' is not a function'); &#125; // 1. Let O be ? ToObject(this value). var o = Object(this); // 2. Let len be ? ToLength(? Get(O, \"length\")). var len = o.length &gt;&gt;&gt; 0; // Steps 3, 4, 5, 6, 7 var k = 0; var value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &lt; len &amp;&amp; !(k in o)) &#123; k++; &#125; // 3. If len is 0 and initialValue is not present, // throw a TypeError exception. if (k &gt;= len) &#123; throw new TypeError( 'Reduce of empty array ' + 'with no initial value' ); &#125; value = o[k++]; &#125; // 8. Repeat, while k &lt; len while (k &lt; len) &#123; // a. Let Pk be ! ToString(k). // b. Let kPresent be ? HasProperty(O, Pk). // c. If kPresent is true, then // i. Let kValue be ? Get(O, Pk). // ii. Let accumulator be ? Call( // callbackfn, undefined, // « accumulator, kValue, k, O »). if (k in o) &#123; value = callback(value, o[k], k, o); &#125; // d. Increase k by 1. k++; &#125; // 9. Return accumulator. return value; &#125; &#125;);&#125; 1234567891011121314151617181920//concise method if (!Array.prototype.reduce) &#123; Object.defineProperty(Array.prototype, 'reduce', &#123; enumerable: false, value: function (callback) &#123; if (this === null) &#123; throw new TypeError( 'Array.prototype.map ' + 'called on null or undefined' ); &#125; if (typeof callback !== 'function') &#123; throw new TypeError(callback + ' is not a function'); &#125; let count = 0; for (let i = 0; i &lt; this.length; i++) &#123; count += callback(count, this[i], i, this); &#125; &#125;, &#125;); &#125; Array.prototype.reduceRight()这个方法与Array.prototype.reduce()只是执行顺序上相反（从右到左）。 reduceRight()方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 接收：一个回调函数，函数包含3个参数。value(元素的值)，index(元素的索引)，arr(被遍历的数组本身) 求一个数组中所有值的和1234var sum = [0, 1, 2, 3].reduceRight(function(a, b) &#123; return a + b;&#125;);// sum is 6 （虽然结果相同，但是是从右到左加） 展示 reduce 与 reduceRight 之间的区别123456var a &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;];var left &#x3D; a.reduce(function(prev, cur) &#123; return prev + cur; &#125;);var right &#x3D; a.reduceRight(function(prev, cur) &#123; return prev + cur; &#125;);console.log(left); &#x2F;&#x2F; &quot;12345&quot;console.log(right); &#x2F;&#x2F; &quot;54321&quot; PolyfillreduceRight 被添加到 ECMA-262 标准第 5 版，因此它在某些实现环境中可能不被支持。把下面的代码添加到脚本开头可以解决此问题，从而允许在那些没有原生支持 reduceRight 的实现环境中使用它。 12345678910111213141516171819202122232425262728293031// Production steps of ECMA-262, Edition 5, 15.4.4.22// Reference: http://es5.github.io/#x15.4.4.22if ('function' !== typeof Array.prototype.reduceRight) &#123; Array.prototype.reduceRight = function(callback /*, initialValue*/) &#123; 'use strict'; if (null === this || 'undefined' === typeof this) &#123; throw new TypeError('Array.prototype.reduceRight called on null or undefined'); &#125; if ('function' !== typeof callback) &#123; throw new TypeError(callback + ' is not a function'); &#125; var t = Object(this), len = t.length &gt;&gt;&gt; 0, k = len - 1, value; if (arguments.length &gt;= 2) &#123; value = arguments[1]; &#125; else &#123; while (k &gt;= 0 &amp;&amp; !(k in t)) &#123; k--; &#125; if (k &lt; 0) &#123; throw new TypeError('reduceRight of empty array with no initial value'); &#125; value = t[k--]; &#125; for (; k &gt;= 0; k--) &#123; if (k in t) &#123; value = callback(value, t[k], k, t); &#125; &#125; return value; &#125;;&#125; 下面是几种遍历方法的时间对比，可以看出传统for...耗时最少，；for...in最差。 对象for…in方法上面已经提到了for...in方法用于遍历数据的索引键。所以这个方法也可以用于遍历对象，具体方法如下： 123456789101112let obj = &#123;a : 1, b : 2, c : 3, d : 4&#125;for(let i in obj)&#123; console.log(`$&#123;i&#125;---$&#123;obj[i]&#125;`)&#125;/**a---1*b---2*c---3*d---4*/ Object.entries()Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。 参数 obj 可以返回其可枚举属性的键值对的对象。 返回值Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。 示例1234567891011121314151617181920212223242526272829const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]// array like objectconst obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]// array like object with random key orderingconst anObj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]// getFoo is property which isn't enumerableconst myObj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value() &#123; return this.foo; &#125; &#125; &#125;);myObj.foo = 'bar';console.log(Object.entries(myObj)); // [ ['foo', 'bar'] ]// non-object argument will be coerced to an objectconsole.log(Object.entries('foo')); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]// iterate through key-value gracefullyconst obj = &#123; a: 5, b: 7, c: 9 &#125;;for (const [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125; $&#123;value&#125;`); // \"a 5\", \"b 7\", \"c 9\"&#125;// Or, using array extrasObject.entries(obj).forEach(([key, value]) =&gt; &#123;console.log(`$&#123;key&#125; $&#123;value&#125;`); // \"a 5\", \"b 7\", \"c 9\"&#125;); Object.keys()Object.keys()方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。 参数 obj 要返回其枚举自身属性的对象。 返回值一个表示给定对象的所有可枚举属性（索引键）的字符串数组。 描述Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性（索引键）。这些属性的顺序与手动遍历该对象属性时的一致。 示例1234567891011121314151617181920// simple arrayvar arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // console: ['0', '1', '2']// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.keys(obj)); // console: ['0', '1', '2']// array like object with random key orderingvar anObj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.keys(anObj)); // console: ['2', '7', '100']// getFoo is a property which isn't enumerablevar myObj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function () &#123; return this.foo; &#125; &#125;&#125;);myObj.foo = 1;console.log(Object.keys(myObj)); // console: ['foo'] Object.values()Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。 参数 obj 被返回可枚举属性值的对象。 返回值一个包含对象自身的所有可枚举属性值的数组。 描述Object.values()返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。 示例12345678910111213141516171819var obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.values(obj)); // ['bar', 42]// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.values(obj)); // ['a', 'b', 'c']// array like object with random key ordering// when we use numeric keys, the value returned in a numerical order according to the keysvar an_obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.values(an_obj)); // ['b', 'c', 'a']// getFoo is property which isn't enumerablevar my_obj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function() &#123; return this.foo; &#125; &#125; &#125;);my_obj.foo = 'bar';console.log(Object.values(my_obj)); // ['bar']// non-object argument will be coerced to an objectconsole.log(Object.values('foo')); // ['f', 'o', 'o'] 本文大部分参考了MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"遍历","slug":"遍历","permalink":"http://yoursite.com/tags/%E9%81%8D%E5%8E%86/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1/"}]},{"title":"flex布局与grid布局简介","slug":"flex布局与grid布局简介","date":"2021-01-24T07:45:23.000Z","updated":"2021-01-25T13:19:33.582Z","comments":true,"path":"2021/01/24/flex布局与grid布局简介/","link":"","permalink":"http://yoursite.com/2021/01/24/flex%E5%B8%83%E5%B1%80%E4%B8%8Egrid%E5%B8%83%E5%B1%80%E7%AE%80%E4%BB%8B/","excerpt":"","text":"flex布局flex布局可以更加简洁的实现之前使用浮动和绝对布局实现的一些布局。特别是item的展示界面等。 首先应该明确一个概念，这个概念在grid布局中也存在，就是container与item，即被布局的元素被称为item，包围这些item的元素即为container。在flex布局中，item的大小要自己设置。 flex布局相对于grid布局，简单许多，它是按照轴线的方式进行布局，按照item其规定一个主轴线main axis（默认为水平），然后对应的即为交叉轴cross axis（默认为垂直）。 所以其属性也分为容器属性和元素属性。 容器属性首先要使用flex布局，就要将容器的display属性设为flex。 注意：一旦将容器的display属性设为flex，则其item的float、clear和vertical-align属性将失效。 1. flex-direction属性flex-direction属性规定了主轴的方向。由于主轴可能有水平、垂直方向，又每个轴又可以从左到右，从上到下或相反。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2. flex-wrap属性flex-wrap属性规定了主轴是否进行换行。默认是不进行换行，又由于flex布局中，item的大小是自己规定的，所以在一行中，若item的总宽度大于父容器的宽度，则会对元素的宽度进行压缩。其有3个属性： nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，从最后一行的左边开始换行，向上换行。 3. flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4. justify-content属性justify-content属性定义了项目在主轴上的对齐方式。其有5个值。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等，两侧无间隔。 space-around：每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。 space-evently：每个项目两侧的间隔相等。间隔等于两侧的间隔。 5. align-items属性align-items属性将所有直接子节点上的align-self值设置为一个组。 align-self属性设置项目在其包含块中在交叉轴方向上的对齐方式。其有5个属性（需要注意的是这里是对每个交叉轴而言，即规定每个交叉轴上元素的对其方式，每个交叉轴上的行宽不会变，这里区别于align-content属性）： flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6. align-content属性align-content属性设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。如果项目只有一根轴线，该属性不起作用。（即每个交叉轴的宽度不是固定的，区别于上面的align-items属性）其有6个值： flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目属性这些属性用于item中。 1. order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 2. flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3. flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4. flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。（这个属性与width相斥，只有一个属性生效。） 5. flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 3. align-self属性align-self属性允许单个项目有与其他项目在交叉行不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 注意：MDN中每个属性还有另外的一些值，比如align-items还有self-atart，start等属性，但是实测在chrome中虽然不会提示错误，但是也不会生效，只有上面的属性会生效，而且VSCODE中也只会提示上面的值，所以，目前只需掌握上面的值即可 grid布局grid布局应该是目前原生最先进的布局方案，也正是因为其原生先进，所以其兼容性并不是很好。 可以看出Chrome在57版本以上才支持，而IE直接不支持。所以不是很友好。但这grid布局是以后的主流。所以可以提前了解其特点。 相同，grid布局中也分为：container容器和item项目。 容器属性1. display 属性display: grid指定一个容器采用网格布局。 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 2. grid-template-columns 属性， grid-template-rows 属性容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 12345.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 上面代码指定了一个三行三列的网格，列宽和行高都是100px。 除了使用绝对单位，也可以使用百分比。 12345.container &#123; display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%;&#125; repeat()：repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。如：repeat(3, 20px)，也可以定义为repeat(3, 10px 20px 30px) auto-fill 关键字：有时，项目的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。 1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; 上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。 fr 关键字：为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。 1234.container &#123; display: grid; grid-template-columns: 1fr 1fr;&#125; 上面代码表示两个相同宽度的列。 fr可以与绝对长度的单位结合使用，这时会非常方便。 1234.container &#123; display: grid; grid-template-columns: 150px 1fr 2fr;&#125; 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。 minmax() minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 1grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 auto 关键字 auto关键字表示由浏览器自己决定长度。 1grid-template-columns: 100px auto 100px; 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。 网格线的名称 grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。 12345.container &#123; display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&#125; 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 3. grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。 最新标准中，grid-row-gap缩写为row-gap；grid-column-gap缩写为colimn-gap。 grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。 1grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; 4. grid-template-areas 属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。 12345678.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i';&#125; 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。 多个单元格合并成一个区域的写法如下。 123grid-template-areas: 'a a a' 'b b b' 'c c c'; 上面代码将9个单元格分成上下a、b、c三个区域。 下面是一个布局实例。 123grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\"; 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。 如果某些区域不需要利用，则使用”点”（.）表示。 123grid-template-areas: 'a . c' 'd . f' 'g . i'; 上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 下面是一个经典布局（其中item的属性grid-area下面介绍）： 1234567891011121314151617181920212223242526 &lt;!--css代码--&gt;.grid &#123; display: grid; grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\"; /* background-color: rgb(247, 80, 177); */ grid-template-rows: 30px 300px 30px; grid-template-columns: 400px 50px 50px; &#125; #header&#123; grid-area: header; background-color: rgb(206, 206, 206); &#125; #main&#123; grid-area: main; background-color: rgb(235, 224, 74); &#125; #sidebar&#123; grid-area: sidebar; background-color: rgb(250, 99, 99); &#125; #footer&#123; grid-area: footer; background-color: rgb(112, 72, 255); &#125; 1234567&lt;!--html代码--&gt; &lt;div class=\"grid\"&gt; &lt;div class=\"grid-inner\" id=\"header\"&gt;&lt;/div&gt; &lt;div class=\"grid-inner\" id=\"sidebar\"&gt;&lt;/div&gt; &lt;div class=\"grid-inner\" id=\"main\"&gt;&lt;/div&gt; &lt;div class=\"grid-inner\" id=\"footer\"&gt;&lt;/div&gt; &lt;/div&gt; 效果图： 3. grid-auto-flow 属性grid-auto-flow 属性决定子元素的排列方式。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 即grid-auto-flow 属性默认值为：row 其取值可以有： 单值 row（默认值）：按行进行排列 column：按列进行排列 dense：该关键字指定自动布局算法使用一种“稠密”堆积算法，如果后面出现了稍小的元素，则会试图去填充网格中前面留下的空白。这样做会填上稍大元素留下的空白，但同时也可能导致原来出现的次序被打乱。 如果省略它，使用一种「稀疏」算法，在网格中布局元素时，布局算法只会「向前」移动，永远不会倒回去填补空白。这保证了所有自动布局元素「按照次序」出现，即使可能会留下被后面元素填充的空白。 双值 row dense：按行排列，并按稠密算法进行填补。 column dense：按列排行，并按稠密算法进行填补。 正式语法1[ row | column ] || dense 4. justify-items 属性， align-items 属性， place-items 属性justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。 1234.container &#123; justify-items: start | end | center | stretch; align-items: start | end | center | stretch;&#125; 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-items属性是align-items属性和justify-items属性的合并简写形式。 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 下面是一个例子。 1place-items: start end; 如果省略第二个值，则浏览器认为与第一个值相等。 另外这个属性还有其他的值，但是支持度并不好： 支持较好的属性： 5. justify-content 属性， align-content 属性， place-content 属性justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。 start - 对齐容器的起始边框。 end - 对齐容器的结束边框。 center - 容器内部居中。 stretch - 项目大小没有指定时，拉伸占据整个网格容器。 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性是align-content属性和justify-content属性的合并简写形式。 1place-content: &lt;align-content&gt; &lt;justify-content&gt; 如果省略第二个值，浏览器就会假定第二个值等于第一个值。 6. grid-auto-columns 属性， grid-auto-rows 属性有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行（使用grid-column-start等属性）。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 123456789.container&#123; display:flex; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125;.item8&#123; grid-row-start: 4; grid-column-start: 2;&#125; 可以看到原本container只有3行3列，但是第8个item被设定在第四行，则浏览器会自动生成第4行，这个第四行就会受grid-auto-rows属性控制。 7. grid-template 属性， grid 属性grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。 grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。 项目属性1. grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线 1234.item-1 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。 上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。 除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。 下面的例子是指定四个边框位置的效果。 123456.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4;&#125; 另外，这4个属性的值还可以取网格线名字，和上面的网格线名字 1234.item-1 &#123; grid-column-start: header-start; //这里是网格线名字 grid-column-end: header-end; //这里是网格线名字&#125; 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 123.item-1 &#123; grid-column-start: span 2;&#125; 上面代码表示，1号项目的左边框距离右边框跨越2个网格。 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 2. grid-column 属性， grid-row 属性grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 1234.item &#123; grid-column: &lt;start-line&gt; / &lt;end-line&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt;;&#125; 下面是一个例子。 1234567891011.item-1 &#123; grid-column: 1 / 3; grid-row: 1 / 2;&#125;/* 等同于 */.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;/* 等同于 */.item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 3. grid-area 属性grid-area属性指定项目放在哪一个区域。 123.item-1 &#123; grid-area: e;&#125; 上面代码中，1号项目位于e区域，效果如下图。 注意：需要在container中使用： 123grid-template-areas: 'a b c' 'd e f' 'g h i'; 来指定区域的位置 grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 下面是一个例子。 123.item-1 &#123; grid-area: 1 / 1 / 3 / 3;&#125; 4. justify-self 属性， align-self 属性， place-self 属性justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 1234.item &#123; justify-self: start | end | center | stretch; align-self: start | end | center | stretch;&#125; 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-self属性是align-self属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 下面是一个例子。 1place-self: center center; 如果省略第二个值，place-self属性会认为这两个值相等。 总结可以看出： flex布局与grid布局相较于原始的浮动布局，简单快捷很多。所以目前flex布局使用的较多，但是由于grid布局的兼容性并不好，所以使用的并不多。 两种布局的属性中存在很多其他W3C以规定的属性，但是浏览器很多都没有实现，Chrome虽然有对应的值，但是并没有生效。 一个问题使用flex布局进行多行布局，并使用justify-content:center/space-around-space-between时，如果最后一行的item数目少于屏幕能容纳的最大数，最后一行会出现问题，即最后一行不能左对齐，会按照其属性进行居中。 目前还没找到很好的解决办法，特别是在每行的数目不能确定的情况下，目前最普遍的方法时使用空白标签占位法，即使用每行添加最大能容纳的item数目的空白标签。这样空白标签不会显示，显性标签就会展示为左对其。但是任然还有一个问题，就是如果每行的数目减小，或者刚好能够容纳，则会出现一行(甚至两行)空白区域。虽然不影响，但是感觉仍然不是最优解。grid布局虽然能够在格式上完美解决，但是由于其兼容性，也不是很好的解决办法。目前仍在想能有什么解决办法。","categories":[{"name":"布局","slug":"布局","permalink":"http://yoursite.com/categories/%E5%B8%83%E5%B1%80/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"},{"name":"flex布局","slug":"flex布局","permalink":"http://yoursite.com/tags/flex%E5%B8%83%E5%B1%80/"},{"name":"grid","slug":"grid","permalink":"http://yoursite.com/tags/grid/"}]},{"title":"Vue插件开发4-插件的打包与引用","slug":"Vue插件开发4-插件的打包与引用","date":"2021-01-13T04:10:05.000Z","updated":"2021-01-16T06:49:24.073Z","comments":true,"path":"2021/01/13/Vue插件开发4-插件的打包与引用/","link":"","permalink":"http://yoursite.com/2021/01/13/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%914-%E6%8F%92%E4%BB%B6%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E5%BC%95%E7%94%A8/","excerpt":"","text":"Vue插件的打包还是犯了一个最基础的错误，本来插件打包Vue-CLI官网给出了说明，而我还在苦苦百度。百度上的教程都是几年前的，全是照搬一套。 具体过程就是： 按照Vue插件开发1-插件原理即应用编写一个插件。 使用命令vue-cli-service build --target lib --name myLib [entry] myLib就是你的插件名字，主要是JS文件的命名。 [entry]是你的文件入口文件，即导出install函数文件 执行该命令就会生成打包完成的js文件。 dist/drag-window.common.js：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包) dist/drag-window.umd.js：一个直接给浏览器或 AMD loader 使用的 UMD 包 dist/drag-window.umd.min.js：压缩后的 UMD 构建版本 dist/drag-window.css：提取出来的 CSS 文件 (可以通过在 vue.config.js 中设置 css: { extract: false } 强制内联) js.map：source map文件是js文件压缩后，文件的变量名替换对应、变量所在位置等元信息数据文件，一般这种文件和min.js主文件放在同一个目录下。 比如压缩后原变量是map，压缩后通过变量替换规则可能会被替换成a，这时source map文件会记录下这个mapping的信息，这样的好处就是说，在调试的时候，如果有一些JS报错，那么浏览器会通过解析这个map文件来重新merge压缩后的js,使开发者可以用未压缩前的代码来调试，这样会给我们带来很大的方便！ npm插件的上传npm其实就是一个仓库。与git一样，我们使用npm install xxx的时候实际上是把其仓库中的xxx文件夹下载到本地。并再到node_modules中，我就可以直接使用import xxx from xxx的语法引入插件，实际上与我们在src下新建一个文件夹lib，然后使用import xxx from ./lib/xxx.js效果一样。 所以我们只需要 在npm注册一个npm账号。 然后新建一个文件夹使用npm init 初始化一个package.js文件。 123456789101112131415&#123; \"name\": \"drag-window\", \"version\": \"0.0.21\", \"description\": \"A plugin creating a drag window\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"darg\", \"window\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\" ], \"author\": \"mw530\", \"license\": \"MIT\"&#125; 这是一个最基本的样板，关键是private: true，然后把main.js设为生成的那个js文件。 在命令行使用npm adduser将自己的用户添加上去。 使用npm publish上传自己的文件。 注意：其中一个点是仓库必须切换为官方仓库，不能为淘宝仓库。 官方仓库：npm config set registry=http://registry.npmjs.org 淘宝仓库：npm install -g cnpm –registry=https://registry.npm.taobao.org; 插件的引用与Vue插件开发1-插件原理即应用的使用一样，只是引入的地址直接写插件命即可，如import xxx from &#39;xxx&#39;。然后使用Vue.use(xxx)。 注意样式表文件需全局直接import xxx/aaa.css，如果在&lt;style&gt;使用了使用了scope属性，则其样式表只在对应组件起效，如果不加，则会全局影响。","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/tags/Vue%E6%8F%92%E4%BB%B6/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"Vue插件开发3-简单拖动窗口的优化","slug":"Vue插件开发3-拖动窗口的优化","date":"2021-01-13T04:02:08.000Z","updated":"2021-01-16T02:05:31.776Z","comments":true,"path":"2021/01/13/Vue插件开发3-拖动窗口的优化/","link":"","permalink":"http://yoursite.com/2021/01/13/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%913-%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"","text":"思路思路一中心思想：首先算出首次拖动窗口距视窗的上面和左面的距离，然后计算出每次鼠标的偏移量（可正可负）。然后将其相加，就可得到新的偏移量。 代码思路： 设置一个变量，用于标记鼠标是否按下。 mousedown钩子函数中记录下此时的clientX1,clientY1,offsetX,offsetY。 mousemove钩子函数中记录下次此时的clientX2,clientY2，然后计算两组量： 拖动之前拖动框距文档边框的距离left1 = clientX1 - offsetX，top1 = clientY1 - offsetY 拖动的距离disX = clientX2 - clientX1，disY = clientY2 - clientY1 此时新的left2 = left + disX，top2 = top + disY 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546banMouseDown(e) &#123; console.log(\"鼠标按下\"); this.isDown = true; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); Vue.set(this.currenctPositon, \"x\", e.clientX); Vue.set(this.currenctPositon, \"y\", e.clientY); Vue.set(this.currenctPositon, \"offX\", e.offsetX); Vue.set(this.currenctPositon, \"offY\", e.offsetY);&#125;,banMouseUp() &#123; this.isDown = false; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"default\";&#125;,banMouseMove(e) &#123; debounce(this, this.handle, 20)(e); //节流函数&#125;,handle(e) &#123; if (this.isDown) &#123; console.log(e); let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); let cx = e.clientX; let cy = e.clientY; let moveX = (this.currenctPositon.x - this.currenctPositon.offX) + (cx - this.currenctPositon.x); let moveY = (this.currenctPositon.y - this.currenctPositon.offY) + (cy - this.currenctPositon.y); Vue.set(this.currenctPositon, \"x\", cx); Vue.set(this.currenctPositon, \"y\", cy); dw.style.left = moveX + \"px\"; dw.style.top = moveY + \"px\"; &#125;&#125;, 思路二然后又发现另一个思路（似乎更简单）： 中心思想：要想达到拖动效果，即要保持鼠标的位置相对于拖动框是相对静止的。而鼠标的位置相对于拖动框就是offset的值，是不会变化的。所以当鼠标发生移动时，拖动框的位置也要发生变化，才能保证offset的值是不变的。所以我们在新的一次鼠标移动(mousemove)后，新的偏移量应当赋予拖动框的left,right值。即left = clientX2 - offsetX，top = clientY2 - offsetY 代码思路： 设置一个变量，用于标志鼠标是否按下。 mousedown钩子函数中记录下此时的clientX1,clientY1,offsetX,offsetY。 mousemove钩子函数中记录下次此时的clientX2,clientY2，然后计算拖动出偏移量dOffsetX，dOffsetY，具体 left = clientX2 - offsetX top = clientY2 - offsetY 将拖动窗口的样式: style.left设置为left style.top设置为top 实测是可以使用的。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940banMouseDown(e) &#123; console.log(\"鼠标按下\"); this.isDown = true; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); Vue.set(this.currenctPositon, \"x\", e.clientX); Vue.set(this.currenctPositon, \"y\", e.clientY); Vue.set(this.currenctPositon, \"offX\", e.offsetX); Vue.set(this.currenctPositon, \"offY\", e.offsetY);&#125;, banMouseUp() &#123; this.isDown = false; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"default\"; &#125;, banMouseMove(e) &#123; debounce(this, this.handle, 20)(e); &#125;, handle(e) &#123; if (this.isDown) &#123; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); let cx = e.clientX; let cy = e.clientY; Vue.set(this.currenctPositon, \"x\", cx); Vue.set(this.currenctPositon, \"y\", cy); let moveX = this.currenctPositon.x - this.currenctPositon.offX; let moveY = this.currenctPositon.y - this.currenctPositon.offY; dw.style.left = moveX + \"px\"; dw.style.top = moveY + \"px\"; &#125; &#125;,&#125; 思路三接下来我发现了另外一个api：movementX，movementY，这个api会在mousemove时记录与上一次移动的距离，所以就在思路一的基础上可以省略求disX,disY的过程，所以有了以下代码： 123456789101112131415161718handle(e) &#123; if (this.isDown) &#123; let dw = this.$refs[this.wid]; let banner = this.$refs[\"banner\"]; banner.style.cursor = \"move\"; let RectData = dw.getBoundingClientRect(); let cx = e.clientX; let cy = e.clientY; Vue.set(this.currenctPositon, \"x\", cx); Vue.set(this.currenctPositon, \"y\", cy); let moveX = this.currenctPositon.x -this.currenctPositon.offX + e.movementX; let moveY = this.currenctPositon.y -this.currenctPositon.offY + e.movementY; dw.style.left = moveX + \"px\"; dw.style.top = moveY + \"px\"; &#125;&#125;, 但是由于movementX,movementY返回的是int，精度不够，所以会出现不跟手的情况；而且IE均不支持该属性，所以不是最优方案。 思路四最后我去参考了layui的方案。 12345678910111213141516171819202122232425262728293031323334353637383940 moveElem.on('mousedown', function(e)&#123; e.preventDefault(); if(config.move)&#123; dict.moveStart = true; dict.offset = [ e.clientX - parseFloat(layero.css('left')) ,e.clientY - parseFloat(layero.css('top')) ]; ready.moveElem.css('cursor', 'move').show(); &#125; &#125;);_DOC.on('mousemove', function(e)&#123; //拖拽移动 if(dict.moveStart)&#123; var X = e.clientX - dict.offset[0] ,Y = e.clientY - dict.offset[1] ,fixed = layero.css('position') === 'fixed'; e.preventDefault(); dict.stX = fixed ? 0 : win.scrollLeft(); dict.stY = fixed ? 0 : win.scrollTop(); //控制元素不被拖出窗口外 if(!config.moveOut)&#123; var setRig = win.width() - layero.outerWidth() + dict.stX ,setBot = win.height() - layero.outerHeight() + dict.stY; X &lt; dict.stX &amp;&amp; (X = dict.stX); X &gt; setRig &amp;&amp; (X = setRig); Y &lt; dict.stY &amp;&amp; (Y = dict.stY); Y &gt; setBot &amp;&amp; (Y = setBot); &#125; layero.css(&#123; left: X ,top: Y &#125;); &#125; layui采用的是一种更为常见的方式。 其关键在于其并没有直接拿offsetX，而是通过clientX - left，clientY - top来计算offset。其原因在于可能是offset属性的兼容性问题。 Feature Chrome Edge Firefox (Gecko) Internet Explorer Opera Safari Basic support (Yes) (Yes) 39.0 (39.0) 6 (Yes) (Yes) Redefined from long to double 56 ? ? ? ? ? offsetX在早期返回一个int，这对于拖动窗口有很大的影响，比如上面的movement属性，所以layui选择了更加稳定的直接获取其style.left属性。 函数节流这一部分，我觉得可加可不加，因为虽然DOM消耗很大，但是目前计算机的性能是完全足够承担一秒几十次到上百次的DOM重绘的。额可以在后期加入检测机制，如果机器性能较差，则可以节流mousemove函数。具体细节可以查看函数的节流与防抖","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Vue插件开发","slug":"Vue插件开发","permalink":"http://yoursite.com/tags/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"拖动窗口","slug":"拖动窗口","permalink":"http://yoursite.com/tags/%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"Vue插件开发2-事件对象e与视窗api详解","slug":"Vue插件开发2-事件对象e与视窗api详解","date":"2021-01-13T03:57:39.000Z","updated":"2021-01-21T02:09:25.631Z","comments":true,"path":"2021/01/13/Vue插件开发2-事件对象e与视窗api详解/","link":"","permalink":"http://yoursite.com/2021/01/13/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%912-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1e%E4%B8%8E%E8%A7%86%E7%AA%97api%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"事件参数 首先Vue没有对事件对象做修改，所以在Vue中的事件对象仍然与原生一样。 其对象属性具体又分为4类： 鼠标 / 键盘属性 属性 描述 altKey 返回当事件被触发时，”ALT” 是否被按下。 button 返回当事件被触发时，哪个鼠标按钮被点击。一个数字，表示鼠标事件发生时按下的鼠标按钮。可能的值：0：鼠标左键1：车轮按钮或中间按钮（如果有）2：鼠标右键注意： Internet Explorer 8和更早版本具有不同的返回值：1：鼠标左键2：鼠标右键4：车轮按钮或中间按钮（如果有）注意：对于左侧配置的鼠标，返回值会反转 buttons buttons属性返回一个数字，指示触发鼠标事件时按下了哪些鼠标按钮或鼠标按钮。一个数字，表示鼠标事件发生时按下的一个或多个鼠标按钮。如果按下多个按钮，则组合这些值以产生新数字（例如，如果按下左按钮（1）和右按钮（2），则返回值为1 + 2，即3） 。可能的值：1：鼠标左键2：鼠标右键4：滚轮按钮或中间按钮8：第四个鼠标按钮（通常是“浏览器返回”按钮）16：第五个鼠标按钮（通常是“浏览器转发”按钮）注意：对于左侧配置的鼠标，返回值会反转 clientX 返回当事件被触发时，鼠标指针的水平坐标。 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 ctrlKey 返回当事件被触发时，”CTRL” 键是否被按下。 metaKey 返回当事件被触发时，”meta” 键是否被按下。 relatedTarget 返回与事件的目标节点相关的节点。 screenX 返回当某个事件被触发时，鼠标指针的水平坐标。 screenY 返回当某个事件被触发时，鼠标指针的垂直坐标。 shiftKey 返回当事件被触发时，”SHIFT” 键是否被按下。 IE 属性除了上面的鼠标/事件属性，IE 浏览器还支持下面的属性： 属性 描述 cancelBubble 如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。 fromElement 对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。 keyCode 对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup 事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。 offsetX,offsetY 发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。 returnValue 如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 fasle，可以取消发生事件的源元素的默认动作。比如在a标签的事件中如果将该值设为false，则不会跳转；在submit按钮中就不会提交事件。 srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。 toElement 对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。 x,y 事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。 但是当前大部分浏览器的事件对象都已经趋近于统一，比如上图是chrome的事件对象，其中也涵盖了大部分上述所谓IE属性。 标准 Event 属性下面列出了 2 级 DOM 事件标准定义的属性。 属性 描述 bubbles 返回布尔值，指示事件是否是起泡事件类型。 cancelable 返回布尔值，指示事件是否拥有可取消的默认动作。 currentTarget 返回其事件监听器触发该事件的元素。 eventPhase 返回事件传播的当前阶段。 target 返回触发此事件的元素（事件的目标节点）。 timeStamp 返回事件生成的日期和时间。 type 返回当前 Event 对象表示的事件的名称。 这部分参数中使用较多的可能是前面几个属性，比如bubbles，cancelables 标准 Event 方法下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法： 方法 描述 initEvent() 初始化新创建的 Event 对象的属性。 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 stopPropagation() 不再派发事件。 这些方法是挂载在原型链的Event对象上的，所以直接的点击或其他事件是看不到的。 参数详解 currentTarget、srcElement与target currentTarget事件属性返回其事件侦听器触发事件的元素。 target始终返回触发事件的真实元素。（在事件冒泡中与currentTarget不同） currentTarget在直接捕捉e得到的结果为null，必须在函数中通过一个变量存储下来。 target的值会始终存储在e中，可以直接通过e查看。 srcElement与target一致，指向事件触发的元素，旧版本firefox不支持。 detail：detail属性返回一个包含事件详细信息的数字。在onclick和ondblclick上使用时，该数字表示当前的点击次数。在onmousedown和onmouseup上使用时，该数字表示当前点击次数加1。 isTrusted：isTrusted事件属性返回一个布尔值，指示事件是否可信。注意：在Chrome，Firefox和Opera中，如果事件由用户调用，则该事件是受信任的，如果由脚本调用，则不受信任。在IE中，除了使用createEvent()方法创建的事件之外，所有事件都是可信任的。 relatedTarget：relatedTarget属性返回与触发鼠标事件的元素相关的元素。relatedTarget属性可以与mouseover事件一起使用，以指示光标刚刚退出的元素，或者使用mouseout事件来指示光标刚刚输入的元素。 which：which属性返回一个数字，表示触发鼠标事件时按下了哪个鼠标按钮。（注意与button不一致） | 项目 | 描述 || :——- | :———————————————————– || 返回值： | 一个数字，表示鼠标事件发生时按下的鼠标按钮。可能的值：0：没有按钮1：鼠标左键2：滚轮按钮或中间按钮（如果有）3：鼠标右键注意：对于左侧配置的鼠标，返回值会反转。 | 视窗相关参数这里具体详解视窗相关参数： clientX,clientY：在页面（不包括浏览器bar部分）可视范围，与最左面，最上面的距离。 pageX、pageY：在整个页面范围内（包括不可视的部分），与最左面，最上面的距离。 screenX、screenY：距离显示器最左面，最上面的距离。（当窗口全屏时，即client加浏览器bar） layerX、layerY：鼠标相比较于当前坐标系的位置,即如果触发元素没有设置绝对定位或相对定位,以页面为参考点,如果有,将改变参考坐标系,从触发元素盒子模型的border区域的左上角为参考点。值得注意的是：该属性是以border边界为0，而offset是以content边界为0。 但是MDN上标注该属性为非规范属性，各个浏览器结果预期不一致，最好不要使用。 offsetX、offsetY：距离事件触发元素的左面，上面的距离。 注意：offset中，padding会被算在内。border会被算作负值。即offset是以padding作为边界的，超过这个边界即被判为负值。 DOM元素还含有一个属性用于计算该元素相对于视窗的距离：getBoundingClientRect()，该方法有4个属性： top：元素上边到视窗上边的距离; right：元素右边到视窗左边的距离; bottom：元素下边到视窗上边的距离; left：元素左边到视窗左边的距离; 注意：这些属性一旦超出视窗范围即为负数 DOM元素还带有一下一组（4个）属性： offsetLeft：返回元素相对于父级元素的左侧偏移量 offsetTop：返回元素相对于父级元素的左侧偏移量 offsetHeight：返回元素的高度（包括padding，border） offsetWidth：返回元素的宽度（包括padding，border） offsetParent：返回元素的父级元素 clientLeft：返回元素到父级元素左侧的距离（包括padding，不包括border） clientTop：返回元素到父级元素上侧的距离（包括padding，不包括border） clientHeigt：返回元素的高度（包括padding，不包括border） clientWidth：返回元素的宽度（包括padding，不包括border） scrollHeight：返回元素的滚动总高度（即总页面，包括因滚动而不在视野内的）（包括padding，不包括border） scrollWidth：返回元素的滚动宽度（即总页面，包括因滚动而不在视野内的）（包括padding，不包括border） 具体需要注意的是： 即offsetxxx包括border，其他的clientxxx，scrollxxx不包括border 这个距离与dom.style.left一样，指的是相对于外层具有定位标志（具有positon样式的元素）的祖先元素的距离。（若外层元素没有positon属性，则以ducoment为其定位元素） 通过element.style.left只能用来赋值（是字符串，需加后缀px），无法直接获取其值，必须通过上面的offsetLeft来获取其具体值。","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/tags/Vue%E6%8F%92%E4%BB%B6/"},{"name":"事件参数","slug":"事件参数","permalink":"http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0/"}]},{"title":"Vue插件开发1-插件原理即应用","slug":"Vue插件开发1-插件原理即应用","date":"2021-01-12T06:45:27.000Z","updated":"2021-01-14T13:49:55.819Z","comments":true,"path":"2021/01/12/Vue插件开发1-插件原理即应用/","link":"","permalink":"http://yoursite.com/2021/01/12/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911-%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%8D%B3%E5%BA%94%E7%94%A8/","excerpt":"","text":"原理简介 插件通常用来为 Vue 添加全局功能。-Vue官网 我觉得广义上的插件，实际上就是一些可以复用的功能或组件的封装。 首先分析Vue源码： 12345678910111213141516171819202122232425//src-&gt;core-&gt;instance-&gt;index.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 我们可以法Vue实例最初是一个函数，然后在其上挂载各种属性。作为函数，我们就可以为其直接添加属性，或者向其prototype上添加参数。 Vue的插件通常包括一下几种： 添加全局方法或者 property。如：vue-custom-element 注册代码： 123456function install(Vue) &#123; Vue.customElement = function vueCustomElement(tag, componentDefinition, options = &#123;&#125;) &#123; //... &#125; //...&#125; 可以看到，这里是直接向Vue实例上添加属性方法。 使用： 1Vue.customElement() 另外，这个插件使用了Web Component这一新的属性，还得找个时间学习一下。它可以在HTML文件中直接使用自定义标签。 添加全局资源：指令/组件/过滤器/过渡等。如 vue-touch 注册代码（vue-touch）： 123456vueTouch.install = function (Vue) &#123; Vue.directive('touch', &#123; //... &#125; //...&#125; 这里是使用了Vue的directive定义了一个全局的v-touch指令。 123&lt;a v-touch:tap=\"onTap\"&gt;Tap me!&lt;/a&gt;&lt;div v-touch:swipeleft=\"onSwipeLeft\"&gt;Swipe me!&lt;/div&gt; 另外，还可以通过Vue.filter注册全局的filter来进行使用，比如 123456789let plugin = &#123;&#125;plugin.install = function(Vue, options)&#123; Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;)&#125; 则可以直接在Vue的tempelate中使用 1&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; 值得注意的是全局组件的注册，因为很多时候我们开发组件是需要组件样式支撑的。这个时候就需要全局注册组件。比如element-UI(可惜无了)，iview这种组件库就需要注册大量的全局样式。 注册代码（部分）（element-UI）： 123components.forEach(component =&gt; &#123; Vue.component(component.name, component);&#125;); 这里使用Vue.component注册全局组件，这样注册的组件可以直接在任何组件中引用而不需在script中申明。 值得注意的是，这样引入的组件即使未被引用，依然会被打包，因此，在大型组件库中尽量少使用全局注册，否则会增加打包后的js大小。 通过全局混入来添加一些组件选项。如 vue-router 注册代码： 123456789101112131415161718export function install (Vue) &#123; Vue.mixin(&#123; beforeCreate () &#123; if (isDef(this.$options.router)) &#123; this._routerRoot = this this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, '_route', this._router.history.current) &#125; else &#123; this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this &#125; registerInstance(this, this) &#125;, destroyed () &#123; registerInstance(this) &#125; &#125;)&#125; 可以看到，这里vue-router使用了Vue.minin对beforeCreate进行了混入，使该混入钩子在Vue自身的钩子之前调用。 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。比如element-UI等组件库。 注册代码： 123456789101112131415161718192021222324const install = function(Vue, opts = &#123;&#125;) &#123; locale.use(opts.locale); locale.i18n(opts.i18n); components.forEach(component =&gt; &#123; Vue.component(component.name, component); &#125;); Vue.use(InfiniteScroll); Vue.use(Loading.directive); Vue.prototype.$ELEMENT = &#123; size: opts.size || '', zIndex: opts.zIndex || 2000 &#125;; Vue.prototype.$loading = Loading.service; Vue.prototype.$msgbox = MessageBox; Vue.prototype.$alert = MessageBox.alert; Vue.prototype.$confirm = MessageBox.confirm; Vue.prototype.$prompt = MessageBox.prompt; Vue.prototype.$notify = Notification; Vue.prototype.$message = Message;&#125; 在Vue的prototype上添加很多参数方法。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router vue-router中有一个index.js与install.js，在install.js中，只提供了与Vue相关的注册函数。在index中，定义了很多自己的API。 使用插件通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成： 123456// 调用 `MyPlugin.install(Vue)`Vue.use(MyPlugin)new Vue(&#123; // ...组件选项&#125;) 也可以传入一个可选的选项对象： 1Vue.use(MyPlugin, &#123; someOption: true &#125;) Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。 Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 Vue.use()。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 Vue.use()： 123456// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时var Vue = require('vue')var VueRouter = require('vue-router')// 不要忘了调用此方法Vue.use(VueRouter) 另外，全局样式表的引入需要直接在main.js中import，这样的css样式也会被全局注册，会影响所有的组件。 开发插件Vue插件打开发其实很简单，最关键的就是其必须要暴露一个install方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 12345678910111213141516171819202122232425262728293031MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) Vue.component('my-component', Mcomponent) //常用 Vue.filter('my-filter', Mfilter) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125;export MyPlugin 应用根据上面的原理，我们只需要遵顼插件定义和使用的规则即可，其目录解构并不重要，但是为了规范，可以新建一个plugin用来存储插件文件，插件的目录解构可以自定义。另外，项目直接使用vue-cli生成一个普通的项目即可。 可以看到，在index.js文件中，我们定义了install函数，并在Vue的prototype上挂载了一个函数和一个方法，同时，也注册了一个全局的组件dwin。最后将该对象导出。 然后在main.js中，我们从index.js中引入dw，然后使用Vue.use(dw)将该组件导入。 然后我们就可以在任何组件中使用dwin组件了。 这样一个简单的组件开发就完成了，具体的打包和上传到npm仓库见这里","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"http://yoursite.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Vue插件开发","slug":"Vue插件开发","permalink":"http://yoursite.com/tags/Vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"dragWindow","slug":"dragWindow","permalink":"http://yoursite.com/tags/dragWindow/"}]},{"title":"TypeScript特点2","slug":"TypeScript特点2","date":"2021-01-10T06:40:17.000Z","updated":"2021-01-11T06:52:20.742Z","comments":true,"path":"2021/01/10/TypeScript特点2/","link":"","permalink":"http://yoursite.com/2021/01/10/TypeScript%E7%89%B9%E7%82%B92/","excerpt":"","text":"类型兼容性TS中的类型兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。 与Java不同，Java的强制转换是基于继承的，只有有继承关系的对象才可以进行转换。 即只要对象中的成员有包含关系，则可以进行类型转换。如， 1234567891011interface Named &#123; name: string;&#125;class Person &#123; name: string;&#125;let p: Named;// OK, because of structural typingp = new Person(); 这一点也是根据JS的灵活性设计的，JS中变量类型是自动检测的，程序员不需要专门进行规定。 对象的兼容TS结构化类型系统的基本规则是，如果x要兼容y，（所谓x兼容y，就是x可以被赋值为y），如 12345678interface Named &#123; name: string;&#125;let x: Named;// y's inferred type is &#123; name: string; location: string; &#125;let y = &#123; name: 'Alice', location: 'Seattle' &#125;;x = y; 称为x兼容y。 这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。 函数的兼容函数参数兼容函数的兼容与对象的兼容相反，函数x的参数包含函数y的参数，则x兼容y。如 12345let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // OKx = y; // Error 要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。 第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。 这里可以理解为，在函数赋值时，函数的参数可以被忽略的，（注意：函数调用的时候仍然必须赋值相等的参数，否则采用可选参数）但是限制了不能多余参数。即y中的参数s，在被赋值给x的时候直接被忽略，即 1234567//JS中函数调用的灵活性function f(a, b)&#123; //...&#125;f(1, 2); //参数b被忽略f(1, 2, 3) //多加参数c 函数返回值兼容返回参数少的函数可以被赋值为参数多的函数（这里TS称参数多的为参数少的函数的子类），即源函数可以被赋值为子类，即向下转换，如 12345let x = () =&gt; (&#123;name: 'Alice'&#125;);let y = () =&gt; (&#123;name: 'Alice', location: 'Seattle'&#125;);x = y; // OKy = x; // Error, because x() lacks a location property 类的兼容类的兼容只比较实例成员。静态部分不会被比较。（仍然是基于成员的比较，而不是Java中的继承），如 123456789101112131415class Animal &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;class Size &#123; feet: number; constructor(numFeet: number) &#123; &#125;&#125;let a: Animal;let s: Size;a = s; // OKs = a; // OK 高级类型交叉类型（Intersection Types）交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。 通俗的讲，就是包含所有成员类型的成员属性。如： 123456789101112131415161718192021222324252627function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; //将T与U成员变量混合成为新的变量，并返回该变量，返回时采用交叉类型而不是any let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person(\"Jim\"), new ConsoleLogger());var n = jim.name;jim.log(); 联合类型（Union Types）形式：A|B|C 含义： 作为参数时，仅支持A类或B类或C类，其他类型数据均不被接接受。如： 1234567function f(value: number|string)&#123; //...&#125;f(1); //正常f(\"1\"); //正常f(true); //失败 作为返回值时： 1234567891011121314151617interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;function getSmallPet(): Fish | Bird &#123; // ...&#125;let pet = getSmallPet();pet.layEggs(); // okaypet.swim(); // errors 由于返回的是A|B,所以我们只能访问A与B的交叉成员。 类型保护与区分类型（Type Guards and Differentiating Types）联合类型可以使我们接受多种特定类型的参数，但是我们要在函数内部更具参数类型执行特定的操作时又该如何判断呢。下面的写法是错误的，因为联合类型在访问任何独有参数时，都会发生错误。 123456789let pet = getSmallPet();// 每一个成员访问都会报错if (pet.swim) &#123; pet.swim();&#125;else if (pet.fly) &#123; pet.fly();&#125; 为了使代码工作，必须使用类型断言 12345678let pet = getSmallPet();if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125; 用户自定义的类型保护注意到，这种写法，我们在任何时候调用参数属性时，都必须加上类型断言。我们可以采用另外一种写法使之后的参数调用不再加上类型断言。 TS中的类型保护机制使之成为现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词： 123function isFish(pet: Fish | Bird): pet is Fish &#123; return (&lt;Fish&gt;pet).swim !== undefined;&#125; 在这个例子里， pet is Fish就是类型谓词。 谓词为 parameterName is Type这种形式， parameterName必须是来自于当前函数签名里的一个参数名。 每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型（在以后对应分支中的参数的每次调用都会被识别为该类型），只要这个类型与变量的原始类型是兼容的。 12345678// 'swim' 和 'fly' 调用都没有问题了if (isFish(pet)) &#123; pet.swim();&#125;else &#123; pet.fly();&#125; typeof类型保护实际上我们可以发现，在上面的断言函数中执行的内容就是判断参数是否为对应类型，是返回true，否返回false，所以我们在断言函数内部可以使用typeof来进行判断。 1234567891011121314151617function isNumber(x: any): x is number &#123; return typeof x === \"number\";&#125;function isString(x: any): x is string &#123; return typeof x === \"string\";&#125;function padLeft(value: string, padding: string | number) &#123; if (isNumber(padding)) &#123; return Array(padding + 1).join(\" \") + value; &#125; if (isString(padding)) &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 更进一步，对于原始类型（number, string, boolean, symbol），TS直接将typeof识别为断言函数，而不必我们每次都为原始类型类型编写一个断言。 123456789function padLeft(value: string, padding: string | number) &#123; if (typeof padding === \"number\") &#123; return Array(padding + 1).join(\" \") + value; &#125; if (typeof padding === \"string\") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 这些 typeof类型保护只有两种形式能被识别： typeof v === &quot;typename&quot;和 typeof v !== &quot;typename&quot;， &quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。 instanceof类型保护对于非原始类型，如何做到类型判断并收紧呢？TS提供了instanceof类型保护，也可以避免我们重写断言函数。 123456789101112131415161718192021222324252627282930313233interface Padder &#123; getPaddingString(): string&#125;class SpaceRepeatingPadder implements Padder &#123; constructor(private numSpaces: number) &#123; &#125; getPaddingString() &#123; return Array(this.numSpaces + 1).join(\" \"); &#125;&#125;class StringPadder implements Padder &#123; constructor(private value: string) &#123; &#125; getPaddingString() &#123; return this.value; &#125;&#125;function getRandomPadder() &#123; return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(\" \");&#125;// 类型为SpaceRepeatingPadder | StringPadderlet padder: Padder = getRandomPadder();if (padder instanceof SpaceRepeatingPadder) &#123; padder; // 类型细化为'SpaceRepeatingPadder'&#125;if (padder instanceof StringPadder) &#123; padder; // 类型细化为'StringPadder'&#125; instanceof的右侧要求是一个构造函数，TypeScript将细化为： 此构造函数的 prototype属性的类型，如果它的类型不为 any的话 构造签名所返回的类型的联合 null和undefinedTS将null，undefined视为两种不同的类型，他们不能被赋值给任何其他类型的参数。如官方文档所说： 注意，按照JavaScript的语义，TypeScript会把 null和 undefined区别对待。 string | null， string | undefined和 string | undefined | null是不同的类型。 可选参数与可选属性使用了 --strictNullChecks，可选参数会被自动地加上 | undefined: 1234567function f(x: number, y?: number) &#123; return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, 'null' is not assignable to 'number | undefined' 也就是说，可选属性可以被赋值为undefined作为占位参数，但是不能被赋值为null。 同样的，可选属性也可被赋值为undefined作为占位参数。 12345678910class C &#123; a: number; b?: number;&#125;let c = new C();c.a = 12;c.a = undefined; // error, 'undefined' is not assignable to 'number'c.b = 13;c.b = undefined; // okc.b = null; // error, 'null' is not assignable to 'number | undefined' 类型别名形如C中的typedef语法，TS提供了类型别名。 1234567891011type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入： 1type Container&lt;T&gt; = &#123; value: T &#125;; 我们也可以使用类型别名来在属性里引用自己： 12345type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125; 类型别名只能出现在申明的左侧。 字符串字面量类型字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。 12345678910111213141516171819type Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\";class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === \"ease-in\") &#123; // ... &#125; else if (easing === \"ease-out\") &#123; &#125; else if (easing === \"ease-in-out\") &#123; &#125; else &#123; // error! should not pass null or undefined. &#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, \"ease-in\");button.animate(0, 0, \"uneasy\"); // error: \"uneasy\" is not allowed here 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。 1Argument of type &#39;&quot;uneasy&quot;&#39; is not assignable to parameter of type &#39;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#39; 数字字面量类型TypeScript还具有数字字面量类型。 123function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 &#123; // ...&#125; 我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候： 123456function foo(x: number) &#123; if (x !== 1 || x !== 2) &#123; // ~~~~~~~ // Operator '!==' cannot be applied to types '1' and '2'. &#125;&#125; 换句话说，当 x与 2进行比较的时候，它的值必须为 1，这就意味着上面的比较检查是非法的。 可辨识联合（Discriminated Unions）你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素： 具有普通的单例类型属性— 可辨识的特征。 一个类型别名包含了那些类型的联合— 联合。 此属性上的类型保护。 12345678910111213interface Square &#123; kind: \"square\"; size: number;&#125;interface Rectangle &#123; kind: \"rectangle\"; width: number; height: number;&#125;interface Circle &#123; kind: \"circle\"; radius: number;&#125; 首先我们声明了将要联合的接口。 每个接口都有 kind属性但有不同的字符串字面量类型。 kind属性称做 可辨识的特征或 标签。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起： 1type Shape = Square | Rectangle | Circle; 现在我们使用可辨识联合: 1234567function area(s: Shape) &#123; switch (s.kind) &#123; case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; &#125;&#125; Symbols这个部分也是ES6的引入一种新的原生类型，如number，string。 其特点是唯一，一个symbols是唯一独特的，无法改变的。即使两个symbol输入的key一样，这两个值仍然是完全不同的。 symbol类型的值是通过Symbol构造函数创建的。 123let sym1 = Symbol();let sym2 = Symbol(\"key\"); // 可选的字符串key Symbols是不可改变且唯一的。 1234let sym2 = Symbol(\"key\");let sym3 = Symbol(\"key\");sym2 === sym3; // false, symbols是唯一的 像字符串一样，symbols也可以被用做对象属性的键。 1234567let sym = Symbol();let obj = &#123; [sym]: \"value\"&#125;;console.log(obj[sym]); // \"value\"","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"TypeScript特点1","slug":"TypeScript特点1","date":"2021-01-09T07:18:36.000Z","updated":"2021-01-10T06:40:00.050Z","comments":true,"path":"2021/01/09/TypeScript特点1/","link":"","permalink":"http://yoursite.com/2021/01/09/TypeScript%E7%89%B9%E7%82%B91/","excerpt":"","text":"基础类型VoidTS中增加了void类型，用于表示没有任何类型，一般也是用于一个函数没有返回值，但是与其他语言不同的是，TS允许一个变量直接声明为Void型（虽然这没什么用）。 1let unusable: void = undefined; void型变量只能被赋值undefined,null Null 和 Undefined这里的null与undefined与JS中基本一致，其是所有类型的子类，即所有的变量都可被赋值为null与undifined。 Nevernever表示那些永远不存在的的值的类型。从应用的角度来看，与void对比，never一般用于无法返回的函数的返回值类型。比如抛出错误的函数，死循环的函数。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; never与null、undefined一致，也是所有类型子类（比null,undefined级别更低）。 除了上述最常用的方法，never有其他用处。比如尤雨溪谈到的收窄类型 类型断言简单说，就是在对any型变量操作时跳过TS在编译时的检测，对于一个any的变量，我们在某些特定情况下知道其必定为某种特定类型，此时调用其特定的方法。我们可以跳过编译时的检测，但是其对运行没有影响。 具体，形式一：“尖括号”语法 123let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 形式二：as语法 123let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 注意，无论是否通过类型断言，没有指定属性的变量始终返回undefined，如 1234567let a : any = 145;let b = (a as string).length;console.log(a.length); //undefinedconsole.log(b); //undefined 解构解构这一部分ES6也支持 ，并且我觉得这是一个非常好的特征，可以更加灵活地进行变量的交换，拆分，合并。 数组解构下面的形式是最简单的数组解构形式 1234let input = [1, 2];let [first, second] = input;console.log(first); // outputs 1console.log(second); // outputs 2 解构用于以申明的变量(交换变量是一个很好的应用) 12// swap variables[first, second] = [second, first]; 用于函数参数 12345function f([first, second]: [number, number]) &#123; console.log(first); console.log(second);&#125;f(input); …语法获取剩余变量 123456789let [first, ...rest] = [1, 2, 3, 4];console.log(first); // outputs 1console.log(rest); // outputs [ 2, 3, 4 ]function f([first, ...second]: [number, number, number, number]) &#123; console.log(first); //1 console.log(second); //[2,3,4]&#125;f(1,2,3,4); 只要位置对应，可以解构数组任何位置元素 123456let [first] = [1, 2, 3, 4];console.log(first); // 1let [, second, , fourth] = [1, 2, 3, 4];console.log(second); // 2console.log(fourth); // 4 对象解构与数组解构原理一致，只要键名一致，就可以就行解构。如， 12345678let o = &#123; a: \"foo\", b: 12, c: \"bar\"&#125;;let &#123; a, b &#125; = o;console.log(a) //fooconsole.log(b) //12 也可以用没有申明的赋值： 1(&#123; a, b &#125; = &#123; a: \"baz\", b: 101 &#125;); 注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。 同样，我们可以使用...语法进行剩余元素提取。 12345678let o = &#123; a: \"foo\", b: 12, c: \"bar\"&#125;;let &#123;a, ...others&#125; = o;console.log(a); //fooconsole.log(others); //&#123; b: 12, c: 'bar' &#125; 属性重命名我们也可以对提取的元素进行重命名， 1let &#123; a: newName1, b: newName2 &#125; = o; 这里需要注意的是:不是表示类型，而是旧名字与新名字的间隔。 但是如果需要限制提取元素的类型，则不能进行属性重命名。 展开我们可以使用...语法来进行数组（对象的展开），如 数组展开 123let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5]; //bothPlus = [0,1,2,3,4] 对象展开 12let defaults = &#123; food: \"spicy\", price: \"$$\", ambiance: \"noisy\" &#125;;let search = &#123; name: \"me\", ...defaults &#125;; //search = &#123;name:\"me\",food:\"spicy\", price: \"$$\", ambiance: \"noisy\" &#125; 值得注意的是，在对象展开中，相同的键值对会被合并！ 接口这里的接口与传统面向对象语言中的接口有一定的差距， 在面向对象的语言中（如Java），接口是一个抽象类型，是抽象方法的集合。 而在TS中，接口更多的是对数据及其解构进行检查。 下面是一个典型的用法： 1234567891011interface LabelledValue &#123; label: string; size: int; //顺序无关&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;printLabel(myObj); //Size 10 Object 与函数参数一致，接口中允许可选属性，只读属性的存在，例如： 123456789interface SquareConfig &#123; color?: string; width?: number; //加?可选属性&#125;interface Point &#123; readonly x: number; readonly y: number; //readonly-只读属性&#125; readonly vs const readonly用于属性； const用于变量； 额外的属性检查这里有一点需要注意的是，如果是采用字面量形式参数时，会触发额外属性检查。如： 12345678910interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;); 这里会报错： script.ts(6,46): error TS2355: A function whose declared type is neither ‘void’ nor ‘any’ must return a value. script.ts(10,31): error TS2345: Argument of type ‘{ colour: string; width: number; }’ is not assignable to parameter of type ‘SquareConfig’. Object literal may only specify known properties, but ‘colour’ does not exist in type ‘SquareConfig’. Did you mean to write ‘color’? 但是我们在传参时不采用字面量对象传参，而是采用变量直接穿，则不会触发额外属性检查。 1234567891011interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let arg = &#123; colour: \"red\", width: 100 &#125;;let mySquare = createSquare(arg); 运行正常！ 函数类型当然TS中的接口也有传统面向对象语言中的抽象方法集合的功能。 123interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 与java不同，TS中的接口是可以直接被使用的，如， 12345let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125; 即直接定义变量的类为接口，在Java中这是不允许的，只有实现接口后的类才能被实例化。 接口实现这一点与java一致，接口是可以被实现的。 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; And，TS中接口可以多继承！ 函数TS中函数部分比较简单，主要仍然是格式问题 123function f(v1: int, v2: string) boolean&#123; //...&#125; 其他的细节都是JS中的内容，此处不谈。","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"2020-奋斗的一年","slug":"2020-奋斗的一年","date":"2020-12-31T15:34:10.000Z","updated":"2021-01-07T15:46:56.788Z","comments":true,"path":"2020/12/31/2020-奋斗的一年/","link":"","permalink":"http://yoursite.com/2020/12/31/2020-%E5%A5%8B%E6%96%97%E7%9A%84%E4%B8%80%E5%B9%B4/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+tmXrjvbsTWhLV0jj1kqCPsbjLRs/2lMZgZI+oD3q7QDv7vOhS+Lh22sQ7u7uC7OPAgmwpVMP0Tv1mbiwPvqQggPKDpN5EiEVabwJtiDd6GNbOmSYmI7943e/7nEblfqfKtP81XL0kC+K9U6hq8425RoyFGTeOQlnCoVOaUMd3ZAwZDULgEFKdRQkAdEbNqfIu9j1DT5tMadel2Qni3j3RYHnrjCB4Sqd5OFc6lKZJdJpt5ursQXiRgjj1ntBfeK0lgERGUv8uQOq49pxKdlEh43RHwg3IoXpvrH90uEjEmR8+VGzWo0GJy8hrdkdLrsJaOi+UXW10WbeO/iUgQgIotfyYkN0cGZQYpFE1SbYtps+BZwt1aOeaDiWxDAGbENipHJkGqf+oy1f4Wna442XgWj9YTmRq7jH46f4DHAEuejbnTLkzBi5g+v9/ZlHtaUkOZwqKAaNAHMQAFWfy7GwadakpWEXZm9bBVrJ+CQV0r6xNVL326hIwKfeivYHpcMQJUOJEodN/IQKnM+IbaL1ntM4d7Xj8Rmssaq28me8BunQNql8WPiRK9huzRCh+8fk94AIYOsobJLIaZuhJZccW/aKpLT2Jsp55DbZwVbQhomORA6fKHsoYPP/ve2fEUB5RVy9F9ldq2Psn1ThkBtPp8P4ZPiUadllqbepSjJzAKnHAq7Zdj8R7O031cWBna2yBkuUReade2ZucMTxkvXtXA/rN95SelgrbkJ5SHRDWu6fOBUu0ghkzM+y/TqZl1WIdxkWJgOdwwPI9RbQXAM2NGCDm1Z4YM0oZiOB0iGjAwKYqOYtmHM3ujkaHBn1r6kKMHltABCp4vockG6aAvjeD7nN6e0IT8uWRM2mJ2RQLKS9lXNul6OOcF2eP2jSx4S+DrQk1zxgEUJbta911a4GICVGyAMZCf84tzvlPBulGwPF/oCdirhKnoyf26bwVny362Vb+pieGQ7l+i/qvzOi4/3NFKVRz6foIt9VCWIw8JUn1j/5sj9rdFW/A7vyXoGHV1xObAUERaU+5ny/nP2mrZcvq8NFVQw4vUzHL0Tl/cg7l+3joSMQPij9F50SduwX9ZQxtvEAjB/lj4wvHnIBFGWzNrqEUTd43Mn3Cqx8gceBb0WSN/emijyJXJNyg/E1u73XvKuzDmncmueObPOyy1s5jAyiPkgiVrAQyO9DfGHUY59Q9eIX5DycfEBdL1gMrwHbM44C89Ty5r5MkEGTjj/9/fsgbYRavbqee9Fw0jjRbSDRbeSPnxJHbX6RGlKMpHHxG0lo+HuDPQlLxbRpDnHOvjx9P5Ui/DwECN48NfFvAinOAN23zAjYnNCWZ7v4rYGeEiw3+7zBeJjseZ5P07ctlhlTs7ekgrCjUqMHe5j/hmgOu2nHy7zBIw1ynvro3wLtlw9Ib8Ke5p1oO0Y+Ev0ITSKBM/JVeYXS4P4k5KMblqHnVdjMtoDoHSi0mr/tW7KmSP3raSwNSmeT5w9ZMUw9wIAZY8qPyuRVDkzSMyzV5jFTxC76ss6CHOnxYPXPpAxu2Ov//vDwtKW2HTikqdIUY4xFPrIIJIXBn4PiSieQiQ67nQp/oiGFKxv0z1iei6mnab6j/llurtom0wEywtIQl+N72LW+ap8kLYDGy2jGoNxs5Nz0ALkrqaxdZ1MYNZae/u03EJYj42bWcfer7vPSHRWlJ+dcBrAaN4P+ysaWJfoeCjyP94zKyIkW7A9ddyjtRlSkXPm3WSSBQeM0h/xjN52Qdv6EIt+1m8uewvjvcJHJdSrpX/EEBYa/kUCAMtDTHygrGJK1BKOdht/HR30ymCMzNIscabK1xSjk1xXosPnLU7ZnsXuQhTY/hhZ2SlHu9S/TDF6pSyYXb2VS1aLvaPCE7ifUuxFEIcgYEbltlp4ZkN4SmhFTwED3PIKFo8g3HVcaDnAqGwF+gIesEWbo8WBCqgsZFHEriu/MTBn8sqVqaXa6szPHuFGHb2z4EQDplNNh17cwVbMX/wega5/JvlnUF873a7OPeRX6kPom5C5gOdrn84P88uTwzxWOHPBGU72BcMBms6j6NK7TSsyHBhEtprxhvycB23LWBmQEDfHbvSm3mCFWXB4N+ST1kBicUvtrgrFwxUsvnlHnwaAqcfCijPNFwf9zjks0PhaE6DvAXPKMa3I7JiBR/c5taE/UfMM+HrbvVV9DaCaRQp5m9Zt74Gkjk5iZIEsdUDoqPwCXbuW9s0+Z5tbZ/3WfMF/e2NRYw2fNtyGsPD91QO9WPd5j2wNCn0KAjlhPvZiZ/Ts4Eh2n8uPxE6C+oPWepSMghndxNj7LWOrlBLOGqEY++lIQezeTokiBRTXkUeyECue+omeUN94KQMgRJHmrIJAYfp3Uq9Xlv+Prh3LXo7Ymy9G2V93hnzwuNg1+eqCEK8V+fRkIAZQc5Y0EWGFCRNdnSlxa5CrUi2Se5JNzEuTBsb6rUAeYjpsX8wkrunX8pSrdQEcKpIE8T/YqLUWI0MzDzm06UmtwXhhrrRsS57HKf2Of+BVrjO4sXtdQ+axQoOxBTwUU6SItLbMUG3qW80nhwGVUdGGTRqxsf/NVLYGT5p62rW/6EGXjQoZdb9J3kH+NP7Xuaw+A7ieyElLF7W7HroWDtp/DIafrVLcZJHDQX9nbMIhZN9iCWR3xcngZQd+V+XZzs5s0yK28O/rIfYNZsfiGgnfejt6ZJWIsIGeEMbqPfNdaWDVY500tm0BLgTu3MxSWkF2iMkCkvb0c1MowOV5RHMsSMM6p91q/NjehMDed6ArZckRqC6qLFYIf5Ilujl0UKmQN7BEAVdDF0BuhmJJ765E3coA6BuNVjtur05xV4RHDsFZ14pydbyOFBdH9IRvdCr1XpzAk0X6R1xeHZ6S9jwy/9l+3+AunkI71i4a1FkBK7C2cLI7AF90A8RZbaUZlpCfHUMMZprtrY/uYaBcnBx6nLNhMDxkejKLl8+Klwv9UMUcGe1WfLlU0e9kxIcKeGZ1Y2KRYZs69EKDdE2XGlnBzV9wpnmLONzCj/ixggfSwxinS41yeetc9MRYML2GJ5VGLVSRa9UC0dlNFoWor6iZ3ZogsJfqmrjRVkqR+840XunWWzqvkSfWIn/Y9yVH1oJFB4fLSW7BuLm46w4AoF7Es2OpZ4CGDoX5cfk0UlCpW50cA3Oi8CP1wH8KlEm6KhUPaJLKkIUEVDCMxDe6oSJkgebrWRw2pKkNT8Tumzdv4fBzLDB7di2NjiDmAC+KrvA0EhiUVS6xDbQdJsfnk43tBfrRYYQ6eb8tmOnimXpnhXwV/ImI321+wE0w9qbvd7tUI5sl6tUJ9YCrAqiV7yNCESuU+a7OwFVcvKATOmbZxv428aCiWdmsIz6okIyo8drBZGhPX5ozTxNatjaiRAb3kODWtj7IPPYXpO3HtcHLq7t1d9OBmnjdIHub9UNsQ9lxqP4ACbZl0TyArCCtpRSRPH50a7See2WOERhCbsM4CXgKjiG4NMXKOmSYVQX1lLjEZOypDye5UYMX63QMnDnV3e0AyVxGFcPHZK9ldSgvljsTo2Tru5xhz+LyH1sKCOJHd0FnUMeZWgXldlCydidXzUraWT2BykdaXD0rzAc9hlSF8+zk+iL+2whgkfjrRbivUmWdsXl56vZgyDWmi8CSWsO8x0ggW3DjAGWpETVBRR0IEoH/5LVOpY6p6VFhJOwbDBMNsue0RgtYMTCulsz443tklk58dswqtSvDO1kugBqjxECOLPwuukeAgIyxgU6OoV2oVATf5qQViLyGzB8CHdCJwR7HMQV3Y/QaKYYLXb53G1oIhiQ1SzfCunVktFV953o4JB2j0DE4sSfBihUrNJYJ4qjZ6E4LJ2O0urBiwIRkSImmHh8rlX4hT3shc/KqguDy2el5v6GbEVJSE9rT8NSKIBd5KSjj2OlcZKkqiWCbRjQ0DlKH0PDyqXqxl5uYLv7y/TCOTEBdj12lKQiFNDgXKM8Yfjs9X3YgQUtp6PXWfa4C2zRX7E0aaeFctIw/SY3wKZnRR40qPovN/13udeGv6tbbts0NbnsbHG1m/IP5aqn2DZUAA6mT1cNFHqpjH4vxo0cMHEGs8a3JcsfLB3kQ2dMftgqm4ropc66heTeKH2Kx7w6RRKH/OiMe11hRPKpjpYAaKZ82vlux2wtE8MtiJMBNN1hqnKW09cFDDWusSQio5JARW+STOPS/I275KAubfEzzGqft2HOMtx2vM694RjMNkj0emPH+39tl53SxOIbEldJqR0h7hHVKkVfz9JWIK2ePC9YBQBducer/FlcEe/JpSgMcCXgiQ3BABDPD0OKKVrFtt4Jp135sQyPeGMyh9EkCG59kVim4q3mO77c/TrBAk/IUPTEU0CBhR/TwPre5UH3MH2s7078LgDdfM2e1tbVkns6pbM6zTafrI3kmJ/qvO+F6TJ95Mbf7jTNEOg1+Ao1P22es7Bcc80DyohJLH5ZLyRi04MtwrKo/xZiOv+loaCIWfFTuEHU80N081sfWYREDro3FqXPaAIgr8+fMgOsVejvk60KEQDTDRM1tqhEWjOASp+xZsOH29ZJWWOMizh5wmzuxtzVaM07aUv4B67MYtTCsRqZWzvZG7Yf+kv8+UPEFfHPR2bWfq7hdhhB/VWlwccm2kEe41D3U7jIbqH50M+0cxqufi76G+ki7u8M71bU+D4VBogztApH6aW7mLGXGOxg3gEHzi4 var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"2020","slug":"2020","permalink":"http://yoursite.com/categories/2020/"}],"tags":[{"name":"2020","slug":"2020","permalink":"http://yoursite.com/tags/2020/"},{"name":"计划","slug":"计划","permalink":"http://yoursite.com/tags/%E8%AE%A1%E5%88%92/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"考研遇到了问题！！！","slug":"考研遇到了问题！！！","date":"2020-04-22T10:46:58.000Z","updated":"2020-04-22T11:49:36.858Z","comments":true,"path":"2020/04/22/考研遇到了问题！！！/","link":"","permalink":"http://yoursite.com/2020/04/22/%E8%80%83%E7%A0%94%E9%81%87%E5%88%B0%E4%BA%86%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81/","excerpt":"","text":"回顾考研与2020想想考试复习考研已经有整整3个多月了，大概一月下旬就开始复习了！ 首先复习了两门科目 数学 英语 数学采用了看视频的方式进行了一轮复习，到四月十号左右就完成了。 英语的话由于最开始没有资料，只有几套真题，所以我直接上手真题。当然，错误率非常之高，问题只有一点：单词和短语积累不够，感觉每一道题，只要单词，短语90%理解，那基本不会错的。所以后面开始用百词斩背单词。由于之前背过，所以考研的词汇还有事多天就要背完了，当然会忘记，所以在考研的过程中，要不间断的背下去。 总体回顾的话，我感觉4月之前，也就是1,2,3月份的状态比较好，早上做英语，下午看视频学习数学，晚上复习数学。作息比较规律，至少可以做到不赖床。 四月的问题进入四月，数学的基础部分基本完成，英语也看了许多视频，把刘晓艳得语法，长难句都看了一遍。书也差不多过了一遍。但是接近四月中旬时出现了很大的问题： 问题 身体出现了问题： 最开始是牙龈出血严重，平时都能感觉口型腔内的血腥味 耳鸣开始困扰我，只要周围声音一大，耳膜就开始震动，耳朵很敏感；晚上睡觉时耳鸣严重（倒是没太影响睡眠）。后来去检测发现鼻炎严重，开始治疗鼻炎。 开始上课了，导致不得不频繁的使用电子设备，很容易分心。 看书感觉很难集中精力去想问题，看着讲义上的内容，完全不想动脑。 不节制玩游戏。 聊天过于频繁。 解决方法既然出现的问题，就必须去解决问题。否则只会被问题一点点拖垮！以我现在的状态，不配考上研究生！ 对于身体问题，只能说加紧治疗，毕竟没有更好的办法，只要不影响学习（但是我感觉最近这一系列问题的出现都是身体问题引起的）。 上完课就将电子设备放到远离自己的位置，避免手能够直接接触。 难集中精力，我觉得80%因为电子设备在旁边，所以先实行方法2，看是否还有其他原因。 立刻戒掉游戏，可以在周末玩一会。 当断不断，必受其乱！现在不是时候！ 接下来的安排既然选择了考研，我就不会退缩！所以我有以下安排来恢复状态，想想高中时一天学习14.5个小时的时候，现在这些算的了什么？！毕竟我是南实出来的人，还是练出来了吧！ 想想自己为什么考研？之前的我还不是很明确，但是现在，我觉得考研的目的很简单，就是为了实现自己的人生目标，实现阶级的跨越，在这样一个阶级越来越固化的时代，中国为底层提供了一个很好的工具，就是读书。起码读完硕士，就迈入了中薪阶层。后面在考虑是否读博士，现在的我并不很排斥继续读博士。 具体措施如下： 恢复斗志很关键，必须要恢复斗志，这是一切的来源！ 尽量隔离电子设备，学习时不看手机！ 每天计划，用纸打印表格。 每周总结，并发布到博客上。 规律作息，早上6:30起床，晚上23:30睡觉。 每周天放松，早上看书，下午玩游戏，晚上看技术文章，写总结。（作息仍然不变！） 一定要坚持下去最开始我在想考研该是有多困难啊！那么多人考不上，后来我才发现原来不是考研难，而是复习的这个过程最困难。不比高中，有人24hours的监督你来学习，时间制定好，饭做好。大部分人可能都没有高考时一半用心，所以考上的人那么少。我现在是真的体会到了他们常说的一句话，考研比的是坚持，比的是身体，比的是自律！一点没错！智商的影响只在于你是否能考上北大清华。加油，记住你对自己的定位！","categories":[{"name":"考研","slug":"考研","permalink":"http://yoursite.com/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://yoursite.com/tags/%E8%80%83%E7%A0%94/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Vue源码1-从初始化到响应式原理","slug":"Vue源码1-从初始化到响应式原理","date":"2020-01-08T14:09:52.000Z","updated":"2020-01-08T15:37:47.093Z","comments":true,"path":"2020/01/08/Vue源码1-从初始化到响应式原理/","link":"","permalink":"http://yoursite.com/2020/01/08/Vue%E6%BA%90%E7%A0%811-%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"首先介绍后面要用到的几个类： Observer类：用于将一个数据变为响应式（可被观测） Watcher类：一个依赖（一个指令对应一个依赖），一旦有一个指令用到了某个对象属性，那么就会新建一个Watcher作为订阅者。 Dep类：依赖管理器，一个对象属性对应一个Dep，其有一个内部属性subs用于存放依赖。 Vue初始化Vue原型是在src/instance/idnex.js中定义的： 12345678910111213141516171819202122232425//src/instance/idnex.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 可以看到Vue原型是一个function。在这个函数只判断了是否是new出来的，否则报警告。然后直接调用了_init()方法，这个方法是在下面的initMixin(Vue)中混入的初始化方法。下面看一下这个方法中的重要部分。 1234567891011121314151617181920212223//init.js 52-72 liens initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props //state包括data，props，methods initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; 这里按顺序进行了一下操作(最简化，不考虑分支)： 首先初始化了生命周期 initLifecycle(vm) 初始化了事件($on,$emit,$once…) initEvents(vm) 初始化了render initRender(vm) 调用了beforeCreate生命周期 callHook(vm, &#39;beforeCreate&#39;) 是初始化inject initInjections(vm) 接下来的initState中，初始化了data,props,methods。 initState(vm) 初始化provide initProvide(vm) 调用生命周期created，callHook(vm, &#39;created&#39;),如同官网所说： 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前尚不可用。 最后一步将el挂载到页面。vm.$mount(vm.$options.el) 响应式原理（以对象为例）响应式的所有文件都放在observer文件夹下： observer array.js:数组的处理相关处理 dep.js:依赖管理器类的定义及其处理 index.js:整个observer的出口 scheduler.js:调度者相关文件 traverse.js:递归遍历一个对象，以唤醒所有转换getter，使每个嵌套的属性内的对象作为“深度”依赖项收集。 watcher.js:观测者，依赖的类定义与相关处理。 还是接着上面的第6步:initState initState方法定义在state.js中，下面节选这一部分中内容： 12345678910111213141516171819202122//state.jsexport function proxy ()&#123; //代理处理 //比如当我们调用this.xxx 的时候实际上它是挂载在vm._data.xxx的，这里的代理同样使用了Object.defineProperty()来进行了代理。&#125;export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 可以看到intiState中，Vue进行了下面主要操作： initProps(vm, opts.props) initMethods(vm, opts.methods) initData(vm) initWatch(vm, opts.watch) 然后以data为例，分析对data的处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243//state.jsfunction initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 在这个函数里 首先看data是一个对象还是一个函数，对其进行对应的处理 然后判断他不能与props,methods中的属性同名，因为最终这三部分都会被挂载到vm实例上。 最后调用observe()方法来使data变为可被观测的 然后我们看observe()方法，这个方法就位于observer下的index.js中了。 1234567891011121314151617181920212223//observer/index.jsexport function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 作为整个将数据变为响应式的入口函数，它进行了一下操作： 判断传入的val如果不是一个对象或者是一个Vnode，就直接返回，不做处理 判断整个val是否有__ob__整个属性或者是不是Observer的子类，如果是的话，直接将val.__ob__返回 进行了一系列的其他的判断，比如是否应该被观测（shouldObserve这个对象定义在全局中，判 标识此时是否应该处理数据）、是否处于服务端渲染模式、是一个数组或是一个对象、是不是可扩展的、是不是Vue本身。 新建一个Observer对象，并将value传入。 继续向下看，新建Observer对象过程，Observer对象也在index中定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//observer/index.jsexport class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 可以看到Observer对象包含了三个私有属性： value：当前观测对象 dep：依赖管理器 vmCount：将这个对象作为$data的数量 再看他的构造方法中，执行流程如下： 初始化了value，dep，vmCount 并给value的加上一个(不可枚举的)__ob__属性，可以联系上面判断__ob__的操作 判断value是否是一个数组，然后执行对数组的observer操作。现不看数组。 如果不是，则代表value是一个对象，则执行walk()方法对其进行处理。 在walk()中，可以看到Vue遍历了对象的所有属性并对其调用了defineReactive方法 我们再跟进defineReactive方法中（这个方法就差不多是核心了）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; //为每一个属性建立一个依赖收集器 const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125; &#125;)&#125; 还是分析一下他的执行流程： 首先建立了一个Dep对象，即每一个属性都有一个依赖管理器用来收集用到这个属性的依赖，这一部分后面在讲。 判断这个对象属性能否被修改，及判断其configurable属性。 判断这个对下给你属性是否自带了getter与setter，如果有的话就将其缓存下来。 判断是否在函数调用时为这个对下给你属性传入了customSetter，如果有的话，则先调用getter将其值存储下来。 判断有无子对象或者是否在函数调用时确定只观测表层属性（不循环处理），如果都不满足则递归进行子属性的响应式处理。 这里就使整个响应式的核心：Object.defineProperty，在这里Vue为其定义了enumerable,configurable,get,set get()： 获取原始的属性值（通过原始getting或者直接获取） 判断Dep.target的值是否存在（这个值后面介绍Dep对象时介绍，代表的是当前的依赖），如果存在的话，就调用dep对象的depend()方法进行依赖收集。 接下来判断是否有子ob对下给你，如果有的话，也调用子的dep的depend方法进行依赖收集。同时判断对象属性原来的值是否是个数组，如果是的话，调用dependArray方法进行数组的依赖收集。 set() 获取对象属性原本的值，调用原来的getter，如果没有，就接受传入的值。 判断有没有必要更新。 判断是否有customSetter，如果有的话，就调用 如果只有getter，没有setter，则直接返回。这里是为了修复#7981的BUG，问题大概是如果一个对象属性如果被其他插件修改后只有getter，但没有setter，也就是说整个插件的原意是将其变为一个不可写入的属性，但是如果不加这一句进行判断，那么Vue会直接调用val = newVal，对其进行赋值。这不符合预期，所以加了这一句判断，直接返回不进行处理。 判断如果原来有setter的话，就调用其setter。否则就直接赋值给val。 然后同样是对子属性的处理。 这一步进行依赖派发。 至此，defineReactive方法流程介绍完毕。但是我们还留下了两个坑 依赖收集dep.depend()具体如何完成的 依赖通知dep.notify()具体如何完成的 接下来我们在进入这两个函数进行分析。 首先我们看一下Dep对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//observer/dep.js/* @flow */import type Watcher from './watcher'import &#123; remove &#125; from '../util/index'import config from '../config'let uid = 0/** * A dep is an observable that can have multiple * directives subscribing to it. * 一个dep可以有多个指令（包括\"&#123;&#123;&#125;&#125;\",\"v-text\",\"v-html\"...）订阅它。 * target属性用于表示正在处理的依赖，当确定为这个值的指令时，则将其添加到subs中（addSub函数）。 * subs属性用于存放所有的依赖，他的依赖是Watcher类 */export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this/* 这个依赖管理器Dep实例 */) &#125; &#125; notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;// The current target watcher being evaluated.// This is globally unique because only one watcher// can be evaluated at a time.Dep.target = nullconst targetStack = []export function pushTarget (target: ?Watcher) &#123; targetStack.push(target) Dep.target = target&#125;export function popTarget () &#123; targetStack.pop() Dep.target = targetStack[targetStack.length - 1]&#125; 可以看到Dep对象有三个属性， target：一个静态属性，类型是Watcher，即当前执行的依赖 id：Dep的标识符 subs：整个dep中所有的依赖，是一个Watcherd数组 然后我们直接看depend()方法： 这个函数判断dep的target是否存在，如果存在的话，则调用当前依赖的addDep方法，我们知道这个target是一个Watcher。所以我们看一下Watcher： 1234567891011121314151617181920212223242526272829303132export default class Watcher &#123; //初始化了很多属性 vm: Component; expression: string; cb: Function; id: number; deep: boolean; user: boolean; lazy: boolean; sync: boolean; dirty: boolean; active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any;&#125; addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; //调用depaddSub方法把这个指令（this）添加到这个dep中 dep.addSub(this) &#125; &#125; &#125; 可以看到在addDep中，判断这个Watcher对应的新dep中是否含有这个传进来的Dep，如果没有就其push到新dep与新depIds中，然后判断原来的dep中是否含有这个watcher，如果没有，就push进来。 这里的newDep与dep是为了灵活的动态更新视图，思考以下场景： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;span v-if&#x3D;&quot;nameShow&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;span&gt; &lt;span v-if&#x3D;&quot;ageShow&quot;&gt;&#123;&#123;age&#125;&#125;&lt;&#x2F;span&gt; &lt;input :value&#x3D;&quot;name&quot;&#x2F;&gt; &lt;input :value&#x3D;&quot;age&quot;&#x2F;&gt; &lt;button @click&#x3D;&quot;nameShow &#x3D; !nameShow&quot;&gt;切换name状态&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;ageShow &#x3D; !ageShow&quot;&gt;age&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name:&quot;Register&quot;, data () &#123; return &#123; nameShow: true, ageShow: true, name:&quot;123&quot;, age:&quot;111&quot; &#125; &#125;&#125;&lt;&#x2F;script&gt; 当nameShow与ageShow都是true时，我们对表单机进行修改以修改name与age的值时，肯定会涉及到到依赖的分发。 但是当我们点击button将nameShow或ageShow的值切换为false时，视图上已经不显示对应信息，则讲道理应该不会在对这个依赖进行通知。这个newDep的存在就是为了这里。 至此，依赖收集的过程基本完成。下面看看如何进行依赖派发的： 当一个对象属性被改变时，其set方法就会被调用，由此调用dep.notify()，进行依赖派发。我们看一下dep.notify()这个函数内部： 12345678910111213141516//observer/dep.jsnotify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 可以看到首先是对subs所有的依赖进行了排序，根据官方的注释是应为：如果subs不是异步运行的话，那么他们没有在调度者中进行排序，所以我们需要对其进行排序以保证其正确按序派发。 然后这里调用每一个watcher的update方法，进行DOM的更新。看一下update()方法 12345678910update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 可以看到首先判断了这个watcher是不是懒加载的，如果是的话，将其dirty属性变为true，Vue会在调用到它时进行加载，否则看他是不是同步的，如果是的话，立即调用run()进行DOM更新操作，否则就将其推入到queueWatcher队列中，等待调度者，进行调度。（这里就不再讲调度算法，后续再讲） 再进入run()方法： 1234567891011121314151617181920212223242526272829303132//observer/watcher.js /** * Scheduler job interface. * Will be called by the scheduler. */ run () &#123; if (this.active) &#123; const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher \"$&#123;this.expression&#125;\"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125; &#125; 由官方的注释也可以看出来，这个run()是由调度者进行执行的（除非他是一个同步的watcher） run()函数的运行流程如下： 判断这个wacher是否的活动的，如果是才操作。 通过get()获取这个watcher对应的值，判断获取到的值与watcher中保存的值是否相同 如果不等，则把当前watcher中保存的值作为oldValue保存下来，将当前watcher中的value设为获取到的value，然后判断这个watcher是不是用户定义的（this.user）（根据调度者中注释，watcher分为user watcher与render watcher），如果使用定义的watcher则用try--catch预防错误，否则直接调用这个watcher的回调函数。这个回调函数就会进行真正操作，比如调用rrnder更新DOM。 数组的响应式如何实现在上面我们介绍Dep对象时，在其构造方法中，我们只看了this.walk()对对象的操作，现在我们看一下对数组的操作： 123456789101112131415161718192021export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; 如果value是一个对象，那么会判断value有没有__ptoto__对象，因为部分浏览器不支持这个属性，如果有的话，则调用protoAugment(value, arrayMethods)把arrayMethods挂载到value的__proto__上，我们再看一下arrayMethods，它放在 observer/array.js中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 可以看到 首先是以原生Array的prototype作为原型创建了一个新的对象arrayMethods。 列举出需要被修改的数组方法methodsToPatch 对methodsToPatch进行forEach循环，并给arrayMethods定义每一个列举出的方法（不可枚举），如果这些方法中要为这个数组插值，我们必须也要探测这个值是否是一个引用类型（Araay或者Object），并也要将其变为响应式，所以后面判断了如果是push,unshift,splice则拿到要插入的值inserted 判断inserted是否存在，如果存在，也使用observeArray将其变为响应式。 进行依赖收集ob.dep.notify() 返回原始方法调用后返回的结果。 然后我们再看protoAugment方法： 12345function protoAugment (target, src: Object) &#123; /* eslint-disable no-proto */ target.__proto__ = src /* eslint-enable no-proto */&#125; 可以看到很简单，就只是把第一个参数的__proto__修改为第二个参数，结合我们刚刚传入的参数，即：将这个数组的_proto_修改为arrayMethods，即上面我们分析的这个对象。 再看copyAugment方法，这个方法也很简单，是针对不支持__proto__属性的浏览器： 1234567891011/** * Augment a target Object or Array by defining * hidden properties. *//* istanbul ignore next */function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125;&#125; 即遍历所有的方法名字，并将其设置为到目标数组上的不可枚举属性。 最后我们看一下observeArray方法： 12345678/** * Observe a list of Array items. */observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125; 这里实际上就是将数组的每一个值变为响应式。 但是还有一点是：我们还可以通过下标的方式为数组赋值，但是JS中找不到方法检测整个操作，所以Vue也无法检测到，所以Vue提供了Vue.set和Vue.del这两个api，用来弥补这一点。 至此，响应式的整个流程就差不多完成了。 最后梳理以下整个流程(对象)： 这个流程主要是我通过分析源码，借助一定的网上资料整理出来的，可能其中会有错误。希望大家指出来，谢谢。","categories":[{"name":"Vue源码","slug":"Vue源码","permalink":"http://yoursite.com/categories/Vue%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Vue源码","slug":"Vue源码","permalink":"http://yoursite.com/tags/Vue%E6%BA%90%E7%A0%81/"},{"name":"响应式原理","slug":"响应式原理","permalink":"http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"}]},{"title":"JavaScript中的&，&&，|，||","slug":"JavaScript中的与或运算","date":"2020-01-07T11:51:20.000Z","updated":"2020-01-07T11:54:33.006Z","comments":true,"path":"2020/01/07/JavaScript中的与或运算/","link":"","permalink":"http://yoursite.com/2020/01/07/JavaScript%E4%B8%AD%E7%9A%84%E4%B8%8E%E6%88%96%E8%BF%90%E7%AE%97/","excerpt":"","text":"简单区分&amp;,&amp;&amp;,|,||&amp;&amp; 位与运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右全为1才为1 || 位或运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右有一个1结果就为1 &amp;&amp;&amp;&amp; 逻辑运算符（与） — 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- 如果第一个值（转换后）为true，则返回后一个值。 如果第一个值（转换后）为false，则返回第一个值。 |||| 逻辑运算符（或）—- 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- 如果第一个值（转化后）为true，则返回第一个值。 如果第一个值（转化后）为false，则返回第二个值。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"运算符","slug":"运算符","permalink":"http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"Vue中动态添加路由的问题","slug":"Vue中动态添加路由的问题","date":"2020-01-06T01:52:42.000Z","updated":"2020-01-06T09:09:09.732Z","comments":true,"path":"2020/01/06/Vue中动态添加路由的问题/","link":"","permalink":"http://yoursite.com/2020/01/06/Vue%E4%B8%AD%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"起始前端的权限控制一直是一个可繁可简的问题，要想简单，直接写入所有路由，然后将每个路由的权限写入路由原信息中，然后在router.beforeEach中判断这个路由是否该用户的权限，进行reject()或者next()。这样做很简单，但是Vue提供了一个addRouter的api，用于动态注册路由，由此可以用这个api来根据用户角色进行动态路由注入。 问题动态注入路由后404问题一般我们将公共路由放置到路的初始化中，这其中就包括404页面，他的path一般是*,也就是匹配所有路由，因此Vue官方文档中提到： 当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: &#39;*&#39; } 通常用于客户端 404 错误。 所以我们一般将404放到静态路由的最后一个，但是当我们动态注入路由后，理论上来说，404的优先级应该比我动态注入的路由高，所以我第一使用动态注入时，所有页面跳转至404页面。开始以为是注入失败，后来将404页面删除就能够正常跳转了。 解决办法 所以我参照了element-ui-admin中的思路，没有使用*来匹配404页面，而是在router.beforeEach中，判断路由是否存在，手动跳转路由。 我在今天(2020-1-6)再次测试，发现Vue-router似乎对*进行了优化，即使将*的路由放到任意位置，包括首位，也会正确匹配路由，即当前所有路由中不存在时，才回去主动匹配*里有。当前使用的版本是：Vue(2.6.10)，Vue-router(3.1.3)，但是仅仅对*做了优化，其他通配符，比如/*并没有优化。 综合就是如果Vue-router版本够高，则可以使用*的方式来进行通配页面。 刷新路由消失的问题还有一个问题就是如果用户主动刷新浏览器，那么动态注入的路由就会生效，但是浏览器url并不会变，这个时候又会跳转至404。我这里采用的比较简答的方法就是在Vue实例初始化的时候进行重新注入。 在用户登录时将其用户标识信息存储至SessionStorage。 在Vue实例初始化时（第一次或刷新），首先应该是判断token，如果token失效，直接跳转至登录页。 如果token有效，再通过sessionStorage获取用户标识符，请求后端用户权限等级。再进行路由注入，并跳转至权限对应的页面。 因为刷新过程中整个页面的数据都会重新载入，所以我们必须使用一个持久化的容器，sessionStorage,localStorage,cookie都可以，但是我们不能将权限信息直接明文放到这些容器中，要么加密，要么只存储标识符，通过标识符再请求用户信息。 用户退出的问题使用router.addRouter的问题在于官方只提供了增加路由的api，并没有提供一个清除路由的api，这就导致如果同一个页面两个用户先后登录，那么就会出现路由重复注入，或者越级路由暴露的问题。经过查找资料，目前有两个主流的办法： 直接location.reload()刷新页面，重置整个Vue实例，路由当然也被重置。 优点 方便，一行代码解决问题。 缺点 如果页面应用过大，那么重新载入可能会花费一定的时间，会给用户不好的体验。 使用hack的方法，直接创建一个新的VueRouter，并将静态路由添加到新的路由中去，然后用新Router的matcher去替换就Router的matcher，这样相当于变相的清除了动态注入的路由。 优点 解决了上面刷新页面的问题。 缺点 官方没有提过使用该方法，所以可能会存在一定的问题，但是我发现element-ui-admin中也是使用的这个方法来实现路由清除，所以目前应该是不会有太大的问题。版本更新后就不一定了，也许后续官方就会推出清除路由的api。 附代码： 1234567891011121314151617181920//router.jsconst routes = [ /* 静态路由 */]const createRouter = () =&gt; &#123; return new VueRouter(&#123; routes &#125;);&#125;;const resetRouter = () =&gt; &#123; const newRouter = createRouter(); router &amp;&amp; (router.matcher = newRouter.matcher);&#125;;export &#123;resetRouter&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"动态路由","slug":"动态路由","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"}]},{"title":"Vue中的插槽与keep-alive","slug":"Vue中的插槽与keep-alive","date":"2020-01-05T15:01:42.000Z","updated":"2020-01-05T15:02:43.462Z","comments":true,"path":"2020/01/05/Vue中的插槽与keep-alive/","link":"","permalink":"http://yoursite.com/2020/01/05/Vue%E4%B8%AD%E7%9A%84%E6%8F%92%E6%A7%BD%E4%B8%8Ekeep-alive/","excerpt":"","text":"插槽初次真正接触插槽是在Elementui中的表格中在自定义列的内容时 12345678910111213&lt;el-table-column label&#x3D;&quot;姓名&quot; width&#x3D;&quot;180&quot;&gt; &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;&lt;el-popover trigger&#x3D;&quot;hover&quot; placement&#x3D;&quot;top&quot;&gt; &lt;p&gt;姓名: &#123;&#123; scope.row.name &#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;住址: &#123;&#123; scope.row.address &#125;&#125;&lt;&#x2F;p&gt; &lt;div slot&#x3D;&quot;reference&quot; class&#x3D;&quot;name-wrapper&quot;&gt; &lt;el-tag size&#x3D;&quot;medium&quot;&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;&#x2F;el-tag&gt; &lt;&#x2F;div&gt; &lt;&#x2F;el-popover&gt; &lt;&#x2F;template&gt;&lt;&#x2F;el-table-column&gt; 在列中插入一个template用来放置我们自定义的内容，并且可以通过slot-scope=&quot;scope&quot;中的scope来获取这一列的row信息。 仔细看了官方文档才明白，插槽slot是用来接收父组件在调用子组件时，在子组件标签内添加添加的内容，这个内容可以时文字，标签，或是其他组件。并且可以在slot上通过v-bind绑定值传递到父组件（说起来也算是子组件向父组件传值哦~）。可以预见，在el-table-column组件中，肯定存在一个slot来接受父组件的template: 123&lt;el-table-column&gt; &lt;slot v-bind:rowRata&#x3D;&quot;rowData&quot;&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;el-table-column&gt; 值得注意的是：scope-slot,slot这两个语法在2.6.0之后都被官方废除，但是并未移除。在3.0中会被移除，取而代之的是新的v-slot指令。具体用法如下： 插槽的作用域值得重视的是，插槽总是在父组件中渲染的，引用官方的一句话： 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 这句话中的“在”字，即我们能看到的。即使是插槽这样传递到子组件中元素。 所以，插槽总是能访问父组件的数据，而不能访问子组件的数组。但是有时我们又必须访问子组件的数据怎么办呢？这就用到了v-slot（slot-scope）属性。 官方称之为 作用域插槽对于默认插槽（即default），可以通过开始的代码形式，来获取子组件的值，前提是在子组件中使用 v-bind将其绑定到slot上。 123456&#x2F;&#x2F;父组件&lt;child&gt; &lt;template v-slot&#x3D;&quot;defaultPorps&quot;&gt; &#123;&#123;defaultPorps.user.name&#125;&#125; &lt;&#x2F;template&gt;&lt;child&gt; 123&#x2F;&#x2F;子组件&lt;slot v-bind:user &#x3D; &#123;&quot;name&quot;:&quot;tom&quot;&#125;&gt;&lt;&#x2F;slot&gt; 还有一点值得注意的是，Vue将整个slot的所有bind值封装为一个对象，所以我们使用v-bind绑定的值仅仅是该对象的一个属性（但是我们可以通过ES6的解构方法来直接拿到属性值） 具名插槽这个就很简单的了，一个子组件可能具有多个插槽，我们可以必须为止加上名字来区分，（如果不加，比如上面的例子中，v-slot = “xxx”全称应该是 v-slot:default=”xxx”，默认名字就是default），使用方法如下： 123456&#x2F;&#x2F;父组件中&lt;child&gt; &lt;template v-slot&#x3D;&quot;slot1&quot;&gt;对应插槽1&lt;&#x2F;template&gt; &lt;template v-slot&#x3D;&quot;slot1&quot;&gt;对应插槽2&lt;&#x2F;template&gt; &lt;template v-slot&#x3D;&quot;slot1&quot;&gt;对应插槽3&lt;&#x2F;template&gt;&lt;&#x2F;child&gt; 123456&#x2F;&#x2F;子组件中&lt;template&gt; &lt;slot name&#x3D;&quot;slot1&quot;&gt;&lt;&#x2F;slot&gt; &lt;slot name&#x3D;&quot;slot1&quot;&gt;&lt;&#x2F;slot&gt; &lt;slot name&#x3D;&quot;slot1&quot;&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;template&gt; 另外v-slot也可以缩写为#，就像v-on缩写为@，v-bind缩写为: keep-alive这个属性之前没有尝试过，但是最近遇到有个组件想要在来回切换时保持状态，既保持用户观看的内容，开始是想手动记录用户的状态，后来发现Vue官方提供了这个抽象组件，正好解决了问题， keep-alive基本用法是缓存某些组件的状态，我们从Vue的生命周期函数中可以发现，在组件失活时，都会触发beforeDestroy生命周期函数，但是如果我们将其包裹在keep-alive标签下，那么这些组件在失活时，并不会调用beforeDestroy方法，而是调用activated和deactivated` 这两个生命周期钩子函数将会被对应执行。将其缓存起来。 keep-alive组件有3个porp. include - 字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max - 数字。最多可以缓存多少组件实例。 基本用法123456789101112131415161718192021222324252627&#x2F;&#x2F;缓存所有的组件&lt;keep-alive&gt; &lt;component1&gt;&lt;&#x2F;component1&gt; &lt;component2&gt;&lt;&#x2F;component1&gt; &lt;component3&gt;&lt;&#x2F;component1&gt;&lt;&#x2F;keep-alive&gt;&#x2F;&#x2F;缓存特定组件&lt;keep-alive inlude&#x3D;&quot;component1&quot;&gt; &lt;component1&gt;&lt;&#x2F;component1&gt; &lt;component2&gt;&lt;&#x2F;component1&gt; &lt;component3&gt;&lt;&#x2F;component1&gt;&lt;&#x2F;keep-alive&gt;&#x2F;&#x2F;不缓存特定组件&lt;keep-alive exclude&#x3D;&quot;component2&quot;&gt; &lt;component1&gt;&lt;&#x2F;component1&gt; &lt;component2&gt;&lt;&#x2F;component1&gt; &lt;component3&gt;&lt;&#x2F;component1&gt;&lt;&#x2F;keep-alive&gt;&#x2F;&#x2F;规定最多缓存2个组件&lt;keep-alive max&#x3D;&quot;2&quot;&gt; &lt;component1&gt;&lt;&#x2F;component1&gt; &lt;component2&gt;&lt;&#x2F;component1&gt; &lt;component3&gt;&lt;&#x2F;component1&gt;&lt;&#x2F;keep-alive&gt; 当然，也可以配合Vue-router。来进行使用： 配合路由在使用Vue-router进行组件选择性渲染的时候，我们同样也可以使用keep-alive，因为&lt;router-view&gt;&lt;/router-view&gt;组件是一个抽象路由，并不会真正创建一个组件结构在整个文档结构中，所以keep-alive对其仍然有效。代码如下： 12345678910111213141516171819202122232425262728293031323334//router.jsimport Vue from 'vue'import Router from 'vue-router'import Home from './views/Home.vue'import Login from './views/Login.vue'import Register from \"./views/regisetr.vue\"Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'home', component: Home &#125;, &#123; path: '/about', name: 'about', componet: About &#125;, &#123; path: '/login', name: 'login', component: Login &#125;, &#123; path: '/register', name: 'register', component: Register &#125; ]&#125;) 12345678910 &lt;transition :duration&#x3D;&quot;500&quot; mode&#x3D;&quot;out-in&quot; enter-active-class&#x3D;&quot;animated bounceIn&quot; leave-active-class&#x3D;&quot;animated bounceOutDown&quot; &gt; &lt;keep-alive exclude&#x3D;&quot;Login,Register&quot; max&#x3D;2&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt;&lt;&#x2F;transition&gt; 上面的代码即表示，不缓存Login,Register组件，并且最多缓存2和组件。 *值得注意的是，当同时使用transiton组件与keep-alive组件时，transiton组件必须位于外层，很容易想明白，keep-alive组件对其内部的组件进行管控，如果将transiton组件放置到其内部，即使它是抽象组件，也会被被keep-alive组件管控，导致不正常**","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"插槽","slug":"插槽","permalink":"http://yoursite.com/tags/%E6%8F%92%E6%A7%BD/"},{"name":"keep-alive","slug":"keep-alive","permalink":"http://yoursite.com/tags/keep-alive/"}]},{"title":"Vue中的组件传值","slug":"Vue中的组件传值","date":"2020-01-05T10:05:01.000Z","updated":"2021-03-06T12:02:07.317Z","comments":true,"path":"2020/01/05/Vue中的组件传值/","link":"","permalink":"http://yoursite.com/2020/01/05/Vue%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/","excerpt":"","text":"父 =&gt; 子父组件向子组件传值比较简单，直接使用v-bind:key = val 1234&#x2F;&#x2F;父组件&lt;template&gt; &lt;child :name &#x3D; &quot;&#39;tom&#39;&quot; :age&#x3D;&quot;&#39;12&#39;&quot; &#x2F;&gt;&lt;&#x2F;template&gt; 12345678910&#x2F;&#x2F;子组件&lt;template&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125; &lt;div&gt;&lt;&#x2F;template&gt;&lt;sctipt&gt; props:[&quot;name&quot;,&quot;age&quot;]&lt;&#x2F;sctipt&gt; 这样在子组件中可以显示父组件给子组件传的值。 值得注意的是：在子组件中可以对父组件穿的值进行检验。 123456789101112131415161718192021222324252627282930&#x2F;&#x2F;子组件&lt;template&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125;----&#123;&#123;id&#125;&#125;----&#123;&#123;address&#125;&#125;---&#123;&#123;email&#125;&#125; &lt;div&gt;&lt;&#x2F;template&gt;&lt;sctipt&gt; props:&#123; &#x2F;&#x2F;验证为字符串 &quot;name&quot;:String, &#x2F;&#x2F;验证为数字 &quot;age&quot;:Number, &#x2F;&#x2F;验证为字符串或者数组 &quot;id&quot;:[String,Number], &#x2F;&#x2F;验证为必须传递的字段，并且默认值为北京 &quot;address&quot;:&#123; required:true, default:function()&#123; return &quot;北京&quot; &#125; &#125;, &#x2F;&#x2F;进行高级验证 &quot;email&quot;:&#123; validator: function(val)&#123; return &#x2F;^([a-zA-Z]|[0-9])(\\w|\\-)+@[a-zA-Z0-9]+\\.([a-zA-Z]&#123;2,4&#125;)$&#x2F;.test(val) &#125; &#125; &#125;&lt;&#x2F;sctipt&gt; 子 =&gt; 父一般不推荐子组件向父组件传值，即父 =&gt; 子的单向数据流会使整个项目更加容易维护。否则无法维护项目的整体性，组件内的状态可能会发生不在预期之内的改变。 但有时又必须通过子组件来改变父组件的值，则Vue官方提供了子组件与父组件通信的方法。借用这个通信的方法可以顺势进行传值。 12345678910111213141516171819202122232425&#x2F;&#x2F;父组件&lt;template&gt; &lt;!-- 通过组件事件进行传值 --&gt; &lt;child @getData &#x3D; getData&#x2F;&gt; &#123;&#123;val&#125;&#125;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; val:&quot;父组件的值&quot; &#125; &#125;, methods:&#123; getData(val)&#123; this.val &#x3D; val; &#125; &#125;, mounted()&#123; &#x2F;&#x2F;或者直接挂载在vue实例上 this.$on(&#39;getData&#39;, this.) &#125;&#125;&lt;&#x2F;script&gt; 123456789101112131415161718192021&#x2F;&#x2F;子组件&lt;template&gt; &lt;button @click&#x3D;&quot;sendData&quot;&gt; 向父组件传值 &lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; val:&quot;子组件的值&quot; &#125; &#125;, methods:&#123; sendData(val)&#123; this.$emit(&quot;getData&quot;,this.val); &#125; &#125;&#125;&lt;&#x2F;script&gt; 即利用v-on为子组件 添加一个自定义时间，并将父组件的特定方法传入这个监听事件。 在子组件中调用this.$emit(&#39;funcName&#39;,args...)来调用父组件的方法，并利用参数将值传入至父组件。 兄弟组件兄弟组件或者跨多级组件则可以使用vuex来进行数组的传输。具体就不在这里讨论vuex的用法。 跨级组件通信 Vuex $attrs、$listeners Provide、inject $attrs、$listenersvm.$attrs 2.4.0 新增 类型：{ [key: string]: string } 只读 详细： 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。 vm.$listeners 2.4.0 新增 类型：{ [key: string]: Function | Array&lt;Function&gt; } 只读 详细： 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。 示例123456789101112131415161718192021222324252627282930 &lt;template&gt; &lt;div class&#x3D;&quot;test&quot;&gt; &lt;child v-bind&#x3D;&quot;&#123;name, sex, age&#125;&quot; v-on&#x3D;&quot;&#123;changeName,changeAge&#125;&quot;&gt;&lt;&#x2F;child&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import child from &#39;.&#x2F;child&#39;export default &#123; data() &#123; return &#123; name: &#39;张三&#39;, sex: &#39;男&#39;, age: 11, &#125; &#125;, components: &#123; child &#125;, methods: &#123; changeName(name) &#123; this.name &#x3D; name &#125;, changeAge(age) &#123; this.age &#x3D; age &#125; &#125;&#125;&lt;&#x2F;script&gt; 子组件child.vue 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class&#x3D;&quot;child&quot;&gt; child组件的$attrs &#123;&#123;$attrs&#125;&#125; &lt;child-child v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot; @showAttrs&#x3D;&quot;showAttrs&quot;&gt;&lt;&#x2F;child-child&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import childChild from &#39;.&#x2F;child-child&#39;export default &#123; name: &quot;child&quot;, props: [&#39;name&#39;], inheritAttrs: false, created() &#123; console.log(&#39;child&#39;, this.$listeners) &#125;, components: &#123; childChild &#125;, methods: &#123; showAttrs() &#123; console.log(this.$attrs) &#125; &#125;&#125;&lt;&#x2F;script&gt; 孙子组件：child-child.vue 123456789101112131415&lt;template&gt; &lt;div class&#x3D;&quot;child-child&quot;&gt; child-child组件的$attrs &#123;&#123;$attrs&#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;child-child&quot;, inheritAttrs: false, created() &#123; console.log(&#39;child-child&#39;,this.$listeners) &#125;&#125;&lt;&#x2F;script&gt; 利用$attrs、$listeners可以实现层级传递，将跨级组件的值传递下去。 Provide、injectprovide / inject 2.2.0 新增 类型： provide：Object | () =&gt; Object inject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } 详细： provide 和 inject 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是： 一个字符串数组，或 一个对象，对象的 key 是本地的绑定名，value 是： 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或 一个对象，该对象的： from property 是在可用的注入内容中搜索用的 key (字符串或 Symbol) default property 是降级情况下使用的 value 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。 示例12345678910111213141516171819202122232425// 父级组件提供 'foo'var Provider = &#123; provide: &#123; foo: 'bar' &#125;, // ...&#125;// 子组件注入 'foo'var Child = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; \"bar\" &#125; // ...&#125;//孙组件注入var grandson = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; \"bar\" &#125; // ...&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"组件传值","slug":"组件传值","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"}]},{"title":"Vue中异步请求更新data导致数据变为非响应式的问题","slug":"Vue中异步请求更新data导致数据变为非响应式的问题","date":"2020-01-05T04:22:40.000Z","updated":"2020-01-05T07:27:21.749Z","comments":true,"path":"2020/01/05/Vue中异步请求更新data导致数据变为非响应式的问题/","link":"","permalink":"http://yoursite.com/2020/01/05/Vue%E4%B8%AD%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9B%B4%E6%96%B0data%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E5%8F%98%E4%B8%BA%E9%9D%9E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题最近在项目遇到一个棘手的问题，看了1天才发现是异步与Vue的数据更新机制导致了结果与预期不一致。 最开始的代码流程是这样： 通过一个请求拿到一组数据data1，包括下一个请求的关键字 在第一个请求的回掉函数中使用for循环利用上一个数组的关键字发送多个子请求得到对应的datan，并在每个子请求的回调中对data1和datan进行对比，然后给data1添加一个字段key 在第一个请求的回调中把修改后的data1赋给Vue实例的data中 产生的问题在Vue实例中的data1对象中，原来的数据都是响应式的，但是我后来添加的数据并不是响应式的，导致DOM不更新。 解决过程产生问题后我先后大概经过了3次修改来解决这个问题： 思路一：data转换为响应式的时间首先我从响应式这个角度去分析，Vue是在哪个生命周期函数内将data挂载到Vue实例中的(因该是在beforeCreate与created之间)，而我做这些操作是在mounted，所以此时data因该已经被挂载到了Vue实例中，后来我又在思考JS中存在变量提升，是不是Vue中也存在，即是否在mounted中存在譬如this.xxx = yyy这样的语句会被提升到其他语句之前执行，yyy的内存地址提前就会被写入到this.xxx的位置，然后在这个内存地址被赋值时就将其变为响应式，所以第一次data1被赋值为一个数组时他是响应式的，但是后面对这个内存地址的变量进行的操作是为数组内的对象进行赋值this.data1[i].key = val，这样的赋值是无法被Vue探测到的，所以其后添加的属性无法变为响应式。这样子似乎一切都说的通，但是关键是这种变量提升这个东西我之前从未在Vue中遇到过，我查阅资料也发现根本不存在这种机制。于是这个说法被PASS。 不过这个过程中我也复习了一下生命周期函数和Vue中数组对象的处理： Vue生命周期引用官方的一张图： 值得注意的是：data，methods等都是在beforeCreated与created之间进行的。经常使用的mounted已经是在模板已经编译完成之后了。 Vue中对数组和对象的处理对于动态更新DOM最基本的原理是定义一个变量的getter和setter，在其中触发更新DOM操作，对于数组，我们整个赋值，我们可以使用getter和setter监听，但是如果我们操作数组内部的元素，比如arr[1] = 0，这样的操作我们是无法监听到的，因此在Vue中，如果这样给data赋值，这个值并不会变为响应式，而是一个普通的值。具体有 数组 通过索引去修改数组中的值，arr[i] = val 直接修改数组的长度，arr.length = n 对象 给对象添加属性（包括data根节点，比如没有在data中初始化某个值，在后续直接使用this.data1 = {}，这样data1无法变为响应式，dev模式下console会报错） 删除对象属性，（包括data根节点） 对于以上的问题，Vue提供了vm.$set这个api来解决。 对于数组的第一个问题，可以使用以下方式来解决： vm.$set(vm.data1,index,val) 对于数组的第二个问题，可以使用数组的方法来解决： vm.data1.splice(3) //data1会被切割为0-3项 原因是Vue在内部也修改了Array原型链上的方法，使其能够被Vue监听到，包括： push() pop() shift() unshift() splice() sort() reverse() 思路二：请求异步的问题这一次我似乎意识到了可能是异步的问题，因为之前玩canvas时，也是一直结果达不到预期，结果是img标签的onload事件是一个异步事件，导致结果不对。再仔细看这次的代码，可以发现，在第一次请求回调内部，由于接下来的子请求又是异步事件，所以直接执行了最后的this.data1 = data1。在子请求回掉函数执行时，data1已经被挂载到vm.data中，此时再对其进行添加属性处理，相当于是上面的对象添加属性的问题。所以必然是非响应式的。于是我this.data1 = data1放到子请求的回调中，每接受一次回调执行一次，虽然感觉这样很消耗性能。 但是结果是，data1数组中只有一个值的属性变为了响应式，其他的数组值仍然是非响应的。。。至少结果逼近真相了。 思路三：Vue对于data赋值的性能优化在Vue中，有一个异步更新队列，在Vue检测到data的值改变时，会将其写入异步更新队列中，在下一个事件循环中去进行DOM跟新等等。并且在这个队列中，会对数据写入进行优化，比如this.data1原来等于1,接下来执行了两句赋值，this.data1 = 3;this.data1 = 1;并且这两句在同一个tick（事件循环队列）中，那么Vue就不会对data1进行操作了。 那么这里极可能是在极短的时间内对data1进行了两次赋值，Vue将这两次操作优化，第一次是整个赋值，第二个则只对修改的部分进行了变更，但是前面又说道，Vue没办法探测数据内容或对象属性的添加操作。所以第一个是响应式的，而第二个则不是响应式的。 所以唯一的解决办法就是只进行一次data1的根赋值，所以我想到了 axios.all这个api，它是在所有请求完成之后返回并进行回调函数。在该回调函数中进行数据处理，再直接将data1赋给vm实例上。 成功解决 总结还是不太够仔细，异步这样的问题不能立即看出来，导致前面走了很大的弯，还好后面分析过程比较正确，找到了我呢提所在。不过也好，重温了一下，生命周期，Vue对数组和对象的处理等等。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"},{"name":"响应式数据","slug":"响应式数据","permalink":"http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE/"}]},{"title":"2019年的我，21岁的人生","slug":"2019年的我，21岁的人生","date":"2020-01-04T02:59:17.000Z","updated":"2020-01-08T15:38:37.033Z","comments":true,"path":"2020/01/04/2019年的我，21岁的人生/","link":"","permalink":"http://yoursite.com/2020/01/04/2019%E5%B9%B4%E7%9A%84%E6%88%91%EF%BC%8C21%E5%B2%81%E7%9A%84%E4%BA%BA%E7%94%9F/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/S0DwQmdUisVn9NOk6JJYX/2yfp8tR/gLSpGRSjYJnDXtshWwTB2dm8ZnB8jxrUOfxiwPDnULWXI3FbxPqqs9rTI4ctjJIUBbhiWvRvz5zaFdpxCo8a/pWCnBEDat1f+t9+DS5crcAqs280vTLYT1+Rls2IInSzH/jHMntl4hrFsSgvoCGQU5WL55s/jFM3H9ShKfL7m6q1larf3EPHN/SIb6LDnETqRJGN5tm+NKZ6JGt1lCsZ2Obb8BD1fPht44BlfNwyNNnMFSNj1s+yCSppSpehxpl40Z7gaM7e0ZsUjdp/DJhTUfTriZuKWI7djL+q2qBFui0g0mg4OzmvbmnM94kj2wWbtjzJWCb9Z/27UqQ0phePwBSjVZ1fFO29zs+pTC1ahJI5mTB2hSWX2ZBQKUYhbTT5oQgyGyMzbQ2V+De8mSiz+eKOF3f61rKLyNbYbfdGjUQEKXfUZpurDxXiXW48XvW8hHYA/ZZFOeiGl5dLzGAnk1pBLuGzBQ8reG67qB9xZkLYRwO8Jr1Lw2KAweMcDLA7CbgUDqGjyrG/iSA0SGBEMBCVzxOSOrpBFJaOb7Czog2T4p5GujlzfJuRTSrRz6b9aXdv3zHjIGQ5FQhVjMoMHBh7wGKLDx9DmKQebD/uUj156eW8iIu4c+XBzIOk9sGpGzh0Xh1+JjVEsg9MYcrzYjRpIQCdRyrHkZC49aJrqs+jUHyYO+6FDyVa9+6cB/x23i6ot1J0N6Sd9aKaiFcIRo5NsD+kFYKk1RVbSf0YuvD/oT0xzW+5qzyeW92GEgOq37ct505I2g8uneQguOT10elUHobjlexgHLkLbLuPbeHmeiofRJ4Iiv6pQ/1B3DiKklVnMiLY0XYxKwwhUR2qWd9GTlBnLQ+bzMIgrMDMdf2tv8jSbRZIU9xuUIvH/QVToTsb/vx+Yy6KL2TewGz7z3073CnQO+4fNm3ImzoJT3BcLaqz6wMUhjN0qatZirDNc+2a7X1osdjCrBv3cn2rKYZGhj65WuiLWWpdBLn7GJ+J6XLfO8DhgKXQfL7hCpWn1uyI4Fj/3YVWlhgThvVtjI0TCJaQBVKwIJzb/nrOTpPNN0ad61pNP10sCPRQ9Qeehr2EhUoTJ5XITK10+W4HlgO2dmhjtREmbTei+hvZVpvscr9Z6IOjkXTnhBEJGB/5aXbz3etuKF+l7bOnyJKvG/OWOeAJWlaE7vQhqRFlIEbRQEJw0cy4C6rcf5bbqM8PQNxrlsATKRAlMJsKuizXvHJbc6jWvXNnBtTkkuuQ1JNXmTsKnvTdIalpGS92K+xW8ysL9LyXWrwOaN25ISpfPZu+3FcnkHzdjRBC3gdrMvPqfRtZ00A5+UbuMtt0QPQAIH8Wan0lk0+dZVSjFAg/QDLYhSthWG5p6PET83TTq5BmWyZVPkpLWrDP+TFMYCE4KbfinxMg9QRgM11cN7DI6cd5SeHPlF8XknDMWj/s4WzBMC/lhYa2RsrOhWoWgI5PPBkQdXXjoTwdRAqsTrTtmCQfuXzsPY4xbGtTyqYBOAmQVV7Hclxy+06ar95A5sQ1zQnu0yQwkj+iIzdp9x3IOPWUMPF3TtrB8aY1stTMB+8x27HCj6gMD7Iq6EfNlUigACDXsQPqC5pYV8SoIRiI00ROTneOzZfdsLiCbBD6NEbDNtfjQNqA+LdNeYumZjiiPUZIPJFEbNFbR1vJVwQdzPPNkgo9NIg0ot2xlNBH6YRqgbhnIrftajB1PvbsPTXpj/obt1/cuJ9w/50PHbA5wET0uNOwSYNmqEajmatOIjLuIK2QdJi1ibxAz2/tpI9Xo9Ut3ucXlmJgyi5obD+laLEcNbRucNRrJ7kvPx7WF97bPjdiamyjHsG/yLELZpQCDGZDTaJaHlIMakAMtGNkI3DCZW4HNIdjwvUwv21viQCTibztQk0XxA0LGsfjfQ45YdbLJAnxsQ4tH2Oz14urVSdctCGMrd2czX5dIto4M5aQPithNA/f7cvR7sqgOWbfC8tyn40Np4jf8VUNhfWEy4AZHeDm1OvBZv0qX5XuXi5ynRnNOKIeQ5MEk9yzQIGk8cU4aoTksKkOaJPOJT4SwBlEQUezBYt7sPIW3VFHG3+4tqfGdT8IHup/Bg/j+sGFjv0jPm461eZG3W3WZ3CZSmg6CNOlO1/X84n3YEnfeHLEBujSMClxWyFGWMkFYlphiIIt2CGwPdPev1XWR+qhdx5B/3y7UjlFL1dwxd8EvJ0OwcTJMk0mHCMrmUJPqL9D8J3XwzgktJS+a4qLgah2zu51ytQUpzaJ8p/3cMArzGFLO4bZDmDwRtxVRODYyKZcqTxl2uGagvf7CLIIl30BhFTdjW1mBFgHyxAKrsvfG+KBEr6k/RgolpNQ+4pxdJoQOyh2XuGn4UOqGkWqvuYx8QIjgrypjp3dBBHmP69yzMATebT0SaS+rdnFlWxh6bXxiKXA9h2CnuKRghmY9R0HUIliyMR0RbjTtHxpRA0enk81AFYVhVVlwQgth9wTTlXQT3wAGI5ZX81zN600plPXRIODcCuWmThgNSORQyavFQojFRIBeleal7I4nSHYelx6yx6Dd284YWHqlT3TakqVQxVedP/mbZiiC3zuFNjJoIjJhVrNYgZxDrVOEA0odkdLgra9/Jhd25nf0tonErRCjFhVYV3GHpoAmKkh/wn1Z6NlEpXJKk8l9ZUjozmpqPPJWU4xzbdAr/9/x/nWjnUWFcXj4hrgU2sVohiZE7FR8FPW/fmPwpe6ikvutb4FQiQUPst/vvcEjRE0L76axRozI5ZZb0RA4rtyGResm1JOOkpm/5dSGn1v0OypNHjAxbN2AG95rMIVShBsGzjH6CteUu5XIRsVDx/2kRZz317WX1wuPCWnQIFjifXe/FvbqxQ0JUQE35nw//Fm/d57dUfVrtgVQwzs/VGXPCN6LJjQHBpxqMYusfoqt7EF4vZUEBOOgmYNOZlKAORchmpUU9SBhjTSBzVm7yisPFJXjBxw2B2TtrCaitWqF8CS2RrRe5n6wmUS8fWB0veqNq+sOOLWjsYq/ugZ0I5tmsEpNKUkgpDk0fS53L5MbWKzQwO6/r7UdycyMOn+Rf3Ab4pBhttrzRTeSFs+01wREqtovtuXIZp7PR5azYdgPyReuY/TgCot2jHrWUHETAWM5FBoJq9ssAWNn5YqQtJ9r2OAiKxLZkDR75UqqjzHqpjkqKm0YJ0cUajHJNxsKjryrvn9BByTm3Yam55SriD3i0xTPlk7ILHilWvPwio/Iyi0TGD5f404rKJEbxkF0XTWUHre6gQArFolVK6xIltj+eGV45AXJM6Y+HI+znffTaxV3DhML16S268CECaMElxZt8xy09ANYacW2L0j+VnViDo/UqoC5P6F6bcDx0WRSzNfXaNEuSHd/9uk6EjUtE71p8xAn2dNzXgvCG1JUPl1XXkTzo3ATe4hdJASIOuC/wj/bKmGunMF8ihkDzopJzgXZ20M/Z/Fq9ZS42mJXwbeJCeILQq0/475Tl2NKsGqS+s1h7DPhuNDVLDVUKcoKK/vOGkgMU4VrNv7XEdVCB7VodbcVK2alxy62XTbtYGkv1iEhFGsdDK9kmwAv72moM+7hVCtAedvH8yQ9D0V0vtl5mRgwgG69w9afsnO0S3RM7Y50/qAn1BmaIhq4mfTK3Xp8VN9aogs42GL2phatpPZlT43+bs0nKVYbHIT7X0sFg08LJlaTTGVvA7Q40mHJBSSOIZr12T3hJ7XMWNgLFPCsqb/zSMLzlpwttG9p5eXbc77AJGgHKrYfbWgr/ejlMfFFErmtOOuHNve+pCEMp8XGsRYbPcBrKuOiK+mBe2IAVlCEsRI7H1tfrrnqEELo+bg5MmdwX378Ciu3UKRj2onoyryBSDZXT5YPMPitFsiXDzmtCMKdrE0zNRLCh2dCJVo4X9Ih1SjbYZodbP2UX7f0QOWDXgeHSePqlb4SQAPDkQKh1WNhQv6lKAATLLXPoUdzeijRxhIdeGhPP13kD/aAjN8vqkA6zCbevIq7W8B6bIpTEehhz0JsSw0r32w5kyTLr3Y3xdiR57uigZ7OgPt8XlwzPV7ij8VG7rJZw3YEpR4D/WjqAcLs1MhUYXG3bIyo7mJXlpzWF4Df8BbAf+nlX/LRroQfoT4wPq/phv4feD7FqOyUhlA/1cwiWn3EAcwUOTnSBCxGPfENKf/q4+3Z2wYgK1N3WmCu1u79TSZlkcHjKIr7j2vh2N0JjoYdFHqFmpYXrK+rJ0s0qY4HFGk6Ub/mw+h20Sbcmf0HBZCNq2KFcw+eIxikolePjdN46a06lEtJ0VZXheMr8kGwnbbl5maP9cN04uXneAj+rp8x3Sd0GJoTYAE8yQg1fDxT4uDYW2Ow1OxEC+WL5vSzE6nlDKxQ6DUEpmi3vQaBmDLqFSFMBR7Apt/k1DXTlMN7TxAezFyvBMc0w41Yx8lI86BXBdQ4R8UoPYG8tFJSxbpQYu/uL5Pehde5fZgHq2ZZqlknt5NpsjhDadhoV6lrP/DMNyiu//1woGSklGpILUyemuY829QXw2n1KA9v8pZynblvWtJbRnVfpQgtj/wbU6mJD9NCPp6UXaVo51dNY+X36AU2arANJ6RRhLhjSry52p4DfgNg5cAzpwZce2a/iaaym2ae1NMA4fOBrXM22QOxZd4a4CBWFqlYNpVzfWg/y98IG8WqUb+FzVDL7ABOX91HsyMMe2nmYDICuwVb6g5l5GyZHM89xsL5POP/VIKxrzRSerNvxhbnMOZhOpfUwPFf9Cbcby0UACYavtn+jJDcrPm/snIIrFxX2WfHUdhE+LOiSH4B5j6ObxhVbri30VV9sK+johZOeKvhzZ759zvVgpfM/mq3LjGta9vSuZjtZ5Z1bxkIG9W3HIuKlz5trsoyEBYk9X9++V4LME3HHu4gpaHbB0aH1mb7nd2I096NDqp9ReArJab+/e/NOTB+lZt7i1MjJJMlkhFqkfNg3IZDoxRugolPVAUy7eD6SyhMRToJmyhcAti5EAIlBVrtiGGkjaH63+as9F5GJy1iK1AR5NAx+QLN0JzEY0STLThNeUs3BQDWqh+/4Cnq6jivAibMB3u08d17fwe+jw4B0iCFrqqP89q1MwyGkAVGRzse9TEjsZ379bM+oWsWoxB0Kndz7NyeCtaP6g+O+4VvnYXIO3XybmaOTATm4eaNYUviSKfVGdRAreaOL9NVTf2SksoqNFx9PKV7nIswyYGWLrMY7+JrFAlmhOaQK0HvKDpCTjkAYgDpg72gsARar0tM2OvgelXl3Q+jaksIrovriKsUzCGtw9v7OIxsYwcLcKsVxg5l2eH8nyAyGYhur3Y30baKG+DSe6wbOnZzyI+HrKa8Hi0SJA+X+EEn0g2ag1mej0Jn6WoJuXaXKlDxLytG4dflMhfYDqMPL3TJwjoovkyLyUEaZ/nG48I/ogRajh4CXI7NvwTUr9fHguRNxLIcUGvlEqL7Rq2+huDUPVU6DVZRoZj3y++ptD8s9qnBsea5O2dEjoOq1CEixdciFd11WKhckRDgp90GbcAcxd61axTcSbaC3zMsE8KrxpfSh1IbxiAMgX91Oav2xb3NPPz49B3CE9BNzL1t2oSNca8TYk5ChjLwgHYOfZYxp5Ucmpznh+5RyPK1FpzazEBiVhHwUJ2tzKSuhXeJ7ciFOw+TtdSITluz442aBg3uD2QwXGvfMes2aUCwX88jhJtdszDVJuf4oT6OugHc67dN/j4TJD2ouhonpUY/qR8AEgVurljeM+C4+vxZ+nflZu2fOIKcntwq+cSN4iFp4ZKjcsCQQtyKqEp1rOblh29y7KRzUY0BZ5U/83RBJxtE8bJwLpQgbu1lXuNqY4hzY6GZ74iiFrwKoacGVRqD4IvUHiK3Ik7sms1hq9J27xR6OwjepX1QLwbvEZWJbiBs01HEOIfyscpIU5svLIdiEimO2Ue1U2pesVM8MzpMVAXPL2KcBHI5jYBT8guKUaEbw0LuyZCoRUk9iGTWxuzyIt02HS8qRcg29LJGq72wkzGyh6SqDSZfd8txqUB1v90Bd+imUB8TYeXMuCjD8IF5ZF+XlfFAHKPcTlvW3pglFMQEWIhQCvPBJM0puXtWnLseflcXdCz1iYrOcBDbBZa78TvzjcHRa4ijZkwLakViuyoV17EAm8cxSXY7Nd9zc1M3WZ+i7bGO7/hejGdxqfnxWWTWhB7SVg7pqa2jcBjPD/luqaKqpiB/ZdKXTllUJ/XIF2r7mL/p+FkVTKjdZTRCNTuxPS7mrFH5eiLWgjTwmHbRx1lXolvCnVKtt8e0FHzgSPNHFV0HnR5VJbhCwsp1Feqta687awNvjSVD59/j3uo++YhG3ARvkQysslKiK5DgPMmzHlomcNpI+LTQhF9WIAN7oZ/esAeZhdlvthVlnQ0kNcBGeortnJ1yDmkZsDs42/gQnudQPSOu2JcnHIwfSO2T8fFBTvYEwC3cEavE/4+h1D2a7F8YIDjty9iBJdqco6kGQjVTaASuBqVfIK8l0YXrcFbUk4vMHp8K3z86xo+K+Sfa/8mNLtTiLR/ZMepMGcqW67sd5dxwZbakgmCbCKsEFaFD/IpO9dRzb/grLg1j7AEPK1e0H8Ra5xwhEiR7LuWDGhph9GIwA9ddZbl0Qcd5iZ9+Nqq3AozWpqdzfqsMo3VpQl1wNaZaalGKSwYVL82VpJhOwnpBq8L/DhuRd5X3s2B6jxK8j7VHRcaixqTcBCVf4DaLm521ncKBjk/hfjrfCE8dp8iaF3cHgwPMWnQ6KoYjWvS1W0EWMTFwn+4JqYsFH4iyd3XKHETaphpgF6bZ7dL9vgqfFGGkZ8xo1bKgemR5S8wSMLqHJJtilQUvfd68nDwmHd0fnqPg8U1+0FhsCSyui4JXATv2PeWGZt6KiqD58k7ZCzuUX06pzZEDnlRUSLwJYB21zX48X37PrLI4pA6QPwrF7nps1FMZlHk42ISm7lCHs3l1Fai4yrp0FcfMFDLXTF2crYWPSxTJxHQ/iDQk19EaUqj3H8gADoJEPxXLskPM+6xKNjjJyJpAgb1yLoDqIS5dE3IaXIN2fXCOnIoWf3lRJImzo35+JRNF02GfhNO1QxtkJ4VWeZ45VUiYfyhJuOBUMJmil2EPNIG6RCzfxvHuTHkjL7CEm5Rjkd1K1II90X8PqL2DdU36JWcLebpegPx+KADuP7P6zPAMHbydcYqZEKavYwd/Vh+lAM/EC/IqXj0x3yzuNhSRG+xl3dpMSGTMkuzXVsWZdCfHTIIbcoPnXlln9XCn8A+saciCPUIT0Pf9Pm60aNn25TUfPeJxF+9cZJ9T0uFsOsUmtzTmCoV1L77r2sDg6V8JX2fYmewyQbzSzF+ic0+ZILeZd4auWKuMJFx873FdsjEBa22K19qU61ow9l6pFG8jKlWW5ooA0zU+knQUzuuX66DcO3cEiOWpJ76bw96+D5P0qAzHNhloUm3bP6TfwV8hKSnBkBb5DSQdObwlTavRUC6E3E2YrbgRT4lYaRI9yCw5jvdShQInn/KMXogQAOo/LfcvF2CRTmQUxFZoCOaA4DIJ3PdvmA+6kFdyFvtzHIO+VmMNQeryxriQDYnYcVNktZQiD2fzP3bbTItOvNnt7EtTCbk7s0Lv6om5eLlh+uqMvZSJ2cAmtcqjNHVQ5sYTcDi0jD+fy1Sh4HZqSFehEJUsge+5Kq+9Y7YrZwIJAEn95FiR+/c9MSvSSRfWCHL0M9T1hgtSxuPTKX6tm9jiqV8V2x2bajQuBTXmtVGsSOI7dwexByaLFVQv6naU5cqcHcY5EWp95OYc32OJx8TH3KzO8O45jAJX4Y45FXmZBmcyibnTiLbC71ZIQ/Ae2qgvfw7AUGS5pmtid+65MUSFFy/zK/WWoS4dr4eaN3/d59Db/Ce14JvlevIBILLvLvo/YWklZUmCiXRvDwNZxSWmTukvcoagd/73aoWXdJ7roXssLJE07GYKOtP9+FArbs8yUwPVr+2eFmadJWA8lRRfM6GQWfpF4I+98J511NfF79ytix8urzUP5lzDgjzel3ddZGYdNHPeJ7qbiNvgE9oGTygEvqnKH4ZJH61+PwhiGD41uQUQd9lH8F3XHs7RsK48JQQZDS+v0nAomQ/L2R9bMPplyd3mRhuQ/IrmpE7n/RQFFYqaU0UXSQJxftfEsoN5MLZrEGTByIPcT/v9RvM68wulPgffRX9fQvWNFaKSbmEbeYwWo/cytwl+Lnzz8d/0m3aP1EFOmmDUNm/mQuqfp5cqHS+dRSDBwyw4N1UBELmiNKfiMMvWzQ9HoDiGCueopzyllIWVHrg1EVLgEdXQNAkV8lA+0vwREYSv+Zq2jmcAn4cCN9R6GUMwUCx8QaRQjss/0tssFA/Iysx12IkwfD7uOQZS6QSmRyIpi72v+/hj1T6W1rI6MQDyBtd5SYisj6ecApGqXXDjiJvr8/E8dZxfdbgS4zYAKi9IYpwB8p2T2SK2Xg+S3ZAJjslq7dE30ok+s9ePbO8ebJ2t7xC+uZRcGE2s4m5OAJSGL+OsCGq29fWvYa4CkMBCFPj8aM7ynHJif6g/PmrvAohmiB00/hQdR/RcghKTqaC9O4HJteQQmjTKzDN9fgUNVW8ZbWhbKX65UZsOql5bbfhGVJ9HST2JdKz/q6MBAxp4+C0QspBiYUKG+CxbqCTr9ie4mNh4mXu7DQCHeX3yfrfz+mXdcVj5PEhMlO3NYike0uSaXwH0jqwlK3/hH2HxAp6x/zHl8LLdgyxS+BvfSnanuyndFcJULi92+9skcUAdrgd0R90vKTDgRB4IHA0E5doS4EZsupOiF56IRXjUb5IbTZPbsuoA0w1XExkBSEbMd4w1bjKsd/duMkNKxzJ+evpBkgvJnpC49CJr7/QY3xAciS9EPaaHkqCS4RPs/QNTRzbuQED8Q8RavsPSLLkOYGjwILcTeLPBD9X9sTONE3p9pL8GORpsElFQ3TE9Bb5qXTfHeug1vandETFgWrgJJwc6rEBinZ/7+h9gvLVMJQMGLnBHUsnvZKW7mxoQprL/F6i0EBPkMOCfS9Rl1uugAipGuhoc2XTQLUV2RvyWI94fbcBJmaFZIKhP8zPfhQhdho8l45LbBSd97VPH7T5AdHjxGdmuzmxyCUrW+b1HJvlEjUVD5E9KeFw3C4a/o3kfWyvgnjNuuRlp0SrRCnPT81jygUXyV6pyDRhv60ogZ9df1lvm9X6fIg3y3iCwg3c3HiWvxC9wVdxJ9d3Cr1SBgMG7wRKHYKbATopG1aIsKgfa8w19ibue9TFTPDOd3I9kta9R1hA2O905SMHMU9x2uFtmLHoxF4Enlaga/R1LwnK5X9+jVdD1EYHm0f9pEevdOGNos36ao4vhPtIFtnIp8VC3Ile0rylXBUTW3kORmYu2JXi8ncTov7lWAtkento3UJwhKYr4pH/H68xJ/CSNp8djCbPo2wMpX7B4TKH/7RgJQsWrV82RQ0OG1uYwQ0VNcU22bJX5VyUe4q7VgV7A7olYYSkX6RgqL1c0V6lgoGQCqDBttj5bRj4D7SH5hDaL6NMtxAzYu0c35r9vr+hEzv/OL3xmdI4Oz+B/QG5T944sY3BP+HSEbIa42zXIxhVDz+I5wDexUQ0nt9MPunnRJQsGiRxsT0BZpzzVkvbN4q4YSvgyXB6jlNUTxuDjZaCILp+K73FbkPk0ksT1oY7yY4X03UeU3HYvdrl27ARmuCuZ5jSwXdeM1fj4sumI1TBzibkRzuIPJSPUFAY+SvSCaRKcFOdMAl/JKlYbu95SS7vcQJkpujKBdB7QvuoWwR0RzoV5tbH+xD5+l5LOG899yH1PWwykRVEU9jHofI7RKgFwtZRKw2891RwutPUUT/nbhfMSEZPhWbj1VJk6dEAmYOdGpOtOlUXAkomP8MCx+5plmircHOtyHTBa7Z9mn8llAuEFPDs9Doe3B9J9/52u/sK2cvQeDq6wiQEaH2tQto+Pf5wHQ7n+y0QRm5AYAIYh2miKT60YoTrCWK9k2OTTgLePt10U8S2SVFou1mu45BDAKSOdOpCgV53ul7RayexMnr49bYjEx6/MP+t/kgOzGMOEfEgklQAgqHttJxQRhQvOiGm7N9ooXonX6FgkTUOxO6NJXgoj/cD7GY/baGjdBcZw4GiGhff4oKhtS9ngPfLxwYQIjOlPs84YHbY3f7U/a8vZ961C2PrLZBMTV0yLGhPbiIO/AT9nH2d4ceWm4dTDe4P+A/vK8kJLQ/a0sGmBkh7a/diQemTP8B439BPzhuDWi1b1zJ3Zbt46lFEBOqWeq9qxfe8BuORgQLXA5WnEyIuHJ3GL0y+cR239qENiCPMJkB64hxxpxfyNz911YNAUMT74fIczqaYCFm/JRtb4jaoD+YFd57ySgiU1tEBmEETvjFuLKXR9YVbRyNg8hr/Ke4FJYHHtY4Jew3wMQEG2EuGBGNdKXMILhpbjfuX1+WTw8t34KYeE0Mzd9UTI6eEhxEa34qF+rnkEKzoYJiL+0paAeNxY490Q//Dq9oLm50V1A7Gj1yqG1YZe6i3opHtFgC1GNuT519VX19VSGY4WvjACjU3mH4whNzIvlJDoW3SyP9IQWFxiMzVpVfyIYuXwDWMU0LcWsJnjij1HYk8XhnvnazOUBgUaKmtpxlC8oXTbod5owl20BItLHIH74uaJbAW0WhGrfoXjzktXnHBrFZApwWlefhHr91pLSurxaaleEldjez/dFK4N6bMf80U1a9lC4W7vuyz0Hb9A9U7daktorpLtT3HftN/ciwy2CrysTcHBikQbTY4ArnznzUbEvbszYSnl/pilGXKCY0vbnVxgLUNUZGskhjO7JgzYsJuDzTWzdAwT0mQWB98lkYlixcgz/hrcQIRVpqLeLCIIH5PiDfVNsWqSpXuz0BNTJCbnZXSVhFNxCWUqloeVwfHX6wb5V9dv2I22a8r4coCKhBlFmeuXVEs98vxD1V/M5mOjbj9QDZLmoEJY5NQ5kM7E5cESahTAJQwPxXswiaZ159/N0SqeQ5yxpV/4EoNAWBZ0QvfwxOYYmCcj2SFtbPHBCe0zLTYie5PdnzSoz6c52CfY7K5TrRq0j0amr9QptDm1gWmgR+1R7A01KXqTEA6RT9AmbPu130DTy6VdO4UAOdDZC6tFGVGR5mm9AV31ORE8PTB4bt5c+iCh6PVNpXGhFTq9PwdydeS0bafRoo+OQOdPMD9CjYlwyR98hGOVQojQ3VQhUGVZRIz05bSl0a9V4Djm+D+xlS3lBWuqMuHG3gBZmBHg89c0RGhPrEKM007XMdLFVoriSUZHgzqsc2HNLXUaYBNsvtywqrGmMMp0HyQGpnlA89wdhfsIS+sPIQwD+eDaqOg/CTuBVwNST7aRTRvGrlBB8iGLnjN3vUS1zjmsDZ/H3VzMIfQIKH8vwKkkBZe/Hd46c5SxVwZrMKFQQZbRu94tYomCWMsAOyPsnuhOYm56gWOe/6VtYRYQRWx8KpCOgXvCy9vG1Y4xDUnmx1KvHTm7rEiREEgB/kerildrX8fModiFW75SqDbyoS8b3Afh715WnO4kr9+hfaV2sIuG1p31M85RVhm1eU14T1sNPxnZzO4YiDW0oX2jQ4fSkEByQDzCnCDRFSZoFYpAtqks4VawzcTZEUR1Klloj0Ri38oTlHhjRrGlAO0tQq4R9ViV8nc+f3i/rQ+LqGJMJtYcQ97MKCacf+0DzeoVQwkaaHZLuSX9lx5qIq+fKh4FT+WlzVtR+70dDnGQ2OoNbih+JjSp7SwvdiCu8+KmKYXGWl6Z9BVR5dl17ud3AA/2VvJV33A3sFda3TuI8X0g3+AsK1juUeFMjv1Mp4Y1zpspD8FvcaYhWcyVYNsUzYDknR6TPSo6I3woGMfmyI41e+zP435H3qnGML3D3OaIjha7q7kHqZov0AGel/35P4dBjxe9W3j9mJKpu2ipMF5H8fg8c1PGeavSH3zdjC1tUFPh3jErJAhS3IG+rvKmlp6VH73XFho8wLgJ/9BLMG46WG9sAHGnKUbXd9GEHUwW1yDw59GlrA3RsB5JZ9q2KllCM3vqC4CUUUPpZHD+FluynJ9zoQ var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"2020","slug":"2020","permalink":"http://yoursite.com/tags/2020/"},{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"react中的事件绑定","slug":"react中的事件绑定","date":"2019-12-22T08:39:36.000Z","updated":"2019-12-22T09:51:52.269Z","comments":true,"path":"2019/12/22/react中的事件绑定/","link":"","permalink":"http://yoursite.com/2019/12/22/react%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/","excerpt":"","text":"遇到的问题最近想试一下React，之前一直用Vue在写东西。稍微看了几篇教程后，就开始写，能够基本运行起来，可能是因为项目比较简单吧。但是也遇到了几个问题，首先就是React的事件绑定问题： 我第一次的写法是： 12345handleEvent()&#123; console.log(\"test\")&#125;&lt;Button onClick=\"handleEvent\"&gt; &lt;/Button&gt; 这样普通的点击事件是能够正常触发的。 this的指向问题但是当我要使用this时，这种写法就出了问题。 1234567handleEvent()&#123; this.setState(&#123; state1 : 111 &#125;)&#125;&lt;Button onClick=\"handleEvent\"&gt; &lt;/Button&gt; 这样就会报错this为undefined的。于是我就想起了之前看过的文章以及结合之前对JavaScript的函数的this分析。就明白此时函数在调用时不是被react对象直接调用的。所以该函数的this的指向为undefined。所以要想使用react对象的方法，只有将函数的this指向为react。根据之前文章对this的分析，要想绑定this，可以使用： call（一次绑定并调用） apply （一次绑定并调用） bind（永久绑定） 箭头函数 () =&gt; {}永久绑定 但是事件是要多次调用并且不是绑定时就调用，而是事件被触发时才调用，所以排除call与apply方法。所以选择bind与箭头函数为最佳(后来看官方文档时发现官方也是推荐了这两种方法来绑定this)。 所以有以下方法： 在构造函数中绑定函数的this指向 12345678910constructor(props)&#123; super(props) this.handleEvent = this.handleEvent.bind(this)&#125;handleEvent()&#123; console.log(this) //此时指向react对象&#125;&lt;Button onClick=&#123;handleEvent&#125;&gt;&lt;/Button&gt; 在事件绑定时绑定函数this 12345handleEvent()&#123; console.log(this) //此时指向react对象&#125;&lt;Button onClick=&#123;this.handleEvent.bind(this)&#125;&gt;&lt;/Button&gt; 至此，this的指向问题基本解决。 函数传参的问题接下来遇到需要传参的函数。我使用了与Vue与原始HTML同样的写法 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;this.handleEvent(\"123\")&#125;&gt;&lt;/Button&gt; 当我尝试触发事件时，发现事件触发不成功，并且在打开控制面板时发现在页面初始化时，该事件被自动触发了3次，点击按钮无法触发。于是我不禁思考JSX的语法，让我想到了EL表达式，EL表达式中的代码会被直接运行，该位置会被填充为运行后的结果。再来看这个问题就发现自己的问题了。 {}内的代码在JSX模板编译时被当成代码直接运行，而tihs.handleEvent(&quot;123&quot;)在JavaScript中不就是直接运行函数吗，所以函数在模板编译时直接被运行了，而onClick的事件则被绑定为函数的返回值，但是这个函数没有返回值，所以事件绑定失败。 所以如何解决这个问题就很简单了，只要在事件绑定的位置放置一个函数而不是函数的调用就行了,方法也有两个： bind方法传参 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;this.handleEvent.bind(this,\"123\")&#125;&gt;&lt;/Button&gt; 箭头函数 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;() =&gt; &#123;this.handleEvent(123)&#125;&#125;&gt;&lt;/Button&gt; 折腾一下在看到箭头函数时我又思考能不能不用箭头函数，直接用匿名函数实现函数的调用。像这样： 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;function(para)&#123;this.handleEvent(para)&#125;&#125;&gt;&lt;/Button&gt; 再一想发现好想更不行，匿名函数没有绑定this指向。所以也就拿不到this.handleEvent()函数了。那就试试绑定一下匿名函数的this指向，像这样： 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;function()&#123;this.handleEvent(123)&#125;.bind(this)&#125;&gt;&lt;/Button&gt; OK，事件成功绑定，但是转念一想，这么搞还不如直接bind原函数，也避开了使用箭头函数。纯属折腾吧。 获取事件对象event在Vue或者原生HTML中，event被存储在window下的event对象中，在绑定事件时将event对象传入即可获得点击事件对象。 但在React中，我们可以这么做： 当我们不需要为这个函数传参时，event对象会自动传入该函数，我们通过第一个参数获取event对象 当我们需要传参时，我们需要手动传入event对象 12345678handleEvent = (para,e) =&gt; &#123; console.log(para) console.log(e)&#125;&lt;Button onClick=&#123;(e) =&gt; &#123;this.handleEvent(123,e)&#125;&#125;&gt;&lt;/Button&gt;//或者这样&lt;Button onClick=&#123;this.handleEvent(123,e)&#125;&gt;&lt;/Button&gt; Last至此，React中的函数事件绑定基本可以搞定。写了一段时间的React，感觉相较于Vue，更灵活。刚入手的话，习惯了Vue模板文件的 &lt;template&gt; &lt;style&gt; &lt;script&gt;这种分明的设计，React中的JSX写起来感觉有点复杂。在对比anted与elemenui，感觉elementui的api简直太简单了。后期在多体验看看吧！","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"事件绑定","slug":"事件绑定","permalink":"http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"}]},{"title":"CSS伪类与伪元素","slug":"CSS伪类与伪元素","date":"2019-11-20T14:54:39.000Z","updated":"2019-11-21T07:06:34.306Z","comments":true,"path":"2019/11/20/CSS伪类与伪元素/","link":"","permalink":"http://yoursite.com/2019/11/20/CSS%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0/","excerpt":"","text":"伪类？伪元素？之前一度认为伪类就是一组选择器，伪元素是不在DOM树的中的一些元素。但是当我看完MDN上的所有伪类与伪元素之后，才发现伪类与伪元素同属于CSS选择器的范畴，而伪元素其特殊之处在于伪元素可以选择的是一些不在DOM树中的元素，比如::selection用于选中用户用鼠标勾选的字符串；当然也可以选择在DOM树中的元素，比如::first-line用于选中元素的第一行，在特殊一点说，伪元素多用于选择一些特殊的东西，而伪类用于元素级别的选择，比如:nth:child用于选择某元素的第n个 由上面可以看出基本看做：元素级别的选择器用伪类，元素内的选择器与特殊选择器用伪元素 实际上最好的方法就是记住伪类与伪元素主要有哪些、特别是伪元素并不多。 伪类状态伪类 选择器 示例 说明 :link a:link 选择所有未访问的链接 :visited a:visited 选择所有访问过的链接 :hover a:hover 鼠标悬浮在链接上的状态 :active a:active 选择在激活状态的链接 :focus input:focus 选择获取焦点的输入框元素 :focus-within form:focus-within 用在父级元素上，当子元素获得焦点时，父元素获得对应属性(IE未实现) 结构化伪类 选择器 示例 示例说明 :first-child :first-child 选择p元素的第一个子元素 :first-of-type p:first-of-type 选择每个父元素是p元素的第一个p子元素 :last-child p:last-child 选择所有p元素的最后一个子元素 :last-of-type p:last-of-type 选择每个p元素是其母元素的最后一个p元素 :not(selector) :not§ 选择所有p以外的元素 :nth-child(n) p:nth-child(2) 选择所有p元素的第二个子元素 :nth-last-child(n) p:nth-last-child(2) 选择所有p元素倒数的第二个子元素 :nth-last-of-type(n) p:nth-last-of-type(2) 选择所有p元素倒数的第二个为p的子元素 :nth-of-type(n) p:nth-of-type(2) 选择所有p元素第二个为p的子元素 :only-of-type p:only-of-type 选择所有仅有一个子元素为p的元素 :only-child p:only-child 选择所有仅有一个子元素的p元素 :target #news:target 选择当前活动#news元素(点击URL包含锚的名字) 表单伪类 选择器 示例 示例说明 :disabled input:disabled 选择所有禁用的表单元素 :enabled input:enabled 选择没有设置 disabled 属性的表单元素 :required input:required 选择设置 required 属性的表单元素 :read-only input:read-only 选择设置 readonly 只读属性的元素 :read-write input:read-write 选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。 :checked input:checked 匹配被选中的 input 元素，input 元素包括 radio 和 checkbox :empty p:empty 匹配所有没有子元素的 p 元素 :in-range input:in-range 选择在指定区域内的元素 :out-of-range input:out-of-range 选择不在指定区域内的元素 :valid input:valid 选择条件验证正确的表单元素 :invalid input:invalid 选择条件验证错误的表单元素 :optional input:optional 选择没有 required 属性，即设置 optional 属性的表单元素 :default - 匹配默认选中的元素(提交按钮总是表单的默认按钮)。 :indeterminate - 当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。 :scope - 匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。(试验阶段) 伪元素单双冒号 选择器 作用 说明 ::before/:before 在被选元素前插入内容。 需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。 ::after/:after 在选被元素后插入内容 其用法和特性与:before相似。 ::first-letter/:first-letter 匹配元素中文本的首字母。 被修饰的首字母不在文档树中。 ::first-line/:first-line 匹配元素中第一行的文本。 这个伪元素只能用在块元素中，不能用在内联元素中。 双冒号 选择器 作用 说明 ::selection 匹配被用户选中或者处于高亮状态的部分. 在火狐浏览器使用时需要添加 -moz 前缀。 ::placeholder 匹配占位符的文本。 只有元素设置了 placeholder 属性时，该伪元素才能生效。 LAST对于伪类与伪元素，最好的不是区分它们，而是记住常用的选择器是属于伪类还是伪元素。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"伪元素","slug":"伪元素","permalink":"http://yoursite.com/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"},{"name":"伪类","slug":"伪类","permalink":"http://yoursite.com/tags/%E4%BC%AA%E7%B1%BB/"}]},{"title":"CSS3过渡与动画","slug":"CSS3过渡与动画","date":"2019-11-18T13:13:17.000Z","updated":"2019-11-19T01:23:21.050Z","comments":true,"path":"2019/11/18/CSS3过渡与动画/","link":"","permalink":"http://yoursite.com/2019/11/18/CSS3%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/","excerpt":"","text":"CSS3-过渡 CSS3中，我们为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript。 使用transition属性，CSS3会自动为属性的变化来添加过渡样式。这个属性一般可以用在:hoevr :active等伪元素切换。 transition也是一个复合属性： 1234tag&#123; transition:transition-property ransition-duration transition-timing-function transition-delay; &#125; 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 transition-property该属性用于定义需要渐变的CSS属性，比如color width等。 可选值 描述 none 没有过渡动画。 all 所有可被动画的属性都表现出过渡动画。 IDENT 性名称。由小写字母 a 到 z，数字 0 到 9，下划线（_）和破折号（-）。第一个非破折号字符不能是数字。同时，不能以两个破折号开头。 transition-duration该属性定义渐变的时间，要带单位（s,ms）。 transition-timing-function这个属性是过渡的核心。引用MDN官方的描述： CSS属性受到 transition effect的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变。 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 step-start 直接跳到结束处 step-end transition-duration steps() 步进函数将过渡时间分成大小相等的时间时隔来运行没有过度效果，而是一帧一帧的变化，integer等于几就分成几帧，阶跃函数 steps()函数steps(&lt;integer&gt;[,start| end]?) :用于指定间隔个数（该值只能是正整数） 第二个参数可选，默认是end,表示开始值保持一次，若参数为start，表示开始值不保持 end:用于指定在step中间隔数少于该有的变化次数时，因该丢弃前面的部分还是后面的部分。 123456789即每个关键帧都分成两次变化完成，则一共有七次变化。七帧 一共变化七次， div本身没有颜色，所以最终的背景无色。但是，只变化七次，有七种颜色，加上无色，一种八种状态，所以需要丢弃一种状态start 橙、黄、灰、蓝、深灰蓝、绿、无色 原理：去掉第一帧的效果，end 红、橙、黄、灰、蓝、深灰蓝、无色原理：去掉最后一帧的效果 cubic-bezier(n,n,n,n)贝塞尔曲线函数的四个值，具体原理后面研究一下再写一篇博客。 transition-delay CSS的transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 下面写个例子 12345678910div&#123; width:120px; color:red; transition:all 0.5s ease 1s; &#125;div:hover&#123; width:200px; color:blue;&#125; 这段代码设定在鼠标划过时，所有的属性在1s后开始过渡，过渡时间为0.5s，过渡方式为ease。 CSS动画CSS3中，我们可以用2个属性来定义函数。 @keyframes animation 利用这两个属性可以制作简单或复杂的CSS东阿虎 @keyframes @keyframes 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。这比转换更能控制动画序列的中间步骤。 Point： 如果一个关键帧规则没有指定动画的开始或结束状态（也就是，0%/from 和100%/to，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。 如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 如果多个关键帧使用同一个名称，以最后一次定义的为准。 @keyframes 不存在层叠样式(cascade)的情况，所以动画在一个时刻（阶段）只会使用一个的关键帧的数据。 如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 因为@keyframes 的规则不存在层叠样式(cascade)的情况，即使多个关键帧设置相同的百分值也不会全部执行。 如果某一个关键帧出现了重复的定义，且重复的关键帧中的css属性值不同，以最后一次定义的属性为准。例如： 123456@keyframes identifier &#123; 0% &#123; top: 0; left: 0px&#125; 50% &#123; top: 30px; left: 20px; &#125; 50% &#123; top: 10px; &#125; 100% &#123; top: 0; left: 30px;&#125;&#125; 上面这个例子中，50% 关键帧中设置的属性top: 10px是有效的，但是其他的属性会被忽略 关键帧中出现的 !important 关键词将会被忽略 @keyframes格式如下： @keyframes 动画名字 { ​ 阶段名:{ ​ 元素属性 ​ } } 其中阶段名可以百分比或者from/to example: 1234567@keyframes mykeyframes&#123;0% &#123;background:red;&#125;25% &#123;background:yellow;&#125;50% &#123;background:blue;&#125;100% &#123;background:green;&#125;&#125; 这样就新建了一个动画关键帧，现在我们就需要使用animation将其添加到对应的元素上。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"过渡","slug":"过渡","permalink":"http://yoursite.com/tags/%E8%BF%87%E6%B8%A1/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"函数的防抖与节流以及一些重要的函数模式","slug":"函数的防抖与节流以及一些重要的函数模式","date":"2019-11-17T12:25:01.000Z","updated":"2021-03-09T13:06:47.277Z","comments":true,"path":"2019/11/17/函数的防抖与节流以及一些重要的函数模式/","link":"","permalink":"http://yoursite.com/2019/11/17/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"防抖（debounce）在学习单片机开发时，按键防抖非常重要，我们必须使用一定的方法来进行防抖，否则会造成一次按键按键的多次触发的情况。而在JavaScript中，同样会有这样的问题，即在用户进行持续性的操作时，在用户大概率完成后，在进行后续操作（请求服务器，浏览器渲染等）。如果不进行防抖操作，会导致服务器或浏览器的性能浪费。 其具体定义：在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后： - 如果在一段时间内没有再次触发滚动事件，那么就执行函数 - 如果在一段时间内再次触发滚动事件，那么当前的计时取消，重新开始计时 下面是一个函数实现： 123456789101112function debounce(fun, delay) &#123; let timer return function (arguments) &#123; //获取函数的作用域和变量 let that = this; let args = arguments; clearTimeout(timer) // 清除定时器 timer = setTimeout(function () &#123; fun.apply(that, args) &#125;, delay) &#125;&#125; 该函数接受一个目标函数与延迟，该函数内部返回了一个函数，并将目标函数的id设为定时器的id。如果第一次调用该函数，会设置一个定时器，设定在delay毫秒后执行目标函数，但是如果在delay毫秒时间内再次调用该函数的防抖函数，那么就会清除掉目标函数的定时器，也就不会执行了。并再次设置一个定时器，循环以上步骤。 节流（Throttle）节流更是一个重要的概念，特别是在进行渲染的操作时（比如，mousemove，scoll），如果不进行节流，那么浏览器将会消耗很多性能，致使页面卡顿与操作不流畅。 具体定义：是指在一定的时间内只允许函数执行特定次数。 123456789101112131415161718192021function throttle(fn,delay)&#123; let _self = fn, timer, firstTime = true; return function()&#123; let args = arguments _this = this if(firstTime)&#123; _self.apply(_this, args) return firstTime = false &#125; if(timer)&#123; return false &#125; timer = setTimeout(function()&#123; clearTimeout(timer) timer = null _self.apply(_this, args) &#125;, delay||500) &#125;&#125; 该函数的核心是在：在外部先判断目标函数fun的timer属性是否为空。如果为空，则代表一次函数还未执行完，则直接返回。否则则设定目标函数的timer属性为一个定时器，在定时器的函数中将timer清空，并执行目标函数。 2021/2/17最近在读《JavaScript设计模式与开发实践》，发现除了函数的节流与防抖，还有一些高级函数模式，可以用来解决一些问题。 分时函数当一个任务需要进行大量同类操作，此时可能会造成页面的卡顿。此时，为了防止页面卡顿，我们要把单个大型任务分割成为多个小的任务，典型的场景是：大量数据插入表格。 我们把但分时函数代码如下： 12345678910111213141516171819let timeChunk = function(ary, fn, count)&#123; let obj let t let len = ary.length let start = function()&#123; for(let i = 0; i &lt; Math.min(count || 1, ary.length); i++)&#123; let obj = ary.shift() fn(obj) &#125; &#125; return function()&#123; t = setInterval(function()&#123; if(ary.length === 0)&#123; return clearInterval(t) &#125; start() &#125;, 200) &#125;&#125; 比如我们需要添加1000调信息到页面中，我们采用每次创建8个节点。 123456789101112let ary = []for(let i = 1; i &lt;= 1000; i++)&#123; ary.push(i)&#125;let renserList = timeChunk(ary, function(n)&#123; let div = document.createElement('div') dic.innerHTML = n document.body.appenChild(div)&#125;, 8)renderList() 惰性加载函数当一个任务在执行之前后悔事先执行一些预先性工作，并且这些工作在每次执行时的结果都是一样的，那我们可以在第一次得到结果后就将其凝固，在以后的每一次执行时就可以减少判断次数，提高性能。 一个典型的场景就是浏览器能力检测，常见的写法如： 12345678let addEvent = function(elem, type, handler)&#123; if(window.addEventListener)&#123; return elem.addEventListener(type, handler, false) &#125; if(window.attachEvent)&#123; return elem.attachEvent('on' + type, handler) &#125;&#125; 这个函数的缺点是，当它每次被调用的时候都会执行里面的if条件分支，虽然执行这些if分支的开销不算大，但也许有一些方法可以让程序避免这些重复的执行条件。如下面的方案就是在最开始调用一次判断，后续调用该函数时，就不会再进行判断了： 123456789101112let addEvent = (function()&#123; if(window.addEventListener)&#123; return function(elem, type, handler)&#123; elem.addEventListener(type, handler, false) &#125; &#125; if(window.attachEvent)&#123; return function(elem, type, handler)&#123; return elem.attachEvent('on' + type, handler) &#125; &#125;&#125;)() 第三种方案就是我们的懒加载函数，代码如下： 123456789101112let addEvent = function(elem, type, handler)&#123; if(window.addEventListener)&#123; addEvent = function(elem, type, handler)&#123; elem.addEventListener(type, handler, false) &#125; &#125;else if(window.attachEvent)&#123; addEvent = function(elem, type, handler)&#123; elem.attachEvent('on'+type, handler) &#125; &#125; addEvent(elem, type, handler)&#125; 这个函数在第一次调用时，会根据条件分支，对addEvent事件进行重载，并且对其进行调用一次。这个函数不必判断第一次，而是自动在第一次时重载，很妙。 这里有一个知识点是，在具名函数的执行过程中是可以对具名函数进行重新赋值的。 summary总体来说，在进行某些操作时，比如表单实时验证或者绘图的操作等，函数的防抖与节流会大幅度节省服务器与浏览器的性能！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"防抖","slug":"防抖","permalink":"http://yoursite.com/tags/%E9%98%B2%E6%8A%96/"},{"name":"节流","slug":"节流","permalink":"http://yoursite.com/tags/%E8%8A%82%E6%B5%81/"}]},{"title":"Vue中局部修改组件样式","slug":"Vue中局部修改组件样式","date":"2019-11-17T11:52:19.000Z","updated":"2019-11-17T12:18:40.077Z","comments":true,"path":"2019/11/17/Vue中局部修改组件样式/","link":"","permalink":"http://yoursite.com/2019/11/17/Vue%E4%B8%AD%E5%B1%80%E9%83%A8%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"Vue如何修改子组件样式在使用element-ui或者i-view这些第三方样式库时，我们有时会想只在某一个组件中局部修改库中的样式而部影响全局样式。 首先我们需要打开控制器找到对应组件的CSS样式的类名或者id 有以下几种方式 不在style样式上添加scope属性&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;el-input&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .father el-input{ color:red; } &lt;/style&gt; 这样相当于只修改father类下的el-input的属性。 使用 &gt;&gt;&gt; 穿透scope的用处scoped是Vue里面style标签的一个特殊属性，当一个style标签拥有scoped属性的时候，就相当于说明它里面的样式只作用于当前这个Vue页面，不会污染到全局的样式，从而实现了组件样式的模块化，那么它是怎么实现的呢？其实如果我们给style标签加上了scoped属性，在编译的时候，他会给我们组件里面的每一个样式加一个自定义的属性data-v-5558821a,从而通过给含有这个自定义属性的标签加上样式，从而实现了部分样式的穿透。 &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;el-input&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; .father &gt;&gt;&gt; el-input{ color:red; } &lt;/style&gt; 如果使用的是less或者sass可以将 &gt;&gt;&gt; 换为 /deep/ &lt;style scoped&gt; .father /deep/ el-input{ color:red; } &lt;/style&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"CSS3-转换","slug":"CSS3-转换","date":"2019-11-05T01:23:39.000Z","updated":"2019-11-08T09:18:21.422Z","comments":true,"path":"2019/11/05/CSS3-转换/","link":"","permalink":"http://yoursite.com/2019/11/05/CSS3-%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"CSS3中的转换CSS3中的转换可以形成简单的动画，对于页面的小优化有点金的效果。 CSS3中的转换都在transform属性中定义，在该属性中定义其他函数来进行不同的转换。 CSS3的2D转换translate()该函数接受两个参数，分别是其x，y轴的偏移量，右下为正方向。 transform:translate(50px,100px); 将原元素向右、下移动50px、100px。 如果只填一个参数，则默认为x轴偏移。 transform:translate(50px); 向x轴移动50px; transform:translate(0,100px); 向y轴移动100px； rotate()该函数接受一个参数，确定偏移的角度，正值为顺时针，负值即为逆时针。 transform: rotate(30deg);//顺时针30度 transform: rotate(-30deg);//逆时针30度 scale()该函数接受两个参数，分别为x轴的倍数，y轴的倍数。 scale(2,3); 将容器宽度放大2倍，高度放大3倍。 skew()通过 skew() 方法，元素将偏斜相应的角度，注意这个偏斜与rotate(旋转)不同，skew将会绕x,y轴偏斜x,y度，观察到的肉眼的形状会改变！比如只偏斜某一轴，则原元素会变成一个平行四边形。(与其他转换一样，其内容也会做对应的变换) transform: skew(30deg); transform: skew(0deg,30deg); transform: skew(30deg,30deg); matrix()matrix() 方法把所有 2D 转换方法组合在一起。默认值为：transforms:matrix(1,0,0,1,0,0); matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 matrix原意是矩阵，所以这六个参数分别是矩阵的6个位置的值： matrix(a,b,c,d,e,f) 也就是利用这个矩阵与原容器做运算后获得新位置。 所以我们运算过后的结果就是： x’=ax+cy+e y’=bx+dy+f 移动所以根据这个式子，我们可以推算如果要对元素进行x轴移动，则x’直接增大固定数值，即改变e的值： 向x轴移动10px，y不变 matrix(1,0,0,1,10,0) 向x,y轴都移动10px matrix(1,0,0,1,10,10) 缩放缩放的实质就是奖x，y轴的数值放大n倍，即： x’=2y y’=2x 对于上面的： x’=ax+cy+e y’=bx+dy+f 可得到： nx = ax+cy+e ny = bx+dy+f 易得： a = nb = 0c = 0d = ne = 0f = 0 即，进行缩放的话，我们只需要修改a,d的值以修改宽,高的缩放程度 旋转利用极坐标，我们可以算出偏移角度与元素某点的坐标的关系。 根据原理图得： 推算可以得到： 所以，我们得： a = cosθ b = -sinθ d = sinθ e = cosθ 所以改变abde，即可实现旋转。 偏移同样由数学知识 即： b = tanθxe = tanθy 所以，skew操作只与b、e相关。 不过如果不是利用CSS3来做一些复杂的变换，可以用这种方式来减少代码。否则最好不要使用这个函数，因为它可能会使你的调试复杂困难。 transform-origin()该属性确定转换的基点位置。 example: transform-origin:20px 20px; 规定变换的基点为：(x=)20px (y=)20px 其值可以为： left center right length % CSS3的3D转换我们在2D之中，我们看过“translate，scale，rotate”这三个变换属性。在3D变换中，这三个属性被拆分3个方向的分属性： translate() translateX() translateY() translateZ() scale() scaleX() scaleY() scaleZ() ratate() rotateX() rotateY() rotateZ() 每个方向上的分量分别是沿某一轴变换。比如：translateX(120)表示沿X轴正方向移动120px。 另外3D还有几个属性： transform-styleCSS 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。 flat 设置元素的子元素位于该元素的平面中。 preserve-3d 指示元素的子元素应位于 3D 空间中。 perspective-originperspective-origin属性也可以有3参数方式，第三个值为Z值。 backface-visibilitybackface-visibility 属性定义当元素不面向屏幕时是否可见。 perspective&amp;&amp;perspective-originperspective 属性定义 3D 元素距视图的距离，以像素计。(类似于AE相机中的属性值)。 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 元素添加perspective属性后，可再添加perspec-origin控制观察位置(类似与AE中的相机的x,y位置)。 注释：perspective 属性只影响 3D 转换元素。 .father{ width:400px; height:400px; perspective:120px; perspective-origin:10px 10px; background-color:blue; margin: 60px; } .son{ margin:60px ; width:120px; height:120px; background-color:gray; transform: rotateX(30deg); } 我们观察当perspective-origin值与perspective值改变时，元素发生的变化。 可以明显看出，当perspective值改变的时候，相当于我们视觉的位置与元素的距离发生了改变。而当perspective-origin发生改变的时候，我们是视觉的x，y位置发生了改变，所以我们看到元素的形状及其位置发生了改变。 LastCSS3中的3D变换算是一门学问，下一章解析过渡的时候一起再解析一下，让自己多理解一下。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"transform","slug":"transform","permalink":"http://yoursite.com/tags/transform/"},{"name":"translate()","slug":"translate","permalink":"http://yoursite.com/tags/translate/"},{"name":"scale()","slug":"scale","permalink":"http://yoursite.com/tags/scale/"},{"name":"rotate()","slug":"rotate","permalink":"http://yoursite.com/tags/rotate/"},{"name":"skew()","slug":"skew","permalink":"http://yoursite.com/tags/skew/"},{"name":"matrix","slug":"matrix","permalink":"http://yoursite.com/tags/matrix/"}]},{"title":"CSS3-文本效果和字体","slug":"CSS3-文本效果和字体","date":"2019-11-04T07:26:39.000Z","updated":"2019-11-05T11:49:18.718Z","comments":true,"path":"2019/11/04/CSS3-文本效果和字体/","link":"","permalink":"http://yoursite.com/2019/11/04/CSS3-%E6%96%87%E6%9C%AC%E6%95%88%E6%9E%9C%E5%92%8C%E5%AD%97%E4%BD%93/","excerpt":"","text":"CSS3中的文字效果及字体CSS3本来规定了较多的文字属性，但是大部分没有被实现，所以只介绍已经被实现的属性。 text-shadowtext-shadow用于创建一个文字阴影，其参数如下： 参数 说明 &lt;offset-x&gt; x轴的偏移量 &lt;offset-y&gt; y轴的偏移量 &lt;blur-radius&gt; 模糊半径 example1: text-shadow: 5px 5px 5px #FF0000; text-shadow案例利用text-shdow的叠加，可以实现多种文字特效： 火焰文字效果关键：在文字外层加上多层黄色，红色的阴影，并且模糊程度越来越大，颜色的掌控很关键。否则可能不会很逼真。 background:black; text-align:left; text-shadow: 0 -5px 4px #FF3,2px -10px 6px #fd3,-2px -15px 11px #f80,2px -25px 18px #f20; color:red; 立体凸起效果关键：将背景颜色与温习颜色设为一致，再设置一个白色的阴影，一个黑色的阴影，x轴分别偏移-1px，1px即可达到效果。 text-shadow: -1px -1px white,1px 1px #333; color:#D1D1D1; font-weight: bold; background: #CCC; 立体凹下效果关键：与凸起相似，但是将两个偏移量交换一下，即可实现凹下效果。 text-shadow: 1px 1px white,-1px -1px #333; color:#D1D1D1; font-weight: bold; background: #CCC; 描边效果关键：设置4个黑色的阴影，模糊度为0，分别向上下左右各偏移1px，即可实现描边效果。 text-shadow: -1px 0 black,0 1px black,1px 0 black,0 -1px black; color:#ffffff; background: #CCC; 外发光效果关键：不要为阴影设置x，y的偏移量，增大模糊度，即可实现。 text-shadow: 0 0 0.2em #F87,0 0 0.2em #f87; color:#d1d1d1; background: #CCC; 3D效果关键：在同一方向上多次叠加颜色更深的阴影。 color:white; font-size: 200px; text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px 10px black; 关于text-shadow对于各种文字效果，如果我们认真分析文字附加效果的颜色及光影效果，我们可以利用text-shadow模拟出很多的文字效果。 word-wrap/overflow-wrapword-wrap又叫做overflow-wrap： word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”。 稳定的谷歌 Chrome 和 Opera 浏览器版本支持这种新语法。 该属性含有一个参数，其可以有以下值： 值 说明 normal 表示在正常的单词结束处换行。 break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 CSS3 @font-face 规则以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。 使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。 当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。 您所选择的字体在新的 CSS3 版本有关于 @font-face 规则描述。 您”自己的”的字体是在 CSS3 @font-face 规则中定义的。 实例： &lt;style&gt; @font-face { font-family: myFirstFont; src: url(sansation_light.woff); } div { font-family:myFirstFont; } &lt;/style&gt; 在font-family中，还可以定义字体的其他属性： 结束通过text-shadow和自定义字体，我们可以实现多种我们想要的字体效果了！结合上一章的背景，网页肯定能换发生机！","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"text-shadow","slug":"text-shadow","permalink":"http://yoursite.com/tags/text-shadow/"},{"name":"word-wrap","slug":"word-wrap","permalink":"http://yoursite.com/tags/word-wrap/"},{"name":"overflow-wrap","slug":"overflow-wrap","permalink":"http://yoursite.com/tags/overflow-wrap/"},{"name":"font-face","slug":"font-face","permalink":"http://yoursite.com/tags/font-face/"}]},{"title":"CSS3-背景","slug":"CSS3-背景","date":"2019-10-29T01:48:59.000Z","updated":"2019-11-01T10:23:17.505Z","comments":true,"path":"2019/10/29/CSS3-背景/","link":"","permalink":"http://yoursite.com/2019/10/29/CSS3-%E8%83%8C%E6%99%AF/","excerpt":"","text":"backgroundCSS中，background是一个符合属性，是以下单属性的符合属性： background-color background-position background-size background-repeat background-origin background-clip background-attachment background-image 其格式如下 background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; background-colorbackground-color属性设置一个元素的背景颜色。 元素的背景是元素的总大小，包括填充和边界（但不包括边框）。 example: background-color:yellow; 其属性支持以下内容： 颜色关键值，如：red,blue… Hex颜色值，如：#bbff00… Hex含透明颜色值，如：#ffbb0036;（最后两位表示透明度，ff则为不透明，可省略，则变为普通Hex） RGB颜色值，如：rgb(255,255,255) RGBA颜色值，RGB可透明的颜色值，如：rgba(55,56,125,0.5)，透明度为0.5 特殊值： currentColor：该值是CSS3新增的一个颜色关键字，等会详细介绍。 transparent：透明背景 全局变量： inherit：继承上一级的背景颜色。（注意，该值可用于所有的CSS属性） initial：设置背景色的为默认值（每一个CSS属性都有一个默认值，有些为none，则设置没有效果），此属性可用于清除父级的继承属性。如p标签中的span标签的文字颜色继承问题。 unset：如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。换句话说这个unset关键字会优先用 inherit 的样式，其次会应该用initial的样式。 currentColor关键字CSS新增了currentColor关键字 currentColor代表了当前元素被应用上的color颜色值。 使用它可以将当前这个颜色值应用到其他属性上，或者嵌套元素的其他属性上。并且该属性会继承上级属性值。 example1: .box{ color:red; background-color:currentColor; //此时currentColor=red; height:100px; width:100px; } exmaple2: .fatherBox{ color:red; } .sonBox{ background-color:currentColor;//此时currentColor继承父级的color属性，为red } background-image其属性有以下内容： url():该函数接受一个地址作为背景图片的url，可以是本地地址，也可以是网络地址。 color值：&lt;rgb()&gt; | &lt;rgba()&gt; | &lt;hsl()&gt; | &lt;hsla()&gt; | &lt;hex-color&gt; | &lt;named-color&gt; | currentcolor | &lt;deprecated-system-color&gt; linear-gradient():该函数用于生成一个线性渐变。 radial-gradient()：该函数用于生成一个径向渐变。 repeating-linear-gradient()：该函数用于生成一个重复的线性渐变 repeating-radial-gradient()：该函数用于生成一个重复的线性渐变。 关键字：inherit(从父级继承) linear-gradient()CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于数据类型，是一种特别的数据类型。 其参数有以下几个： angle：角度，可为以下值： 角度值deg，如45deg，-120deg,方向递增方向为顺时针方向。 角度关键字，如，to left，to bottom right，这些关键字等同于相应的角度，如to top = 0deg，to right = 90deg，to bottom right = 135deg color-stop:结束位置颜色值（渐变开始位置）, 包含颜色及结束位置，如red 30%，blue 50% 只包含颜色值，如red,rgb(123,45,26)，此时每一个颜色会被设置默认的结束位置值，即按颜色均分该区域。如，red blue = red 0%,blue 100% 值得注意的是，每个颜色结束位置之间的距离就是这两个颜色渐变的距离 如： red 0%,blue 100%，那么红色与蓝色在之间的渐变距离即为100% red 0%,blue 50%,brown 100%，那么红色与蓝色之间的渐变距离则为50%，蓝色与棕色之间的渐变距离也为50%。 仔细思考一下会发现，如果两个颜色之间的渐变距离为0，那么他们之间的就不会有渐变，再利用角度的可改变与多次使用该属性，即可实现绘制图形 比如： 条形背景： background: linear-gradient(90deg,rgb(153, 153, 153) 50%,rgb(105, 105, 105) 50%); background-size: 20%; background-repeat: repeat; 切角效果 background: linear-gradient(45deg,red 10%,transparent 10%), linear-gradient(135deg,red 10%,transparent 10%), linear-gradient(-45deg,red 10%,transparent 10%), linear-gradient(-135deg,red 10%,transparent 10%); 折角效果 background:linear-gradient(-135deg,transparent 51%,rgba(0, 0, 0, 0.178)51%) no-repeat 100% 0 / 6em 6em, linear-gradient(-135deg,transparent 10%,rgb(169, 169, 233) 10%); 利用其线性切割+重复性，可以实现多种图案，只要想象力足够，唯一需要考虑的就是性能问题，如果通过其绘制过于复杂的线性动画导致页面性能损失，那也是得不偿失的。 radial-gradient()该函数接受5个属性： 参数 描述 可选值 &lt;size&gt; 整个渐变的尺寸大小，如果设置为circle,则可以在前面通过”100px”，”10%”的格式设置其半径，radius；如果设置为ellipse，则可以在前面通过”100px 200px”,”10% 20%”的格式设置其短半径与长半径的值。 绝对单位数值，如100px。相对单位数值，如20% &lt;extent-keyword&gt; 此关键字的词用于确定渐变最外侧的边与哪个边相切，或与哪个角相距。实际上也是确定半径，所以也可以通过size属性直接设置半径。 见下表 &lt;shape&gt; 渐变的形状。圆形（渐变的形状是一个半径不变的正圆）或椭圆形（轴对称椭圆）。默认值为椭圆。椭圆半径与容器的长宽比例相同。 redius：绝对单位数值，如100px；shape：’circle’,’ellipse’ &lt;position&gt; 渐变圆的圆心位置 一般在前面加上 at 关键字 ， 绝对单位数值，如100px。相对单位数值，如20% &lt;color-stop&gt; 渐变的颜色及其渐变结束位置 color:Hex值，rgb值，rgba值，颜色关键字；stop：绝对单位数值，如100px。相对单位数值，如20% 关键字 常量 描述 常量 描述 closest-side 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 closest-side 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 closest-corner 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 closest-corner 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 farthest-side 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 farthest-side 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 farthest-corner 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 farthest-corner 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 radial-gradient()基本应用example1(自己设置半径)： background-image: radial-gradient(100px 150px ellipse at 200px 250px,yellow 50%,red 70%); background-repeat: no-repeat; example2(用关键字)： background-image: radial-gradient(closest-side ellipse at 200px 250px,yellow 50%,red 70%); background-repeat: no-repeat; radial-gradient()高级应用与radial-gradient一样，如果设置两个结束颜色的渐变距离为0或为负值，则可形成径向切割，以此构成多样化的图形。 如： example1(内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%); 但是我们一般会想要多个内凹圆角，当我们简单的将多个radial-gradient堆起来就会发现前一个背景无论如何都会把后面的背景给覆盖掉。所以我们最好的办法是结合background-size,backround-position,background-repeat结合起来，形成多个不叠加的背景！ example2(两个内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 100% / 50% 100%, radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 100%; example3(四个内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 0% / 50% 50%, radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 0%/ 50% 50%, radial-gradient(100px circle at 0 100%,transparent 50%,red 50%) no-repeat 0% 100%/ 50% 50%, radial-gradient(100px circle at 100% 100%,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 50%; repeating-linear-gradient()repeating-linear-gradient() 函数用于创建重复的线性渐变 “图像”。该属性的参数与linear-gradient()相同，所以不在赘述。 由于可以重复的组成背景图形，因此用处更多，条形背景是一个典型的应用。 example1: background: repeating-linear-gradient(yellow 0%,yellow 10%,black 10%,black 20%); example2: background: repeating-linear-gradient(rgba(255, 255, 0, 0.397) 0%,rgba(255, 255, 0, 0.397) 10%,rgba(0, 0, 0, 0.26) 10%,rgba(0, 0, 0, 0.26) 20%), repeating-linear-gradient(to right,rgba(255, 255, 0, 0.397) 0%,rgba(85, 243, 36, 0.397) 10%,rgba(0, 0, 0, 0.26) 10%,rgba(0, 0, 0, 0.26) 20%); repeating-radial-gradient()repeating-radial-gradient()用于创建多个repeating-radial原点辐射。参数与repeating-radial()一致。 example1: background: repeating-radial-gradient(circle at center, rgb(146, 146, 146) 0, rgb(146, 146, 146) 2%, black 2%,black 4%); 渐变综合应用用渐变生成一个复古胶盘： .box3 { position: relative; margin: 100px; height: 400px; width: 400px; color: cadetblue; border-radius: 50%; background: linear-gradient(30deg, transparent 40%, rgba(42, 41, 40, .85) 40%) no-repeat 100% 0, linear-gradient(60deg, rgba(42, 41, 40, .85) 60%, transparent 60%) no-repeat 0 100%, repeating-radial-gradient(#2a2928, #2a2928 4px, #ada9a0 5px, #2a2928 6px); background-size:50% 100%, 100% 50%, 100% 100%; } .box3:after{ position: absolute; top: 50%; left: 50%; margin: -35px; border: solid 1px #d9a388; width: 68px; height: 68px; border-radius: 50%; box-shadow: 0 0 0 4px #da5b33, inset 0 0 0 27px #da5b33; background: #b5ac9a; content: &apos;&apos;; } background-sizebackground-size 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。 其参数有以下内容： 值 解释 &lt;length&gt; &lt;length&gt; 值，比如10px,10em…指定背景图片大小，不能为负值。 &lt;percentage&gt; &lt;percentage&gt; 值，如10%，指定背景图片相对背景区（background positioning area）的百分比。背景区由background-origin设置，默认为盒模型的内容区与内边距，也可设置为只有内容区，或者还包括边框。如果attachment 为fixed，背景区为浏览器可视区（即视口），不包括滚动条。不能为负值。 auto 以背景图片的比例缩放背景图片。 cover 缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。 contain 缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。 inherit/initial/unset 继承父级该属性的值/默认值/如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。 注意， 如果其值为&lt;length&gt;时，则可以分别设置其宽高，如： background-size: 50% 25%; 如果background有多个值，那么在background-size就可以有多个值，并且与其一一对应。 background-size: 50% 25%, contain, 3em; //有3个背景图片 background-originbackground-origin 规定了指定背景图片background-image 属性的原点位置的背景相对区域. 参数如下： 值 解释 border-box 背景图片的摆放以border区域为参考 padding-box 背景图片的摆放以padding区域为参考 content-box 背景图片的摆放以content区域为参考 下面是效果图： background-clipbackground-clip 设置元素的背景（背景图片或颜色）是否延伸到边框或padding下面。 值 解释 border-box 背景延伸至边框外沿（但是在边框下层）。 padding-box 背景延伸至内边距（padding）外沿。不会绘制到边框处。 content-box 背景被裁剪至内容区（content box）外沿。 text 背景被裁剪成文字的前景色。（实验性属性，chrome需加上-webkit-前缀） 下面是效果图： example: -webkit-background-clip: text; color: transparent; font-size: 200px; background-positionbackground-position 为每一个背景图片设置初始位置。 这个位置是相对于由 background-origin 定义的位置图层的。 参数如下： 值 解释 center 用来居中背景图片。 top, left, bottom, right 用来指定把这个项目（原文为 item）放在哪一个边缘。另一个维度被设置成 50%，所以这个项目（原文为 item）被放在指定边缘的中间位置。 &lt;length&gt; 指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。 &lt;percentage&gt; 指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。 该属性可以分别用两个值规定x,y的距离 如：example1： background-position：50px 50px; 也可以向自己规定的边的距离： example2： background-position: right 50px bottom 50px; 我们也可以使用关键词center来居中背景： example3： background-position: center; 如果我们规定一个关键词，另一个关键词则为center： example4： background-position: left; 如果我们将距离值设置为负值，那么背景就会偏离出容器内部，延时到容器的外部（不会显示出来）。 example5: 注意：background还可以拆分为background-position-x与background-position-y，用来分别设置x，y轴的距离。虽然这是一个是实验性属性，不过大部分浏览器都实现了该方法，一般不会出问题 background-repeatbackground-repeat CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。 其参数包含以下，并且每一个单参数都可以改写成双参数（x,y两个方向）的形式： 属性值 含义 双值 repeat 默认值，图像在水平方向和垂直方向都重复以填满容器 repeat repeat repeat-x 图像只在水平方向重复以填满容器 repeat no-repeat repeat-y 图像只在垂直方向重复以填满容器 no-repeat repeat space 图像向两端对齐重复以填满容器，多余空间用空白代替 space space round 图像向两端对齐重复以填满容器，多余空间通过图像拉伸来填充 round round no-repeat 不重复，图像只显示一次 no-repeat no-repeat 注意round与space的区别 round通过图片拉伸将容器内部全部填满： background-repeat: round; space将对应数量的背景填入容器，多余的空间将background-color的颜色填充。 background-repeat: space; 并且我们可以通过双值的方式，分别设置想，x，y上的重复方式 example1： background-repeat: space round; background-attachmentbackground-attachment CSS 属性决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。 属性 解释 fixed 此关键字表示背景相对于window窗口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。 local 此关键字表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。 scroll 此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。 fixed的效果：当fixed时，背景图随着容器位置的改变而改变，也就是说背景图是以window位置为基础的（可以想想象为：背景图已经铺满了window，该容器的位置会截取对应位置的一部分作为其背景图）。 local效果：当local时，背景会随着容器的的滚动而滚动，但是其基准任然是容器（随着容器的位置的改变，背景的位置并没有改变） scroll效果：当scroll时，当我们滚动容器时，背景图不会改变；而且当容器位置改变时，背景图也没有发送改变（相对于容器），也就是说，此时背景是以容器为基准的。 给容器添加滚动条height:300px; width:300px; overflow: scroll; 添加此属性后，无论容器的内容是否超过300px，滚动条都会被添加； 如果设置： height:300px; width:300px; overflow: auto; 那么，如果容器的内容超过300px，滚动条才会被添加。 overflow属性同样是一个复合属性。它是overflow-x,overflow-y两个属性的复合属性。同样的是，overflow可以写两个值： overflow: auto scroll; 设置x轴为自动，y轴为添加滚动条时。 Last背景图这一部分的样式很有意思，特别是渐变那一部分，可以组成很多有趣的图形，不过这一部分内容还是多，需要多看多实践，才能深入掌握！","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"background","slug":"background","permalink":"http://yoursite.com/tags/background/"},{"name":"background-color","slug":"background-color","permalink":"http://yoursite.com/tags/background-color/"},{"name":"background-image","slug":"background-image","permalink":"http://yoursite.com/tags/background-image/"},{"name":"background-size","slug":"background-size","permalink":"http://yoursite.com/tags/background-size/"},{"name":"background-origin","slug":"background-origin","permalink":"http://yoursite.com/tags/background-origin/"},{"name":"background-clip","slug":"background-clip","permalink":"http://yoursite.com/tags/background-clip/"},{"name":"background-position","slug":"background-position","permalink":"http://yoursite.com/tags/background-position/"},{"name":"background-repeat","slug":"background-repeat","permalink":"http://yoursite.com/tags/background-repeat/"},{"name":"background-attachment","slug":"background-attachment","permalink":"http://yoursite.com/tags/background-attachment/"}]},{"title":"CSS3-边框","slug":"CSS3-边框","date":"2019-10-19T14:09:49.000Z","updated":"2019-10-21T08:30:44.030Z","comments":true,"path":"2019/10/19/CSS3-边框/","link":"","permalink":"http://yoursite.com/2019/10/19/CSS3-%E8%BE%B9%E6%A1%86/","excerpt":"","text":"引言之所以想到重学CSS3，是因为最近在看《CSS揭秘》一书时，在发现原来CSS3的内容有很多当时没有深入去琢磨，只是简单学习了其基础用法。下面就通过其一些高级用法来深入的研究一下CSS3的内容。 该内容分为： 边框 背景 文本效果 字体 2D、3D转换 过渡 动画 多列、用户界面（盒尺寸、轮廓） 媒体查询 CSS边框border-radiusborder-radius参数解析该属性与padding、margin相同，可以有1、2、3、4个值，所以复习一次： Example1: border-radius:10px; 四个角的弧度相同，均为10px。 Example2: border-radisu:10px 50px; 左上、右下弧度为10px，左下、右上弧度为50px。 Example3: border-radius:10px 50px 100px; 左上弧度10px，右上、左下弧度50px，右下弧度100px。 Example4: border-radius:10px 50px 100px 200px; 左上、右上、右下、左下弧度分别为：10px 50px 100px 200px; 实际上border-radius是一个简写属性，它是下面四个属性的简写： border-top-left-radius border-top-right-radius border-bottom-left-radius border-bottom-right-radius 所以也可以直接单独设置每个角的值。 border-radius参数单位border-radius参数可以为： 绝对值，比如px,em,rem等。 相对值，百分比值（参数为height、width） border-radius参数意义 这个值实际上就是这个圆角的半径值。 如果是百分比值，则通过这个容器的height\\width算出对应的值。 border-radius配置一个圆角两侧的不同弧度如上图所说，如果按照普通配置，圆角就是在容器的一角形成一个圆，将其1/4作为其圆角。 实际上我们可以分别配置一个圆角的两侧的弧度。即，将一个椭圆的1/4圆作为容器的圆角。 borde-radius:x1 x2 x3 x4/y1 y2 y3 y4; 等价于: border-top-left-radius: x1 y1; border-top-right-radius: x2 y2; border-bottom-right-radius: x3 y3; border-bottom-left-radius: x4 y4; 当然，/前后的属性可以简写： 一个值： borde-radius:x1/y1; 等价于： border-top-left-radius: x1 y1; border-top-right-radius: x1 y1; border-bottom-right-radius: x1 y1; border-bottom-left-radius: x1 y1; 两个值： borde-radius:x1 x2/y1 y2; 等价于： border-top-left-radius: x1 y1; border-top-right-radius: x2 y2; border-bottom-right-radius: x2 y1; border-bottom-left-radius: x2 y2; /前后的值是配置的是每个角的x半径、y的半径。可以为1，2，3，4个值，原理和上面一样。 border-radius高级应用基础用法-圆角.div{ height: 500px; width: 900px; border: 3px solid red; bakcground-color: brown; border-radius: 20px; } 圆形、椭圆圆形（容器的height、width必须相同，height、width的值即为圆的直径） .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-radius: 50%; } 椭圆（height、width即为该椭圆的x轴、y轴的直径） .box{ margin: 20px; height: 500px; width: 700px; border: 3px solid red; background: brown; border-radius: 50%; } 标签图形 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-bottom-right-radius: 50% 100px; border-bottom-left-radius: 50% 100px; } 烧杯 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-bottom-right-radius: 100px 100px; border-bottom-left-radius: 100px 100px; } 树叶 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-radius: 0 100% / 0 100%; } border-radius总结 实际上只要是包含圆角的图形我们都可以通过border-radius来构造，通过多个元素的+定位+圆角来构成图形。 box-shadowbox-shadow参数解析 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 基础用法： box-shadow:10px 10px 10x 10px blue; 值得注意的是： box-shadow的值允许有多组值。 example1: box-shadow: 10px 10px 10px 10px blue,20px 20px 20px 20px black; 高级应用-作为边框如果我们将blur值设为0，即不模糊，再将其h-shadow、v-shadow设置为0，即不偏移，即可将其设置边框。 example2: box-shadow: 0 0 0 10px blue； 再利用可以添加多个边框的性质，即可实现多边框。 box-shadow: 0 0 0 10px blue, 0 0 0 20px black; outlineoutline在元素外部绘制一条线。 outline:outline-color,outline-style,outline-width; 值 描述 outline-color 规定边框的颜色。 outline-style 规定边框的样式。 outline-width 规定边框的宽度。 inherit 规定应该从父元素继承 outline 属性的设置。 example: outline: greenyellow 5px solid; outline也是一个简写属性，即为：outline-color、outline-style、outline-width的简写。outline-style的风格繁多。 值 描述 none 默认。定义无轮廓。 dotted 定义点状的轮廓。 dashed 定义虚线轮廓。 solid 定义实线轮廓。 double 定义双线轮廓。双线的宽度等同于 outline-width 的值。 groove 定义 3D 凹槽轮廓。此效果取决于 outline-color 值。 ridge 定义 3D 凸槽轮廓。此效果取决于 outline-color 值。 inset 定义 3D 凹边轮廓。此效果取决于 outline-color 值。 outset 定义 3D 凸边轮廓。此效果取决于 outline-color 值。 inherit 规定应该从父元素继承轮廓样式的设置。 注意，还有一个与outline相关的属性-&gt;outline-offset，该属性可以为负值 利用outline的虚线轮廓与outline-offset可以实现缝线风格的边框。 缝线风格outline:greenyellow 2px dashed; outline-offset: -10px; border-image注意： 在大多数浏览器下，要应用border-image，必须要先设置边框border属性 当border-image存在且其第一个参数border-image-source不为none时，border-style属性将不会生效，若border-image-source为none，则border-style生效 border-image参数 值 描述 border-image-source 用在边框的图片的路径。 border-image-slice 图片边框向内偏移。 border-image-width 图片边框的宽度。 border-image-outset 边框图像区域超出边框的量。 border-image-repeat 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。 example: .box { margin: 200px; height: 500px; width: 500px; border: 100px solid transparent; background: rgb(243, 103, 103); border-image: url(&apos;/bg.png&apos;) 30% 20%/2/1 repeat; } 注意参数的格式： border-image:border-image-source border-image-slice/border-image-width/border-image-outset border-image-repeat 接下来解析一下这几个参数 border-image-source解释：第一个参数，图片地址，这个不用解释。 border-image-slice解释：第二个参数，图片边框向内偏移，即从何处裁剪背景图片。 example: border-image: url(&apos;/bg.png&apos;) 33% 20% 50% 10% repeat; //省略其他参数 该参数的个数与padding,margin相同，四参数则为上右下左的顺序，三参数则为上下、左、右，两参数则为上下、左右、一参数则全相同 border-image-width解释：第三个参数，规定border-image的宽度，被borer-width也会被相应的缩放以适应border-iamge宽度。单位为倍数，2则为被border-image-slice切割后图片的2倍，0.3则为原来的0.3倍。 example: border-image: url(&apos;/bg.png&apos;) 33%/1/0 round;//默认该参数为1 改变参数为2、0.3 border-image: url(&apos;/bg.png&apos;) 33%/2/0 round; border-image: url(&apos;/bg.png&apos;) 33%/0.2/0 round; 注意，这个参数并不会实际改变border-width中定义的宽度，如果该属性增加，则会向容器内部扩展 border-image-outset解释：该属性会将border-image向外偏移一定量。单位任然是倍数，默认为0，即占据border的位置，向外扩展0倍，1代表增加1倍，即直接与容器的border连接。向外扩展1倍。2倍则偏移两倍，则会在容器外部与边框相距边框的距离。 默认值为0： border-image: url(&apos;/bg.png&apos;) 33%/1/0 round; 变为1： border-image: url(&apos;/bg.png&apos;) 33%/1/1 round; 变为2： border-image: url(&apos;/bg.png&apos;) 33%/1/2 round; 变为0.5： border-image: url(&apos;/bg.png&apos;) 33%/1/0.5 round; 注意这里border-image向外偏移了0.5，即占据了border的一半width。 border-image-repeat解释：该属性用于如何分布border-image-slice切割后的部分该如何组合分布在边框上。它含有以下属性： 值 描述 stretch 默认值。拉伸图像来填充区域 repeat 平铺（repeated）图像来填充区域。 round 类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域。 space 类似 repeat 值。如果无法完整平铺所有图像，扩展空间会分布在图像周围 initial 将此属性设置为默认值。 inherit 从父元素中继承该属性。 特别解释一下： tretch只会将剪切过后的图片放置一张在边框位置，然后拉伸以适应边框的长度。 repeat会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽大于border-width，居中后将多余的部分隐藏在两侧。 round会将多个切割后的图片组合放在边框位置，并且组合后的图片长/宽小于border-width，然后会缩放切割图片以适应长（宽）度。 space会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽小于border-width，多余的部分会空出来，如果有背景色，则用背景色填充。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"border-radius","slug":"border-radius","permalink":"http://yoursite.com/tags/border-radius/"},{"name":"box-shadow","slug":"box-shadow","permalink":"http://yoursite.com/tags/box-shadow/"},{"name":"border-image","slug":"border-image","permalink":"http://yoursite.com/tags/border-image/"}]},{"title":"javaee之spring框架总结","slug":"javaee之spring框架总结","date":"2019-08-09T08:36:31.000Z","updated":"2019-08-09T08:38:51.988Z","comments":true,"path":"2019/08/09/javaee之spring框架总结/","link":"","permalink":"http://yoursite.com/2019/08/09/javaee%E4%B9%8Bspring%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","excerpt":"前言spring作为目前最流行，应用最广泛的后端框架，它有着许多优点与特色，比如应用它IOC（控制翻转）的功能以及spring内部的封装，可以与hibernate，struts进行整合，这里只是简单的介绍其主要功能。","text":"前言spring作为目前最流行，应用最广泛的后端框架，它有着许多优点与特色，比如应用它IOC（控制翻转）的功能以及spring内部的封装，可以与hibernate，struts进行整合，这里只是简单的介绍其主要功能。 springIOCIOC内部原理IOC内部使用了映射的原理： &lt;bean id = &quot;userService&quot; class=&quot;cn.itcast.UserService&quot;/&gt; 内部原理如下： //解析dom4j解析xml文件得到class属性值 String classValue = &quot;class属性值&quot;; //使用反射创建类对象 Class clazz = Class.forName(classValue); //创建类对象 UserService service = clazz.newInstance(); return service; Bean实例化类的无参构造方式&lt;bean id=&quot;user&quot; calss=&quot;cn.itcast.ioc.User&quot;&gt;&lt;/bean&gt; 类的静态工厂方法类方法： public class Bean2Factory{ public static Bean2 getBean2(){ return new Bean2(); } } 配置文件： &lt;bean id=&quot;bean2&quot; class=&quot;cn.itcast.bean.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt; 类的实例工厂方法类方法： public class Bean3Factory{ public Bean3 getBean3(){ return new Bean3(); } } 配置文件： &lt;bean id=&quot;bean3Factory&quot; class=&quot;cn.itcast.bean.Bean3Factory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;&gt; 获取实例化对象//加载配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //获取实例 User user = (User) context.getBean(&quot;user&quot;); Bean标签的常用属性 id属性：对这个bean的属性名，获取该bean的实例时所需的名字。 class属性：创建对象所在类的全路径。 name属性：功能与id属性一样，id属性不能包含特殊字符，但是在name属性值里面可以包含特殊字符。 scope属性：单实例与否。 singleton：默认值，单实例 prototype：多实例 属性注入使用构造函数注入bean： public class PropertyDemo1{ pubcli PropertyDemo1(String username){ this.username= username; } } 配置文件： &lt;bean id=&quot;demo&quot; class=&quot;cn.itcast.property.PropertyDemo1&quot;&gt; &lt;construct-arg name=&quot;username&quot; value=&quot;谁谁谁&quot;&gt;&lt;/construct-arg&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); PropertyDemo1 demo = (demo) context.getBean(&quot;demo&quot;); System.out.println(demo.username); 使用set方法注入bean： class setBookname{ private String bookname; public void setBookname(String bookname){ this.bookname = bookname; } } 配置文件： &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.property.Book&quot;&gt; &lt;property name=&quot;bookname&quot; value=&quot;嘿嘿嘿&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); setBookname book = (book) context.getBean(&quot;book&quot;); System.out.println(book.bookname); 注入对象类型属性UserDao： public class UserDao{ public test(){ System.out.print(&quot;test...&quot;); } } UserService： public class UserService{ private UserDao userDao; public void setUserDao(User userDao){ this.userDao = userDao; } } 配置文件： &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt; //id为类中的属性名 //ref值与生成的bean的id值相同 &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.userDao.test(); 注入数组，list集合，map集合，properties类型属性&lt;bean id=&quot;person&quot; class=&quot;cn.itcast.property.Person&quot;&gt; &lt;!-- 数组 --&gt; &lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- list --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;小奥&lt;/value&gt; &lt;value&gt;小金&lt;/value&gt; &lt;value&gt;小普&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- map --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aa&quot; value=&quot;lucy&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;bb&quot; value=&quot;mary&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;cc&quot; value=&quot;tom&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- properties --&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverclass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; IOC注解方式 在spring配置文件中引入约束： xmlns:context=”http://www.springframework.org/schema/context&quot; xsi:schemaLocation=” http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; 在配置文件中开启注解扫描 //base-package：需要扫描注解的包 &lt;context:component-scan base-package=”cn.itcast”&gt;&lt;/context:component-scan&gt; 创建注解对象在bean中类的上方加上注解：@Component(value=&quot;...&quot;) bean： @Component(value=&quot;user&quot;) //等价于&lt;bean id=&quot;user&quot; class=&quot;...&quot;&gt; public class User{ public test(){ System.out.println(&quot;got it!&quot;); } } 调用： public class test( ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); user.test(); //got it! } 可以了解的是，spring提供了4个注解关键字来实例化bean，其中后3个是Componnet的衍生： @Component:都可以使用 @Controller: web层 @Service: 业务层 @Repository: 持久层 注解确定单、多实例@Scope(value=&quot;prototype&quot;) //多实例 @Scope(value=&quot;singleton&quot;) //单实例 注解注入属性注入基本类型@Value(value) bean: public class test{ @Value(&quot;谁谁谁&quot;) private String username; @Value(123) private int userid; } 不过我们想向本类中注入值的情况比较少，掌握即可 注入属性对象类型 @Autowired:自动检测属性并注入，前提是这个属性对象已经通过spring创建了对象实例，配置文件方式或注释方法都可以。 Resource(name=”对象名”)，对象名是通过spring创建的实例id值或name值 创建属性实例 @Component(value=”userDao”) class userDao{ } 注入属性的两种方式 @Autowired private UserDao userDao; @Resource(name=&quot;userDao&quot;) Private UserDao userDao; 配置文件与注解混合使用可以在配置文件中声明对象的属性类，然后在对象中通过注解注入属性。 配置文件： &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; 类： @Resource(name=&quot;bean0&quot;); private Bean0 bean0; @Resource(name=&quot;bean1&quot;); private Bean0 bean1; spring中的AOP名词解释 Joinpoint(连接点)：类里面可以被增强的方法，这些方法被称为连接点。 Ponitcut(切入点)：所谓切入点是指我们要对哪些Joinpoint进行拦截。 Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Aspect(切面): 是切入点和通知（引介）的结合 增强：增强的逻辑，成为增强，包含以下类型： 前置通知：在方法之前执行 后置通知：在方法之后执行 异常通知：在方法出现异常时执行 最终通知：在后置通知之后执行 环绕通知：在方法之前和之后执行配置文件 引入xml命名空间 http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd 使用表达式配置切入点(实际增强的方法) 表达式： execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* cn.itcast.aop.Book.add(…)) execution( cn.itcast.aop.Book.(..)) execution( .*(..)) 匹配..开头的方法 execution( save(..)) AspectJ的aop操作 AspectJ不是spring的一部分，和spring一起使用aop操作。 spring2.0以后新增了对AspectJ的支持。 AspectJ可以用配置文件或注释文件。 配置对象 配置aop操作 aop:config //配置切入点 &lt;aop:pointcut expression=&quot;execution(* cn.itcast.aop.Book.*(..))&quot; id=&quot;pointcut1&quot;&gt; //配置切面，将增强用到切入点上 &lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:aspect&gt; &lt;/aop:config&gt; 值得注意的是： aop:point标签是在配置切入点，即哪些方法需要被增强，其中expression为表达式，id为自定义名称。 aop:aspect标签是在配置切面，即用哪些增强(方法)来增强切入点。 在aop:aspect内部标签表示的是增强的方式。包含以下标签： aop:before 前置通知 aop:after-returning 后置通知 aop:around 环绕通知 aop:after-throwing 异常通知 aop:after 最终通知 AspectJ的注解AOP操作 创建对象 &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt; 在spring核心配置文件中，开启aop操作 aop:aspectj-autoproxyaop:aspectj-autoproxy 在增强类上使用注解完成aop操作 @Aspect public class MyBook{ @Before(value=&quot;execution(* cn.itcast.aop.Book.*(..))&quot;) public void before1(){ System.out.print(&quot;before........&quot;); } } sping的jdbcTemplate操作 设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(“com.mysql.jdbc.Driver”); dataSource.setUrl(“jdbc.mysql:///database0”); dataSource.setUsername(“root”); dataSource.setPassword(“root”); 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); 创建sql语句，并执行jdbcTemplate中的方法 增加 String sql = “insert into user value(?,?)”;int rows = jdbcTemplate.update(sql,”lucy”,”250”); 修改 String sql = “update user set password =? where username=?”;int rows = jdbcTemplate.update(sql,”1234”,”lucy”); 删除 String sql = “delete from user where username=?”;int rows = jdbcTemplate.update(sql,”lucy”); 查询 //返回对象String sql = “select * from user where username=?”;User user jdbcTemplate.queryForObject(sql,new MyRowMapper(),”mary”);System.out.println(user); //实现RowMapperclass MyRowMapper implements RowMapper{ @Override public User mapRow(Result re, int num) throws SQLException{ String username= rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); User user = new User(); user.setUsername(username); user.setPassword(password); }} //返回list String sql = &quot;select * from user&quot;; List&lt;User&gt; list = jdbcTemplate.query(sql,new MyRowMapper()); System.out.println(list); Spring配置c3p0连接池和dao使用jdbcTemplate因为配置jdbcTemplate数据库的数据库信息实际上还是创建对象，注入属性。所以同样可以用Spring的AOP进行对象的创建。 导入c3p0以及配合的jarbao 配置c3p0连接池 dao使用jdbcTemplate 创建service和dao，配置service和dao对象，并把service注入dao对象 &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c3p0.UserService&quot;&gt; &lt;proerpty name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c3p0.UserDao&quot;&gt; 2. 创建jdbcTemplate对象 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate){ this.jdbcTemplate = jdbcTemplate; } 3. 把模板对象注入dao中 &lt;bean id=&quot;userDao&quot; class=&quot;class.itcast.c3p0.UserDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; 4. 在jdbcTemplate对象里注入dataSource private DataSource dataSource; privateSQLExceptionTranslator exceptionTranslator; private boolean lazyInit = true; public void setDataSource(DataSource dataSource){ this.dataSource = dataSource; } &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;bean&gt; spring的事务管理xml方式 在核心配置文件中配置事务管理器 配置事务增强 &lt;tx:advice id=”txadvice” transaction-manager=”transactionManager”&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;account*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; tx:advice 配置切面 aop:config &lt;aop:pointcut expression=&quot;execution(* cn.itcast.service.OrderService.*(..))&quot; id=&quot;pointcut1&quot;&gt; &lt;aop:adviser advice-ref=&quot;txadvice&quot; point=ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; 注解方式 配置事务管理器 开启事务注解 &lt;tx:annotation-driven transaction-manager=”transactionManager”/&gt; 在需要使用事务的方法所在类上面添加注解 @Transactional public class ordersService{ } Last这里的内容多是视频教学笔记中的内容加上我自己的理解，只是不是很深，只是一个最基本的用法，并且省去了配置环境的问题，比如导入jar包等等，这里面可能有很多错误或不足，因为我也是才开始接触。加油加油！","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/tags/JavaEE/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"javaee之hibernate框架总结","slug":"javaee之hibernate框架总结","date":"2019-08-08T10:09:11.000Z","updated":"2021-03-08T02:55:58.693Z","comments":true,"path":"2019/08/08/javaee之hibernate框架总结/","link":"","permalink":"http://yoursite.com/2019/08/08/javaee%E4%B9%8Bhibernate%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","excerpt":"前言Hibernate目前使用的还是比较多，虽然不及mybatis。 Hibernate概述Hibernate工作在javaEE三层结构中的dao层，对数据库进行crud操作，其核心思想是orm（object relational mapping，对象关系映射），并且Hibernate支持多种查询方式，包括HQL，QBC,SQL三种方式。 orm 让实体类和数据库表进行一一对应关系 让实体类首先和数据库表对应 让实体类属性 和 表里面字段对应 不需要直接操作数据库表，而操作表对应实体类对象","text":"前言Hibernate目前使用的还是比较多，虽然不及mybatis。 Hibernate概述Hibernate工作在javaEE三层结构中的dao层，对数据库进行crud操作，其核心思想是orm（object relational mapping，对象关系映射），并且Hibernate支持多种查询方式，包括HQL，QBC,SQL三种方式。 orm 让实体类和数据库表进行一一对应关系 让实体类首先和数据库表对应 让实体类属性 和 表里面字段对应 不需要直接操作数据库表，而操作表对应实体类对象 配置文件Hibernate的核心配置文件有如下要求： 必须在src下 必须为hibernate.cfg.xml 配置核心文件 引入约束 12&lt;!DOCTYPE hibernate-configuration PUBLIC&quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot;&quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt; 配置信息 123456789101112131415161718192021222324252627&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 第一部分： 配置数据库信息 必须的 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;&#x2F;hibernate_day01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt;&lt;!-- 第二部分： 配置hibernate信息 可选的--&gt; &lt;!-- 输出底层sql语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 输出底层sql语句格式 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- hibernate帮创建表，需要配置之后 update: 如果已经有表，更新，如果没有，创建 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 配置数据库方言 在mysql里面实现分页 关键字 limit，只能使用mysql里面 在oracle数据库，实现分页rownum 让hibernate框架识别不同数据库的自己特有的语句 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第三部分： 把映射文件放到核心配置文件中 必须的--&gt; &lt;mapping resource&#x3D;&quot;cn&#x2F;itcast&#x2F;entity&#x2F;User.hbm.xml&quot;&#x2F;&gt;&lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 值得注意的是： 配置数据库信息部分与jdbc部分的配置信息一致 hibernate.show_sql： 在编译时控制台输出生成的SQL语句 hibernate.format_sql : 在上面的属性开启的前提之下输出格式化之后的SQL语句 hibernate.hbm2ddl.auto : 配置数据库方言在mysql里面实现分页 关键字 limit，只能使用mysql里面在oracle数据库，实现分页rownum让hibernate框架识别不同数据库的自己特有的语句 配置映射文件映射文件是一个表与实体的配置映射 命名没有确定规则 位置也没有确定位置 引入约束 &lt;!DOCTYPE hibernate-configuration PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN” “http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 配置映射关系 12345678910&lt;hibernate-mapping&gt; &lt;class name&#x3D;&quot;priv.mw.dao&quot; table&#x3D;&quot;t_user&quot;&gt; &lt;id name&#x3D;&quot;uid&quot; column&#x3D;&quot;uid&quot;&gt; &lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;password&quot; column&#x3D;&quot;username&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;class&gt; &lt;&#x2F;hibernate-mapping&gt; 值得注意的是： hibernate-mapping package:填写包名，如果此处填写了完整的包名，则后面class的name属性只需要填写class名字。否则class的name属性则需要填写完整的名字，及包含包名的类名。 class name：填写类名（全路径或名字） table：数据库中表名。（orm中表与类一一对应） id：每一张表必须要有一个唯一的属性。 name：类中属性的名字 column：为表中列的名字 property:表中的属性 name:类中的属性名 column：表中的列名 值得注意的是： id或property中的column是可选的，如果不填，则默认与name属性相同。 实体类的编写规则 实体类中的属性是私有的 私有属性使用公开的set和get方法 要求实体类有属性作为唯一值(一般使用id值) 实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类，其目的是Integer score = null。可以表示不存在这个值，而基本类不能为null。 主键的生成策略 native：自动增长 uuid：uuid算法 CRUDsession方式 加载核心配置文件 加载SessionFactory对象 使用SessionFactory对象创建session对象 开启事务 开始写具体逻辑，crud操作 提交事务 关闭资源 12345678910111213141516171819202122232425262728public test()&#123; //1. 加载hibernate核心配置文件 //这一步从src中查找hibernate.cfg.xml Configuration cfg = new Configuration(); cfg.configure(); //2. 创建SessionFactory对象 //同时读取映射文件，创建表格 SessionFactory sessionFactory = cfg.buildSessionFactory(); //3. 创建Session对象 Session session = session.openSession(); //4. 开启事物 Transaction tx = session.beginTransaction(); //5. 写入具体的crud操作 User user = new User(); user.setUsername(\"李雷\"); user.setPassword('123'); user.setAddress(\"日本\"); session.save(user); //6. 提交事务 tx.commit(); //7. 关闭资源 session.close(); sessionFactory.close(); } session对象导航查询常用的方法： get():通过OID 从数据库中抓取数据，并把数据加载到一个新实例对象上。 save():执行insert语句，当数据库存在这条记录时，会抛出异常。 saveOrUpdate():如果数据库中不存在该数据，则执行insert语句，如果存在则执行更新操作。 update():当数据库中存在这条记录时，Hibernate 总会执行一条SQLUPDATE 语句；当数据库中不存这条记录时，就会抛出异常。 delete():当数据库中存在这条记录时，Hibernate 总会执行一条SQLDELETE 语句；当数据库中不存这条记录时，就会抛出异常。 load():该方法与get相同，但是不会立即去查询数据库，而是等待需要使用该数据时才去查询。比如用ID查询ID，get方法任然回去查询数据库，而load则直接返回使用的ID，不去查询数据库。 实体对象三种状态 瞬时状态(Transident):如果对象从未与Session对象关联过，称该对象处于瞬时状态（或临时状态）。 持久状态(Persisdent):如果对象与Session对象关联起来，且该对象对应到数据库记录，则称该对象处于持久化状态。比如通过get获取的对象。 游离状态(Detached)：当持久化对象的Session关闭后，这个对象就会从持久化状态改变成游离状态。 HQL方式example： 12Query query = session.createQuery(\"from Customer where name=?\");query.setParameter(\"mw\"); 条件查询： from Customer c where c.cid=? and c.custName=? 模糊查询 from Customer c where s.custName like ? 排序查询 from Customer order by cid desc 分页查询 Query query = session.createQuery(“from Customer”); query.setFirstResult(0); query.setMaxReaults(3); List list = query.list(); 投影查询:查询不是所有字段值，而是部分字段的值 Query query = session.createQuery(“select cusName from Customer”); List list = query.list(); for(Object object : list){ Systom.out.println(Object); } 聚集函数使用 Query query = session.createQuery(&quot;select count(*) from Customer&quot;); object obj = query.uniqueResult(); Long lobj = (Long)obj; int count = lobj.intValue(); 内连接查询（返回list）：选取两张表的外键相同的数据返回。 Query query = session.createQuery(“from Customer c inner join c.setLinkMan”) 迫切内连接（返回对象） Query query = session.createQuery(&quot;from Customer c inner join fetch c.setLinkMan&quot;) 左外连接（返回list）：返回左侧表中的所有数据以及右侧与之外键相同的的数据。 Query query = session.createQuery(“from Customer c left outer join c.setLinkMan”); 迫切左外连接（返回对象） Query query = session.createQuery(&quot;from Customer c left outer join fetch c.setLinkMan&quot;); 右外连接：返回左右侧表中的所有数据以及左侧与之外键相同的的数据。 Query query = session.createQuery(“from Customer c right outer join s.setLinkMan”); QBC方式调用Criteria的方法实现查询 查询所有 Criteria criteria = session.createCriteria(Customer.class); List list = criteria.list(); 条件查询 Criteria criteria = session.createCriteria(Customer.class); cretera.add(Restrictions.eq(“cid”,1)); critera.add(Restrictions.eq(“custName”,”someone”)); List list = criteria.list(); cretiria.add(Restrictions.like(“custName”,”%s%”)); 排序查询 Criteria criteria = session.createCriteria(Customer.class); cretiria.addOrder(Order.desc(“cid”)); 分页查询 Criteria criteria = session.createCriteria(Customer.class); criteria.setFirstResult(0); criteria.setMaxResult(3); 统计查询 Criteria criteria = session.createCriteria(Customer.class); criteria.setProjection(Projections.rowCount()); Object obj = criteria.uniqueResult(); Long lobj = (Long) obj; int count = lobj.intValue; 离线查询：不通过session对象来创建查询对象，即可以在dao层session对象关闭后也能执行查询。一般用在多条件查询直接在service层进行离线查询。 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class); Criteria criteria = detachedCriteria.getExecutableCriteria(session); List list = criteria.list(); hibernate一对多操作这里的一对多其实就是SQL中一对多的概念，不过我们在学习如何在hibernate中来使用这个概念。 以客户，联系人为例： 创建两个实体类，客户、联系人 让连个实体之间相互表示，即将对方对象作为一个自己的一个私有属性，并设置set,get方法。 在客户实体类里面表示多个联系人 private Set setLinkMan = new HashSet(); public Set getSetLinkMan(){ return setLinkMan;} public void getSetLinkMan(Set setLinkMan){ this.setLinkMan = setLinkMan;} 在联系人实体类里面表示所属客户 private Customer customer; public Customer getCustomer(){ return customer;} public void setCustomer(Customer customer){ this.customer = customer;} 配置客户映射关系 //在客户映射文件中，表示联系人 //使用set标签表示所有联系人 //set中name为联系人中的set集合名称 //column为外键名称 //class中写联系人的实体全路径 配置联系人映射文件 //name：在联系人实体中的客户属性的名字 //class：联系人class的全路径 //column：外键名称 配置核心配置文件 resource：映射文件的路径名称 &lt;mapping resource=&quot;cn/itcast/entuty/Customer.hbm.xml&quot;&gt; &lt;mapping resource=&quot;cn/itcast/entuty/LinkMan.hbm.xml&quot;&gt; 一对多级联保存123456789101112131415Customer customer = new Customer();customer.setCustName(\"百度\");customer.setCustLevel(\"普通客户\");customer.setCustSource(\"网络\");customer.setCustPhone(\"110\");customer.setCustMobile(\"999\");LinkMan linkman = new LinkMan();linkman.setLkm_name(\"小宏\");linkman.setLkm_gender(\"男\");linkman.setLkm_phone(\"911\");//2 把联系人放到客户里面customer.getSetLinkMan().add(linkman);//3 保存客户session.save(customer); 一对多级联删除删除某个客户，把客户里面所有的联系人删除 需在set中配置cascade属性： 12345&lt;set name=\"setLinkMan\" cascade=\"save-update,delete\"&gt;Customer customer = session.get(CUstomer.class,3);session.delete(customer); 一对多级联更新123456789101112//根据id查询Lucy联系人，客户百度Customer baidu = session.get(Customer.class,1);//设置持久态对象Customer lucy = session.get(LinkMan.class,2);//把联系人放入客户对象中baidu.getSetLinkMan().add(lucy);//把客户放到联系人中lucy.setCustomer(baidu); 值得注意的是： 在默认转态下，两个对象都会维护这个关系。所以会执行两次SQL语句。为了解决这个问题，可以在set中配置inverse属性，让某一方放弃维护。 inverse: false不放弃维护 true放弃维护 hibernate多对多实际上我们在比较少用多对多关系，会将其转化为两个一对多关系。 以用户和角色为例： 创建实体类，用户和角色 让两个实体类相互表示 一个用户有多个角色，使用set集合 123456789101112131415161718192021Private Set&lt;Role&gt; setRole = new HashSet&lt;Role&gt;(); public Set&lt;Role&gt; getSetRole()&#123; return setRole;&#125; public void setSetRole(Set&lt;Role&gt; setRole)&#123; this.setRole = setRole;&#125; 2. 一个角色有多个用户，使用set集合 private Set&lt;User&gt; setUser = new HashSet&lt;User&gt;(); public Set&lt;User&gt; getSetUser()&#123; return setUser;&#125; public void setSetUser(Set&lt;User&gt; setUser)&#123; this.setUser =setUser;&#125; 配置映射关系 在用户里面表示所有角色，使用set标签 在角色中表示所有用户，使用set标签 在核心配置文件中引入映射文件 多对多级联保存任然需要在set中配置cascade &lt;set name=&quot;setRole&quot; table=&quot;user_role&quot; cascade=&quot;save-update,delete&quot;&gt; 实体类中代码： 1234567891011121314151617181920212223242526272829303132User user1 = new User();user1.setUser_name(\"lucy\");user1.setUser_password(\"123\");User user2 = new User();user2.setUser_name(\"mary\");user2.setUser_password(\"456\");Role r1 = new Role();r1.setRole_name(\"总经理\");r1.setRole_memo(\"总经理\");Role r2 = new Role();r2.setRole_name(\"秘书\");r2.setRole_memo(\"秘书\");Role r3 = new Role();r3.setRole_name(\"保安\");r3.setRole_memo(\"保安\");//2 建立关系，把角色放到用户里面// user1 -- r1/r2user1.getSetRole().add(r1);user1.getSetRole().add(r2);// user2 -- r2/r3user2.getSetRole().add(r2);user2.getSetRole().add(r3);//3 保存用户session.save(user1);session.save(user2); 多对多级联删除1234&lt;set name=\"setRole\" table=\"user_role\" cascade=\"save-update,delete\"&gt;User user = session.get(User.class,1);session.delete(user); 多对多级联更新12345678User lucy = session.get(User.class,1);Role role = session.get(Role.class,1);//为用户添加角色lucy.getSetRole().add(role);//把用户角色删除lucy.getSetRole().remove(role); hibernate缓存hibernate为了增加查询效率，建立了缓存机制。即在查询到某个数据后，则将其存储到内存中，下一次查询时直接获取内存中的数据，不用向数据库查询，直接获取，加快查询速度。 hibernate的一级缓存默认打开的 hibernate的一级缓存使用范围，是session范围，3. hibernate的一级缓存中，存储数据必须 持久态数据 hibernate事务与SQL的事务一致，保证一系列工作的全部执行。具有以下特性： 原子性： 确保工作单元中的所有操作都成功完成; 否则，该事务被中止的故障点，操作回滚到操作之前的状态。 一致性：确保数据库正确后成功提交事务更改状态。 隔离性：事务操作彼此独立和透明。 持久性：可确保提交的事务的结果或仍然存在系统故障的情况下的作用。 try { 开启事务 提交事务}catch() { 回滚事务}finally { 关闭} 12345678910111213141516171819202122232425262728293031public void testTx() &#123; SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; try &#123; sessionFactory = HibernateUtils.getSessionFactory(); session = sessionFactory.openSession(); //开启事务 tx = session.beginTransaction(); //添加 User user = new User(); user.setUsername(\"小马\"); user.setPassword(\"250\"); user.setAddress(\"美国\"); session.save(user); int i = 10/0; //提交事务 tx.commit(); &#125;catch(Exception e) &#123; e.printStackTrace(); //回滚事务 tx.rollback(); &#125;finally &#123; //关闭操作 session.close(); sessionFactory.close(); &#125;&#125; 通过session.beginTransaction()获取Transaction对象。 最后这个说明只是一个简单的概述，根据黑马程序员2016年版的笔记总结而来，肯定不是全部的，但是这个足够进行简单的操作。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/tags/JavaEE/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"hibernate","slug":"hibernate","permalink":"http://yoursite.com/tags/hibernate/"}]},{"title":"javaee之struts框架总结","slug":"javaee之struts框架总结","date":"2019-08-08T00:32:52.000Z","updated":"2019-08-08T10:15:24.283Z","comments":true,"path":"2019/08/08/javaee之struts框架总结/","link":"","permalink":"http://yoursite.com/2019/08/08/javaee%E4%B9%8Bstruts%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","excerpt":"前言最近在了解后端开发框架，所以先从SSH（Struts，Spring，Hibernate）开始，因为在企业级开发中SSH任然在使用，所以还是有必要了解一下，后面再详细学习SSM（Spring MVC，Spring，mybatis），目前互联网企业中大多都在使用SSM。","text":"前言最近在了解后端开发框架，所以先从SSH（Struts，Spring，Hibernate）开始，因为在企业级开发中SSH任然在使用，所以还是有必要了解一下，后面再详细学习SSM（Spring MVC，Spring，mybatis），目前互联网企业中大多都在使用SSM。 这一期先介绍struts。 strutsstruts介绍struts是一个工作在表示层，负责与JSP页面实现交互，将用户的请求委派给相应的Action处理。 配置过滤器在web-app内添加如下内容： &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 创建action方法一 直接创建Actionpublic class Democlass{ public String execute(){ return &quot;none&quot;; } } 方法二 继承ActionSupport类（最常用）public class Democlass extends ActionSupport{ public String execute(){ return &quot;none&quot;; } } 方法三 实现接口Actionpublic class Democlass implements Action{ public String execute(){ return &quot;none&quot;; } } 配置文件配置文件必须是命名为struts.xml，并且位于src目录下。 引入dtd约束&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; 配置action&lt;package name=&quot;methoddemo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;&quot; class=&quot;cn.itcast.method.BookAction&quot; method=&quot;&quot; &gt; &lt;result name=&quot;ok&quot;&gt;hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 结构为：package-&gt;action-&gt;result package参数： name:（必填）自定义名称 namespace:（可选）命名空间 extends:（可选）该包继承自其它包，一般填struts-default abstract:（可选）该类是否是一个抽象包，抽象包中不能包含Action定义。 action参数： name：（必填）action的标识，在URL访问时后缀为该值。 class：（可选）Action的类的全路径。 method：（可选）指定请求Action时调用的方法，默认为execute方法。 converter：（可选）指定类型转换器的类。 result参数： name：（可选）指定逻辑视图的名称，默认为success。（为指定函数的返回值） type：（可选）指定访问内容的方式，主要有如下方式（默认为dispatcher） dispatcher：页面转发 redirect：页面重定向 chain：action转发 redirectAction：action重定向 global-result如果在action类的方法中，返回了一个字符串，但如果没有配置对应的result，则浏览器会返回404，但是global-result可以匹配任何action中的对应action。 注意：如果action中与global-result同时配置了相同的result。则局部result优先级更高。 &lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; &lt;global-results&gt; action获取表单数据使用ActionContext类获取ActionContext context = ActionContext.getContext(); Map&lt;String,Object&gt; map = context.getParameters(); //使用Map.Entry遍历获取的Map for(Map.Entry&lt;String, Object&gt; entry : map.entrySet()) { System.out.println(entry.getKey()+&quot;--&quot;+Arrays.toString((Object[]) (entry.getValue()))); } 使用SevletActionContext类获取该方法直接获取request对象。 HttpServletRequest request = ServletActionContext.getRequest(); //下面就是调用request了 String para1 = request.getParameter(&apos;para1&apos;); String para2 = request.getParameter(&apos;para2&apos;); String para3 = request.getParameter(&apos;para3&apos;); 使用接口获取requestpublic class Demo implements ServletRequestAware{ @Override public void setServletRequest(HttpServletRequest){ this.request = request; } } 在action中操作域对象struts的域对象与servlet的域对象一样，用于存储数据，在JSP页面中直接获取。 具体用法： request域 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(“key”,”value”); session域 HttpSession session = request.getSession(); session.setAttribute(“key”,”value”); ServletContext域 ServletContext context = ServletAction.getServletContext(); context.setAttribute(“key”,”value”); 属性封装表单提交的数据会自动封装到类实例的属性 一、直接将表单提交的属性封装到action中 在action成员中定义变量 生成变量的set,get方法 private String userName; private String password; private String address; public String getUserName(){ return this.userName; } public String setUserName(String userName){ this.userName = userName; } public String getPassword(){ return this.password; } public String setPassword(String userName){ this.password = password; } public String getAddress(){ return this.address; } public String setAddress(String userName){ this.address = address; } 模型驱动封装(重点) action实现接口ModelDriven 实现接口里面的getModel方法 在action里创建实体类对象 class Demo extends ActionSupport implements ModelDriven{ private User user = new User(); public User getModel(){ return user } } 使用模型驱动封装，一个表单只能封装一个模型驱动封装。 不能同时使用属性封装与模型驱动封装。 表达式封装使用表达式封装是指在表单提交时，name属性则为具体实例的属性（struts有自己的表示方式，比如：User.name） 在action中声明实例类 生成实例类的set与get方法 private User user; public User getUser(){ return user; } public void setUser(User user){ this.user = user } 在表单输入项的name属性里面写表达式形式 username:&lt;\\input type=”test” name=”user.userName”&gt; password:&lt;\\input type=”password” name=”user.password”&gt; address:&lt;\\input type=”text” name=”user.address”&gt; 封装到集合中封装到list集合第一步 在action声明List第二步 生成list变量的set和get方法 private List&lt;User&gt; list; public List&lt;User&gt; getList(){ return list; } public void setList(List&lt;User&gt; list){ this.list = list; } 第三步 在表单输入项中写表达式 username:&lt;input type=&quot;text&quot; name=&quot;list[0].userName&quot;&gt; password:&lt;input type=&quot;password&quot; name=&quot;list[0].password&quot;&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[0].address&quot;&gt; &lt;br/&gt;&lt;br/&gt; username:&lt;input type=&quot;text&quot; name=&quot;list[1].userName&quot;&gt; password:&lt;input type=&quot;password&quot; name=&quot;list[1].password&quot;&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[1].address&quot;&gt; 封装到Map集合第一步 声明map集合第二步 生成get和set方法 private Map&lt;String,User&gt; map; public Map&lt;String,User&gt; getMap(){ return map; } public void setMap(Map&lt;String,User&gt; map){ this.map = map; } username:&lt;input type=&quot;text&quot; name=&quot;map[one].userName&quot;/&gt; password:&lt;input type=&quot;password&quot; name=&quot;map[one].password&quot;/&gt; address:&lt;input type=&quot;text&quot; name=&quot;map[one].address&quot;/&gt; OGNL表达式与EL表达式一样，OGNL表达式可以用来操作值栈。 引用struts标签库//引用标签库 &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt; //操作 &lt;s:property value=&quot;&apos;haha&apos;.length()&quot;&gt; 值栈 在servlet中，我们把数据放到了域对象中，在页面中使用EL表达式获取；域对象同样在一定范围内，存值和取值。 在struts中也提供了一种存储机制，类似与域对象，被称为值栈，也可以存值获取值。 在action中把数据存到值栈中，在页面中获取数据。 servelet和action区别 Servlet：默认在第一次访问创建，创建一次，单实例对象。 Action：访问时创建，每次访问的时候，都会创建一个action对象。所以它是一个多实例对象。 值栈存储在action中。 获取值栈对象ActionContext context = ActionContext.getContext(); ValueStack stack1 = context.getValueStack(); 每一个action只有一个值栈对象。 值栈分为两部分： root：list集合 context：map集合（实际就是action的上下文），包含如下内容： request：HttpRequest对象的引用 session：HttpSession对象引用 application：ServletContext对象的引用 parameters：传递的相关参数 attr：域对象，使用seAttribute(“key”,”value”)存储 可以使用s:debug来查看action的结构 向值栈中存值 使用set方法 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); stack.set(“key”,”value”); 使用push方法 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); stack.push(“something”); 向值栈中存放对象 private User user = new User(); public User getUser(){ return user; } public String excute() throws Exception{ user.setUsername(&quot;lucy&quot;); user.setPassword(&quot;123&quot;); user.setAddress(&quot;美国&quot;); return &quot;success&quot;; } 向值栈中存放list集合 private List list = new ArrayList(); public List getList(){ return list; } public String excute() throws Exception{ User user1 = new User(); user1.setUsername(&quot;lucy&quot;); user1.setPassword(&quot;123&quot;); user1.setAddress(&quot;美国&quot;); User user2 = new User(); user2.setUsername(&quot;tom&quot;); user2.setPassword(&quot;12345&quot;); user2.setAddress(&quot;意大利&quot;); list.add(user1); list.add(user2); return &quot;success&quot;; } 从值栈中取值我们都是用OGNL表达式结合struts标签来获取值栈中的值。 获取字符串&lt;s:property value=&quot;username&quot;/&gt; 获取对象//方法一 &lt;s:property value=&quot;list[0].username&quot;/&gt; &lt;s:property value=&quot;list[0].password&quot;/&gt; &lt;s:property value=&quot;list[0].address&quot;/&gt; &lt;br/&gt; &lt;s:property value=&quot;list[1].username&quot;/&gt; &lt;s:property value=&quot;list[1].password&quot;/&gt; &lt;s:property value=&quot;list[1].address&quot;/&gt; //方法二 &lt;s:iterator value=&quot;list&quot;&gt; &lt;s:property value=&quot;username&quot;/&gt; &lt;s:property value=&quot;password&quot;/&gt; &lt;s:property value=&quot;address&quot;/&gt; &lt;s:iterator&gt; //方法三 &lt;s:iterator value=&quot;list&quot; var = &quot;user&quot;&gt; &lt;s:property value=&quot;#user.username&quot;/&gt; &lt;s:property value=&quot;#user.password&quot;/&gt; &lt;s:property value=&quot;#user.address&quot;/&gt; &lt;s:iterator&gt; 获取set值&lt;s:property value=&quot;key&quot;&gt; 获取push方法&lt;s:property value=&quot;[0].top&quot;&gt; 可以通过debug的方式看出，值栈实际上就是存在context中，作为其属性。 EL表达式可以不去值栈数据EL表达式实际上是增强了getAttribute方法，如果在request中获取到对应的值，则返回该值，否则再到值栈中检索。 OGBL中的#与% # 获取context中的值 &lt;s:property value=”#user.username”/&gt; 获取request中的值 &lt;s:property value=”#request.req”/&gt; % 在struts2标签中表单标签 在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别。 &lt;s:textfield name=&quot;username&quot; value=&quot;%{#request.req}&quot;&gt; struts拦截器struts的拦截器是一种AOP(面向切面编程)思想的实践，通俗的来说就是不改变源代码来实现对原来类或方法的拓展。 而在每次action启动的时，我们都会为每个action方法增加一些拦截器，在action对象创建之后，action方法之前，拦截器的方法得到执行，拦截决定是否放行，然后由下一个拦截器接手继续执行，知道所有拦截器执行完。一旦任何一个拦截器拒绝了，那么后面的拦截也都不会执行了。 拦截器与过滤器 过滤器：理论上可以过滤任意内容，包括html,jsp,servlet… 拦截器：只能拦截action 自定拦截器编写拦截器方法 继承MethodFilterInterceptor并重写其中的doIntercept方法。 public class MyFilter extends MthodsFilterInterceptor{ protected String doIntercept(ActionInvocation invocation)throws { //如果符合条件，则通过执行invocation.invoke()来放行 if(somthongright){ invocation.invoke(); }else{ //否则，不执行invocation.invoke() return &quot;null&quot;; } } } 配置拦截器在package中： 声明拦截器 //class为自定义拦截器的全路径 使用自定义的拦截器在要使用的action内部使用： //name为上面配置的name值 3.还有一点要注意，由于interceptor-ref值默认为执行struts的默认拦截器，我们修改了之后就不会执行默认拦截器了，所以我们还要执行默认拦截器。 &lt;interceptor-ref name=&quot;defultStack&quot;&gt;&lt;/interceptor-ref&gt; 这里的defaultStack是struts在对默认拦截器的一个名称定义，直接引用不能改变。 如果我们需要让某些action不进行拦截，我们可以在使用拦截器时加入属性： &lt;param name=&quot;excludeMthods&quot;&gt;login&lt;/param&gt; struts常用标签库 s:property :使用OGNL表达式获取值栈的值。 s:iterator :使用OGNL迭代获取值栈中的值。 s:iterator :查看值栈的结构和数据。 struts的表单属性，struts对HTML表单属性都有封装，但一般不用，比如&lt;s:input type=”text”&gt; 最后虽然struts目前用的最少，但是最为SSH三大框架之一，了解一下还是有利于以后的工作。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://yoursite.com/tags/JavaEE/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"struts","slug":"struts","permalink":"http://yoursite.com/tags/struts/"}]},{"title":"javaScript深入解析3-类与行为委托","slug":"javaScript深入解析3-类与行为委托","date":"2019-07-19T14:11:44.000Z","updated":"2021-03-09T11:43:48.933Z","comments":true,"path":"2019/07/19/javaScript深入解析3-类与行为委托/","link":"","permalink":"http://yoursite.com/2019/07/19/javaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%903-%E7%B1%BB%E4%B8%8E%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/","excerpt":"JavaScript中“纠结的类”正如前文所说，JavaScript中并没有传统意义上的“类”，可能是因为在JavaScript这门脚本语言诞生之初，并没有人会他会有如今的成就，所以就借用了Self语言的基于原型的面向对象设计。具体可以看JavaScript的诞生","text":"JavaScript中“纠结的类”正如前文所说，JavaScript中并没有传统意义上的“类”，可能是因为在JavaScript这门脚本语言诞生之初，并没有人会他会有如今的成就，所以就借用了Self语言的基于原型的面向对象设计。具体可以看JavaScript的诞生 面向对象编程（OOP）面向对象编程是一种编程思想，其重要思维体现在： 封装性：讲一组方法，变量封装在一个“模块”中，一般来说是一个类。 继承性：继承性是面向对象技术中的另外一个重要特点，是指一个类继承另一个类的方法，类的继承。他们的关系通常是父与子的关系。 多态性：是指子类对父类的方法进行重写或重载。 对于传统的OOP语言，比如java，C++。 类意味着复制。 实例化时，他的行为会被复制到实例中；继承时，行为也会被复制到子类中。 JavaScript中的类JavaScript程序员开始大都是由其它语言程序员没经过系统学习这门语言的精髓就开始编程（因为大家认为JavaScript是一门脚本语言，是如此的简单。）所以从开始到现在，程序员们总是试图使用JavaScript来进行面向对象编程，寻找类这个东西的存在。然而不幸的是，JavaScript没有传统的类。还好我们拥有[[prototype]]这个好东西，我们才能进行所谓的面向对象编程。但这任然不是我们传统观念上的面向对象编程，即使是ES6中ECMA提供的class关键字，任然是[[prototype]]的原法糖。 detail在许多JavaScript库中都提供了类的语法糖，我们来看一下其内部是如何实现的。 类123456function Person(name)&#123; this.name = name;&#125;var tom = new Person('tom');var mike = new Person('mike'); 我们可以直接用new操作符进行“类的实例化”，但是JavaScript中不存在类。所以我们实际上是新创建了一个空对象，然后将其[[prototype]]设为Person.prototype。然后将该函数的this指向新建对象，然后调用该函数，如果函数没有返回对象，就返回新建对象。 继承下面是最典型的一种继承实现方式（JavaScript中多种实现继承的方式，但大同小异）： 1234567891011121314151617function Person(name)&#123; this.name = name; Person.prototype.me = function()&#123;console.log('Person')&#125;;&#125;function Student(name,id)&#123; //调用父级构造函数，相当于super Person.call(name); this.id = id; Student.prototype.onduty = function()&#123;console.log('Studnet')&#125;;&#125;//\"继承\"Student.prototype = Object.create(Person.prototype);var person0 = new Person('tom');var student0 = new Student('mike',123); 我们可以看出来，所谓的继承，也就是Student.prototype = Object.create(Person.prototype)这句话，实际上是将子类Student的[[prototype]]设置为一个空对象，该对象的[[prototype]]指向父级类Person的prototype。（Object.create(obj1)）的意义是创建一个空对象，该对象的[[proottype]]指向obj1首先我们需要了解的是，我们有4个对象(在JavaScript中函数也是对象，可以拥有自己的属性)来储存数据： student0 student0.proto ([[prototype]])（注意通过Object.create方式创建的__proto__并不指向Student.peototype） Student Student.prototype 根据原型链的查找规则，我们在获取实例的某个属性时，会分别从：student0 —&gt; student0.proto-&gt;Student-&gt;Student.prototype查找。 看下面的图： 我们可以看到，子类的属性在实例的__proto__中，父类的属性在实例的__proto__的__proto__中，因此我们可以获取子类，父类的所有方法，我们就完成就继承。 ES6的中类上面提过，ES6中的出现了class关键字，下面我们通过ES6的方法重写一下的例子： 12345678910111213141516171819202122class Person&#123; construct(name)&#123; this.name = name; &#125; speak()&#123; console.log(\"name:\"+this.name); &#125;&#125;class Student extends Person&#123; construct(name,id)&#123; super(name); this.id = id; &#125; me()&#123; console.log(\"name:\"+this.name); console.log(\"id:\"+this.id); &#125;&#125;var person0 = new Person();var student0 = new Student(); 这个看上去漂亮多了，就像是在写传统的OOP的语言。但是实际上，它的背后任然是混乱的[[prototype]]的链。 ES6的class还有一个常用的特点，静态方法。所谓静态方法，就是直接可以在类上面直接调用的方法。 1234567891011class Person&#123; construct(name)&#123; this.name = name; &#125; speak()&#123; console.log(\"name:\"+this.name); &#125; static sayme()&#123; console.log('me'); &#125;&#125; 想一下class背后的原理，用ES5的语法来实现以下static： 1Person.sayme = function()&#123;console.log('me');&#125; 没错，就是这么简单！只是因为这个方法是类自身的属性，并不是方法的[[prototype]]属性值。 混入(mixin)正如我们之前所说，传统的OOP意味着复制。 然而我们JavaScript中模拟的类，并不是传统的复制，而是基于原型链的“伪类”。 所以为了实现很真实的“类”，我们有了混入(mixin)这一概念。 显示混入看下面的例子： 123456789101112131415161718192021222324252627function mixin(sourceObj,tragetObj)&#123; for(var key in sourceObj)&#123; if(!(key in targetObj))&#123; targetObj[key] = sourceObj[key] &#125; &#125; return targetObj;&#125;var Vehicle = &#123; engines: 1, ignition: function()&#123; console.log(\"turn on my engine\") &#125;, drive: function()&#123; this.ignition(); console.log(\"Steering and move forward!\"); &#125;&#125;;var Car = mixin(Vehicle,&#123; wheel: 4, dirive: function()&#123; Vehicle.drive.call(this); console.log(\"Rolling on all\"+this.wheels+\"wheels!\") &#125;&#125;) ​没错，就是一次复制过程。现在我们也可以用： 1object.assign(targetObj,sourceObj); 因为这个方法的原理就是上面的mixin函数。 隐式混入思考下面代码： 1234567891011121314151617181920var something = &#123; cool: function()&#123; this.greeting = \"hello wowld!\"; this.count = this.count ? this.count++ : 1; &#125;&#125;Something.cool();something.greeting; //hello worldsomething.count; //1var Another = &#123; cool: function()&#123; something.cool.call(this); &#125;&#125;Another.cool();Another.greeting; //\"hello world\"Another.count; //1 (count不是共享的) 关键在于something.cool.call(this)，将something.cool函数的this指向了Another这个对象。因此，我们把Something的行为“混入”到Another中。 更合理的编程思想：行为委托类与委托的前世今生如我们前面所说，JavaScript本身是不存在类的，只是为了适应程序员们的设计习惯，我们使JavaScript中有了“类”的存在，实际上这种设计方式无疑是把吧苹果涂上橙色，在上面插上孔…然后把它装饰成橘子。但他始终都是苹果，无论我们怎么在外部伪装。既然如此，为什么我们不直接把它当成橘子来吃呢？ 如何使用行为委托看下面的例子： 123456789101112131415161718var Task = &#123; setId: fucntion(id)&#123;this.id = id;&#125;, outputID: function()&#123;console.log(this.id)&#125;&#125;var someWork = Object.create(Task);someWork.prepareTask = fucntion(id,label)&#123; this.setId(id); this.label = label;&#125;some.outputTaskDetails = function()&#123; this.outputId(); console.log(this.label);&#125;var someWork0 = Object.create(someWork); 在上面这段代码中，Task，someWork都不是类（或者函数），而是对象。我们把someWork的[[prototype]]委托给了Task。这很符合Self语言的基于原型的面向对象编程的思想。这也被成为“对象关联（OLOO）” 对象关联风格的代码还有一些不同之处。 在代码上，id和label数据成员都是直接存储someWork之上，而不是Task。 在类的思想上，我们鼓励方法的重写（多态）。也就上在子类中定义父类同名的函数。但在委托行为中恰恰相反，我们尽量避免在[[prototype]]链上存在同名函数。 Last不得不说，行为委托从语言底层来说更加适合JavaScript编程，但是越来越多的程序员习惯使用面向对象的编程思想。这迫使JavaScript不得不改变自己，比如在ES6中推出了class的语法糖，但这代表了官方的认可，也许在不久的将来，我们可以看见真正的class出现在JavaScript。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/%E7%B1%BB/"},{"name":"行为委托","slug":"行为委托","permalink":"http://yoursite.com/tags/%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/"}]},{"title":"javaScript深入解析2-原型及原型链","slug":"javaScript深入解析2-原型及原型链","date":"2019-07-18T12:05:44.000Z","updated":"2021-10-11T12:47:22.365Z","comments":true,"path":"2019/07/18/javaScript深入解析2-原型及原型链/","link":"","permalink":"http://yoursite.com/2019/07/18/javaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%902-%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"关于原型(prototype)原型可以说是JavaScript设计中最特殊，也可以说是最精髓的设计，他遍布整个JavaScript对象。几乎也是整个JavaScript技术的核心，只有熟悉了原型，才能充分理解JavaScript中的类与委托机制了。","text":"关于原型(prototype)原型可以说是JavaScript设计中最特殊，也可以说是最精髓的设计，他遍布整个JavaScript对象。几乎也是整个JavaScript技术的核心，只有熟悉了原型，才能充分理解JavaScript中的类与委托机制了。 whatQ：什么是原型呢？ A：在所有对象中都有一个特殊的[[Prototype]]属性，其实就是对其他对象的引用。几乎所有的对象在创建时[[Prototype]]都会被赋予一个非空的值。(注意，部分浏览器将该属性暴露出来，并命名为 __proto__) Q：什么是原型链呢？ A：如上所说，每一个对象都会有一个[[Prototype]]属性，然而[[Prototype]]属性引用的也是一个对象，这个对象同样也会含有[[Prototype]]属性，这样每一个对象就如同一个链节，一起就组成了一个链，我们称之为原型链。 whyQ：为什么要设计这样一个独特的机制呢？ A：或许不应该对存在这个问题如此深究，因为这可能是第一代开发人员的灵光一现，就有了这个特征。但实际上大都认为这是一门动态编译语言，或者说是脚本语言，所以没有设计类的概念，但为了填补这个概念，就有了原型。但谁也不知道JavaScript会在接下来的几十年中发展的如此蓬勃，程序员们多么希望JavaScript有OOP的概念，于是想方设法的使用原型链来模拟类的行为，但无论如何，就现在为止，JavaScript底层是没有类的概念的，包括ES6的类，任然是原型的语法糖。 how我们了解了什么是原型，为什么会存在原型之后，就要知道我们该如何使用它了。 创建对象我们来看一下创建对象的几种方法。 let obj = {num : 0} let obj = new Object({num : 0}) 或者var obj = Object({num : 0}) let construt = function(){this.num = 0} =&gt; let obj = new construct() let obj0 = {num : 0} =&gt; let obj1 = Object.create(obj0) 这几种方法创建的对象有所不同，我们还是来解析一下： 1,2：字面量方法，创建的是一个普通对象，其[[Prototype]]指向Object.prototype（大部分对象的原型链最后都指向它）。 3：new操作符： 当我们看到new操作符，一定会想到类，但是JavaScript中的new操作符与传统OOP语言中的new完全不同，JavaScript中的new只是将函数当成一个构造函数来调用。如同上一篇中所说，JavaScript中所有的函数都一样，不存在本质的构造函数，只有被new调用的函数就是构造函数。我们在回顾一下new操作符的执行过程： 123456789function C(name)&#123; this.name = name;&#125;let obj = new C('mw');console.log(obj);//C &#123;name:'mw'&#125;//此时obj的__proto__指向的是C.prototype 创建一个新的对象 将新对象的[[prototype]]设为C.prototype 将新对象设为函数调用的this 如果函数没有返回其他对象，则new操作符调用的函数会自动返回这个新对象，否则则会直接返回函数内的对象 4: 使用Object.creat()函数来创建对象，实际上是创建了一个新对象，然后将其[[Prototype]]设置为对应对象，如果不加参数，则[[Prototype]]为Object对象。 1234let a = &#123;num : 0&#125;;let b = Object.create(a);console.log(b.__proto__);//&#123;num:0,__proto__:Object&#125; 属性获取，设置与屏蔽当我们有了一个对象，我们可能会对他们做一些操作，比如，[[get]],[[set]],或者seal,freeze等等操作。那么这个过程又是什么样的呢？ 我们提前需要了解的是：每一个对象的每一个属性都是具有属性描述： 数据属性 configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。 enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。 writable：表示能否修改属性值。默认为true。 value： 包含这个属性的数据值，读属性时，从这个位置读；写属性的时候，把新值保存在这个位置。默认为undefined。 访问器属性 configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。 enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。 get：读取属性时调用的函数。默认为undefined。 set：写入属性时调用的函数。默认为undefined。 值得注意的是： 官方来说，只能通过Reflect.defineProperty(obj,proName,proValue)，但是Firefox在最开始指定了__defineGetter__，__defineSetter__，后期Chrome，Opera，Safari也实现了该方法。 在defineProperty()中get,set不能与writable，value，同时设置。 在ES6中，将Object中的很多方法(包括defineProperty…)都放到了Reflect对象中，虽然Object任然包含该方法，但建议使用Reflect对象。 属性获取与屏蔽思考一下下面的代码： 1234let obj = &#123;num : 0&#125;;let str = obj.toString();console.log(str);//\"[object Object]\" 首先我们需要思考的是，我们并没有在obj上定义toString方法，为什么我们能够调用，并且得到一个结果(虽然并不那么漂亮)，我想你肯定猜到了，那是因为obj的原型对象Object拥有这个方法。所以，我们在或得一个对象的值时，是从链的底端开始查找，顺着原型链，一直查到顶端，如果不存在，返回undefined或者error。如果存在，则返回这个值。也就是说，我们能够在一个对象中查找到值，并不代表该对象含有该值，很有可能是该对象的原型链上的某个原型对象含有该值。 思考下面的代码： 12345let a = &#123;getString:function()&#123;return 'from a'&#125;&#125;;let b = Object.create(a);b.getString = function()&#123;return 'from b'&#125;;console.log(b.getString()); 结果是什么呢？hava a try! 没错，结果是’from b’ 这就是我们所说的属性屏蔽，这一切的根源在于：我们是从链底查到链顶的，所以下层的同名属性会优先被获取，一旦引擎获取到该属性，则遍历结束，不会再向下查找。 属性设置与屏蔽当我们为一个对象的键赋值时，会发生三种情况： eg： 12let obj = &#123;&#125;;obj.name = 'value' 如果在[[Prototype]]链上存在名为name的普通数据访问值，并且被标记为可写(writale:true)(默认即为true)，那就会直接在obj上添加一个名为name的新属性，它就是屏蔽属性。 如果在[[Prototype]]链上存在名为name的普通数据访问值，但是该属性被标记为只读，(writable:false)，那么无法修改已有属性或者在obj上创建屏蔽属性。如果在严格模式下，会抛出一个错误；否则会忽略该语句。总之，不会发生屏蔽。 如果在[[Prototype]]链上存在name并且它是一个setter。那就一定会调用这个setter。name不会被添加到obj上，也不会重新定义setter。 屏蔽的发生也许不像我们通常认为，还要联系对象属性的描述符来确定！我们需要记住。 隐式屏蔽正如类型转换一样，同样存在隐式屏蔽，只要操作对象的属性，都有可能发生隐式屏蔽。 比如： 123let obj0 = &#123;num:0&#125;;let obj1 = Object.create(obj0);obj1.num++ //这里发生了隐式屏蔽！！！ 只要是[[set]]，都有可能发生隐式屏蔽 修改[[Prototype]] Object.create()，该方法是最适用的方法。即在创建时就设置其prototype。 123let obj0 = &#123;num:0&#125;;let obj1 = Object.create(obj0);//将obj0设置为obj1的prototype Object.setPrototypeOf()，该方法是ES6新增的方法。 1234let obj0 = &#123;num:0&#125;;let obj1 = Object.create(obj0);Object.setPrototypeOf(obj0,obj1);//把obj1设置为obj0的protoype 构造函数方法 123let F = function()&#123;this.a = 123&#125;;let obj = &#123;&#125;;obj.prototype = new F(); 回顾一下上面new操作符，就能想明白。 检测原型链我们又该如何检测对象的原型连上存在哪些原型对象呢？ instance操作符 123let obj = &#123;&#125;;console.log(obj instance Object);true __proto__属性，如上所说，大多数浏览器实现了__proto__(在ES6中加入了标准)，在兜底情况时，可以使用这种方法检测。 Last理解清楚原型链，我们才能清楚理解后面的委托，“类”等等。所以这一部分是基础。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"原型链","slug":"原型链","permalink":"http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"javaScript深入解析1-this关键字","slug":"javaScript深入解析1-this关键字","date":"2019-07-17T03:44:15.000Z","updated":"2021-03-08T03:38:53.592Z","comments":true,"path":"2019/07/17/javaScript深入解析1-this关键字/","link":"","permalink":"http://yoursite.com/2019/07/17/javaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%901-this%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"前言花了三天时间粗略看完了《你不知道的JavaScript》下部，这一部分介绍了ES6的部分内容（本书出版时ES7,8）的部分特性还未推出，因为之前已经学过ES6，所以这一遍只是温习和关注细节，感觉除了新增的特征，迭代器应该是最重要的部分，因为ES6的很多特性都用到了迭代器，包括 扩展运算符(spread)‘[…]’，泛数组的迭代(for..of循环，keys(),values(),entries()等等),其次就是Promise，这个特性用的也很多，特别是在异步操作上，配合生成器(function */)，迭代器(iterator),就是async异步函数的底层实现。 关于thisthis关键字作为JavaScript开发者必须理解的概念之一，其实并没有那么高深。 whatQ：什么是this？A：this代表的是函数运行的上下文环境。","text":"前言花了三天时间粗略看完了《你不知道的JavaScript》下部，这一部分介绍了ES6的部分内容（本书出版时ES7,8）的部分特性还未推出，因为之前已经学过ES6，所以这一遍只是温习和关注细节，感觉除了新增的特征，迭代器应该是最重要的部分，因为ES6的很多特性都用到了迭代器，包括 扩展运算符(spread)‘[…]’，泛数组的迭代(for..of循环，keys(),values(),entries()等等),其次就是Promise，这个特性用的也很多，特别是在异步操作上，配合生成器(function */)，迭代器(iterator),就是async异步函数的底层实现。 关于thisthis关键字作为JavaScript开发者必须理解的概念之一，其实并没有那么高深。 whatQ：什么是this？A：this代表的是函数运行的上下文环境。Detail： 在所有语言中，都有一个调用栈的概念，即函数被哪个对象所调用（注意JavaScript中对象的概念，几乎所有的方法，参数都有一个宿主对象，其中顶层对象在浏览器中window，在node中则为global）。所以我们再执行一个函数或调用一个变量时，默认是带有一个顶层对象前缀的，不过由于我们所有的代码都在该对象中，则可以省略，不信可以试一下： 123var num = 0;console.log(num);console.log(window.num); 没错，它们的结果都是0。 回归正题，所以粗略的来说，函数被调用的对象即为他的this指向(先不谈硬绑定)，最简单的例子： 12345678var obj = &#123; num : 0, func: function()&#123; console.log(this.num); &#125;&#125;obj.func(); 执行结果是什么呢？没错，是0；因为这里的func函数由obj调用，所以this指向obj。OK,那么再看一下下面这段代码： 12345678910var num = 0;var obj = &#123; num : 1, func: function()&#123; console.log(this.num); &#125;&#125;var outterFunc = obj.func;outterFunc(); 执行结果又是什么呢？have a try!可能出乎你的意料，结果是0.So,why?思考一下我们上面的解释。 没错，也许你想通了，因为这时候的func函数并不是通过obj来调用的，所以this默认指向window，但window中num变量为0，所以结果是0. 在这之中，我们需要了解的是：在JavaScript中，函数，对象，数组，或者说所有对象即对象的子类（因为包括函数，数组皆为对象的子类）都是通过地址的形式存储，类似与C语言中的指针形式存储 思考下面代码： 1var func = function()&#123;console.log(123)&#125; 在JavaScript引擎中时如何运行完这条语句的呢？（你需要了解的是JavaScript不是一门预编译语言，而是一门解释执行的语言（即执行一句，编译一句，当然这是不完全正确的，从变量提升即可以看出来）） 查询是否存在func这个变量—否 声明这个变量 定义函数function(){console.log(123)} 将该函数存储于内存中，并取得其地址 将该地址赋值给func变量 所以func变量实际存储的是该函数的地址。所以函数实际上是没有存储作用域链中的任何信息，它总是一个独立存在的个体。这也就解释了为什么func虽然定义在obj中，但是通过某种方式提取出来后直接调用其this就指向了window。 所以你大概已经明白了了吧，思考一下下面的代码： 12345678910111213var num = 0;function inner()&#123; console.log(this.num)&#125;function outter()&#123; var num = 1; inner();&#125;outter(); 所以，结果是什么呢？ 我猜你肯定答对了，是0； 同样的道理，inner函数虽然在outter函数中被调用，但任然是直接调用，没有任何前缀对象，所以其this指向任然是window。 最后一个例子： 123456789101112var name = \"clever coder\"; var person = &#123; name : \"foocoder\", hello : function(sth)&#123; var that = this; var sayhello = function(sth) &#123; console.log(that.name + \" says \" + sth); &#125;; sayhello(sth); &#125; &#125; person.hello(\"hello world\");//foocoder says hello world 这里内层函数this指向的任然是window，有人认为是JavaScript的设计错误，但是从上面内存的角度去分析，会发现这是正确的。 why &amp; where说了这么多this，那么为什么要用this呢？又在哪里用呢？ Q：why？ A：this的使用使调用上下文对象变得更加简洁，否则，每次调用函数必须传递上下文对象，编码将及其复杂。 Q：where？ A：相信接触过OOP（面向对象编程）的同学应该熟悉这个结构(伪代码)： 123456789Class Example&#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125;&#125;declare instan = new Example('tom',23); 没错，这是一个基本类的构造，只包括了一个constructor构造器方法，其中的this指向的即是这个被实例化的对象(instan),则instan的name属性为’tom’，age属性为23。试想没有this的话，构造器该如何为实例属性赋值呢？只有显式的将instan传递给constructor函数，这将变得无比繁杂。 在js中，不仅是在类，即使是用行为委托方式编码，任然离不开this，因为总是存在对上下文对象的应用。 值得注意的是：JavaScript语言基础中并没有class的概念，即使ES6推出了class关键字，但它任然是使用原型链对类的模拟，任然是ES5部分框架class实现的语法糖 how说了那么多，还是要详细讲一下this的绑定问题： 默认绑定 独立函数调用执行默认绑定。 123456789var a = 0;function func()&#123; console.log('a:'this.a);&#125;func();//a:0 如上面我们所说，这里的func是直接的函数调用，所以执行默认绑定，this指向了window对象。 值得注意的是：在strict模式下，默认绑定this为undefined 12345678910var a = 0;function func()&#123; \"use strict\" console.log('a:'+this.a);&#125;func();//Uncaught TypeError: Cannot read property 'a' of undefined 隐式绑定 这就是我们之前熟悉的用对象来调用函数： 12345678910var obj = &#123; num : 0, func: function()&#123; console.log('num:'+this.num); &#125;&#125;obj.func();//num:0 当含有多层对象引用的时候，只有距函数最近的一个对象为上下文对象 123456789101112131415var obj0 = &#123; num : 0, func: function()&#123; console.log('num:'+this.num); &#125;&#125;var obj1 = &#123; num:1, obj0:obj0&#125;obj1.obj0.func()//num:0 正如我们之前所说的，函数的存储与上下文对象毫无关系，所以，当我们将对象中的函数通过某种方法提取出来时，它就与原来的对象毫无关系了，其this指向则为window了（这种现象一般被称为隐式丢失）。具体可以看上面那个例子。 显示绑定 所谓显示绑定，即通过call(),apply(),以及ES6的bind()函数直接指定this的指向。 12345678910111213var a = 0;var obj = &#123; a: 1&#125;function func()&#123; console.log(this.a);&#125;func.call(obj);//1 值得注意的是：call(),apply()函数的绑定是软绑定，即只在绑定这一次起作用，下一次调用时this任然执行原有绑定规则。 所以就衍生出了硬绑定，ES6之前需要手动封装硬绑定方法： 12345678function bind(fn,obj)&#123; return function()&#123; return fn.apply(obj,arguments) &#125;&#125;//执行此方法后，函数的this指向将被永久绑定在指定对象上，无法修改。 由于这个方法需求太广泛了，所以ES6推出了官方的bind()方法，直接调用即可。 new绑定 与其他语言中构造函数的特殊性不同，在JavaScript中，构造函数是一个普通的函数，唯一的特殊点是它在执行new操作符后自动调用，并且开始执行一系列操作： 创建一个新的对象 这个新对象会被执行[[prototype]]连接(即将__proto__指定为函数的prototype)。 这个对象将会被绑定到对应的函数的this。 如果函数没有返回其他对象，那么new表达式中函数调用会自动返回这个新对象。 第四步解释： 12345678910function Fun()&#123; return &#123; b:2 &#125;&#125;var instan = new Fun()//&#123;b:2&#125; 优先级 如果是new绑定，则this按上面的规则绑定对象。 如果是显示绑定，则this指向显示绑定的对象。 如果有隐式绑定，则this绑定在调用对象上。 否则执行默认绑定，非严格模式下为window，严格模式下位undefined。 箭头函数 =&gt;在ES6中，新加了一种声明函数的方式，箭头函数(=&gt;) 1()=&gt;&#123;&#125; 等价于 function()&#123;&#125; 关于箭头函数的特性就不具体细讲，他与this相关的就是：箭头函数的this决定于定义函数时的外层作用域来决定： 12345678910111213141516//arrayFunc var a = 0; //定义全局变量a function fun() &#123; return (arrayFunc = ()=&gt;&#123; console.log(this.a); &#125;)()//这是一个立即执行函数，也可以在外围多调用一次 &#125; var obj = &#123; a : 1, func: fun() &#125; fun.call(obj);//将fun的this指向obj //1 由于fun的this指向obj，而箭头函数的this根据外围函数的this决定，所以arrayFunc的this也指向obj，则a为1。 123456789101112131415//normal var a = 0; function fun() &#123; return (function normalFunc()&#123; console.log(this.a); &#125;)() &#125; var obj = &#123; a : 1, func: fun() &#125; fun.call(obj); //0 这里普通函数的this根据调用的对象来确定，由于它是单独调用的，所以this指向window，则a为0。 Lastthis的用法相当重要，不管是自己原生开发，或是用框架，特别是使用框架时，由于一般框架会有一个App实例，我们的操作都在这个实例之中进行，所以会无数次用到this，所以我们必须学通。下一期写一下Protype原型链，也是JavaScript中相当重要的一个内容。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"this关键字","slug":"this关键字","permalink":"http://yoursite.com/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"Promise理解","slug":"Promise理解","date":"2019-06-28T13:57:55.000Z","updated":"2021-01-29T07:22:03.607Z","comments":true,"path":"2019/06/28/Promise理解/","link":"","permalink":"http://yoursite.com/2019/06/28/Promise%E7%90%86%E8%A7%A3/","excerpt":"唠唠叨叨最近考试比较多，终于快结束了，间隙时间，我第一遍看了《你不知道的JavaScript》的上中篇，说实话，可能是因为译本的原因，也可能是知识比较深入，我感觉比较难理解，有时感觉一小节讲完，发现他的中心观点只有一句话。但总的来说，这是套值得深入研读的书籍，暑假我将再次研读。","text":"唠唠叨叨最近考试比较多，终于快结束了，间隙时间，我第一遍看了《你不知道的JavaScript》的上中篇，说实话，可能是因为译本的原因，也可能是知识比较深入，我感觉比较难理解，有时感觉一小节讲完，发现他的中心观点只有一句话。但总的来说，这是套值得深入研读的书籍，暑假我将再次研读。 Promise的神秘面纱ES6的知识点着实比较庞大，除了对Number，Array等的扩展。Promise这个概念也很吸引人。比如著名的axios就是采用Promise来封装的。 我在《你不知道的JavaScript》中看到一个比较形象的比喻，当你去买一个汉堡包，你先把钱给服务员，然后服务员会给你一个凭证，在这个汉堡包被完成之前，凭证即代表了你的汉堡包。一段时间过后，服务员通知你结果。但这是服务员可能会对你说：‘Sorry Sir,hamburger has sold out…’这种失败的结果即为Promise中的reject。但大多数情况下，我们期望并得到的结果是一个汉堡包 （ solved）。 也就是说：Promise是一个容器，里面保存着未来才会结束的事件（通常是一个一步操作）的结果。 Promise的特点 Promise的状态不收外界的影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise的基本用法 12345678910111213141516//定义promisevar promise = new Promise(function(resolve,reject) &#123; var res = asycFunc(); if(res.code 满足条件)&#123; resolved(res.data); &#125;else&#123; reject(res.data) &#125;&#125;)//调用promise//1(不推荐). promise.then(res =&gt; &#123;show(res)&#125;,err=&gt;(handleError(err)))//2(推荐). promise.then(res =&gt; &#123;show(res)&#125;).catch(err =&gt; &#123;handleError(err)&#125;) 第二种的好处在于，1.采用链式的写法可以捕获前一个then抛出的错误，而一then中同时写resolve与reject无法做到。2.在语法上更人性化，类似于try…catch…语法。但实际catch = then(null,rejection).都是捕获产生的错误，包括rejected，Error；对于错误，还有一点值得注意的是，reject或者resolve即代表这个promise状态的冻结。类似于函数的return，这两个语句一旦发生，其后面所有的语句都将无效。即使是抛出错误，也无法再被catch所捕获。 Promise的链式玩法 前面的then…catch…其实已经是链式的写法了。 Promise有3个函数可以链式调用。分别是 then(func(reslved,rejected){...}): 为Promise实例添加状态改变时的回调函数。 catch(func(err){...}): 用于指定发生错误时的回调函数。包括rejected也被他处理。 finally(func(){...}): 无论状态如何，是否抛出错误。都将执行该回调。 但其能够一直链式调用的原因是：这3个函数每次调用都会产生一个新的Promise对象，并且这个新的promise会将旧的promise返回值作为参数，这个对象又包含了这3个方法，所以可以一直链式调用。 Promise的高级玩法（模式） Promise.all([p1,p2,…]) 说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为： a. 所有的Promise的值变为resolved时，该对象才返回resolved，并返回所有的结果。b. 一旦有一个Promise对象返回rejected，则整个对象返回rejected，并返回错误原因。 由Promise封装的axios中，有axios.all([re1,re2,…])方法 Promise.race([p1,p2,…]) 说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为： a. 当第一个Promise返回resolved时，整个Promise状态变为resolved，并返回第一个Promise resolved的结果，一旦有任何一个Promise决议为拒绝，他就会拒绝。 值得注意的 Promise.all在传入空数组时，会立即返回resolved；但Promise.race会被一直挂起。所以不要想Promise.race中传递空数组。希望ECMA会尽快修改这一点。 一些骚操作 在《你不知道JavaScript》一书中，提出来一些ES6标准之外的Promise模式之外的一些扩展模式，比如： Promise.none([...]):与Promise.all的情况互换，即所有的Promise都rejected才rejected。反之则返回resolved。 Promise.any([...]):与race相对，该模式忽略rejected，得到第一个resolved。 Promise.first([...]):这个模式类似与any([…])的竞争，，即只要第一个Promise完成，他就会忽略有序的任何拒绝和完成。 Promise.last([...]):这个类似与first([…]，但确实最后一个完成胜出。 示例：Promise.first([...])的实现 //polyfill安全的guard检查 if(!Promise.first){ Promise.first = function(prs){ //返回最终的Promise对象 return new Promise(function(resolve,reject){ //把所有的Promise循环一次 prs.forEach(function(pr){ //把值规整化，并且不管哪个先完成，就决议组Promise Promise.resolve(pr).then(resolve); }) }) } } Promise的实际应用 异步加载图片 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; 异步Ajax 1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 最后Promise着实避免了回调函数的一些缺陷，并且它的使用也越来越广泛，包括后面的async异步函数，也是利用Promise来完成的，因此，这里简单的了解一下Promise还是很有必要的。 2021年1月18日补充概念 其在新建时就开始立即执行，一旦完成，其状态就会”凝固“。 “凝固”过后其状态就不会发生改变，并且与事件不同的是，其可以随之被监听，即： 1234567891011const p1 = new Promise(resolve, reject)&#123; setTimeout(()=&gt;&#123;resolve(1)&#125;, 3000)&#125;p1.then((res) =&gt; &#123; console.log(`$&#123;res&#125;--第一次获取`)&#125;)p1.then((res) =&gt; &#123; console.log(`$&#123;res&#125;--第二次获取`)&#125;) 第一个结果为：1—第一次获取 第二个结果为：1—第二次获取 注意：这两次执行都会在3秒过后执行，并且都会执行；这里区别于普通事件，一旦错过，就无法再监听到了。但是Promise在操作完成后会凝固状态，无论后面在什么时候进行监听（定义其then函数）都会被执行。 以实现的接口 Promise.all([p1, p2, p3])，其返回结果分为两种： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 注意：注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [\"hello\", Error: 报错了] Promise.race([p1, p2, p3])：上面代码中，只要p1、p2、p3之中有一个实例率先改变状态（无论是fulfilled还是reject），p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 下面这个即利用这个特性完成请求超时： 12345678910const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); Promise.allSettled(p1, p2, p3)：方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。 123456789101112const resolved = Promise.resolve(42);const rejected = Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123; console.log(results);&#125;);// [// &#123; status: 'fulfilled', value: 42 &#125;,// &#123; status: 'rejected', reason: -1 &#125;// ] Promise.any(p1, p2, p3)：该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。（与all相反） 1234567891011const promises = [ fetch('/endpoint-a').then(() =&gt; 'a'), fetch('/endpoint-b').then(() =&gt; 'b'), fetch('/endpoint-c').then(() =&gt; 'c'),];try &#123; const first = await Promise.any(promises); console.log(first);&#125; catch (error) &#123; console.log(error);&#125; Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。 捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。 12345678Promise.any(promises).then( (first) =&gt; &#123; // Any of the promises was fulfilled. &#125;, (error) =&gt; &#123; // All of the promises were rejected. &#125;); 下面是一个例子。 1234567891011var resolved = Promise.resolve(42);var rejected = Promise.reject(-1);var alsoRejected = Promise.reject(Infinity);Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123; console.log(result); // 42&#125;);Promise.any([rejected, alsoRejected]).catch(function (results) &#123; console.log(results); // [-1, Infinity]&#125;); Promise.resolve()：有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function (value) &#123; console.log(value); // 42&#125;); 上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出42。 参数不是具有then()方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。 123456const p = Promise.resolve('Hello');p.then(function (s) &#123; console.log(s)&#125;);// Hello 上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。 Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 Promise.reject()：会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 12345Promise.reject('出错了').catch(e =&gt; &#123; console.log(e === '出错了')&#125;)// true 上面代码中，Promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。 目前Chrome(87)中的以实现上述方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"杂记兼第一个开源项目","slug":"杂记兼第一个开源项目","date":"2019-05-19T16:00:30.000Z","updated":"2019-05-19T16:02:46.292Z","comments":true,"path":"2019/05/20/杂记兼第一个开源项目/","link":"","permalink":"http://yoursite.com/2019/05/20/%E6%9D%82%E8%AE%B0%E5%85%BC%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","excerpt":"碎碎念最近过完了第一遍《JavaScript高级程序设计》，有两个感觉 JavaScript体系还是很巨大，值得深入挖掘 这本书太过老旧，我看了一下第一版是在2012年发行，最近一次修订是在2019年，但这一次修订并没有大范围修改书中的内容，仅仅添加了部分ES6的内容，并且ES6还是不是正式版，其中的ArrayType在正式版ES6中并没有实现。","text":"碎碎念最近过完了第一遍《JavaScript高级程序设计》，有两个感觉 JavaScript体系还是很巨大，值得深入挖掘 这本书太过老旧，我看了一下第一版是在2012年发行，最近一次修订是在2019年，但这一次修订并没有大范围修改书中的内容，仅仅添加了部分ES6的内容，并且ES6还是不是正式版，其中的ArrayType在正式版ES6中并没有实现。 虽然如此，总体来说这本书还是非常有价值的，深入的讲解了JavaScript，包括组成部分，ECMAScript+BOM+DOM,HTMLDOM与XML的关系这些以前比较少了解的东西，还有原型链，作用域，实现继承等老生常谈的东西。感觉这本书还是要多刷几次，暑假回家配合《你不知道的JavaScript》二刷，去研究更细微的东西。 第一个开源项目：PageWindow一直在学习，做工程项目，想想也该是时候做一点开源项目，让明年面试更有利一点~ 这个项目使我一直想做的，其实很简单，就是实现页面上模拟windows窗口，好像目前是有这种东西，但我是想将其封装成一个UI库。进而实现伪多任务。 这里主要就是涉及DOM操作。包括鼠标操作比较多： mousedown mouseup mousemove click 第一个demo遇到就是阻止冒泡与阻止默认事件 阻止冒泡 e.stopPropagation() 标准W3C方法 e.cancelBubble = true IE专用，但chrome，firefox也实现了属性 阻止默认事件 e.preventDefault() 标准W3C e.returnValue = false IE专用，但chrome，firefox也实现了属性","categories":[{"name":"pageWindow","slug":"pageWindow","permalink":"http://yoursite.com/categories/pageWindow/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"},{"name":"pageWindow","slug":"pageWindow","permalink":"http://yoursite.com/tags/pageWindow/"}]},{"title":"项目实际问题一:对象深浅拷贝问题","slug":"项目实际问题一-对象深浅拷贝问题","date":"2019-05-18T00:32:35.000Z","updated":"2021-10-13T09:57:32.120Z","comments":true,"path":"2019/05/18/项目实际问题一-对象深浅拷贝问题/","link":"","permalink":"http://yoursite.com/2019/05/18/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E4%B8%80-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98/","excerpt":"第一次经手比较大型的项目，总结第一个问题：对象的深拷贝问题。之前没注意这个问题，写完代码发现总是与自己的想法不符合，经调试才发现是对象的深浅拷贝问题。 原理的话也很简单，对象作为基本类型之外的引用类型，在栈内存中保存着引用变量的名字，而这个变量保存的实际是一个地址，这个地址指向堆内存，实际这个变量的值是保存在堆内存中。 所以当我们直接用 “=” 进行变量copy时，实际copy的是对内存中的地址。copy之后改变原变量的值同样会使新变量的值进行改变。所以有时候我们需要进行深拷贝来在堆内存中开辟一个新的内存空间来放置副本，切断新旧变量之间的联系。","text":"第一次经手比较大型的项目，总结第一个问题：对象的深拷贝问题。之前没注意这个问题，写完代码发现总是与自己的想法不符合，经调试才发现是对象的深浅拷贝问题。 原理的话也很简单，对象作为基本类型之外的引用类型，在栈内存中保存着引用变量的名字，而这个变量保存的实际是一个地址，这个地址指向堆内存，实际这个变量的值是保存在堆内存中。 所以当我们直接用 “=” 进行变量copy时，实际copy的是对内存中的地址。copy之后改变原变量的值同样会使新变量的值进行改变。所以有时候我们需要进行深拷贝来在堆内存中开辟一个新的内存空间来放置副本，切断新旧变量之间的联系。 方法对象的深拷贝适用于所有类型的对象（含数组） JSON.parse(JSON.stringfy(Object)) Point:这是最简单的进行深拷贝的方法，其原理是先将其转换为JSON字符串，此时就不在存在原变量的堆地址，而是以字符串-基本变量保存在栈地址中。再将其转换回对象，则是一个完全与原变量无关的新变量。但是该方法会丢失对象所有的函数属性，undefined，以及会重置原型对象为Object(),或Array(),如果没修改多原型对象，则没有影响。 递归遍历对象 1234567891011121314//只能clone Object和Arrayfunction deepClone1(obj) &#123; //判断obj是否是引用类型 if(obj &amp;&amp; typeof obj === \"object\")&#123; let newObj = Array.isArray(obj) ? [] : &#123;&#125; for(let i in obj)&#123; newObj[i] = deepClone1(obj[i]) &#125; return newObj &#125;else&#123; //如果不是引用类型则直接返回该值 return obj &#125;&#125; } 使用lodash库中的cloneDeep()函数，其原理与上述原理一样，但健壮性更高。 适用于简单对象 Object.assign() eg: const obj = { a: 1 }; const copy = Object.assign({}, obj); console.log(copy); // { a: 1 } Point:该方法只适用于由基本数据类型组成的对象，不能用于对象键或值包含引用类型，否则任然是浅拷贝。同时，该函数会忽略undefined与null值（可以用来过滤无效值） 使用于简单数组 Array.slice(startPositong,endPositon) Array.contact(arr1,arr2) array.splice(startPositon,delteteNum,addArr1,addArr2...) 数组的迭代方法：Array.every(),Array.filter(),Array.map() Point:使用以上方法，必须是由基本数据类型组成的数组，数组项不能包含引用类型，否则任然是浅拷贝！！！ Final以上方法都只会转化可枚举项，对于不可枚举项，都是默认忽略的。 综上，JSON.parse(JSON.stringfy(obj))应该算是最简单且最易用的方法了，并且原生代码的效率相较于JS也会有优势，所以，如果仅仅为了深拷贝，没有其他需求，该方法是比较好的方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"深拷贝","slug":"深拷贝","permalink":"http://yoursite.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"}]},{"title":"项目部署引发的知识","slug":"项目部署引发的知识","date":"2019-04-09T13:38:21.000Z","updated":"2021-10-14T07:06:20.375Z","comments":true,"path":"2019/04/09/项目部署引发的知识/","link":"","permalink":"http://yoursite.com/2019/04/09/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%BC%95%E5%8F%91%E7%9A%84%E7%9F%A5%E8%AF%86/","excerpt":"项目部署之前一直在写东西，都没怎么部署过项目，特别是Linux系统下，本来之前买服务器是想买一个Linux的服务器的，然而，学生党只配用Windows，万恶的阿里云。现在又可以买Linux的了，然而我又不想重新布属我的项目。今天再部署Linux时，才发现完全不会。枯了~ git命令开发最常用命令 git init //初始化一个git文件夹 git remote add origin https://gitee.com/mw530/xxx //为本地仓库添加远程仓库 git status //查看项目状态 git add . //把所有修改文件推送到stage中 git commit -m des(描述) git push //推送到默认分支 git push origin master(本地分支名) : master(远程仓库名) 常用命令 git config –global user.name “Tocy” //配置用户名 git config –global user.email zyvj@qq.com //配置邮箱 git clone 仓库地址 //将远程仓库拉至本地 git add 文件名 //将某一文件提交至stage git diff //查看当前目录的所有修改 git remote add [short_name] [url] //添加远程仓库 git branch //列出所有分支 -* 本地 -r 远程 -a 本地与远程 git branch [branch-name] //新建一个分支，但仍然留在当前分支 git branch -d [branch-name] //删除该分支 git checkout -b [branch-name] //新建并切换到该分支 git checkout [branch-name] //切换到该分支 git checkout [file] //恢复暂存区的指定文件到工作区 git checkout . //恢复暂存区的所有文件到工作区 分支管理 git merge –no-ff develop //将develop合并到当前分支 –no-ff(no-fast forward)的含义：当两个分支之间存在先后关系时，若合并分支在当前分支之后，则git只会移动指针，使当前分支指向被合并分支，这个过程被称为快速合并。而禁止快速，即–no-ff则会在当前分支新建一个提交来存放这一次develop的提交。","text":"项目部署之前一直在写东西，都没怎么部署过项目，特别是Linux系统下，本来之前买服务器是想买一个Linux的服务器的，然而，学生党只配用Windows，万恶的阿里云。现在又可以买Linux的了，然而我又不想重新布属我的项目。今天再部署Linux时，才发现完全不会。枯了~ git命令开发最常用命令 git init //初始化一个git文件夹 git remote add origin https://gitee.com/mw530/xxx //为本地仓库添加远程仓库 git status //查看项目状态 git add . //把所有修改文件推送到stage中 git commit -m des(描述) git push //推送到默认分支 git push origin master(本地分支名) : master(远程仓库名) 常用命令 git config –global user.name “Tocy” //配置用户名 git config –global user.email zyvj@qq.com //配置邮箱 git clone 仓库地址 //将远程仓库拉至本地 git add 文件名 //将某一文件提交至stage git diff //查看当前目录的所有修改 git remote add [short_name] [url] //添加远程仓库 git branch //列出所有分支 -* 本地 -r 远程 -a 本地与远程 git branch [branch-name] //新建一个分支，但仍然留在当前分支 git branch -d [branch-name] //删除该分支 git checkout -b [branch-name] //新建并切换到该分支 git checkout [branch-name] //切换到该分支 git checkout [file] //恢复暂存区的指定文件到工作区 git checkout . //恢复暂存区的所有文件到工作区 分支管理 git merge –no-ff develop //将develop合并到当前分支 –no-ff(no-fast forward)的含义：当两个分支之间存在先后关系时，若合并分支在当前分支之后，则git只会移动指针，使当前分支指向被合并分支，这个过程被称为快速合并。而禁止快速，即–no-ff则会在当前分支新建一个提交来存放这一次develop的提交。 Linux安装node.js 到根目录 cd ~ 建一个文件夹 mkdir deploy 下载node包 wget https://nodejs.org/dist/v10.11.0/node-v10.11.0-linux-x64.tar.xz 解压node包 tar zf node-v10.11.0-linux-x64.tar.xz 重命名包 cd node-v10.11.0-linux-x64.tar.xz/bin &amp;&amp; ls 查看node,npm的版本 ./node -v ./npm -v 设置环境变量 vim ~/.bash_profile 在文件尾部添加以下内容 export NODE_HOME=/deploy/node-v8.11.3-linux-x64 export PATH=$PATH:$NODE_HOME/bin 退出vim: 按 esc 输入:wq enter 退出 保存profile文件 source /etc/profile 将目录软链接到全局环境下（命令后面的/usr/local/bin/node是固定的） ln -s /deploy/node-v8.11.3-linux-x64/bin/node /usr/local/bin/node ln -s /deploy/node-v8.11.3-linux-x64/bin/npm /usr/local/bin/npm 检验安装是否成功 node -vnpm -v 安装Nginx 安装yum npm install yum 安装依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 下载Nginx //创建一个文件夹 cd /usr/local mkdir nginx cd nginx //下载tar包 wget http://nginx.org/download/nginx-1.13.7.tar.gz tar -xvf nginx-1.13.7.tar.g 安装Nginx //进入nginx目录 cd /usr/local/nginx //执行命令 ./configure //执行make命令 make //执行make install命令 make install Nginx常用命令 //测试配置文件 安装路径下的/nginx/sbin/nginx -t //启动命令 安装路径下的/nginx/sbin/nginx //停止命令 安装路径下的/nginx/sbin/nginx -s stop 或者 : nginx -s quit //重启命令 安装路径下的/nginx/sbin/nginx -s reload //查看进程命令 ps -ef | grep nginx Nginx虚拟域名配置及测试验证 //编辑nginx.conf sudo vim /usr/local/nginx/conf/nginx.conf //增加行 include vhost/*.conf //保存退出 ：wq enter //在/usr/local/nginx/conf目录新建vhost文件夹 mkdir vhost //创建每个域名的配置 sudo vim jimisun.com.conf //节点中增加入响应的配置 端口转发 或者访问文件系统 Nginx启动 //进入nginx安装目录 cd sbin sudo ./nginx 测试访问 http://ip地址","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Vue-review-router","slug":"Vue-review-router","date":"2019-03-20T14:36:33.000Z","updated":"2019-03-20T14:38:10.841Z","comments":true,"path":"2019/03/20/Vue-review-router/","link":"","permalink":"http://yoursite.com/2019/03/20/Vue-review-router/","excerpt":"最基本的一个路由展示域 在Vue控制域中写入router规定的标签 Go to Login //该项为路由的链接，默认为a标签 Go to Register//该项为路由的链接，默认为a标签 //该项为渲染路由组件的位置 以下步骤一般不能交换，因为存在相互依赖关系","text":"最基本的一个路由展示域 在Vue控制域中写入router规定的标签 Go to Login //该项为路由的链接，默认为a标签 Go to Register//该项为路由的链接，默认为a标签 //该项为渲染路由组件的位置 以下步骤一般不能交换，因为存在相互依赖关系 创建组件模板 const login = {template:&apos;&lt;h1\\&gt;这是一个登录框&lt;/h1\\&gt;&apos;}; const register = {template:&apos;&lt;h1\\&gt;这是一个注册框&lt;/h1\\&gt;&apos;}; 创建一个routes对象作为VueRouter的参数 const routes = [ {path:&apos;/login&apos;,component:login}, {path:&apos;/register&apos;,component:register} ] 创建一个VueRouter实例，并将上面的routes作为参数，值得注意的是，这里的参数名字是routes，下面是使用ES6的写法简写对象名 const router = new VueRouter({ routes }) 创建Vue实例，值得注意的是，这之中的路由参数为router，下面是使用ES6的写法简写对象名 const vm = new Vue({ el:&apos;#app&apos;, router }) 路由重定向需要添加的是,在创建routes对象时 //创建一个routes对象 const routes = [ //这里是重要点，给需要添加默认路由的加路由加上redirect属性，其值为要转向的路由地址 {path:&apos;/&apos;,redirect:&quot;/login&quot;}, {path:&apos;/login&apos;,component:login}, {path:&apos;/register&apos;,component:register} ] 子路由的使用JavaScript： &lt;script&gt; //创建模板 const teacher = {template:&quot;#teacher&quot;}; const student = {template:&quot;#student&quot;} const teacherName = {template:&quot;&lt;h1&gt;这是老师的名字&lt;/h1&gt;&quot;} const studentName = {template:&quot;&lt;h1&gt;这是学生的名字&lt;/h1&gt;&quot;} const teacherId = {template:&quot;&lt;h1&gt;这是老师的序号&lt;/h1&gt;&quot;} const studentId = {template:&quot;&lt;h1&gt;这是学生的序号&lt;/h1&gt;&quot;} //创建父级routes对象 routes = [ { path:&apos;/student&apos;, component:student, //注意这里子路由的申明的方式 children:[ {path:&apos;name&apos;,component:studentName}, {path:&apos;id&apos;,component:studentId} ] }, { path:&apos;/teacher&apos;, component:teacher, children:[ {path:&apos;name&apos;,component:teacherName}, {path:&apos;id&apos;,component:teacherId} ] } ] //创建VueRouter实例 const router = new VueRouter({ routes }) //创建Vue实例 const vm = new Vue({ el:&quot;#app&quot;, router }) &lt;/script&gt; body &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/student&quot;&gt;student&lt;/router-link&gt; &lt;router-link to=&quot;/teacher&quot;&gt;teacher&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; //注意这里在模板中申明子路由的link和view &lt;template id=&quot;teacher&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/teacher/name&quot;&gt;这是老师的名字 &lt;/router-link&gt; &lt;router-link to=&quot;/teacher/id&quot;&gt;这是老师的id&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; //注意这里在模板中申明子路由的link和view &lt;template id=&quot;student&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/student/name&quot;&gt;这是学生的名字 &lt;/router-link&gt; &lt;router-link to=&quot;/student/id&quot;&gt;这是学生的id&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 带名视图body &lt;div id=&quot;app&quot;&gt; //注意下面的router-view中都是带有name属性的 &lt;h1&gt;这里是默认视图&lt;/h1&gt; &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;h1&gt;这里只显示学生的视图&lt;/h1&gt; &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;h1&gt;这里只显示老师的视图&lt;/h1&gt; &lt;router-view name=&quot;tea&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=&quot;default&quot;&gt; &lt;div&gt; &lt;h1&gt;这是默认的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;stu&quot;&gt; &lt;div&gt; &lt;h1&gt;这是学生的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;tea&quot;&gt; &lt;div&gt; &lt;h1&gt;这是老师的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; js部分 //创建模板 const defaultView = {template:&quot;#default&quot;}; const stuView = {template:&quot;#stu&quot;}; const teaView = {template:&quot;#tea&quot;}; //创建路由参数,这里是关键，component的value可以是一个对象，该对象的键值就是视图的名字和模板对应的名字 const routes = [ { path:&quot;/&quot;, components:{ default:defaultView, stu:stuView, tea:teaView } } ] //创建路由实例 const router = new VueRouter({ routes }) //创建Vue实例 const vm = new Vue({ el:&quot;#app&quot;, router })","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"VueRouter","slug":"VueRouter","permalink":"http://yoursite.com/tags/VueRouter/"}]},{"title":"webpack中ES6代码的压缩问题","slug":"webpack中ES6代码的压缩问题","date":"2019-03-16T03:06:14.000Z","updated":"2019-03-17T14:19:55.978Z","comments":true,"path":"2019/03/16/webpack中ES6代码的压缩问题/","link":"","permalink":"http://yoursite.com/2019/03/16/webpack%E4%B8%ADES6%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E9%97%AE%E9%A2%98/","excerpt":"问题webpack中ES6代码压缩问题： 在使用webpack插件uglifyjs-webpack-plugin压缩JS代码时，发现该插件只能压缩ES5-的代码，遇到ES6，就会报错ERROR in xxx.js from UglifyJs,遂查找解决办法。","text":"问题webpack中ES6代码压缩问题： 在使用webpack插件uglifyjs-webpack-plugin压缩JS代码时，发现该插件只能压缩ES5-的代码，遇到ES6，就会报错ERROR in xxx.js from UglifyJs,遂查找解决办法。 原理解决办法原理如上所说，uglifyjs-webpack-plugin该插件仅支持ES5-的JS代码。 解决办法1. 不使用ES6语法这个办法理论上可行，但是面对ES6那么多方便快捷的语法，不使用的话会大大降低开发的进度，所以一般不使用该方法。 2. 使用babel-loader将ES6转化为ES5代码该方法是网上流行最广的解决办法，具体是： 安装es2015插件 npm install --save babel-preset-es2015 安装babel-loader npm install babel-loader 也许是我环境的问题，网上的教程上都没这一步，但是，如果不安装babel-loader，就会报错ERROR in Entry module not found: Error: Can&#39;t resolve &#39;babel-loader&#39; in........., 这一步需要注意的是： babel-loader必须与babel-core版本相同，否则会报错Error: Cannot find module &#39;@babel/core&#39;,这一点需要自己到package.json中查看babel-loader,与babel-core的版本来确定。（比如，babel-core版本是：6.23.3那么你装的babel-loader必须是7.1.5以下的版本，否则loader就与core不匹配了，注意如果直接npm install babel-loader，默认是安装8.0.0的，所以不兼容） 配置webpack.congfig.js 在rules里加入对js代码的过滤 { test: /\\.js$/, loader: &apos;babel-loader&apos;, options:{ presets:[&quot;es2015&quot;] }, exclude:[/node_modules/] } 建.babelrc文件 在项目根目录新建一个文件名为.babelrc的文件，填入以下内容： { &quot;presets&quot;: [&quot;es2015&quot;] } 这是网上流传最广的办法，不过步骤繁琐，麻烦，下面介绍最优解决方案 3.使用uglifyes-webpack-plugin插件其实上面的坑都是我一个一个经历的，网上的解决办法都是不完整，当我踩完所有坑，感觉这个方法太繁琐了。然后我就准备去深入了解一下uglifyjs-webpack-plugin这个插件，结果无意间发现uglify有一个专门针对ES6的插件uglifyes-webpack-plugin，哇，一试就知道有多爽，完全没有那么多步骤： 安装： npm install uglifyes-webpack-plugin webpack.config.js： const UglifyEsPlugin = require(&quot;uglifyes-webpack-plugin&quot;); plugins:[ new MiniCssExtractPlugin({ //css压缩 filename:&apos;[name][hash].css&apos;, chunkFilename:&apos;[id].[hash].css&apos; }) ], optimization:{ minimizer :[ new UglifyEsPlugin({}), //直接引用 new OptimizeCSSAssetsPligin({}) //css压缩 ] 其实就一句话：new UglifyEsPlugin({}),,与uglifyjs-webpack-plugin的使用一样简单。 需要注意的是uglifyes-webpack-plugin与uglify-es-webpack-plugin并不是同一个插件，前者是官方的，也就是与uglifyjs-webpack-plugin一个维护者的，而后者已被弃用并不再维护 Point 该插件默认就会将ES6代码改成ES5代码，并且有压缩，混淆等功能，与uglifyjs-webpack-plugin基本一致，下面是他的一些重要的API： test:匹配的文件，默认/.js($|?)/i，接受正则表达式 mangle:是否混淆代码，默认为true sourceMap：是否启用SourceMap,默认为false compress: 自定义压缩选项，内容是一个对象，默认{}，该选项下的子选项很重要，提一下 sequences：是否使用逗号运算符来连接连续的表达式，默认true properties：是否优化属性读取方式：a[“foo”] → a.foo，默认true dead_code：是否丢弃不可达代码，默认true drop_debugger：是否丢弃调试语句，默认true unsafe：是否优化危险代码，默认false conditionals：是否优化 if-else 条件语句，默认true comparisons：是否优化比较代码，默认true evaluate：是否直接计算常量的值，默认true booleans：优化布尔表达式，默认true loops：是否优化循环代码，默认true unused：是否丢弃不使用的变量，函数，默认true。这里需要注意，如果你的函数本来就是一个DOM触发事件函数，请关闭此选项，否则，该函数将会被丢弃！！！ hoist_funs：是否提升函数的申明，默认true hoist_vars：是否提升变量的申明，默认false if_return：是否优化优化if/return 和 if/continue join_vars：是否将加入变量申明，默认true cascade：优化连续语句，将 x, x 转成 x，x = something(), x 转成 x = something()——声明变量，默认true side_effects：丢弃副作用声明，默认true warnings：警告潜在的危险优化/代码，默认true global_defs：定义全局变量，默认{} extractComments：是否要删除注释，默认false，接受boolean，正则，函数，对象。 include： 要转化的文件，默认无，接受字符串，正则 exclude：在test验证通过后不转化的文件，默认空，接受字符串，正则 相较于uglifyjs-webpack-plugin，uglify-es-webpack-plugin功能要相对少一些，但基本也能满足要求 附uglifyjs-webpack-plugin常用API： test：测试匹配的文件，接受String|RegExp|Array&lt;String|RegExp&gt;,默认/.js(?.*)?$/i cache: 是否启用文件缓存 ，接受Boolean|String,默认false parallel:是否启用多进程来提高构建速度，接受Boolean|Number，默认false sourceMap: 是否启用SourceMap(将错误信息映射值模块源文件)，开启可能会降低编译速度，接受Boolean，默认false uglifyOptions：压缩选项 extractComments：是否保留注释，接受Boolen,String,RegEXp,function,Object,默认false warningsFilter:允许过滤uglify-js警告。返回true以保持警告，否则为false。接受Function&lt;(warning, source) -&gt; Boolean&gt; Default: () =&gt; true 最后是UglifyJS的官网。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Image对象的complete与onload()事件(以及Canvas的drawImage()函数)","slug":"Image对象的complete与onload()事件(以及Canvas的drawImage()函数)","date":"2019-03-12T11:45:26.000Z","updated":"2019-03-12T11:53:08.590Z","comments":true,"path":"2019/03/12/Image对象的complete与onload()事件(以及Canvas的drawImage()函数)/","link":"","permalink":"http://yoursite.com/2019/03/12/Image%E5%AF%B9%E8%B1%A1%E7%9A%84complete%E4%B8%8Eonload()%E4%BA%8B%E4%BB%B6(%E4%BB%A5%E5%8F%8ACanvas%E7%9A%84drawImage()%E5%87%BD%E6%95%B0)/","excerpt":"问题之前基本看完了canvas的API，准备做一个小游戏，emmm，然后今天就遇到了问题，我本来以为是canvas的问题，但是仔细分析之后才发现是JS中的问题：","text":"问题之前基本看完了canvas的API，准备做一个小游戏，emmm，然后今天就遇到了问题，我本来以为是canvas的问题，但是仔细分析之后才发现是JS中的问题： 回顾关于HTML与JS的关系可以从网页的加载顺序来看，当浏览器打开网页的时候，网页由上至下的解析该网页，然后开始构建DOM树(Document Object Model)(属于JavaScript)，也就是说将HTML的每一个标签构建成一个相应的对象，但是DOM整体就是一个对象，每一个标签是其的一个子对象，对比与JSX有些相似,遇到JS或CSS时利用相应引擎进行解析。从这里就可以理解出，在网页完成加载后，每一个标签就成为了DOM这个对象里的一个子对象，我们使用相应的方法，比如Document.getElementById(“xxx”)就可以获取相应的对象，并进行操作。 Image()对象由上可知，Image()也是一个节点对象，只是是否渲染至页面上的问题。 Image对象的属性 属性 描述 属性 描述 align 设置或返回与内联内容的对齐方式。 align 设置或返回与内联内容的对齐方式。 alt 设置或返回无法显示图像时的替代文本。 alt 设置或返回无法显示图像时的替代文本。 border 设置或返回图像周围的边框。 border 设置或返回图像周围的边框。 complete 返回浏览器是否已完成对图像的加载。 complete 返回浏览器是否已完成对图像的加载。 height 设置或返回图像的高度。 height 设置或返回图像的高度。 hspace 设置或返回图像左侧和右侧的空白。 hspace 设置或返回图像左侧和右侧的空白。 id 设置或返回图像的 id。 id 设置或返回图像的 id。 isMap 返回图像是否是服务器端的图像映射。 isMap 返回图像是否是服务器端的图像映射。 longDesc 设置或返回指向包含图像描述的文档的 URL。 longDesc 设置或返回指向包含图像描述的文档的 URL。 lowsrc 设置或返回指向图像的低分辨率版本的 URL。 lowsrc 设置或返回指向图像的低分辨率版本的 URL。 name 设置或返回图像的名称。 name 设置或返回图像的名称。 src 设置或返回图像的 URL。 src 设置或返回图像的 URL。 useMap 设置或返回客户端图像映射的 usemap 属性的值。 useMap 设置或返回客户端图像映射的 usemap 属性的值。 vspace 设置或返回图像的顶部和底部的空白。 vspace 设置或返回图像的顶部和底部的空白。 width 设置或返回图像的宽度。 width 设置或返回图像的宽度。 标准属性 属性 描述 className 设置或返回元素的 class 属性。 title 设置或返回元素的 title。 Image对象的事件句柄 事件句柄 描述 onabort 当用户放弃图像的装载时调用的事件句柄。 onerror 在装载图像的过程中发生错误时调用的事件句柄。 onload 当图像装载完毕时调用的事件句柄。 浅谈图片加载complete属性：图片显示出来之后其属性由false变为true在这个属性上，IE与其他浏览器有所不同，IE是根据图片的src属性是否是一个有效的图片地址值。即，在IE下，只有当image()对象的src值为一个正确的图片地址时，complete值才为true，否则一直为false，但是在其他浏览器下，当image()对象呗定义完成的时候，其complete值就为true，不会检测其src属性的有效性 也就是说：complete这个属性在IE系浏览器与其他浏览器的判断方式不一样，所以对于适配性来说，最好不用 onload()回调事件onload()是当图像装载完毕后调用的函数。关键是如何才算是装载完毕，经测试， 当我们直接在HTML中定义一个标签，并且在其中规定其onload事件，只有当src属性填写正确时，才算是装载完成，否则onload事件一直不触发，直至修改其src值为有效图片地址的时候才算是装载完成。 当我们在JS代码中手动生成一个Image()对象时，无论其src值是否被赋值为有效的图片地址，其onload事件总会触发，即当我们手动生成一个 Image 对象时，一旦其被生成，则认定为装载完成，立即调用onload事件。至于原因，我还没弄明白，看来需要深入的去了解一下浏览器机制，才能明白这一点。 Canvas中悟到的Image对象的用发法 ctx.drawImage(img,x,y)中的Img应当是一个Image对象，可以是从DOM树中获取的Image()子对象，也可以是一个自己定义的Image()对象，不管是这两者中的哪一者，再绘制到画板上时，都必须将绘制语句写到该对象的onload()函数中，其原因在于，Image()的定义是一个异步执行的操作，也就是说，在执行到let img = new Image()时，JS引擎不会等待该语句执行完毕在继续执行，而是直接继续执行，在对象定义完成时，就会自动调用其onlaod.onerror,onabort回调事件。那么问题就是，可能在对象还没有定义完成的时候，已经执行到了ctx.drawImage()这一条语句，所以绘制不出任何效果(而且大部分情况下，JS语句的执行都是快于对象的定义，所以基本上都绘制不出图形)。所以所有的Canvas图形绘制都必须是在onload中进行的。 问题又出现了，那如果要就行较大型的图形绘制，我不可能把所有代码都写到一个函数里吧，所以再写多个函数时就要多次调用onload事件，但是一个图片的onload事件只能执行一次。所以我想到了一种错误的方法，在不同寒暑表中多次载入同一张图片，并分别调用其回调函数onload，结果当然是失败了。这种情况下onload事件的顺序是无法确定的，即使你是前后分别执行，因为onload函数是异步进行的，现在惟一的办法就是把这张图片统一载入，然后想办法将下面的代码都建立在onlaod函数执行的前提下。然后我找到了一种方法： let img = new Image(); img.addEventListener(‘onload’,’start’,’true’); function start(){ draw1(); draw2(); } fucntion draw1(){ ctx.drawImage(); ... } fucntion draw1(){ ctx.drawImage(); ... } 上面这么写的好处在于，所有的函数后在onload回调函数之后执行了，确保了绘图的正确性。 Last but not least 我在网上搜了很久，在讲解onload()事件时基本就一篇文章，被抄了无数次，但是我试验却发现和文章中的结果完全不一样。文章中写到，即使是在JS代码中定义一个Image()对象时，只要src不赋值，其onload事件就不会触发，但是~像我上面实验的那样，我试验了很多次，都是那样的结果，测试了Chrome，Firefox，IE，Edge，每个浏览器的测试都一样。可能是那篇文章已经是很久之前的了，但是这些同学从未自己试过，直接就抄过去了。所以实践才是真理啊。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"canvas基础","slug":"canvas基础","date":"2019-03-10T13:56:25.000Z","updated":"2021-03-08T02:36:51.217Z","comments":true,"path":"2019/03/10/canvas基础/","link":"","permalink":"http://yoursite.com/2019/03/10/canvas%E5%9F%BA%E7%A1%80/","excerpt":"创建canvas画布css: canvas{ border:3px solid blue; } html: &lt;canvas width=&quot;700&quot; height=&quot;700&quot; id=&quot;myCanvas&quot;&gt; 您的浏览器不支持canvas，请更换浏览器访问！ &lt;/canvas&gt; Javascript: &lt;script&gt; let canvas = document.getElementById(&quot;myCanvas&quot;); let ctx = canvas.getContext(&quot;2d&quot;); &lt;/script&gt;","text":"创建canvas画布css: canvas{ border:3px solid blue; } html: &lt;canvas width=&quot;700&quot; height=&quot;700&quot; id=&quot;myCanvas&quot;&gt; 您的浏览器不支持canvas，请更换浏览器访问！ &lt;/canvas&gt; Javascript: &lt;script&gt; let canvas = document.getElementById(&quot;myCanvas&quot;); let ctx = canvas.getContext(&quot;2d&quot;); &lt;/script&gt; Point: canvas标签是一个双标签，其内部写的是当浏览器不支持canvas时显示的内容，可以插入其他元素，比如文字，图片等。 canvas画布的宽高因该在其标签内定义，不能在其CSS内定义，否则其绘制的图像会按照300*150发生缩放。 所有绘图行为都在script标签中进行。 let ctx = canvas.getContext(“2d”); 所有canvas的API都是定义在该对象上的，其中参数可以是2D，或者3D. Canvas绘制图像canvas的绘制图形有两种方式： context.fill() fill()指的是填充，其默认颜色是黑色，可以在使用fill()之前使用fillStyle()方法改变填充颜色，如果是闭合图像，那么就直接填充。如果是非闭合的路径，则fill()先帮其闭合，然后填充。 12ctx.fillStyle = \"red\";//设置填充色ctx.fillRect(10,10,100,100);//绘制一个填充矩形 context.stroke() stroke()方法会实际的绘制出moveTo()和lineTo()方法的路径。默认颜色是黑色，在绘制之前，可以使用strokeStyle()进行设置。 12ctx.strokeStyle = \"red\";//设置边框填充色ctx.strokeRect(10,10,100,100);//绘制空心矩形 绘制矩形绘制基本矩形12ctx.fillRect(x,y,height,width)//实心矩形ctx.strokeRect(x,y,height,width)//空心边框 x:起点的x坐标(即左上角的x坐标) y:起点的y坐标(即左上角的y坐标) height:矩形的高 width:矩形的宽 改变颜色1234ctx.fillStyle = \"red\";//设置填充颜色ctx.fillRect(10,10,100,100);ctx.strokeStyle = \"red\";//设置边框颜色ctx.strokeRect(200,200,100,100); Point: ctx.fillStyle = “red”用来设置填充颜色 ctx.strokeStyle = “red”用来设置边框颜色 这些描述都要放在绘制图形之前声明 擦除矩形区域 ctx.clearRect(x,y,height,width) ctx.clearRect(50,50,200,200)//绘制一个矩形区域并擦除该区域之前的内容 绘制圆形绘制基本圆实心圆 ctx.arc(x,y,radius,starAngle,endAngle,anticlockwise) x:圆心的x坐标 y:圆心的y坐标 radius:半径 startAngle:开始角度 endAngle:结束角度 anticlockwise:旋转方向， true:逆时针(可选参数，默认为false) false:顺时针 123ctx.fillStyle = \"red\"; //设置填充色ctx.arc(200,200,50,0,Math.PI*2,true);//绘制圆形ctx.fill();//填充 空心圆12345ctx.beginPath()ctx.arc(200,200,50,0,Math.PI*2,true);ctx.strokeStyle = \"red\"; ctx.closePath();ctx.stroke(); Point 上面用到了路径，实际ctx.arc()相当于是一个lineTo()的一个集合。利用其绘制出一个圆形，最后要关闭(ctx.cloePath())，以及要(stroke())才能完全绘制出该图形。 非完整圆如果要绘制一个非完整的圆，比如一个实心半圆，该如何绘制呢？ 答案是使用arc方法中的startAngle和endAngle来改变。 12ctx.fillStyle = \"red\";ctx.arc(200,200,50,0,Math.PI,true); 空心圆形 12345ctx.beginPath();ctx.strokeStyle = \"red\";ctx.arc(400,400,100,0,Math.PI);ctx.closePath();ctx.stroke(); 绘制线段 moveTo(x,y):把画笔移动至画布的制定位置，不创建线条 lineTo(x,y):添加一个点(x,y) stroke():按照之前添加的点绘制路径 1234ctx.strokeStyle = \"red\";//设置填充色ctx.moveTo(0,0);//将画笔移动至(0,0)ctx.lineTo(100,100);//添加一个点(100,100)ctx.stroke();//按点绘制路径 Point 如果没有在第一次指定moveTo(x,y)，则第一个lineTo(x,y) == moveTo(x,y) 如果在lineTo()后没有使用moveTo()方法，则依次连接，eg： ctx.moveTo(0,0); ctx.lineTo(10,10); ctx.lineTo(20,20); ctx.lineTo(30,30); ctx.stroke(); 则画出后是一段从点(0,0)=&gt;(10,10)=&gt;(20,20)=&gt;(30,30)的一段折线。 ctx.beginPath():开始一段路径 ctx.closePath()：闭合路径，即canvas会自动将未闭合的线段的首尾连接起来。 eg(一个三角形): ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(10,10); ctx.lineTo(20,20); ctx.closePath(); ctx.stroke(); 案例(六边形)： var n = 0; var dx = 150;//路径开始x坐标 var dy = 150;//路径开始y坐标 var s = 100;//边长 ctx.beginPath();//路径开始 ctx.fillStyle = &apos;pink&apos;;//设置填充色 ctx.strokeStyle = &apos;rgb(0,0,100)&apos;;//设置边框颜色 var dig = Math.PI / 3;//计算偏移角度 for (var i = 0; i &lt; 6; i++) { var x = Math.sin(i * dig);//计算以下个点的x坐标的增量 var y = Math.cos(i * dig);//计算下一个点的y坐标的增量 ctx.lineTo(dx + x * s, dy + y * s);//绘制下一个点 //console.log( x ,y ) } ctx.closePath();//闭合整个路径 ctx.fill();//设置填充 ctx.stroke();//绘制路径 Point 这个例子用了一点数学知识，主要是： for (var i = 0; i &lt; 6; i++) { var x = Math.sin(i * dig);//计算以下个点的x坐标的增量 var y = Math.cos(i * dig);//计算下一个点的y坐标的增量 ctx.lineTo(dx + x * s, dy + y * s);//绘制下一个点 //console.log( x ,y ) } 其原理是利用了简单的沟股定理，计算下一个点的坐标 线性渐变 let lg = ctx.createLinearGradient(xStart,yStart,xEnd,yEnd) lg.addColorStop(offset,color) xSart:渐变开始点的x坐标 yStart：渐变开始点的y坐标 xEnd：渐变结束点的x坐标 yEnd：渐变结束点的y坐标 offset:设定的颜色离渐变结束点的偏移量 color:绘制的颜色 eg: let lg = ctx.createLinearGradient(0,0,100,200); lg.addColorStop(0,”#E55D87”); lg.addColorStop(1,”#5FC3E4”); ctx.fillStyle = lg; ctx.fillRect(0,0,200,200); Point 线性渐变仅仅是相当于设置填充色，在定义完填充色之后，我们还需要将填充设置为该线性渐变(ctx.fillStyle = gl) 由于线性渐变仅仅是设置填充色，所以具体的背景容器还需要我们自己设置，比如设置一个矩形作为容器ctx.fillRect(0,0,200,200) 由于渐变背景的坐标是相对于画布，而图形的坐标也是相对于画布，所以在定义背景时，需要注意与图形的坐标搭配以达到需要的效果 径向渐变 12let rg = ctx.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)rg.addCOlorStop(offset,color); xSart:发散开始的圆心x坐标 yStart：发散开始的圆心y坐标 radiusStart：发散开始圆的半径 xEnd：发散结束圆心的x坐标 yEnd：发散结束圆心的y坐标 radiusEnd：发散结束圆的半径 offset：设定的颜色结束点的偏移量(0-1) color:绘制颜色 12345678var g1 = ctx.createRadialGradient(200, 150, 0, 200, 150, 200); g1.addColorStop(0.1, '#F09819'); g1.addColorStop(1, '#EDDE5D'); ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(200, 150, 100, 0, Math.PI * 2, true); ctx.closePath(); ctx.fill(); 图形变形缩放 scale(x,y) x:x坐标轴按x比例缩放 y:y坐标轴按y比例缩放 前面参数的是按倍数来衡量的(0.5=&gt;50%,1=&gt;100%,2=&gt;200%) eg: 1234567ctx.strokeStyle = \"red\"; ctx.scale(2,2); ctx.strokeRect(5,5,25,15); ctx.scale(2,2); ctx.strokeRect(5,5,25,15); ctx.scale(2,2); ctx.strokeRect(5,5,25,15); Point 缩放一个图形，先使用ctx.scale(x,y)对画布进行缩放处理，后面再创建要缩放的工具ctx.strokeRect(5,5,25,15);。 缩放的原点都是在(0,0)位置。 旋转 ratate(angle) angle:旋转的角度，以弧度计。 eg: 1234ctx.strokeStyle = \"red\";// ctx.strokeRect(5,5,200,200);ctx.rotate(20*Math.PI/180);//旋转5°ctx.strokeRect(5,5,200,300); Point: 默认的旋转中心是在(0,0)位置。下面介绍如何改变旋转中心。 平移 translate(x,y) x:坐标原点向x轴平移x y:坐标原点想y轴平移y eg1(以矩形中心为原点旋转)： 1234567891011ctx.strokeStyle = \"red\"; //以(0,0)为原点绘制一个起点为(200,200)，边长为200的正方形 ctx.strokeRect(200,200,200,200); //移动原点至(300,300)，即上面矩形的中心位置 ctx.translate(300,300); //将画布进行一个45°的旋转，得到一个旋转后的图形 ctx.rotate(45*Math.PI/180); //将原点坐标改为(0,0) ctx.translate(-300,-300); //绘制出旋转后的矩形 ctx.strokeRect(200,200,200,200); eg2(以矩形中心为原点缩放图形): 123456ctx.strokeStyle = \"red\";ctx.strokeRect(200,200,100,100);ctx.translate(250,250);ctx.scale(2,2);ctx.translate(-250,-250);ctx.strokeRect(200,200,100,100); Point 上面提到的，scale,rotate方法的操作都是对画布而言的，貌似整的canvas的思维都是这样，需要我们有反向思考的能力。 组合图形 1globalCompositeOperation = type 后绘制的图形如何与之前的图像叠加渲染，取决与type。下面是type的种类： source-over(默认):在原图形之上绘制(覆盖)。 destination-over:在原图形之下绘制。 source-in:显示原有图形和新图形的交集，新图形在上，所以颜色为新图形颜色 destination-in:显示原图形和新图形的交集，原图形在上，所以颜色为原图形的颜色 source-out:只显示新图形的非交集部分 destination-out:只显示旧图形的非交集部分 source-atop:显示原图形和交集部分，新图形在上，所以交集部分为新图形颜色 destination-atop：显示新图形和交集部分，新图形在上，所以交集部分为新图形颜色 lighter：显示原有图形和新图形，交集部分做颜色叠加 copy:只显示新图形 eg: 12345ctx.globalCompositeOperation = \"lighter\"; ctx.fillStyle = \"red\";ctx.fillRect(50,50,200,200); ctx.fillStyle = \"blue\";ctx.fillRect(100,100,200,200); Point 该属性与上面的ctx.translate(x,y)一样，一旦作用，就对下面的元素都起作用，如果要还原，请在此使用该属性还原。 阴影 shadowOffsetX:设置或返回阴影距形状的水平距离(默认值为0)-shadowOffsetY:设置或返回阴影形状的垂直距离(默认值为0) shadowColor:设置或返回阴影的颜色 shadowBlur:设置或返回阴影的模糊级别(值越大越模糊) eg: ctx.shadowOffsetX=20; ctx.shadowColor=”blue”; ctx.shadowBlur = 50; ctx.fillStyle = “red”; ctx.fillRect(100,100,200,200); 1234ctx.shadowBlur = 0;ctx.shadowOffsetX = 0;ctx.fillStyle = \"yellow\";ctx.fillRect(400,400,100,100); Point 相同的是，阴影属性也是对一下的所有图形都生效。要取消阴影效果，必须重置: 12ctx.shadowBlur = 0;ctx.shadowOffsetX = 0; 图像操作 drawImage(img,x,y):在画布上定位图像 drawImage(img,x,y,width,height):在画布上定位图像，并规定图像的宽度和高度 drawImage(img,sx,sy,swidth,sheight,x,y,width,height) img:规定要使用的图像，画布或视频 sx(可选):开始剪切的x坐标位置 sy(可选):开始剪切的y坐标位置 swidth(可选):被剪切的图像的宽度 sheight(可选):被剪切的图像的高度 x:在画布上放置img的x坐标位置 y:在画布上放置img的y坐标位置 width(可选):要使用的图像的宽度。(拉伸或压缩) height(可选)：要使用的图像的高度。(拉伸或压缩) eg: 12345let img = new Image();img.src = \"expi.jpg\";img.onload = function()&#123; ctx.drawImage(img,100,100,200,200,200,200,200,200);&#125; Point img因该是一个img对象，img = new Image()或者是一个Image的DOM标签document.getElementById(&quot;img&quot;)(实际也是一个Image对象，因为在HTML中，每创建一个img标签，就会自动创建一个Image对象。) 在使用该标签时，应当使用，Image对象的回调函数onload,否则不能渲染成功，其原因是: 12let img = new Image(); img.src = \"expi.jpg\"; 这个过程中，对img.src赋值的时候，可能还没有赋值完成，就进行了ctx.drawImage语句，由于还没赋值完成，此使img.src还是空，所以无法渲染出来。 图像平铺 createPattern(image,type) type: no-repeat:不平铺 repeawt-x:按x轴方向平铺 repeat-y:按y轴方向平铺 repeat：全方向平铺 eg: let img = new Image; img.src = “beauty.png”; img.onload = function(){ let pattern = ctx.createPattern(img,”repeat-x”); ctx.fillStyle = pattern; ctx.fillRect(10,10,500,500); } Point 相同的是，必须要配合Image的oload回调函数来使用，道理同上。 图像剪切 clip() 该函数的使用方法： 创建剪切区域:ctx.rect(x,y,width,heigth) 设置剪切部分的填充色:ctx.fillStyle = “pink” 进行填充:ctx.fill(); 进行剪切:ctx.clip(); eg: 12345678910ctx.fillStyle = \"yellow\";ctx.fillRect(0,0,300,300);ctx.rect(100,100,500,500);ctx.fillStyle = \"pink\";ctx.fill();ctx.clip();ctx.fillStyle = \"blue\";ctx.fillRect(0,0,200,200); Point -一旦剪切了某个区域，则之后的所有绘图都会被限制在被剪切区域内进行（不能访问画布上的其他区域）。我们也可以在使用clip()方法之前通过使用save()方法将之前的画布保存下来,并在任意时间使用restored()方法。 绘制文字 fillText(text,x,y):绘制实心文字 x:文字的中心点x坐标 y：文字的中心点y坐标 strokeText():绘制文字描边(空心文字) textAlign：设置或返回文字内容的当前对齐方式(注意：其都是相对于该文字对象的中心)，其值有： start:默认。文本在指定的位置开始。 end:文本在指定的位置结束。 left:文本左对齐。 center:文本的中心被放置在指定的位置。 right:文本右对齐。 textBaseline：设置会返回在绘制文本时使用的当前文字基线,其值有： Bottom：文本基线是 em 方框的底端。 Top：文本基线是 em 方框的顶端。 Middle：文本基线是 em 方框的正中。 Alphabetic：默认。文本基线是普通的字母基线。 hanging：文本基线是悬挂基线。 font:设置或返回文本内容的当前文字属性 eg: 12345ctx.font = \"40px Arial\";ctx.textAlign = \"center\";ctx.fillText(\"Hello World\",200,200);ctx.strokeText(\"Hello World\",200,300);console.log(ctx.textBaseline);","categories":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/categories/Canvas/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"JavaScript中的.与[]的区别","slug":"JavaScript中的.与[]的区别","date":"2019-03-03T04:17:00.000Z","updated":"2019-03-03T05:04:01.331Z","comments":true,"path":"2019/03/03/JavaScript中的.与[]的区别/","link":"","permalink":"http://yoursite.com/2019/03/03/JavaScript%E4%B8%AD%E7%9A%84.%E4%B8%8E[]%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"叨叨一下最近在看ES6，感觉很有意思啊。然后就遇到了这个问题，.(点)与[] (方括号)的区别。","text":"叨叨一下最近在看ES6，感觉很有意思啊。然后就遇到了这个问题，.(点)与[] (方括号)的区别。 正文这个问题是在遍历器(Iterator)这一部分发现的，其中对于不存在遍历器的数据结构，比如一个对象。我们可以自定义一个遍历器，就可以实现forEach,for…in…等方法。然后就出现下面这段语句： var arrlike = { 0:a, 1:b, 2:c } arrlike.[Symbol.iterator](){ //遍历器内容，略 } 问题就在：arrlike.[Symbol.iterator]()，如果Symbol是对象arrlike的一个属性，那么为什么不能用arrlike.Symbol…的方法来获取该属性。 下面就说一下这两个的区别： 相同: .与[]都可以获取元素的属性。 不同: 中括号运算符可以用字符串变量的内容作为属性名。点运算符不能。 中括号运算符可以用纯数字为属性名。点运算符不能。 中括号运算符可以用js的关键字和保留字作为属性名。点运算符不能。 说回上面的arrlike.[Symbol.iterator](),Symbol.iterator是一个JS内置的一个关键字，然后这个属性返回的是一个函数。 然后后面的括号就是执行该函数。 function fun1(){return &quot;yes&quot;} console.log(func1) //function... console.log(func1()) //yes LastES6还是真的有意思，加油鸭！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JSP实战项目:学生信息管理系统的总结","slug":"JSP实战项目-学生信息管理系统的总结","date":"2019-02-09T04:38:11.000Z","updated":"2019-02-09T09:26:53.927Z","comments":true,"path":"2019/02/09/JSP实战项目-学生信息管理系统的总结/","link":"","permalink":"http://yoursite.com/2019/02/09/JSP%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"前言简单学习了一下JSP，不知道以后老师怎么教的，不过我是感觉到JSP的真谛还是Java，无论是按照MVC或者三层模式，一般Control层都是servlet来写，Model层都是用纯java来写，当然，在JSP文件中，也是可以进行这些操作的，毕竟在JSP的&lt;%…%&gt;中完全可以写java代码，而servlet的本质就是java的一个类。但是一般在开始时总是界面与逻辑分开，否则整个项目结构混乱，代码冗余。所以我觉的学JSP本质还是学java，学servlet。","text":"前言简单学习了一下JSP，不知道以后老师怎么教的，不过我是感觉到JSP的真谛还是Java，无论是按照MVC或者三层模式，一般Control层都是servlet来写，Model层都是用纯java来写，当然，在JSP文件中，也是可以进行这些操作的，毕竟在JSP的&lt;%…%&gt;中完全可以写java代码，而servlet的本质就是java的一个类。但是一般在开始时总是界面与逻辑分开，否则整个项目结构混乱，代码冗余。所以我觉的学JSP本质还是学java，学servlet。 正文整个项目差不多就包含学生信息的增删改，准备添加一个文件上传，不过还没添加，嘿嘿嘿。后面再说。 在这个过程中我遇到了不少问题，下面我就想起什么就讲什么吧~ 前端部分 前端完美居中之flex布局： 在登陆界面这种只需要一个div完美居中的情况，flex布局是在一个不错的方法： body{ display:flex;//设置body为flex布局 justify-content:center; //设置布局主轴上的对齐方式为居中 align-items:center;//设置另一轴的对齐方式为居中 } 这种布局下，body里的内容就会完美居中。 另外在回顾一下flex布局里的所有属性： 容器属性 flex-direction: 决定主轴的方向，即项目排列的方向，有四个可能的值：row(默认)|row-reverse|column|column-reverse flex-wrap:默认情况下，item排列在一条线上，即主轴上，flex-wrap决定当排列不下时是否换行以及换行的方式，可能的值nowrap(默认)|wrap|wrap-reverse flex-flow:flex-direction和flex-wrap的简写形式，如：row wrap|column wrap-reverse等。默认值为row nowrap，即横向排列 不换行。 justify-content:决定item在主轴上的对齐方式，可能的值有flex-start（默认），flex-end，center，space-between，space-around。 align-items:决定了item在交叉轴上的对齐方式，可能的值有flex-start|flex-end|center|baseline|stretch align-content:该属性定义了当有多根主轴时，即item不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，定义了align-content后，align-items属性将失效。 容器属性 order：order的值是整数，默认为0，整数越小，item排列越靠前。 flex-grow：定义了当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大；可能的值为整数，表示不同item的放大比例 flex-shrink：定义了当容器空间不足时，item是否缩小。默认值为1，表示当空间不足时，item自动缩小，其可能的值为整数，表示不同item的缩小比例。 flex-basis：表示项目在主轴上占据的空间，默认值为auto，其可为具体数值(px)。 flex：flex属性是flex-grow、flex-shrink和flex-basis三属性的简写总和。 align-self： align-self属性允许item有自己独特的在交叉轴上的对齐方式，它有六个可能的值：auto|flex-start|flex-end|center|baseline|stretch。默认值为auto。 前端onsubmit属性 这个属性真有点用~这个属性是用在submit按钮上的，他可以在你提交表单之前进行数据的审核。在审核通过后再上传，如果审核不通过，则不提交。具体代码如下。 //表单部分 &lt;input type=&quot;submit&quot; value=&quot;提交&quot; onsubmit=&quot;return check()&quot;&gt; //JS部分 function check(){ //执行判断，注意要返回一个boolean值，该值来确定是否需要提交表单 } Jquery的ajax请求 由于原生JS的ajax请求有点负载，所以我还是采用了jquery。所以还是具体介绍一下jquery的ajax请求。 1. $(“#id”).load(url,data,function(response,status,xhr)) 这种请求方法可以直接将请求到的数据添加到指定元素中（其本质还是get()方式）。 url：（必选）请求的地址 data:（可选）要发送的数据,采用键值存储发送，多个数据时采用花括号：{key1:value1,key2:value2} function():（可选），在服务器反馈后执行的函数。 response：服务器返回的数据 status：服务器返回的status值 xhr：服务器返回的xhr对象 2. $.get(url,data,function(response,status,xhr) 这个基本的get请求，get()只请求数据，不对数据做任何处理。 但是jquery将jsonp也封装进了get方法中，所以我们再调用get方法时，可以使用jsonp进行传输，但一般是是直接传字符串: $.get(url,data,function(data,status,xhr){}) 如果需要使用JSONP来请求，需要再声明： $.get(url,data.function(data,status,xhr){},&quot;JSONP&quot;) 关于JSON与JSONP，可以看一下这一篇文章，还是比较易懂。 3. $.get(url,data,function(response,status,xhr) 回顾一下，get与post： get: 数据追加到url中传输，因此保密性较差，直接可视化，不适用于账户，密码等信息的传输。 由于url的限制，也不适用于较长数据的传输，一般url的数据量在1KB左右。 由于使用url直接传输，因此传输效率会比post方式高。 post： post是将数据封装为HTTP消息发送给服务器，这样做有以下优点： 数据传输量相较于get()方法得到提升，一般文件传输都是利用该方法 数据保密性得到一定性的保护，无法直接获取，但需要注意的是，通过抓包，任然可以获得post提交的所有数据。所以我们在传输密码时，一般是通过加密传输，不传明文密码。这一点，在HTTPS中得到了较好的解决。但是HTTPS需要申请且价格昂贵，所以目前对于数据的加密任是最好方法。 4.$.ajax({ type:”get”,url:”url”,data:””,async:true,function(data,status,xhr){} }) 注意：async即异步，一般默认是true，即，你删掉async这个选项，则默认为true，还记得ajax的含义么： Asynchronous JavaScript and XML 第一个就是async，所以如果是false，就没意义了对吧，不过也许有的情况有用，了解到就好。 5. $.getJSON(url,data,function(response,status,xhr) 我觉得这是jquery中最好用的一个方法了，因为他将请求到的JSON字符串直接转换为JSON对象了，直接用key和value属性就可以使用了，舒服的板~ JS的cookies的使用 之前一直是使用的localStorage或者sessionStorage来存储数据，使用这个就很便捷，直接使用key来取value值就行了，我好像还有一个专门的文章来介绍，不过最终好像还是cookies使用的较多一点，可能是兼容性的原因，然年后我发现cookies的使用比localStorage要复杂一些，所以还是看一下： 设置cookie： function setCookie(cname,cvalue,exdays) { var d = new Date();//实例化一个时间 d.setTime(d.getTime()+(exdays*24*60*60*1000));//设置过期时间的变量 var expires = &quot;expires=&quot;+d.toUTCString();//将Date()对象转化为数组 document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;//设置cookie } 获取cookie值： function getCookie(cname) { var name = cname + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;);//分割cookie字符串 for(var i=0; i&lt;ca.length; i++) { var c = ca[i].trim();//去除空格 if (c.indexOf(name)==0) return c.substring(name.length,c.length); }//搜索是否存在该cookie，是则返回值 return &quot;&quot;; } 注意：可以看出，JS的cookie的API设计似乎没有localStorage那么友好，毕竟很多年前的东西了。所以document.cookie是直接获得整个cookie，以键值对用”=”连接起来，具体获得对应的值还需要我们自己来处理字符串，emmmm，从体验上来说，没有那么友好，但还有一点值得注意的是，document.cookie是一个方法，当你对他进行赋值操作的时候。他是直接识别”=”添加键值，而对其进行取值的时候，是以字符串返回所有的cookie值。 上面获取cookie的方法不是唯一的，因为处理字符串的方式不是唯一的，包括正则也是不错的方法 后端部分 关于MVC的理解我觉得也是学到的一部分，即将视图，模型，控制分离，而且无论是哪种设计方式，最终目的是保证层次的清晰。这样无论是对一次开发还是重构，都是及其重要的。 另外对于JSP这门后端语言，我觉得要理解其精髓，还是要学习servlet，java。因为model，controller层，一般都是采用servlet或者java来开发，似乎很少有用JSP来写逻辑层面的东西的。 在开发时我遇到了一个BUG卡了我好几天，搜索也没有结果，知道我理解其原因，啧啧啧： 我用java写好后端数据库交互层后，直接写了mian函数进行测试，成功！但是在我使用JSP文件发送ajax请求时，后端文件报错，无法找到sql驱动文件，我检查了sql文件，确实是在Java Resource的library中，并且直接运行java文件也通过了。。。搜索了很久，突然想到既然是javaweb程序，是不是在调用库文件时时使用的WebContent-&gt;WEB-INF-&gt;lib下的库文件，而不是调用java的库文件。我直接将sql驱动添加到javaweb的库中。nice，运行成功！ 关于eclipse的问题，在测试的某一段时间，发现整个工程没有更新了，修改了代码也没有用，以前也发生过，一般重启一下server就ok了，可这次重启也没用，没办法，清除缓存把，我直接清除了工程的缓存。然后。。。就是java程序无法运行，一直报错：无法找到main函数入口。在网上看到很多这种情况，但一般都说是classpath设置不对，但我另一个工程却可以运行，所以明显不是这种情况，然后我看到了这篇文章我按照第二条的方法，发现我有个库文件报错，直接移除，ok，解决（可是这和我的main函数有什么关系呢？？？） 最后在java那些库文件的语法方面我就不再BB了，反正是固定的API，按文档写就OK（其实是我懒，哈哈哈）~~~ 最后 最后我觉得我还是有个大问题，那就是变量的命名问题。。。This is a problem。很多不规范，这个在我以后的实践中尽量解决，比如~写个文档啊，哈哈哈。 所以这个项目就告一段落，前端的框架看一下就开学了~~~只能开学去看Python的GUI编程了~","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"实战","slug":"实战","permalink":"http://yoursite.com/tags/%E5%AE%9E%E6%88%98/"}]},{"title":"JSP数据库处理","slug":"JSP数据库处理","date":"2019-01-31T08:50:58.000Z","updated":"2019-01-31T09:44:46.171Z","comments":true,"path":"2019/01/31/JSP数据库处理/","link":"","permalink":"http://yoursite.com/2019/01/31/JSP%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86/","excerpt":"JSP的数据库操作经过这两天的操作，我觉得还是要看视频或者买书或者看官方文档学习，网上的资料缺点太多，写的过于简单，甚至兼容性也有问题。所以，搞了一天，终于，把数据库搞出来了~","text":"JSP的数据库操作经过这两天的操作，我觉得还是要看视频或者买书或者看官方文档学习，网上的资料缺点太多，写的过于简单，甚至兼容性也有问题。所以，搞了一天，终于，把数据库搞出来了~ 源码分析sql.java package student.servlet; import java.sql.*; public class sql { public static void Update(){ Statement stmt = null; Connection connection = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } String name=&quot;root&quot;; String pwd=&quot;957837&quot;; String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;; try { connection = DriverManager.getConnection(url,name,pwd); System.out.print(&quot;数据库连接成功！&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { stmt = connection.createStatement(); String sqlString = &quot;insert into blog values(5,&apos;https&apos;,&apos;hhhhh&apos;,&apos;2015-8-9&apos;)&quot;; int lines = stmt.executeUpdate(sqlString); System.out.print(&quot;插入成功&quot;+lines+&quot;受影响&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { if(stmt != null) { stmt.close(); } connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public static void Select() { Statement stmt = null; Connection connection = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } String name=&quot;root&quot;; String pwd=&quot;957837&quot;; String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;; try { connection = DriverManager.getConnection(url,name,pwd); System.out.print(&quot;数据库连接成功&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { stmt = connection.createStatement(); String sqlString = &quot;select * from blog&quot;; ResultSet res = stmt.executeQuery(sqlString); System.out.println(&quot;查询数据库成功&quot;); while(res.next()) { int num= res.getInt(&quot;order_id&quot;); String title = res.getString(&quot;title&quot;); System.out.println(num); System.out.println(title); } } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { if(stmt != null) { stmt.close(); } connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public static void main(String[] args){ // Update(); Select(); } } 代码分析： 对于连接数据库这种操作，一般不在JSP中操作，而是用javabean来操作，也就是说在创建一个java文件，将其作为数据库处理的文件，然后再JSP文件中连接该文件进行操作。 引入数据库驱动，首先要去网上下载一个数据库驱动，不同的数据库系统驱动不同，这个是由数据库厂商提供的。下载完之后，就将其copy到Web App Libraries文件夹中。然后就可以使用该Class了。 然后就是： Statement connection = DriverManager.getConnection(url,name,pwd) 使用该句来连接数据库（注意：在Java文件中，该句需要添加try…catch…）。 增删改数据库: Statement stmt = connection.createStatement(); String sql = “insert…”; //该方法返回的是受影响的行数 int res = connection.executeUpdate(sql) 查数据库：查数据唯一不同的是执行语句： String sql =”…”; ResultSet res = connection.executeQuery(sql); while(res.next()) { int num= res.getInt(&quot;...&quot;); String title = res.getString(&quot;...&quot;); System.out.println(num); System.out.println(title); } 注意：在获取数据库内容时，使用:ResultSet res =connection.executeQuery(sql),这个res是一个表的集合。可以类比遇一个Iterator 使用一个while循环来使用获取全部的数据。 res该对象含有：next(),hasNext()等方法来获取下一个。主要的还是get方法。但是获取不同类型的数据需要用不同的get方法：getInt(“name”);getString(“”)…like this。 最后需要注意的是，连接完数据库后，要把链接关闭。 stmt.close(); connection(); 这两个都要被关闭！ ##Last but important##就上面这几句代码，emmmm，在网上找了一天，现在才发现，网上的资料的参差不齐，终归还是要看文档，不行就看书，then，看视频。经验，哈哈哈。还有6天，做一个Demo吧，哈哈哈。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"JSP基础部分","slug":"JSP基础部分","date":"2019-01-30T13:46:43.000Z","updated":"2019-01-30T14:43:15.712Z","comments":true,"path":"2019/01/30/JSP基础部分/","link":"","permalink":"http://yoursite.com/2019/01/30/JSP%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/","excerpt":"JSP这几天把JSP基本部分看了，方便记忆，还是回顾一下。文件部分有一点复杂，所以后面直接单独解析一下。","text":"JSP这几天把JSP基本部分看了，方便记忆，还是回顾一下。文件部分有一点复杂，所以后面直接单独解析一下。 日期处理其实日期处理部分还是JAVA中的Date()对象提供的。只是之前学习JAVA是没认真看，哈哈哈。 获取时间eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*, javax.servlet.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;显示当前时间与日期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示当前时间与日期&lt;/h1&gt; &lt;% Date date = new Date(); out.print( &quot;&lt;h2 align=\\&quot;center\\&quot;&gt;&quot; +date.toString()+&quot;&lt;/h2&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 提示：任然是实例化Date对象，然后对该对象进行操作，其中该对象有以下方法： 序号 方法 &amp; 描述 boolean after(Date date)如果比给定的日期晚，则返回true，否则返回false boolean before(Date date)如果比给定的日期早，则返回true，否则返回false Object clone( )获取当前对象的一个副本 int compareTo(Date date)如果与给定日期相等，则返回0，如果比给定日期早，则返回一个负数，如果比给定日期晚，则返回一个正数 int compareTo(Object obj)与 compareTo(Date) 方法相同，如果 obj 不是Date类或其子类的对象，抛出ClassCastException异常 boolean equals(Object date)如果与给定日期相同，则返回true，否则返回false long getTime( )返回从1970年1月1日凌晨至此对象所表示时间的毫秒数 int hashCode( )返回此对象的哈希码 void setTime(long time)使用给定参数设置时间和日期，参数time表示从1970年1月1日凌晨至time所经过的毫秒数 String toString( )将此对象转换为字符串并返回这个字符串 日期的比较 使用getTime()方法得到毫秒数，然后比较毫秒数就行了。 使用before()，after()，equals()方法。比如，new Date(99,2,12).before(new Date(99,2,18))返回true。 使用compareTo()方法，这个方法在Comparable接口中定义，在Date中实现。 使用SimpleDateFormat格式化日期eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;%@ page import=&quot;javax.servlet.*,java.text.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;显示当前时间与日期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示当前时间与日期&lt;/h1&gt; &lt;% Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd HH:mm:ss&quot;); out.print( &quot;&lt;h2 align=\\&quot;center\\&quot;&gt;&quot; + ft.format(dNow) + &quot;&lt;/h2&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; SimpleDateFormat格式码 字符 描述 示例G 时代标识符 AD y 4位数年份 2001 M 月 July or 07 d 日 10 h 12小时制， A.M./P.M. (1~12) 12 H 24小时制 22 m 分钟 30 s 秒 55 S 毫秒 234 E 星期 Tuesday D 一年中的某天 360 F 一个月中某星期的某天 2 (second Wed. in July) w 一年中的某星期 40 W 一个月中的某星期 1 a A.M./P.M. 标记 PM k 一天中的某个小时 (1~24) 24 K 一天中的某个小时，A.M./P.M. (0~11) 10 z 时区 Eastern Standard Time ‘ 文本分隔 Delimiter “ 单引号 ` 页面重定向页面重定向是指在client访问a.jsp时，根据据需要，a.jsp页面将请求重定向至另一个页面。注意这一个过程中，a.jsp的所有内容都不会返回至client，而是直接将请求引导至新页面，也就是说client会进行二次访问，新页面的加载还是又client来完成。 eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;页面重定向&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;页面重定向&lt;/h1&gt; &lt;% // 重定向到新地址,关键部分 String site = new String(&quot;http://www.runoob.com&quot;); response.setStatus(response.SC_MOVED_TEMPORARILY); response.setHeader(&quot;Location&quot;, site); %&gt; &lt;/body&gt; &lt;/html&gt; 还有一个类似的请求转发，而请求转发是在接手到client的请求后，在server端进行请求，然后再这个请求的基础上将新内容返回。也就是说，该种方法只经历了1次请求，并且转发只能是转发到本次请求的服务器，而重定向则可以定向到其他服务器。(进过我的测试暂时是这样) 我在看这一部分时，想在重定向或者焕发之前给client一些提示，但是由于该页面的内容内容根本不会写入到response中，所以是不能实现的，在网上查找了一圈的资料，基本都是说使用前端来实现跳转，才能给客户端反馈。 比如: out.print(&quot;&lt;script&gt; alert(&quot;即将跳转至百度！&quot;); window.href=&quot;http:www.baidu.com&quot;; &lt;/script&gt;&quot;) 所以，如果使用重定向或者是转发，是不能给客户端提示的，如果要提示，就要用前端实现跳转。 JSP点击量统计在菜鸟上，对于统计量方法的实现，时使用application对象来存储一对键值，在访问时动态变化，实现访问量统计。所以我们看一下applicant这个对象，它有以下特点： 在服务器启动时自动创建，在服务器关闭时自动销毁 一个网站仅有一个application，也就是说所有的客户共享一个application。 所以如果服务器遇到宕机，那么这个量就被销毁了，所以最保险的方法是将其储存到数据库中，并定期刷新。保证不会频繁访问数据库，又可以最大化的保存数据。 eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;访问量统计&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Integer hitsCount = (Integer)application.getAttribute(&quot;hitCounter&quot;); if( hitsCount ==null || hitsCount == 0 ){ /* 第一次访问 */ out.println(&quot;欢迎访问菜鸟教程!&quot;); hitsCount = 1; }else{ /* 返回访问值 */ out.println(&quot;欢迎再次访问菜鸟教程!&quot;); hitsCount += 1; } application.setAttribute(&quot;hitCounter&quot;, hitsCount); %&gt; &lt;p&gt;页面访问量为: &lt;%= hitsCount%&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; JSP自动刷新我其实觉得这个功能可以在前端实现，不过也许有些时候必须要使用后端实现呢，所以还是看一下，其实就一句： response.setIntHeader(&quot;Refresh&quot;, 5); eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;自动刷新实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;自动刷新实&lt;/h2&gt; &lt;% // 设置每隔5秒刷新一次 response.setIntHeader(&quot;Refresh&quot;, 5); // 获取当前时间 Calendar calendar = new GregorianCalendar(); String am_pm; int hour = calendar.get(Calendar.HOUR); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); if(calendar.get(Calendar.AM_PM) == 0) am_pm = &quot;AM&quot;; else am_pm = &quot;PM&quot;; String CT = hour+&quot;:&quot;+ minute +&quot;:&quot;+ second +&quot; &quot;+ am_pm; out.println(&quot;当前时间为: &quot; + CT + &quot;\\n&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 通过这个栗子可以看出效果，当然，对于日期的刷新，不肯能用这个东西，肯定是局部的ajax来实现。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"JSP中的表单编码问题","slug":"JSP中的表单编码问题","date":"2019-01-28T12:13:29.000Z","updated":"2019-01-28T12:35:17.410Z","comments":true,"path":"2019/01/28/JSP中的表单编码问题/","link":"","permalink":"http://yoursite.com/2019/01/28/JSP%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8D%95%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"JSP的编码才看了几天的JSP，把最重要的表单提交看了一下，遇到了中文编码的问题，然后我查了一下JSP的默认代码是：ISO-8859-1重新设编码的语句共有下面几句：","text":"JSP的编码才看了几天的JSP，把最重要的表单提交看了一下，遇到了中文编码的问题，然后我查了一下JSP的默认代码是：ISO-8859-1重新设编码的语句共有下面几句： pageEncoding=”UTF-8” contentType=”text/html;charset=UTF-8” request.setCharacterEncoding(“UTF-8”) response.setCharacterEncoding(“UTF-8”) pageEncoding=”UTF-8” 是在第一阶段，转换阶段（即将JSP文件转化为servlet文件的过程中使用该局代码提示的编码） contentType=”text/html;charset=UTF-8” 是用在第二阶段，将servle渲染为html时，使用该语句的编码 request.setCharacterEncoding(“UTF-8”) 是用来指定对浏览器发送来的数据以特定的字符集进行重新编码，常用于对 POST 请求参数进行解码。 response.setCharacterEncoding(“UTF-8”) 是用来在服务器将响应返回到浏览器前，对响应使用指定字符集进行重新编码。一旦使用了该种方式，即使该响应页面指定了具体的 contentType，也将失效。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"编码","slug":"编码","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"Python3_CGI编程踩坑日记","slug":"Python3-CGI编程踩坑日记","date":"2019-01-14T12:25:07.000Z","updated":"2019-01-14T14:02:46.626Z","comments":true,"path":"2019/01/14/Python3-CGI编程踩坑日记/","link":"","permalink":"http://yoursite.com/2019/01/14/Python3-CGI%E7%BC%96%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/","excerpt":"Hard-start这是学习Python的第六天，也是进入Python高级编程的第一天，嗯，对，然后我就遇见了Big Problem，甚至到现在都还有一个问题没有解决。","text":"Hard-start这是学习Python的第六天，也是进入Python高级编程的第一天，嗯，对，然后我就遇见了Big Problem，甚至到现在都还有一个问题没有解决。 Problem I met Apache的安装问题 在得之要使用Apache之后，我直接就百度Apache，然后再官网首页 结果下载下来直接用不了，解压了发现文件不对。然后一搜教程才发现文件下载错了。 应该在这里下载： 终于完成填了第一个坑！ Apache配置问题 要启用CGI，必需修改配置文件。而这个配置不仅仅是是一个地方，是n个地方： ServerRoot配置 ServerRoot “” 主要用于指定Apache的安装路径，此选项参数值在安装Apache时系统会自动把Apache的路径写入。Windows安装时，该选项的值为Windows安装的路径，Linux安装时该选项值为编译时选择的路径 找到： Define SRVROOT &quot;${SRVROOT}&quot; ServerRoot &quot;${SRVROOT}4&quot; 改为： Define SRVROOT &quot;D:\\web\\Apache24&quot; ServerRoot &quot;D:\\web\\Apache24&quot; 其中”${SRVROOT}”应改为你你安装Apache的目录。 Listen 配置 Listen主要侦听web服务端口状态，默认为：80，即侦听所有的地址的80端口，注意这里也可以写成IP地址的侦听形式，不写即默认的地址：0.0.0.0 找到： Listen:80 改为： Listen:8080 一般不为80，因为容易占用，改为其他好一点。比如我改为8080。 CGI配置 找到： AddHandler cgi-script .cgi .pl 改为： AddHandler cgi-script .cgi .pl .py 这里是增加对Python的支持。 找到： &lt;Directory &quot;/${SRVROOT}&quot;&gt; AllowOverride none Require all denied &lt;/Directory&gt; 改为： &lt;Directory &quot;D:\\web\\Apache24\\cgi-bin&quot;&gt; AllowOverride None Options Indexes FollowSymLinks ExecCGI Require all granted Require host ip &lt;/Directory&gt; 注意这里/${SRVROOT}任然还是Apache的安装地址。 Python解释器 我就这么按照runoob上代码粘贴下来，like this： #!/usr/bin/python3 print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是来自菜鸟教程的第一CGI程序&lt;/h2&gt;&apos;) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) 然后就出现了500错误，下面是log里的提示： [Mon Jan 14 11:31:58.626473 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。 : [client ::1:52212] couldn&apos;t create child process: 720002: hello.py [Mon Jan 14 11:31:58.660452 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。 : [client ::1:52212] AH01223: couldn&apos;t spawn child process: D:/web/Apache24/cgi-bin/hello.py 百度了半天，突然想起Apache如何载入编译器呢，然后直接百度上面代码的第一行： #!/usr/bin/python3 然后才知道这是Linux下Python的解释器位置，我枯了。然后我找到了自己Python3的安装位置，却发现没有exe文件，我又枯了。但是用sys自己的命令： import sys sys.path 得到了就是这个位置。不管了，直接写吧！于是得到了这一段代码： #!D:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python.exe 没错，就是这么长，不知道自己当时怎么安装的。我又枯了。 结果成功解析了！！！ 但是！！！ 又乱码了，检查了py文件的编码，发现py默认是utf-8啊。然后终于在网上找到了解决办法。没错，是print()函数的问题。 又大佬看print()源码使用Unicode，果然乱码了，然后引入了这一段代码： import io sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) 即：将print()函数改为utf-8编码输出，终于留了一张图： 附上正常获取text，textarea的代码，其他的都一样。 (text.html): &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/cgi-bin/text.py&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt; &lt;input tyep = &apos;text&apos; name = &apos;name&apos;/&gt; &lt;textarea name=&quot;personinform&quot;&gt;个人信息&lt;/textarea&gt; &lt;input type=&apos;submit&apos; value=&apos;提交&apos;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; (text.py): #!D:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python.exe import io import sys import cgi, cgitb sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) form = cgi.FieldStorage() name = form.getvalue(&apos;name&apos;) personinform= form.getvalue(&apos;personinform&apos;) print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;) print(name) print(personinform) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) 下面是get从url来获取键值的方法： #!D:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python.exe import io import sys import cgi, cgitb sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) form = cgi.FieldStorage() name = form.getvalue(&apos;name&apos;) number = form.getvalue(&apos;number&apos;) print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;) print(name,number) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) last problem(unsolved) 最后一个问题就是CGI的文件上传问题。由上面的代码可以知道，所有接受的数据都来自： cgi.FieldStorage() 网上的教程都这么获得数据： import cgi, os import cgitb; cgitb.enable() form = cgi.FieldStorage() # 获取文件名 fileitem = form[&apos;filename&apos;] # 检测文件是否上传 if fileitem.filename: # 设置文件路径 fn = os.path.basename(fileitem.filename) open(&apos;/tmp/&apos; + fn, &apos;wb&apos;).write(fileitem.file.read()) message = &apos;文件 &quot;&apos; + fn + &apos;&quot; 上传成功&apos; else: message = &apos;文件没有上传&apos; 但是问题在于， fileitem.filename == none 我直接输出 fielitem fileitem = MiniFielStorage(&apos;filename&apos;,&apos;test.txt&apos;) #test.txt为上传的文件名 所以fileitem.filename始终为none。所以一直解决不了，查了各种资料，不过官方文档里有类似的解释，但是还是没有解决办法。明天再看吧~~~难受啊，马飞~","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"CGI","slug":"CGI","permalink":"http://yoursite.com/tags/CGI/"}]},{"title":"欢迎2019-假如我年少有为","slug":"欢迎2019-假如我年少有为","date":"2019-01-13T12:08:09.000Z","updated":"2020-01-08T15:38:47.126Z","comments":true,"path":"2019/01/13/欢迎2019-假如我年少有为/","link":"","permalink":"http://yoursite.com/2019/01/13/%E6%AC%A2%E8%BF%8E2019-%E5%81%87%E5%A6%82%E6%88%91%E5%B9%B4%E5%B0%91%E6%9C%89%E4%B8%BA/","excerpt":"不知道怎么开始这一篇文章，首先应该是欢迎2019吧，又度过了一年。真要回忆这一年，我竟然没有多少印象。我尽力去回忆，尽力去把这一年的日子换算成有价值的东西。不知道我什么时候变得如此的现实，一切似乎都不能是白过的。","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX18t3lIwMshaeRtBlH9MsYJWDNnpStSyBeYmB5bx2WbGYEJP+RXTsndW9PeZXgYnT2hpbl0u5PchxI74i+BE3ipdoITuaB4f09KJBpx3a+chbr9I6fU91aHL8rCkKLDxr/V/GstVorY2RswiBD+XjZosesypI2A0TDRSKkB0/r/XWlgxPMVi6z5ItJ7ldf5Jsj/G4GSnRJR3zSTetf1cmV+u6VQ32TyxvzaetDiUIjFKO2utu6X/72usZ9JKj9qGLT8pUOT/PCbH0G+G3BjKvAVvW4on0lc9F1kjkwR5WpYfdUXmUXyWwN2Xh6z9rCCm+wETGX79IhOScJyH/CgMZMrgdTAq6nhjxKW66yUDJpB8HQojlyYGFZWlIDkEueoU4CUveGvlX6v+DSHnvpxcjMwIpYq3/5aMZEDiwZx+5AqE6Cp1win4B10cKzfSFirct3+dgejSm+x5/Ka+n+59zqD73cDT2jeoYjtdXQnJXEZS5pSr/VAl6yxdARvlA0sqEoktS3OAcg6A2oRO+JaOGtmy5tT3a6LNNgHr87ZLcd/+Lq/9drb4BsZxHfDHA1a7xBFjhBEfd6Pinpngffqx8Q9f/3RpAA+phF6kSeFX00Z8rNLRxrUj7mJoQ8TteV1nc74XgroEiEkfJd6XsEV9PtnyyHCBAgH87cQ6ZtvK4EmmtwKDABPOq2RP+tlGOOmPHz+W8y1Wwd6+XkaooyScPWS7Yd/KyOQ5oQNb25Lxh/u56U3DjdkN2ipB+EAq/MNhKSfl2mWTn+2poK3z+DdWfPu7Hz6SFYhNBVsO7Jc6tP/k1fFPyzLVFXREj5NWW6xVxTpwf5nIfe6G2OUvOp4sXRGujaIg3LyF2/c928vyW7oLMpACUhQPUH6ZdaLH8B5HvZ83W3DT4xGh4+UQ366M3GxZACbuMHMnNrZyKAu44PAwOCwnXh3m0+cG86yO+ATEdGedNFqCcojfDTELZ7xkdbKsLUelkJMqlAATm2RM3JkMKC0iq6MGnsqTu4c0fUXD7+wiXZ+TDhiWlU2dp2tRVvfzmQCuQCYHnmtRrTbFo2XuXPeAnsBQ5u1QdvFgVzh8d7PTnQG3HOvDUwGij5/wTn1YCCfrwMaaRsHKmmNq+dlKdY4tD+mHWkIMbdO77tsg5My7rh1D/9Y/b712Fz9UBFDz3GmQf1jYaqIeIBn+VqZYeOTRASBf0CE5w8WzS/KvQBvB94W1VSene9KvnNBg2gtAA5Mwba2F2SIXMWlLIm/VxyBiDFycjzihcvGzQCFQzw+UvmASVI/LC7vSx41Ti0NNCS3tsd2PK/a50q8vYjErt/FppXeWE92mpOS1zHnsicApTZOlhu1WLA50XlgPM5Fz7S6mMySg8eUnkW9DUj0J5mNNKNeMAlY6bAgOqQJWLxOiMv/pxG3JHHqIOckl/wQOlZXbKFq/IzoLsHekVZH2Rexv3A7xoz9RWRjhkTAfaL5A6acqln18ten41tiiiZYoLoDTQ9e1wJHDAtFUkZxNdun+fYistJVAc9jWI8XiZAGCJZT9dS7bhejqQdF92Ja6VndRNeCN3HhKX3Q5wsWcrmV2Lo87HImHT5CrYxrzDoWp2Tv0HlhHVmJdJXhY3ytyYTs8Zy+j+oNHIef5Tpqdbr0xtj0EkVn18UB/sTXs7EviZfqi1rqDyjDZil/P9js1UyKS1NwNJwP5pI/gi9p1h4y6Yc7ipUFPf+17WZ7m6+FczyG+BU1efmITgrH1ZGiti2ZpiVFsaNCJUymu2sTF8WvdH8AtY875L/eAmCB7boZDaov+UIzWRsrkb1UhKsss3bTOz9rHArizJvffUi7OACDVHgGtQmUJQBBcuJ47uZiiVFtdsqOg+rbcU4VCcx+sbSLJtvKetU8WAjXr0Vq4ytKie8aD3j4ZmywORBS4jBfNGgKHCqDfA/kBapqbru3q5Bz7W+cIWL3BC2YBgGnlkPOpLIgmtS+Fr6aOs/tDY4xCCpMIdfuAfjDnhmHglFW7aiU3xgs2kQmOdkGtAWIiNcNoqVWc1hXzg+lbY35z+rof0xSdFfNZ/NeRcHEtHdblx9U6rFgdL8N1HTPHMJgWIr30qYYKqPalZgP7NZbBvJi0DEZJFltPUPCTzLJvp4wegU8RR83wiqD608v51AARDYQTFF6M21gA2xcWcyQxGE7e+DDbWTBu+h4yrwojpcOTjSokUi51CIGSE93d0wv6QqApZLMweGPTUoVNG2olJdowhhADZR86RZBEDAM81YZM6dyJLYdGVQKkVC0PCJu5f1lOhAdQSralRYvRlndPqljik0IA2IsvRr2He1n0YhyLEofVrnfXY834T0qM9klpQGkUDdvpk/3eBchtFIpGAU42/KOnVDnv8evFb4NGsZYlWKhC5TDVjRWO4cZrQhdRQDoGPlOnj4oEhLnx+YfiXJTljGVWKn3yuSw2eHJELv35wgMbW1uvmbzyjAyhaYPlFtrRju+nFbpOodIvh7wgOTZbFxAai8+Y7NVand2z/vKl/3sqVB4R1dFA1vTpI8Dh1vuQ8kJkHoCSz1YvjTNDZJy6RA30KvPogeJTkF8a+CZLoGswAF1aF88UCuKpPkTnMTw5JM0B/J5hssvebaitoRMBYZcz2PS7jDSGAzHh07KMjU4nydfc8AYzCfRPs5cO2rN/RoqlDkUelaH0oRD9tO7rN3Njme8tTCFXvjmCjo+ZDhQLx7o1unHECErVScdBj3d8xyCVQ6engg/iUUjT8K93QFshsQTq38zOhe95AiIHBienqvgfNphykjj++sPjYdzLoBj99XheBwxptVbsSIshAEpFdMMhGDP7OzyJjp9OXJiO4ziDn+112Y5sN//jSnl048qO7gTx9NtaT2d5bESwba/yG0Ssp5QtLU1vGOGt2qk7Q+npEtMd6Y6i0jNPBanU9/s9hqYEm9yXHdYPsOKlPZiLeVDHGb3/ZtUk0FX5r3sFDY/ba98cayxP7ghcNTxWeia7Zze1mEddm2FwKorHyPkBRSQT8bmZN/60o53Lx4fKvuh+eJYwl/9HKM/iJtHG0Mvgkx74aRMyn12ILRGQNPmVE9NxhhyQ7eG9FnHDdO2A7y++TKl0G60TEHvdi6MGbDawRFfHrG+Hc+aXt0ESNfD4GcGRF/t4fTWm7D4+WG2AsZ3Ezu2U5iYAF76K73jYtOeZM0uKaJhQL5FsZ4ASSYZYO+YBy/4Zki2Oj4jJEtB6SK0MSx0eSBStRD6nhxa7n4GVilW/OJOQ6sfb6mNUlytwDUXVMfvmRFWm+7rLoWug5HT6UkHZspxy8Kpzc09qG0qF53ld6bkqIuvk2nuMShUJKrlbwLrxxFgEA9zqpCCG1w/SWTgsocbtAjAtpscCo0GHHVUV7YD+lIb0A20HLuiKsiaE/T9S6nvyQipwNn39Gpc5d+1O8JVqDbfLAZGfTrpDcPmRyKWV4npwxFhTldh057pQjjTdOahLYOB+E3BTk3AkPWbS1jN1jsBximTiAaSrI/DsitL9Xe+ITcCmikfHitF38nhOkPOvEDTz0+8sOl+WOFq6gWhjvqJ8i1EfXqZnrXIL2Q+s2Mb00R0M1pjEA82vhzxaJjzFBJ7j7AleWOtfWI2qGftsKXbt/n4muTfJYROWCarX2HD+ZeBAD9VFL7c1KPgPgaj93UfjWAjxHpPW/6zGeyulNm2VuzTlWnO+znhtiwxwMUSWoNFBjPaCiinApASFsiJsSYgYn/wIYq4Q0MLZeLd7wxKyQUWP8hFPYm20idj+4gEvxq2zPEDlLhzYqcgpyTz+pVXYlfPKogADoK19AtVyCrKmijZsUnjOHZO9oxBDNcqJYbP6ZUT5dHX3eBfN4rRz0d5cby+1DrsbfKAmWsvQ+YcjKB6HRKW+VQuVr7u7QP9HP6KSr9uQr2T0u+XQ8qDSvJu3GIoS59utW4A/igR4p6HhvL7bStN9mxaDhrgpRTzRTUjo8wt1swNgSEQwomFBGs6kM5dFp2FVOCaOQ/Jvfu4pLPAFI2oWiErml+oZT9WAitKJ8Few5pOAmwFZ5D710zOhBfQEh+qFiO9dz6sWkucGDKaoS1870MkkQ+JZcD9nPMK7LwREtzQCAihZ/BnDa6slTrKB8+6vfWCRAAmUglkVtgME1Yu0gigZBgvFBn2p2f5fTyyuCCB4kjyJF+KNyJaXqdTiys2b+cIlGMxrzKDpsIWDiNmQDeLu/4rzmXE9ZLb9QK9JGFRK6zxjVlM2VT9YxbvFaKRHSTYYl89deHEMajRJKIFfovxxlTEFAwtYZEe5LfPHiI9UfTFohAV47xMcqbVyxHU5XofKwUFGcpjMZDmE22usEDdoUvsiWuwNsV9CYYY+XG+WYKrlGba6aN1tiUcwfvl6Zn14wotpFiSS3SyBvRpVCR0cWmPSj47+N7Mlu1Pvu/3N6kj9gFco5R6eZS4hjTI4ki9f+HS+3VgVnhABAxMcml79FnCUOTQcYCuq6ifu7NNVVQHiI3Ofs2ZLL+QVg0M1feSileL+kA8YNItnnbk5x1BrvlDrDq1G+6mkGnW7xUpq5t9QpQZ+QwaBsJZngtaAOvNfxNXgTExX7Cibf/1LmrSBm2CGKPEOD93LDmrdy9TqXagJKktUFarOyAOtK7ykQkJPIb77LsZ6sS7IpAwAskOTRGmTK6lHkzmYnYzO8E+liesgxIHOwnhhKk/kOwyYJooMbZ8l5oVjmVQ7162SYm5Yqa/l8MXMFQDKTGC+2+//I9Ns0SAT4r3mtlSJdKSdQgHkeoUK3FRhIUZYVVoFU+489RY4nkbNLxx/VCpfxgpPqb0X/ddoYtwICYBSF23ucAjg8mgBRWUKNSdRDbN2IxGHNDan8DRnEX7ZVyeWXz3xc1xguZslQSLNRb4nFdoZlD/q2wFDwh+Xyr0SqzApp06KyjKVwDvt2um7kg/8gLWjziO31LnPXIJzLjNziqQJQonVYVTGyYMA+oagvwu/pa3UhrHbJQdRxS4Yxd4VYd3LABKtCcCWNFCUcAlifbdC0SOhE1inm6vXlHTO6+MWs0gD2/nw1YVO9/wAoM4cU84Ea5La3h1aBx9nk7xbeTFXSTc8OBbmkFlvc84zFBkI6hslupTFy8iXBL2uewOA4FFY+CTL78EVmyOLjqUv7dASaAK2bYtH65iPyBNw/6lc90RDuhc9nVyWhHZD8ghQ3aQAOoxbqDOPijgGiahhqcWNHEoHTKI8g1rL+/8eY15aRq9x+Tm7IrqlumiAu/9ZKXgqlgcEDah/89NDh3R7xxsDI1mHe8fDpjsito360V8FuLHoadR5dlqbZJs6S1Uw8rYMFXjVASbeF9eJPfCl4HR18BE2T8RNw+xxn3yo4gQLDT3DY5/SGYpHHCj64MdVnzyPHw7prCfKVIXWgDpE2l3ZpP2zgD5IEa3pvz+g+qkvpeJMWIXs/8EckeKatE9/mrDrMVEaHrUJXgFbBR9H0WIjSdOEKC3TDytnsZaxlFH0hr04q0o5wRZDevh/5GtEVdGKfZvhHLpha6kFyuXL8q026vgOtAv7Z3bmbVc9jhj/ODxSMu1YRfu9ZRr+YrD1a0WM12/EjqemnjBjbaxXpwMsvJEeHLOT/MisWDEV83YS0iMbp7ZDeOpjNH1bJz02meXIYsV0OCdr62fcx+Yk/5UqAO09Kd7hHp+l0g4t8MjyFuTaz1C8MnYcTvHUNb2xu9SqwjJpbzdedVEN6+KQnJzIAc3GzivqeKpx+PQJG2lni+l0jz1RKQtAqhWzxpRTTXBfFrL+s6Q3Dku6xR9T9O7NdzlJrvlhxEvNHs/b9SXp1wg/pmhjURV3ShW4l88JKACXTpMyCyUF9x4jxNxLPnqrvMldQs9dS2nqwuhVBTFte0HqotcR0Yglz1sFNRkf4yFaNzdcjxkS9g6knvn1vTCyvqjbRCm2MO3hel5uf65KzkJnS+wVK8BbyUACh1Zl82lvQMd7J5ElqPgn/wtAJoJBGR+WZ4dhQ9zuIOGlEWFfgYfxpGLrrI2mYU48A12rfmwGEMXfAtO94ewCYZItwGoNlrrgckoWC4fLEfSwUAjLQxk0mwy7UIzbICtf/RafPfzeqfwLeBnrSlLMncuXfD3f16scapd6eHKhI35xriHn9WLJ1bTaTdumioauoFfk8J78EYdnkbOukPE9fx/XDoymEsTELKCiWnec2z7OqQxiBCsboPSBGTnOsG2+W0mbqFQrQ+UpbTUW6zn/n5/D2BYTvXg0dWXQwv91kdAev70Tb5YslVH9qivNu+CSjJcyrDKY2eSxBgT1IyrLgkoGI1T3A85+TVmLvFIHAHJeFvOX8P/6sxo7DxSDlhiieLmzwFVl0LukhS8qtP8kP2hTjujIH7emciPaMpiC1uFVc/1xd+wbdmwBK6h+pY+iSvMI3YSSsG33kNWxf/39klZYml4HOqFKGUwVcCkZwj4R4unkJIUhG+53NY68QWsHTucQmc9GIN4NwpLskrxaJtaa0TbF6dfQAYJOZ5qYjA5D9WaSxt6btavNt0RkLcmdD/PkI+UfsA== var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"2019","slug":"2019","permalink":"http://yoursite.com/tags/2019/"}]},{"title":"周报(0)","slug":"周报(0)","date":"2018-12-01T04:10:17.000Z","updated":"2019-01-12T15:31:43.707Z","comments":true,"path":"2018/12/01/周报(0)/","link":"","permalink":"http://yoursite.com/2018/12/01/%E5%91%A8%E6%8A%A5(0)/","excerpt":"LeetCode： 简单思路：令i从0开始向后跑寻找与下标为length-1不相等的数，找到之后将那个数放到length的位置上，并且令length长度加1，最后返回length就行了。","text":"LeetCode： 简单思路：令i从0开始向后跑寻找与下标为length-1不相等的数，找到之后将那个数放到length的位置上，并且令length长度加1，最后返回length就行了。代码部分： int removeDuplicates(int* nums, int numsSize) { if(numsSize==0){ return 0; } int length = 1; for(int i=0;i&lt;numsSize;i++){ if(nums[i]!=nums[length-1]){ nums[length++]=nums[i]; } } return length; } Java学习部分内容重写与重载重写：在子类中1. 参数列表必须完全与被重写方法的相同 2. 返回类型必须与被重写方法的返回类型相同 3. 访问权限不能比父类中被重写的方法的访问权限更低。例如，父类的一个方法被申明为public，那么该子类中重写该方法就不能申明为protected。 4. 父类的成员方法只能被它的子类重写 5. 申明为final的方法不能被重写 6. 申明为static的方法不能被重写，但是能够被再次申明 7. 子类与父类在同一个包中，那么子类可以重写父类的所有方法，除了声明为private与final的方法 8. 子类与父类不在一个包中，那么子类只能够重写父类的声明为public和protected的非final方法 9. 构造方法不能被重写 10. 如果不能继承一个方法，则不能重写这个方法 super1. 在父类的某一方法被重写后，如果需要调用原父类的方法，需在该方法前加super关键字 重载 ：在同一个类中1. 被重载的方法必须改变参数列表（参数个数或类型不一样） 2. 被重载的方法可以改变返回类型 3. 被重载的方法可以改变访问修饰符 4. 被重载的方法可以声明新的或更广的检查异常 5. 方法能够在同一个类中或者一个子类中被重载 6. 无法以返回值类型作为重载函数的区分标准 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 来自 http://www.runoob.com/java/java-override-overload.html 2.多态：同一个行为具有多个不同表现形式或形态的能力。 向上转型：子类引用的对象转换为父类类型称为向上转型。 重写式多态：也叫运行时多态，这种多态通过动态绑定技术来实现，是指在执行期间判断所引用的对象的实际类型调用起相应的方法。 Animal animal = new Cat(); //向上转型 1. 向上转型时，子类单独定义的方法会丢失。比如上面Dog类中定义的run方法，当animal引用指向Dog类实例时是访问不到run方法的，animal.run()会报错。 2. 子类引用不能指向父类对象。Cat c = (Cat)new Animal()这样是不行的。 向上转型后方法引用的优先级问题： 继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 注意：此时的（super）O 指的是O的父类。以下面的8为例： b.show(C) 由于b的引用对象为B，所以可以调用的方法有：show(B)，show(A) （this.show(O)） 又b的类型也为B，所以方法也先在B中选择，发现没有show(C)方法 （super.show(O)） 在B的父类，即A中查找show(C)方法，任然没有查找到 （this.show(super)O） 原式为：b.show（C），又C的父类为B，所以该式变为：b.show(b)，并且在B中查找，找到了该方法，于是执行该方法，得到结果：B and B 实例class A { public String show(D obj) { return (“A and D”); } public String show(A obj) { return (&quot;A and A&quot;); } } class B extends A{ public String show(B obj){ return (“B and B”); } public String show(A obj){ return (&quot;B and A&quot;); } } class C extends B{ } class D extends B{ } public class Demo { public static void main(String[] args) { A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(&quot;1--&quot; + a1.show(b)); System.out.println(&quot;2--&quot; + a1.show(c)); System.out.println(&quot;3--&quot; + a1.show(d)); System.out.println(&quot;4--&quot; + a2.show(b)); System.out.println(&quot;5--&quot; + a2.show(c)); System.out.println(&quot;6--&quot; + a2.show(d)); System.out.println(&quot;7--&quot; + b.show(b)); System.out.println(&quot;8--&quot; + b.show(c)); System.out.println(&quot;9--&quot; + b.show(d)); } }//结果：//1–A and A//2–A and A//3–A and D//4–B and A//5–B and A//6–A and D//7–B and B//8–B and B//9–A and D 从4向后的解析原理：当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。Animal animal = new Cat(); //向上转型 Animal为引用对象Cat为引用变量 首先，a2是类型为A的引用类型，它指向类型为B的对象。A确定可调用的方法：show(D obj)和show(A obj)。a2.show(b) ==&gt; this.show(b)，这里this指的是B。 然后.在B类中找show（B obj），找到了，可惜没用，因为show（B obj）方法不在可调用范围内，this.show(O)失败，进入下一级别：super.show(O)，super指的是A。 在A 中寻找show（B obj)，失败，因为没用定义这个方法。进入第三级别：this.show((super)O)，this指的是B。在B中找show（（A）O）,找到了：show(A obj)，选择调用该方法。 输出：B and A 上面的例子简单的介绍了多态的意义，同一个行为具有不同的表现形式或形态的能力。 多态（重写式）实现的条件： 1. 继承（实现） 2. 重写 3. 向上转型 重载式多态：也叫编译时多态，也就是说这种多态在编译时已经确定好了。在调用这种方法时，通过传入不同的参数得到不同的结果。 此处重载式多态有不同的说法，部分观点认为：重载不属于多态，认为多态仅仅指的是在程序运行时根据不同的输入，而方法有不同的响应称之为多态；但重载指的是：在一个类里，方法名字相同，而参数不同。也就是说在程序编译时就确定了该方法的响应。所以不能称之为多态。关于这个部分，我还没有更深的理解，所以暂时保留意见。","categories":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/categories/%E5%91%A8%E6%8A%A5/"}],"tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/%E5%91%A8%E6%8A%A5/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"JavaScript数组（二，ES6部分）","slug":"JavaScript数组（二，ES6部分）","date":"2018-11-02T10:06:23.000Z","updated":"2018-11-02T10:08:09.215Z","comments":true,"path":"2018/11/02/JavaScript数组（二，ES6部分）/","link":"","permalink":"http://yoursite.com/2018/11/02/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%8CES6%E9%83%A8%E5%88%86%EF%BC%89/","excerpt":"前言上次介绍了ES5之前发布的JS的数组方法，这次再看一下ES5中发布的JS方法。","text":"前言上次介绍了ES5之前发布的JS的数组方法，这次再看一下ES5中发布的JS方法。 正文 indexOf()和lastIndexOf() 描述： indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。 应用： 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。 exp: var arr = [1,3,5,7,7,5,3,1]; console.log(arr.indexOf(5)); //2（5在该数组的第2位） console.log(arr.lastIndexOf(5)); //5(从后向前，5在数组的第5位) console.log(arr.indexOf(5,2)); //2（从第二位开始检索，任然2在第5位） console.log(arr.lastIndexOf(5,4)); //2（从倒数第四位开始检索，5在倒数第四位） console.log(arr.indexOf(&quot;5&quot;)); //-1（数组中没有字符&quot;5&quot;，所以返回-1） forEach() 描述： 对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。 应用： 用于遍历数组，获得数组成员的内容，索引，及其数组本身 var arr = [1, 2, 3, 4, 5]; arr.forEach(function(x, index, a){ console.log(x + ‘|’ + index + ‘|’ + (a === arr)); }); // 输出为： // 1|0|true // 2|1|true // 3|2|true // 4|3|true // 5|4|true map() 描述： 遍历一个数组，并且经过处理后返回一个新的数组。 原型： arr.map(function(currentValue，index，arr),thisValue) currentValue 必须 当前元素值 index 可选 当前元素的索引值 arr 可选 当前元素属于的数组对象。 exp:通过map方法返回数组元素的平方 var arr = [1, 2, 3, 4, 5]; var arr2 = arr.map(function(item){ return item*item; }); console.log(arr2); //[1, 4, 9, 16, 25] 注意，map()方法不会改变原数组，而是返回一个新的数组，注意function中药返回值，否则为空数组 exp2: var arr = [1,2,3,7,9]; var arr2 = arr.map(function(x,index,a){ x=x+1; }); console.log(arr2);//[undifined,undifined,undifined,undifined,undifine] console.log(arr);//[1,2,3,7,9] 即使在map()的函数中改变currentValue的值，原数组的职业不会改变。而如果没有返回值，则该数组为undefined。 filter() 描述： “过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 原型：array.filter(function(currentValue,index,arr), thisValue) currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 exp： var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; var arr2 = arr.filter(function(x, index) { return index % 3 === 0 || x &gt;= 8; }); console.log(arr2); //[1, 4, 7, 8, 9, 10] 该方法的注意事项和上一个方法差不多，也是不会改变原数组，并且必须要有返回值，否则数组为undefined。 every() 描述： 判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 原型：array.filter(function(currentValue,index,arr), thisValue) currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 应用： 检测数组所有元素是否都符合指定条件（通过函数提供）。 exp： var arr = [1, 2, 3, 4, 5]; var arr2 = arr.every(function(x) { return x &lt; 10; }); console.log(arr2); //true var arr3 = arr.every(function(x) { return x &lt; 3; }); console.log(arr3); // false some() 描述： 判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 应用： some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。 exp： var arr = [1, 2, 3, 4, 5]; var arr2 = arr.some(function(x) { return x &lt; 3; }); console.log(arr2); //true var arr3 = arr.some(function(x) { return x &lt; 1; }); console.log(arr3); // false 注意： some() 方法会依次执行数组的每个元素： 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。 reduce()和 reduceRight() 描述： 这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 原型（以reduce为例）： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 currentIndex 可选。当前元素的索引 arr 可选。当前元素所属的数组对象。 exp： var values = [1,2,3,4,5]; var sum = values.reduceRight(function(total, currentValue, currentIndex, arr){ return total + currenValue; },10); console.log(sum); //25 最后这是ES6中提供的数组方法，对于ES6，我还没有认真研究，不过这些方法还是挺实用的，对于低版本的浏览器可能会不支持。感觉开发中还是要针对需求使用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript数组","slug":"JavaScript数组","date":"2018-10-25T16:22:49.000Z","updated":"2018-10-26T13:48:01.919Z","comments":true,"path":"2018/10/26/JavaScript数组/","link":"","permalink":"http://yoursite.com/2018/10/26/JavaScript%E6%95%B0%E7%BB%84/","excerpt":"JavaScript数组复习一下数组，发现有些方法都忘记了 定义数组的方式 采用直接量创建 var MyArray = [];//创建空数组 var MyArray = [1,2,3];//创建数字型数组 var MyArray = [“A”,”B”,”C”];//创建字符型数组 var MyArray = [{id:1},{id:2},{id:3}];//创建对象型数组 采用构造函数创建 var MyArray = new Array(); MyArray[0] = 0; MyArray[1] = “A”; var MyArray = new Array(5); var MyArray = new Array(5,4,3,2,1);","text":"JavaScript数组复习一下数组，发现有些方法都忘记了 定义数组的方式 采用直接量创建 var MyArray = [];//创建空数组 var MyArray = [1,2,3];//创建数字型数组 var MyArray = [“A”,”B”,”C”];//创建字符型数组 var MyArray = [{id:1},{id:2},{id:3}];//创建对象型数组 采用构造函数创建 var MyArray = new Array(); MyArray[0] = 0; MyArray[1] = “A”; var MyArray = new Array(5); var MyArray = new Array(5,4,3,2,1); 属性 constructor 描述：返回对创建此对象的数组函数的引用。 应用1：用于判断元素类型 exp： &lt;script type=&quot;text/javascript&quot;&gt; var test=new Array(); if (test.constructor==Array) { document.write(&quot;This is an Array&quot;); } if (test.constructor==Boolean) { document.write(&quot;This is a Boolean&quot;); } if (test.constructor==Date) { document.write(&quot;This is a Date&quot;); } if (test.constructor==String) { document.write(&quot;This is a String&quot;); } &lt;/script&gt; 输出： This is an Array 应用2：用于获取构造函数的原形 exp: &lt;script type=&quot;text/javascript&quot;&gt; function employee(name,job,born) { this.name=name; this.job=job; this.born=born; } var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985); document.write(bill.constructor); &lt;/script&gt; 输出： function employee(name, job, born) {this.name = name; this.job = job; this.born = born;} length 描述：设置或返回数组中元素的数目 应用：设置或返回数组中元素的数目 exp： &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;John&quot; arr[1] = &quot;Andy&quot; arr[2] = &quot;Wendy&quot; document.write(&quot;Original length: &quot; + arr.length) document.write(&quot;&lt;br /&gt;&quot;) arr.length=5 document.write(&quot;New length: &quot; + arr.length) &lt;/script&gt; 输出： Original length: 3 New length: 5 prototype 描述：使您有能力向对象添加属性和方法 应用：向对象添加属性和方法 exp: //定义一个employee对象 function employee(name,job,born) { this.name=name; this.job=job; this.born=born; } //实例化一个employee var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985); employee.prototype.salary=null; bill.salary=20000; document.write(bill.salary); &lt;/script&gt; 值得注意的是：prototyp是面向对象编程的重要属性。在W3C的解释中，可以知道函数也是一个对向（具体函数与对象的关系后续再详细讨论），每个函数对象都具有一个子对象prototype。Prototype 表示了该函数的原型，prototype表示了一个类的属性的集合。当通过new来生成一个类的对象时，prototype对象的属性就会成为实例化对象的属性。 方法 contact() 描述：连接两个或更多的数组，并返回结果 应用：连接n个数组 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; var arr2 = new Array(3) arr2[0] = &quot;James&quot; arr2[1] = &quot;Adrew&quot; arr2[2] = &quot;Martin&quot; var arr3 = new Array(2) arr3[0] = &quot;William&quot; arr3[1] = &quot;Franklin&quot; //执行连接操作 document.write(arr.concat(arr2,arr3)) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin,William,Franklin join() 描述：把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 应用：创建一个数组，然后把它的所有元素放入一个字符串 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr.join(&quot;.&quot;)) &lt;/script&gt; 输出： George.John.Thomas 注意：join(separator)中separator为间隔符，若为空择默认为逗号。 pop() 描述：pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值 应用：创建一个数组，然后删除数组的最后一个元素 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr) document.write(&quot;&lt;br /&gt;&quot;) document.write(arr.pop()) document.write(&quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas Thomas George,John push() 描述：push() 方法可把它的参数顺序添加到 arrayObject 的尾部。 它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。 arrayObject.push(newelement1,newelement2,....,newelementX) newelement1（必选）- 要添加的第一个元素 newelement2（可选）- 要添加的第二个元素 newelementX（可选）- 要添加的第X个元素 应用：创建一个数组，并通过添加一个元素来改变其长度 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.push(&quot;James&quot;) + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas 4 George,John,Thomas,James reverse() 描述：用于颠倒数组中元素的顺序（该方法会改变原来的数组，而不会创建新的数组） 应用：创建一个数组，然后颠倒其元素的顺序 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.reverse()) &lt;/script&gt; 输出： George,John,Thomas Thomas,John,George shift() 描述:用于把数组的第一个元素从其中删除，并返回第一个元素的值(如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject) 应用：创建一个数组，并删除数组的第一个元素。请注意，这也将改变数组的长度 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.shift() + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas George John,Thomas slice() 描述：slice() 方法可从已有的数组中返回选定的元素 arrayObject.slice(start,end) start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end: 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 应用：创建一个新数组，然后显示从其中选取的元素 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) //截取数组的2-4位（注意数组下标从0开始） document.write(arr.slice(2,4) + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin Thomas,James George,John,Thomas,James,Adrew,Martin sort() 描述：用于对数组的元素进行排序 arrayObject.sort(sortby) sortby 可选。规定排序顺序。必须是函数。 返回值为对数组的引用。请注意，数组在原数组上进行排序，不生成副本 参数说明：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。若 a 等于 b，则返回 0。若 a 大于 b，则返回一个大于 0 的值。 应用：创建一个数组，并按字母顺序进行排序 exp1： &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.sort()) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin Adrew,George,James,John,Martin,Thomas exp2:实现对多位数的排序（利用排序函数作为参数） &lt;script type=&quot;text/javascript&quot;&gt; function sortNumber(a,b) { return a - b } var arr = new Array(6) arr[0] = &quot;10&quot; arr[1] = &quot;5&quot; arr[2] = &quot;40&quot; arr[3] = &quot;25&quot; arr[4] = &quot;1000&quot; arr[5] = &quot;1&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.sort(sortNumber)) &lt;/script&gt; 如果不写该函数作为参数，只会对多位数的第一位以ASCII码进行排序，无法实现多位数排序 splice() 描述：splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 该方法会改变原始数组 arrayObject.splice(index,howmany,item1,…..,itemX) index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX 可选。向数组添加的新项目。 请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 应用： exp1:创建一个新数组，并向其添加/删除一个元素 &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) //从第二个位置修改，&quot;howmany&quot;参数为0择不删除，第三个参数为要添加的元素 arr.splice(2,0,&quot;William&quot;) document.write(arr + &quot;&lt;br /&gt;&quot;) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin George,John,William,Thomas,James,Adrew,Martin exp2：删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素 var arr = new Array(6) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" arr[3] = \"James\" arr[4] = \"Adrew\" arr[5] = \"Martin\" document.write(arr + \"\") arr.splice(2,1,\"William\") document.write(arr) 输出： George,John,Thomas,James,Adrew,Martin George,John,William,James,Adrew,Martin exp3:删除从 index 2 (“Thomas”) 开始的三个元素，并添加一个新元素 (“William”) 来替代被删除的元素 var arr = new Array(6) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" arr[3] = \"James\" arr[4] = \"Adrew\" arr[5] = \"Martin\" document.write(arr + \"\") arr.splice(2,3,\"William\") document.write(arr) 输出： George,John,Thomas,James,Adrew,Martin George,John,William,Martin unshift 描述：可向数组的开头添加一个或更多元素，并返回新的长度 arrayObject.unshift(newelement1,newelement2,….,newelementX) newelement1 必需。向数组添加的第一个元素。 newelement2 可选。向数组添加的第二个元素。 newelementX 可选。可添加若干个元素。 说明：unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。 请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。 请注意，unshift() 方法无法在 Internet Explorer 中正确地工作！ 应用：创建一个数组，并把一个元素添加到数组的开头，并返回数组的新长度 exp: var arr = new Array() arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" document.write(arr + \"\") document.write(arr.unshift(\"William\") + \"\") document.write(arr) 输出： George,John,Thomas 4 William,George,John,Thomas 一些不常用的方法 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 valueOf() 返回数组对象的原始值 说明以上内容均来自W3Cschool，我是为了加深印象，巩固一下知识点。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JS代码段所放位置的区别","slug":"JS代码段所放位置的区别","date":"2018-10-19T14:27:14.000Z","updated":"2018-10-19T16:44:07.515Z","comments":true,"path":"2018/10/19/JS代码段所放位置的区别/","link":"","permalink":"http://yoursite.com/2018/10/19/JS%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%89%80%E6%94%BE%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"前言在很久之前就遇到了这个问题，由于代码段放的位置不对导致代码段无法生效。所以这次就简单写一下代码段不同位置的区别。 正文","text":"前言在很久之前就遇到了这个问题，由于代码段放的位置不对导致代码段无法生效。所以这次就简单写一下代码段不同位置的区别。 正文 JavaScriptJS是一种解释性脚本（不进行预编译） 高级语言的两种翻译方式： 编译 以基本的C语言为例，大部分语言是直接通过编译器将高级语言编译成为机器可以懂的机器语言（二进制文件 .exe）。但是也有不一样的，比如JAVA这种跨平台语言，它是将高级语言先编译成为JAVA虚拟机能够识别的class文件，在不同的平台上再编译为相应的机器语言，实现跨平台。 解释 解释性脚本脚本不需要编译，在执行时才进行解释。解释性脚本语言有专门的解释器，不过每次执行时都需要编译，所以效率比较低。 JavaScript也有自己的解释器–JavaScript引擎，他是浏览器的一部分。 HTML 语言的执行顺序作为一门解释性脚本语言，它的执行顺序是从前到后顺序执行。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Html页面内容执行顺序&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var userId = $(&apos;#hiddenUserId&apos;).val(); var contextPath = $(&apos;#hiddenContextPath&apos;).val(); var userName = $(&apos;#hiddenUserName&apos;).val(); alert(userName); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 按照顺序执行，先解析该文档为HTML文档，接着解析head部分的script脚本，head部分的style样式，接着渲染body部分，接着解析body中的script脚本。 按照以上顺序，我就可以理解为什么我上一次引用的验证码脚本以及vue框架放在HTML中head部分时，无法生效。原因是在于如果将脚本放在head中，script脚本执行时DOM树还没有被渲染，所以脚本是无法执行对DOM进行修改的。而如果将脚本放在body尾部，执行此脚本时，DOM树已被渲染完毕，所以可执行修改操作。 结论1.head中所放的JavaScript代码段主要功能应该是不会在页面加载时就进行执行的脚本功能，即后续通过其他操作触发的（比如onclik按键触发），这类脚本可以预先解释，在需要时再执行 2.body后面放的脚本应该是页面加载时就要触发的脚本，比如对DOM数内容的初始化（向上面的验证码系统，vue的脚本） 特殊情况以下情况可以改变JS代码的执行顺序 window.onload:等到页面中的所有内容加载完成后才会执行。 $(document).ready():页面中所有的DOM结构绘制完成后就能够执行。 script脚本中，大部分浏览器支持async和defer属性。 async表示的意思是异步加载JavaScript文件，它的下载过程可以在HTML的解析过程中进行，加载完成之后立即执行这个文件的代码，执行文件代码的过程中会阻塞HTML的解析，它不保证文件加载的顺序。 defer表示的意思是在HTML文档解析之后在执行加载完成的JavaScript文件，JavaScript文件的下载过程可以在HTML的解析过程中进行，它是按照script标签的先后顺序来加载文件的。 参考资料： 1.把JavaScript文件放在文档的头部还是尾部 2.CSS、JS 放置位置与前端性能的关系？ 3.HTML页面的加载顺序","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"node-js基本用法解析","slug":"node-js基本用法解析","date":"2018-09-22T07:18:33.000Z","updated":"2018-09-25T13:34:51.186Z","comments":true,"path":"2018/09/22/node-js基本用法解析/","link":"","permalink":"http://yoursite.com/2018/09/22/node-js%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/","excerpt":"前言 为什么会想到搞一下node呢，emmmm，主要是之前想收图片，每个人4张，一共几十个人，如果都通过qq发过来那简直市场噩梦（虽然我最后还是经历了这擦会给你噩梦），所以下定决心要搞一下后端的东西，PHP，ASP学习成本有点高，速成还是有点难，所以我想到了node.js这个神奇的东西，用js的语言来写后端的东西，nice哦。所以就有了这篇文章。","text":"前言 为什么会想到搞一下node呢，emmmm，主要是之前想收图片，每个人4张，一共几十个人，如果都通过qq发过来那简直市场噩梦（虽然我最后还是经历了这擦会给你噩梦），所以下定决心要搞一下后端的东西，PHP，ASP学习成本有点高，速成还是有点难，所以我想到了node.js这个神奇的东西，用js的语言来写后端的东西，nice哦。所以就有了这篇文章。 正文EventEmitter模块这个模块可以说是node中一个核心的模块，包括fs，http，net等模块的事件都是继承自该模块，若不使用继承的方法，其基本用法是： //引入events模块 var eventEmitter = require(&apos;events&apos;); //创建eventEmitter var events = new events.EventEmitter(); event.on(&apos;some_event1&apos;,function(){ console.log(&quot;监听器1执行&quot;); }) event.addListener(&apos;some_event2&apos;,function(){ console.log(&quot;监听器2执行&quot;); }) event.removeListener(&apos;some_event1&apos;,function(){ console.log(&quot;监听器1移除&quot;); }) event.emit(&apos;some_event1&apos;); 这是一些基本的用法，不过这个方法在平时不怎么用，所以了解一下就ok了。 文件系统fs异步与同步由于node是基于JS，所以异步与同步是不可回避的一个问题，在之前的博文中，我们也解析过JS的异步与同步操作，这里不再赘述。而node中文件操作是同时支持异步与同步操作，具体区别这里也不再赘述。 异步与同步代码var fs = require(&apos;fs&apos;); //异步读取 fs.readFile(&apos;input.txt&apos;,function(err,data){ if(err){ return console.error(err); } console.log(&apos;异步读取&apos;+data.toString()); }); //同步读取 var data = fs.readFileSync(&apos;input.txt&apos;); console.log(&quot;同步读取：&quot;+dataString()); console.log(&apos;文件操作完毕&apos;); 注意这里是展示同步与异步的代码区别，一般是在操作代码后加上“Sync”(同步)，但一般我们并不使用这种同步的方法，因为在文件大一点的时候这会严重影响代码执行的效率。 打开文件语法格式 fs.open(path,flag,callback) 参数 path-文件路径 flag-文件打开的模式 callback-回调函数，该函数带有两个参数（err,fd），err-&gt;错误，fd-fileData，文件内容及信息 下面是flag的参数及其说明 获取文件信息语法格式 fs.stat(path,callback) 参数 path-文件路径 call-回调函数 var fs = require(&apos;fs&apos;); fs.stat(&apos;/Users/liuht/code/itbilu/demo/fs.js&apos;, function (err, stats) { console.log(stats.isFile()); //true }) 下面是该类中的方法： 写入文件语法格式 fs.writeFile(file,data[,option],callback) 参数 file-文件名或文件描述 data-要写入的数据，可以是字符串（String）或缓冲变量（Buffer）对象 option-该参数是一个对象，包含{encoding,mode,flag}。默认为{utf8,0666,w} callback-回调函数（仅包含err，在写入失败时返回） var fs = require(&apos;fs&apos;); console.log(&apos;准备写入文件&apos;); fs.writeFile(&apos;input.txt&apos;,&apos;我是通过fs.file写入的内容&apos;,function(err){ return console.log(err); } console.log(&apos;数据写入成功！&apos;); console.log(&apos;读取写入的数据!&apos;); fs.readFile(&apos;input.txt&apos;,function(err,data){ if(err){ return console.log(err);} console.log(&apos;读取文件内容：&apos;+data.toString()); }); }); 这是代码执行效果： $ node file.js 准备写入文件 数据写入成功！ 读取写入的数据！ 异步读取文件数据: 我是通 过fs.writeFile 写入文件的内容 读取文件语法格式 fs.readFile(fd,buffer,offset,length,position,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 buffer - 数据写入的缓冲区。 offset - 缓冲区写入的写入偏移量。 length - 要从文件中读取的字节数。 position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。 callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。 var fs = require(&quot;fs&quot;); var buf = new Buffer.alloc(1024); console.log(&quot;准备打开已存在的文件！&quot;); fs.open(&apos;input.txt&apos;, &apos;r+&apos;, function(err, fd) { if (err) { return console.error(err); } console.log(&quot;文件打开成功！&quot;); console.log(&quot;准备读取文件：&quot;); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){ if (err){ console.log(err); } console.log(bytes + &quot; 字节被读取&quot;); // 仅输出读取的字节 if(bytes &gt; 0){ console.log(buf.slice(0, bytes).toString()); } }); }); 下面是代码执行效果： $ node file.js 准备打开已存在的文件！ 文件打开成功！ 准备读取文件： 25 字节被读取 This is a test inputtxt 关闭文件fs.close(fd,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 callback - 回调函数，没有参数。 fs.close(fd, function(err){ if (err){ console.log(err); } console.log(&quot;文件关闭成功&quot;); 截取文件fs.ftruncate(fd,len,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 len - 文件内容截取的长度。 callback - 回调函数，没有参数（但含有err参数）。 fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){ if (err){ console.log(err); } // 仅输出读取的字节 if(bytes &gt; 0){ console.log(buf.slice(0, bytes).toString()); } 删除文件fs.unlink(path,callback) 参数 path-路径 callback-回调函数，没有参数（但含有err参数） 实例 var fs = require(&apos;fs&apos;); console.log(&apos;开始删除文件！&apos;); fs.unlink(&apos;input.txt&apos;,function(err){ if(err){ return console.log(err); } console.log(&quot;删除成功！&quot;); }) 创建目录fs.mkdir(path,[,mode],callback) 参数 path - 文件路径。 mode - 设置目录权限，默认为 0777。 callback - 回调函数，没有参数。 实例 var fs = require(&apos;fs&apos;); console.log(&apos;创建目录 /tmp/test/&apos;); fs.mkdir(&quot;/tmp/test/&quot;,function(err){ if(err){ return console.log(err); } console.log(&apos;目录创建成功&apos;); }) 这是执行效果 $ node file.js 创建目录 /tmp/test/ 目录创建成功。 ###读取目录###语法 fs.readdir(path,callback) 参数 path - 文件路径。 callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。 实例 var fs = require(&quot;fs&quot;); console.log(&quot;查看 /tmp 目录&quot;); fs.readdir(&quot;/tmp/&quot;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); 执行效果 $ node file.js 查看 /tmp 目录 input.out output.out test test.txt ###删除目录### 语法 fs.rmdir(path,callback) 实例 var fs = require(&quot;fs&quot;); // 执行前创建一个空的 /tmp/test 目录 console.log(&quot;准备删除目录 /tmp/test&quot;); fs.rmdir(&quot;/tmp/test&quot;,function(err){ if (err) { return console.error(err); } console.log(&quot;读取 /tmp 目录&quot;); fs.readdir(&quot;/tmp/&quot;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); }); 执行效果： $ node file.js 准备删除目录 /tmp/test 读取 /tmp 目录 …… 文件模块还有很多方法，具体可以参见node.js官方文档 http模块http模块一般是使用createServer方法来创建服务器，下面是不使用html文件的代码： //获取http方法并定义到变量 var http = require(&apos;http&apos;); http.createServer(function(req,res){ res.writeHead(400,{&apos;Content-Type&apos;:&apos;text/html&apos;}) res.end(&quot;This is a test&quot;); }).listen(3000); console.log(&quot;server running at http://127.0.0.1:3000/&quot;); 这个代码执行后会在网页上显示This is a test 的字样。 下面是使用html文件来作为网页显示： var http = require(&apos;require&apos;); var fs = require(&apos;fs&apos;); var url = require(&apos;&apos;); //创建服务器 http.createServer(function(req,res){ //解析请求，包括文件名 var pathname = url.parse(req.url).pathname; //从文件系统中请求文件内容 console.log(&apos;request for&apos;+pathname+&apos;received&apos;); fs.readFile(pathname.substr(1),function(err,data){ if(err){ console.lor(err); //发送404（未查找到文件）HTTP状态码并规定解析文件为html文件 res.writeHead(404,{&apos;Content-Type&apos;:&apos;text/html&apos;}); }else{ //发送200（正常）HTTP状态码并规定解析文件为html res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;}); //响应文件内容 res.write(data.toString()); }) res.end(); }).listen(3000); console.log(&quot;Server running at http://127.0.0.1:3000/&quot;); index文件： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 执行上面JS代码，并在浏览器中填入：http://127.0.0.1:8080/index.html，就会显示出index.html网页内容。 url及post和get请求url是指请求的地址，其中不仅包含路径，还了可以包含多个参数，如下图，网址‘http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&#39; 以下代码可以从url中获取相关的参数： var http = require(&apos;http&apos;); var url = require(&apos;url&apos;); var util = require(&apos;util&apos;); http.createServer(function(req,res){ res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;;&apos;charset=utf-8&apos;}); res.end(util.inspect(url.parse(req.url,true))); }).listen(3000); 其效果： 其中util模块是一个工具模块，提供了很多功能，其中util.inspect(object[,options]),这里option的选项很多，这里不再展开叙述。其作用是一个将任意对象转换 为字符串的方法,通常用于调试和错误输出。 将url中的属性值提取出来， var http = require(&apos;http&apos;); var url = require(&apos;url&apos;); var util = require(&apos;util&apos;); http.createServer(function(req,res){ res.writeHead(200,{&apos;Conten-Type&apos;:&apos;text/plain&apos;}); var params = url.parse(req.url,true).query; res.write(&quot;网站名：&quot;+params.name); res.write(&quot;\\n&quot;); res.write(&quot;网站URL：&quot;params.url); res.end(); }).listen(3000); 效果： 获取表单数据 var http = require(&apos;http&apos;); var querystring = require(&apos;querystring&apos;); var postHTML = &apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;&apos; + &apos;&lt;body&gt;&apos; + &apos;&lt;form method=&quot;post&quot;&gt;&apos; + &apos;网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;&apos; + &apos;网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;&apos; + &apos;&lt;input type=&quot;submit&quot;&gt;&apos; + &apos;&lt;/form&gt;&apos; + &apos;&lt;/body&gt;&lt;/html&gt;&apos;; http.createServer(function (req, res) { var body = &quot;&quot;; req.on(&apos;data&apos;, function (chunk) { body += chunk; }); req.on(&apos;end&apos;, function () { // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/html; charset=utf8&apos;}); if(body.name &amp;&amp; body.url) { // 输出提交的数据 res.write(&quot;网站名：&quot; + body.name); res.write(&quot;&lt;br&gt;&quot;); res.write(&quot;网站 URL：&quot; + body.url); } else { // 输出表单 res.write(postHTML); } res.end(); }); }).listen(3000); 其效果如图： 将表单提交的数据利用express框架获取表单内容var express = require(&apos;express&apos;); var app = express(); //将文件夹public设为express公开文件夹(express模块已经将fs方法至于其中，因此在设置公开文件夹时不需再引用fs模块)。 app.use(express.static(&apos;public&apos;)); app.get(&apos;/index.html&apos;,function(req,res){ res.sendFile(_dirname+&apos;/&apos;+&apos;index.html&apos;); }) app.get(&apos;/process_get&apos;,function(req,res){ var response = { &quot;first_name&quot;:req.query.first_name, &quot;last_name&quot;:req.query.last_name }; console.log(response); res.end(JSON.stringify(response)); }); var server = app.listen(8081,function(req,res){ var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port); }); html代码： &lt;html&gt; &lt;body&gt; &lt;form action=&quot;http://127.0.0.1:8081/process_get&quot; method=&quot;GET&quot;&gt; First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt; &lt;br&gt; Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 效果如图： express模块是一个web应用框架，他提供了很多强大的功能来更简单的创建web应用。 利用express及multer来实现文件的上传multer模块主要处理表单文件的上传。 var express = require(&apos;express&apos;); var multer = require(&apos;multer&apos;); var app = express(); app.use(express.static(&apos;public&apos;)); // 通过 filename 属性定制 var storage = multer.diskStorage({ destination: function (req, file, cb) { cb(null, &apos;/web开发/测试/upload&apos;); // 保存的路径，备注：需要自己创建 }, filename: function (req, file, cb) { // 将保存文件名设置为 字段名 + 时间戳+后缀，比如 logo-1478521468943 cb(null, file.fieldname + &apos;-&apos; + Date.now()+&apos;.jpg&apos;); } }); // 通过 storage 选项来对 上传行为 进行定制化 var upload = multer({ storage: storage }) //var upload = multer({dest : &apos;upload/&apos; }); //var upload = multer({storage:storage}); app.get(&apos;/index&apos;,function(req,res){ res.send(_dirname+&quot;/&quot;+&quot;index.html&quot;); }) //single中的第二个参数代表可以接受几个文件，2代表可以接受两个文件 app.post(&apos;/upload&apos;,upload.single(&apos;pics，2&apos;),function(req,res){ res.send(&quot;ok&quot;); }) var server=app.listen(3030,function(){ var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) }) 上面这段代码可以实现文件的上传并将其放在规定的文件夹及其规律化的命名： html代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!-- &lt;span&gt;first item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;first_item&quot;&gt;&lt;br/&gt; &lt;span&gt;second item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;second_item&quot;&gt;&lt;br/&gt; --&gt; &lt;span&gt;file&lt;/span&gt;&lt;input type=&quot;file&quot; name=&quot;pics&quot;&gt;&lt;br/&gt; &lt;/be/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 最后终于把这个简单的文章写完了，这只是node的冰山一角，node还有很多模块及其方法，想要精通段时间内几乎是不可能的，后面还是要继续努力xio习啊！ 引用 菜鸟教程 Nodejs进阶：基于express+multer的文件上传","categories":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/categories/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"千万不要躺太久-三和大神的生活","slug":"千万不要躺太久-三和大神的生活","date":"2018-08-30T11:45:44.000Z","updated":"2018-08-31T14:40:51.424Z","comments":true,"path":"2018/08/30/千万不要躺太久-三和大神的生活/","link":"","permalink":"http://yoursite.com/2018/08/30/%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E8%BA%BA%E5%A4%AA%E4%B9%85-%E4%B8%89%E5%92%8C%E5%A4%A7%E7%A5%9E%E7%9A%84%E7%94%9F%E6%B4%BB/","excerpt":"三和大神“三和大神”是一群平凡而又特殊的工人，平凡在于他们也是干活领工资，也在人才市场找工作。特殊在于他们的工作信仰与普通的工人不同，他们的理念是“干一天，玩三天”，只要身上有钱，就不去工作，什么时候口袋空了，什么时候就去工作。","text":"三和大神“三和大神”是一群平凡而又特殊的工人，平凡在于他们也是干活领工资，也在人才市场找工作。特殊在于他们的工作信仰与普通的工人不同，他们的理念是“干一天，玩三天”，只要身上有钱，就不去工作，什么时候口袋空了，什么时候就去工作。 三和大神的贫瘠生活经济的贫瘠“干一天玩三天”，这就是三和大神所信奉的生活状态，那这一天挣多少呢？ –大约86元人民币 接下来的三天就可以过着自由的生活，安逸的躺在十几元的廉价旅馆中，把已经发霉的被子盖在身上，闻着各种习以为常的异味，连着WiFi刷着破损的手机，吃着4元一碗的挂逼面，喝着1元一瓶的挂逼水，或者是在1元一小时的网吧中玩上两天。在身上已经没有钱够吃一碗挂逼面时，又站起来去到“人才市场”干一天。 精神的贫瘠干完这一天又回到那家小旅馆，躺下…… 这样一个又一个的循环，他们生活里毫无波澜，仿佛一滩没有生命的死水，唯一能激起一圈涟漪的应该就是兜里没有钱时，又要去干一天的无奈。他们希望通过网络弥补现实生活的贫瘠，在手机中看着这个明星又出轨了，那个人扶老奶奶又被讹了，他们手指迅速点击着屏幕，批判这个明星的生活作风太差，指责这个社会的黑暗，没有好人了。或者在游戏中虐一下对手，或者嘲讽一下对手，或者夸耀一下自己，将自己想象为游戏角色，以此拾得自己早已丢失在生活中自豪感。 然后又到了工作的那一天，他们将自己的精神冻结起来，以一种自我麻痹的状态完成工作，然后又回到网络上，拾回自己的精神，他们不敢把自己的精神带回到现实生活，因为他们不敢面对那个真实的自己，那个一无所有的自己，那个毫无地位的自己。 感情的贫瘠在“三和大神”的行列中，感情似乎是一件不可望更不可及的东西，没有亲人或者亲人根本不联系，更别提爱情，不想要更不需要，一人吃饱全家喝足的状态，这样毫无牵挂，似乎完全没有必要再在社会中跌跟头了，一直躺在地上就挺舒服。 他们为什么到这一步？每个人自来到这个世界，都不甘于低于别人，那为什么“三和大神”会甘于这样的生活？ 对生活失去希望宋春江，27岁迈入大神的行列，中专学习的服装和电脑，本以为毕业后可以找个好工作，有个温馨的家庭，平静的生活。可学校分配的工作是做流水线工人，早上7点工作到晚上11点甚至更晚。刚毕业那会还觉得有机会，七八年后，他已不再想过日子，这期间他也从流水线工人变成了标准的“三合大神”。过着“干一天玩三天”的生活。是什么让他成为了“三和大神”？—失去生活的希望 流水线的工作，无限制的循环一件事情，似乎完全看不见自己的未来，还是带着每日全身的疲倦，与其如此，不如过着“三和大神”的生活来的实在，累一天“舒服”三天。 误入歧途 东东，22岁，来自农村，因为上班时打瞌睡被老板娘说了几句就辞职来到三和，住进了15元一晚的宾馆。开始“三和大神”的生活。 躺下太久就站不起来了！ 对于“三和大神”，我感到的不是同情，而是可怜，甚至是可笑，所有的一切不过都是自己不想站起来的原因罢了！不过是自己懒惰的借口！我们不得不承认社会的不公，你也许永远无法成为王健林，马云，但你是可以靠自己的努力让你过上普通人的生活。觉得自己的工作没希望就换个有希望的工作，找不到就去学习。这中国这片土地上永远不缺可供学习的地方。唯一缺的是愿意一心一意去学习的人。所谓的“三和大神”不过是那些受不了现实的打击或承受不了现实的打磨，倒在路上的一群人！他们甘愿倒在半路！他们甘愿走在社会的最低层！那么这就是不会被同情的，因为是他们自己选择了自己的道路，不是别人，更不是这个社会！“讨厌长期劳动，喜欢日结”不过是自己不愿努力的掩饰罢了，就如同“讨厌站起来，喜欢躺在在床上”一样可笑。 我们都一样人性相同其实他们与我们有什么不同？哪一个人不希望每天轻轻松松，什么都不干，不去承受，不去负担。这种人性的弱点是始终存在的。即使是再伟大的人，也会有偷懒的想法。古代的皇帝，每天翻阅奏章，管理国家大事，几乎所有的大事都会通过皇帝的脑袋，难道他不想随便完成然后去后宫吃喝玩乐？如今的富商哪一个不是每天满满的日程，用尽心思的去经营自己的生意，难道他们不想停下来休息一下？芸芸众生谁不辛苦？谁生活在温室中？谁不想停下来“躺在地上”？但我们没有那么做，因为“躺下太久，就站不起来了”！ 选择不同但我们的选择不同，我们选择了站起来，继续前进。现实一次又一次的将我们击倒，但仍然有人站起来，继续前进！“三和大神”就是被击倒后站不起来的那一群人。他们倒下后发现原来躺着是这么舒服啊，那就别站起来了，干脆做他一场黄粱大梦，或在梦中，或在网络中。 请不要躺太久！请不要躺太久，以至于忘记如何站立！不管自己的梦想是否遥远，都请一直走下去，因为至少你可以更清晰的看见自己的梦想啊。","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"社会","slug":"社会","permalink":"http://yoursite.com/tags/%E7%A4%BE%E4%BC%9A/"},{"name":"见解","slug":"见解","permalink":"http://yoursite.com/tags/%E8%A7%81%E8%A7%A3/"}]},{"title":"开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）","slug":"开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）","date":"2018-08-25T01:01:03.000Z","updated":"2018-08-25T11:50:13.614Z","comments":true,"path":"2018/08/25/开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）/","link":"","permalink":"http://yoursite.com/2018/08/25/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%89%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%EF%BC%88%E5%88%A9%E7%94%A8localStorage%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%EF%BC%89/","excerpt":"前言这个小项目花了我大概10天的时间（每天5h左右），可以说是很慢了，主要是JS的很多知识点不熟悉，边研究边开发。而且数据库部分仍然时使用本地存储，也就是说这个案例是无法投入到实际使用中，但后面我会去研究一下mysql，在服务器端部署一个小型的数据库，估计不会花太长时间，另外觉得node.js挺有意思，hexo就是基于node.js，将JS用于与计算机系统的直接沟通，That`s cool，本来我的原计划是将博客信息存储在本地文件中，比如直接在本地存储一个JSON文件用来存储一篇博客，后来发现这个是实现不了的，因为浏览器内核无法与系统直接沟通，内核是在浏览器提供的一个BOX中运行，无法直接操作系统文件，emmmm，可能这也是为系统安全把，不然随便一个恶意网页就可以操作你的文件，This is unimaginative。也是因为这个所以才有了node.js的诞生的吧！","text":"前言这个小项目花了我大概10天的时间（每天5h左右），可以说是很慢了，主要是JS的很多知识点不熟悉，边研究边开发。而且数据库部分仍然时使用本地存储，也就是说这个案例是无法投入到实际使用中，但后面我会去研究一下mysql，在服务器端部署一个小型的数据库，估计不会花太长时间，另外觉得node.js挺有意思，hexo就是基于node.js，将JS用于与计算机系统的直接沟通，That`s cool，本来我的原计划是将博客信息存储在本地文件中，比如直接在本地存储一个JSON文件用来存储一篇博客，后来发现这个是实现不了的，因为浏览器内核无法与系统直接沟通，内核是在浏览器提供的一个BOX中运行，无法直接操作系统文件，emmmm，可能这也是为系统安全把，不然随便一个恶意网页就可以操作你的文件，This is unimaginative。也是因为这个所以才有了node.js的诞生的吧！ 正文BB了那么久，咳咳，进入正题。 首页 布局过后首页上半部分是这样，和当初的设计差不多。整个上半部分是一个轮播图。 var i=0; setInterval(function(){ if(i&lt;4) { i++; $(document).ready(function(){ $(&quot;.item&quot;).eq(i).fadeIn(2000).siblings().fadeOut(2000); }); } else { $(document).ready(function(){ $(&quot;.item&quot;).eq(3).fadeIn(2000).siblings().fadeOut(2000); }); i=-1; } //console.log(i); }, 4000); 用了jquery的fadeIn,fadeOut方法，由于没有按钮使代码很简单，只用了十多行代码。唯一有问题的最后一张图片与第一张总是相差设定时间的2倍，想了许多办法没有解决，我就直接班另一张图片插入到最后一张与第一张的间隔之间，这样就实现图片的播放速度是均匀的，但问题是不循环播放的，有一张图片要多出现一次。 顶部分别是home，catalogue，和login的链接，左半部分有博主本人的logo。 点击logo可以将其大部分隐藏到屏幕外侧，like this， 再次点击边缘部分，可再次点击召唤出logo &lt;- &lt;-其原理也很简单，只是利用了jquery的动画方法， animate（） 布局方面整个上半部分设计简单，只用了原生的CSS与html完成。 下半部分是文章展示部分，我是在首页设置了几篇置顶文章，具体方法是直接在在html文档中写入写入这一部分代码，不是JS后期插入到文档中，然后下面是使用JS写入的文章部分，这些文章都是存储在数据库中的部分，并且可以在article页面查看。具体实现方式是在写入博客时将博客的title，date，tags，article写入到一个对象中，再JSON化写入本地（这里JSON化的原因在上期关于localStorage的介绍中已经写到，主要原因是localStorage只能存储string要想保留格式，JSON化是一种比较好的办法）。然后在首页读取数据再JSON.parse，在格式插入到文档中。 另外在首页还需要解决问题就是将文章序号传输到文章展示页面，因为当点击文章标题或more时，需要跳转至文章展示页面，展示该文章。我所想到的解决办法是在添加文章到首页文档流中时就把序号写入放置该文章的div的id的尾部，传输到展示页面时再通过this关键字读取id关键字（在测试中我也发现this无法获取class属性的值，原因我正在探索中，后面会出一起专门关于this的文章），并通过charAt()获取该序号，然后通过URL传值的方法将其传递到展示页面。 展示页面 文章展示页面提供问文章的全面展示，并且提供评论功能。（本来是打算在首页也只展示文章的部分，后来感觉有点麻烦，看后面有时间了再实现）。 接上面首页传输文章序号到展示页面，展示页面通过函数解析序号，这个函数我实用的网上的一个模板，代码如下。 UrlParm = function() { // url参数 var data, index; (function init() { data = []; index = {}; var u = window.location.search.substr(1); if (u != &apos;&apos;) { var parms = decodeURIComponent(u).split(&apos;&amp;&apos;); for (var i = 0, len = parms.length; i &lt; len; i++) { if (parms[i] != &apos;&apos;) { var p = parms[i].split(&quot;=&quot;); if (p.length == 1 || (p.length == 2 &amp;&amp; p[1] == &apos;&apos;)) {// p | p= data.push([&apos;&apos;]); index[p[0]] = data.length - 1; } else if (typeof(p[0]) == &apos;undefined&apos; || p[0] == &apos;&apos;) { // =c | = data[0] = [p[1]]; } else if (typeof(index[p[0]]) == &apos;undefined&apos;) { // c=aaa data.push([p[1]]); index[p[0]] = data.length - 1; } else {// c=aaa data[index[p[0]]].push(p[1]); } } } } })(); return { // 获得参数,类似request.getParameter() parm : function(o) { // o: 参数名或者参数次序 try { return (typeof(o) == &apos;number&apos; ? data[o][0] : data[index[o]][0]); } catch (e) { } }, //获得参数组, 类似request.getParameterValues() parmValues : function(o) { // o: 参数名或者参数次序 try { return (typeof(o) == &apos;number&apos; ? data[o] : data[index[o]]); } catch (e) {} }, //是否含有parmName参数 hasParm : function(parmName) { return typeof(parmName) == &apos;string&apos; ? typeof(index[parmName]) != &apos;undefined&apos; : false; }, // 获得参数Map ,类似request.getParameterMap() parmMap : function() { var map = {}; try { for (var p in index) { map[p] = data[index[p]]; } } catch (e) {} return map; } } }(); 有点长，权当备份一下，后面在分析这个函数。 展示页面解析到文章序号后，展示函数直接通过读取数据库读取到数据添加到文档流中。 评论部分的实现也比较简单，通过读取文档中用户输入的信息并将其重新写入该文章数据库中的JSON中，展示时自动展示出来。 目录页面 目录页面展示了所有通过JS放入数据库的文章（不包括首页置顶文章）。 这里的实现就是直接遍历数据库中的博客文章信息，因为当时存储时是格式命名的，所以遍历很简单，再把title循环添加到文档流中就ok了。 登录及后台管理页面 登录页面使用MD5加密方式，与本地存储的密匙（未来的密匙存储在服务器端）进行对比。 这里是在登录过后显示页面，首先这里布局还是用了frame框架，我暂时还没想到更好的替代办法，虽然frame在H5已被抛弃。 在写博客页面，用户将自己的文章内容输入，然后提交，文章内容会被JSON化后被保存到数据库，下次进入首页时就会直接被展示出来。 删改页面也是遍历数据库，直接修改数据库内容就好了，还是比较简单了，具体过程就不再赘述。 最后的工具页面是我想没事可以自己开发一些简单的工具，比如什么颜色拾取等等，这也是后话。 最后其实这个小项目还是比较简单，代码量也不是很大，主要是练一下手，熟悉以一下前端的一些知识，当然这个小项目还有很多不足需要满足，包括在代码规范等等,方便后面的深入学习。当然后面在学习玩数据库后会把本地数据库改为服务器端的数据库，使之可以实际运行。","categories":[{"name":"博客开发系列","slug":"博客开发系列","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"博客开发","slug":"博客开发","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}]},{"title":"关于JS单线程，异步执行的理解","slug":"关于JS单线程，异步执行的理解","date":"2018-08-22T02:13:24.000Z","updated":"2018-08-22T04:20:53.093Z","comments":true,"path":"2018/08/22/关于JS单线程，异步执行的理解/","link":"","permalink":"http://yoursite.com/2018/08/22/%E5%85%B3%E4%BA%8EJS%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"前言在这几天的开发过程中，遇到了不少问题，阻塞最久的应该就是一段JS代码没有按照我以为的执行顺序去执行，想想好像也没有具体的了解JS的执行过程，所以花了一整天的时间来了解了一下JS的执行机制。","text":"前言在这几天的开发过程中，遇到了不少问题，阻塞最久的应该就是一段JS代码没有按照我以为的执行顺序去执行，想想好像也没有具体的了解JS的执行过程，所以花了一整天的时间来了解了一下JS的执行机制。 问题代码for(var i=0;i&lt;=3;i++){ $(document).ready(function){ console.log(i); }); 出现问题的代码简化过后大概是这个样式，我的预期是输出1，2，3，但输出的结果却为3,3,3，我开始以为是JS单线程执行的缘故，所以Jquery代码被放在了callback queue（任务队列）的最后执行，但我查询资料后发现仅发现浏览器会为定时器，ajax等多开线程，jquery应该不算，正在我疑惑之时，我打开了Jquery的官方文档，看到了 $(document).ready(function(){});的定义：文档准备完成后，内部的匿名函数作为document(ready)的回调函数进行执行，而此时for早已进行玩了。这就解释了为什么都是3,3,3。 正文从浏览器谈起浏览器的进程与线程浏览器是多进程的 Browser进程：负责浏览器的主进程（协调，主控）。 第三方插件进程：每一个插件对应一个进程。 GPU进程：用于绘制3D图形等。 浏览器渲染进程 （render进程，浏览器内核）：每一个Tab页面一个进程，这个进程渲染我们所看到的每个页面。 浏览器渲染进程是多线程的前面我们说到我们所看到的页面都是有渲染进程进行渲染的，而他又是多线程的： GUI渲染线程（浏览器内核） 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发进程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 进入正题，JS的执行过程js的同步任务和异步任务 所有同步任务（能够立即被执行，不消耗时间的任务，如变量核函数的初始化，时间的绑定等等不需要回调函数的任务）都在主线程中执行，形成执行栈（stack），heap（堆）用来存储变量，对象等。 所有异步任务（一半会有操作，如点击事件，定时事件，具有回调函数的事件）运行在事件触发线程中，当异步任务有结果是，其回调函数（Callback Function）就会被放到任务队列中，等待执行。 当执行栈中同步任务执行完毕后， JS引擎就会从任务队列中（callback queue）中查找任务放入执行栈中，这个过程就被称之为事件循环event loop。 从上面的解释中可以看到JS引擎始终是在执行栈中单线程执行任务，当执行栈空时，接下来的任务才回从任务队列中读取下一任务。 何为异步 所谓的异步，就是在其他线程（事件触发线程，异步http请求线程等）的辅助下，JS线程实现异步处理任务。举个栗子： consloe.log(&quot;a&quot;) setTimeout(function() { console.log(&quot;b&quot;) }, 0) console.log(&quot;c&quot;) 模拟其运行过程： 1.consloe.log(&quot;a&quot;)// JS引擎发现这是一个同步任务，立即执行打印出a; 2.setTimeout(function() { console.log(&quot;b&quot;) }, 0)//JS引擎只想此处时发现这是一个异步任务，所以直接交由定时触发线程。 JS引擎继续向下执行，与此同时，定时触发线程接收到该事件，解析代码过后， 将在0毫秒实际是4毫秒，因为在上面我们讲到，W3C规定定时引擎的最低时间为4毫秒）后向JS引擎发送 回调函数，并将其推到任务队列中等待执行。 3.console.log(&quot;c&quot;)//再向定时引擎发送定时事件后立即执行该代码。打印出c。 4.定时引擎将console.log(&quot;b&quot;)推入任务队 列，在console.log（&quot;c&quot;）运行完成后，执行栈空，再将其推入执行栈，然后执console.log(&quot;c&quot;)， 打印出c,因此这段代码输出的结果为a,c,b,而不是a,b,c. 注意，即使setTimeout不是4毫秒后，而是0毫秒后返回回调函数，执行结果任然是a,c,b。因为这是一个排队的过程，console.log(“b”)任是排在console.log(“c”)之后的。 由此，一个异步任务就在JS引擎与其他线程的共同作用下完成了。 参考资料从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 js的单线程和异步 JavaScript单线程和异步机制 最后这只是一个简单的理解，其中还有许多部分可能没有完善，等以后有更深的理解时再来完善吧。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"利用SS（Shadowsocks）快速搭建一个vpn","slug":"利用SS（Shadowsocks）快速搭建一个vpn","date":"2018-08-20T10:43:57.000Z","updated":"2018-08-20T12:06:34.774Z","comments":true,"path":"2018/08/20/利用SS（Shadowsocks）快速搭建一个vpn/","link":"","permalink":"http://yoursite.com/2018/08/20/%E5%88%A9%E7%94%A8SS%EF%BC%88Shadowsocks%EF%BC%89%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAvpn/","excerpt":"前言前几天玩kali时发现需要下一个插件，但是需要科学上网，无奈打开之前的vpn软件，发现几乎都关闭了服务，于是我就诞生了自己搭建一个vpn的想法，于是在参考了网上的教程后，折腾了一上午终于成功了。 正文一，购买服务器（vps）国外的服务器提供商比较多，比如DigtaOcean，Vultr，Amazon等等，我选择了Vultr，因为它提供的vps价格最低的一款仅2.5$/月（后来才发现是个坑，后人谨记），其实DigtaOcean也还不错，绑定信用卡就送10刀，而他价格最低的一款vps价格为5刀，相当于是说送你两个月的体验时间，Amazon好像开可以免费体验一年，所以选择服务器时要多方考虑一下，","text":"前言前几天玩kali时发现需要下一个插件，但是需要科学上网，无奈打开之前的vpn软件，发现几乎都关闭了服务，于是我就诞生了自己搭建一个vpn的想法，于是在参考了网上的教程后，折腾了一上午终于成功了。 正文一，购买服务器（vps）国外的服务器提供商比较多，比如DigtaOcean，Vultr，Amazon等等，我选择了Vultr，因为它提供的vps价格最低的一款仅2.5$/月（后来才发现是个坑，后人谨记），其实DigtaOcean也还不错，绑定信用卡就送10刀，而他价格最低的一款vps价格为5刀，相当于是说送你两个月的体验时间，Amazon好像开可以免费体验一年，所以选择服务器时要多方考虑一下，地点我们尽量选在米国，具体速度我没有测试过。注意：千万不要选择2.5刀那款服务器，因为它只有一个ipv6的地址，是无法用来搭建的（具体原因我没有深入探索，但估计也是，不是所有的服务都兼容ipv6，购买这款服务器时官方也会有提示），所以我们选择5刀的那款，系统选择Ubuntu，当然其他的也是可以的。但我们在后面还是把enable ipv6勾上，为我们分配一个ipv6的地址。label和hostname是你自己的信息。至此，服务器的购买就完成了，等待服务器初始化和开机。 二，连接服务器此时，我们可以在你的控制面板里看到你服务器端的ip地址以及用户名和密码。然后我们需要远程连接到你的服务器，这里我们选择Xshell这款软件。点击文件，新建。在主机输入我们在控制面板中看到的IPV4的地址，之后会提示我们输入用户名及密码，这些信息也都在控制面板中，我就不再截图。 之后我们就会连接上我们的服务器。 然后就输几行代码就ok了。 apt-get install python-pip pip install shadowsocks 两行代码就安装好了ShadowSocks,下面就是配置SS文件 nano /etc/shadowsocks.json nano相比于vim更对Linux新手友好。之后将下面这段代码改为你的账户后粘贴进去。 { “server”:”0.0.0.0”, “server_port”:8388, “local_address”: “127.0.0.1”, “local_port”:1080, “password”:”mypassword”, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”: false } 多账户： { “server”:”0.0.0.0”, “port_password”:{ “8381”:”xxxxxxx”, “8382”:”xxxxxxx”, “8383”:”xxxxxxx”, “8384”:”xxxxxxx” }, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”: false } | 字段 | 说明 || server | ss服务监听地址，0.0.0.0允许所有人访问，如果只是自己用，可以改成自己使用端的ip || server_port | ss服务监听端口 || local_address | 本地的监听地址 || local_port | 本地的监听端口 || password | 密码 || timeout | 超时时间，单位秒 || method | 加密方法，默认是aes-256-cfb || fast_open | 使用TCP_FASTOPEN, true / false || workers | workers数，只支持Unix/Linux系统 | 然后启动服务 ssserver -c /etc/shadowsocks.json -d start 如果需要关闭服务 ssserver -c /etc/shadowsocks.json -d stop 至此，我们服务器端就配置好了，现在就是需要下载shadowsocks连接就ok了。 客户端的使用由于SS在天朝已经GG了，官网已经打不开了，只在github中更新，所以，在这里下载以及查看官方文档。！client 下载完客户端后，输入我们的服务器IP，刚刚在SS中设置端口及密码，点击确定就可以连接到我们的vpn了。 然后就查找学习资料吧~","categories":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://yoursite.com/categories/Shadowsocks/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://yoursite.com/tags/Shadowsocks/"},{"name":"vpn","slug":"vpn","permalink":"http://yoursite.com/tags/vpn/"}]},{"title":"对于JS中localStorage的理解","slug":"对于JS中localStorage的理解","date":"2018-08-20T07:13:20.000Z","updated":"2018-08-20T08:36:46.437Z","comments":true,"path":"2018/08/20/对于JS中localStorage的理解/","link":"","permalink":"http://yoursite.com/2018/08/20/%E5%AF%B9%E4%BA%8EJS%E4%B8%ADlocalStorage%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"前言最近在开发博客的过程中，遇到了数据储存的问题，由于我服务器中还未安装sql，加上我对数据库的操作还不是很熟悉，所以先把数据放入了localStorage中，所以我就具体了解了一下这个本地数据库。 正文前端的存储数据的三种方式前端一般数据存储的方式有三种： cookies sessionStorage localStorage","text":"前言最近在开发博客的过程中，遇到了数据储存的问题，由于我服务器中还未安装sql，加上我对数据库的操作还不是很熟悉，所以先把数据放入了localStorage中，所以我就具体了解了一下这个本地数据库。 正文前端的存储数据的三种方式前端一般数据存储的方式有三种： cookies sessionStorage localStorage 简单介绍一下这三种方式的异同： cookies与localStorage可以是永久存储（cookies可设置失效时间；用户不主动清除） sessionStorage与localStorage属于H5引入的新标签，在IE8，Chrome4.0等以上才能执行；并且存储空间更大（5MB/站点）相对于cookies（4KB/站点）。具体localStorage的解析 localStorage的优势与局限优势 相对于cookies拓展了空间大小。 相对于sessionStorage，可永久存储信息。 局限 由于是H5引入的属性，可能一些老版的浏览器不支持该属性。 localStorage所存储的信息被限定被string类型，但由于有JSON等对象转换算法，所以也无所谓了。 另外我在网上了解到，localStorage无法被爬虫抓取到，这一点我目前没有深入探究。 localStorage的使用判断浏览器是否支持 localStorage属性if(！window.localStorage){ alert(&quot;您的浏览器不支持localStorage&quot;) return false} else{ //执行代码 } localStorage的写入三种方法： var data=window.localStorage; data[&quot;name&quot;] = MJ;//关键字name写入 data.age = 20;//关键字age的写入 data.setItem = [&quot;shcool&quot;,清华大学];//关键字school写入 注意：前面是将localStorage属性放入了data变量，同样可以不放入变量，直接调用，所以前面的代码等同于: localStorage[&quot;name&quot;]=MJ; localStorage.age=20; localStorage.setItem(&quot;school&quot;,清华大学); localStorage的读取三种方法： var name = localStorage[&quot;name&quot;]; var age = localStorage.age; var school = localStorage.getItem(&quot;school&quot;); 同样想写入方法一样，也可以将localStorage放入变量中在调用。 值得注意的是，官方更推荐使用，setItem与getItem语法，其原因未具体说明，我猜测可能是为了与JS中的对象区分开，更加语言话，不产生混淆 localStorage的删改localStorage改关键字的值其实就是重新为其赋值，即： localStorage.setItem(&quot;name&quot;,MW); var nameAfter=localStorage.getItem(&quot;name&quot;); //nameAfter===MW-&gt;true localStorage的删除： localStorage.clear();//删除改站点的所有localStorage数据 localStorage.removeItem(&quot;name&quot;); //此时localStorage.name-&gt;nudifined 关于存储的数据仅为string的解决办法（JSON数据类型转换）一，写入时转换为JSON格式输入 var person={ name = &quot;MJ&quot;, age = 20, maritalStatus = true } localStorage.setItem(&quot;person&quot;,JSON.string(person)); 二，读取时转换为JS变量 var person =JSON.parse(localStorage.getItem(&quot;person&quot;)); typof(person.age) //typeof检查变量类型为number typeof(person.maritalStstus)//boolean 最后本来写之前感觉有很多注意要写，但写起来感觉哪些之前感觉是注意点的地方其实只是一个普通的点，所以感觉写起来感觉没有太重要的点，但需要注意的点还是有滴，比如三种存储的异同，localStorage存储的数据仅为string等等。ok，就这样把！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"localStorage","slug":"localStorage","permalink":"http://yoursite.com/tags/localStorage/"}]},{"title":"Apicloud不同页面传值","slug":"Apicloud不同页面传值","date":"2018-08-13T11:00:52.000Z","updated":"2018-08-13T13:26:24.749Z","comments":true,"path":"2018/08/13/Apicloud不同页面传值/","link":"","permalink":"http://yoursite.com/2018/08/13/Apicloud%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC/","excerpt":"前言 标准开头，前一段时间因为需要开发一个简单的app,所以接触了一下Apicloud,因为没有native应用的开发知识，所以采用了Apicloud的web应用开发。其中不同页面的传值问题我具体研究一段时间，因为之前一直传值不成功。 正文方法一：api.execScript","text":"前言 标准开头，前一段时间因为需要开发一个简单的app,所以接触了一下Apicloud,因为没有native应用的开发知识，所以采用了Apicloud的web应用开发。其中不同页面的传值问题我具体研究一段时间，因为之前一直传值不成功。 正文方法一：api.execScript 这个方法本来的功能是用来不同页面的函数的传递，当然，也可以用来传递值，将这个值作为函数的参数就可以传递到其他页面。具体： index1： //name是该页面函数的参数，作为参数传递到另一个页面 var str=&quot;test(&quot;+name+&quot;)&quot;; api.exeScript({ name:&quot;index2&quot;, script:str}); index2: //index2页面代码 function test(name){ alert(name); } 方法：api.addEventListener&amp;&amp;api.sendEvent这个是利用广播事件传递参数。 index1:发送广播 api.sendEvent({ name:&apos;myEvent&apos;, extra:{key1:&apos;value&apos;,key2:&apos;key2&apos;} }); index2:接受广播 api.addEventListener({ name:&apos;myEvent&apos;}, function(ret){ if(ret&amp;&amp;ret.value){ var value = ret.value; alert(value.key1+&apos;,&apos;+value.key2); } }); 方法三 :api.LocalStorage这个方法很简单，采用了本地数据存储的方法来交换数据。 index1: $api.setStorage(&apos;name&apos;,&apos;value&apos;);//数据存储 index2: $api.getStorage(&apos;name&apos;);//取出name值 另外： $api.rnStorage(&apos;name&apos;);//清除name值 $api.clearStorage(&apos;name&apos;);//清除所有本地数据 方法四 ：api.openWin&amp;api.openFrame&amp;api.openFrameGroup最后最简单的是采用打开窗口时可以顺带传值。 index1: //打开新窗口 api.openWin({ name:index2, url:index2.html, pageParam: { key : value, } }); //打开frame组 api.openFrameGroup({ name: &apos;group1&apos;, rect: { //frame的位置 x: 0, y: 0, w: &apos;auto&apos;, h: &apos;auto&apos; }, frames: [{ //frame组 name: &apos;frame1&apos;, url: &apos;frame1.html&apos;, bgColor: &apos;#fff&apos; }, { name: &apos;frame2&apos;, url: &apos;frame2.html&apos;, bgColor: &apos;#fff&apos; }] }, function(ret, err) { //回调函数 var index = ret.index; }); index2: apiready=function(){ var test=api.pageParam.key; alert(test); }","categories":[{"name":"Apicloud","slug":"Apicloud","permalink":"http://yoursite.com/categories/Apicloud/"}],"tags":[{"name":"Apicloud","slug":"Apicloud","permalink":"http://yoursite.com/tags/Apicloud/"}]},{"title":"开发一个简单的个人博客（1）UI设计","slug":"代码开发一个简单的个人博客（1）UI设计","date":"2018-08-13T08:55:46.000Z","updated":"2018-08-25T00:51:43.963Z","comments":true,"path":"2018/08/13/代码开发一个简单的个人博客（1）UI设计/","link":"","permalink":"http://yoursite.com/2018/08/13/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%881%EF%BC%89UI%E8%AE%BE%E8%AE%A1/","excerpt":"前言本来早该写这个博客，因为前一段时间一直在学习各种框架，为这个开发做准备。所以一直拖到现在才开始这个系列的文章，估计这个系列文章会持续4-5期，来写下我开发这个网站的全过程。我会尽力开发到理想状态，具体效果在月底估计会出来。","text":"前言本来早该写这个博客，因为前一段时间一直在学习各种框架，为这个开发做准备。所以一直拖到现在才开始这个系列的文章，估计这个系列文章会持续4-5期，来写下我开发这个网站的全过程。我会尽力开发到理想状态，具体效果在月底估计会出来。 正文UI设计 在具体开发开发之前，我先概括的设计出来一个几个用户界面，包括主页，文章界面，后台用户界面。具体设计软件时使用Axure。 主页界面 主页是采用了比较简洁通用的设计样式，顶部是采用了稍隐藏式的顶部栏样式，顶部栏左侧是Tags,Home链接；左侧是后台界面的登录按钮。其次整个上部是一个轮播图，右侧是一个作者介绍，包括简书，github等的链接，头像，头像左侧准备设计一个按钮，点击时头像隐藏到右侧。 在底部没有采用过多的装饰，作者权限以及在有条件下可以开发一个浏览人数（图片上未展示）。文章界面文章界面上部是没有做改动，与主页界面一样，唯一不同的是轮播图改为静态图片展示，为了更好的阅读体验。其次在界面左侧引用了百度的分享控件，用来分享。在底部，我准备自己开发一个简单的评论系统，并不打算采用第三方评论系统。方案在后面写出。 后台界面 最后的后台用户界面，具体选项目前只准备了写博客与删除博客，以及使用工具的选项。具体美化可以在后期自我发挥~","categories":[{"name":"博客开发系列","slug":"博客开发系列","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"博客开发","slug":"博客开发","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}]},{"title":"《亮剑》精神-军人的尊严","slug":"《亮剑》精神","date":"2018-07-25T11:12:33.000Z","updated":"2018-08-31T14:40:25.887Z","comments":true,"path":"2018/07/25/《亮剑》精神/","link":"","permalink":"http://yoursite.com/2018/07/25/%E3%80%8A%E4%BA%AE%E5%89%91%E3%80%8B%E7%B2%BE%E7%A5%9E/","excerpt":"近来3天读完了《亮剑》一书。说来奇怪，平时读书无不是强忍困意的煎熬，唯独这本书，里面的情节，人物，仿佛有莫大的吸引力。把我带入那个战火纷飞的年代……","text":"近来3天读完了《亮剑》一书。说来奇怪，平时读书无不是强忍困意的煎熬，唯独这本书，里面的情节，人物，仿佛有莫大的吸引力。把我带入那个战火纷飞的年代……我对李云龙的理解，仅限于电视剧中的那个形象，鲁莽，草率，但却勇敢，敢作敢当，思维已与常人。甚至当我刚读到原著时，我也这么认为，因为电视剧几乎是忠于原文，没有做改动，确是都梁笔下的那个李云龙。 但也是当我读到后来我才发现，电视剧未免有些片面，只塑造了一个能征善战的李云龙，这恐怕不是都梁的本意，也是由于敏感原因，导演无法将都梁笔下的那个李云龙活生生塑造出来。不过在我看来，李云龙这个人物的关键就在于后面的部分，前面的部分塑造了他的英勇，而后面李云龙的改变与他的坚持正是这个人物的灵魂所在。他在成长，却也有他坚持的信条！ 当他岳父谈及党内出现错误之时，他严厉的表示反对，因为他认为他跟及的共产党是不可能犯错误的，错在岳父根深蒂固的资产阶级思想。甚至在他的岳父岳母被拉到农村进行改造之时他仍认为这是他们的错误所对应的惩罚。 他信念的动摇是在赵刚死之后，作为搭档十几年的老战友，他相信赵刚是不会犯这种错误的，但他还是不明白到底是谁的错，他要去打死害死赵刚的人，被田雨制止，从这里他开始了他的思考，到底是谁的错误，使这些原本无罪的人受到非人的待遇。 当时他已是一军之长，管理着一个军的庞大队伍，而这一个军队却被两派所谓的左系革命派骑在头上，当其中一派要求得到他的支持时，他装病躲进来医院，以此来避开，而新来的副军长马天生确实一个极其“聪明”之人，他在李云龙“养病”之时，选着了其中一方支持，而另一方却得到省军区的支持。两派系随之进入了军事级别的斗争，若不是书中描述，我怎么也不会想到两个工人组成的团体可以在一座城市中兵戎相见，动辄就是大炮相见，甚至想要夺取军库，拿取大型榴弹炮，而这种榴弹炮的攻击半径几乎是半个城市。 李云龙不敢抵抗，因为一旦抵抗，毫无疑问，下场和赵刚没有区别。李云龙是个聪明人，他一忍再忍，企图想到一个两全其美的办法，但还没等到他想出来，他的一个师部就被革命派占领，军事机密，武器全落入他人之手，他明白只意味着什么，一旦不加以制止，整个城市都将毁于一旦。 李云龙还是那个李云龙，他亮剑了。就如同他在平安城下的那句“开炮！”。他开始下达了命令。这命令也代表这李云龙的灭亡，一颗流星的陨落，一个时代的结束。 最终，李云龙在他家里的阁楼上用那把楚云飞送他的勃朗宁手枪结束了自己的一生。 赵刚在临终的信中写着死亡也是一种反抗，他是对自己信条的坚持，所不同的是，李云龙坚持的是他的军人尊严！宁死不屈的精神！ 原文中对李云龙自杀前用了大量的文笔，无非是为了诠释，李云龙一生戎马，可倾尽一生，也无法想出，到底是谁的错，毛主席不会错，共产党不会错，那可能就是他李云龙的错误吧。","categories":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"感情","slug":"感情","permalink":"http://yoursite.com/tags/%E6%84%9F%E6%83%85/"}]},{"title":"在ESC服务器上搭建静态网站","slug":"ecsAndWebsite","date":"2018-07-22T14:14:41.000Z","updated":"2018-07-25T14:12:41.473Z","comments":true,"path":"2018/07/22/ecsAndWebsite/","link":"","permalink":"http://yoursite.com/2018/07/22/ecsAndWebsite/","excerpt":"开始前面在连接上服务器后，紧接着我想测试一下服务器的网站搭建，下面就把简单的教程贴出来。 1.首先要要在服务器管理页面对服务器进行配置（我最开始就是忘了配置服务器的端口，结果怎么都不对!!!）由于我们HTTP的对应端口是80，所以我们在安全组规则中添加对80端口的开放。","text":"开始前面在连接上服务器后，紧接着我想测试一下服务器的网站搭建，下面就把简单的教程贴出来。 1.首先要要在服务器管理页面对服务器进行配置（我最开始就是忘了配置服务器的端口，结果怎么都不对!!!）由于我们HTTP的对应端口是80，所以我们在安全组规则中添加对80端口的开放。 添加好之后: 2.我的windows服务器中是没有自带IIS的，所以先从IIS的安装开始，点击左下角的服务器管理图标进入服务器管理页面。 3.在服务器管理中点击角色并点击右面的添加角色。 4.进入添加角色向导。 5.钩选Web服务器(IIS),点击安装。 6.点击安装后会弹出是否添加，点击“添加必需的功能”。 7.然后会弹出角色服务，由于我们搭建的静态网页，所以勾选常见的HTTTP功能，如果需要构建动态网站，可够相爱U呢引用程序开发下的相应功能。 8.然后等待角色安装完成。 9.然后就可以输入服务器的公网IP查看是否成功安装IIS服务。看到上面这张图就代表安装成功了。 10.添加应用池。 11.添加站点，注意，IP地址要选择全部未分配 *12.最后是默认文档的修改，服务器中默认的主页是default.htm,你可以把它改成你的主页名。 13.在浏览器输入你的ip地址。查看你的网页。 结尾至此，一个静态网站就搭建好了。其中容易发生错误的点主要有： 安全规则没有配置或者没有配置正确。 创建新站点的IP地址要选择全部未分配。 借鉴资料： 部分图片取自csdn博主bestself_iot的文章IIS 静态页面网站搭建","categories":[{"name":"website","slug":"website","permalink":"http://yoursite.com/categories/website/"}],"tags":[{"name":"esc","slug":"esc","permalink":"http://yoursite.com/tags/esc/"},{"name":"website","slug":"website","permalink":"http://yoursite.com/tags/website/"}]},{"title":"xhellAnEcsd","slug":"xhellandcsd","date":"2018-07-22T03:51:30.000Z","updated":"2018-07-25T14:14:05.082Z","comments":true,"path":"2018/07/22/xhellandcsd/","link":"","permalink":"http://yoursite.com/2018/07/22/xhellandcsd/","excerpt":"关于ecs服务器的连接问题最近看阿里云有一个学生优惠，就申请了一个优惠的ecs服务器，一个月9.9,2G内存，40G云盘，血赚不亏。","text":"关于ecs服务器的连接问题最近看阿里云有一个学生优惠，就申请了一个优惠的ecs服务器，一个月9.9,2G内存，40G云盘，血赚不亏。然后我就开始配置服务器，发现这个廉价的服务器是没办法更换操作系统的，自带的是一个Windows Server 2008 32位。然后我就开始准备连接服务器。阿里云自带有连接服务，但每天都要登陆网页会很麻烦。 然后我就下载了xshell，但一直连接不上，查看服务器端口配置，发现ssh端口22是打开的。后来我在网上查了很多资料，发现还是连接不上。最后我才意识到可能是操作系统的问题。果然我查询了sxhell支持的操作系统。得到如下结果： xshell等软件仅支持Linux，UNIX，centos等。 对于windows系统，需要用RDCMan或者windows自带的远程桌面连接。","categories":[{"name":"ecs","slug":"ecs","permalink":"http://yoursite.com/categories/ecs/"}],"tags":[{"name":"ecs","slug":"ecs","permalink":"http://yoursite.com/tags/ecs/"},{"name":"xshell","slug":"xshell","permalink":"http://yoursite.com/tags/xshell/"}]},{"title":"第一篇博客啊","slug":"blog","date":"2018-07-19T16:36:22.000Z","updated":"2018-07-20T03:25:25.931Z","comments":true,"path":"2018/07/20/blog/","link":"","permalink":"http://yoursite.com/2018/07/20/blog/","excerpt":"","text":"这是我的第一篇博客啊！折腾了3天了，不过算起来也只是几个小时，还没弄好，心态有点爆炸啊，js也几天没有学了。这是百度的链接emmmm,暂时就这样！123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;fuck you&quot;); return 0;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"}]}]}