<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue插件开发4-插件的打包与引用]]></title>
    <url>%2F2021%2F01%2F13%2FVue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%914-%E6%8F%92%E4%BB%B6%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+Z3+yprbGaUeOe5lM4HTjE8xCXGeCmU+O/m5Qxqst+EY0gCQdN0yYvgcQkXlj2T5eE21PwYECJyU+zTeH9mcNUpfbUBNNsGn0+goINrw84MWjCV1kySD0TykqQP01NWI62uewxB5gXAGhC38MSM0sz7+AP5mYxxpQW+7O9eD/YqCyW+pTI98ilH0vuhQwV8/T+rJM2VlJy2+zi4MDGJ6/eTYf16ynoTcItWmlb6M2jX/FUmE6QAIxdshttMr9zFBCDu7dWcoVBeIvJK3Zyykr3jCTx0GTvQpEZyo1f7zqbdEu0zr2JIG0N1LmUTews4qkmLVYbq0sHIt4RRl1foYcvdqVMncM1C74w7fzYlrUTfBthaiZUFdaeEmFoi3qGX/1G/lXDdOh0mA== var onError = function(error) { document.getElementById("enc_error").innerHTML = "不知道密码就别猜了，这是我得小秘密，哈哈哈" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue插件开发3-拖动窗口的优化]]></title>
    <url>%2F2021%2F01%2F13%2FVue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%913-%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/NRb9wr81hm5Dt1okJdcSxDykk4hybZ7k= var onError = function(error) { document.getElementById("enc_error").innerHTML = "不知道密码就别猜了，这是我得小秘密，哈哈哈" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue插件开发3-事件参数e]]></title>
    <url>%2F2021%2F01%2F13%2FVue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%912-%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0e%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19vRN7VuX6GynMVBZIaRrBGLROlHkezVEQ= var onError = function(error) { document.getElementById("enc_error").innerHTML = "不知道密码就别猜了，这是我得小秘密，哈哈哈" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue插件开发1-插件原理即应用]]></title>
    <url>%2F2021%2F01%2F12%2FVue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%911-%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%8D%B3%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原理简介 插件通常用来为 Vue 添加全局功能。-Vue官网 我觉得广义上的插件，实际上就是一些可以复用的功能或组件的封装。 首先分析Vue源码： 12345678910111213141516171819202122232425//src-&gt;core-&gt;instance-&gt;index.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 我们可以法Vue实例最初是一个函数，然后在其上挂载各种属性。作为函数，我们就可以为其直接添加属性，或者向其prototype上添加参数。 Vue的插件通常包括一下几种： 添加全局方法或者 property。如：vue-custom-element 注册代码： 123456function install(Vue) &#123; Vue.customElement = function vueCustomElement(tag, componentDefinition, options = &#123;&#125;) &#123; //... &#125; //...&#125; 可以看到，这里是直接向Vue实例上添加属性方法。 使用： 1Vue.customElement() 另外，这个插件使用了Web Component这一新的属性，还得找个时间学习一下。它可以在HTML文件中直接使用自定义标签。 添加全局资源：指令/组件/过滤器/过渡等。如 vue-touch 注册代码（vue-touch）： 123456vueTouch.install = function (Vue) &#123; Vue.directive('touch', &#123; //... &#125; //...&#125; 这里是使用了Vue的directive定义了一个全局的v-touch指令。 123&lt;a v-touch:tap="onTap"&gt;Tap me!&lt;/a&gt;&lt;div v-touch:swipeleft="onSwipeLeft"&gt;Swipe me!&lt;/div&gt; 另外，还可以通过Vue.filter注册全局的filter来进行使用，比如 123456789let plugin = &#123;&#125;plugin.install = function(Vue, options)&#123; Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;)&#125; 则可以直接在Vue的tempelate中使用 1&lt;div v-bind:id="rawId | formatId"&gt;&lt;/div&gt; 值得注意的是全局组件的注册，因为很多时候我们开发组件是需要组件样式支撑的。这个时候就需要全局注册组件。比如element-UI(可惜无了)，iview这种组件库就需要注册大量的全局样式。 注册代码（部分）（element-UI）： 123components.forEach(component =&gt; &#123; Vue.component(component.name, component);&#125;); 这里使用Vue.component注册全局组件，这样注册的组件可以直接在任何组件中引用而不需在script中申明。 值得注意的是，这样引入的组件即使未被引用，依然会被打包，因此，在大型组件库中尽量少使用全局注册，否则会增加打包后的js大小。 通过全局混入来添加一些组件选项。如 vue-router 注册代码： 123456789101112131415161718export function install (Vue) &#123; Vue.mixin(&#123; beforeCreate () &#123; if (isDef(this.$options.router)) &#123; this._routerRoot = this this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, '_route', this._router.history.current) &#125; else &#123; this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this &#125; registerInstance(this, this) &#125;, destroyed () &#123; registerInstance(this) &#125; &#125;)&#125; 可以看到，这里vue-router使用了Vue.minin对beforeCreate进行了混入，使该混入钩子在Vue自身的钩子之前调用。 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。比如element-UI等组件库。 注册代码： 123456789101112131415161718192021222324const install = function(Vue, opts = &#123;&#125;) &#123; locale.use(opts.locale); locale.i18n(opts.i18n); components.forEach(component =&gt; &#123; Vue.component(component.name, component); &#125;); Vue.use(InfiniteScroll); Vue.use(Loading.directive); Vue.prototype.$ELEMENT = &#123; size: opts.size || '', zIndex: opts.zIndex || 2000 &#125;; Vue.prototype.$loading = Loading.service; Vue.prototype.$msgbox = MessageBox; Vue.prototype.$alert = MessageBox.alert; Vue.prototype.$confirm = MessageBox.confirm; Vue.prototype.$prompt = MessageBox.prompt; Vue.prototype.$notify = Notification; Vue.prototype.$message = Message;&#125; 在Vue的prototype上添加很多参数方法。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router vue-router中有一个index.js与install.js，在install.js中，只提供了与Vue相关的注册函数。在index中，定义了很多自己的API。 使用插件通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成： 123456// 调用 `MyPlugin.install(Vue)`Vue.use(MyPlugin)new Vue(&#123; // ...组件选项&#125;) 也可以传入一个可选的选项对象： 1Vue.use(MyPlugin, &#123; someOption: true &#125;) Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。 Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 Vue.use()。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 Vue.use()： 123456// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时var Vue = require('vue')var VueRouter = require('vue-router')// 不要忘了调用此方法Vue.use(VueRouter) 另外，全局样式表的引入需要直接在main.js中import，这样的css样式也会被全局注册，会影响所有的组件。 开发插件Vue插件打开发其实很简单，最关键的就是其必须要暴露一个install方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 12345678910111213141516171819202122232425262728293031MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) Vue.component('my-component', Mcomponent) //常用 Vue.filter('my-filter', Mfilter) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125;export MyPlugin 应用根据上面的原理，我们只需要遵顼插件定义和使用的规则即可，其目录解构并不重要，但是为了规范，可以新建一个plugin用来存储插件文件，插件的目录解构可以自定义。另外，项目直接使用vue-cli生成一个普通的项目即可。 可以看到，在index.js文件中，我们定义了install函数，并在Vue的prototype上挂载了一个函数和一个方法，同时，也注册了一个全局的组件dwin。最后将该对象导出。 然后在main.js中，我们从index.js中引入dw，然后使用Vue.use(dw)将该组件导入。 然后我们就可以在任何组件中使用dwin组件了。 这样一个简单的组件开发就完成了，具体的打包和上传到npm仓库见这里]]></content>
      <categories>
        <category>Vue插件</category>
      </categories>
      <tags>
        <tag>Vue插件开发</tag>
        <tag>dragWindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript特点2]]></title>
    <url>%2F2021%2F01%2F10%2FTypeScript%E7%89%B9%E7%82%B92%2F</url>
    <content type="text"><![CDATA[类型兼容性TS中的类型兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。 与Java不同，Java的强制转换是基于继承的，只有有继承关系的对象才可以进行转换。 即只要对象中的成员有包含关系，则可以进行类型转换。如， 1234567891011interface Named &#123; name: string;&#125;class Person &#123; name: string;&#125;let p: Named;// OK, because of structural typingp = new Person(); 这一点也是根据JS的灵活性设计的，JS中变量类型是自动检测的，程序员不需要专门进行规定。 对象的兼容TS结构化类型系统的基本规则是，如果x要兼容y，（所谓x兼容y，就是x可以被赋值为y），如 12345678interface Named &#123; name: string;&#125;let x: Named;// y's inferred type is &#123; name: string; location: string; &#125;let y = &#123; name: 'Alice', location: 'Seattle' &#125;;x = y; 称为x兼容y。 这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。 函数的兼容函数参数兼容函数的兼容与对象的兼容相反，函数x的参数包含函数y的参数，则x兼容y。如 12345let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // OKx = y; // Error 要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。 第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。 这里可以理解为，在函数赋值时，函数的参数可以被忽略的，（注意：函数调用的时候仍然必须赋值相等的参数，否则采用可选参数）但是限制了不能多余参数。即y中的参数s，在被赋值给x的时候直接被忽略，即 1234567//JS中函数调用的灵活性function f(a, b)&#123; //...&#125;f(1, 2); //参数b被忽略f(1, 2, 3) //多加参数c 函数返回值兼容返回参数少的函数可以被赋值为参数多的函数（这里TS称参数多的为参数少的函数的子类），即源函数可以被赋值为子类，即向下转换，如 12345let x = () =&gt; (&#123;name: 'Alice'&#125;);let y = () =&gt; (&#123;name: 'Alice', location: 'Seattle'&#125;);x = y; // OKy = x; // Error, because x() lacks a location property 类的兼容类的兼容只比较实例成员。静态部分不会被比较。（仍然是基于成员的比较，而不是Java中的继承），如 123456789101112131415class Animal &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;class Size &#123; feet: number; constructor(numFeet: number) &#123; &#125;&#125;let a: Animal;let s: Size;a = s; // OKs = a; // OK 高级类型交叉类型（Intersection Types）交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。 通俗的讲，就是包含所有成员类型的成员属性。如： 123456789101112131415161718192021222324252627function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; //将T与U成员变量混合成为新的变量，并返回该变量，返回时采用交叉类型而不是any let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person("Jim"), new ConsoleLogger());var n = jim.name;jim.log(); 联合类型（Union Types）形式：A|B|C 含义： 作为参数时，仅支持A类或B类或C类，其他类型数据均不被接接受。如： 1234567function f(value: number|string)&#123; //...&#125;f(1); //正常f("1"); //正常f(true); //失败 作为返回值时： 1234567891011121314151617interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;function getSmallPet(): Fish | Bird &#123; // ...&#125;let pet = getSmallPet();pet.layEggs(); // okaypet.swim(); // errors 由于返回的是A|B,所以我们只能访问A与B的交叉成员。 类型保护与区分类型（Type Guards and Differentiating Types）联合类型可以使我们接受多种特定类型的参数，但是我们要在函数内部更具参数类型执行特定的操作时又该如何判断呢。下面的写法是错误的，因为联合类型在访问任何独有参数时，都会发生错误。 123456789let pet = getSmallPet();// 每一个成员访问都会报错if (pet.swim) &#123; pet.swim();&#125;else if (pet.fly) &#123; pet.fly();&#125; 为了使代码工作，必须使用类型断言 12345678let pet = getSmallPet();if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125; 用户自定义的类型保护注意到，这种写法，我们在任何时候调用参数属性时，都必须加上类型断言。我们可以采用另外一种写法使之后的参数调用不再加上类型断言。 TS中的类型保护机制使之成为现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词： 123function isFish(pet: Fish | Bird): pet is Fish &#123; return (&lt;Fish&gt;pet).swim !== undefined;&#125; 在这个例子里， pet is Fish就是类型谓词。 谓词为 parameterName is Type这种形式， parameterName必须是来自于当前函数签名里的一个参数名。 每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型（在以后对应分支中的参数的每次调用都会被识别为该类型），只要这个类型与变量的原始类型是兼容的。 12345678// 'swim' 和 'fly' 调用都没有问题了if (isFish(pet)) &#123; pet.swim();&#125;else &#123; pet.fly();&#125; typeof类型保护实际上我们可以发现，在上面的断言函数中执行的内容就是判断参数是否为对应类型，是返回true，否返回false，所以我们在断言函数内部可以使用typeof来进行判断。 1234567891011121314151617function isNumber(x: any): x is number &#123; return typeof x === "number";&#125;function isString(x: any): x is string &#123; return typeof x === "string";&#125;function padLeft(value: string, padding: string | number) &#123; if (isNumber(padding)) &#123; return Array(padding + 1).join(" ") + value; &#125; if (isString(padding)) &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 更进一步，对于原始类型（number, string, boolean, symbol），TS直接将typeof识别为断言函数，而不必我们每次都为原始类型类型编写一个断言。 123456789function padLeft(value: string, padding: string | number) &#123; if (typeof padding === "number") &#123; return Array(padding + 1).join(" ") + value; &#125; if (typeof padding === "string") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 这些 typeof类型保护只有两种形式能被识别： typeof v === &quot;typename&quot;和 typeof v !== &quot;typename&quot;， &quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。 instanceof类型保护对于非原始类型，如何做到类型判断并收紧呢？TS提供了instanceof类型保护，也可以避免我们重写断言函数。 123456789101112131415161718192021222324252627282930313233interface Padder &#123; getPaddingString(): string&#125;class SpaceRepeatingPadder implements Padder &#123; constructor(private numSpaces: number) &#123; &#125; getPaddingString() &#123; return Array(this.numSpaces + 1).join(" "); &#125;&#125;class StringPadder implements Padder &#123; constructor(private value: string) &#123; &#125; getPaddingString() &#123; return this.value; &#125;&#125;function getRandomPadder() &#123; return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(" ");&#125;// 类型为SpaceRepeatingPadder | StringPadderlet padder: Padder = getRandomPadder();if (padder instanceof SpaceRepeatingPadder) &#123; padder; // 类型细化为'SpaceRepeatingPadder'&#125;if (padder instanceof StringPadder) &#123; padder; // 类型细化为'StringPadder'&#125; instanceof的右侧要求是一个构造函数，TypeScript将细化为： 此构造函数的 prototype属性的类型，如果它的类型不为 any的话 构造签名所返回的类型的联合 null和undefinedTS将null，undefined视为两种不同的类型，他们不能被赋值给任何其他类型的参数。如官方文档所说： 注意，按照JavaScript的语义，TypeScript会把 null和 undefined区别对待。 string | null， string | undefined和 string | undefined | null是不同的类型。 可选参数与可选属性使用了 --strictNullChecks，可选参数会被自动地加上 | undefined: 1234567function f(x: number, y?: number) &#123; return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, 'null' is not assignable to 'number | undefined' 也就是说，可选属性可以被赋值为undefined作为占位参数，但是不能被赋值为null。 同样的，可选属性也可被赋值为undefined作为占位参数。 12345678910class C &#123; a: number; b?: number;&#125;let c = new C();c.a = 12;c.a = undefined; // error, 'undefined' is not assignable to 'number'c.b = 13;c.b = undefined; // okc.b = null; // error, 'null' is not assignable to 'number | undefined' 类型别名形如C中的typedef语法，TS提供了类型别名。 1234567891011type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入： 1type Container&lt;T&gt; = &#123; value: T &#125;; 我们也可以使用类型别名来在属性里引用自己： 12345type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125; 类型别名只能出现在申明的左侧。 字符串字面量类型字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。 12345678910111213141516171819type Easing = "ease-in" | "ease-out" | "ease-in-out";class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === "ease-in") &#123; // ... &#125; else if (easing === "ease-out") &#123; &#125; else if (easing === "ease-in-out") &#123; &#125; else &#123; // error! should not pass null or undefined. &#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, "ease-in");button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。 1Argument of type &apos;&quot;uneasy&quot;&apos; is not assignable to parameter of type &apos;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&apos; 数字字面量类型TypeScript还具有数字字面量类型。 123function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 &#123; // ...&#125; 我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候： 123456function foo(x: number) &#123; if (x !== 1 || x !== 2) &#123; // ~~~~~~~ // Operator '!==' cannot be applied to types '1' and '2'. &#125;&#125; 换句话说，当 x与 2进行比较的时候，它的值必须为 1，这就意味着上面的比较检查是非法的。 可辨识联合（Discriminated Unions）你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素： 具有普通的单例类型属性— 可辨识的特征。 一个类型别名包含了那些类型的联合— 联合。 此属性上的类型保护。 12345678910111213interface Square &#123; kind: "square"; size: number;&#125;interface Rectangle &#123; kind: "rectangle"; width: number; height: number;&#125;interface Circle &#123; kind: "circle"; radius: number;&#125; 首先我们声明了将要联合的接口。 每个接口都有 kind属性但有不同的字符串字面量类型。 kind属性称做 可辨识的特征或 标签。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起： 1type Shape = Square | Rectangle | Circle; 现在我们使用可辨识联合: 1234567function area(s: Shape) &#123; switch (s.kind) &#123; case "square": return s.size * s.size; case "rectangle": return s.height * s.width; case "circle": return Math.PI * s.radius ** 2; &#125;&#125; Symbols这个部分也是ES6的引入一种新的原生类型，如number，string。 其特点是唯一，一个symbols是唯一独特的，无法改变的。即使两个symbol输入的key一样，这两个值仍然是完全不同的。 symbol类型的值是通过Symbol构造函数创建的。 123let sym1 = Symbol();let sym2 = Symbol("key"); // 可选的字符串key Symbols是不可改变且唯一的。 1234let sym2 = Symbol("key");let sym3 = Symbol("key");sym2 === sym3; // false, symbols是唯一的 像字符串一样，symbols也可以被用做对象属性的键。 1234567let sym = Symbol();let obj = &#123; [sym]: "value"&#125;;console.log(obj[sym]); // "value"]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript特点1]]></title>
    <url>%2F2021%2F01%2F09%2FTypeScript%E7%89%B9%E7%82%B91%2F</url>
    <content type="text"><![CDATA[基础类型VoidTS中增加了void类型，用于表示没有任何类型，一般也是用于一个函数没有返回值，但是与其他语言不同的是，TS允许一个变量直接声明为Void型（虽然这没什么用）。 1let unusable: void = undefined; void型变量只能被赋值undefined,null Null 和 Undefined这里的null与undefined与JS中基本一致，其是所有类型的子类，即所有的变量都可被赋值为null与undifined。 Nevernever表示那些永远不存在的的值的类型。从应用的角度来看，与void对比，never一般用于无法返回的函数的返回值类型。比如抛出错误的函数，死循环的函数。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error("Something failed");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; never与null、undefined一致，也是所有类型子类（比null,undefined级别更低）。 除了上述最常用的方法，never有其他用处。比如尤雨溪谈到的收窄类型 类型断言简单说，就是在对any型变量操作时跳过TS在编译时的检测，对于一个any的变量，我们在某些特定情况下知道其必定为某种特定类型，此时调用其特定的方法。我们可以跳过编译时的检测，但是其对运行没有影响。 具体，形式一：“尖括号”语法 123let someValue: any = "this is a string";let strLength: number = (&lt;string&gt;someValue).length; 形式二：as语法 123let someValue: any = "this is a string";let strLength: number = (someValue as string).length; 注意，无论是否通过类型断言，没有指定属性的变量始终返回undefined，如 1234567let a : any = 145;let b = (a as string).length;console.log(a.length); //undefinedconsole.log(b); //undefined 解构解构这一部分ES6也支持 ，并且我觉得这是一个非常好的特征，可以更加灵活地进行变量的交换，拆分，合并。 数组解构下面的形式是最简单的数组解构形式 1234let input = [1, 2];let [first, second] = input;console.log(first); // outputs 1console.log(second); // outputs 2 解构用于以申明的变量(交换变量是一个很好的应用) 12// swap variables[first, second] = [second, first]; 用于函数参数 12345function f([first, second]: [number, number]) &#123; console.log(first); console.log(second);&#125;f(input); …语法获取剩余变量 123456789let [first, ...rest] = [1, 2, 3, 4];console.log(first); // outputs 1console.log(rest); // outputs [ 2, 3, 4 ]function f([first, ...second]: [number, number, number, number]) &#123; console.log(first); //1 console.log(second); //[2,3,4]&#125;f(1,2,3,4); 只要位置对应，可以解构数组任何位置元素 123456let [first] = [1, 2, 3, 4];console.log(first); // 1let [, second, , fourth] = [1, 2, 3, 4];console.log(second); // 2console.log(fourth); // 4 对象解构与数组解构原理一致，只要键名一致，就可以就行解构。如， 12345678let o = &#123; a: "foo", b: 12, c: "bar"&#125;;let &#123; a, b &#125; = o;console.log(a) //fooconsole.log(b) //12 也可以用没有申明的赋值： 1(&#123; a, b &#125; = &#123; a: "baz", b: 101 &#125;); 注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。 同样，我们可以使用...语法进行剩余元素提取。 12345678let o = &#123; a: "foo", b: 12, c: "bar"&#125;;let &#123;a, ...others&#125; = o;console.log(a); //fooconsole.log(others); //&#123; b: 12, c: 'bar' &#125; 属性重命名我们也可以对提取的元素进行重命名， 1let &#123; a: newName1, b: newName2 &#125; = o; 这里需要注意的是:不是表示类型，而是旧名字与新名字的间隔。 但是如果需要限制提取元素的类型，则不能进行属性重命名。 展开我们可以使用...语法来进行数组（对象的展开），如 数组展开 123let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5]; //bothPlus = [0,1,2,3,4] 对象展开 12let defaults = &#123; food: "spicy", price: "$$", ambiance: "noisy" &#125;;let search = &#123; name: "me", ...defaults &#125;; //search = &#123;name:"me",food:"spicy", price: "$$", ambiance: "noisy" &#125; 值得注意的是，在对象展开中，相同的键值对会被合并！ 接口这里的接口与传统面向对象语言中的接口有一定的差距， 在面向对象的语言中（如Java），接口是一个抽象类型，是抽象方法的集合。 而在TS中，接口更多的是对数据及其解构进行检查。 下面是一个典型的用法： 1234567891011interface LabelledValue &#123; label: string; size: int; //顺序无关&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: "Size 10 Object"&#125;;printLabel(myObj); //Size 10 Object 与函数参数一致，接口中允许可选属性，只读属性的存在，例如： 123456789interface SquareConfig &#123; color?: string; width?: number; //加?可选属性&#125;interface Point &#123; readonly x: number; readonly y: number; //readonly-只读属性&#125; readonly vs const readonly用于属性； const用于变量； 额外的属性检查这里有一点需要注意的是，如果是采用字面量形式参数时，会触发额外属性检查。如： 12345678910interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let mySquare = createSquare(&#123; colour: "red", width: 100 &#125;); 这里会报错： script.ts(6,46): error TS2355: A function whose declared type is neither ‘void’ nor ‘any’ must return a value. script.ts(10,31): error TS2345: Argument of type ‘{ colour: string; width: number; }’ is not assignable to parameter of type ‘SquareConfig’. Object literal may only specify known properties, but ‘colour’ does not exist in type ‘SquareConfig’. Did you mean to write ‘color’? 但是我们在传参时不采用字面量对象传参，而是采用变量直接穿，则不会触发额外属性检查。 1234567891011interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let arg = &#123; colour: "red", width: 100 &#125;;let mySquare = createSquare(arg); 运行正常！ 函数类型当然TS中的接口也有传统面向对象语言中的抽象方法集合的功能。 123interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 与java不同，TS中的接口是可以直接被使用的，如， 12345let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125; 即直接定义变量的类为接口，在Java中这是不允许的，只有实现接口后的类才能被实例化。 接口实现这一点与java一致，接口是可以被实现的。 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; And，TS中接口可以多继承！ 函数TS中函数部分比较简单，主要仍然是格式问题 123function f(v1: int, v2: string) boolean&#123; //...&#125; 其他的细节都是JS中的内容，此处不谈。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-奋斗的一年]]></title>
    <url>%2F2020%2F12%2F31%2F2020-%E5%A5%8B%E6%96%97%E7%9A%84%E4%B8%80%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "不知道密码就别猜了，这是我得小秘密，哈哈哈" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>2020</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>计划</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考研遇到了问题！！！]]></title>
    <url>%2F2020%2F04%2F22%2F%E8%80%83%E7%A0%94%E9%81%87%E5%88%B0%E4%BA%86%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[回顾考研与2020想想考试复习考研已经有整整3个多月了，大概一月下旬就开始复习了！ 首先复习了两门科目 数学 英语 数学采用了看视频的方式进行了一轮复习，到四月十号左右就完成了。 英语的话由于最开始没有资料，只有几套真题，所以我直接上手真题。当然，错误率非常之高，问题只有一点：单词和短语积累不够，感觉每一道题，只要单词，短语90%理解，那基本不会错的。所以后面开始用百词斩背单词。由于之前背过，所以考研的词汇还有事多天就要背完了，当然会忘记，所以在考研的过程中，要不间断的背下去。 总体回顾的话，我感觉4月之前，也就是1,2,3月份的状态比较好，早上做英语，下午看视频学习数学，晚上复习数学。作息比较规律，至少可以做到不赖床。 四月的问题进入四月，数学的基础部分基本完成，英语也看了许多视频，把刘晓艳得语法，长难句都看了一遍。书也差不多过了一遍。但是接近四月中旬时出现了很大的问题： 问题 身体出现了问题： 最开始是牙龈出血严重，平时都能感觉口型腔内的血腥味 耳鸣开始困扰我，只要周围声音一大，耳膜就开始震动，耳朵很敏感；晚上睡觉时耳鸣严重（倒是没太影响睡眠）。后来去检测发现鼻炎严重，开始治疗鼻炎。 开始上课了，导致不得不频繁的使用电子设备，很容易分心。 看书感觉很难集中精力去想问题，看着讲义上的内容，完全不想动脑。 不节制玩游戏。 聊天过于频繁。 解决方法既然出现的问题，就必须去解决问题。否则只会被问题一点点拖垮！以我现在的状态，不配考上研究生！ 对于身体问题，只能说加紧治疗，毕竟没有更好的办法，只要不影响学习（但是我感觉最近这一系列问题的出现都是身体问题引起的）。 上完课就将电子设备放到远离自己的位置，避免手能够直接接触。 难集中精力，我觉得80%因为电子设备在旁边，所以先实行方法2，看是否还有其他原因。 立刻戒掉游戏，可以在周末玩一会。 当断不断，必受其乱！现在不是时候！ 接下来的安排既然选择了考研，我就不会退缩！所以我有以下安排来恢复状态，想想高中时一天学习14.5个小时的时候，现在这些算的了什么？！毕竟我是南实出来的人，还是练出来了吧！ 想想自己为什么考研？之前的我还不是很明确，但是现在，我觉得考研的目的很简单，就是为了实现自己的人生目标，实现阶级的跨越，在这样一个阶级越来越固化的时代，中国为底层提供了一个很好的工具，就是读书。起码读完硕士，就迈入了中薪阶层。后面在考虑是否读博士，现在的我并不很排斥继续读博士。 具体措施如下： 恢复斗志很关键，必须要恢复斗志，这是一切的来源！ 尽量隔离电子设备，学习时不看手机！ 每天计划，用纸打印表格。 每周总结，并发布到博客上。 规律作息，早上6:30起床，晚上23:30睡觉。 每周天放松，早上看书，下午玩游戏，晚上看技术文章，写总结。（作息仍然不变！） 一定要坚持下去最开始我在想考研该是有多困难啊！那么多人考不上，后来我才发现原来不是考研难，而是复习的这个过程最困难。不比高中，有人24hours的监督你来学习，时间制定好，饭做好。大部分人可能都没有高考时一半用心，所以考上的人那么少。我现在是真的体会到了他们常说的一句话，考研比的是坚持，比的是身体，比的是自律！一点没错！智商的影响只在于你是否能考上北大清华。加油，记住你对自己的定位！]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码1-从初始化到响应式原理]]></title>
    <url>%2F2020%2F01%2F08%2FVue%E6%BA%90%E7%A0%811-%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[首先介绍后面要用到的几个类： Observer类：用于将一个数据变为响应式（可被观测） Watcher类：一个依赖（一个指令对应一个依赖），一旦有一个指令用到了某个对象属性，那么就会新建一个Watcher作为订阅者。 Dep类：依赖管理器，一个对象属性对应一个Dep，其有一个内部属性subs用于存放依赖。 Vue初始化Vue原型是在src/instance/idnex.js中定义的： 12345678910111213141516171819202122232425//src/instance/idnex.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 可以看到Vue原型是一个function。在这个函数只判断了是否是new出来的，否则报警告。然后直接调用了_init()方法，这个方法是在下面的initMixin(Vue)中混入的初始化方法。下面看一下这个方法中的重要部分。 1234567891011121314151617181920212223//init.js 52-72 liens initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props //state包括data，props，methods initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; 这里按顺序进行了一下操作(最简化，不考虑分支)： 首先初始化了生命周期 initLifecycle(vm) 初始化了事件($on,$emit,$once…) initEvents(vm) 初始化了render initRender(vm) 调用了beforeCreate生命周期 callHook(vm, &#39;beforeCreate&#39;) 是初始化inject initInjections(vm) 接下来的initState中，初始化了data,props,methods。 initState(vm) 初始化provide initProvide(vm) 调用生命周期created，callHook(vm, &#39;created&#39;),如同官网所说： 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前尚不可用。 最后一步将el挂载到页面。vm.$mount(vm.$options.el) 响应式原理（以对象为例）响应式的所有文件都放在observer文件夹下： observer array.js:数组的处理相关处理 dep.js:依赖管理器类的定义及其处理 index.js:整个observer的出口 scheduler.js:调度者相关文件 traverse.js:递归遍历一个对象，以唤醒所有转换getter，使每个嵌套的属性内的对象作为“深度”依赖项收集。 watcher.js:观测者，依赖的类定义与相关处理。 还是接着上面的第6步:initState initState方法定义在state.js中，下面节选这一部分中内容： 12345678910111213141516171819202122//state.jsexport function proxy ()&#123; //代理处理 //比如当我们调用this.xxx 的时候实际上它是挂载在vm._data.xxx的，这里的代理同样使用了Object.defineProperty()来进行了代理。&#125;export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 可以看到intiState中，Vue进行了下面主要操作： initProps(vm, opts.props) initMethods(vm, opts.methods) initData(vm) initWatch(vm, opts.watch) 然后以data为例，分析对data的处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243//state.jsfunction initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method "$&#123;key&#125;" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property "$&#123;key&#125;" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 在这个函数里 首先看data是一个对象还是一个函数，对其进行对应的处理 然后判断他不能与props,methods中的属性同名，因为最终这三部分都会被挂载到vm实例上。 最后调用observe()方法来使data变为可被观测的 然后我们看observe()方法，这个方法就位于observer下的index.js中了。 1234567891011121314151617181920212223//observer/index.jsexport function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 作为整个将数据变为响应式的入口函数，它进行了一下操作： 判断传入的val如果不是一个对象或者是一个Vnode，就直接返回，不做处理 判断整个val是否有__ob__整个属性或者是不是Observer的子类，如果是的话，直接将val.__ob__返回 进行了一系列的其他的判断，比如是否应该被观测（shouldObserve这个对象定义在全局中，判 标识此时是否应该处理数据）、是否处于服务端渲染模式、是一个数组或是一个对象、是不是可扩展的、是不是Vue本身。 新建一个Observer对象，并将value传入。 继续向下看，新建Observer对象过程，Observer对象也在index中定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//observer/index.jsexport class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 可以看到Observer对象包含了三个私有属性： value：当前观测对象 dep：依赖管理器 vmCount：将这个对象作为$data的数量 再看他的构造方法中，执行流程如下： 初始化了value，dep，vmCount 并给value的加上一个(不可枚举的)__ob__属性，可以联系上面判断__ob__的操作 判断value是否是一个数组，然后执行对数组的observer操作。现不看数组。 如果不是，则代表value是一个对象，则执行walk()方法对其进行处理。 在walk()中，可以看到Vue遍历了对象的所有属性并对其调用了defineReactive方法 我们再跟进defineReactive方法中（这个方法就差不多是核心了）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; //为每一个属性建立一个依赖收集器 const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125; &#125;)&#125; 还是分析一下他的执行流程： 首先建立了一个Dep对象，即每一个属性都有一个依赖管理器用来收集用到这个属性的依赖，这一部分后面在讲。 判断这个对象属性能否被修改，及判断其configurable属性。 判断这个对下给你属性是否自带了getter与setter，如果有的话就将其缓存下来。 判断是否在函数调用时为这个对下给你属性传入了customSetter，如果有的话，则先调用getter将其值存储下来。 判断有无子对象或者是否在函数调用时确定只观测表层属性（不循环处理），如果都不满足则递归进行子属性的响应式处理。 这里就使整个响应式的核心：Object.defineProperty，在这里Vue为其定义了enumerable,configurable,get,set get()： 获取原始的属性值（通过原始getting或者直接获取） 判断Dep.target的值是否存在（这个值后面介绍Dep对象时介绍，代表的是当前的依赖），如果存在的话，就调用dep对象的depend()方法进行依赖收集。 接下来判断是否有子ob对下给你，如果有的话，也调用子的dep的depend方法进行依赖收集。同时判断对象属性原来的值是否是个数组，如果是的话，调用dependArray方法进行数组的依赖收集。 set() 获取对象属性原本的值，调用原来的getter，如果没有，就接受传入的值。 判断有没有必要更新。 判断是否有customSetter，如果有的话，就调用 如果只有getter，没有setter，则直接返回。这里是为了修复#7981的BUG，问题大概是如果一个对象属性如果被其他插件修改后只有getter，但没有setter，也就是说整个插件的原意是将其变为一个不可写入的属性，但是如果不加这一句进行判断，那么Vue会直接调用val = newVal，对其进行赋值。这不符合预期，所以加了这一句判断，直接返回不进行处理。 判断如果原来有setter的话，就调用其setter。否则就直接赋值给val。 然后同样是对子属性的处理。 这一步进行依赖派发。 至此，defineReactive方法流程介绍完毕。但是我们还留下了两个坑 依赖收集dep.depend()具体如何完成的 依赖通知dep.notify()具体如何完成的 接下来我们在进入这两个函数进行分析。 首先我们看一下Dep对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//observer/dep.js/* @flow */import type Watcher from './watcher'import &#123; remove &#125; from '../util/index'import config from '../config'let uid = 0/** * A dep is an observable that can have multiple * directives subscribing to it. * 一个dep可以有多个指令（包括"&#123;&#123;&#125;&#125;","v-text","v-html"...）订阅它。 * target属性用于表示正在处理的依赖，当确定为这个值的指令时，则将其添加到subs中（addSub函数）。 * subs属性用于存放所有的依赖，他的依赖是Watcher类 */export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this/* 这个依赖管理器Dep实例 */) &#125; &#125; notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;// The current target watcher being evaluated.// This is globally unique because only one watcher// can be evaluated at a time.Dep.target = nullconst targetStack = []export function pushTarget (target: ?Watcher) &#123; targetStack.push(target) Dep.target = target&#125;export function popTarget () &#123; targetStack.pop() Dep.target = targetStack[targetStack.length - 1]&#125; 可以看到Dep对象有三个属性， target：一个静态属性，类型是Watcher，即当前执行的依赖 id：Dep的标识符 subs：整个dep中所有的依赖，是一个Watcherd数组 然后我们直接看depend()方法： 这个函数判断dep的target是否存在，如果存在的话，则调用当前依赖的addDep方法，我们知道这个target是一个Watcher。所以我们看一下Watcher： 1234567891011121314151617181920212223242526272829303132export default class Watcher &#123; //初始化了很多属性 vm: Component; expression: string; cb: Function; id: number; deep: boolean; user: boolean; lazy: boolean; sync: boolean; dirty: boolean; active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any;&#125; addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; //调用depaddSub方法把这个指令（this）添加到这个dep中 dep.addSub(this) &#125; &#125; &#125; 可以看到在addDep中，判断这个Watcher对应的新dep中是否含有这个传进来的Dep，如果没有就其push到新dep与新depIds中，然后判断原来的dep中是否含有这个watcher，如果没有，就push进来。 这里的newDep与dep是为了灵活的动态更新视图，思考以下场景： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;span v-if=&quot;nameShow&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt; &lt;span v-if=&quot;ageShow&quot;&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt; &lt;input :value=&quot;name&quot;/&gt; &lt;input :value=&quot;age&quot;/&gt; &lt;button @click=&quot;nameShow = !nameShow&quot;&gt;切换name状态&lt;/button&gt; &lt;button @click=&quot;ageShow = !ageShow&quot;&gt;age&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&quot;Register&quot;, data () &#123; return &#123; nameShow: true, ageShow: true, name:&quot;123&quot;, age:&quot;111&quot; &#125; &#125;&#125;&lt;/script&gt; 当nameShow与ageShow都是true时，我们对表单机进行修改以修改name与age的值时，肯定会涉及到到依赖的分发。 但是当我们点击button将nameShow或ageShow的值切换为false时，视图上已经不显示对应信息，则讲道理应该不会在对这个依赖进行通知。这个newDep的存在就是为了这里。 至此，依赖收集的过程基本完成。下面看看如何进行依赖派发的： 当一个对象属性被改变时，其set方法就会被调用，由此调用dep.notify()，进行依赖派发。我们看一下dep.notify()这个函数内部： 12345678910111213141516//observer/dep.jsnotify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 可以看到首先是对subs所有的依赖进行了排序，根据官方的注释是应为：如果subs不是异步运行的话，那么他们没有在调度者中进行排序，所以我们需要对其进行排序以保证其正确按序派发。 然后这里调用每一个watcher的update方法，进行DOM的更新。看一下update()方法 12345678910update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 可以看到首先判断了这个watcher是不是懒加载的，如果是的话，将其dirty属性变为true，Vue会在调用到它时进行加载，否则看他是不是同步的，如果是的话，立即调用run()进行DOM更新操作，否则就将其推入到queueWatcher队列中，等待调度者，进行调度。（这里就不再讲调度算法，后续再讲） 再进入run()方法： 1234567891011121314151617181920212223242526272829303132//observer/watcher.js /** * Scheduler job interface. * Will be called by the scheduler. */ run () &#123; if (this.active) &#123; const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher "$&#123;this.expression&#125;"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125; &#125; 由官方的注释也可以看出来，这个run()是由调度者进行执行的（除非他是一个同步的watcher） run()函数的运行流程如下： 判断这个wacher是否的活动的，如果是才操作。 通过get()获取这个watcher对应的值，判断获取到的值与watcher中保存的值是否相同 如果不等，则把当前watcher中保存的值作为oldValue保存下来，将当前watcher中的value设为获取到的value，然后判断这个watcher是不是用户定义的（this.user）（根据调度者中注释，watcher分为user watcher与render watcher），如果使用定义的watcher则用try--catch预防错误，否则直接调用这个watcher的回调函数。这个回调函数就会进行真正操作，比如调用rrnder更新DOM。 数组的响应式如何实现在上面我们介绍Dep对象时，在其构造方法中，我们只看了this.walk()对对象的操作，现在我们看一下对数组的操作： 123456789101112131415161718192021export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; 如果value是一个对象，那么会判断value有没有__ptoto__对象，因为部分浏览器不支持这个属性，如果有的话，则调用protoAugment(value, arrayMethods)把arrayMethods挂载到value的__proto__上，我们再看一下arrayMethods，它放在 observer/array.js中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 可以看到 首先是以原生Array的prototype作为原型创建了一个新的对象arrayMethods。 列举出需要被修改的数组方法methodsToPatch 对methodsToPatch进行forEach循环，并给arrayMethods定义每一个列举出的方法（不可枚举），如果这些方法中要为这个数组插值，我们必须也要探测这个值是否是一个引用类型（Araay或者Object），并也要将其变为响应式，所以后面判断了如果是push,unshift,splice则拿到要插入的值inserted 判断inserted是否存在，如果存在，也使用observeArray将其变为响应式。 进行依赖收集ob.dep.notify() 返回原始方法调用后返回的结果。 然后我们再看protoAugment方法： 12345function protoAugment (target, src: Object) &#123; /* eslint-disable no-proto */ target.__proto__ = src /* eslint-enable no-proto */&#125; 可以看到很简单，就只是把第一个参数的__proto__修改为第二个参数，结合我们刚刚传入的参数，即：将这个数组的_proto_修改为arrayMethods，即上面我们分析的这个对象。 再看copyAugment方法，这个方法也很简单，是针对不支持__proto__属性的浏览器： 1234567891011/** * Augment a target Object or Array by defining * hidden properties. *//* istanbul ignore next */function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125;&#125; 即遍历所有的方法名字，并将其设置为到目标数组上的不可枚举属性。 最后我们看一下observeArray方法： 12345678/** * Observe a list of Array items. */observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125; 这里实际上就是将数组的每一个值变为响应式。 但是还有一点是：我们还可以通过下标的方式为数组赋值，但是JS中找不到方法检测整个操作，所以Vue也无法检测到，所以Vue提供了Vue.set和Vue.del这两个api，用来弥补这一点。 至此，响应式的整个流程就差不多完成了。 最后梳理以下整个流程(对象)： 这个流程主要是我通过分析源码，借助一定的网上资料整理出来的，可能其中会有错误。希望大家指出来，谢谢。]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>Vue源码</tag>
        <tag>响应式原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的&，&&，|，||]]></title>
    <url>%2F2020%2F01%2F07%2FJavaScript%E4%B8%AD%E7%9A%84%E4%B8%8E%E6%88%96%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[简单区分&amp;,&amp;&amp;,|,||&amp;&amp; 位与运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右全为1才为1 || 位或运算符 — 用于位运算（非数字会通过primitive原则转换为数字）—- 左右有一个1结果就为1 &amp;&amp;&amp;&amp; 逻辑运算符（与） — 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- 如果第一个值（转换后）为true，则返回后一个值。 如果第一个值（转换后）为false，则返回第一个值。 |||| 逻辑运算符（或）—- 用于逻辑运算 （非Boolean型会被转化为Boolean型进行对比）—- 如果第一个值（转化后）为true，则返回第一个值。 如果第一个值（转化后）为false，则返回第二个值。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中动态添加路由的问题]]></title>
    <url>%2F2020%2F01%2F06%2FVue%E4%B8%AD%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[起始前端的权限控制一直是一个可繁可简的问题，要想简单，直接写入所有路由，然后将每个路由的权限写入路由原信息中，然后在router.beforeEach中判断这个路由是否该用户的权限，进行reject()或者next()。这样做很简单，但是Vue提供了一个addRouter的api，用于动态注册路由，由此可以用这个api来根据用户角色进行动态路由注入。 问题动态注入路由后404问题一般我们将公共路由放置到路的初始化中，这其中就包括404页面，他的path一般是*,也就是匹配所有路由，因此Vue官方文档中提到： 当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: &#39;*&#39; } 通常用于客户端 404 错误。 所以我们一般将404放到静态路由的最后一个，但是当我们动态注入路由后，理论上来说，404的优先级应该比我动态注入的路由高，所以我第一使用动态注入时，所有页面跳转至404页面。开始以为是注入失败，后来将404页面删除就能够正常跳转了。 解决办法 所以我参照了element-ui-admin中的思路，没有使用*来匹配404页面，而是在router.beforeEach中，判断路由是否存在，手动跳转路由。 我在今天(2020-1-6)再次测试，发现Vue-router似乎对*进行了优化，即使将*的路由放到任意位置，包括首位，也会正确匹配路由，即当前所有路由中不存在时，才回去主动匹配*里有。当前使用的版本是：Vue(2.6.10)，Vue-router(3.1.3)，但是仅仅对*做了优化，其他通配符，比如/*并没有优化。 综合就是如果Vue-router版本够高，则可以使用*的方式来进行通配页面。 刷新路由消失的问题还有一个问题就是如果用户主动刷新浏览器，那么动态注入的路由就会生效，但是浏览器url并不会变，这个时候又会跳转至404。我这里采用的比较简答的方法就是在Vue实例初始化的时候进行重新注入。 在用户登录时将其用户标识信息存储至SessionStorage。 在Vue实例初始化时（第一次或刷新），首先应该是判断token，如果token失效，直接跳转至登录页。 如果token有效，再通过sessionStorage获取用户标识符，请求后端用户权限等级。再进行路由注入，并跳转至权限对应的页面。 因为刷新过程中整个页面的数据都会重新载入，所以我们必须使用一个持久化的容器，sessionStorage,localStorage,cookie都可以，但是我们不能将权限信息直接明文放到这些容器中，要么加密，要么只存储标识符，通过标识符再请求用户信息。 用户退出的问题使用router.addRouter的问题在于官方只提供了增加路由的api，并没有提供一个清除路由的api，这就导致如果同一个页面两个用户先后登录，那么就会出现路由重复注入，或者越级路由暴露的问题。经过查找资料，目前有两个主流的办法： 直接location.reload()刷新页面，重置整个Vue实例，路由当然也被重置。 优点 方便，一行代码解决问题。 缺点 如果页面应用过大，那么重新载入可能会花费一定的时间，会给用户不好的体验。 使用hack的方法，直接创建一个新的VueRouter，并将静态路由添加到新的路由中去，然后用新Router的matcher去替换就Router的matcher，这样相当于变相的清除了动态注入的路由。 优点 解决了上面刷新页面的问题。 缺点 官方没有提过使用该方法，所以可能会存在一定的问题，但是我发现element-ui-admin中也是使用的这个方法来实现路由清除，所以目前应该是不会有太大的问题。版本更新后就不一定了，也许后续官方就会推出清除路由的api。 附代码： 1234567891011121314151617181920//router.jsconst routes = [ /* 静态路由 */]const createRouter = () =&gt; &#123; return new VueRouter(&#123; routes &#125;);&#125;;const resetRouter = () =&gt; &#123; const newRouter = createRouter(); router &amp;&amp; (router.matcher = newRouter.matcher);&#125;;export &#123;resetRouter&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>动态路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中的插槽与keep-alive]]></title>
    <url>%2F2020%2F01%2F05%2FVue%E4%B8%AD%E7%9A%84%E6%8F%92%E6%A7%BD%E4%B8%8Ekeep-alive%2F</url>
    <content type="text"><![CDATA[插槽初次真正接触插槽是在Elementui中的表格中在自定义列的内容时 12345678910111213&lt;el-table-column label=&quot;姓名&quot; width=&quot;180&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt;&lt;el-popover trigger=&quot;hover&quot; placement=&quot;top&quot;&gt; &lt;p&gt;姓名: &#123;&#123; scope.row.name &#125;&#125;&lt;/p&gt; &lt;p&gt;住址: &#123;&#123; scope.row.address &#125;&#125;&lt;/p&gt; &lt;div slot=&quot;reference&quot; class=&quot;name-wrapper&quot;&gt; &lt;el-tag size=&quot;medium&quot;&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;/el-tag&gt; &lt;/div&gt; &lt;/el-popover&gt; &lt;/template&gt;&lt;/el-table-column&gt; 在列中插入一个template用来放置我们自定义的内容，并且可以通过slot-scope=&quot;scope&quot;中的scope来获取这一列的row信息。 仔细看了官方文档才明白，插槽slot是用来接收父组件在调用子组件时，在子组件标签内添加添加的内容，这个内容可以时文字，标签，或是其他组件。并且可以在slot上通过v-bind绑定值传递到父组件（说起来也算是子组件向父组件传值哦~）。可以预见，在el-table-column组件中，肯定存在一个slot来接受父组件的template: 123&lt;el-table-column&gt; &lt;slot v-bind:rowRata=&quot;rowData&quot;&gt;&lt;/slot&gt;&lt;/el-table-column&gt; 值得注意的是：scope-slot,slot这两个语法在2.6.0之后都被官方废除，但是并未移除。在3.0中会被移除，取而代之的是新的v-slot指令。具体用法如下： 插槽的作用域值得重视的是，插槽总是在父组件中渲染的，引用官方的一句话： 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 这句话中的“在”字，即我们能看到的。即使是插槽这样传递到子组件中元素。 所以，插槽总是能访问父组件的数据，而不能访问子组件的数组。但是有时我们又必须访问子组件的数据怎么办呢？这就用到了v-slot（slot-scope）属性。 官方称之为 作用域插槽对于默认插槽（即default），可以通过开始的代码形式，来获取子组件的值，前提是在子组件中使用 v-bind将其绑定到slot上。 123456//父组件&lt;child&gt; &lt;template v-slot=&quot;defaultPorps&quot;&gt; &#123;&#123;defaultPorps.user.name&#125;&#125; &lt;/template&gt;&lt;child&gt; 123//子组件&lt;slot v-bind:user = &#123;&quot;name&quot;:&quot;tom&quot;&#125;&gt;&lt;/slot&gt; 还有一点值得注意的是，Vue将整个slot的所有bind值封装为一个对象，所以我们使用v-bind绑定的值仅仅是该对象的一个属性（但是我们可以通过ES6的解构方法来直接拿到属性值） 具名插槽这个就很简单的了，一个子组件可能具有多个插槽，我们可以必须为止加上名字来区分，（如果不加，比如上面的例子中，v-slot = “xxx”全称应该是 v-slot:default=”xxx”，默认名字就是default），使用方法如下： 123456//父组件中&lt;child&gt; &lt;template v-slot=&quot;slot1&quot;&gt;对应插槽1&lt;/template&gt; &lt;template v-slot=&quot;slot1&quot;&gt;对应插槽2&lt;/template&gt; &lt;template v-slot=&quot;slot1&quot;&gt;对应插槽3&lt;/template&gt;&lt;/child&gt; 123456//子组件中&lt;template&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;&lt;/template&gt; 另外v-slot也可以缩写为#，就像v-on缩写为@，v-bind缩写为: keep-alive这个属性之前没有尝试过，但是最近遇到有个组件想要在来回切换时保持状态，既保持用户观看的内容，开始是想手动记录用户的状态，后来发现Vue官方提供了这个抽象组件，正好解决了问题， keep-alive基本用法是缓存某些组件的状态，我们从Vue的生命周期函数中可以发现，在组件失活时，都会触发beforeDestroy生命周期函数，但是如果我们将其包裹在keep-alive标签下，那么这些组件在失活时，并不会调用beforeDestroy方法，而是调用activated和deactivated` 这两个生命周期钩子函数将会被对应执行。将其缓存起来。 keep-alive组件有3个porp. include - 字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max - 数字。最多可以缓存多少组件实例。 基本用法123456789101112131415161718192021222324252627//缓存所有的组件&lt;keep-alive&gt; &lt;component1&gt;&lt;/component1&gt; &lt;component2&gt;&lt;/component1&gt; &lt;component3&gt;&lt;/component1&gt;&lt;/keep-alive&gt;//缓存特定组件&lt;keep-alive inlude=&quot;component1&quot;&gt; &lt;component1&gt;&lt;/component1&gt; &lt;component2&gt;&lt;/component1&gt; &lt;component3&gt;&lt;/component1&gt;&lt;/keep-alive&gt;//不缓存特定组件&lt;keep-alive exclude=&quot;component2&quot;&gt; &lt;component1&gt;&lt;/component1&gt; &lt;component2&gt;&lt;/component1&gt; &lt;component3&gt;&lt;/component1&gt;&lt;/keep-alive&gt;//规定最多缓存2个组件&lt;keep-alive max=&quot;2&quot;&gt; &lt;component1&gt;&lt;/component1&gt; &lt;component2&gt;&lt;/component1&gt; &lt;component3&gt;&lt;/component1&gt;&lt;/keep-alive&gt; 当然，也可以配合Vue-router。来进行使用： 配合路由在使用Vue-router进行组件选择性渲染的时候，我们同样也可以使用keep-alive，因为&lt;router-view&gt;&lt;/router-view&gt;组件是一个抽象路由，并不会真正创建一个组件结构在整个文档结构中，所以keep-alive对其仍然有效。代码如下： 12345678910111213141516171819202122232425262728293031323334//router.jsimport Vue from 'vue'import Router from 'vue-router'import Home from './views/Home.vue'import Login from './views/Login.vue'import Register from "./views/regisetr.vue"Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'home', component: Home &#125;, &#123; path: '/about', name: 'about', componet: About &#125;, &#123; path: '/login', name: 'login', component: Login &#125;, &#123; path: '/register', name: 'register', component: Register &#125; ]&#125;) 12345678910 &lt;transition :duration=&quot;500&quot; mode=&quot;out-in&quot; enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated bounceOutDown&quot; &gt; &lt;keep-alive exclude=&quot;Login,Register&quot; max=2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 上面的代码即表示，不缓存Login,Register组件，并且最多缓存2和组件。 *值得注意的是，当同时使用transiton组件与keep-alive组件时，transiton组件必须位于外层，很容易想明白，keep-alive组件对其内部的组件进行管控，如果将transiton组件放置到其内部，即使它是抽象组件，也会被被keep-alive组件管控，导致不正常**]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>插槽</tag>
        <tag>keep-alive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中的组件传值]]></title>
    <url>%2F2020%2F01%2F05%2FVue%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[父 =&gt; 子父组件向子组件传值比较简单，直接使用v-bind:key = val 1234//父组件&lt;template&gt; &lt;child :name = &quot;&apos;tom&apos;&quot; :age=&quot;&apos;12&apos;&quot; /&gt;&lt;/template&gt; 12345678910//子组件&lt;template&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125; &lt;div&gt;&lt;/template&gt;&lt;sctipt&gt; props:[&quot;name&quot;,age]&lt;/sctipt&gt; 这样在子组件中可以显示父组件给子组件传的值。 值得注意的是：在子组件中可以对父组件穿的值进行检验。 123456789101112131415161718192021222324252627282930//子组件&lt;template&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; --- &#123;&#123;age&#125;&#125;----&#123;&#123;id&#125;&#125;----&#123;&#123;address&#125;&#125;---&#123;&#123;email&#125;&#125; &lt;div&gt;&lt;/template&gt;&lt;sctipt&gt; props:&#123; //验证为字符串 &quot;name&quot;:String, //验证为数字 &quot;age&quot;:Number, //验证为字符串或者数组 &quot;id&quot;:[String,Number], //验证为必须传递的字段，并且默认值为北京 &quot;address&quot;:&#123; required:true, default:function()&#123; return &quot;北京&quot; &#125; &#125;, //进行高级验证 &quot;email&quot;:&#123; validator: function(val)&#123; return /^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+\.([a-zA-Z]&#123;2,4&#125;)$/.test(val) &#125; &#125; &#125;&lt;/sctipt&gt; 子 =&gt; 父一般不推荐子组件向父组件传值，即父 =&gt; 子的单向数据流会使整个项目更加容易维护。否则无法维护项目的整体性，组件内的状态可能会发生不在预期之内的改变。 但有时又必须通过子组件来改变父组件的值，则Vue官方提供了子组件与父组件通信的方法。借用这个通信的方法可以顺势进行传值。 1234567891011121314151617181920//父组件&lt;template&gt; &lt;child @getData = getData/&gt; &#123;&#123;val&#125;&#125;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; val:&quot;父组件的值&quot; &#125; &#125;, methods:&#123; getData(val)&#123; this.val = val; &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021//子组件&lt;template&gt; &lt;button @click=&quot;sendData&quot;&gt; 向父组件传值 &lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; val:&quot;子组件的值&quot; &#125; &#125;, methods:&#123; sendData(val)&#123; this.$emit(&quot;getData&quot;,this.val); &#125; &#125;&#125;&lt;/script&gt; 即利用v-on为子组件 添加一个自定义时间，并将父组件的特定方法传入这个监听事件。 在子组件中调用this.$emit(&#39;funcName&#39;,args...)来调用父组件的方法，并利用参数将值传入至父组件。 同级组件同级组件或者跨多级组件则可以使用vuex来进行数组的传输。具体就不在这里讨论vuex。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>组件传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中异步请求更新data导致数据变为非响应式的问题]]></title>
    <url>%2F2020%2F01%2F05%2FVue%E4%B8%AD%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9B%B4%E6%96%B0data%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E5%8F%98%E4%B8%BA%E9%9D%9E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题最近在项目遇到一个棘手的问题，看了1天才发现是异步与Vue的数据更新机制导致了结果与预期不一致。 最开始的代码流程是这样： 通过一个请求拿到一组数据data1，包括下一个请求的关键字 在第一个请求的回掉函数中使用for循环利用上一个数组的关键字发送多个子请求得到对应的datan，并在每个子请求的回调中对data1和datan进行对比，然后给data1添加一个字段key 在第一个请求的回调中把修改后的data1赋给Vue实例的data中 产生的问题在Vue实例中的data1对象中，原来的数据都是响应式的，但是我后来添加的数据并不是响应式的，导致DOM不更新。 解决过程产生问题后我先后大概经过了3次修改来解决这个问题： 思路一：data转换为响应式的时间首先我从响应式这个角度去分析，Vue是在哪个生命周期函数内将data挂载到Vue实例中的(因该是在beforeCreate与created之间)，而我做这些操作是在mounted，所以此时data因该已经被挂载到了Vue实例中，后来我又在思考JS中存在变量提升，是不是Vue中也存在，即是否在mounted中存在譬如this.xxx = yyy这样的语句会被提升到其他语句之前执行，yyy的内存地址提前就会被写入到this.xxx的位置，然后在这个内存地址被赋值时就将其变为响应式，所以第一次data1被赋值为一个数组时他是响应式的，但是后面对这个内存地址的变量进行的操作是为数组内的对象进行赋值this.data1[i].key = val，这样的赋值是无法被Vue探测到的，所以其后添加的属性无法变为响应式。这样子似乎一切都说的通，但是关键是这种变量提升这个东西我之前从未在Vue中遇到过，我查阅资料也发现根本不存在这种机制。于是这个说法被PASS。 不过这个过程中我也复习了一下生命周期函数和Vue中数组对象的处理： Vue生命周期引用官方的一张图： 值得注意的是：data，methods等都是在beforeCreated与created之间进行的。经常使用的mounted已经是在模板已经编译完成之后了。 Vue中对数组和对象的处理对于动态更新DOM最基本的原理是定义一个变量的getter和setter，在其中触发更新DOM操作，对于数组，我们整个赋值，我们可以使用getter和setter监听，但是如果我们操作数组内部的元素，比如arr[1] = 0，这样的操作我们是无法监听到的，因此在Vue中，如果这样给data赋值，这个值并不会变为响应式，而是一个普通的值。具体有 数组 通过索引去修改数组中的值，arr[i] = val 直接修改数组的长度，arr.length = n 对象 给对象添加属性（包括data根节点，比如没有在data中初始化某个值，在后续直接使用this.data1 = {}，这样data1无法变为响应式，dev模式下console会报错） 删除对象属性，（包括data根节点） 对于以上的问题，Vue提供了vm.$set这个api来解决。 对于数组的第一个问题，可以使用以下方式来解决： vm.$set(vm.data1,index,val) 对于数组的第二个问题，可以使用数组的方法来解决： vm.data1.splice(3) //data1会被切割为0-3项 原因是Vue在内部也修改了Array原型链上的方法，使其能够被Vue监听到，包括： push() pop() shift() unshift() splice() sort() reverse() 思路二：请求异步的问题这一次我似乎意识到了可能是异步的问题，因为之前玩canvas时，也是一直结果达不到预期，结果是img标签的onload事件是一个异步事件，导致结果不对。再仔细看这次的代码，可以发现，在第一次请求回调内部，由于接下来的子请求又是异步事件，所以直接执行了最后的this.data1 = data1。在子请求回掉函数执行时，data1已经被挂载到vm.data中，此时再对其进行添加属性处理，相当于是上面的对象添加属性的问题。所以必然是非响应式的。于是我this.data1 = data1放到子请求的回调中，每接受一次回调执行一次，虽然感觉这样很消耗性能。 但是结果是，data1数组中只有一个值的属性变为了响应式，其他的数组值仍然是非响应的。。。至少结果逼近真相了。 思路三：Vue对于data赋值的性能优化在Vue中，有一个异步更新队列，在Vue检测到data的值改变时，会将其写入异步更新队列中，在下一个事件循环中去进行DOM跟新等等。并且在这个队列中，会对数据写入进行优化，比如this.data1原来等于1,接下来执行了两句赋值，this.data1 = 3;this.data1 = 1;并且这两句在同一个tick（事件循环队列）中，那么Vue就不会对data1进行操作了。 那么这里极可能是在极短的时间内对data1进行了两次赋值，Vue将这两次操作优化，第一次是整个赋值，第二个则只对修改的部分进行了变更，但是前面又说道，Vue没办法探测数据内容或对象属性的添加操作。所以第一个是响应式的，而第二个则不是响应式的。 所以唯一的解决办法就是只进行一次data1的根赋值，所以我想到了 axios.all这个api，它是在所有请求完成之后返回并进行回调函数。在该回调函数中进行数据处理，再直接将data1赋给vm实例上。 成功解决 总结还是不太够仔细，异步这样的问题不能立即看出来，导致前面走了很大的弯，还好后面分析过程比较正确，找到了我呢提所在。不过也好，重温了一下，生命周期，Vue对数组和对象的处理等等。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>axios</tag>
        <tag>响应式数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年的我，21岁的人生]]></title>
    <url>%2F2020%2F01%2F04%2F2019%E5%B9%B4%E7%9A%84%E6%88%91%EF%BC%8C21%E5%B2%81%E7%9A%84%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "不知道密码就别猜了，这是我得小秘密，哈哈哈" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react中的事件绑定]]></title>
    <url>%2F2019%2F12%2F22%2Freact%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[遇到的问题最近想试一下React，之前一直用Vue在写东西。稍微看了几篇教程后，就开始写，能够基本运行起来，可能是因为项目比较简单吧。但是也遇到了几个问题，首先就是React的事件绑定问题： 我第一次的写法是： 12345handleEvent()&#123; console.log("test")&#125;&lt;Button onClick="handleEvent"&gt; &lt;/Button&gt; 这样普通的点击事件是能够正常触发的。 this的指向问题但是当我要使用this时，这种写法就出了问题。 1234567handleEvent()&#123; this.setState(&#123; state1 : 111 &#125;)&#125;&lt;Button onClick="handleEvent"&gt; &lt;/Button&gt; 这样就会报错this为undefined的。于是我就想起了之前看过的文章以及结合之前对JavaScript的函数的this分析。就明白此时函数在调用时不是被react对象直接调用的。所以该函数的this的指向为undefined。所以要想使用react对象的方法，只有将函数的this指向为react。根据之前文章对this的分析，要想绑定this，可以使用： call（一次绑定并调用） apply （一次绑定并调用） bind（永久绑定） 箭头函数 () =&gt; {}永久绑定 但是事件是要多次调用并且不是绑定时就调用，而是事件被触发时才调用，所以排除call与apply方法。所以选择bind与箭头函数为最佳(后来看官方文档时发现官方也是推荐了这两种方法来绑定this)。 所以有以下方法： 在构造函数中绑定函数的this指向 12345678910constructor(props)&#123; super(props) this.handleEvent = this.handleEvent.bind(this)&#125;handleEvent()&#123; console.log(this) //此时指向react对象&#125;&lt;Button onClick=&#123;handleEvent&#125;&gt;&lt;/Button&gt; 在事件绑定时绑定函数this 12345handleEvent()&#123; console.log(this) //此时指向react对象&#125;&lt;Button onClick=&#123;this.handleEvent.bind(this)&#125;&gt;&lt;/Button&gt; 至此，this的指向问题基本解决。 函数传参的问题接下来遇到需要传参的函数。我使用了与Vue与原始HTML同样的写法 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;this.handleEvent("123")&#125;&gt;&lt;/Button&gt; 当我尝试触发事件时，发现事件触发不成功，并且在打开控制面板时发现在页面初始化时，该事件被自动触发了3次，点击按钮无法触发。于是我不禁思考JSX的语法，让我想到了EL表达式，EL表达式中的代码会被直接运行，该位置会被填充为运行后的结果。再来看这个问题就发现自己的问题了。 {}内的代码在JSX模板编译时被当成代码直接运行，而tihs.handleEvent(&quot;123&quot;)在JavaScript中不就是直接运行函数吗，所以函数在模板编译时直接被运行了，而onClick的事件则被绑定为函数的返回值，但是这个函数没有返回值，所以事件绑定失败。 所以如何解决这个问题就很简单了，只要在事件绑定的位置放置一个函数而不是函数的调用就行了,方法也有两个： bind方法传参 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;this.handleEvent.bind(this,"123")&#125;&gt;&lt;/Button&gt; 箭头函数 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;() =&gt; &#123;this.handleEvent(123)&#125;&#125;&gt;&lt;/Button&gt; 折腾一下在看到箭头函数时我又思考能不能不用箭头函数，直接用匿名函数实现函数的调用。像这样： 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;function(para)&#123;this.handleEvent(para)&#125;&#125;&gt;&lt;/Button&gt; 再一想发现好想更不行，匿名函数没有绑定this指向。所以也就拿不到this.handleEvent()函数了。那就试试绑定一下匿名函数的this指向，像这样： 12345handleEvent = (para) =&gt; &#123; console.log(para)&#125;&lt;Button onClick=&#123;function()&#123;this.handleEvent(123)&#125;.bind(this)&#125;&gt;&lt;/Button&gt; OK，事件成功绑定，但是转念一想，这么搞还不如直接bind原函数，也避开了使用箭头函数。纯属折腾吧。 获取事件对象event在Vue或者原生HTML中，event被存储在window下的event对象中，在绑定事件时将event对象传入即可获得点击事件对象。 但在React中，我们可以这么做： 当我们不需要为这个函数传参时，event对象会自动传入该函数，我们通过第一个参数获取event对象 当我们需要传参时，我们需要手动传入event对象 12345678handleEvent = (para,e) =&gt; &#123; console.log(para) console.log(e)&#125;&lt;Button onClick=&#123;(e) =&gt; &#123;this.handleEvent(123,e)&#125;&#125;&gt;&lt;/Button&gt;//或者这样&lt;Button onClick=&#123;this.handleEvent(123,e)&#125;&gt;&lt;/Button&gt; Last至此，React中的函数事件绑定基本可以搞定。写了一段时间的React，感觉相较于Vue，更灵活。刚入手的话，习惯了Vue模板文件的 &lt;template&gt; &lt;style&gt; &lt;script&gt;这种分明的设计，React中的JSX写起来感觉有点复杂。在对比anted与elemenui，感觉elementui的api简直太简单了。后期在多体验看看吧！]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>事件绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS伪类与伪元素]]></title>
    <url>%2F2019%2F11%2F20%2FCSS%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[伪类？伪元素？之前一度认为伪类就是一组选择器，伪元素是不在DOM树的中的一些元素。但是当我看完MDN上的所有伪类与伪元素之后，才发现伪类与伪元素同属于CSS选择器的范畴，而伪元素其特殊之处在于伪元素可以选择的是一些不在DOM树中的元素，比如::selection用于选中用户用鼠标勾选的字符串；当然也可以选择在DOM树中的元素，比如::first-line用于选中元素的第一行，在特殊一点说，伪元素多用于选择一些特殊的东西，而伪类用于元素级别的选择，比如:nth:child用于选择某元素的第n个 由上面可以看出基本看做：元素级别的选择器用伪类，元素内的选择器与特殊选择器用伪元素 实际上最好的方法就是记住伪类与伪元素主要有哪些、特别是伪元素并不多。 伪类状态伪类 选择器 示例 说明 :link a:link 选择所有未访问的链接 :visited a:visited 选择所有访问过的链接 :hover a:hover 鼠标悬浮在链接上的状态 :active a:active 选择在激活状态的链接 :focus input:focus 选择获取焦点的输入框元素 :focus-within form:focus-within 用在父级元素上，当子元素获得焦点时，父元素获得对应属性(IE未实现) 结构化伪类 选择器 示例 示例说明 :first-child :first-child 选择p元素的第一个子元素 :first-of-type p:first-of-type 选择每个父元素是p元素的第一个p子元素 :last-child p:last-child 选择所有p元素的最后一个子元素 :last-of-type p:last-of-type 选择每个p元素是其母元素的最后一个p元素 :not(selector) :not§ 选择所有p以外的元素 :nth-child(n) p:nth-child(2) 选择所有p元素的第二个子元素 :nth-last-child(n) p:nth-last-child(2) 选择所有p元素倒数的第二个子元素 :nth-last-of-type(n) p:nth-last-of-type(2) 选择所有p元素倒数的第二个为p的子元素 :nth-of-type(n) p:nth-of-type(2) 选择所有p元素第二个为p的子元素 :only-of-type p:only-of-type 选择所有仅有一个子元素为p的元素 :only-child p:only-child 选择所有仅有一个子元素的p元素 :target #news:target 选择当前活动#news元素(点击URL包含锚的名字) 表单伪类 选择器 示例 示例说明 :disabled input:disabled 选择所有禁用的表单元素 :enabled input:enabled 选择没有设置 disabled 属性的表单元素 :required input:required 选择设置 required 属性的表单元素 :read-only input:read-only 选择设置 readonly 只读属性的元素 :read-write input:read-write 选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。 :checked input:checked 匹配被选中的 input 元素，input 元素包括 radio 和 checkbox :empty p:empty 匹配所有没有子元素的 p 元素 :in-range input:in-range 选择在指定区域内的元素 :out-of-range input:out-of-range 选择不在指定区域内的元素 :valid input:valid 选择条件验证正确的表单元素 :invalid input:invalid 选择条件验证错误的表单元素 :optional input:optional 选择没有 required 属性，即设置 optional 属性的表单元素 :default - 匹配默认选中的元素(提交按钮总是表单的默认按钮)。 :indeterminate - 当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。 :scope - 匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。(试验阶段) 伪元素单双冒号 选择器 作用 说明 ::before/:before 在被选元素前插入内容。 需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。 ::after/:after 在选被元素后插入内容 其用法和特性与:before相似。 ::first-letter/:first-letter 匹配元素中文本的首字母。 被修饰的首字母不在文档树中。 ::first-line/:first-line 匹配元素中第一行的文本。 这个伪元素只能用在块元素中，不能用在内联元素中。 双冒号 选择器 作用 说明 ::selection 匹配被用户选中或者处于高亮状态的部分. 在火狐浏览器使用时需要添加 -moz 前缀。 ::placeholder 匹配占位符的文本。 只有元素设置了 placeholder 属性时，该伪元素才能生效。 LAST对于伪类与伪元素，最好的不是区分它们，而是记住常用的选择器是属于伪类还是伪元素。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>伪元素</tag>
        <tag>伪类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3过渡与动画]]></title>
    <url>%2F2019%2F11%2F18%2FCSS3%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[CSS3-过渡 CSS3中，我们为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript。 使用transition属性，CSS3会自动为属性的变化来添加过渡样式。这个属性一般可以用在:hoevr :active等伪元素切换。 transition也是一个复合属性： 1234tag&#123; transition:transition-property ransition-duration transition-timing-function transition-delay; &#125; 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 transition-property该属性用于定义需要渐变的CSS属性，比如color width等。 可选值 描述 none 没有过渡动画。 all 所有可被动画的属性都表现出过渡动画。 IDENT 性名称。由小写字母 a 到 z，数字 0 到 9，下划线（_）和破折号（-）。第一个非破折号字符不能是数字。同时，不能以两个破折号开头。 transition-duration该属性定义渐变的时间，要带单位（s,ms）。 transition-timing-function这个属性是过渡的核心。引用MDN官方的描述： CSS属性受到 transition effect的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变。 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 step-start 直接跳到结束处 step-end transition-duration steps() 步进函数将过渡时间分成大小相等的时间时隔来运行没有过度效果，而是一帧一帧的变化，integer等于几就分成几帧，阶跃函数 steps()函数steps(&lt;integer&gt;[,start| end]?) :用于指定间隔个数（该值只能是正整数） 第二个参数可选，默认是end,表示开始值保持一次，若参数为start，表示开始值不保持 end:用于指定在step中间隔数少于该有的变化次数时，因该丢弃前面的部分还是后面的部分。 123456789即每个关键帧都分成两次变化完成，则一共有七次变化。七帧 一共变化七次， div本身没有颜色，所以最终的背景无色。但是，只变化七次，有七种颜色，加上无色，一种八种状态，所以需要丢弃一种状态start 橙、黄、灰、蓝、深灰蓝、绿、无色 原理：去掉第一帧的效果，end 红、橙、黄、灰、蓝、深灰蓝、无色原理：去掉最后一帧的效果 cubic-bezier(n,n,n,n)贝塞尔曲线函数的四个值，具体原理后面研究一下再写一篇博客。 transition-delay CSS的transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 下面写个例子 12345678910div&#123; width:120px; color:red; transition:all 0.5s ease 1s; &#125;div:hover&#123; width:200px; color:blue;&#125; 这段代码设定在鼠标划过时，所有的属性在1s后开始过渡，过渡时间为0.5s，过渡方式为ease。 CSS动画CSS3中，我们可以用2个属性来定义函数。 @keyframes animation 利用这两个属性可以制作简单或复杂的CSS东阿虎 @keyframes @keyframes 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。这比转换更能控制动画序列的中间步骤。 Point： 如果一个关键帧规则没有指定动画的开始或结束状态（也就是，0%/from 和100%/to，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。 如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 如果多个关键帧使用同一个名称，以最后一次定义的为准。 @keyframes 不存在层叠样式(cascade)的情况，所以动画在一个时刻（阶段）只会使用一个的关键帧的数据。 如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 因为@keyframes 的规则不存在层叠样式(cascade)的情况，即使多个关键帧设置相同的百分值也不会全部执行。 如果某一个关键帧出现了重复的定义，且重复的关键帧中的css属性值不同，以最后一次定义的属性为准。例如： 123456@keyframes identifier &#123; 0% &#123; top: 0; left: 0px&#125; 50% &#123; top: 30px; left: 20px; &#125; 50% &#123; top: 10px; &#125; 100% &#123; top: 0; left: 30px;&#125;&#125; 上面这个例子中，50% 关键帧中设置的属性top: 10px是有效的，但是其他的属性会被忽略 关键帧中出现的 !important 关键词将会被忽略 @keyframes格式如下： @keyframes 动画名字 { ​ 阶段名:{ ​ 元素属性 ​ } } 其中阶段名可以百分比或者from/to example: 1234567@keyframes mykeyframes&#123;0% &#123;background:red;&#125;25% &#123;background:yellow;&#125;50% &#123;background:blue;&#125;100% &#123;background:green;&#125;&#125; 这样就新建了一个动画关键帧，现在我们就需要使用animation将其添加到对应的元素上。]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>过渡</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数的防抖与节流]]></title>
    <url>%2F2019%2F11%2F17%2F%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖（debounce）在学习单片机开发时，按键防抖非常重要，我们必须使用一定的方法来进行防抖，否则会造成一次按键按键的多次触发的情况。而在JavaScript中，同样会有这样的问题，即在用户进行持续性的操作时，在用户大概率完成后，在进行后续操作（请求服务器，浏览器渲染等）。如果不进行防抖操作，会导致服务器或浏览器的性能浪费。 其具体定义：是指某一操作会被频繁触发，在一定时间内，该操作只会触发一次。 下面是一个函数实现： 1234567891011function debounce(fun, delay) &#123; return function (arguments) &#123; //获取函数的作用域和变量 let that = this; let args = arguments; clearTimeout(fun.id) // 清除定时器 fun.id = setTimeout(function () &#123; fun.call(that, args) &#125;, delay) &#125;&#125; 该函数接受一个目标函数与延迟，该函数内部返回了一个函数，并将目标函数的id设为定时器的id。如果第一次调用该函数，会设置一个定时器，设定在delay毫秒后执行目标函数，但是如果在delay毫秒时间内再次调用该函数的防抖函数，那么就会清除掉目标函数的定时器，也就不会执行了。并再次设置一个定时器，循环以上步骤。 节流（Throttle）节流更是一个重要的概念，特别是在进行渲染的操作时（比如，mousemove，scoll），如果不进行节流，那么浏览器将会消耗很多性能，致使页面卡顿与操作不流畅。 具体定义：是指在一定的时间内值允许函数执行特定次数。 1234567891011function throttle(fun,delay)&#123; return function(arguments)&#123; let that = this; let args = arguments; if(fun.timer) return fun.timer = setTimeout(function()&#123; fun.timer = null fun.call(that,args) &#125;,delay) &#125;&#125; 该函数的核心是在：在外部先判断目标函数fun的timer属性是否为空。如果为空，则直接返回。否则则设定目标函数的timer属性为一个定时器，在定时器的函数中将timer清空，并执行目标函数。 summary总体来说，在进行某些操作时，比如表单实时验证或者绘图的操作等，函数的防抖与节流会大幅度节省服务器与浏览器的性能！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中局部修改组件样式]]></title>
    <url>%2F2019%2F11%2F17%2FVue%E4%B8%AD%E5%B1%80%E9%83%A8%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Vue如何修改子组件样式在使用element-ui或者i-view这些第三方样式库时，我们有时会想只在某一个组件中局部修改库中的样式而部影响全局样式。 首先我们需要打开控制器找到对应组件的CSS样式的类名或者id 有以下几种方式 不在style样式上添加scope属性&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;el-input&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .father el-input{ color:red; } &lt;/style&gt; 这样相当于只修改father类下的el-input的属性。 使用 &gt;&gt;&gt; 穿透scope的用处scoped是Vue里面style标签的一个特殊属性，当一个style标签拥有scoped属性的时候，就相当于说明它里面的样式只作用于当前这个Vue页面，不会污染到全局的样式，从而实现了组件样式的模块化，那么它是怎么实现的呢？其实如果我们给style标签加上了scoped属性，在编译的时候，他会给我们组件里面的每一个样式加一个自定义的属性data-v-5558821a,从而通过给含有这个自定义属性的标签加上样式，从而实现了部分样式的穿透。 &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;el-input&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; .father &gt;&gt;&gt; el-input{ color:red; } &lt;/style&gt; 如果使用的是less或者sass可以将 &gt;&gt;&gt; 换为 /deep/ &lt;style scoped&gt; .father /deep/ el-input{ color:red; } &lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-转换]]></title>
    <url>%2F2019%2F11%2F05%2FCSS3-%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[CSS3中的转换CSS3中的转换可以形成简单的动画，对于页面的小优化有点金的效果。 CSS3中的转换都在transform属性中定义，在该属性中定义其他函数来进行不同的转换。 CSS3的2D转换translate()该函数接受两个参数，分别是其x，y轴的偏移量，右下为正方向。 transform:translate(50px,100px); 将原元素向右、下移动50px、100px。 如果只填一个参数，则默认为x轴偏移。 transform:translate(50px); 向x轴移动50px; transform:translate(0,100px); 向y轴移动100px； rotate()该函数接受一个参数，确定偏移的角度，正值为顺时针，负值即为逆时针。 transform: rotate(30deg);//顺时针30度 transform: rotate(-30deg);//逆时针30度 scale()该函数接受两个参数，分别为x轴的倍数，y轴的倍数。 scale(2,3); 将容器宽度放大2倍，高度放大3倍。 skew()通过 skew() 方法，元素将偏斜相应的角度，注意这个偏斜与rotate(旋转)不同，skew将会绕x,y轴偏斜x,y度，观察到的肉眼的形状会改变！比如只偏斜某一轴，则原元素会变成一个平行四边形。(与其他转换一样，其内容也会做对应的变换) transform: skew(30deg); transform: skew(0deg,30deg); transform: skew(30deg,30deg); matrix()matrix() 方法把所有 2D 转换方法组合在一起。默认值为：transforms:matrix(1,0,0,1,0,0); matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 matrix原意是矩阵，所以这六个参数分别是矩阵的6个位置的值： matrix(a,b,c,d,e,f) 也就是利用这个矩阵与原容器做运算后获得新位置。 所以我们运算过后的结果就是： x’=ax+cy+e y’=bx+dy+f 移动所以根据这个式子，我们可以推算如果要对元素进行x轴移动，则x’直接增大固定数值，即改变e的值： 向x轴移动10px，y不变 matrix(1,0,0,1,10,0) 向x,y轴都移动10px matrix(1,0,0,1,10,10) 缩放缩放的实质就是奖x，y轴的数值放大n倍，即： x’=2y y’=2x 对于上面的： x’=ax+cy+e y’=bx+dy+f 可得到： nx = ax+cy+e ny = bx+dy+f 易得： a = nb = 0c = 0d = ne = 0f = 0 即，进行缩放的话，我们只需要修改a,d的值以修改宽,高的缩放程度 旋转利用极坐标，我们可以算出偏移角度与元素某点的坐标的关系。 根据原理图得： 推算可以得到： 所以，我们得： a = cosθ b = -sinθ d = sinθ e = cosθ 所以改变abde，即可实现旋转。 偏移同样由数学知识 即： b = tanθxe = tanθy 所以，skew操作只与b、e相关。 不过如果不是利用CSS3来做一些复杂的变换，可以用这种方式来减少代码。否则最好不要使用这个函数，因为它可能会使你的调试复杂困难。 transform-origin()该属性确定转换的基点位置。 example: transform-origin:20px 20px; 规定变换的基点为：(x=)20px (y=)20px 其值可以为： left center right length % CSS3的3D转换我们在2D之中，我们看过“translate，scale，rotate”这三个变换属性。在3D变换中，这三个属性被拆分3个方向的分属性： translate() translateX() translateY() translateZ() scale() scaleX() scaleY() scaleZ() ratate() rotateX() rotateY() rotateZ() 每个方向上的分量分别是沿某一轴变换。比如：translateX(120)表示沿X轴正方向移动120px。 另外3D还有几个属性： transform-styleCSS 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。 flat 设置元素的子元素位于该元素的平面中。 preserve-3d 指示元素的子元素应位于 3D 空间中。 perspective-originperspective-origin属性也可以有3参数方式，第三个值为Z值。 backface-visibilitybackface-visibility 属性定义当元素不面向屏幕时是否可见。 perspective&amp;&amp;perspective-originperspective 属性定义 3D 元素距视图的距离，以像素计。(类似于AE相机中的属性值)。 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 元素添加perspective属性后，可再添加perspec-origin控制观察位置(类似与AE中的相机的x,y位置)。 注释：perspective 属性只影响 3D 转换元素。 .father{ width:400px; height:400px; perspective:120px; perspective-origin:10px 10px; background-color:blue; margin: 60px; } .son{ margin:60px ; width:120px; height:120px; background-color:gray; transform: rotateX(30deg); } 我们观察当perspective-origin值与perspective值改变时，元素发生的变化。 可以明显看出，当perspective值改变的时候，相当于我们视觉的位置与元素的距离发生了改变。而当perspective-origin发生改变的时候，我们是视觉的x，y位置发生了改变，所以我们看到元素的形状及其位置发生了改变。 LastCSS3中的3D变换算是一门学问，下一章解析过渡的时候一起再解析一下，让自己多理解一下。]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>transform</tag>
        <tag>translate()</tag>
        <tag>scale()</tag>
        <tag>rotate()</tag>
        <tag>skew()</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-文本效果和字体]]></title>
    <url>%2F2019%2F11%2F04%2FCSS3-%E6%96%87%E6%9C%AC%E6%95%88%E6%9E%9C%E5%92%8C%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[CSS3中的文字效果及字体CSS3本来规定了较多的文字属性，但是大部分没有被实现，所以只介绍已经被实现的属性。 text-shadowtext-shadow用于创建一个文字阴影，其参数如下： 参数 说明 &lt;offset-x&gt; x轴的偏移量 &lt;offset-y&gt; y轴的偏移量 &lt;blur-radius&gt; 模糊半径 example1: text-shadow: 5px 5px 5px #FF0000; text-shadow案例利用text-shdow的叠加，可以实现多种文字特效： 火焰文字效果关键：在文字外层加上多层黄色，红色的阴影，并且模糊程度越来越大，颜色的掌控很关键。否则可能不会很逼真。 background:black; text-align:left; text-shadow: 0 -5px 4px #FF3,2px -10px 6px #fd3,-2px -15px 11px #f80,2px -25px 18px #f20; color:red; 立体凸起效果关键：将背景颜色与温习颜色设为一致，再设置一个白色的阴影，一个黑色的阴影，x轴分别偏移-1px，1px即可达到效果。 text-shadow: -1px -1px white,1px 1px #333; color:#D1D1D1; font-weight: bold; background: #CCC; 立体凹下效果关键：与凸起相似，但是将两个偏移量交换一下，即可实现凹下效果。 text-shadow: 1px 1px white,-1px -1px #333; color:#D1D1D1; font-weight: bold; background: #CCC; 描边效果关键：设置4个黑色的阴影，模糊度为0，分别向上下左右各偏移1px，即可实现描边效果。 text-shadow: -1px 0 black,0 1px black,1px 0 black,0 -1px black; color:#ffffff; background: #CCC; 外发光效果关键：不要为阴影设置x，y的偏移量，增大模糊度，即可实现。 text-shadow: 0 0 0.2em #F87,0 0 0.2em #f87; color:#d1d1d1; background: #CCC; 3D效果关键：在同一方向上多次叠加颜色更深的阴影。 color:white; font-size: 200px; text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px 10px black; 关于text-shadow对于各种文字效果，如果我们认真分析文字附加效果的颜色及光影效果，我们可以利用text-shadow模拟出很多的文字效果。 word-wrap/overflow-wrapword-wrap又叫做overflow-wrap： word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”。 稳定的谷歌 Chrome 和 Opera 浏览器版本支持这种新语法。 该属性含有一个参数，其可以有以下值： 值 说明 normal 表示在正常的单词结束处换行。 break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 CSS3 @font-face 规则以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。 使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。 当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。 您所选择的字体在新的 CSS3 版本有关于 @font-face 规则描述。 您”自己的”的字体是在 CSS3 @font-face 规则中定义的。 实例： &lt;style&gt; @font-face { font-family: myFirstFont; src: url(sansation_light.woff); } div { font-family:myFirstFont; } &lt;/style&gt; 在font-family中，还可以定义字体的其他属性： 结束通过text-shadow和自定义字体，我们可以实现多种我们想要的字体效果了！结合上一章的背景，网页肯定能换发生机！]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>text-shadow</tag>
        <tag>word-wrap</tag>
        <tag>overflow-wrap</tag>
        <tag>font-face</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-背景]]></title>
    <url>%2F2019%2F10%2F29%2FCSS3-%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[backgroundCSS中，background是一个符合属性，是以下单属性的符合属性： background-color background-position background-size background-repeat background-origin background-clip background-attachment background-image 其格式如下 background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; background-colorbackground-color属性设置一个元素的背景颜色。 元素的背景是元素的总大小，包括填充和边界（但不包括边框）。 example: background-color:yellow; 其属性支持以下内容： 颜色关键值，如：red,blue… Hex颜色值，如：#bbff00… Hex含透明颜色值，如：#ffbb0036;（最后两位表示透明度，ff则为不透明，可省略，则变为普通Hex） RGB颜色值，如：rgb(255,255,255) RGBA颜色值，RGB可透明的颜色值，如：rgba(55,56,125,0.5)，透明度为0.5 特殊值： currentColor：该值是CSS3新增的一个颜色关键字，等会详细介绍。 transparent：透明背景 全局变量： inherit：继承上一级的背景颜色。（注意，该值可用于所有的CSS属性） initial：设置背景色的为默认值（每一个CSS属性都有一个默认值，有些为none，则设置没有效果），此属性可用于清除父级的继承属性。如p标签中的span标签的文字颜色继承问题。 unset：如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。换句话说这个unset关键字会优先用 inherit 的样式，其次会应该用initial的样式。 currentColor关键字CSS新增了currentColor关键字 currentColor代表了当前元素被应用上的color颜色值。 使用它可以将当前这个颜色值应用到其他属性上，或者嵌套元素的其他属性上。并且该属性会继承上级属性值。 example1: .box{ color:red; background-color:currentColor; //此时currentColor=red; height:100px; width:100px; } exmaple2: .fatherBox{ color:red; } .sonBox{ background-color:currentColor;//此时currentColor继承父级的color属性，为red } background-image其属性有以下内容： url():该函数接受一个地址作为背景图片的url，可以是本地地址，也可以是网络地址。 color值：&lt;rgb()&gt; | &lt;rgba()&gt; | &lt;hsl()&gt; | &lt;hsla()&gt; | &lt;hex-color&gt; | &lt;named-color&gt; | currentcolor | &lt;deprecated-system-color&gt; linear-gradient():该函数用于生成一个线性渐变。 radial-gradient()：该函数用于生成一个径向渐变。 repeating-linear-gradient()：该函数用于生成一个重复的线性渐变 repeating-radial-gradient()：该函数用于生成一个重复的线性渐变。 关键字：inherit(从父级继承) linear-gradient()CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于数据类型，是一种特别的数据类型。 其参数有以下几个： angle：角度，可为以下值： 角度值deg，如45deg，-120deg,方向递增方向为顺时针方向。 角度关键字，如，to left，to bottom right，这些关键字等同于相应的角度，如to top = 0deg，to right = 90deg，to bottom right = 135deg color-stop:结束位置颜色值（渐变开始位置）, 包含颜色及结束位置，如red 30%，blue 50% 只包含颜色值，如red,rgb(123,45,26)，此时每一个颜色会被设置默认的结束位置值，即按颜色均分该区域。如，red blue = red 0%,blue 100% 值得注意的是，每个颜色结束位置之间的距离就是这两个颜色渐变的距离 如： red 0%,blue 100%，那么红色与蓝色在之间的渐变距离即为100% red 0%,blue 50%,brown 100%，那么红色与蓝色之间的渐变距离则为50%，蓝色与棕色之间的渐变距离也为50%。 仔细思考一下会发现，如果两个颜色之间的渐变距离为0，那么他们之间的就不会有渐变，再利用角度的可改变与多次使用该属性，即可实现绘制图形 比如： 条形背景： background: linear-gradient(90deg,rgb(153, 153, 153) 50%,rgb(105, 105, 105) 50%); background-size: 20%; background-repeat: repeat; 切角效果 background: linear-gradient(45deg,red 10%,transparent 10%), linear-gradient(135deg,red 10%,transparent 10%), linear-gradient(-45deg,red 10%,transparent 10%), linear-gradient(-135deg,red 10%,transparent 10%); 折角效果 background:linear-gradient(-135deg,transparent 51%,rgba(0, 0, 0, 0.178)51%) no-repeat 100% 0 / 6em 6em, linear-gradient(-135deg,transparent 10%,rgb(169, 169, 233) 10%); 利用其线性切割+重复性，可以实现多种图案，只要想象力足够，唯一需要考虑的就是性能问题，如果通过其绘制过于复杂的线性动画导致页面性能损失，那也是得不偿失的。 radial-gradient()该函数接受5个属性： 参数 描述 可选值 &lt;size&gt; 整个渐变的尺寸大小，如果设置为circle,则可以在前面通过”100px”，”10%”的格式设置其半径，radius；如果设置为ellipse，则可以在前面通过”100px 200px”,”10% 20%”的格式设置其短半径与长半径的值。 绝对单位数值，如100px。相对单位数值，如20% &lt;extent-keyword&gt; 此关键字的词用于确定渐变最外侧的边与哪个边相切，或与哪个角相距。实际上也是确定半径，所以也可以通过size属性直接设置半径。 见下表 &lt;shape&gt; 渐变的形状。圆形（渐变的形状是一个半径不变的正圆）或椭圆形（轴对称椭圆）。默认值为椭圆。椭圆半径与容器的长宽比例相同。 redius：绝对单位数值，如100px；shape：’circle’,’ellipse’ &lt;position&gt; 渐变圆的圆心位置 一般在前面加上 at 关键字 ， 绝对单位数值，如100px。相对单位数值，如20% &lt;color-stop&gt; 渐变的颜色及其渐变结束位置 color:Hex值，rgb值，rgba值，颜色关键字；stop：绝对单位数值，如100px。相对单位数值，如20% 关键字 常量 描述 常量 描述 closest-side 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 closest-side 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 closest-corner 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 closest-corner 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 farthest-side 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 farthest-side 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 farthest-corner 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 farthest-corner 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 radial-gradient()基本应用example1(自己设置半径)： background-image: radial-gradient(100px 150px ellipse at 200px 250px,yellow 50%,red 70%); background-repeat: no-repeat; example2(用关键字)： background-image: radial-gradient(closest-side ellipse at 200px 250px,yellow 50%,red 70%); background-repeat: no-repeat; radial-gradient()高级应用与radial-gradient一样，如果设置两个结束颜色的渐变距离为0或为负值，则可形成径向切割，以此构成多样化的图形。 如： example1(内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%); 但是我们一般会想要多个内凹圆角，当我们简单的将多个radial-gradient堆起来就会发现前一个背景无论如何都会把后面的背景给覆盖掉。所以我们最好的办法是结合background-size,backround-position,background-repeat结合起来，形成多个不叠加的背景！ example2(两个内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 100% / 50% 100%, radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 100%; example3(四个内凹角) background: radial-gradient(100px circle at 0 0,transparent 50%,red 50%) no-repeat 0% 0% / 50% 50%, radial-gradient(100px circle at 100% 0,transparent 50%,red 50%) no-repeat 100% 0%/ 50% 50%, radial-gradient(100px circle at 0 100%,transparent 50%,red 50%) no-repeat 0% 100%/ 50% 50%, radial-gradient(100px circle at 100% 100%,transparent 50%,red 50%) no-repeat 100% 100%/ 50% 50%; repeating-linear-gradient()repeating-linear-gradient() 函数用于创建重复的线性渐变 “图像”。该属性的参数与linear-gradient()相同，所以不在赘述。 由于可以重复的组成背景图形，因此用处更多，条形背景是一个典型的应用。 example1: background: repeating-linear-gradient(yellow 0%,yellow 10%,black 10%,black 20%); example2: background: repeating-linear-gradient(rgba(255, 255, 0, 0.397) 0%,rgba(255, 255, 0, 0.397) 10%,rgba(0, 0, 0, 0.26) 10%,rgba(0, 0, 0, 0.26) 20%), repeating-linear-gradient(to right,rgba(255, 255, 0, 0.397) 0%,rgba(85, 243, 36, 0.397) 10%,rgba(0, 0, 0, 0.26) 10%,rgba(0, 0, 0, 0.26) 20%); repeating-radial-gradient()repeating-radial-gradient()用于创建多个repeating-radial原点辐射。参数与repeating-radial()一致。 example1: background: repeating-radial-gradient(circle at center, rgb(146, 146, 146) 0, rgb(146, 146, 146) 2%, black 2%,black 4%); 渐变综合应用用渐变生成一个复古胶盘： .box3 { position: relative; margin: 100px; height: 400px; width: 400px; color: cadetblue; border-radius: 50%; background: linear-gradient(30deg, transparent 40%, rgba(42, 41, 40, .85) 40%) no-repeat 100% 0, linear-gradient(60deg, rgba(42, 41, 40, .85) 60%, transparent 60%) no-repeat 0 100%, repeating-radial-gradient(#2a2928, #2a2928 4px, #ada9a0 5px, #2a2928 6px); background-size:50% 100%, 100% 50%, 100% 100%; } .box3:after{ position: absolute; top: 50%; left: 50%; margin: -35px; border: solid 1px #d9a388; width: 68px; height: 68px; border-radius: 50%; box-shadow: 0 0 0 4px #da5b33, inset 0 0 0 27px #da5b33; background: #b5ac9a; content: &apos;&apos;; } background-sizebackground-size 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。 其参数有以下内容： 值 解释 &lt;length&gt; &lt;length&gt; 值，比如10px,10em…指定背景图片大小，不能为负值。 &lt;percentage&gt; &lt;percentage&gt; 值，如10%，指定背景图片相对背景区（background positioning area）的百分比。背景区由background-origin设置，默认为盒模型的内容区与内边距，也可设置为只有内容区，或者还包括边框。如果attachment 为fixed，背景区为浏览器可视区（即视口），不包括滚动条。不能为负值。 auto 以背景图片的比例缩放背景图片。 cover 缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。 contain 缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。 inherit/initial/unset 继承父级该属性的值/默认值/如果unset 的CSS关键字从其父级继承，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值。 注意， 如果其值为&lt;length&gt;时，则可以分别设置其宽高，如： background-size: 50% 25%; 如果background有多个值，那么在background-size就可以有多个值，并且与其一一对应。 background-size: 50% 25%, contain, 3em; //有3个背景图片 background-originbackground-origin 规定了指定背景图片background-image 属性的原点位置的背景相对区域. 参数如下： 值 解释 border-box 背景图片的摆放以border区域为参考 padding-box 背景图片的摆放以padding区域为参考 content-box 背景图片的摆放以content区域为参考 下面是效果图： background-clipbackground-clip 设置元素的背景（背景图片或颜色）是否延伸到边框或padding下面。 值 解释 border-box 背景延伸至边框外沿（但是在边框下层）。 padding-box 背景延伸至内边距（padding）外沿。不会绘制到边框处。 content-box 背景被裁剪至内容区（content box）外沿。 text 背景被裁剪成文字的前景色。（实验性属性，chrome需加上-webkit-前缀） 下面是效果图： example: -webkit-background-clip: text; color: transparent; font-size: 200px; background-positionbackground-position 为每一个背景图片设置初始位置。 这个位置是相对于由 background-origin 定义的位置图层的。 参数如下： 值 解释 center 用来居中背景图片。 top, left, bottom, right 用来指定把这个项目（原文为 item）放在哪一个边缘。另一个维度被设置成 50%，所以这个项目（原文为 item）被放在指定边缘的中间位置。 &lt;length&gt; 指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。 &lt;percentage&gt; 指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。 该属性可以分别用两个值规定x,y的距离 如：example1： background-position：50px 50px; 也可以向自己规定的边的距离： example2： background-position: right 50px bottom 50px; 我们也可以使用关键词center来居中背景： example3： background-position: center; 如果我们规定一个关键词，另一个关键词则为center： example4： background-position: left; 如果我们将距离值设置为负值，那么背景就会偏离出容器内部，延时到容器的外部（不会显示出来）。 example5: 注意：background还可以拆分为background-position-x与background-position-y，用来分别设置x，y轴的距离。虽然这是一个是实验性属性，不过大部分浏览器都实现了该方法，一般不会出问题 background-repeatbackground-repeat CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。 其参数包含以下，并且每一个单参数都可以改写成双参数（x,y两个方向）的形式： 属性值 含义 双值 repeat 默认值，图像在水平方向和垂直方向都重复以填满容器 repeat repeat repeat-x 图像只在水平方向重复以填满容器 repeat no-repeat repeat-y 图像只在垂直方向重复以填满容器 no-repeat repeat space 图像向两端对齐重复以填满容器，多余空间用空白代替 space space round 图像向两端对齐重复以填满容器，多余空间通过图像拉伸来填充 round round no-repeat 不重复，图像只显示一次 no-repeat no-repeat 注意round与space的区别 round通过图片拉伸将容器内部全部填满： background-repeat: round; space将对应数量的背景填入容器，多余的空间将background-color的颜色填充。 background-repeat: space; 并且我们可以通过双值的方式，分别设置想，x，y上的重复方式 example1： background-repeat: space round; background-attachmentbackground-attachment CSS 属性决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。 属性 解释 fixed 此关键字表示背景相对于window窗口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。 local 此关键字表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。 scroll 此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。 fixed的效果：当fixed时，背景图随着容器位置的改变而改变，也就是说背景图是以window位置为基础的（可以想想象为：背景图已经铺满了window，该容器的位置会截取对应位置的一部分作为其背景图）。 local效果：当local时，背景会随着容器的的滚动而滚动，但是其基准任然是容器（随着容器的位置的改变，背景的位置并没有改变） scroll效果：当scroll时，当我们滚动容器时，背景图不会改变；而且当容器位置改变时，背景图也没有发送改变（相对于容器），也就是说，此时背景是以容器为基准的。 给容器添加滚动条height:300px; width:300px; overflow: scroll; 添加此属性后，无论容器的内容是否超过300px，滚动条都会被添加； 如果设置： height:300px; width:300px; overflow: auto; 那么，如果容器的内容超过300px，滚动条才会被添加。 overflow属性同样是一个复合属性。它是overflow-x,overflow-y两个属性的复合属性。同样的是，overflow可以写两个值： overflow: auto scroll; 设置x轴为自动，y轴为添加滚动条时。 Last背景图这一部分的样式很有意思，特别是渐变那一部分，可以组成很多有趣的图形，不过这一部分内容还是多，需要多看多实践，才能深入掌握！]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>background</tag>
        <tag>background-color</tag>
        <tag>background-image</tag>
        <tag>background-size</tag>
        <tag>background-origin</tag>
        <tag>background-clip</tag>
        <tag>background-position</tag>
        <tag>background-repeat</tag>
        <tag>background-attachment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-边框]]></title>
    <url>%2F2019%2F10%2F19%2FCSS3-%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[引言之所以想到重学CSS3，是因为最近在看《CSS揭秘》一书时，在发现原来CSS3的内容有很多当时没有深入去琢磨，只是简单学习了其基础用法。下面就通过其一些高级用法来深入的研究一下CSS3的内容。 该内容分为： 边框 背景 文本效果 字体 2D、3D转换 过渡 动画 多列、用户界面（盒尺寸、轮廓） 媒体查询 CSS边框border-radiusborder-radius参数解析该属性与padding、margin相同，可以有1、2、3、4个值，所以复习一次： Example1: border-radius:10px; 四个角的弧度相同，均为10px。 Example2: border-radisu:10px 50px; 左上、右下弧度为10px，左下、右上弧度为50px。 Example3: border-radius:10px 50px 100px; 左上弧度10px，右上、左下弧度50px，右下弧度100px。 Example4: border-radius:10px 50px 100px 200px; 左上、右上、右下、左下弧度分别为：10px 50px 100px 200px; 实际上border-radius是一个简写属性，它是下面四个属性的简写： border-top-left-radius border-top-right-radius border-bottom-left-radius border-bottom-right-radius 所以也可以直接单独设置每个角的值。 border-radius参数单位border-radius参数可以为： 绝对值，比如px,em,rem等。 相对值，百分比值（参数为height、width） border-radius参数意义 这个值实际上就是这个圆角的半径值。 如果是百分比值，则通过这个容器的height\width算出对应的值。 border-radius配置一个圆角两侧的不同弧度如上图所说，如果按照普通配置，圆角就是在容器的一角形成一个圆，将其1/4作为其圆角。 实际上我们可以分别配置一个圆角的两侧的弧度。即，将一个椭圆的1/4圆作为容器的圆角。 borde-radius:x1 x2 x3 x4/y1 y2 y3 y4; 等价于: border-top-left-radius: x1 y1; border-top-right-radius: x2 y2; border-bottom-right-radius: x3 y3; border-bottom-left-radius: x4 y4; 当然，/前后的属性可以简写： 一个值： borde-radius:x1/y1; 等价于： border-top-left-radius: x1 y1; border-top-right-radius: x1 y1; border-bottom-right-radius: x1 y1; border-bottom-left-radius: x1 y1; 两个值： borde-radius:x1 x2/y1 y2; 等价于： border-top-left-radius: x1 y1; border-top-right-radius: x2 y2; border-bottom-right-radius: x2 y1; border-bottom-left-radius: x2 y2; /前后的值是配置的是每个角的x半径、y的半径。可以为1，2，3，4个值，原理和上面一样。 border-radius高级应用基础用法-圆角.div{ height: 500px; width: 900px; border: 3px solid red; bakcground-color: brown; border-radius: 20px; } 圆形、椭圆圆形（容器的height、width必须相同，height、width的值即为圆的直径） .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-radius: 50%; } 椭圆（height、width即为该椭圆的x轴、y轴的直径） .box{ margin: 20px; height: 500px; width: 700px; border: 3px solid red; background: brown; border-radius: 50%; } 标签图形 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-bottom-right-radius: 50% 100px; border-bottom-left-radius: 50% 100px; } 烧杯 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-bottom-right-radius: 100px 100px; border-bottom-left-radius: 100px 100px; } 树叶 .box{ margin: 20px; height: 500px; width: 500px; border: 3px solid red; background: brown; border-radius: 0 100% / 0 100%; } border-radius总结 实际上只要是包含圆角的图形我们都可以通过border-radius来构造，通过多个元素的+定位+圆角来构成图形。 box-shadowbox-shadow参数解析 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 基础用法： box-shadow:10px 10px 10x 10px blue; 值得注意的是： box-shadow的值允许有多组值。 example1: box-shadow: 10px 10px 10px 10px blue,20px 20px 20px 20px black; 高级应用-作为边框如果我们将blur值设为0，即不模糊，再将其h-shadow、v-shadow设置为0，即不偏移，即可将其设置边框。 example2: box-shadow: 0 0 0 10px blue； 再利用可以添加多个边框的性质，即可实现多边框。 box-shadow: 0 0 0 10px blue, 0 0 0 20px black; outlineoutline在元素外部绘制一条线。 outline:outline-color,outline-style,outline-width; 值 描述 outline-color 规定边框的颜色。 outline-style 规定边框的样式。 outline-width 规定边框的宽度。 inherit 规定应该从父元素继承 outline 属性的设置。 example: outline: greenyellow 5px solid; outline也是一个简写属性，即为：outline-color、outline-style、outline-width的简写。outline-style的风格繁多。 值 描述 none 默认。定义无轮廓。 dotted 定义点状的轮廓。 dashed 定义虚线轮廓。 solid 定义实线轮廓。 double 定义双线轮廓。双线的宽度等同于 outline-width 的值。 groove 定义 3D 凹槽轮廓。此效果取决于 outline-color 值。 ridge 定义 3D 凸槽轮廓。此效果取决于 outline-color 值。 inset 定义 3D 凹边轮廓。此效果取决于 outline-color 值。 outset 定义 3D 凸边轮廓。此效果取决于 outline-color 值。 inherit 规定应该从父元素继承轮廓样式的设置。 注意，还有一个与outline相关的属性-&gt;outline-offset，该属性可以为负值 利用outline的虚线轮廓与outline-offset可以实现缝线风格的边框。 缝线风格outline:greenyellow 2px dashed; outline-offset: -10px; border-image注意： 在大多数浏览器下，要应用border-image，必须要先设置边框border属性 当border-image存在且其第一个参数border-image-source不为none时，border-style属性将不会生效，若border-image-source为none，则border-style生效 border-image参数 值 描述 border-image-source 用在边框的图片的路径。 border-image-slice 图片边框向内偏移。 border-image-width 图片边框的宽度。 border-image-outset 边框图像区域超出边框的量。 border-image-repeat 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。 example: .box { margin: 200px; height: 500px; width: 500px; border: 100px solid transparent; background: rgb(243, 103, 103); border-image: url(&apos;/bg.png&apos;) 30% 20%/2/1 repeat; } 注意参数的格式： border-image:border-image-source border-image-slice/border-image-width/border-image-outset border-image-repeat 接下来解析一下这几个参数 border-image-source解释：第一个参数，图片地址，这个不用解释。 border-image-slice解释：第二个参数，图片边框向内偏移，即从何处裁剪背景图片。 example: border-image: url(&apos;/bg.png&apos;) 33% 20% 50% 10% repeat; //省略其他参数 该参数的个数与padding,margin相同，四参数则为上右下左的顺序，三参数则为上下、左、右，两参数则为上下、左右、一参数则全相同 border-image-width解释：第三个参数，规定border-image的宽度，被borer-width也会被相应的缩放以适应border-iamge宽度。单位为倍数，2则为被border-image-slice切割后图片的2倍，0.3则为原来的0.3倍。 example: border-image: url(&apos;/bg.png&apos;) 33%/1/0 round;//默认该参数为1 改变参数为2、0.3 border-image: url(&apos;/bg.png&apos;) 33%/2/0 round; border-image: url(&apos;/bg.png&apos;) 33%/0.2/0 round; 注意，这个参数并不会实际改变border-width中定义的宽度，如果该属性增加，则会向容器内部扩展 border-image-outset解释：该属性会将border-image向外偏移一定量。单位任然是倍数，默认为0，即占据border的位置，向外扩展0倍，1代表增加1倍，即直接与容器的border连接。向外扩展1倍。2倍则偏移两倍，则会在容器外部与边框相距边框的距离。 默认值为0： border-image: url(&apos;/bg.png&apos;) 33%/1/0 round; 变为1： border-image: url(&apos;/bg.png&apos;) 33%/1/1 round; 变为2： border-image: url(&apos;/bg.png&apos;) 33%/1/2 round; 变为0.5： border-image: url(&apos;/bg.png&apos;) 33%/1/0.5 round; 注意这里border-image向外偏移了0.5，即占据了border的一半width。 border-image-repeat解释：该属性用于如何分布border-image-slice切割后的部分该如何组合分布在边框上。它含有以下属性： 值 描述 stretch 默认值。拉伸图像来填充区域 repeat 平铺（repeated）图像来填充区域。 round 类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域。 space 类似 repeat 值。如果无法完整平铺所有图像，扩展空间会分布在图像周围 initial 将此属性设置为默认值。 inherit 从父元素中继承该属性。 特别解释一下： tretch只会将剪切过后的图片放置一张在边框位置，然后拉伸以适应边框的长度。 repeat会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽大于border-width，居中后将多余的部分隐藏在两侧。 round会将多个切割后的图片组合放在边框位置，并且组合后的图片长/宽小于border-width，然后会缩放切割图片以适应长（宽）度。 space会将多个切割后的图片组合放到边框位置，并且组合后的图片长/宽小于border-width，多余的部分会空出来，如果有背景色，则用背景色填充。]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>border-radius</tag>
        <tag>box-shadow</tag>
        <tag>border-image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaee之spring框架总结]]></title>
    <url>%2F2019%2F08%2F09%2Fjavaee%E4%B9%8Bspring%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言spring作为目前最流行，应用最广泛的后端框架，它有着许多优点与特色，比如应用它IOC（控制翻转）的功能以及spring内部的封装，可以与hibernate，struts进行整合，这里只是简单的介绍其主要功能。 springIOCIOC内部原理IOC内部使用了映射的原理： &lt;bean id = &quot;userService&quot; class=&quot;cn.itcast.UserService&quot;/&gt; 内部原理如下： //解析dom4j解析xml文件得到class属性值 String classValue = &quot;class属性值&quot;; //使用反射创建类对象 Class clazz = Class.forName(classValue); //创建类对象 UserService service = clazz.newInstance(); return service; Bean实例化类的无参构造方式&lt;bean id=&quot;user&quot; calss=&quot;cn.itcast.ioc.User&quot;&gt;&lt;/bean&gt; 类的静态工厂方法类方法： public class Bean2Factory{ public static Bean2 getBean2(){ return new Bean2(); } } 配置文件： &lt;bean id=&quot;bean2&quot; class=&quot;cn.itcast.bean.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt; 类的实例工厂方法类方法： public class Bean3Factory{ public Bean3 getBean3(){ return new Bean3(); } } 配置文件： &lt;bean id=&quot;bean3Factory&quot; class=&quot;cn.itcast.bean.Bean3Factory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;&gt; 获取实例化对象//加载配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //获取实例 User user = (User) context.getBean(&quot;user&quot;); Bean标签的常用属性 id属性：对这个bean的属性名，获取该bean的实例时所需的名字。 class属性：创建对象所在类的全路径。 name属性：功能与id属性一样，id属性不能包含特殊字符，但是在name属性值里面可以包含特殊字符。 scope属性：单实例与否。 singleton：默认值，单实例 prototype：多实例 属性注入使用构造函数注入bean： public class PropertyDemo1{ pubcli PropertyDemo1(String username){ this.username= username; } } 配置文件： &lt;bean id=&quot;demo&quot; class=&quot;cn.itcast.property.PropertyDemo1&quot;&gt; &lt;construct-arg name=&quot;username&quot; value=&quot;谁谁谁&quot;&gt;&lt;/construct-arg&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); PropertyDemo1 demo = (demo) context.getBean(&quot;demo&quot;); System.out.println(demo.username); 使用set方法注入bean： class setBookname{ private String bookname; public void setBookname(String bookname){ this.bookname = bookname; } } 配置文件： &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.property.Book&quot;&gt; &lt;property name=&quot;bookname&quot; value=&quot;嘿嘿嘿&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); setBookname book = (book) context.getBean(&quot;book&quot;); System.out.println(book.bookname); 注入对象类型属性UserDao： public class UserDao{ public test(){ System.out.print(&quot;test...&quot;); } } UserService： public class UserService{ private UserDao userDao; public void setUserDao(User userDao){ this.userDao = userDao; } } 配置文件： &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt; //id为类中的属性名 //ref值与生成的bean的id值相同 &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 调用： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.userDao.test(); 注入数组，list集合，map集合，properties类型属性&lt;bean id=&quot;person&quot; class=&quot;cn.itcast.property.Person&quot;&gt; &lt;!-- 数组 --&gt; &lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- list --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;小奥&lt;/value&gt; &lt;value&gt;小金&lt;/value&gt; &lt;value&gt;小普&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- map --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aa&quot; value=&quot;lucy&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;bb&quot; value=&quot;mary&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;cc&quot; value=&quot;tom&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- properties --&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverclass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; IOC注解方式 在spring配置文件中引入约束： xmlns:context=”http://www.springframework.org/schema/context&quot; xsi:schemaLocation=” http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; 在配置文件中开启注解扫描 //base-package：需要扫描注解的包 &lt;context:component-scan base-package=”cn.itcast”&gt;&lt;/context:component-scan&gt; 创建注解对象在bean中类的上方加上注解：@Component(value=&quot;...&quot;) bean： @Component(value=&quot;user&quot;) //等价于&lt;bean id=&quot;user&quot; class=&quot;...&quot;&gt; public class User{ public test(){ System.out.println(&quot;got it!&quot;); } } 调用： public class test( ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); user.test(); //got it! } 可以了解的是，spring提供了4个注解关键字来实例化bean，其中后3个是Componnet的衍生： @Component:都可以使用 @Controller: web层 @Service: 业务层 @Repository: 持久层 注解确定单、多实例@Scope(value=&quot;prototype&quot;) //多实例 @Scope(value=&quot;singleton&quot;) //单实例 注解注入属性注入基本类型@Value(value) bean: public class test{ @Value(&quot;谁谁谁&quot;) private String username; @Value(123) private int userid; } 不过我们想向本类中注入值的情况比较少，掌握即可 注入属性对象类型 @Autowired:自动检测属性并注入，前提是这个属性对象已经通过spring创建了对象实例，配置文件方式或注释方法都可以。 Resource(name=”对象名”)，对象名是通过spring创建的实例id值或name值 创建属性实例 @Component(value=”userDao”) class userDao{ } 注入属性的两种方式 @Autowired private UserDao userDao; @Resource(name=&quot;userDao&quot;) Private UserDao userDao; 配置文件与注解混合使用可以在配置文件中声明对象的属性类，然后在对象中通过注解注入属性。 配置文件： &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; &lt;bean id=&quot;bean0&quot; class=&quot;...&quot;&gt; 类： @Resource(name=&quot;bean0&quot;); private Bean0 bean0; @Resource(name=&quot;bean1&quot;); private Bean0 bean1; spring中的AOP名词解释 Joinpoint(连接点)：类里面可以被增强的方法，这些方法被称为连接点。 Ponitcut(切入点)：所谓切入点是指我们要对哪些Joinpoint进行拦截。 Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Aspect(切面): 是切入点和通知（引介）的结合 增强：增强的逻辑，成为增强，包含以下类型： 前置通知：在方法之前执行 后置通知：在方法之后执行 异常通知：在方法出现异常时执行 最终通知：在后置通知之后执行 环绕通知：在方法之前和之后执行配置文件 引入xml命名空间 http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd 使用表达式配置切入点(实际增强的方法) 表达式： execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* cn.itcast.aop.Book.add(…)) execution( cn.itcast.aop.Book.(..)) execution( .*(..)) 匹配..开头的方法 execution( save(..)) AspectJ的aop操作 AspectJ不是spring的一部分，和spring一起使用aop操作。 spring2.0以后新增了对AspectJ的支持。 AspectJ可以用配置文件或注释文件。 配置对象 配置aop操作 aop:config //配置切入点 &lt;aop:pointcut expression=&quot;execution(* cn.itcast.aop.Book.*(..))&quot; id=&quot;pointcut1&quot;&gt; //配置切面，将增强用到切入点上 &lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:aspect&gt; &lt;/aop:config&gt; 值得注意的是： aop:point标签是在配置切入点，即哪些方法需要被增强，其中expression为表达式，id为自定义名称。 aop:aspect标签是在配置切面，即用哪些增强(方法)来增强切入点。 在aop:aspect内部标签表示的是增强的方式。包含以下标签： aop:before 前置通知 aop:after-returning 后置通知 aop:around 环绕通知 aop:after-throwing 异常通知 aop:after 最终通知 AspectJ的注解AOP操作 创建对象 &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt; 在spring核心配置文件中，开启aop操作 aop:aspectj-autoproxyaop:aspectj-autoproxy 在增强类上使用注解完成aop操作 @Aspect public class MyBook{ @Before(value=&quot;execution(* cn.itcast.aop.Book.*(..))&quot;) public void before1(){ System.out.print(&quot;before........&quot;); } } sping的jdbcTemplate操作 设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(“com.mysql.jdbc.Driver”); dataSource.setUrl(“jdbc.mysql:///database0”); dataSource.setUsername(“root”); dataSource.setPassword(“root”); 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); 创建sql语句，并执行jdbcTemplate中的方法 增加 String sql = “insert into user value(?,?)”;int rows = jdbcTemplate.update(sql,”lucy”,”250”); 修改 String sql = “update user set password =? where username=?”;int rows = jdbcTemplate.update(sql,”1234”,”lucy”); 删除 String sql = “delete from user where username=?”;int rows = jdbcTemplate.update(sql,”lucy”); 查询 //返回对象String sql = “select * from user where username=?”;User user jdbcTemplate.queryForObject(sql,new MyRowMapper(),”mary”);System.out.println(user); //实现RowMapperclass MyRowMapper implements RowMapper{ @Override public User mapRow(Result re, int num) throws SQLException{ String username= rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); User user = new User(); user.setUsername(username); user.setPassword(password); }} //返回list String sql = &quot;select * from user&quot;; List&lt;User&gt; list = jdbcTemplate.query(sql,new MyRowMapper()); System.out.println(list); Spring配置c3p0连接池和dao使用jdbcTemplate因为配置jdbcTemplate数据库的数据库信息实际上还是创建对象，注入属性。所以同样可以用Spring的AOP进行对象的创建。 导入c3p0以及配合的jarbao 配置c3p0连接池 dao使用jdbcTemplate 创建service和dao，配置service和dao对象，并把service注入dao对象 &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c3p0.UserService&quot;&gt; &lt;proerpty name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c3p0.UserDao&quot;&gt; 2. 创建jdbcTemplate对象 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate){ this.jdbcTemplate = jdbcTemplate; } 3. 把模板对象注入dao中 &lt;bean id=&quot;userDao&quot; class=&quot;class.itcast.c3p0.UserDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; 4. 在jdbcTemplate对象里注入dataSource private DataSource dataSource; privateSQLExceptionTranslator exceptionTranslator; private boolean lazyInit = true; public void setDataSource(DataSource dataSource){ this.dataSource = dataSource; } &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;bean&gt; spring的事务管理xml方式 在核心配置文件中配置事务管理器 配置事务增强 &lt;tx:advice id=”txadvice” transaction-manager=”transactionManager”&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;account*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; tx:advice 配置切面 aop:config &lt;aop:pointcut expression=&quot;execution(* cn.itcast.service.OrderService.*(..))&quot; id=&quot;pointcut1&quot;&gt; &lt;aop:adviser advice-ref=&quot;txadvice&quot; point=ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; 注解方式 配置事务管理器 开启事务注解 &lt;tx:annotation-driven transaction-manager=”transactionManager”/&gt; 在需要使用事务的方法所在类上面添加注解 @Transactional public class ordersService{ } Last这里的内容多是视频教学笔记中的内容加上我自己的理解，只是不是很深，只是一个最基本的用法，并且省去了配置环境的问题，比如导入jar包等等，这里面可能有很多错误或不足，因为我也是才开始接触。加油加油！]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JavaEE</tag>
        <tag>SSH</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaee之hibernate框架总结]]></title>
    <url>%2F2019%2F08%2F08%2Fjavaee%E4%B9%8Bhibernate%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言Hibernate目前使用的还是比较多，虽然不及mybatis。 Hibernate概述Hibernate工作在javaEE三层结构中的dao层，对数据库进行crud操作，其核心思想是orm（object relational mapping，对象关系映射），并且Hibernate支持多种查询方式，包括HQL，QBC,SQL三种方式。 orm 让实体类和数据库表进行一一对应关系 让实体类首先和数据库表对应 让实体类属性 和 表里面字段对应 不需要直接操作数据库表，而操作表对应实体类对象 配置文件Hibernate的核心配置文件有如下要求： 必须在src下 必须为hibernate.cfg.xml 配置核心文件 引入约束 &lt;!DOCTYPE hibernate-configuration PUBLIC “-//Hibernate/Hibernate Configuration DTD 3.0//EN” “http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; 配置信息 &lt;session-factory&gt; &lt;!-- 第一部分： 配置数据库信息 必须的 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;!-- 第二部分： 配置hibernate信息 可选的--&gt; &lt;!-- 输出底层sql语句 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 输出底层sql语句格式 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- hibernate帮创建表，需要配置之后 update: 如果已经有表，更新，如果没有，创建 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 配置数据库方言 在mysql里面实现分页 关键字 limit，只能使用mysql里面 在oracle数据库，实现分页rownum 让hibernate框架识别不同数据库的自己特有的语句 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 第三部分： 把映射文件放到核心配置文件中 必须的--&gt; &lt;mapping resource=&quot;cn/itcast/entity/User.hbm.xml&quot;/&gt; &lt;/session-factory&gt; 值得注意的是： 配置数据库信息部分与jdbc部分的配置信息一致 hibernate.show_sql： 在编译时控制台输出生成的SQL语句 hibernate.format_sql : 在上面的属性开启的前提之下输出格式化之后的SQL语句 hibernate.hbm2ddl.auto : 配置数据库方言在mysql里面实现分页 关键字 limit，只能使用mysql里面在oracle数据库，实现分页rownum让hibernate框架识别不同数据库的自己特有的语句 配置映射文件映射文件是一个表与实体的配置映射 命名没有确定规则 位置也没有确定位置 引入约束 &lt;!DOCTYPE hibernate-configuration PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN” “http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 配置映射关系 &lt;class name=&quot;priv.mw.dao&quot; table=&quot;t_user&quot;&gt; &lt;id name=&quot;uid&quot; column=&quot;uid&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; column=&quot;username&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/property&gt; &lt;/class&gt; 值得注意的是： hibernate-mapping package:填写包名，如果此处填写了完整的包名，则后面class的name属性只需要填写class名字。否则class的name属性则需要填写完整的名字，及包含包名的类名。 class name：填写类名（全路径或名字） table：数据库中表名。（orm中表与类一一对应） id：每一张表必须要有一个唯一的属性。 name：类中属性的名字 column：为表中列的名字 property:表中的属性 name:类中的属性名 column：表中的列名 值得注意的是： id或property中的column是可选的，如果不填，则默认与name属性相同。 实体类的编写规则 实体类中的属性是私有的 私有属性使用公开的set和get方法 要求实体类有属性作为唯一值(一般使用id值) 实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类，其目的是Integer score = null。可以表示不存在这个值，而基本类不能为null。 主键的生成策略 native：自动增长 uuid：uuid算法 CRUDsession方式 加载核心配置文件 加载SessionFactory对象 使用SessionFactory对象创建session对象 开启事务 开始写具体逻辑，crud操作 提交事务 关闭资源 public test(){ //1. 加载hibernate核心配置文件 //这一步从src中查找hibernate.cfg.xml Configuration cfg = new Configuration(); cfg.configure(); //2. 创建SessionFactory对象 //同时读取映射文件，创建表格 SessionFactory sessionFactory = cfg.buildSessionFactory(); //3. 创建Session对象 Session session = session.openSession(); //4. 开启事物 Transaction tx = session.beginTransaction(); //5. 写入具体的crud操作 User user = new User(); user.setUsername(&quot;李雷&quot;); user.setPassword(&apos;123&apos;); user.setAddress(&quot;日本&quot;); session.save(user); //6. 提交事务 tx.commit(); //7. 关闭资源 session.close(); sessionFactory.close(); } session对象导航查询常用的方法： get():通过OID 从数据库中抓取数据，并把数据加载到一个新实例对象上。 save():执行insert语句，当数据库存在这条记录时，会抛出异常。 saveOrUpdate():如果数据库中不存在该数据，则执行insert语句，如果存在则执行更新操作。 update():当数据库中存在这条记录时，Hibernate 总会执行一条SQLUPDATE 语句；当数据库中不存这条记录时，就会抛出异常。 delete():当数据库中存在这条记录时，Hibernate 总会执行一条SQLDELETE 语句；当数据库中不存这条记录时，就会抛出异常。 load():该方法与get相同，但是不会立即去查询数据库，而是等待需要使用该数据时才去查询。比如用ID查询ID，get方法任然回去查询数据库，而load则直接返回使用的ID，不去查询数据库。 实体对象三种状态 瞬时状态(Transident):如果对象从未与Session对象关联过，称该对象处于瞬时状态（或临时状态）。 持久状态(Persisdent):如果对象与Session对象关联起来，且该对象对应到数据库记录，则称该对象处于持久化状态。比如通过get获取的对象。 游离状态(Detached)：当持久化对象的Session关闭后，这个对象就会从持久化状态改变成游离状态。 HQL方式example： Query query = session.createQuery(&quot;from Customer where name=?&quot;); query.setParameter(&quot;mw&quot;); 条件查询： from Customer c where c.cid=? and c.custName=? 模糊查询 from Customer c where s.custName like ? 排序查询 from Customer order by cid desc 分页查询 Query query = session.createQuery(“from Customer”); query.setFirstResult(0); query.setMaxReaults(3); List list = query.list(); 投影查询:查询不是所有字段值，而是部分字段的值 Query query = session.createQuery(“select cusName from Customer”); List list = query.list(); for(Object object : list){ Systom.out.println(Object); } 聚集函数使用 Query query = session.createQuery(&quot;select count(*) from Customer&quot;); object obj = query.uniqueResult(); Long lobj = (Long)obj; int count = lobj.intValue(); 内连接查询（返回list）：选取两张表的外键相同的数据返回。 Query query = session.createQuery(“from Customer c inner join c.setLinkMan”) 迫切内连接（返回对象） Query query = session.createQuery(&quot;from Customer c inner join fetch c.setLinkMan&quot;) 左外连接（返回list）：返回左侧表中的所有数据以及右侧与之外键相同的的数据。 Query query = session.createQuery(“from Customer c left outer join c.setLinkMan”); 迫切左外连接（返回对象） Query query = session.createQuery(&quot;from Customer c left outer join fetch c.setLinkMan&quot;); 右外连接：返回左右侧表中的所有数据以及左侧与之外键相同的的数据。 Query query = session.createQuery(“from Customer c right outer join s.setLinkMan”); QBC方式调用Criteria的方法实现查询 查询所有 Criteria criteria = session.createCriteria(Customer.class); List list = criteria.list(); 条件查询 Criteria criteria = session.createCriteria(Customer.class); cretera.add(Restrictions.eq(“cid”,1)); critera.add(Restrictions.eq(“custName”,”someone”)); List list = criteria.list(); cretiria.add(Restrictions.like(“custName”,”%s%”)); 排序查询 Criteria criteria = session.createCriteria(Customer.class); cretiria.addOrder(Order.desc(“cid”)); 分页查询 Criteria criteria = session.createCriteria(Customer.class); criteria.setFirstResult(0); criteria.setMaxResult(3); 统计查询 Criteria criteria = session.createCriteria(Customer.class); criteria.setProjection(Projections.rowCount()); Object obj = criteria.uniqueResult(); Long lobj = (Long) obj; int count = lobj.intValue; 离线查询：不通过session对象来创建查询对象，即可以在dao层session对象关闭后也能执行查询。一般用在多条件查询直接在service层进行离线查询。 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class); Criteria criteria = detachedCriteria.getExecutableCriteria(session); List list = criteria.list(); hibernate一对多操作这里的一对多其实就是SQL中一对多的概念，不过我们在学习如何在hibernate中来使用这个概念。 以客户，联系人为例： 创建两个实体类，客户、联系人 让连个实体之间相互表示，即将对方对象作为一个自己的一个私有属性，并设置set,get方法。 在客户实体类里面表示多个联系人 private Set setLinkMan = new HashSet(); public Set getSetLinkMan(){ return setLinkMan;} public void getSetLinkMan(Set setLinkMan){ this.setLinkMan = setLinkMan;} 在联系人实体类里面表示所属客户 private Customer customer; public Customer getCustomer(){ return customer;} public void setCustomer(Customer customer){ this.customer = customer;} 配置客户映射关系 //在客户映射文件中，表示联系人 //使用set标签表示所有联系人 //set中name为联系人中的set集合名称 //column为外键名称 //class中写联系人的实体全路径 配置联系人映射文件 //name：在联系人实体中的客户属性的名字 //class：联系人class的全路径 //column：外键名称 配置核心配置文件 resource：映射文件的路径名称 &lt;mapping resource=&quot;cn/itcast/entuty/Customer.hbm.xml&quot;&gt; &lt;mapping resource=&quot;cn/itcast/entuty/LinkMan.hbm.xml&quot;&gt; 一对多级联保存Customer customer = new Customer(); customer.setCustName(&quot;百度&quot;); customer.setCustLevel(&quot;普通客户&quot;); customer.setCustSource(&quot;网络&quot;); customer.setCustPhone(&quot;110&quot;); customer.setCustMobile(&quot;999&quot;); LinkMan linkman = new LinkMan(); linkman.setLkm_name(&quot;小宏&quot;); linkman.setLkm_gender(&quot;男&quot;); linkman.setLkm_phone(&quot;911&quot;); //2 把联系人放到客户里面 customer.getSetLinkMan().add(linkman); //3 保存客户 session.save(customer); 一对多级联删除删除某个客户，把客户里面所有的联系人删除 需在set中配置cascade属性： &lt;set name=&quot;setLinkMan&quot; cascade=&quot;save-update,delete&quot;&gt; Customer customer = session.get(CUstomer.class,3); session.delete(customer); 一对多级联更新//根据id查询Lucy联系人，客户百度 Customer baidu = session.get(Customer.class,1); //设置持久态对象 Customer lucy = session.get(LinkMan.class,2); //把联系人放入客户对象中 baidu.getSetLinkMan().add(lucy); //把客户放到联系人中 lucy.setCustomer(baidu); 值得注意的是： 在默认转态下，两个对象都会维护这个关系。所以会执行两次SQL语句。为了解决这个问题，可以在set中配置inverse属性，让某一方放弃维护。 inverse: false不放弃维护 true放弃维护 hibernate多对多实际上我们在比较少用多对多关系，会将其转化为两个一对多关系。 以用户和角色为例： 创建实体类，用户和角色 让两个实体类相互表示 一个用户有多个角色，使用set集合 Private Set setRole = new HashSet(); public Set getSetRole(){ return setRole;} public void setSetRole(Set setRole){ this.setRole = setRole;} 一个角色有多个用户，使用set集合 private Set setUser = new HashSet(); public Set getSetUser(){ return setUser;} public void setSetUser(Set setUser){ this.setUser =setUser;} 配置映射关系 在用户里面表示所有角色，使用set标签 在角色中表示所有用户，使用set标签 在核心配置文件中引入映射文件 多对多级联保存任然需要在set中配置cascade &lt;set name=&quot;setRole&quot; table=&quot;user_role&quot; cascade=&quot;save-update,delete&quot;&gt; 实体类中代码： User user1 = new User(); user1.setUser_name(&quot;lucy&quot;); user1.setUser_password(&quot;123&quot;); User user2 = new User(); user2.setUser_name(&quot;mary&quot;); user2.setUser_password(&quot;456&quot;); Role r1 = new Role(); r1.setRole_name(&quot;总经理&quot;); r1.setRole_memo(&quot;总经理&quot;); Role r2 = new Role(); r2.setRole_name(&quot;秘书&quot;); r2.setRole_memo(&quot;秘书&quot;); Role r3 = new Role(); r3.setRole_name(&quot;保安&quot;); r3.setRole_memo(&quot;保安&quot;); //2 建立关系，把角色放到用户里面 // user1 -- r1/r2 user1.getSetRole().add(r1); user1.getSetRole().add(r2); // user2 -- r2/r3 user2.getSetRole().add(r2); user2.getSetRole().add(r3); //3 保存用户 session.save(user1); session.save(user2); 多对多级联删除&lt;set name=&quot;setRole&quot; table=&quot;user_role&quot; cascade=&quot;save-update,delete&quot;&gt; User user = session.get(User.class,1); session.delete(user); 多对多级联更新User lucy = session.get(User.class,1); Role role = session.get(Role.class,1); //为用户添加角色 lucy.getSetRole().add(role); //把用户角色删除 lucy.getSetRole().remove(role); hibernate缓存hibernate为了增加查询效率，建立了缓存机制。即在查询到某个数据后，则将其存储到内存中，下一次查询时直接获取内存中的数据，不用向数据库查询，直接获取，加快查询速度。 hibernate的一级缓存默认打开的 hibernate的一级缓存使用范围，是session范围，3. hibernate的一级缓存中，存储数据必须 持久态数据 hibernate事务与SQL的事务一致，保证一系列工作的全部执行。具有以下特性： 原子性： 确保工作单元中的所有操作都成功完成; 否则，该事务被中止的故障点，操作回滚到操作之前的状态。 一致性：确保数据库正确后成功提交事务更改状态。 隔离性：事务操作彼此独立和透明。 持久性：可确保提交的事务的结果或仍然存在系统故障的情况下的作用。 try { 开启事务 提交事务}catch() { 回滚事务}finally { 关闭} public void testTx() { SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; try { sessionFactory = HibernateUtils.getSessionFactory(); session = sessionFactory.openSession(); //开启事务 tx = session.beginTransaction(); //添加 User user = new User(); user.setUsername(&quot;小马&quot;); user.setPassword(&quot;250&quot;); user.setAddress(&quot;美国&quot;); session.save(user); int i = 10/0; //提交事务 tx.commit(); }catch(Exception e) { e.printStackTrace(); //回滚事务 tx.rollback(); }finally { //关闭操作 session.close(); sessionFactory.close(); } } 通过session.beginTransaction()获取Transaction对象。 最后这个说明只是一个简单的概述，根据黑马程序员2016年版的笔记总结而来，肯定不是全部的，但是这个足够进行简单的操作。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JavaEE</tag>
        <tag>SSH</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaee之struts框架总结]]></title>
    <url>%2F2019%2F08%2F08%2Fjavaee%E4%B9%8Bstruts%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言最近在了解后端开发框架，所以先从SSH（Struts，Spring，Hibernate）开始，因为在企业级开发中SSH任然在使用，所以还是有必要了解一下，后面再详细学习SSM（Spring MVC，Spring，mybatis），目前互联网企业中大多都在使用SSM。 这一期先介绍struts。 strutsstruts介绍struts是一个工作在表示层，负责与JSP页面实现交互，将用户的请求委派给相应的Action处理。 配置过滤器在web-app内添加如下内容： &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 创建action方法一 直接创建Actionpublic class Democlass{ public String execute(){ return &quot;none&quot;; } } 方法二 继承ActionSupport类（最常用）public class Democlass extends ActionSupport{ public String execute(){ return &quot;none&quot;; } } 方法三 实现接口Actionpublic class Democlass implements Action{ public String execute(){ return &quot;none&quot;; } } 配置文件配置文件必须是命名为struts.xml，并且位于src目录下。 引入dtd约束&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; 配置action&lt;package name=&quot;methoddemo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;&quot; class=&quot;cn.itcast.method.BookAction&quot; method=&quot;&quot; &gt; &lt;result name=&quot;ok&quot;&gt;hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 结构为：package-&gt;action-&gt;result package参数： name:（必填）自定义名称 namespace:（可选）命名空间 extends:（可选）该包继承自其它包，一般填struts-default abstract:（可选）该类是否是一个抽象包，抽象包中不能包含Action定义。 action参数： name：（必填）action的标识，在URL访问时后缀为该值。 class：（可选）Action的类的全路径。 method：（可选）指定请求Action时调用的方法，默认为execute方法。 converter：（可选）指定类型转换器的类。 result参数： name：（可选）指定逻辑视图的名称，默认为success。（为指定函数的返回值） type：（可选）指定访问内容的方式，主要有如下方式（默认为dispatcher） dispatcher：页面转发 redirect：页面重定向 chain：action转发 redirectAction：action重定向 global-result如果在action类的方法中，返回了一个字符串，但如果没有配置对应的result，则浏览器会返回404，但是global-result可以匹配任何action中的对应action。 注意：如果action中与global-result同时配置了相同的result。则局部result优先级更高。 &lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; &lt;global-results&gt; action获取表单数据使用ActionContext类获取ActionContext context = ActionContext.getContext(); Map&lt;String,Object&gt; map = context.getParameters(); //使用Map.Entry遍历获取的Map for(Map.Entry&lt;String, Object&gt; entry : map.entrySet()) { System.out.println(entry.getKey()+&quot;--&quot;+Arrays.toString((Object[]) (entry.getValue()))); } 使用SevletActionContext类获取该方法直接获取request对象。 HttpServletRequest request = ServletActionContext.getRequest(); //下面就是调用request了 String para1 = request.getParameter(&apos;para1&apos;); String para2 = request.getParameter(&apos;para2&apos;); String para3 = request.getParameter(&apos;para3&apos;); 使用接口获取requestpublic class Demo implements ServletRequestAware{ @Override public void setServletRequest(HttpServletRequest){ this.request = request; } } 在action中操作域对象struts的域对象与servlet的域对象一样，用于存储数据，在JSP页面中直接获取。 具体用法： request域 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(“key”,”value”); session域 HttpSession session = request.getSession(); session.setAttribute(“key”,”value”); ServletContext域 ServletContext context = ServletAction.getServletContext(); context.setAttribute(“key”,”value”); 属性封装表单提交的数据会自动封装到类实例的属性 一、直接将表单提交的属性封装到action中 在action成员中定义变量 生成变量的set,get方法 private String userName; private String password; private String address; public String getUserName(){ return this.userName; } public String setUserName(String userName){ this.userName = userName; } public String getPassword(){ return this.password; } public String setPassword(String userName){ this.password = password; } public String getAddress(){ return this.address; } public String setAddress(String userName){ this.address = address; } 模型驱动封装(重点) action实现接口ModelDriven 实现接口里面的getModel方法 在action里创建实体类对象 class Demo extends ActionSupport implements ModelDriven{ private User user = new User(); public User getModel(){ return user } } 使用模型驱动封装，一个表单只能封装一个模型驱动封装。 不能同时使用属性封装与模型驱动封装。 表达式封装使用表达式封装是指在表单提交时，name属性则为具体实例的属性（struts有自己的表示方式，比如：User.name） 在action中声明实例类 生成实例类的set与get方法 private User user; public User getUser(){ return user; } public void setUser(User user){ this.user = user } 在表单输入项的name属性里面写表达式形式 username:&lt;\input type=”test” name=”user.userName”&gt; password:&lt;\input type=”password” name=”user.password”&gt; address:&lt;\input type=”text” name=”user.address”&gt; 封装到集合中封装到list集合第一步 在action声明List第二步 生成list变量的set和get方法 private List&lt;User&gt; list; public List&lt;User&gt; getList(){ return list; } public void setList(List&lt;User&gt; list){ this.list = list; } 第三步 在表单输入项中写表达式 username:&lt;input type=&quot;text&quot; name=&quot;list[0].userName&quot;&gt; password:&lt;input type=&quot;password&quot; name=&quot;list[0].password&quot;&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[0].address&quot;&gt; &lt;br/&gt;&lt;br/&gt; username:&lt;input type=&quot;text&quot; name=&quot;list[1].userName&quot;&gt; password:&lt;input type=&quot;password&quot; name=&quot;list[1].password&quot;&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[1].address&quot;&gt; 封装到Map集合第一步 声明map集合第二步 生成get和set方法 private Map&lt;String,User&gt; map; public Map&lt;String,User&gt; getMap(){ return map; } public void setMap(Map&lt;String,User&gt; map){ this.map = map; } username:&lt;input type=&quot;text&quot; name=&quot;map[one].userName&quot;/&gt; password:&lt;input type=&quot;password&quot; name=&quot;map[one].password&quot;/&gt; address:&lt;input type=&quot;text&quot; name=&quot;map[one].address&quot;/&gt; OGNL表达式与EL表达式一样，OGNL表达式可以用来操作值栈。 引用struts标签库//引用标签库 &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt; //操作 &lt;s:property value=&quot;&apos;haha&apos;.length()&quot;&gt; 值栈 在servlet中，我们把数据放到了域对象中，在页面中使用EL表达式获取；域对象同样在一定范围内，存值和取值。 在struts中也提供了一种存储机制，类似与域对象，被称为值栈，也可以存值获取值。 在action中把数据存到值栈中，在页面中获取数据。 servelet和action区别 Servlet：默认在第一次访问创建，创建一次，单实例对象。 Action：访问时创建，每次访问的时候，都会创建一个action对象。所以它是一个多实例对象。 值栈存储在action中。 获取值栈对象ActionContext context = ActionContext.getContext(); ValueStack stack1 = context.getValueStack(); 每一个action只有一个值栈对象。 值栈分为两部分： root：list集合 context：map集合（实际就是action的上下文），包含如下内容： request：HttpRequest对象的引用 session：HttpSession对象引用 application：ServletContext对象的引用 parameters：传递的相关参数 attr：域对象，使用seAttribute(“key”,”value”)存储 可以使用s:debug来查看action的结构 向值栈中存值 使用set方法 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); stack.set(“key”,”value”); 使用push方法 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); stack.push(“something”); 向值栈中存放对象 private User user = new User(); public User getUser(){ return user; } public String excute() throws Exception{ user.setUsername(&quot;lucy&quot;); user.setPassword(&quot;123&quot;); user.setAddress(&quot;美国&quot;); return &quot;success&quot;; } 向值栈中存放list集合 private List list = new ArrayList(); public List getList(){ return list; } public String excute() throws Exception{ User user1 = new User(); user1.setUsername(&quot;lucy&quot;); user1.setPassword(&quot;123&quot;); user1.setAddress(&quot;美国&quot;); User user2 = new User(); user2.setUsername(&quot;tom&quot;); user2.setPassword(&quot;12345&quot;); user2.setAddress(&quot;意大利&quot;); list.add(user1); list.add(user2); return &quot;success&quot;; } 从值栈中取值我们都是用OGNL表达式结合struts标签来获取值栈中的值。 获取字符串&lt;s:property value=&quot;username&quot;/&gt; 获取对象//方法一 &lt;s:property value=&quot;list[0].username&quot;/&gt; &lt;s:property value=&quot;list[0].password&quot;/&gt; &lt;s:property value=&quot;list[0].address&quot;/&gt; &lt;br/&gt; &lt;s:property value=&quot;list[1].username&quot;/&gt; &lt;s:property value=&quot;list[1].password&quot;/&gt; &lt;s:property value=&quot;list[1].address&quot;/&gt; //方法二 &lt;s:iterator value=&quot;list&quot;&gt; &lt;s:property value=&quot;username&quot;/&gt; &lt;s:property value=&quot;password&quot;/&gt; &lt;s:property value=&quot;address&quot;/&gt; &lt;s:iterator&gt; //方法三 &lt;s:iterator value=&quot;list&quot; var = &quot;user&quot;&gt; &lt;s:property value=&quot;#user.username&quot;/&gt; &lt;s:property value=&quot;#user.password&quot;/&gt; &lt;s:property value=&quot;#user.address&quot;/&gt; &lt;s:iterator&gt; 获取set值&lt;s:property value=&quot;key&quot;&gt; 获取push方法&lt;s:property value=&quot;[0].top&quot;&gt; 可以通过debug的方式看出，值栈实际上就是存在context中，作为其属性。 EL表达式可以不去值栈数据EL表达式实际上是增强了getAttribute方法，如果在request中获取到对应的值，则返回该值，否则再到值栈中检索。 OGBL中的#与% # 获取context中的值 &lt;s:property value=”#user.username”/&gt; 获取request中的值 &lt;s:property value=”#request.req”/&gt; % 在struts2标签中表单标签 在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别。 &lt;s:textfield name=&quot;username&quot; value=&quot;%{#request.req}&quot;&gt; struts拦截器struts的拦截器是一种AOP(面向切面编程)思想的实践，通俗的来说就是不改变源代码来实现对原来类或方法的拓展。 而在每次action启动的时，我们都会为每个action方法增加一些拦截器，在action对象创建之后，action方法之前，拦截器的方法得到执行，拦截决定是否放行，然后由下一个拦截器接手继续执行，知道所有拦截器执行完。一旦任何一个拦截器拒绝了，那么后面的拦截也都不会执行了。 拦截器与过滤器 过滤器：理论上可以过滤任意内容，包括html,jsp,servlet… 拦截器：只能拦截action 自定拦截器编写拦截器方法 继承MethodFilterInterceptor并重写其中的doIntercept方法。 public class MyFilter extends MthodsFilterInterceptor{ protected String doIntercept(ActionInvocation invocation)throws { //如果符合条件，则通过执行invocation.invoke()来放行 if(somthongright){ invocation.invoke(); }else{ //否则，不执行invocation.invoke() return &quot;null&quot;; } } } 配置拦截器在package中： 声明拦截器 //class为自定义拦截器的全路径 使用自定义的拦截器在要使用的action内部使用： //name为上面配置的name值 3.还有一点要注意，由于interceptor-ref值默认为执行struts的默认拦截器，我们修改了之后就不会执行默认拦截器了，所以我们还要执行默认拦截器。 &lt;interceptor-ref name=&quot;defultStack&quot;&gt;&lt;/interceptor-ref&gt; 这里的defaultStack是struts在对默认拦截器的一个名称定义，直接引用不能改变。 如果我们需要让某些action不进行拦截，我们可以在使用拦截器时加入属性： &lt;param name=&quot;excludeMthods&quot;&gt;login&lt;/param&gt; struts常用标签库 s:property :使用OGNL表达式获取值栈的值。 s:iterator :使用OGNL迭代获取值栈中的值。 s:iterator :查看值栈的结构和数据。 struts的表单属性，struts对HTML表单属性都有封装，但一般不用，比如&lt;s:input type=”text”&gt; 最后虽然struts目前用的最少，但是最为SSH三大框架之一，了解一下还是有利于以后的工作。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JavaEE</tag>
        <tag>SSH</tag>
        <tag>struts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript深入解析3-类与行为委托]]></title>
    <url>%2F2019%2F07%2F19%2FjavaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%903-%E7%B1%BB%E4%B8%8E%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[JavaScript中“纠结的类”正如前文所说，JavaScript中并没有传统意义上的“类”，可能是因为在JavaScript这门脚本语言诞生之初，并没有人会他会有如今的成就，所以就借用了Self语言的基于原型的面向对象设计。具体可以看JavaScript的诞生 面向对象编程（OOP）面向对象编程是一种编程思想，其重要思维体现在： 封装性：讲一组方法，变量封装在一个“模块”中，一般来说是一个类。 继承性：继承性是面向对象技术中的另外一个重要特点，是指一个类继承另一个类的方法，类的继承。他们的关系通常是父与子的关系。 多态性：是指子类对父类的方法进行重写或重载。 对于传统的OOP语言，比如java，C++。 类意味着复制。 实例化时，他的行为会被复制到实例中；继承时，行为也会被复制到子类中。 JavaScript中的类JavaScript程序员开始大都是由其它语言程序员没经过系统学习这门语言的精髓就开始编程（因为大家认为JavaScript是一门脚本语言，是如此的简单。）所以从开始到现在，程序员们总是试图使用JavaScript来进行面向对象编程，寻找类这个东西的存在。然而不幸的是，JavaScript没有传统的类。还好我们拥有[[prototype]]这个好东西，我们才能进行所谓的面向对象编程。但这任然不是我们传统观念上的面向对象编程，即使是ES6中ECMA提供的class关键字，任然是[[prototype]]的原法糖。 detail在许多JavaScript库中都提供了类的语法糖，我们来看一下其内部是如何实现的。 类function Person(name){ this.name = name; } var tom = new Person(&apos;tom&apos;); var mike = new Person(&apos;mike&apos;); 我们可以直接用new操作符进行“类的实例化”，但是JavaScript中不存在类。所以我们实际上是新创建了一个空对象，然后将其[[prototype]]设为Person.prototype。然后将该函数的this指向新建对象，然后调用该函数，如果函数没有返回对象，就返回新建对象。 继承下面是最典型的一种继承实现方式（JavaScript中多种实现继承的方式，但大同小异）： function Person(name){ this.name = name; Person.prototype.me = function(){console.log(&apos;Person&apos;)}; } function Student(name,id){ //调用父级构造函数，相当于super Person.call(name); this.id = id; Student.prototype.onduty = function(){console.log(&apos;Studnet&apos;)}; } //&quot;继承&quot; Student.prototype = Object.create(Person.prototype); var person0 = new Person(&apos;tom&apos;); var student0 = new Student(&apos;mike&apos;,123); 我们可以看出来，所谓的继承，也就是Student.prototype = Object.create(Person.prototype)这句话，实际上是将父级类Person的[[prototype]]设置为一个空对象，该对象的[[prototype]]指向父级类Person的prototype。首先我们需要了解的是，我们有4个对象(在JavaScript中函数也是对象，可以拥有自己的属性)来储存数据： student0 student0.proto ([[prototype]]) Student Student.prototype 根据原型链的查找规则，我们在获取实例的某个属性时，会分别从：student0 —&gt; student0.proto-&gt;Student-&gt;Student.prototype查找。 看下面的图： 我们可以看到，子类的属性在实例的__proto__中，父类的属性在实例的__proto__的__proto__中，因此我们可以获取子类，父类的所有方法，我们就完成就继承。 ES6的中类上面提过，ES6中的出现了class关键字，下面我们通过ES6的方法重写一下的例子： class Person{ construct(name){ this.name = name; } speak(){ console.log(&quot;name:&quot;+this.name); } } class Student extends Person{ construct(name,id){ super(name); this.id = id; } me(){ console.log(&quot;name:&quot;+this.name); console.log(&quot;id:&quot;+this.id); } } var person0 = new Person(); var student0 = new Student(); 这个看上去漂亮多了，就像是在写传统的OOP的语言。但是实际上，它的背后任然是混乱的[[prototype]]的链。 ES6的class还有一个常用的特点，静态方法。所谓静态方法，就是直接可以在类上面直接调用的方法。 class Person{ construct(name){ this.name = name; } speak(){ console.log(&quot;name:&quot;+this.name); } static sayme(){ console.log(&apos;me&apos;); } } 想一下class背后的原理，用ES5的语法来实现以下static： Person.sayme = function(){console.log(&apos;me&apos;);} 没错，就是这么简单！只是因为这个方法是类自身的方法，并不是方法的[[prototype]]属性值。 混入(mixin)正如我们之前所说，传统的OOP意味着复制。 然而我们JavaScript中模拟的类，并不是传统的复制，而是基于原型链的“伪类”。 所以为了实现很真实的“类”，我们有了混入(mixin)这一概念。 显示混入看下面的例子： function mixin(sourceObj,tragetObj){ for(var key in sourceObj){ if(!(key in targetObj)){ targetObj[key] = sourceObj[key] } } return targetObj; } var Vehicle = { engines: 1, ignition: function(){ console.log(&quot;turn on my engine&quot;) }, drive: function(){ this.ignition(); console.log(&quot;Steering and move forward!&quot;); } }; var Car = mixin(Vehicle,{ wheel: 4, dirive: function(){ Vehicle.drive.call(this); console.log(&quot;Rolling on all&quot;+this.wheels+&quot;wheels!&quot;) } }) 没错，就是一次复制过程。现在我们也可以用： object.assign(targetObj,sourceObj); 因为这个方法的原理就是上面的mixin函数。 隐式混入思考下面代码： var something = { cool: function(){ this.greeting = &quot;hello wowld!&quot;; this.count = this.count ? this.count++ : 1; } } Something.cool(); something.greeting; //hello world something.count; //1 var Another = { cool: function(){ something.cool.call(this); } } Another.cool(); Another.greeting; //&quot;hello world&quot; Another.count; //1 (count不是共享的) 关键在于something.cool.call(this)，将something.cool函数的this指向了Another这个对象。因此，我们把Something的行为“混入”到Another中。 更合理的编程思想：行为委托类与委托的前世今生如我们前面所说，JavaScript本身是不存在类的，只是为了适应程序员们的设计习惯，我们使JavaScript中有了“类”的存在，实际上这种设计方式无疑是把吧苹果涂上橙色，在上面插上孔…然后把它装饰成橘子。但他始终都是苹果，无论我们怎么在外部伪装。既然如此，为什么我们不直接把它当成橘子来吃呢？ 如何使用行为委托看下面的例子： var Task = { setId: fucntion(id){this.id = id;}, outputID: function(){console.log(this.id)} } var someWork = Object.create(Task); someWork.prepareTask = fucntion(id,label){ this.setId(id); this.label = label; } some.outputTaskDetails = function(){ this.outputId(); console.log(this.label); } var someWork0 = Object.create(someWork); 在上面这段代码中，Task，someWork都不是类（或者函数），而是对象。我们把someWork的[[prototype]]委托给了Task。这很符合Self语言的基于原型的面向对象编程的思想。这也被成为“对象关联（OLOO）” 对象关联风格的代码还有一些不同之处。 在代码上，id和label数据成员都是直接存储someWork之上，而不是Task。 在类的思想上，我们鼓励方法的重写（多态）。也就上在子类中定义父类同名的函数。但在委托行为中恰恰相反，我们尽量避免在[[prototype]]链上存在同名函数。 Last不得不说，行为委托从语言底层来说更加适合JavaScript编程，但是越来越多的程序员习惯使用面向对象的编程思想。这迫使JavaScript不得不改变自己，比如在ES6中推出了class的语法糖，但这代表了官方的认可，也许在不久的将来，我们可以看见真正的class出现在JavaScript。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>类</tag>
        <tag>行为委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript深入解析2-原型及原型链]]></title>
    <url>%2F2019%2F07%2F18%2FjavaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%902-%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[关于原型(prototype)原型可以说是JavaScript设计中最特殊，也可以说是最精髓的设计，他遍布整个JavaScript对象。几乎也是整个JavaScript技术的核心，只有熟悉了原型，才能充分理解JavaScript中的类与委托机制了。 whatQ：什么是原型呢？ A：在所有对象中都有一个特殊的[[Prototype]]属性，其实就是对其他对象的引用。几乎所有的对象在创建时[[Prototype]]都会被赋予一个非空的值。(注意，部分浏览器将该属性暴露出来，并命名为 __proto__) Q：什么是原型链呢？ A：如上所说，每一个对象都会有一个[[Prototype]]属性，然而[[Prototype]]属性引用的也是一个对象，这个对象同样也会含有[[Prototype]]属性，这样每一个对象就如同一个链节，一起就组成了一个链，我们称之为原型链。 whyQ：为什么要设计这样一个独特的机制呢？ A：或许不应该对存在这个问题如此深究，因为这可能是第一代开发人员的灵光一现，就有了这个特征。但实际上大都认为这是一门动态编译语言，或者说是脚本语言，所以没有设计类的概念，但为了填补这个概念，就有了原型。但谁也不知道JavaScript会在接下来的几十年中发展的如此蓬勃，程序员们多么希望JavaScript有OOP的概念，于是想方设法的使用原型链来模拟类的行为，但无论如何，就现在为止，JavaScript底层是没有类的概念的，包括ES6的类，任然是原型的语法糖。 how我们了解了什么是原型，为什么会存在原型之后，就要知道我们该如何使用它了。 创建对象我们来看一下创建对象的几种方法。 var obj = {num : 0} var obj = new Object({num : 0}) 或者var obj = Object({num : 0}) var construt = function(){this.num = 0} =&gt; var obj = new construct() var obj0 = {num : 0} =&gt; var obj1 = Object.create(obj0) 这几种方法创建的对象有所不同，我们还是来解析一下： 1,2：字面量方法，创建的是一个普通对象，其[[Prototype]]指向Object(所有原型链的最终节点)。 3：new操作符： 当我们看到new操作符，一定会想到类，但是JavaScript中的new操作符与传统OOP语言中的new完全不同，JavaScript中的new只是将函数当成一个构造函数来调用。如同上一篇中所说，JavaScript中所有的函数都一样，不存在本质的构造函数，只有被new调用的函数就是构造函数。我们在回顾一下new操作符的执行过程： function C(name){ this.name = name; } var obj = new C(&apos;mw&apos;); console.log(obj); //C {name:&apos;mw&apos;} //此时obj的__proto__指向的是C.prototype 创建一个新的对象 将新对象的[[prototype]]设为C.prototype 将新对象设为函数调用的this 如果函数没有返回其他对象，则new操作符调用的函数会自动返回这个新对象 4: 使用Object.creat()函数来创建对象，实际上是创建了一个新对象，然后将其[[Prototype]]设置为对应对象，如果不加参数，则[[Prototype]]为Object对象。 var a = {num : 0}; var b = Object.create(a); console.log(b.__proto__); //{num:0,__proto__:Object} 属性获取，设置与屏蔽当我们有了一个对象，我们可能会对他们做一些操作，比如，[[get]],[[set]],或者seal,freeze等等操作。那么这个过程又是什么样的呢？ 我们提前需要了解的是：每一个对象的每一个属性都是具有属性描述： 数据属性 configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。 enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。 writable：表示能否修改属性值。默认为true。 value： 包含这个属性的数据值，读属性时，从这个位置读；写属性的时候，把新值保存在这个位置。默认为undefined。 访问器属性 configurable：表示该属性能否通过delete操作符删除从而重新定义。默认为true。 enumerable：表示该属性能够通过for-in循环遍历返回属性值。默认为true。 get：读取属性时调用的函数。默认为undefined。 set：写入属性时调用的函数。默认为undefined。 值得注意的是： 官方来说，只能通过Reflect.defineProperty(obj,proName,proValue)，但是Firefox在最开始指定了defineGetter，defineSetter，后期Chrome，Opera，Safari也实现了该方法。 在defineProperty()中get,set不能与writable，value，同时设置。 在ES6中，将Object中的很多方法(包括defineProperty…)都放到了Reflect对象中，虽然Object任然包含该方法，但建议使用Reflect对象。 属性获取与屏蔽思考一下下面的代码： var obj = {num : 0}; var str = obj.toString(); console.log(str); //&quot;[object Object]&quot; 首先我们需要思考的是，我们并没有在obj上定义toString方法，为什么我们能够调用，并且得到一个结果(虽然并不那么漂亮)，我想你肯定猜到了，那是因为obj的原型对象Object拥有这个方法。所以，我们在或得一个对象的值时，是从链的底端开始查找，顺着原型链，一直查到顶端，如果不存在，返回undefined或者error。如果存在，则返回这个值。也就是说，我们能够在一个对象中查找到值，并不代表该对象含有该值，很有可能是该对象的原型链上的某个原型对象含有该值。 思考下面的代码： var a = {getString:function(){return &apos;from a&apos;}}; var b = Object.create(a); b.getString = function(){return &apos;from b&apos;}; console.log(b.getString()); 结果是什么呢？hava a try! 没错，结果是’from b’ 这就是我们所说的属性屏蔽，这一切的根源在于：我们是从链底查到链顶的，所以下层的同名属性会优先被获取，一旦引擎获取到该属性，则遍历结束，不会再向下查找。 属性设置与屏蔽当我们为一个对象的键赋值时，会发生三种情况： eg： var obj = {}; obj.name = &apos;value&apos; 如果在[[Prototype]]链上存在名为name的普通数据访问值，并且被标记为可写(writale:true)(默认即为true)，那就会直接在obj上添加一个名为name的新属性，它就是屏蔽属性。 如果在[[Prototype]]链上存在名为name的普通数据访问值，但是该属性被标记为只读，(writable:false)，那么无法修改已有属性或者在obj上创建屏蔽属性。如果在严格模式下，会抛出一个错误；否则会忽略该语句。总之，不会发生屏蔽。 如果在[[Prototype]]链上存在name并且它是一个setter。那就一定会调用这个setter。name不会被添加到obj上，也不会重新定义setter。 屏蔽的发生也许不像我们通常认为，还要联系对象属性的描述符来确定！我们需要记住。 隐式屏蔽正如类型转换一样，同样存在隐式屏蔽，只要操作对象的属性，都有可能发生隐式屏蔽。 比如： var obj0 = {num:0}; var obj1 = Object.create(obj0); obj1.num++ //这里发生了隐式屏蔽！！！ 只要是[[set]]，都有可能发生隐式屏蔽 修改[[Prototype]] Object.create()，该方法是最适用的方法。即在创建时就设置其prototype。 var obj0 = {num:0}; var obj1 = Object.create(obj0); //将obj0设置为obj1的prototype Object.setPrototypeOf()，该方法是ES6新增的方法。 var obj0 = {num:0}; var obj1 = Object.create(obj0); Object.setPrototypeOf(obj0,obj1); //把obj1设置为obj0的protoype 构造函数方法 var F = function(){this.a = 123}; var obj = {}; obj.prototype = new F(); 回顾一下上面new操作符，就能想明白。 检测原型链我们又该如何检测对象的原型连上存在哪些原型对象呢？ instance操作符 var obj = {}; console.log(obj instance Object); true __proto__属性，如上所说，大多数浏览器实现了__proto__(在ES6中加入了标准)，在兜底情况时，可以使用这种方法检测。 Last理解清楚原型链，我们才能清楚理解后面的委托，“类”等等。所以这一部分是基础。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript深入解析1-this关键字]]></title>
    <url>%2F2019%2F07%2F17%2FjavaScript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%901-this%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[前言花了三天时间粗略看完了《你不知道的JavaScript》下部，这一部分介绍了ES6的部分内容（本书出版时ES7,8）的部分特性还未推出，因为之前已经学过ES6，所以这一遍只是温习和关注细节，感觉除了新增的特征，迭代器应该是最重要的部分，因为ES6的很多特性都用到了迭代器，包括 扩展运算符(spread)‘[…]’，泛数组的迭代(for..of循环，keys(),values(),entries()等等),其次就是Promise，这个特性用的也很多，特别是在异步操作上，配合生成器(function */)，迭代器(iterator),就是async异步函数的底层实现。 关于thisthis关键字作为JavaScript开发者必须理解的概念之一，其实并没有那么高深。 whatQ：什么是this？A：this代表的是函数运行的上下文环境。Detail： 在所有语言中，都有一个调用栈的概念，即函数被哪个对象所调用（注意JavaScript中对象的概念，几乎所有的方法，参数都有一个宿主对象，其中顶层对象在浏览器中window，在node中则为global）。所以我们再执行一个函数或调用一个变量时，默认是带有一个顶层对象前缀的，不过由于我们所有的代码都在该对象中，则可以省略，不信可以试一下： var num = 0; console.log(num); console.log(window.num); 没错，它们的结果都是0。 回归正题，所以粗略的来说，函数被调用的对象即为他的this指向(先不谈硬绑定)，最简单的例子： var obj = { num : 0, func: function(){ console.log(this.num); } } obj.func(); 执行结果是什么呢？没错，是0；因为这里的func函数由obj调用，所以this指向obj。OK,那么再看一下下面这段代码： var num = 0; var obj = { num : 1, func: function(){ console.log(this.num); } } var outterFunc = obj.func; outterFunc(); 执行结果又是什么呢？have a try!可能出乎你的意料，结果是0.So,why?思考一下我们上面的解释。 没错，也许你想通了，因为这时候的func函数并不是通过obj来调用的，所以this默认指向window，但window中num变量为0，所以结果是0. 在这之中，我们需要了解的是：在JavaScript中，函数，对象，数组，或者说所有对象即对象的子类（因为包括函数，数组皆为对象的子类）都是通过地址的形式存储，类似与C语言中的指针形式存储 思考下面代码： var func = function(){console.log(123)} 在JavaScript引擎中时如何运行完这条语句的呢？（你需要了解的是JavaScript不是一门预编译语言，而是一门解释执行的语言（即执行一句，编译一句，当然这是不完全正确的，从变量提升即可以看出来）） 查询是否存在func这个变量—否 声明这个变量 定义函数function(){console.log(123)} 将该函数存储于内存中，并取得其地址 将该地址赋值给func变量 所以func变量实际存储的是该函数的地址。所以函数实际上是没有存储作用域链中的任何信息，它总是一个独立存在的个体。这也就解释了为什么func虽然定义在obj中，但是通过某种方式提取出来后直接调用其this就指向了window。 所以你大概已经明白了了吧，思考一下下面的代码： var num = 0; function inner() { console.log(this.num) } function outter() { var num = 1; inner(); } outter(); 所以，结果是什么呢？ 我猜你肯定答对了，是0； 同样的道理，inner函数虽然在outter函数中被调用，但任然是直接调用，没有任何前缀对象，所以其this指向任然是window。 最后一个例子： var name = &quot;clever coder&quot;; var person = { name : &quot;foocoder&quot;, hello : function(sth){ var that = this; var sayhello = function(sth) { console.log(that.name + &quot; says &quot; + sth); }; sayhello(sth); } } person.hello(&quot;hello world&quot;);//foocoder says hello world 这里内层函数this指向的任然是window，有人认为是JavaScript的设计错误，但是从上面内存的角度去分析，会发现这是正确的。 why &amp; where说了这么多this，那么为什么要用this呢？又在哪里用呢？ Q：why？ A：this的使用使调用上下文对象变得更加简洁，否则，每次调用函数必须传递上下文对象，编码将及其复杂。 Q：where？ A：相信接触过OOP（面向对象编程）的同学应该熟悉这个结构(伪代码)： Class Example{ constructor(name,age) { this.name = name; this.age = age; } } declare instan = new Example(&apos;tom&apos;,23); 没错，这是一个基本类的构造，只包括了一个constructor构造器方法，其中的this指向的即是这个被实例化的对象(instan),则instan的name属性为’tom’，age属性为23。试想没有this的话，构造器该如何为实例属性赋值呢？只有显式的将instan传递给constructor函数，这将变得无比繁杂。 在js中，不仅是在类，即使是用行为委托方式编码，任然离不开this，因为总是存在对上下文对象的应用。 值得注意的是：JavaScript语言基础中并没有class的概念，即使ES6推出了class关键字，但它任然是使用原型链对类的模拟，任然是ES5部分框架class实现的语法糖 how说了那么多，还是要详细讲一下this的绑定问题： 默认绑定 独立函数调用执行默认绑定。 var a = 0; function func() { console.log(&apos;a:&apos;this.a); } func(); //a:0 如上面我们所说，这里的func是直接的函数调用，所以执行默认绑定，this指向了window对象。 值得注意的是：在strict模式下，默认绑定this为undefined var a = 0; function func() { &quot;use strict&quot; console.log(&apos;a:&apos;+this.a); } func(); //Uncaught TypeError: Cannot read property &apos;a&apos; of undefined 隐式绑定 这就是我们之前熟悉的用对象来调用函数： var obj = { num : 0, func: function(){ console.log(&apos;num:&apos;+this.num); } } obj.func(); //num:0 当含有多层对象引用的时候，只有距函数最近的一个对象为上下文对象 var obj0 = { num : 0, func: function(){ console.log(&apos;num:&apos;+this.num); } } var obj1 = { num:1, obj0:obj0 } obj1.obj0.func() //num:0 正如我们之前所说的，函数的存储与上下文对象毫无关系，所以，当我们将对象中的函数通过某种方法提取出来时，它就与原来的对象毫无关系了，其this指向则为window了（这种现象一般被称为隐式丢失）。具体可以看上面那个例子。 显示绑定 所谓显示绑定，即通过call(),apply(),以及ES6的bind()函数直接指定this的指向。 var a = 0; var obj = { a: 1 } function func() { console.log(this.a); } func.call(obj); //1 值得注意的是：call(),apply()函数的绑定是软绑定，即只在绑定这一次起作用，下一次调用时this任然执行原有绑定规则。 所以就衍生出了硬绑定，ES6之前需要手动封装硬绑定方法： function bind(fn,obj) { return function(){ return fn.apply(obj,arguments) } } //执行此方法后，函数的this指向将被永久绑定在指定对象上，无法修改。 由于这个方法需求太广泛了，所以ES6推出了官方的bind()方法，直接调用即可。 new绑定 与其他语言中构造函数的特殊性不同，在JavaScript中，构造函数是一个普通的函数，唯一的特殊点是它在执行new操作符后自动调用，并且开始执行一系列操作： 创建一个新的对象 这个新对象会被执行[[prototype]]连接(会在实例与Object原型之间在建立一层Prototype)。 这个对象将会被绑定到对应的函数的this。 如果函数没有返回其他对象，那么new表达式中函数调用会自动返回这个新对象。 第四步解释： function Fun() { reuturn { b:2 } } var instan = new Foo() //{b:2} 优先级 如果是new绑定，则this按上面的规则绑定对象。 如果是显示绑定，则this指向显示绑定的对象。 如果有隐式绑定，则this绑定在调用对象上。 否则执行默认绑定，非严格模式下为window，严格模式下位undefined。 箭头函数 =&gt;在ES6中，新加了一种声明函数的方式，箭头函数(=&gt;) ()=&gt;{} 等价于 function(){} 关于箭头函数的特性就不具体细讲，他与this相关的就是：箭头函数的this决定于外层作用域来决定： //arrayFunc var a = 0; //定义全局变量a function fun() { return (arrayFunc = ()=&gt;{ console.log(this.a); })()//这是一个立即执行函数，也可以在外围多调用一次 } var obj = { a : 1, func: fun() } fun.call(obj);//将fun的this指向obj //1 由于fun的this指向obj，而箭头函数的this根据外围函数的this决定，所以arrayFunc的this也指向obj，则a为1。 //normal var a = 0; function fun() { return (function normalFunc(){ console.log(this.a); })() } var obj = { a : 1, func: fun() } fun.call(obj); //0 这里普通函数的this根据调用的对象来确定，由于它是单独调用的，所以this指向window，则a为0。 Lastthis的用法相当重要，不管是自己原生开发，或是用框架，特别是使用框架时，由于一般框架会有一个App实例，我们的操作都在这个实例之中进行，所以会无数次用到this，所以我们必须学通。下一期写一下Protype原型链，也是JavaScript中相当重要的一个内容。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>this关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pomise理解]]></title>
    <url>%2F2019%2F06%2F28%2FPomise%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[唠唠叨叨最近考试比较多，终于快结束了，间隙时间，我第一遍看了《你不知道的JavaScript》的上中篇，说实话，可能是因为译本的原因，也可能是知识比较深入，我感觉比较难理解，有时感觉一小节讲完，发现他的中心观点只有一句话。但总的来说，这是套值得深入研读的书籍，暑假我将再次研读。 Promise的神秘面纱ES6的知识点着实比较庞大，除了对Number，Array等的扩展。Promise这个新的概念也很吸引人。比如著名的axios就是采用Promise来封装的。 我在《你不知道的JavaScript》中看到一个比较形象的比喻，当你去买一个汉堡包，你先把钱给服务员，然后服务员会给你一个凭证，在这个汉堡包被完成之前，凭证即代表了你的汉堡包。一段时间过后，服务员通知你结果。但这是服务员可能会对你说：‘Sorry Sir,hamburger has sold out…’这种失败的结果即为Promise中的reject。但大多数情况下，我们期望并得到的结果是一个汉堡包 （ solved）。 也就是说：Promise是一个容器，里面保存着未来才会结束的事件（通常是一个一步操作）的结果。 Promise的特点 Promise的状态不收外界的影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise的基本用法 //定义promise var promise = new Promise(function(resolve,reject) { var res = asycFunc(); if(res.code 满足条件){ resolved(res.data); }else{ reject(res.data) } }) //调用promise //1(不推荐). promise.then(res =&gt; {show(res)},err=&gt;(handleError(err))) //2(推荐). promise.then(res =&gt; {show(res)}).catch(err =&gt; {handleError(err)}) 第二种的好处在于，1.采用链式的写法可以捕获前一个then抛出的错误，而一then中同时写resolve与reject无法做到。2.在语法上更人性化，类似于try…catch…语法。但实际catch = then(null,rejection).都是捕获产生的错误，包括rejected，Error；对于错误，还有一点值得注意的是，reject或者resolve即代表这个promise状态的冻结。类似于函数的return，这两个语句一旦发生，其后面所有的语句都将无效。即使是抛出错误，也无法再被catch所捕获。 Promise的链式玩法 前面的then…catch…其实已经是链式的写法了。 Promise有3个函数可以链式调用。分别是 then(func(reslved,rejected){…}): 为Promise实例添加状态改变时的回调函数。 catch(func(err){…}): 用于指定发生错误时的回调函数。包括rejected也被他处理。 finally(func(){…}): 无论状态如何，是否抛出错误。都将执行该回调。 但其能够一直链式调用的原因是：这3个函数每次调用都会产生一个新的Promise对象，并且这个新的promise会将旧的promise返回值作为参数，这个对象又包含了这3个方法，所以可以一直链式调用。 Promise的高级玩法（模式） Promise.all([p1,p2,…]) 说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为： a. 所有的Promise的值变为resolved时，该对象才返回resolved，并返回所有的结果。b. 一旦有一个Promise对象返回rejected，则整个对象返回rejected，并返回错误原因。 由Promise封装的axios中，有axios.all([re1,re2,…])方法 Promise.race([p1,p2,…]) 说明：该方法用于将多个Promise实例包装成一个Promise实例。返回值判定方法为： a. 当第一个Promise返回resolved时，整个Promise状态变为resolved，并返回第一个Promise resolved的结果，一旦有任何一个Promise决议为拒绝，他就会拒绝。 值得注意的 Promise.all在传入空数组时，会立即返回resolved；但Promise.race会被一直挂起。所以不要想Promise.race中传递空数组。希望ECMA会尽快修改这一点。 一些骚操作 在《你不知道JavaScript》一书中，提出来一些ES6标准之外的Promise模式之外的一些扩展模式，比如： Promise.none([…]):与Promise.all的情况互换，即所有的Promise都rejected才rejected。反之则返回resolved。 Promise.any([…]):与race相对，该模式忽略rejected，得到第一个resolved。 Promise.first([…]):这个模式类似与any([…])的竞争，，即只要第一个Promise完成，他就会忽略有序的任何拒绝和完成。 Promise.last([…]):这个类似与first([…]，但确实最后一个完成胜出。 示例：Promise.first([…])的实现 //polyfill安全的guard检查 if(!Promise.first){ Promise.first = function(prs){ //返回最终的Promise对象 return new Promise(function(resolve,reject){ //把所有的Promise循环一次 prs.forEach(function(pr){ //把值规整化，并且不管哪个先完成，就决议组Promise Promise.resolve(pr).then(resolve); }) }) } } Promise的实际应用 异步加载图片 const preloadImage = function (path) { return new Promise(function (resolve, reject) { var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); }; 异步Ajax const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); client.send(); }); return promise; }; getJSON(“/posts.json”).then(function(json) { console.log(‘Contents: ‘ + json); }, function(error) { console.error(‘出错了’, error); }); 最后Promise着实避免了回调函数的一些缺陷，并且它的使用也越来越广泛，包括后面的async异步函数，也是利用Promise来完成的，因此，这里简单的了解一下Promise还是很有必要的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记兼第一个开源项目]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%9D%82%E8%AE%B0%E5%85%BC%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[碎碎念最近过完了第一遍《JavaScript高级程序设计》，有两个感觉 JavaScript体系还是很巨大，值得深入挖掘 这本书太过老旧，我看了一下第一版是在2012年发行，最近一次修订是在2019年，但这一次修订并没有大范围修改书中的内容，仅仅添加了部分ES6的内容，并且ES6还是不是正式版，其中的ArrayType在正式版ES6中并没有实现。 虽然如此，总体来说这本书还是非常有价值的，深入的讲解了JavaScript，包括组成部分，ECMAScript+BOM+DOM,HTMLDOM与XML的关系这些以前比较少了解的东西，还有原型链，作用域，实现继承等老生常谈的东西。感觉这本书还是要多刷几次，暑假回家配合《你不知道的JavaScript》二刷，去研究更细微的东西。 第一个开源项目：PageWindow一直在学习，做工程项目，想想也该是时候做一点开源项目，让明年面试更有利一点~ 这个项目使我一直想做的，其实很简单，就是实现页面上模拟windows窗口，好像目前是有这种东西，但我是想将其封装成一个UI库。进而实现伪多任务。 这里主要就是涉及DOM操作。包括鼠标操作比较多： mousedown mouseup mousemove click 第一个demo遇到就是阻止冒泡与阻止默认事件 阻止冒泡 e.stopPropagation() 标准W3C方法 e.cancelBubble = true IE专用，但chrome，firefox也实现了属性 阻止默认事件 e.preventDefault() 标准W3C e.returnValue = false IE专用，但chrome，firefox也实现了属性]]></content>
      <categories>
        <category>pageWindow</category>
      </categories>
      <tags>
        <tag>pageWindow</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目实际问题一:对象深浅拷贝问题]]></title>
    <url>%2F2019%2F05%2F18%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E4%B8%80-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一次经手比较大型的项目，总结第一个问题：对象的深拷贝问题。之前没注意这个问题，写完代码发现总是与自己的想法不符合，经调试才发现是对象的深浅拷贝问题。 原理的话也很简单，对象作为基本类型之外的引用类型，在栈内存中保存着引用变量的名字，而这个变量保存的实际是一个地址，这个地址指向堆内存，实际这个变量的值是保存在堆内存中。 所以当我们直接用 “=” 进行变量copy时，实际copy的是对内存中的地址。copy之后改变原变量的值同样会使新变量的值进行改变。所以有时候我们需要进行深拷贝来在堆内存中开辟一个新的内存空间来放置副本，切断新旧变量之间的联系。 方法对象的深拷贝适用于所有类型的对象（含数组） JSON.parse(JSON.stringfy(Object)) Point:这是最简单的进行深拷贝的方法，其原理是先将其转换为JSON字符串，此时就不在存在原变量的堆地址，而是以字符串-基本变量保存在栈地址中。再将其转换回对象，则是一个完全与原变量无关的新变量。但是该方法会丢失对象所有的函数属性，undefined，以及会重置原型对象为Object(),或Array(),如果没修改多原型对象，则没有影响。 递归遍历对象 function deepClone(obj){ if(typeof obj == &apos;object&apos;){ let newObject = {}; let keys = Object.keys(obj); let values = Object.values(obj); for(value of values){ if(typeof value == &apos;object&apos;){ value = arguments.callee(value) } } for(let i = 0; i&lt; keys.length ;i++){ newObject[keys[i]] = values[i]; } return newObject; } } 使用lodash库中的cloneDeep()函数，其原理与上述原理一样，但健壮性更高。 适用于简单对象 Object.assign() eg: const obj = { a: 1 }; const copy = Object.assign({}, obj); console.log(copy); // { a: 1 } Point:该方法只适用于由基本数据类型组成的对象，不能用于对象键或值包含引用类型，否则任然是浅拷贝。同时，该函数会忽略undefined与null值（可以用来过滤无效值） 使用于简单数组 Array.slice(startPositong,endPositon) Array.contact(arr1,arr2) array.splice(startPositon,delteteNum,addArr1,addArr2…) 数组的迭代方法：Array.every(),Array.filter(),Array.map() Point:使用以上方法，必须是由基本数据类型组成的数组，数组项不能包含引用类型，否则任然是浅拷贝！！！ Final以上方法都只会转化可枚举项，对于不可枚举项，都是默认忽略的。 综上，JSON.parse(JSON.stringfy(obj))应该算是最简单且最易用的方法了，并且原生代码的效率相较于JS也会有优势，所以，如果仅仅为了深拷贝，没有其他需求，该方法是比较好的方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目部署引发的知识]]></title>
    <url>%2F2019%2F04%2F09%2F%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%BC%95%E5%8F%91%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[项目部署之前一直在写东西，都没怎么部署过项目，特别是Linux系统下，本来之前买服务器是想买一个Linux的服务器的，然而，学生党只配用Windows，万恶的阿里云。现在又可以买Linux的了，然而我又不想重新布属我的项目。今天再部署Linux时，才发现完全不会。枯了~ git命令开发最常用命令 git status //查看项目状态 git add . //把所有修改文件推送到stage中 git commit -m des(描述) git push //推送到默认分支 git push origin master(本地分支名) : master(远程仓库名) 常用命令 git config –global user.name “Tocy” //配置用户名 git config –global user.email zyvj@qq.com //配置邮箱 git clone 仓库地址 //将远程仓库拉至本地 git add 文件名 //将某一文件提交至stage git diff //查看当前目录的所有修改 git remote add [short_name] [url] //添加远程仓库 git branch //列出所有分支 -* 本地 -r 远程 -a 本地与远程 git branch [branch-name] //新建一个分支 git checkout -b [branch-name] //新建并切换到该分支 git branch -d [branch-name] //删除该分支 git checkout [file] //恢复暂存区的指定文件到工作区 git checkout . //恢复暂存区的所有文件到工作区 Linux安装node.js 到根目录 cd ~ 建一个文件夹 mkdir deploy 下载node包 wget https://nodejs.org/dist/v10.11.0/node-v10.11.0-linux-x64.tar.xz 解压node包 tar zf node-v10.11.0-linux-x64.tar.xz 重命名包 cd node-v10.11.0-linux-x64.tar.xz/bin &amp;&amp; ls 查看node,npm的版本 ./node -v ./npm -v 设置环境变量 vim ~/.bash_profile 在文件尾部添加以下内容 export NODE_HOME=/deploy/node-v8.11.3-linux-x64 export PATH=$PATH:$NODE_HOME/bin 退出vim: 按 esc 输入:wq enter 退出 保存profile文件 source /etc/profile 将目录软链接到全局环境下（命令后面的/usr/local/bin/node是固定的） ln -s /deploy/node-v8.11.3-linux-x64/bin/node /usr/local/bin/node ln -s /deploy/node-v8.11.3-linux-x64/bin/npm /usr/local/bin/npm 检验安装是否成功 node -vnpm -v 安装Nginx 安装yum npm install yum 安装依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 下载Nginx //创建一个文件夹 cd /usr/local mkdir nginx cd nginx //下载tar包 wget http://nginx.org/download/nginx-1.13.7.tar.gz tar -xvf nginx-1.13.7.tar.g 安装Nginx //进入nginx目录 cd /usr/local/nginx //执行命令 ./configure //执行make命令 make //执行make install命令 make install Nginx常用命令 //测试配置文件 安装路径下的/nginx/sbin/nginx -t //启动命令 安装路径下的/nginx/sbin/nginx //停止命令 安装路径下的/nginx/sbin/nginx -s stop 或者 : nginx -s quit //重启命令 安装路径下的/nginx/sbin/nginx -s reload //查看进程命令 ps -ef | grep nginx Nginx虚拟域名配置及测试验证 //编辑nginx.conf sudo vim /usr/local/nginx/conf/nginx.conf //增加行 include vhost/*.conf //保存退出 ：wq enter //在/usr/local/nginx/conf目录新建vhost文件夹 mkdir vhost //创建每个域名的配置 sudo vim jimisun.com.conf //节点中增加入响应的配置 端口转发 或者访问文件系统 Nginx启动 //进入nginx安装目录 cd sbin sudo ./nginx 测试访问 http://ip地址]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>git</tag>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-review-router]]></title>
    <url>%2F2019%2F03%2F20%2FVue-review-router%2F</url>
    <content type="text"><![CDATA[最基本的一个路由展示域 在Vue控制域中写入router规定的标签 Go to Login //该项为路由的链接，默认为a标签 Go to Register//该项为路由的链接，默认为a标签 //该项为渲染路由组件的位置 以下步骤一般不能交换，因为存在相互依赖关系 创建组件模板 const login = {template:&apos;&lt;h1\&gt;这是一个登录框&lt;/h1\&gt;&apos;}; const register = {template:&apos;&lt;h1\&gt;这是一个注册框&lt;/h1\&gt;&apos;}; 创建一个routes对象作为VueRouter的参数 const routes = [ {path:&apos;/login&apos;,component:login}, {path:&apos;/register&apos;,component:register} ] 创建一个VueRouter实例，并将上面的routes作为参数，值得注意的是，这里的参数名字是routes，下面是使用ES6的写法简写对象名 const router = new VueRouter({ routes }) 创建Vue实例，值得注意的是，这之中的路由参数为router，下面是使用ES6的写法简写对象名 const vm = new Vue({ el:&apos;#app&apos;, router }) 路由重定向需要添加的是,在创建routes对象时 //创建一个routes对象 const routes = [ //这里是重要点，给需要添加默认路由的加路由加上redirect属性，其值为要转向的路由地址 {path:&apos;/&apos;,redirect:&quot;/login&quot;}, {path:&apos;/login&apos;,component:login}, {path:&apos;/register&apos;,component:register} ] 子路由的使用JavaScript： &lt;script&gt; //创建模板 const teacher = {template:&quot;#teacher&quot;}; const student = {template:&quot;#student&quot;} const teacherName = {template:&quot;&lt;h1&gt;这是老师的名字&lt;/h1&gt;&quot;} const studentName = {template:&quot;&lt;h1&gt;这是学生的名字&lt;/h1&gt;&quot;} const teacherId = {template:&quot;&lt;h1&gt;这是老师的序号&lt;/h1&gt;&quot;} const studentId = {template:&quot;&lt;h1&gt;这是学生的序号&lt;/h1&gt;&quot;} //创建父级routes对象 routes = [ { path:&apos;/student&apos;, component:student, //注意这里子路由的申明的方式 children:[ {path:&apos;name&apos;,component:studentName}, {path:&apos;id&apos;,component:studentId} ] }, { path:&apos;/teacher&apos;, component:teacher, children:[ {path:&apos;name&apos;,component:teacherName}, {path:&apos;id&apos;,component:teacherId} ] } ] //创建VueRouter实例 const router = new VueRouter({ routes }) //创建Vue实例 const vm = new Vue({ el:&quot;#app&quot;, router }) &lt;/script&gt; body &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/student&quot;&gt;student&lt;/router-link&gt; &lt;router-link to=&quot;/teacher&quot;&gt;teacher&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; //注意这里在模板中申明子路由的link和view &lt;template id=&quot;teacher&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/teacher/name&quot;&gt;这是老师的名字 &lt;/router-link&gt; &lt;router-link to=&quot;/teacher/id&quot;&gt;这是老师的id&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; //注意这里在模板中申明子路由的link和view &lt;template id=&quot;student&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/student/name&quot;&gt;这是学生的名字 &lt;/router-link&gt; &lt;router-link to=&quot;/student/id&quot;&gt;这是学生的id&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 带名视图body &lt;div id=&quot;app&quot;&gt; //注意下面的router-view中都是带有name属性的 &lt;h1&gt;这里是默认视图&lt;/h1&gt; &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;h1&gt;这里只显示学生的视图&lt;/h1&gt; &lt;router-view name=&quot;stu&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;h1&gt;这里只显示老师的视图&lt;/h1&gt; &lt;router-view name=&quot;tea&quot; class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=&quot;default&quot;&gt; &lt;div&gt; &lt;h1&gt;这是默认的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;stu&quot;&gt; &lt;div&gt; &lt;h1&gt;这是学生的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;tea&quot;&gt; &lt;div&gt; &lt;h1&gt;这是老师的展示页面&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; js部分 //创建模板 const defaultView = {template:&quot;#default&quot;}; const stuView = {template:&quot;#stu&quot;}; const teaView = {template:&quot;#tea&quot;}; //创建路由参数,这里是关键，component的value可以是一个对象，该对象的键值就是视图的名字和模板对应的名字 const routes = [ { path:&quot;/&quot;, components:{ default:defaultView, stu:stuView, tea:teaView } } ] //创建路由实例 const router = new VueRouter({ routes }) //创建Vue实例 const vm = new Vue({ el:&quot;#app&quot;, router })]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>VueRouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中ES6代码的压缩问题]]></title>
    <url>%2F2019%2F03%2F16%2Fwebpack%E4%B8%ADES6%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题webpack中ES6代码压缩问题： 在使用webpack插件uglifyjs-webpack-plugin压缩JS代码时，发现该插件只能压缩ES5-的代码，遇到ES6，就会报错ERROR in xxx.js from UglifyJs,遂查找解决办法。 原理解决办法原理如上所说，uglifyjs-webpack-plugin该插件仅支持ES5-的JS代码。 解决办法1. 不使用ES6语法这个办法理论上可行，但是面对ES6那么多方便快捷的语法，不使用的话会大大降低开发的进度，所以一般不使用该方法。 2. 使用babel-loader将ES6转化为ES5代码该方法是网上流行最广的解决办法，具体是： 安装es2015插件 npm install --save babel-preset-es2015 安装babel-loader npm install babel-loader 也许是我环境的问题，网上的教程上都没这一步，但是，如果不安装babel-loader，就会报错ERROR in Entry module not found: Error: Can&#39;t resolve &#39;babel-loader&#39; in........., 这一步需要注意的是： babel-loader必须与babel-core版本相同，否则会报错Error: Cannot find module &#39;@babel/core&#39;,这一点需要自己到package.json中查看babel-loader,与babel-core的版本来确定。（比如，babel-core版本是：6.23.3那么你装的babel-loader必须是7.1.5以下的版本，否则loader就与core不匹配了，注意如果直接npm install babel-loader，默认是安装8.0.0的，所以不兼容） 配置webpack.congfig.js 在rules里加入对js代码的过滤 { test: /\.js$/, loader: &apos;babel-loader&apos;, options:{ presets:[&quot;es2015&quot;] }, exclude:[/node_modules/] } 建.babelrc文件 在项目根目录新建一个文件名为.babelrc的文件，填入以下内容： { &quot;presets&quot;: [&quot;es2015&quot;] } 这是网上流传最广的办法，不过步骤繁琐，麻烦，下面介绍最优解决方案 3.使用uglifyes-webpack-plugin插件其实上面的坑都是我一个一个经历的，网上的解决办法都是不完整，当我踩完所有坑，感觉这个方法太繁琐了。然后我就准备去深入了解一下uglifyjs-webpack-plugin这个插件，结果无意间发现uglify有一个专门针对ES6的插件uglifyes-webpack-plugin，哇，一试就知道有多爽，完全没有那么多步骤： 安装： npm install uglifyes-webpack-plugin webpack.config.js： const UglifyEsPlugin = require(&quot;uglifyes-webpack-plugin&quot;); plugins:[ new MiniCssExtractPlugin({ //css压缩 filename:&apos;[name][hash].css&apos;, chunkFilename:&apos;[id].[hash].css&apos; }) ], optimization:{ minimizer :[ new UglifyEsPlugin({}), //直接引用 new OptimizeCSSAssetsPligin({}) //css压缩 ] 其实就一句话：new UglifyEsPlugin({}),,与uglifyjs-webpack-plugin的使用一样简单。 需要注意的是uglifyes-webpack-plugin与uglify-es-webpack-plugin并不是同一个插件，前者是官方的，也就是与uglifyjs-webpack-plugin一个维护者的，而后者已被弃用并不再维护 Point 该插件默认就会将ES6代码改成ES5代码，并且有压缩，混淆等功能，与uglifyjs-webpack-plugin基本一致，下面是他的一些重要的API： test:匹配的文件，默认/.js($|?)/i，接受正则表达式 mangle:是否混淆代码，默认为true sourceMap：是否启用SourceMap,默认为false compress: 自定义压缩选项，内容是一个对象，默认{}，该选项下的子选项很重要，提一下 sequences：是否使用逗号运算符来连接连续的表达式，默认true properties：是否优化属性读取方式：a[“foo”] → a.foo，默认true dead_code：是否丢弃不可达代码，默认true drop_debugger：是否丢弃调试语句，默认true unsafe：是否优化危险代码，默认false conditionals：是否优化 if-else 条件语句，默认true comparisons：是否优化比较代码，默认true evaluate：是否直接计算常量的值，默认true booleans：优化布尔表达式，默认true loops：是否优化循环代码，默认true unused：是否丢弃不使用的变量，函数，默认true。这里需要注意，如果你的函数本来就是一个DOM触发事件函数，请关闭此选项，否则，该函数将会被丢弃！！！ hoist_funs：是否提升函数的申明，默认true hoist_vars：是否提升变量的申明，默认false if_return：是否优化优化if/return 和 if/continue join_vars：是否将加入变量申明，默认true cascade：优化连续语句，将 x, x 转成 x，x = something(), x 转成 x = something()——声明变量，默认true side_effects：丢弃副作用声明，默认true warnings：警告潜在的危险优化/代码，默认true global_defs：定义全局变量，默认{} extractComments：是否要删除注释，默认false，接受boolean，正则，函数，对象。 include： 要转化的文件，默认无，接受字符串，正则 exclude：在test验证通过后不转化的文件，默认空，接受字符串，正则 相较于uglifyjs-webpack-plugin，uglify-es-webpack-plugin功能要相对少一些，但基本也能满足要求 附uglifyjs-webpack-plugin常用API： test：测试匹配的文件，接受String|RegExp|Array&lt;String|RegExp&gt;,默认/.js(?.*)?$/i cache: 是否启用文件缓存 ，接受Boolean|String,默认false parallel:是否启用多进程来提高构建速度，接受Boolean|Number，默认false sourceMap: 是否启用SourceMap(将错误信息映射值模块源文件)，开启可能会降低编译速度，接受Boolean，默认false uglifyOptions：压缩选项 extractComments：是否保留注释，接受Boolen,String,RegEXp,function,Object,默认false warningsFilter:允许过滤uglify-js警告。返回true以保持警告，否则为false。接受Function&lt;(warning, source) -&gt; Boolean&gt; Default: () =&gt; true 最后是UglifyJS的官网。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Image对象的complete与onload()事件(以及Canvas的drawImage()函数)]]></title>
    <url>%2F2019%2F03%2F12%2FImage%E5%AF%B9%E8%B1%A1%E7%9A%84complete%E4%B8%8Eonload()%E4%BA%8B%E4%BB%B6(%E4%BB%A5%E5%8F%8ACanvas%E7%9A%84drawImage()%E5%87%BD%E6%95%B0)%2F</url>
    <content type="text"><![CDATA[问题之前基本看完了canvas的API，准备做一个小游戏，emmm，然后今天就遇到了问题，我本来以为是canvas的问题，但是仔细分析之后才发现是JS中的问题： 回顾关于HTML与JS的关系可以从网页的加载顺序来看，当浏览器打开网页的时候，网页由上至下的解析该网页，然后开始构建DOM树(Document Object Model)(属于JavaScript)，也就是说将HTML的每一个标签构建成一个相应的对象，但是DOM整体就是一个对象，每一个标签是其的一个子对象，对比与JSX有些相似,遇到JS或CSS时利用相应引擎进行解析。从这里就可以理解出，在网页完成加载后，每一个标签就成为了DOM这个对象里的一个子对象，我们使用相应的方法，比如Document.getElementById(“xxx”)就可以获取相应的对象，并进行操作。 Image()对象由上可知，Image()也是一个节点对象，只是是否渲染至页面上的问题。 Image对象的属性 属性 描述 属性 描述 align 设置或返回与内联内容的对齐方式。 align 设置或返回与内联内容的对齐方式。 alt 设置或返回无法显示图像时的替代文本。 alt 设置或返回无法显示图像时的替代文本。 border 设置或返回图像周围的边框。 border 设置或返回图像周围的边框。 complete 返回浏览器是否已完成对图像的加载。 complete 返回浏览器是否已完成对图像的加载。 height 设置或返回图像的高度。 height 设置或返回图像的高度。 hspace 设置或返回图像左侧和右侧的空白。 hspace 设置或返回图像左侧和右侧的空白。 id 设置或返回图像的 id。 id 设置或返回图像的 id。 isMap 返回图像是否是服务器端的图像映射。 isMap 返回图像是否是服务器端的图像映射。 longDesc 设置或返回指向包含图像描述的文档的 URL。 longDesc 设置或返回指向包含图像描述的文档的 URL。 lowsrc 设置或返回指向图像的低分辨率版本的 URL。 lowsrc 设置或返回指向图像的低分辨率版本的 URL。 name 设置或返回图像的名称。 name 设置或返回图像的名称。 src 设置或返回图像的 URL。 src 设置或返回图像的 URL。 useMap 设置或返回客户端图像映射的 usemap 属性的值。 useMap 设置或返回客户端图像映射的 usemap 属性的值。 vspace 设置或返回图像的顶部和底部的空白。 vspace 设置或返回图像的顶部和底部的空白。 width 设置或返回图像的宽度。 width 设置或返回图像的宽度。 标准属性 属性 描述 className 设置或返回元素的 class 属性。 title 设置或返回元素的 title。 Image对象的事件句柄 事件句柄 描述 onabort 当用户放弃图像的装载时调用的事件句柄。 onerror 在装载图像的过程中发生错误时调用的事件句柄。 onload 当图像装载完毕时调用的事件句柄。 浅谈图片加载complete属性：图片显示出来之后其属性由false变为true在这个属性上，IE与其他浏览器有所不同，IE是根据图片的src属性是否是一个有效的图片地址值。即，在IE下，只有当image()对象的src值为一个正确的图片地址时，complete值才为true，否则一直为false，但是在其他浏览器下，当image()对象呗定义完成的时候，其complete值就为true，不会检测其src属性的有效性 也就是说：complete这个属性在IE系浏览器与其他浏览器的判断方式不一样，所以对于适配性来说，最好不用 onload()回调事件onload()是当图像装载完毕后调用的函数。关键是如何才算是装载完毕，经测试， 当我们直接在HTML中定义一个标签，并且在其中规定其onload事件，只有当src属性填写正确时，才算是装载完成，否则onload事件一直不触发，直至修改其src值为有效图片地址的时候才算是装载完成。 当我们在JS代码中手动生成一个Image()对象时，无论其src值是否被赋值为有效的图片地址，其onload事件总会触发，即当我们手动生成一个 Image 对象时，一旦其被生成，则认定为装载完成，立即调用onload事件。至于原因，我还没弄明白，看来需要深入的去了解一下浏览器机制，才能明白这一点。 Canvas中悟到的Image对象的用发法 ctx.drawImage(img,x,y)中的Img应当是一个Image对象，可以是从DOM树中获取的Image()子对象，也可以是一个自己定义的Image()对象，不管是这两者中的哪一者，再绘制到画板上时，都必须将绘制语句写到该对象的onload()函数中，其原因在于，Image()的定义是一个异步执行的操作，也就是说，在执行到let img = new Image()时，JS引擎不会等待该语句执行完毕在继续执行，而是直接继续执行，在对象定义完成时，就会自动调用其onlaod.onerror,onabort回调事件。那么问题就是，可能在对象还没有定义完成的时候，已经执行到了ctx.drawImage()这一条语句，所以绘制不出任何效果(而且大部分情况下，JS语句的执行都是快于对象的定义，所以基本上都绘制不出图形)。所以所有的Canvas图形绘制都必须是在onload中进行的。 问题又出现了，那如果要就行较大型的图形绘制，我不可能把所有代码都写到一个函数里吧，所以再写多个函数时就要多次调用onload事件，但是一个图片的onload事件只能执行一次。所以我想到了一种错误的方法，在不同寒暑表中多次载入同一张图片，并分别调用其回调函数onload，结果当然是失败了。这种情况下onload事件的顺序是无法确定的，即使你是前后分别执行，因为onload函数是异步进行的，现在惟一的办法就是把这张图片统一载入，然后想办法将下面的代码都建立在onlaod函数执行的前提下。然后我找到了一种方法： let img = new Image(); img.addEventListener(‘onload’,’start’,’true’); function start(){ draw1(); draw2(); } fucntion draw1(){ ctx.drawImage(); ... } fucntion draw1(){ ctx.drawImage(); ... } 上面这么写的好处在于，所有的函数后在onload回调函数之后执行了，确保了绘图的正确性。 Last but not least 我在网上搜了很久，在讲解onload()事件时基本就一篇文章，被抄了无数次，但是我试验却发现和文章中的结果完全不一样。文章中写到，即使是在JS代码中定义一个Image()对象时，只要src不赋值，其onload事件就不会触发，但是~像我上面实验的那样，我试验了很多次，都是那样的结果，测试了Chrome，Firefox，IE，Edge，每个浏览器的测试都一样。可能是那篇文章已经是很久之前的了，但是这些同学从未自己试过，直接就抄过去了。所以实践才是真理啊。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas基础]]></title>
    <url>%2F2019%2F03%2F10%2Fcanvas%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[创建canvas画布css: canvas{ border:3px solid blue; } html: &lt;canvas width=&quot;700&quot; height=&quot;700&quot; id=&quot;myCanvas&quot;&gt; 您的浏览器不支持canvas，请更换浏览器访问！ &lt;/canvas&gt; Javascript: &lt;script&gt; let canvas = document.getElementById(&quot;myCanvas&quot;); let ctx = canvas.getContext(&quot;2d&quot;); &lt;/script&gt; Point: canvas标签是一个双标签，其内部写的是当浏览器不支持canvas时显示的内容，可以插入其他元素，比如文字，图片等。 canvas画布的宽高因该在其标签内定义，不能在其CSS内定义，否则其绘制的图像会按照300*150发生缩放。 所有绘图行为都在script标签中进行。 let ctx = canvas.getContext(“2d”); 所有canvas的API都是定义在该对象上的，其中参数可以是2D，或者3D. Canvas绘制图像canvas的绘制图形有两种方式： context.fill() fill()指的是填充，其默认颜色是黑色，可以在使用fill()之前使用fillStyle()方法改变填充颜色，如果是闭合图像，那么就直接填充。如果是非闭合的路径，则fill()先帮其闭合，然后填充。 ctx.fillStyle = &quot;red&quot;;//设置填充色 ctx.fillRect(10,10,100,100);//绘制一个填充矩形 context.stroke() stroke()方法会实际的绘制出moveTo()和lineTo()方法的路径。默认颜色是黑色，在绘制之前，可以使用strokeStyle()进行设置。 ctx.strokeStyle = &quot;red&quot;;//设置边框填充色 ctx.strokeRect(10,10,100,100);//绘制空心矩形 绘制矩形绘制基本矩形ctx.fillRect(x,y,height,width)//实心矩形 ctx.strokeRect(x,y,height,width)//空心边框 x:起点的x坐标(即左上角的x坐标) y:起点的y坐标(即左上角的y坐标) height:矩形的高 width:矩形的宽 改变颜色ctx.fillStyle = &quot;red&quot;;//设置填充颜色 ctx.fillRect(10,10,100,100); ctx.strokeStyle = &quot;red&quot;;//设置边框颜色 ctx.strokeRect(200,200,100,100); Point: ctx.fillStyle = “red”用来设置填充颜色 ctx.strokeStyle = “red”用来设置边框颜色 这些描述都要放在绘制图形之前声明 擦除矩形区域 ctx.clearRect(x,y,height,width) ctx.clearRect(50,50,200,200)//绘制一个矩形区域并擦除该区域之前的内容 绘制圆形绘制基本圆实心圆 ctx.arc(x,y,radius,starAngle,endAngle,anticlockwise) x:圆心的x坐标 y:圆心的y坐标 radius:半径 startAngle:开始角度 endAngle:结束角度 anticlockwise:旋转方向，true:逆时针(可选参数，默认为false) false:顺时针 ctx.fillStyle = &quot;red&quot;; //设置填充色 ctx.arc(200,200,50,0,Math.PI*2,true);//绘制圆形 ctx.fill();//填充 空心圆ctx.beginPath() ctx.arc(200,200,50,0,Math.PI*2,true); ctx.strokeStyle = &quot;red&quot;; ctx.closePath(); ctx.stroke(); Point 上面用到了路径，实际ctx.arc()相当于是一个lineTo()的一个集合。利用其绘制出一个圆形，最后要关闭(ctx.cloePath())，以及要(stroke())才能完全绘制出该图形。 非完整圆如果要绘制一个非完整的圆，比如一个实心半圆，该如何绘制呢？ 答案是使用arc方法中的startAngle和endAngle来改变。 ctx.fillStyle = &quot;red&quot;; ctx.arc(200,200,50,0,Math.PI,true); 空心圆形 ctx.beginPath(); ctx.strokeStyle = &quot;red&quot;; ctx.arc(400,400,100,0,Math.PI); ctx.closePath(); ctx.stroke(); 绘制线段 moveTo(x,y):把画笔移动至画布的制定位置，不创建线条 lineTo(x,y):添加一个点(x,y) stroke():按照之前添加的点绘制路径 ctx.strokeStyle = &quot;red&quot;;//设置填充色 ctx.moveTo(0,0);//将画笔移动至(0,0) ctx.lineTo(100,100);//添加一个点(100,100) ctx.stroke();//按点绘制路径 Point 如果没有在第一次指定moveTo(x,y)，则第一个lineTo(x,y) == moveTo(x,y) 如果在lineTo()后没有使用moveTo()方法，则依次连接，eg： ctx.moveTo(0,0); ctx.lineTo(10,10); ctx.lineTo(20,20); ctx.lineTo(30,30); ctx.stroke(); 则画出后是一段从点(0,0)=&gt;(10,10)=&gt;(20,20)=&gt;(30,30)的一段折线。 ctx.beginPath():开始一段路径 ctx.closePath()：闭合路径，即canvas会自动将未闭合的线段的首尾连接起来。 eg(一个三角形): ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(10,10); ctx.lineTo(20,20); ctx.closePath(); ctx.stroke(); 案例(六边形)： var n = 0; var dx = 150;//路径开始x坐标 var dy = 150;//路径开始y坐标 var s = 100;//边长 ctx.beginPath();//路径开始 ctx.fillStyle = &apos;pink&apos;;//设置填充色 ctx.strokeStyle = &apos;rgb(0,0,100)&apos;;//设置边框颜色 var dig = Math.PI / 3;//计算偏移角度 for (var i = 0; i &lt; 6; i++) { var x = Math.sin(i * dig);//计算以下个点的x坐标的增量 var y = Math.cos(i * dig);//计算下一个点的y坐标的增量 ctx.lineTo(dx + x * s, dy + y * s);//绘制下一个点 //console.log( x ,y ) } ctx.closePath();//闭合整个路径 ctx.fill();//设置填充 ctx.stroke();//绘制路径 Point 这个例子用了一点数学知识，主要是： for (var i = 0; i &lt; 6; i++) { var x = Math.sin(i * dig);//计算以下个点的x坐标的增量 var y = Math.cos(i * dig);//计算下一个点的y坐标的增量 ctx.lineTo(dx + x * s, dy + y * s);//绘制下一个点 //console.log( x ,y ) } 其原理是利用了简单的沟股定理，计算下一个点的坐标 线性渐变 let lg = ctx.createLinearGradient(xStart,yStart,xEnd,yEnd) lg.addColorStop(offset,color) xSart:渐变开始点的x坐标 yStart：渐变开始点的y坐标 xEnd：渐变结束点的x坐标 yEnd：渐变结束点的y坐标 offset:设定的颜色离渐变结束点的偏移量 color:绘制的颜色 eg: let lg = ctx.createLinearGradient(0,0,100,200); lg.addColorStop(0,”#E55D87”); lg.addColorStop(1,”#5FC3E4”); ctx.fillStyle = lg; ctx.fillRect(0,0,200,200); Point 线性渐变仅仅是相当于设置填充色，在定义完填充色之后，我们还需要将填充设置为该线性渐变(ctx.fillStyle = gl) 由于线性渐变仅仅是设置填充色，所以具体的背景容器还需要我们自己设置，比如设置一个矩形作为容器ctx.fillRect(0,0,200,200) 由于渐变背景的坐标是相对于画布，而图形的坐标也是相对于画布，所以在定义背景时，需要注意与图形的坐标搭配以达到需要的效果 径向渐变 let rg = ctx.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd) rg.addCOlorStop(offset,color); xSart:发散开始的圆心x坐标 yStart：发散开始的圆心y坐标 radiusStart：发散开始圆的半径 xEnd：发散结束圆心的x坐标 yEnd：发散结束圆心的y坐标 radiusEnd：发散结束圆的半径 offset：设定的颜色结束点的偏移量(0-1) color:绘制颜色 var g1 = ctx.createRadialGradient(200, 150, 0, 200, 150, 200); g1.addColorStop(0.1, ‘#F09819’); g1.addColorStop(1, ‘#EDDE5D’); ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(200, 150, 100, 0, Math.PI * 2, true); ctx.closePath(); ctx.fill(); 图形变形缩放 scale(x,y) x:x坐标轴按x比例缩放 y:y坐标轴按y比例缩放 前面参数的是按倍数来衡量的(0.5=&gt;50%,1=&gt;100%,2=&gt;200%) eg: ctx.strokeStyle = &quot;red&quot;; ctx.scale(2,2); ctx.strokeRect(5,5,25,15); ctx.scale(2,2); ctx.strokeRect(5,5,25,15); ctx.scale(2,2); ctx.strokeRect(5,5,25,15); Point 缩放一个图形，先使用ctx.scale(x,y)对画布进行缩放处理，后面再创建要缩放的工具ctx.strokeRect(5,5,25,15);。 缩放的原点都是在(0,0)位置。 旋转 ratate(angle) angle:旋转的角度，以弧度计。 eg: ctx.strokeStyle = &quot;red&quot;; // ctx.strokeRect(5,5,200,200); ctx.rotate(20*Math.PI/180);//旋转5° ctx.strokeRect(5,5,200,300); Point: 默认的旋转中心是在(0,0)位置。下面介绍如何改变旋转中心。 平移 translate(x,y) x:坐标原点向x轴平移x y:坐标原点想y轴平移y eg1(以矩形中心为原点旋转)： ctx.strokeStyle = &quot;red&quot;; //以(0,0)为原点绘制一个起点为(200,200)，边长为200的正方形 ctx.strokeRect(200,200,200,200); //移动原点至(300,300)，即上面矩形的中心位置 ctx.translate(300,300); //将画布进行一个45°的旋转，得到一个旋转后的图形 ctx.rotate(45*Math.PI/180); //将原点坐标改为(0,0) ctx.translate(-300,-300); //绘制出旋转后的矩形 ctx.strokeRect(200,200,200,200); eg2(以矩形中心为原点缩放图形): ctx.strokeStyle = &quot;red&quot;; ctx.strokeRect(200,200,100,100); ctx.translate(250,250); ctx.scale(2,2); ctx.translate(-250,-250); ctx.strokeRect(200,200,100,100); Point 上面提到的，scale,rotate方法的操作都是对画布而言的，貌似整的canvas的思维都是这样，需要我们有反向思考的能力。 组合图形 globalCompositeOperation = type 后绘制的图形如何与之前的图像叠加渲染，取决与type。下面是type的种类： source-over(默认):在原图形之上绘制(覆盖)。 destination-over:在原图形之下绘制。 source-in:显示原有图形和新图形的交集，新图形在上，所以颜色为新图形颜色 destination-in:显示原图形和新图形的交集，原图形在上，所以颜色为原图形的颜色 source-out:只显示新图形的非交集部分 destination-out:只显示旧图形的非交集部分 source-atop:显示原图形和交集部分，新图形在上，所以交集部分为新图形颜色 destination-atop：显示新图形和交集部分，新图形在上，所以交集部分为新图形颜色 lighter：显示原有图形和新图形，交集部分做颜色叠加 copy:只显示新图形 eg: ctx.globalCompositeOperation = &quot;lighter&quot;; ctx.fillStyle = &quot;red&quot;; ctx.fillRect(50,50,200,200); ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(100,100,200,200); Point 该属性与上面的ctx.translate(x,y)一样，一旦作用，就对下面的元素都起作用，如果要还原，请在此使用该属性还原。 阴影 shadowOffsetX:设置或返回阴影距形状的水平距离(默认值为0)-shadowOffsetY:设置或返回阴影形状的垂直距离(默认值为0) shadowColor:设置或返回阴影的颜色 shadowBlur:设置或返回阴影的模糊级别(值越大越模糊) eg: ctx.shadowOffsetX=20; ctx.shadowColor=”blue”; ctx.shadowBlur = 50; ctx.fillStyle = “red”; ctx.fillRect(100,100,200,200); ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.fillStyle = &quot;yellow&quot;; ctx.fillRect(400,400,100,100); Point 相同的是，阴影属性也是对一下的所有图形都生效。要取消阴影效果，必须重置: ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; 图像操作 drawImage(img,x,y):在画布上定位图像 drawImage(img,x,y,width,height):在画布上定位图像，并规定图像的宽度和高度 drawImage(img,sx,sy,swidth,sheight,x,y,width,height) img:规定要使用的图像，画布或视频 sx(可选):开始剪切的x坐标位置 sy(可选):开始剪切的y坐标位置 swidth(可选):被剪切的图像的宽度 sheight(可选):被剪切的图像的高度 x:在画布上放置img的x坐标位置 y:在画布上放置img的y坐标位置 width(可选):要使用的图像的宽度。(拉伸或压缩) height(可选)：要使用的图像的高度。(拉伸或压缩) eg: let img = new Image(); img.src = &quot;expi.jpg&quot;; img.onload = function(){ ctx.drawImage(img,100,100,200,200,200,200,200,200); } Point img因该是一个img对象，img = new Image()或者是一个Image的DOM标签document.getElementById(&quot;img&quot;)(实际也是一个Image对象，因为在HTML中，每创建一个img标签，就会自动创建一个Image对象。) 在使用该标签时，应当使用，Image对象的回调函数onload,否则不能渲染成功，其原因是: let img = new Image(); img.src = &quot;expi.jpg&quot;; 这个过程中，对img.src赋值的时候，可能还没有赋值完成，就进行了ctx.drawImage语句，由于还没赋值完成，此使img.src还是空，所以无法渲染出来。 图像平铺 createPattern(image,type) type: no-repeat:不平铺 repeawt-x:按x轴方向平铺 repeat-y:按y轴方向平铺 repeat：全方向平铺 eg: let img = new Image; img.src = “beauty.png”; img.onload = function(){ let pattern = ctx.createPattern(img,”repeat-x”); ctx.fillStyle = pattern; ctx.fillRect(10,10,500,500); } Point 相同的是，必须要配合Image的oload回调函数来使用，道理同上。 图像剪切 clip() 该函数的使用方法： 创建剪切区域:ctx.rect(x,y,width,heigth) 设置剪切部分的填充色:ctx.fillStyle = “pink” 进行填充:ctx.fill(); 进行剪切:ctx.clip(); eg: ctx.fillStyle = &quot;yellow&quot;; ctx.fillRect(0,0,300,300); ctx.rect(100,100,500,500); ctx.fillStyle = &quot;pink&quot;; ctx.fill(); ctx.clip(); ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(0,0,200,200); Point -一旦剪切了某个区域，则之后的所有绘图都会被限制在被剪切区域内进行（不能访问画布上的其他区域）。我们也可以在使用clip()方法之前通过使用save()方法将之前的画布保存下来,并在任意时间使用restored()方法。 绘制文字 fillText(text,x,y):绘制实心文字 x:文字的中心点x坐标 y：文字的中心点y坐标 strokeText():绘制文字描边(空心文字) textAlign：设置或返回文字内容的当前对齐方式(注意：其都是相对于该文字对象的中心)，其值有： start:默认。文本在指定的位置开始。 end:文本在指定的位置结束。 left:文本左对齐。 center:文本的中心被放置在指定的位置。 right:文本右对齐。 textBaseline：设置会返回在绘制文本时使用的当前文字基线,其值有： Bottom：文本基线是 em 方框的底端。 Top：文本基线是 em 方框的顶端。 Middle：文本基线是 em 方框的正中。 Alphabetic：默认。文本基线是普通的字母基线。 hanging：文本基线是悬挂基线。 font:设置或返回文本内容的当前文字属性 eg: ctx.font = &quot;40px Arial&quot;; ctx.textAlign = &quot;center&quot;; ctx.fillText(&quot;Hello World&quot;,200,200); ctx.strokeText(&quot;Hello World&quot;,200,300); console.log(ctx.textBaseline);]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的.与[]的区别]]></title>
    <url>%2F2019%2F03%2F03%2FJavaScript%E4%B8%AD%E7%9A%84.%E4%B8%8E%5B%5D%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[叨叨一下最近在看ES6，感觉很有意思啊。然后就遇到了这个问题，.(点)与[] (方括号)的区别。 正文这个问题是在遍历器(Iterator)这一部分发现的，其中对于不存在遍历器的数据结构，比如一个对象。我们可以自定义一个遍历器，就可以实现forEach,for…in…等方法。然后就出现下面这段语句： var arrlike = { 0:a, 1:b, 2:c } arrlike.[Symbol.iterator](){ //遍历器内容，略 } 问题就在：arrlike.[Symbol.iterator]()，如果Symbol是对象arrlike的一个属性，那么为什么不能用arrlike.Symbol…的方法来获取该属性。 下面就说一下这两个的区别： 相同: .与[]都可以获取元素的属性。 不同: 中括号运算符可以用字符串变量的内容作为属性名。点运算符不能。 中括号运算符可以用纯数字为属性名。点运算符不能。 中括号运算符可以用js的关键字和保留字作为属性名。点运算符不能。 说回上面的arrlike.[Symbol.iterator](),Symbol.iterator是一个JS内置的一个关键字，然后这个属性返回的是一个函数。 然后后面的括号就是执行该函数。 function fun1(){return &quot;yes&quot;} console.log(func1) //function... console.log(func1()) //yes LastES6还是真的有意思，加油鸭！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP实战项目:学生信息管理系统的总结]]></title>
    <url>%2F2019%2F02%2F09%2FJSP%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言简单学习了一下JSP，不知道以后老师怎么教的，不过我是感觉到JSP的真谛还是Java，无论是按照MVC或者三层模式，一般Control层都是servlet来写，Model层都是用纯java来写，当然，在JSP文件中，也是可以进行这些操作的，毕竟在JSP的&lt;%…%&gt;中完全可以写java代码，而servlet的本质就是java的一个类。但是一般在开始时总是界面与逻辑分开，否则整个项目结构混乱，代码冗余。所以我觉的学JSP本质还是学java，学servlet。 正文整个项目差不多就包含学生信息的增删改，准备添加一个文件上传，不过还没添加，嘿嘿嘿。后面再说。 在这个过程中我遇到了不少问题，下面我就想起什么就讲什么吧~ 前端部分 前端完美居中之flex布局： 在登陆界面这种只需要一个div完美居中的情况，flex布局是在一个不错的方法： body{ display:flex;//设置body为flex布局 justify-content:center; //设置布局主轴上的对齐方式为居中 align-items:center;//设置另一轴的对齐方式为居中 } 这种布局下，body里的内容就会完美居中。 另外在回顾一下flex布局里的所有属性： 容器属性 flex-direction: 决定主轴的方向，即项目排列的方向，有四个可能的值：row(默认)|row-reverse|column|column-reverse flex-wrap:默认情况下，item排列在一条线上，即主轴上，flex-wrap决定当排列不下时是否换行以及换行的方式，可能的值nowrap(默认)|wrap|wrap-reverse flex-flow:flex-direction和flex-wrap的简写形式，如：row wrap|column wrap-reverse等。默认值为row nowrap，即横向排列 不换行。 justify-content:决定item在主轴上的对齐方式，可能的值有flex-start（默认），flex-end，center，space-between，space-around。 align-items:决定了item在交叉轴上的对齐方式，可能的值有flex-start|flex-end|center|baseline|stretch align-content:该属性定义了当有多根主轴时，即item不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，定义了align-content后，align-items属性将失效。 容器属性 order：order的值是整数，默认为0，整数越小，item排列越靠前。 flex-grow：定义了当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大；可能的值为整数，表示不同item的放大比例 flex-shrink：定义了当容器空间不足时，item是否缩小。默认值为1，表示当空间不足时，item自动缩小，其可能的值为整数，表示不同item的缩小比例。 flex-basis：表示项目在主轴上占据的空间，默认值为auto，其可为具体数值(px)。 flex：flex属性是flex-grow、flex-shrink和flex-basis三属性的简写总和。 align-self： align-self属性允许item有自己独特的在交叉轴上的对齐方式，它有六个可能的值：auto|flex-start|flex-end|center|baseline|stretch。默认值为auto。 前端onsubmit属性 这个属性真有点用~这个属性是用在submit按钮上的，他可以在你提交表单之前进行数据的审核。在审核通过后再上传，如果审核不通过，则不提交。具体代码如下。 //表单部分 &lt;input type=&quot;submit&quot; value=&quot;提交&quot; onsubmit=&quot;return check()&quot;&gt; //JS部分 function check(){ //执行判断，注意要返回一个boolean值，该值来确定是否需要提交表单 } Jquery的ajax请求 由于原生JS的ajax请求有点负载，所以我还是采用了jquery。所以还是具体介绍一下jquery的ajax请求。 1. $(“#id”).load(url,data,function(response,status,xhr)) 这种请求方法可以直接将请求到的数据添加到指定元素中（其本质还是get()方式）。 url：（必选）请求的地址 data:（可选）要发送的数据,采用键值存储发送，多个数据时采用花括号：{key1:value1,key2:value2} function():（可选），在服务器反馈后执行的函数。 response：服务器返回的数据 status：服务器返回的status值 xhr：服务器返回的xhr对象 2. $.get(url,data,function(response,status,xhr) 这个基本的get请求，get()只请求数据，不对数据做任何处理。 但是jquery将jsonp也封装进了get方法中，所以我们再调用get方法时，可以使用jsonp进行传输，但一般是是直接传字符串: $.get(url,data,function(data,status,xhr){}) 如果需要使用JSONP来请求，需要再声明： $.get(url,data.function(data,status,xhr){},&quot;JSONP&quot;) 关于JSON与JSONP，可以看一下这一篇文章，还是比较易懂。 3. $.get(url,data,function(response,status,xhr) 回顾一下，get与post： get: 数据追加到url中传输，因此保密性较差，直接可视化，不适用于账户，密码等信息的传输。 由于url的限制，也不适用于较长数据的传输，一般url的数据量在1KB左右。 由于使用url直接传输，因此传输效率会比post方式高。 post： post是将数据封装为HTTP消息发送给服务器，这样做有以下优点： 数据传输量相较于get()方法得到提升，一般文件传输都是利用该方法 数据保密性得到一定性的保护，无法直接获取，但需要注意的是，通过抓包，任然可以获得post提交的所有数据。所以我们在传输密码时，一般是通过加密传输，不传明文密码。这一点，在HTTPS中得到了较好的解决。但是HTTPS需要申请且价格昂贵，所以目前对于数据的加密任是最好方法。 4.$.ajax({ type:”get”,url:”url”,data:””,async:true,function(data,status,xhr){} }) 注意：async即异步，一般默认是true，即，你删掉async这个选项，则默认为true，还记得ajax的含义么： Asynchronous JavaScript and XML 第一个就是async，所以如果是false，就没意义了对吧，不过也许有的情况有用，了解到就好。 5. $.getJSON(url,data,function(response,status,xhr) 我觉得这是jquery中最好用的一个方法了，因为他将请求到的JSON字符串直接转换为JSON对象了，直接用key和value属性就可以使用了，舒服的板~ JS的cookies的使用 之前一直是使用的localStorage或者sessionStorage来存储数据，使用这个就很便捷，直接使用key来取value值就行了，我好像还有一个专门的文章来介绍，不过最终好像还是cookies使用的较多一点，可能是兼容性的原因，然年后我发现cookies的使用比localStorage要复杂一些，所以还是看一下： 设置cookie： function setCookie(cname,cvalue,exdays) { var d = new Date();//实例化一个时间 d.setTime(d.getTime()+(exdays*24*60*60*1000));//设置过期时间的变量 var expires = &quot;expires=&quot;+d.toUTCString();//将Date()对象转化为数组 document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;//设置cookie } 获取cookie值： function getCookie(cname) { var name = cname + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;);//分割cookie字符串 for(var i=0; i&lt;ca.length; i++) { var c = ca[i].trim();//去除空格 if (c.indexOf(name)==0) return c.substring(name.length,c.length); }//搜索是否存在该cookie，是则返回值 return &quot;&quot;; } 注意：可以看出，JS的cookie的API设计似乎没有localStorage那么友好，毕竟很多年前的东西了。所以document.cookie是直接获得整个cookie，以键值对用”=”连接起来，具体获得对应的值还需要我们自己来处理字符串，emmmm，从体验上来说，没有那么友好，但还有一点值得注意的是，document.cookie是一个方法，当你对他进行赋值操作的时候。他是直接识别”=”添加键值，而对其进行取值的时候，是以字符串返回所有的cookie值。 上面获取cookie的方法不是唯一的，因为处理字符串的方式不是唯一的，包括正则也是不错的方法 后端部分 关于MVC的理解我觉得也是学到的一部分，即将视图，模型，控制分离，而且无论是哪种设计方式，最终目的是保证层次的清晰。这样无论是对一次开发还是重构，都是及其重要的。 另外对于JSP这门后端语言，我觉得要理解其精髓，还是要学习servlet，java。因为model，controller层，一般都是采用servlet或者java来开发，似乎很少有用JSP来写逻辑层面的东西的。 在开发时我遇到了一个BUG卡了我好几天，搜索也没有结果，知道我理解其原因，啧啧啧： 我用java写好后端数据库交互层后，直接写了mian函数进行测试，成功！但是在我使用JSP文件发送ajax请求时，后端文件报错，无法找到sql驱动文件，我检查了sql文件，确实是在Java Resource的library中，并且直接运行java文件也通过了。。。搜索了很久，突然想到既然是javaweb程序，是不是在调用库文件时时使用的WebContent-&gt;WEB-INF-&gt;lib下的库文件，而不是调用java的库文件。我直接将sql驱动添加到javaweb的库中。nice，运行成功！ 关于eclipse的问题，在测试的某一段时间，发现整个工程没有更新了，修改了代码也没有用，以前也发生过，一般重启一下server就ok了，可这次重启也没用，没办法，清除缓存把，我直接清除了工程的缓存。然后。。。就是java程序无法运行，一直报错：无法找到main函数入口。在网上看到很多这种情况，但一般都说是classpath设置不对，但我另一个工程却可以运行，所以明显不是这种情况，然后我看到了这篇文章我按照第二条的方法，发现我有个库文件报错，直接移除，ok，解决（可是这和我的main函数有什么关系呢？？？） 最后在java那些库文件的语法方面我就不再BB了，反正是固定的API，按文档写就OK（其实是我懒，哈哈哈）~~~ 最后 最后我觉得我还是有个大问题，那就是变量的命名问题。。。This is a problem。很多不规范，这个在我以后的实践中尽量解决，比如~写个文档啊，哈哈哈。 所以这个项目就告一段落，前端的框架看一下就开学了~~~只能开学去看Python的GUI编程了~]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP数据库处理]]></title>
    <url>%2F2019%2F01%2F31%2FJSP%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[JSP的数据库操作经过这两天的操作，我觉得还是要看视频或者买书或者看官方文档学习，网上的资料缺点太多，写的过于简单，甚至兼容性也有问题。所以，搞了一天，终于，把数据库搞出来了~ 源码分析sql.java package student.servlet; import java.sql.*; public class sql { public static void Update(){ Statement stmt = null; Connection connection = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } String name=&quot;root&quot;; String pwd=&quot;957837&quot;; String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;; try { connection = DriverManager.getConnection(url,name,pwd); System.out.print(&quot;数据库连接成功！&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { stmt = connection.createStatement(); String sqlString = &quot;insert into blog values(5,&apos;https&apos;,&apos;hhhhh&apos;,&apos;2015-8-9&apos;)&quot;; int lines = stmt.executeUpdate(sqlString); System.out.print(&quot;插入成功&quot;+lines+&quot;受影响&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { if(stmt != null) { stmt.close(); } connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public static void Select() { Statement stmt = null; Connection connection = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } String name=&quot;root&quot;; String pwd=&quot;957837&quot;; String url=&quot;jdbc:mysql://localhost:3306/myblog&quot;; try { connection = DriverManager.getConnection(url,name,pwd); System.out.print(&quot;数据库连接成功&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { stmt = connection.createStatement(); String sqlString = &quot;select * from blog&quot;; ResultSet res = stmt.executeQuery(sqlString); System.out.println(&quot;查询数据库成功&quot;); while(res.next()) { int num= res.getInt(&quot;order_id&quot;); String title = res.getString(&quot;title&quot;); System.out.println(num); System.out.println(title); } } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } try { if(stmt != null) { stmt.close(); } connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public static void main(String[] args){ // Update(); Select(); } } 代码分析： 对于连接数据库这种操作，一般不在JSP中操作，而是用javabean来操作，也就是说在创建一个java文件，将其作为数据库处理的文件，然后再JSP文件中连接该文件进行操作。 引入数据库驱动，首先要去网上下载一个数据库驱动，不同的数据库系统驱动不同，这个是由数据库厂商提供的。下载完之后，就将其copy到Web App Libraries文件夹中。然后就可以使用该Class了。 然后就是： Statement connection = DriverManager.getConnection(url,name,pwd) 使用该句来连接数据库（注意：在Java文件中，该句需要添加try…catch…）。 增删改数据库: Statement stmt = connection.createStatement(); String sql = “insert…”; //该方法返回的是受影响的行数 int res = connection.executeUpdate(sql) 查数据库：查数据唯一不同的是执行语句： String sql =”…”; ResultSet res = connection.executeQuery(sql); while(res.next()) { int num= res.getInt(&quot;...&quot;); String title = res.getString(&quot;...&quot;); System.out.println(num); System.out.println(title); } 注意：在获取数据库内容时，使用:ResultSet res =connection.executeQuery(sql),这个res是一个表的集合。可以类比遇一个Iterator 使用一个while循环来使用获取全部的数据。 res该对象含有：next(),hasNext()等方法来获取下一个。主要的还是get方法。但是获取不同类型的数据需要用不同的get方法：getInt(“name”);getString(“”)…like this。 最后需要注意的是，连接完数据库后，要把链接关闭。 stmt.close(); connection(); 这两个都要被关闭！ ##Last but important##就上面这几句代码，emmmm，在网上找了一天，现在才发现，网上的资料的参差不齐，终归还是要看文档，不行就看书，then，看视频。经验，哈哈哈。还有6天，做一个Demo吧，哈哈哈。]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP基础部分]]></title>
    <url>%2F2019%2F01%2F30%2FJSP%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[JSP这几天把JSP基本部分看了，方便记忆，还是回顾一下。文件部分有一点复杂，所以后面直接单独解析一下。 日期处理其实日期处理部分还是JAVA中的Date()对象提供的。只是之前学习JAVA是没认真看，哈哈哈。 获取时间eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*, javax.servlet.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;显示当前时间与日期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示当前时间与日期&lt;/h1&gt; &lt;% Date date = new Date(); out.print( &quot;&lt;h2 align=\&quot;center\&quot;&gt;&quot; +date.toString()+&quot;&lt;/h2&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 提示：任然是实例化Date对象，然后对该对象进行操作，其中该对象有以下方法： 序号 方法 &amp; 描述 boolean after(Date date)如果比给定的日期晚，则返回true，否则返回false boolean before(Date date)如果比给定的日期早，则返回true，否则返回false Object clone( )获取当前对象的一个副本 int compareTo(Date date)如果与给定日期相等，则返回0，如果比给定日期早，则返回一个负数，如果比给定日期晚，则返回一个正数 int compareTo(Object obj)与 compareTo(Date) 方法相同，如果 obj 不是Date类或其子类的对象，抛出ClassCastException异常 boolean equals(Object date)如果与给定日期相同，则返回true，否则返回false long getTime( )返回从1970年1月1日凌晨至此对象所表示时间的毫秒数 int hashCode( )返回此对象的哈希码 void setTime(long time)使用给定参数设置时间和日期，参数time表示从1970年1月1日凌晨至time所经过的毫秒数 String toString( )将此对象转换为字符串并返回这个字符串 日期的比较 使用getTime()方法得到毫秒数，然后比较毫秒数就行了。 使用before()，after()，equals()方法。比如，new Date(99,2,12).before(new Date(99,2,18))返回true。 使用compareTo()方法，这个方法在Comparable接口中定义，在Date中实现。 使用SimpleDateFormat格式化日期eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;%@ page import=&quot;javax.servlet.*,java.text.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;显示当前时间与日期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示当前时间与日期&lt;/h1&gt; &lt;% Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd HH:mm:ss&quot;); out.print( &quot;&lt;h2 align=\&quot;center\&quot;&gt;&quot; + ft.format(dNow) + &quot;&lt;/h2&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; SimpleDateFormat格式码 字符 描述 示例G 时代标识符 AD y 4位数年份 2001 M 月 July or 07 d 日 10 h 12小时制， A.M./P.M. (1~12) 12 H 24小时制 22 m 分钟 30 s 秒 55 S 毫秒 234 E 星期 Tuesday D 一年中的某天 360 F 一个月中某星期的某天 2 (second Wed. in July) w 一年中的某星期 40 W 一个月中的某星期 1 a A.M./P.M. 标记 PM k 一天中的某个小时 (1~24) 24 K 一天中的某个小时，A.M./P.M. (0~11) 10 z 时区 Eastern Standard Time ‘ 文本分隔 Delimiter “ 单引号 ` 页面重定向页面重定向是指在client访问a.jsp时，根据据需要，a.jsp页面将请求重定向至另一个页面。注意这一个过程中，a.jsp的所有内容都不会返回至client，而是直接将请求引导至新页面，也就是说client会进行二次访问，新页面的加载还是又client来完成。 eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;页面重定向&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;页面重定向&lt;/h1&gt; &lt;% // 重定向到新地址,关键部分 String site = new String(&quot;http://www.runoob.com&quot;); response.setStatus(response.SC_MOVED_TEMPORARILY); response.setHeader(&quot;Location&quot;, site); %&gt; &lt;/body&gt; &lt;/html&gt; 还有一个类似的请求转发，而请求转发是在接手到client的请求后，在server端进行请求，然后再这个请求的基础上将新内容返回。也就是说，该种方法只经历了1次请求，并且转发只能是转发到本次请求的服务器，而重定向则可以定向到其他服务器。(进过我的测试暂时是这样) 我在看这一部分时，想在重定向或者焕发之前给client一些提示，但是由于该页面的内容内容根本不会写入到response中，所以是不能实现的，在网上查找了一圈的资料，基本都是说使用前端来实现跳转，才能给客户端反馈。 比如: out.print(&quot;&lt;script&gt; alert(&quot;即将跳转至百度！&quot;); window.href=&quot;http:www.baidu.com&quot;; &lt;/script&gt;&quot;) 所以，如果使用重定向或者是转发，是不能给客户端提示的，如果要提示，就要用前端实现跳转。 JSP点击量统计在菜鸟上，对于统计量方法的实现，时使用application对象来存储一对键值，在访问时动态变化，实现访问量统计。所以我们看一下applicant这个对象，它有以下特点： 在服务器启动时自动创建，在服务器关闭时自动销毁 一个网站仅有一个application，也就是说所有的客户共享一个application。 所以如果服务器遇到宕机，那么这个量就被销毁了，所以最保险的方法是将其储存到数据库中，并定期刷新。保证不会频繁访问数据库，又可以最大化的保存数据。 eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;访问量统计&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Integer hitsCount = (Integer)application.getAttribute(&quot;hitCounter&quot;); if( hitsCount ==null || hitsCount == 0 ){ /* 第一次访问 */ out.println(&quot;欢迎访问菜鸟教程!&quot;); hitsCount = 1; }else{ /* 返回访问值 */ out.println(&quot;欢迎再次访问菜鸟教程!&quot;); hitsCount += 1; } application.setAttribute(&quot;hitCounter&quot;, hitsCount); %&gt; &lt;p&gt;页面访问量为: &lt;%= hitsCount%&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; JSP自动刷新我其实觉得这个功能可以在前端实现，不过也许有些时候必须要使用后端实现呢，所以还是看一下，其实就一句： response.setIntHeader(&quot;Refresh&quot;, 5); eg: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;自动刷新实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;自动刷新实&lt;/h2&gt; &lt;% // 设置每隔5秒刷新一次 response.setIntHeader(&quot;Refresh&quot;, 5); // 获取当前时间 Calendar calendar = new GregorianCalendar(); String am_pm; int hour = calendar.get(Calendar.HOUR); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); if(calendar.get(Calendar.AM_PM) == 0) am_pm = &quot;AM&quot;; else am_pm = &quot;PM&quot;; String CT = hour+&quot;:&quot;+ minute +&quot;:&quot;+ second +&quot; &quot;+ am_pm; out.println(&quot;当前时间为: &quot; + CT + &quot;\n&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 通过这个栗子可以看出效果，当然，对于日期的刷新，不肯能用这个东西，肯定是局部的ajax来实现。]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP中的表单编码问题]]></title>
    <url>%2F2019%2F01%2F28%2FJSP%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8D%95%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JSP的编码才看了几天的JSP，把最重要的表单提交看了一下，遇到了中文编码的问题，然后我查了一下JSP的默认代码是：ISO-8859-1重新设编码的语句共有下面几句： pageEncoding=”UTF-8” contentType=”text/html;charset=UTF-8” request.setCharacterEncoding(“UTF-8”) response.setCharacterEncoding(“UTF-8”) pageEncoding=”UTF-8” 是在第一阶段，转换阶段（即将JSP文件转化为servlet文件的过程中使用该局代码提示的编码） contentType=”text/html;charset=UTF-8” 是用在第二阶段，将servle渲染为html时，使用该语句的编码 request.setCharacterEncoding(“UTF-8”) 是用来指定对浏览器发送来的数据以特定的字符集进行重新编码，常用于对 POST 请求参数进行解码。 response.setCharacterEncoding(“UTF-8”) 是用来在服务器将响应返回到浏览器前，对响应使用指定字符集进行重新编码。一旦使用了该种方式，即使该响应页面指定了具体的 contentType，也将失效。]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3_CGI编程踩坑日记]]></title>
    <url>%2F2019%2F01%2F14%2FPython3-CGI%E7%BC%96%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Hard-start这是学习Python的第六天，也是进入Python高级编程的第一天，嗯，对，然后我就遇见了Big Problem，甚至到现在都还有一个问题没有解决。 Problem I met Apache的安装问题 在得之要使用Apache之后，我直接就百度Apache，然后再官网首页 结果下载下来直接用不了，解压了发现文件不对。然后一搜教程才发现文件下载错了。 应该在这里下载： 终于完成填了第一个坑！ Apache配置问题 要启用CGI，必需修改配置文件。而这个配置不仅仅是是一个地方，是n个地方： ServerRoot配置 ServerRoot “” 主要用于指定Apache的安装路径，此选项参数值在安装Apache时系统会自动把Apache的路径写入。Windows安装时，该选项的值为Windows安装的路径，Linux安装时该选项值为编译时选择的路径 找到： Define SRVROOT &quot;${SRVROOT}&quot; ServerRoot &quot;${SRVROOT}4&quot; 改为： Define SRVROOT &quot;D:\web\Apache24&quot; ServerRoot &quot;D:\web\Apache24&quot; 其中”${SRVROOT}”应改为你你安装Apache的目录。 Listen 配置 Listen主要侦听web服务端口状态，默认为：80，即侦听所有的地址的80端口，注意这里也可以写成IP地址的侦听形式，不写即默认的地址：0.0.0.0 找到： Listen:80 改为： Listen:8080 一般不为80，因为容易占用，改为其他好一点。比如我改为8080。 CGI配置 找到： AddHandler cgi-script .cgi .pl 改为： AddHandler cgi-script .cgi .pl .py 这里是增加对Python的支持。 找到： &lt;Directory &quot;/${SRVROOT}&quot;&gt; AllowOverride none Require all denied &lt;/Directory&gt; 改为： &lt;Directory &quot;D:\web\Apache24\cgi-bin&quot;&gt; AllowOverride None Options Indexes FollowSymLinks ExecCGI Require all granted Require host ip &lt;/Directory&gt; 注意这里/${SRVROOT}任然还是Apache的安装地址。 Python解释器 我就这么按照runoob上代码粘贴下来，like this： #!/usr/bin/python3 print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是来自菜鸟教程的第一CGI程序&lt;/h2&gt;&apos;) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) 然后就出现了500错误，下面是log里的提示： [Mon Jan 14 11:31:58.626473 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。 : [client ::1:52212] couldn&apos;t create child process: 720002: hello.py [Mon Jan 14 11:31:58.660452 2019] [cgi:error] [pid 3624:tid 1196] (OS 2)系统找不到指定的文件。 : [client ::1:52212] AH01223: couldn&apos;t spawn child process: D:/web/Apache24/cgi-bin/hello.py 百度了半天，突然想起Apache如何载入编译器呢，然后直接百度上面代码的第一行： #!/usr/bin/python3 然后才知道这是Linux下Python的解释器位置，我枯了。然后我找到了自己Python3的安装位置，却发现没有exe文件，我又枯了。但是用sys自己的命令： import sys sys.path 得到了就是这个位置。不管了，直接写吧！于是得到了这一段代码： #!D:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python37\\python.exe 没错，就是这么长，不知道自己当时怎么安装的。我又枯了。 结果成功解析了！！！ 但是！！！ 又乱码了，检查了py文件的编码，发现py默认是utf-8啊。然后终于在网上找到了解决办法。没错，是print()函数的问题。 又大佬看print()源码使用Unicode，果然乱码了，然后引入了这一段代码： import io sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) 即：将print()函数改为utf-8编码输出，终于留了一张图： 附上正常获取text，textarea的代码，其他的都一样。 (text.html): &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/cgi-bin/text.py&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt; &lt;input tyep = &apos;text&apos; name = &apos;name&apos;/&gt; &lt;textarea name=&quot;personinform&quot;&gt;个人信息&lt;/textarea&gt; &lt;input type=&apos;submit&apos; value=&apos;提交&apos;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; (text.py): #!D:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python37\\python.exe import io import sys import cgi, cgitb sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) form = cgi.FieldStorage() name = form.getvalue(&apos;name&apos;) personinform= form.getvalue(&apos;personinform&apos;) print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;) print(name) print(personinform) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) 下面是get从url来获取键值的方法： #!D:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python37\\python.exe import io import sys import cgi, cgitb sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf-8&apos;) form = cgi.FieldStorage() name = form.getvalue(&apos;name&apos;) number = form.getvalue(&apos;number&apos;) print (&quot;Content-type:text/html&quot;) print () # 空行，告诉服务器结束头部 print (&apos;&lt;html&gt;&apos;) print (&apos;&lt;head&gt;&apos;) print (&apos;&lt;meta charset=&quot;utf-8&quot;&gt;&apos;) print (&apos;&lt;title&gt;Hello Word - 我的第一个 CGI 程序！&lt;/title&gt;&apos;) print (&apos;&lt;/head&gt;&apos;) print (&apos;&lt;body&gt;&apos;) print (&apos;&lt;h2&gt;Hello Word! 我是第一CGI程序&lt;/h2&gt;&apos;) print(name,number) print (&apos;&lt;/body&gt;&apos;) print (&apos;&lt;/html&gt;&apos;) last problem(unsolved) 最后一个问题就是CGI的文件上传问题。由上面的代码可以知道，所有接受的数据都来自： cgi.FieldStorage() 网上的教程都这么获得数据： import cgi, os import cgitb; cgitb.enable() form = cgi.FieldStorage() # 获取文件名 fileitem = form[&apos;filename&apos;] # 检测文件是否上传 if fileitem.filename: # 设置文件路径 fn = os.path.basename(fileitem.filename) open(&apos;/tmp/&apos; + fn, &apos;wb&apos;).write(fileitem.file.read()) message = &apos;文件 &quot;&apos; + fn + &apos;&quot; 上传成功&apos; else: message = &apos;文件没有上传&apos; 但是问题在于， fileitem.filename == none 我直接输出 fielitem fileitem = MiniFielStorage(&apos;filename&apos;,&apos;test.txt&apos;) #test.txt为上传的文件名 所以fileitem.filename始终为none。所以一直解决不了，查了各种资料，不过官方文档里有类似的解释，但是还是没有解决办法。明天再看吧~~~难受啊，马飞~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CGI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎2019-假如我年少有为]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%AC%A2%E8%BF%8E2019-%E5%81%87%E5%A6%82%E6%88%91%E5%B9%B4%E5%B0%91%E6%9C%89%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "不知道密码就别猜了，这是我得小秘密，哈哈哈" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周报(0)]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%91%A8%E6%8A%A5(0)%2F</url>
    <content type="text"><![CDATA[LeetCode： 简单思路：令i从0开始向后跑寻找与下标为length-1不相等的数，找到之后将那个数放到length的位置上，并且令length长度加1，最后返回length就行了。代码部分： int removeDuplicates(int* nums, int numsSize) { if(numsSize==0){ return 0; } int length = 1; for(int i=0;i&lt;numsSize;i++){ if(nums[i]!=nums[length-1]){ nums[length++]=nums[i]; } } return length; } Java学习部分内容重写与重载重写：在子类中1. 参数列表必须完全与被重写方法的相同 2. 返回类型必须与被重写方法的返回类型相同 3. 访问权限不能比父类中被重写的方法的访问权限更低。例如，父类的一个方法被申明为public，那么该子类中重写该方法就不能申明为protected。 4. 父类的成员方法只能被它的子类重写 5. 申明为final的方法不能被重写 6. 申明为static的方法不能被重写，但是能够被再次申明 7. 子类与父类在同一个包中，那么子类可以重写父类的所有方法，除了声明为private与final的方法 8. 子类与父类不在一个包中，那么子类只能够重写父类的声明为public和protected的非final方法 9. 构造方法不能被重写 10. 如果不能继承一个方法，则不能重写这个方法 super1. 在父类的某一方法被重写后，如果需要调用原父类的方法，需在该方法前加super关键字 重载 ：在同一个类中1. 被重载的方法必须改变参数列表（参数个数或类型不一样） 2. 被重载的方法可以改变返回类型 3. 被重载的方法可以改变访问修饰符 4. 被重载的方法可以声明新的或更广的检查异常 5. 方法能够在同一个类中或者一个子类中被重载 6. 无法以返回值类型作为重载函数的区分标准 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 来自 http://www.runoob.com/java/java-override-overload.html 2.多态：同一个行为具有多个不同表现形式或形态的能力。 向上转型：子类引用的对象转换为父类类型称为向上转型。 重写式多态：也叫运行时多态，这种多态通过动态绑定技术来实现，是指在执行期间判断所引用的对象的实际类型调用起相应的方法。 Animal animal = new Cat(); //向上转型 1. 向上转型时，子类单独定义的方法会丢失。比如上面Dog类中定义的run方法，当animal引用指向Dog类实例时是访问不到run方法的，animal.run()会报错。 2. 子类引用不能指向父类对象。Cat c = (Cat)new Animal()这样是不行的。 向上转型后方法引用的优先级问题： 继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 注意：此时的（super）O 指的是O的父类。以下面的8为例： b.show(C) 由于b的引用对象为B，所以可以调用的方法有：show(B)，show(A) （this.show(O)） 又b的类型也为B，所以方法也先在B中选择，发现没有show(C)方法 （super.show(O)） 在B的父类，即A中查找show(C)方法，任然没有查找到 （this.show(super)O） 原式为：b.show（C），又C的父类为B，所以该式变为：b.show(b)，并且在B中查找，找到了该方法，于是执行该方法，得到结果：B and B 实例class A { public String show(D obj) { return (“A and D”); } public String show(A obj) { return (&quot;A and A&quot;); } } class B extends A{ public String show(B obj){ return (“B and B”); } public String show(A obj){ return (&quot;B and A&quot;); } } class C extends B{ } class D extends B{ } public class Demo { public static void main(String[] args) { A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(&quot;1--&quot; + a1.show(b)); System.out.println(&quot;2--&quot; + a1.show(c)); System.out.println(&quot;3--&quot; + a1.show(d)); System.out.println(&quot;4--&quot; + a2.show(b)); System.out.println(&quot;5--&quot; + a2.show(c)); System.out.println(&quot;6--&quot; + a2.show(d)); System.out.println(&quot;7--&quot; + b.show(b)); System.out.println(&quot;8--&quot; + b.show(c)); System.out.println(&quot;9--&quot; + b.show(d)); } }//结果：//1–A and A//2–A and A//3–A and D//4–B and A//5–B and A//6–A and D//7–B and B//8–B and B//9–A and D 从4向后的解析原理：当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。Animal animal = new Cat(); //向上转型 Animal为引用对象Cat为引用变量 首先，a2是类型为A的引用类型，它指向类型为B的对象。A确定可调用的方法：show(D obj)和show(A obj)。a2.show(b) ==&gt; this.show(b)，这里this指的是B。 然后.在B类中找show（B obj），找到了，可惜没用，因为show（B obj）方法不在可调用范围内，this.show(O)失败，进入下一级别：super.show(O)，super指的是A。 在A 中寻找show（B obj)，失败，因为没用定义这个方法。进入第三级别：this.show((super)O)，this指的是B。在B中找show（（A）O）,找到了：show(A obj)，选择调用该方法。 输出：B and A 上面的例子简单的介绍了多态的意义，同一个行为具有不同的表现形式或形态的能力。 多态（重写式）实现的条件： 1. 继承（实现） 2. 重写 3. 向上转型 重载式多态：也叫编译时多态，也就是说这种多态在编译时已经确定好了。在调用这种方法时，通过传入不同的参数得到不同的结果。 此处重载式多态有不同的说法，部分观点认为：重载不属于多态，认为多态仅仅指的是在程序运行时根据不同的输入，而方法有不同的响应称之为多态；但重载指的是：在一个类里，方法名字相同，而参数不同。也就是说在程序编译时就确定了该方法的响应。所以不能称之为多态。关于这个部分，我还没有更深的理解，所以暂时保留意见。]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>周报</tag>
        <tag>Java</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组（二，ES6部分）]]></title>
    <url>%2F2018%2F11%2F02%2FJavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%8CES6%E9%83%A8%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言上次介绍了ES5之前发布的JS的数组方法，这次再看一下ES5中发布的JS方法。 正文 indexOf()和lastIndexOf() 描述： indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。 应用： 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。 exp: var arr = [1,3,5,7,7,5,3,1]; console.log(arr.indexOf(5)); //2（5在该数组的第2位） console.log(arr.lastIndexOf(5)); //5(从后向前，5在数组的第5位) console.log(arr.indexOf(5,2)); //2（从第二位开始检索，任然2在第5位） console.log(arr.lastIndexOf(5,4)); //2（从倒数第四位开始检索，5在倒数第四位） console.log(arr.indexOf(&quot;5&quot;)); //-1（数组中没有字符&quot;5&quot;，所以返回-1） forEach() 描述： 对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。 应用： 用于遍历数组，获得数组成员的内容，索引，及其数组本身 var arr = [1, 2, 3, 4, 5]; arr.forEach(function(x, index, a){ console.log(x + ‘|’ + index + ‘|’ + (a === arr)); }); // 输出为： // 1|0|true // 2|1|true // 3|2|true // 4|3|true // 5|4|true map() 描述： 遍历一个数组，并且经过处理后返回一个新的数组。 原型： arr.map(function(currentValue，index，arr),thisValue) currentValue 必须 当前元素值 index 可选 当前元素的索引值 arr 可选 当前元素属于的数组对象。 exp:通过map方法返回数组元素的平方 var arr = [1, 2, 3, 4, 5]; var arr2 = arr.map(function(item){ return item*item; }); console.log(arr2); //[1, 4, 9, 16, 25] 注意，map()方法不会改变原数组，而是返回一个新的数组，注意function中药返回值，否则为空数组 exp2: var arr = [1,2,3,7,9]; var arr2 = arr.map(function(x,index,a){ x=x+1; }); console.log(arr2);//[undifined,undifined,undifined,undifined,undifine] console.log(arr);//[1,2,3,7,9] 即使在map()的函数中改变currentValue的值，原数组的职业不会改变。而如果没有返回值，则该数组为undefined。 filter() 描述： “过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 原型：array.filter(function(currentValue,index,arr), thisValue) currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 exp： var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; var arr2 = arr.filter(function(x, index) { return index % 3 === 0 || x &gt;= 8; }); console.log(arr2); //[1, 4, 7, 8, 9, 10] 该方法的注意事项和上一个方法差不多，也是不会改变原数组，并且必须要有返回值，否则数组为undefined。 every() 描述： 判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 原型：array.filter(function(currentValue,index,arr), thisValue) currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 应用： 检测数组所有元素是否都符合指定条件（通过函数提供）。 exp： var arr = [1, 2, 3, 4, 5]; var arr2 = arr.every(function(x) { return x &lt; 10; }); console.log(arr2); //true var arr3 = arr.every(function(x) { return x &lt; 3; }); console.log(arr3); // false some() 描述： 判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 应用： some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。 exp： var arr = [1, 2, 3, 4, 5]; var arr2 = arr.some(function(x) { return x &lt; 3; }); console.log(arr2); //true var arr3 = arr.some(function(x) { return x &lt; 1; }); console.log(arr3); // false 注意： some() 方法会依次执行数组的每个元素： 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。 reduce()和 reduceRight() 描述： 这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 原型（以reduce为例）： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 currentIndex 可选。当前元素的索引 arr 可选。当前元素所属的数组对象。 exp： var values = [1,2,3,4,5]; var sum = values.reduceRight(function(total, currentValue, currentIndex, arr){ return total + currenValue; },10); console.log(sum); //25 最后这是ES6中提供的数组方法，对于ES6，我还没有认真研究，不过这些方法还是挺实用的，对于低版本的浏览器可能会不支持。感觉开发中还是要针对需求使用。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组]]></title>
    <url>%2F2018%2F10%2F26%2FJavaScript%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[JavaScript数组复习一下数组，发现有些方法都忘记了 定义数组的方式 采用直接量创建 var MyArray = [];//创建空数组 var MyArray = [1,2,3];//创建数字型数组 var MyArray = [“A”,”B”,”C”];//创建字符型数组 var MyArray = [{id:1},{id:2},{id:3}];//创建对象型数组 采用构造函数创建 var MyArray = new Array(); MyArray[0] = 0; MyArray[1] = “A”; var MyArray = new Array(5); var MyArray = new Array(5,4,3,2,1); 属性 constructor 描述：返回对创建此对象的数组函数的引用。 应用1：用于判断元素类型 exp： &lt;script type=&quot;text/javascript&quot;&gt; var test=new Array(); if (test.constructor==Array) { document.write(&quot;This is an Array&quot;); } if (test.constructor==Boolean) { document.write(&quot;This is a Boolean&quot;); } if (test.constructor==Date) { document.write(&quot;This is a Date&quot;); } if (test.constructor==String) { document.write(&quot;This is a String&quot;); } &lt;/script&gt; 输出： This is an Array 应用2：用于获取构造函数的原形 exp: &lt;script type=&quot;text/javascript&quot;&gt; function employee(name,job,born) { this.name=name; this.job=job; this.born=born; } var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985); document.write(bill.constructor); &lt;/script&gt; 输出： function employee(name, job, born) {this.name = name; this.job = job; this.born = born;} length 描述：设置或返回数组中元素的数目 应用：设置或返回数组中元素的数目 exp： &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;John&quot; arr[1] = &quot;Andy&quot; arr[2] = &quot;Wendy&quot; document.write(&quot;Original length: &quot; + arr.length) document.write(&quot;&lt;br /&gt;&quot;) arr.length=5 document.write(&quot;New length: &quot; + arr.length) &lt;/script&gt; 输出： Original length: 3 New length: 5 prototype 描述：使您有能力向对象添加属性和方法 应用：向对象添加属性和方法 exp: //定义一个employee对象 function employee(name,job,born) { this.name=name; this.job=job; this.born=born; } //实例化一个employee var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985); employee.prototype.salary=null; bill.salary=20000; document.write(bill.salary); &lt;/script&gt; 值得注意的是：prototyp是面向对象编程的重要属性。在W3C的解释中，可以知道函数也是一个对向（具体函数与对象的关系后续再详细讨论），每个函数对象都具有一个子对象prototype。Prototype 表示了该函数的原型，prototype表示了一个类的属性的集合。当通过new来生成一个类的对象时，prototype对象的属性就会成为实例化对象的属性。 方法 contact() 描述：连接两个或更多的数组，并返回结果 应用：连接n个数组 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; var arr2 = new Array(3) arr2[0] = &quot;James&quot; arr2[1] = &quot;Adrew&quot; arr2[2] = &quot;Martin&quot; var arr3 = new Array(2) arr3[0] = &quot;William&quot; arr3[1] = &quot;Franklin&quot; //执行连接操作 document.write(arr.concat(arr2,arr3)) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin,William,Franklin join() 描述：把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 应用：创建一个数组，然后把它的所有元素放入一个字符串 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr.join(&quot;.&quot;)) &lt;/script&gt; 输出： George.John.Thomas 注意：join(separator)中separator为间隔符，若为空择默认为逗号。 pop() 描述：pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值 应用：创建一个数组，然后删除数组的最后一个元素 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr) document.write(&quot;&lt;br /&gt;&quot;) document.write(arr.pop()) document.write(&quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas Thomas George,John push() 描述：push() 方法可把它的参数顺序添加到 arrayObject 的尾部。 它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。 arrayObject.push(newelement1,newelement2,....,newelementX) newelement1（必选）- 要添加的第一个元素 newelement2（可选）- 要添加的第二个元素 newelementX（可选）- 要添加的第X个元素 应用：创建一个数组，并通过添加一个元素来改变其长度 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.push(&quot;James&quot;) + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas 4 George,John,Thomas,James reverse() 描述：用于颠倒数组中元素的顺序（该方法会改变原来的数组，而不会创建新的数组） 应用：创建一个数组，然后颠倒其元素的顺序 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.reverse()) &lt;/script&gt; 输出： George,John,Thomas Thomas,John,George shift() 描述:用于把数组的第一个元素从其中删除，并返回第一个元素的值(如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject) 应用：创建一个数组，并删除数组的第一个元素。请注意，这也将改变数组的长度 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(3) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.shift() + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas George John,Thomas slice() 描述：slice() 方法可从已有的数组中返回选定的元素 arrayObject.slice(start,end) start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end: 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 应用：创建一个新数组，然后显示从其中选取的元素 exp: &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) //截取数组的2-4位（注意数组下标从0开始） document.write(arr.slice(2,4) + &quot;&lt;br /&gt;&quot;) document.write(arr) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin Thomas,James George,John,Thomas,James,Adrew,Martin sort() 描述：用于对数组的元素进行排序 arrayObject.sort(sortby) sortby 可选。规定排序顺序。必须是函数。 返回值为对数组的引用。请注意，数组在原数组上进行排序，不生成副本 参数说明：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。若 a 等于 b，则返回 0。若 a 大于 b，则返回一个大于 0 的值。 应用：创建一个数组，并按字母顺序进行排序 exp1： &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.sort()) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin Adrew,George,James,John,Martin,Thomas exp2:实现对多位数的排序（利用排序函数作为参数） &lt;script type=&quot;text/javascript&quot;&gt; function sortNumber(a,b) { return a - b } var arr = new Array(6) arr[0] = &quot;10&quot; arr[1] = &quot;5&quot; arr[2] = &quot;40&quot; arr[3] = &quot;25&quot; arr[4] = &quot;1000&quot; arr[5] = &quot;1&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) document.write(arr.sort(sortNumber)) &lt;/script&gt; 如果不写该函数作为参数，只会对多位数的第一位以ASCII码进行排序，无法实现多位数排序 splice() 描述：splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 该方法会改变原始数组 arrayObject.splice(index,howmany,item1,…..,itemX) index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX 可选。向数组添加的新项目。 请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 应用： exp1:创建一个新数组，并向其添加/删除一个元素 &lt;script type=&quot;text/javascript&quot;&gt; var arr = new Array(6) arr[0] = &quot;George&quot; arr[1] = &quot;John&quot; arr[2] = &quot;Thomas&quot; arr[3] = &quot;James&quot; arr[4] = &quot;Adrew&quot; arr[5] = &quot;Martin&quot; document.write(arr + &quot;&lt;br /&gt;&quot;) //从第二个位置修改，&quot;howmany&quot;参数为0择不删除，第三个参数为要添加的元素 arr.splice(2,0,&quot;William&quot;) document.write(arr + &quot;&lt;br /&gt;&quot;) &lt;/script&gt; 输出： George,John,Thomas,James,Adrew,Martin George,John,William,Thomas,James,Adrew,Martin exp2：删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素 var arr = new Array(6) arr[0] = "George" arr[1] = "John" arr[2] = "Thomas" arr[3] = "James" arr[4] = "Adrew" arr[5] = "Martin" document.write(arr + "") arr.splice(2,1,"William") document.write(arr) 输出： George,John,Thomas,James,Adrew,Martin George,John,William,James,Adrew,Martin exp3:删除从 index 2 (“Thomas”) 开始的三个元素，并添加一个新元素 (“William”) 来替代被删除的元素 var arr = new Array(6) arr[0] = "George" arr[1] = "John" arr[2] = "Thomas" arr[3] = "James" arr[4] = "Adrew" arr[5] = "Martin" document.write(arr + "") arr.splice(2,3,"William") document.write(arr) 输出： George,John,Thomas,James,Adrew,Martin George,John,William,Martin unshift 描述：可向数组的开头添加一个或更多元素，并返回新的长度 arrayObject.unshift(newelement1,newelement2,….,newelementX) newelement1 必需。向数组添加的第一个元素。 newelement2 可选。向数组添加的第二个元素。 newelementX 可选。可添加若干个元素。 说明：unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。 请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。 请注意，unshift() 方法无法在 Internet Explorer 中正确地工作！ 应用：创建一个数组，并把一个元素添加到数组的开头，并返回数组的新长度 exp: var arr = new Array() arr[0] = "George" arr[1] = "John" arr[2] = "Thomas" document.write(arr + "") document.write(arr.unshift("William") + "") document.write(arr) 输出： George,John,Thomas 4 William,George,John,Thomas 一些不常用的方法 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 valueOf() 返回数组对象的原始值 说明以上内容均来自W3Cschool，我是为了加深印象，巩固一下知识点。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS代码段所放位置的区别]]></title>
    <url>%2F2018%2F10%2F19%2FJS%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%89%80%E6%94%BE%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言在很久之前就遇到了这个问题，由于代码段放的位置不对导致代码段无法生效。所以这次就简单写一下代码段不同位置的区别。 正文 JavaScriptJS是一种解释性脚本（不进行预编译） 高级语言的两种翻译方式： 编译 以基本的C语言为例，大部分语言是直接通过编译器将高级语言编译成为机器可以懂的机器语言（二进制文件 .exe）。但是也有不一样的，比如JAVA这种跨平台语言，它是将高级语言先编译成为JAVA虚拟机能够识别的class文件，在不同的平台上再编译为相应的机器语言，实现跨平台。 解释 解释性脚本脚本不需要编译，在执行时才进行解释。解释性脚本语言有专门的解释器，不过每次执行时都需要编译，所以效率比较低。 JavaScript也有自己的解释器–JavaScript引擎，他是浏览器的一部分。 HTML 语言的执行顺序作为一门解释性脚本语言，它的执行顺序是从前到后顺序执行。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Html页面内容执行顺序&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var userId = $(&apos;#hiddenUserId&apos;).val(); var contextPath = $(&apos;#hiddenContextPath&apos;).val(); var userName = $(&apos;#hiddenUserName&apos;).val(); alert(userName); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 按照顺序执行，先解析该文档为HTML文档，接着解析head部分的script脚本，head部分的style样式，接着渲染body部分，接着解析body中的script脚本。 按照以上顺序，我就可以理解为什么我上一次引用的验证码脚本以及vue框架放在HTML中head部分时，无法生效。原因是在于如果将脚本放在head中，script脚本执行时DOM树还没有被渲染，所以脚本是无法执行对DOM进行修改的。而如果将脚本放在body尾部，执行此脚本时，DOM树已被渲染完毕，所以可执行修改操作。 结论1.head中所放的JavaScript代码段主要功能应该是不会在页面加载时就进行执行的脚本功能，即后续通过其他操作触发的（比如onclik按键触发），这类脚本可以预先解释，在需要时再执行 2.body后面放的脚本应该是页面加载时就要触发的脚本，比如对DOM数内容的初始化（向上面的验证码系统，vue的脚本） 特殊情况以下情况可以改变JS代码的执行顺序 window.onload:等到页面中的所有内容加载完成后才会执行。 $(document).ready():页面中所有的DOM结构绘制完成后就能够执行。 script脚本中，大部分浏览器支持async和defer属性。 async表示的意思是异步加载JavaScript文件，它的下载过程可以在HTML的解析过程中进行，加载完成之后立即执行这个文件的代码，执行文件代码的过程中会阻塞HTML的解析，它不保证文件加载的顺序。 defer表示的意思是在HTML文档解析之后在执行加载完成的JavaScript文件，JavaScript文件的下载过程可以在HTML的解析过程中进行，它是按照script标签的先后顺序来加载文件的。 参考资料： 1.把JavaScript文件放在文档的头部还是尾部 2.CSS、JS 放置位置与前端性能的关系？ 3.HTML页面的加载顺序]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-js基本用法解析]]></title>
    <url>%2F2018%2F09%2F22%2Fnode-js%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言 为什么会想到搞一下node呢，emmmm，主要是之前想收图片，每个人4张，一共几十个人，如果都通过qq发过来那简直市场噩梦（虽然我最后还是经历了这擦会给你噩梦），所以下定决心要搞一下后端的东西，PHP，ASP学习成本有点高，速成还是有点难，所以我想到了node.js这个神奇的东西，用js的语言来写后端的东西，nice哦。所以就有了这篇文章。 正文EventEmitter模块这个模块可以说是node中一个核心的模块，包括fs，http，net等模块的事件都是继承自该模块，若不使用继承的方法，其基本用法是： //引入events模块 var eventEmitter = require(&apos;events&apos;); //创建eventEmitter var events = new events.EventEmitter(); event.on(&apos;some_event1&apos;,function(){ console.log(&quot;监听器1执行&quot;); }) event.addListener(&apos;some_event2&apos;,function(){ console.log(&quot;监听器2执行&quot;); }) event.removeListener(&apos;some_event1&apos;,function(){ console.log(&quot;监听器1移除&quot;); }) event.emit(&apos;some_event1&apos;); 这是一些基本的用法，不过这个方法在平时不怎么用，所以了解一下就ok了。 文件系统fs异步与同步由于node是基于JS，所以异步与同步是不可回避的一个问题，在之前的博文中，我们也解析过JS的异步与同步操作，这里不再赘述。而node中文件操作是同时支持异步与同步操作，具体区别这里也不再赘述。 异步与同步代码var fs = require(&apos;fs&apos;); //异步读取 fs.readFile(&apos;input.txt&apos;,function(err,data){ if(err){ return console.error(err); } console.log(&apos;异步读取&apos;+data.toString()); }); //同步读取 var data = fs.readFileSync(&apos;input.txt&apos;); console.log(&quot;同步读取：&quot;+dataString()); console.log(&apos;文件操作完毕&apos;); 注意这里是展示同步与异步的代码区别，一般是在操作代码后加上“Sync”(同步)，但一般我们并不使用这种同步的方法，因为在文件大一点的时候这会严重影响代码执行的效率。 打开文件语法格式 fs.open(path,flag,callback) 参数 path-文件路径 flag-文件打开的模式 callback-回调函数，该函数带有两个参数（err,fd），err-&gt;错误，fd-fileData，文件内容及信息 下面是flag的参数及其说明 获取文件信息语法格式 fs.stat(path,callback) 参数 path-文件路径 call-回调函数 var fs = require(&apos;fs&apos;); fs.stat(&apos;/Users/liuht/code/itbilu/demo/fs.js&apos;, function (err, stats) { console.log(stats.isFile()); //true }) 下面是该类中的方法： 写入文件语法格式 fs.writeFile(file,data[,option],callback) 参数 file-文件名或文件描述 data-要写入的数据，可以是字符串（String）或缓冲变量（Buffer）对象 option-该参数是一个对象，包含{encoding,mode,flag}。默认为{utf8,0666,w} callback-回调函数（仅包含err，在写入失败时返回） var fs = require(&apos;fs&apos;); console.log(&apos;准备写入文件&apos;); fs.writeFile(&apos;input.txt&apos;,&apos;我是通过fs.file写入的内容&apos;,function(err){ return console.log(err); } console.log(&apos;数据写入成功！&apos;); console.log(&apos;读取写入的数据!&apos;); fs.readFile(&apos;input.txt&apos;,function(err,data){ if(err){ return console.log(err);} console.log(&apos;读取文件内容：&apos;+data.toString()); }); }); 这是代码执行效果： $ node file.js 准备写入文件 数据写入成功！ 读取写入的数据！ 异步读取文件数据: 我是通 过fs.writeFile 写入文件的内容 读取文件语法格式 fs.readFile(fd,buffer,offset,length,position,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 buffer - 数据写入的缓冲区。 offset - 缓冲区写入的写入偏移量。 length - 要从文件中读取的字节数。 position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。 callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。 var fs = require(&quot;fs&quot;); var buf = new Buffer.alloc(1024); console.log(&quot;准备打开已存在的文件！&quot;); fs.open(&apos;input.txt&apos;, &apos;r+&apos;, function(err, fd) { if (err) { return console.error(err); } console.log(&quot;文件打开成功！&quot;); console.log(&quot;准备读取文件：&quot;); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){ if (err){ console.log(err); } console.log(bytes + &quot; 字节被读取&quot;); // 仅输出读取的字节 if(bytes &gt; 0){ console.log(buf.slice(0, bytes).toString()); } }); }); 下面是代码执行效果： $ node file.js 准备打开已存在的文件！ 文件打开成功！ 准备读取文件： 25 字节被读取 This is a test inputtxt 关闭文件fs.close(fd,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 callback - 回调函数，没有参数。 fs.close(fd, function(err){ if (err){ console.log(err); } console.log(&quot;文件关闭成功&quot;); 截取文件fs.ftruncate(fd,len,callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 len - 文件内容截取的长度。 callback - 回调函数，没有参数（但含有err参数）。 fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){ if (err){ console.log(err); } // 仅输出读取的字节 if(bytes &gt; 0){ console.log(buf.slice(0, bytes).toString()); } 删除文件fs.unlink(path,callback) 参数 path-路径 callback-回调函数，没有参数（但含有err参数） 实例 var fs = require(&apos;fs&apos;); console.log(&apos;开始删除文件！&apos;); fs.unlink(&apos;input.txt&apos;,function(err){ if(err){ return console.log(err); } console.log(&quot;删除成功！&quot;); }) 创建目录fs.mkdir(path,[,mode],callback) 参数 path - 文件路径。 mode - 设置目录权限，默认为 0777。 callback - 回调函数，没有参数。 实例 var fs = require(&apos;fs&apos;); console.log(&apos;创建目录 /tmp/test/&apos;); fs.mkdir(&quot;/tmp/test/&quot;,function(err){ if(err){ return console.log(err); } console.log(&apos;目录创建成功&apos;); }) 这是执行效果 $ node file.js 创建目录 /tmp/test/ 目录创建成功。 ###读取目录###语法 fs.readdir(path,callback) 参数 path - 文件路径。 callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。 实例 var fs = require(&quot;fs&quot;); console.log(&quot;查看 /tmp 目录&quot;); fs.readdir(&quot;/tmp/&quot;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); 执行效果 $ node file.js 查看 /tmp 目录 input.out output.out test test.txt ###删除目录### 语法 fs.rmdir(path,callback) 实例 var fs = require(&quot;fs&quot;); // 执行前创建一个空的 /tmp/test 目录 console.log(&quot;准备删除目录 /tmp/test&quot;); fs.rmdir(&quot;/tmp/test&quot;,function(err){ if (err) { return console.error(err); } console.log(&quot;读取 /tmp 目录&quot;); fs.readdir(&quot;/tmp/&quot;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); }); 执行效果： $ node file.js 准备删除目录 /tmp/test 读取 /tmp 目录 …… 文件模块还有很多方法，具体可以参见node.js官方文档 http模块http模块一般是使用createServer方法来创建服务器，下面是不使用html文件的代码： //获取http方法并定义到变量 var http = require(&apos;http&apos;); http.createServer(function(req,res){ res.writeHead(400,{&apos;Content-Type&apos;:&apos;text/html&apos;}) res.end(&quot;This is a test&quot;); }).listen(3000); console.log(&quot;server running at http://127.0.0.1:3000/&quot;); 这个代码执行后会在网页上显示This is a test 的字样。 下面是使用html文件来作为网页显示： var http = require(&apos;require&apos;); var fs = require(&apos;fs&apos;); var url = require(&apos;&apos;); //创建服务器 http.createServer(function(req,res){ //解析请求，包括文件名 var pathname = url.parse(req.url).pathname; //从文件系统中请求文件内容 console.log(&apos;request for&apos;+pathname+&apos;received&apos;); fs.readFile(pathname.substr(1),function(err,data){ if(err){ console.lor(err); //发送404（未查找到文件）HTTP状态码并规定解析文件为html文件 res.writeHead(404,{&apos;Content-Type&apos;:&apos;text/html&apos;}); }else{ //发送200（正常）HTTP状态码并规定解析文件为html res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;}); //响应文件内容 res.write(data.toString()); }) res.end(); }).listen(3000); console.log(&quot;Server running at http://127.0.0.1:3000/&quot;); index文件： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 执行上面JS代码，并在浏览器中填入：http://127.0.0.1:8080/index.html，就会显示出index.html网页内容。 url及post和get请求url是指请求的地址，其中不仅包含路径，还了可以包含多个参数，如下图，网址‘http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&#39; 以下代码可以从url中获取相关的参数： var http = require(&apos;http&apos;); var url = require(&apos;url&apos;); var util = require(&apos;util&apos;); http.createServer(function(req,res){ res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html&apos;;&apos;charset=utf-8&apos;}); res.end(util.inspect(url.parse(req.url,true))); }).listen(3000); 其效果： 其中util模块是一个工具模块，提供了很多功能，其中util.inspect(object[,options]),这里option的选项很多，这里不再展开叙述。其作用是一个将任意对象转换 为字符串的方法,通常用于调试和错误输出。 将url中的属性值提取出来， var http = require(&apos;http&apos;); var url = require(&apos;url&apos;); var util = require(&apos;util&apos;); http.createServer(function(req,res){ res.writeHead(200,{&apos;Conten-Type&apos;:&apos;text/plain&apos;}); var params = url.parse(req.url,true).query; res.write(&quot;网站名：&quot;+params.name); res.write(&quot;\n&quot;); res.write(&quot;网站URL：&quot;params.url); res.end(); }).listen(3000); 效果： 获取表单数据 var http = require(&apos;http&apos;); var querystring = require(&apos;querystring&apos;); var postHTML = &apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;&apos; + &apos;&lt;body&gt;&apos; + &apos;&lt;form method=&quot;post&quot;&gt;&apos; + &apos;网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;&apos; + &apos;网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;&apos; + &apos;&lt;input type=&quot;submit&quot;&gt;&apos; + &apos;&lt;/form&gt;&apos; + &apos;&lt;/body&gt;&lt;/html&gt;&apos;; http.createServer(function (req, res) { var body = &quot;&quot;; req.on(&apos;data&apos;, function (chunk) { body += chunk; }); req.on(&apos;end&apos;, function () { // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/html; charset=utf8&apos;}); if(body.name &amp;&amp; body.url) { // 输出提交的数据 res.write(&quot;网站名：&quot; + body.name); res.write(&quot;&lt;br&gt;&quot;); res.write(&quot;网站 URL：&quot; + body.url); } else { // 输出表单 res.write(postHTML); } res.end(); }); }).listen(3000); 其效果如图： 将表单提交的数据利用express框架获取表单内容var express = require(&apos;express&apos;); var app = express(); //将文件夹public设为express公开文件夹(express模块已经将fs方法至于其中，因此在设置公开文件夹时不需再引用fs模块)。 app.use(express.static(&apos;public&apos;)); app.get(&apos;/index.html&apos;,function(req,res){ res.sendFile(_dirname+&apos;/&apos;+&apos;index.html&apos;); }) app.get(&apos;/process_get&apos;,function(req,res){ var response = { &quot;first_name&quot;:req.query.first_name, &quot;last_name&quot;:req.query.last_name }; console.log(response); res.end(JSON.stringify(response)); }); var server = app.listen(8081,function(req,res){ var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port); }); html代码： &lt;html&gt; &lt;body&gt; &lt;form action=&quot;http://127.0.0.1:8081/process_get&quot; method=&quot;GET&quot;&gt; First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt; &lt;br&gt; Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 效果如图： express模块是一个web应用框架，他提供了很多强大的功能来更简单的创建web应用。 利用express及multer来实现文件的上传multer模块主要处理表单文件的上传。 var express = require(&apos;express&apos;); var multer = require(&apos;multer&apos;); var app = express(); app.use(express.static(&apos;public&apos;)); // 通过 filename 属性定制 var storage = multer.diskStorage({ destination: function (req, file, cb) { cb(null, &apos;/web开发/测试/upload&apos;); // 保存的路径，备注：需要自己创建 }, filename: function (req, file, cb) { // 将保存文件名设置为 字段名 + 时间戳+后缀，比如 logo-1478521468943 cb(null, file.fieldname + &apos;-&apos; + Date.now()+&apos;.jpg&apos;); } }); // 通过 storage 选项来对 上传行为 进行定制化 var upload = multer({ storage: storage }) //var upload = multer({dest : &apos;upload/&apos; }); //var upload = multer({storage:storage}); app.get(&apos;/index&apos;,function(req,res){ res.send(_dirname+&quot;/&quot;+&quot;index.html&quot;); }) //single中的第二个参数代表可以接受几个文件，2代表可以接受两个文件 app.post(&apos;/upload&apos;,upload.single(&apos;pics，2&apos;),function(req,res){ res.send(&quot;ok&quot;); }) var server=app.listen(3030,function(){ var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) }) 上面这段代码可以实现文件的上传并将其放在规定的文件夹及其规律化的命名： html代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!-- &lt;span&gt;first item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;first_item&quot;&gt;&lt;br/&gt; &lt;span&gt;second item&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;second_item&quot;&gt;&lt;br/&gt; --&gt; &lt;span&gt;file&lt;/span&gt;&lt;input type=&quot;file&quot; name=&quot;pics&quot;&gt;&lt;br/&gt; &lt;/be/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 最后终于把这个简单的文章写完了，这只是node的冰山一角，node还有很多模块及其方法，想要精通段时间内几乎是不可能的，后面还是要继续努力xio习啊！ 引用 菜鸟教程 Nodejs进阶：基于express+multer的文件上传]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千万不要躺太久-三和大神的生活]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E8%BA%BA%E5%A4%AA%E4%B9%85-%E4%B8%89%E5%92%8C%E5%A4%A7%E7%A5%9E%E7%9A%84%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[三和大神“三和大神”是一群平凡而又特殊的工人，平凡在于他们也是干活领工资，也在人才市场找工作。特殊在于他们的工作信仰与普通的工人不同，他们的理念是“干一天，玩三天”，只要身上有钱，就不去工作，什么时候口袋空了，什么时候就去工作。 三和大神的贫瘠生活经济的贫瘠“干一天玩三天”，这就是三和大神所信奉的生活状态，那这一天挣多少呢？ –大约86元人民币 接下来的三天就可以过着自由的生活，安逸的躺在十几元的廉价旅馆中，把已经发霉的被子盖在身上，闻着各种习以为常的异味，连着WiFi刷着破损的手机，吃着4元一碗的挂逼面，喝着1元一瓶的挂逼水，或者是在1元一小时的网吧中玩上两天。在身上已经没有钱够吃一碗挂逼面时，又站起来去到“人才市场”干一天。 精神的贫瘠干完这一天又回到那家小旅馆，躺下…… 这样一个又一个的循环，他们生活里毫无波澜，仿佛一滩没有生命的死水，唯一能激起一圈涟漪的应该就是兜里没有钱时，又要去干一天的无奈。他们希望通过网络弥补现实生活的贫瘠，在手机中看着这个明星又出轨了，那个人扶老奶奶又被讹了，他们手指迅速点击着屏幕，批判这个明星的生活作风太差，指责这个社会的黑暗，没有好人了。或者在游戏中虐一下对手，或者嘲讽一下对手，或者夸耀一下自己，将自己想象为游戏角色，以此拾得自己早已丢失在生活中自豪感。 然后又到了工作的那一天，他们将自己的精神冻结起来，以一种自我麻痹的状态完成工作，然后又回到网络上，拾回自己的精神，他们不敢把自己的精神带回到现实生活，因为他们不敢面对那个真实的自己，那个一无所有的自己，那个毫无地位的自己。 感情的贫瘠在“三和大神”的行列中，感情似乎是一件不可望更不可及的东西，没有亲人或者亲人根本不联系，更别提爱情，不想要更不需要，一人吃饱全家喝足的状态，这样毫无牵挂，似乎完全没有必要再在社会中跌跟头了，一直躺在地上就挺舒服。 他们为什么到这一步？每个人自来到这个世界，都不甘于低于别人，那为什么“三和大神”会甘于这样的生活？ 对生活失去希望宋春江，27岁迈入大神的行列，中专学习的服装和电脑，本以为毕业后可以找个好工作，有个温馨的家庭，平静的生活。可学校分配的工作是做流水线工人，早上7点工作到晚上11点甚至更晚。刚毕业那会还觉得有机会，七八年后，他已不再想过日子，这期间他也从流水线工人变成了标准的“三合大神”。过着“干一天玩三天”的生活。是什么让他成为了“三和大神”？—失去生活的希望 流水线的工作，无限制的循环一件事情，似乎完全看不见自己的未来，还是带着每日全身的疲倦，与其如此，不如过着“三和大神”的生活来的实在，累一天“舒服”三天。 误入歧途 东东，22岁，来自农村，因为上班时打瞌睡被老板娘说了几句就辞职来到三和，住进了15元一晚的宾馆。开始“三和大神”的生活。 躺下太久就站不起来了！ 对于“三和大神”，我感到的不是同情，而是可怜，甚至是可笑，所有的一切不过都是自己不想站起来的原因罢了！不过是自己懒惰的借口！我们不得不承认社会的不公，你也许永远无法成为王健林，马云，但你是可以靠自己的努力让你过上普通人的生活。觉得自己的工作没希望就换个有希望的工作，找不到就去学习。这中国这片土地上永远不缺可供学习的地方。唯一缺的是愿意一心一意去学习的人。所谓的“三和大神”不过是那些受不了现实的打击或承受不了现实的打磨，倒在路上的一群人！他们甘愿倒在半路！他们甘愿走在社会的最低层！那么这就是不会被同情的，因为是他们自己选择了自己的道路，不是别人，更不是这个社会！“讨厌长期劳动，喜欢日结”不过是自己不愿努力的掩饰罢了，就如同“讨厌站起来，喜欢躺在在床上”一样可笑。 我们都一样人性相同其实他们与我们有什么不同？哪一个人不希望每天轻轻松松，什么都不干，不去承受，不去负担。这种人性的弱点是始终存在的。即使是再伟大的人，也会有偷懒的想法。古代的皇帝，每天翻阅奏章，管理国家大事，几乎所有的大事都会通过皇帝的脑袋，难道他不想随便完成然后去后宫吃喝玩乐？如今的富商哪一个不是每天满满的日程，用尽心思的去经营自己的生意，难道他们不想停下来休息一下？芸芸众生谁不辛苦？谁生活在温室中？谁不想停下来“躺在地上”？但我们没有那么做，因为“躺下太久，就站不起来了”！ 选择不同但我们的选择不同，我们选择了站起来，继续前进。现实一次又一次的将我们击倒，但仍然有人站起来，继续前进！“三和大神”就是被击倒后站不起来的那一群人。他们倒下后发现原来躺着是这么舒服啊，那就别站起来了，干脆做他一场黄粱大梦，或在梦中，或在网络中。 请不要躺太久！请不要躺太久，以至于忘记如何站立！不管自己的梦想是否遥远，都请一直走下去，因为至少你可以更清晰的看见自己的梦想啊。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>社会</tag>
        <tag>见解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个简单的个人博客（2）代码开发（利用localStorage保存数据）]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%89%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%EF%BC%88%E5%88%A9%E7%94%A8localStorage%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言这个小项目花了我大概10天的时间（每天5h左右），可以说是很慢了，主要是JS的很多知识点不熟悉，边研究边开发。而且数据库部分仍然时使用本地存储，也就是说这个案例是无法投入到实际使用中，但后面我会去研究一下mysql，在服务器端部署一个小型的数据库，估计不会花太长时间，另外觉得node.js挺有意思，hexo就是基于node.js，将JS用于与计算机系统的直接沟通，That`s cool，本来我的原计划是将博客信息存储在本地文件中，比如直接在本地存储一个JSON文件用来存储一篇博客，后来发现这个是实现不了的，因为浏览器内核无法与系统直接沟通，内核是在浏览器提供的一个BOX中运行，无法直接操作系统文件，emmmm，可能这也是为系统安全把，不然随便一个恶意网页就可以操作你的文件，This is unimaginative。也是因为这个所以才有了node.js的诞生的吧！ 正文BB了那么久，咳咳，进入正题。 首页 布局过后首页上半部分是这样，和当初的设计差不多。整个上半部分是一个轮播图。 var i=0; setInterval(function(){ if(i&lt;4) { i++; $(document).ready(function(){ $(&quot;.item&quot;).eq(i).fadeIn(2000).siblings().fadeOut(2000); }); } else { $(document).ready(function(){ $(&quot;.item&quot;).eq(3).fadeIn(2000).siblings().fadeOut(2000); }); i=-1; } //console.log(i); }, 4000); 用了jquery的fadeIn,fadeOut方法，由于没有按钮使代码很简单，只用了十多行代码。唯一有问题的最后一张图片与第一张总是相差设定时间的2倍，想了许多办法没有解决，我就直接班另一张图片插入到最后一张与第一张的间隔之间，这样就实现图片的播放速度是均匀的，但问题是不循环播放的，有一张图片要多出现一次。 顶部分别是home，catalogue，和login的链接，左半部分有博主本人的logo。 点击logo可以将其大部分隐藏到屏幕外侧，like this， 再次点击边缘部分，可再次点击召唤出logo &lt;- &lt;-其原理也很简单，只是利用了jquery的动画方法， animate（） 布局方面整个上半部分设计简单，只用了原生的CSS与html完成。 下半部分是文章展示部分，我是在首页设置了几篇置顶文章，具体方法是直接在在html文档中写入写入这一部分代码，不是JS后期插入到文档中，然后下面是使用JS写入的文章部分，这些文章都是存储在数据库中的部分，并且可以在article页面查看。具体实现方式是在写入博客时将博客的title，date，tags，article写入到一个对象中，再JSON化写入本地（这里JSON化的原因在上期关于localStorage的介绍中已经写到，主要原因是localStorage只能存储string要想保留格式，JSON化是一种比较好的办法）。然后在首页读取数据再JSON.parse，在格式插入到文档中。 另外在首页还需要解决问题就是将文章序号传输到文章展示页面，因为当点击文章标题或more时，需要跳转至文章展示页面，展示该文章。我所想到的解决办法是在添加文章到首页文档流中时就把序号写入放置该文章的div的id的尾部，传输到展示页面时再通过this关键字读取id关键字（在测试中我也发现this无法获取class属性的值，原因我正在探索中，后面会出一起专门关于this的文章），并通过charAt()获取该序号，然后通过URL传值的方法将其传递到展示页面。 展示页面 文章展示页面提供问文章的全面展示，并且提供评论功能。（本来是打算在首页也只展示文章的部分，后来感觉有点麻烦，看后面有时间了再实现）。 接上面首页传输文章序号到展示页面，展示页面通过函数解析序号，这个函数我实用的网上的一个模板，代码如下。 UrlParm = function() { // url参数 var data, index; (function init() { data = []; index = {}; var u = window.location.search.substr(1); if (u != &apos;&apos;) { var parms = decodeURIComponent(u).split(&apos;&amp;&apos;); for (var i = 0, len = parms.length; i &lt; len; i++) { if (parms[i] != &apos;&apos;) { var p = parms[i].split(&quot;=&quot;); if (p.length == 1 || (p.length == 2 &amp;&amp; p[1] == &apos;&apos;)) {// p | p= data.push([&apos;&apos;]); index[p[0]] = data.length - 1; } else if (typeof(p[0]) == &apos;undefined&apos; || p[0] == &apos;&apos;) { // =c | = data[0] = [p[1]]; } else if (typeof(index[p[0]]) == &apos;undefined&apos;) { // c=aaa data.push([p[1]]); index[p[0]] = data.length - 1; } else {// c=aaa data[index[p[0]]].push(p[1]); } } } } })(); return { // 获得参数,类似request.getParameter() parm : function(o) { // o: 参数名或者参数次序 try { return (typeof(o) == &apos;number&apos; ? data[o][0] : data[index[o]][0]); } catch (e) { } }, //获得参数组, 类似request.getParameterValues() parmValues : function(o) { // o: 参数名或者参数次序 try { return (typeof(o) == &apos;number&apos; ? data[o] : data[index[o]]); } catch (e) {} }, //是否含有parmName参数 hasParm : function(parmName) { return typeof(parmName) == &apos;string&apos; ? typeof(index[parmName]) != &apos;undefined&apos; : false; }, // 获得参数Map ,类似request.getParameterMap() parmMap : function() { var map = {}; try { for (var p in index) { map[p] = data[index[p]]; } } catch (e) {} return map; } } }(); 有点长，权当备份一下，后面在分析这个函数。 展示页面解析到文章序号后，展示函数直接通过读取数据库读取到数据添加到文档流中。 评论部分的实现也比较简单，通过读取文档中用户输入的信息并将其重新写入该文章数据库中的JSON中，展示时自动展示出来。 目录页面 目录页面展示了所有通过JS放入数据库的文章（不包括首页置顶文章）。 这里的实现就是直接遍历数据库中的博客文章信息，因为当时存储时是格式命名的，所以遍历很简单，再把title循环添加到文档流中就ok了。 登录及后台管理页面 登录页面使用MD5加密方式，与本地存储的密匙（未来的密匙存储在服务器端）进行对比。 这里是在登录过后显示页面，首先这里布局还是用了frame框架，我暂时还没想到更好的替代办法，虽然frame在H5已被抛弃。 在写博客页面，用户将自己的文章内容输入，然后提交，文章内容会被JSON化后被保存到数据库，下次进入首页时就会直接被展示出来。 删改页面也是遍历数据库，直接修改数据库内容就好了，还是比较简单了，具体过程就不再赘述。 最后的工具页面是我想没事可以自己开发一些简单的工具，比如什么颜色拾取等等，这也是后话。 最后其实这个小项目还是比较简单，代码量也不是很大，主要是练一下手，熟悉以一下前端的一些知识，当然这个小项目还有很多不足需要满足，包括在代码规范等等,方便后面的深入学习。当然后面在学习玩数据库后会把本地数据库改为服务器端的数据库，使之可以实际运行。]]></content>
      <categories>
        <category>博客开发系列</category>
      </categories>
      <tags>
        <tag>博客开发</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JS单线程，异步执行的理解]]></title>
    <url>%2F2018%2F08%2F22%2F%E5%85%B3%E4%BA%8EJS%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言在这几天的开发过程中，遇到了不少问题，阻塞最久的应该就是一段JS代码没有按照我以为的执行顺序去执行，想想好像也没有具体的了解JS的执行过程，所以花了一整天的时间来了解了一下JS的执行机制。 问题代码for(var i=0;i&lt;=3;i++){ $(document).ready(function){ console.log(i); }); 出现问题的代码简化过后大概是这个样式，我的预期是输出1，2，3，但输出的结果却为3,3,3，我开始以为是JS单线程执行的缘故，所以Jquery代码被放在了callback queue（任务队列）的最后执行，但我查询资料后发现仅发现浏览器会为定时器，ajax等多开线程，jquery应该不算，正在我疑惑之时，我打开了Jquery的官方文档，看到了 $(document).ready(function(){});的定义：文档准备完成后，内部的匿名函数作为document(ready)的回调函数进行执行，而此时for早已进行玩了。这就解释了为什么都是3,3,3。 正文从浏览器谈起浏览器的进程与线程浏览器是多进程的 Browser进程：负责浏览器的主进程（协调，主控）。 第三方插件进程：每一个插件对应一个进程。 GPU进程：用于绘制3D图形等。 浏览器渲染进程 （render进程，浏览器内核）：每一个Tab页面一个进程，这个进程渲染我们所看到的每个页面。 浏览器渲染进程是多线程的前面我们说到我们所看到的页面都是有渲染进程进行渲染的，而他又是多线程的： GUI渲染线程（浏览器内核） 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发进程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 进入正题，JS的执行过程js的同步任务和异步任务 所有同步任务（能够立即被执行，不消耗时间的任务，如变量核函数的初始化，时间的绑定等等不需要回调函数的任务）都在主线程中执行，形成执行栈（stack），heap（堆）用来存储变量，对象等。 所有异步任务（一半会有操作，如点击事件，定时事件，具有回调函数的事件）运行在事件触发线程中，当异步任务有结果是，其回调函数（Callback Function）就会被放到任务队列中，等待执行。 当执行栈中同步任务执行完毕后， JS引擎就会从任务队列中（callback queue）中查找任务放入执行栈中，这个过程就被称之为事件循环event loop。 从上面的解释中可以看到JS引擎始终是在执行栈中单线程执行任务，当执行栈空时，接下来的任务才回从任务队列中读取下一任务。 何为异步 所谓的异步，就是在其他线程（事件触发线程，异步http请求线程等）的辅助下，JS线程实现异步处理任务。举个栗子： consloe.log(&quot;a&quot;) setTimeout(function() { console.log(&quot;b&quot;) }, 0) console.log(&quot;c&quot;) 模拟其运行过程： 1.consloe.log(&quot;a&quot;)// JS引擎发现这是一个同步任务，立即执行打印出a; 2.setTimeout(function() { console.log(&quot;b&quot;) }, 0)//JS引擎只想此处时发现这是一个异步任务，所以直接交由定时触发线程。 JS引擎继续向下执行，与此同时，定时触发线程接收到该事件，解析代码过后， 将在0毫秒实际是4毫秒，因为在上面我们讲到，W3C规定定时引擎的最低时间为4毫秒）后向JS引擎发送 回调函数，并将其推到任务队列中等待执行。 3.console.log(&quot;c&quot;)//再向定时引擎发送定时事件后立即执行该代码。打印出c。 4.定时引擎将console.log(&quot;b&quot;)推入任务队 列，在console.log（&quot;c&quot;）运行完成后，执行栈空，再将其推入执行栈，然后执console.log(&quot;c&quot;)， 打印出c,因此这段代码输出的结果为a,c,b,而不是a,b,c. 注意，即使setTimeout不是4毫秒后，而是0毫秒后返回回调函数，执行结果任然是a,c,b。因为这是一个排队的过程，console.log(“b”)任是排在console.log(“c”)之后的。 由此，一个异步任务就在JS引擎与其他线程的共同作用下完成了。 参考资料从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 js的单线程和异步 JavaScript单线程和异步机制 最后这只是一个简单的理解，其中还有许多部分可能没有完善，等以后有更深的理解时再来完善吧。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用SS（Shadowsocks）快速搭建一个vpn]]></title>
    <url>%2F2018%2F08%2F20%2F%E5%88%A9%E7%94%A8SS%EF%BC%88Shadowsocks%EF%BC%89%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAvpn%2F</url>
    <content type="text"><![CDATA[前言前几天玩kali时发现需要下一个插件，但是需要科学上网，无奈打开之前的vpn软件，发现几乎都关闭了服务，于是我就诞生了自己搭建一个vpn的想法，于是在参考了网上的教程后，折腾了一上午终于成功了。 正文一，购买服务器（vps）国外的服务器提供商比较多，比如DigtaOcean，Vultr，Amazon等等，我选择了Vultr，因为它提供的vps价格最低的一款仅2.5$/月（后来才发现是个坑，后人谨记），其实DigtaOcean也还不错，绑定信用卡就送10刀，而他价格最低的一款vps价格为5刀，相当于是说送你两个月的体验时间，Amazon好像开可以免费体验一年，所以选择服务器时要多方考虑一下，地点我们尽量选在米国，具体速度我没有测试过。注意：千万不要选择2.5刀那款服务器，因为它只有一个ipv6的地址，是无法用来搭建的（具体原因我没有深入探索，但估计也是，不是所有的服务都兼容ipv6，购买这款服务器时官方也会有提示），所以我们选择5刀的那款，系统选择Ubuntu，当然其他的也是可以的。但我们在后面还是把enable ipv6勾上，为我们分配一个ipv6的地址。label和hostname是你自己的信息。至此，服务器的购买就完成了，等待服务器初始化和开机。 二，连接服务器此时，我们可以在你的控制面板里看到你服务器端的ip地址以及用户名和密码。然后我们需要远程连接到你的服务器，这里我们选择Xshell这款软件。点击文件，新建。在主机输入我们在控制面板中看到的IPV4的地址，之后会提示我们输入用户名及密码，这些信息也都在控制面板中，我就不再截图。 之后我们就会连接上我们的服务器。 然后就输几行代码就ok了。 apt-get install python-pip pip install shadowsocks 两行代码就安装好了ShadowSocks,下面就是配置SS文件 nano /etc/shadowsocks.json nano相比于vim更对Linux新手友好。之后将下面这段代码改为你的账户后粘贴进去。 { “server”:”0.0.0.0”, “server_port”:8388, “local_address”: “127.0.0.1”, “local_port”:1080, “password”:”mypassword”, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”: false } 多账户： { “server”:”0.0.0.0”, “port_password”:{ “8381”:”xxxxxxx”, “8382”:”xxxxxxx”, “8383”:”xxxxxxx”, “8384”:”xxxxxxx” }, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”: false } | 字段 | 说明 || server | ss服务监听地址，0.0.0.0允许所有人访问，如果只是自己用，可以改成自己使用端的ip || server_port | ss服务监听端口 || local_address | 本地的监听地址 || local_port | 本地的监听端口 || password | 密码 || timeout | 超时时间，单位秒 || method | 加密方法，默认是aes-256-cfb || fast_open | 使用TCP_FASTOPEN, true / false || workers | workers数，只支持Unix/Linux系统 | 然后启动服务 ssserver -c /etc/shadowsocks.json -d start 如果需要关闭服务 ssserver -c /etc/shadowsocks.json -d stop 至此，我们服务器端就配置好了，现在就是需要下载shadowsocks连接就ok了。 客户端的使用由于SS在天朝已经GG了，官网已经打不开了，只在github中更新，所以，在这里下载以及查看官方文档。！client 下载完客户端后，输入我们的服务器IP，刚刚在SS中设置端口及密码，点击确定就可以连接到我们的vpn了。 然后就查找学习资料吧~]]></content>
      <categories>
        <category>Shadowsocks</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于JS中localStorage的理解]]></title>
    <url>%2F2018%2F08%2F20%2F%E5%AF%B9%E4%BA%8EJS%E4%B8%ADlocalStorage%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言最近在开发博客的过程中，遇到了数据储存的问题，由于我服务器中还未安装sql，加上我对数据库的操作还不是很熟悉，所以先把数据放入了localStorage中，所以我就具体了解了一下这个本地数据库。 正文前端的存储数据的三种方式前端一般数据存储的方式有三种： cookies sessionStorage localStorage 简单介绍一下这三种方式的异同： cookies与localStorage可以是永久存储（cookies可设置失效时间；用户不主动清除） sessionStorage与localStorage属于H5引入的新标签，在IE8，Chrome4.0等以上才能执行；并且存储空间更大（5MB/站点）相对于cookies（4KB/站点）。具体localStorage的解析 localStorage的优势与局限优势 相对于cookies拓展了空间大小。 相对于sessionStorage，可永久存储信息。 局限 由于是H5引入的属性，可能一些老版的浏览器不支持该属性。 localStorage所存储的信息被限定被string类型，但由于有JSON等对象转换算法，所以也无所谓了。 另外我在网上了解到，localStorage无法被爬虫抓取到，这一点我目前没有深入探究。 localStorage的使用判断浏览器是否支持 localStorage属性if(！window.localStorage){ alert(&quot;您的浏览器不支持localStorage&quot;) return false} else{ //执行代码 } localStorage的写入三种方法： var data=window.localStorage; data[&quot;name&quot;] = MJ;//关键字name写入 data.age = 20;//关键字age的写入 data.setItem = [&quot;shcool&quot;,清华大学];//关键字school写入 注意：前面是将localStorage属性放入了data变量，同样可以不放入变量，直接调用，所以前面的代码等同于: localStorage[&quot;name&quot;]=MJ; localStorage.age=20; localStorage.setItem(&quot;school&quot;,清华大学); localStorage的读取三种方法： var name = localStorage[&quot;name&quot;]; var age = localStorage.age; var school = localStorage.getItem(&quot;school&quot;); 同样想写入方法一样，也可以将localStorage放入变量中在调用。 值得注意的是，官方更推荐使用，setItem与getItem语法，其原因未具体说明，我猜测可能是为了与JS中的对象区分开，更加语言话，不产生混淆 localStorage的删改localStorage改关键字的值其实就是重新为其赋值，即： localStorage.setItem(&quot;name&quot;,MW); var nameAfter=localStorage.getItem(&quot;name&quot;); //nameAfter===MW-&gt;true localStorage的删除： localStorage.clear();//删除改站点的所有localStorage数据 localStorage.removeItem(&quot;name&quot;); //此时localStorage.name-&gt;nudifined 关于存储的数据仅为string的解决办法（JSON数据类型转换）一，写入时转换为JSON格式输入 var person={ name = &quot;MJ&quot;, age = 20, maritalStatus = true } localStorage.setItem(&quot;person&quot;,JSON.string(person)); 二，读取时转换为JS变量 var person =JSON.parse(localStorage.getItem(&quot;person&quot;)); typof(person.age) //typeof检查变量类型为number typeof(person.maritalStstus)//boolean 最后本来写之前感觉有很多注意要写，但写起来感觉哪些之前感觉是注意点的地方其实只是一个普通的点，所以感觉写起来感觉没有太重要的点，但需要注意的点还是有滴，比如三种存储的异同，localStorage存储的数据仅为string等等。ok，就这样把！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>localStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apicloud不同页面传值]]></title>
    <url>%2F2018%2F08%2F13%2FApicloud%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[前言 标准开头，前一段时间因为需要开发一个简单的app,所以接触了一下Apicloud,因为没有native应用的开发知识，所以采用了Apicloud的web应用开发。其中不同页面的传值问题我具体研究一段时间，因为之前一直传值不成功。 正文方法一：api.execScript 这个方法本来的功能是用来不同页面的函数的传递，当然，也可以用来传递值，将这个值作为函数的参数就可以传递到其他页面。具体： index1： //name是该页面函数的参数，作为参数传递到另一个页面 var str=&quot;test(&quot;+name+&quot;)&quot;; api.exeScript({ name:&quot;index2&quot;, script:str}); index2: //index2页面代码 function test(name){ alert(name); } 方法：api.addEventListener&amp;&amp;api.sendEvent这个是利用广播事件传递参数。 index1:发送广播 api.sendEvent({ name:&apos;myEvent&apos;, extra:{key1:&apos;value&apos;,key2:&apos;key2&apos;} }); index2:接受广播 api.addEventListener({ name:&apos;myEvent&apos;}, function(ret){ if(ret&amp;&amp;ret.value){ var value = ret.value; alert(value.key1+&apos;,&apos;+value.key2); } }); 方法三 :api.LocalStorage这个方法很简单，采用了本地数据存储的方法来交换数据。 index1: $api.setStorage(&apos;name&apos;,&apos;value&apos;);//数据存储 index2: $api.getStorage(&apos;name&apos;);//取出name值 另外： $api.rnStorage(&apos;name&apos;);//清除name值 $api.clearStorage(&apos;name&apos;);//清除所有本地数据 方法四 ：api.openWin&amp;api.openFrame&amp;api.openFrameGroup最后最简单的是采用打开窗口时可以顺带传值。 index1: //打开新窗口 api.openWin({ name:index2, url:index2.html, pageParam: { key : value, } }); //打开frame组 api.openFrameGroup({ name: &apos;group1&apos;, rect: { //frame的位置 x: 0, y: 0, w: &apos;auto&apos;, h: &apos;auto&apos; }, frames: [{ //frame组 name: &apos;frame1&apos;, url: &apos;frame1.html&apos;, bgColor: &apos;#fff&apos; }, { name: &apos;frame2&apos;, url: &apos;frame2.html&apos;, bgColor: &apos;#fff&apos; }] }, function(ret, err) { //回调函数 var index = ret.index; }); index2: apiready=function(){ var test=api.pageParam.key; alert(test); }]]></content>
      <categories>
        <category>Apicloud</category>
      </categories>
      <tags>
        <tag>Apicloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个简单的个人博客（1）UI设计]]></title>
    <url>%2F2018%2F08%2F13%2F%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%881%EF%BC%89UI%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[前言本来早该写这个博客，因为前一段时间一直在学习各种框架，为这个开发做准备。所以一直拖到现在才开始这个系列的文章，估计这个系列文章会持续4-5期，来写下我开发这个网站的全过程。我会尽力开发到理想状态，具体效果在月底估计会出来。 正文UI设计 在具体开发开发之前，我先概括的设计出来一个几个用户界面，包括主页，文章界面，后台用户界面。具体设计软件时使用Axure。 主页界面 主页是采用了比较简洁通用的设计样式，顶部是采用了稍隐藏式的顶部栏样式，顶部栏左侧是Tags,Home链接；左侧是后台界面的登录按钮。其次整个上部是一个轮播图，右侧是一个作者介绍，包括简书，github等的链接，头像，头像左侧准备设计一个按钮，点击时头像隐藏到右侧。 在底部没有采用过多的装饰，作者权限以及在有条件下可以开发一个浏览人数（图片上未展示）。文章界面文章界面上部是没有做改动，与主页界面一样，唯一不同的是轮播图改为静态图片展示，为了更好的阅读体验。其次在界面左侧引用了百度的分享控件，用来分享。在底部，我准备自己开发一个简单的评论系统，并不打算采用第三方评论系统。方案在后面写出。 后台界面 最后的后台用户界面，具体选项目前只准备了写博客与删除博客，以及使用工具的选项。具体美化可以在后期自我发挥~]]></content>
      <categories>
        <category>博客开发系列</category>
      </categories>
      <tags>
        <tag>博客开发</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《亮剑》精神-军人的尊严]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%8A%E4%BA%AE%E5%89%91%E3%80%8B%E7%B2%BE%E7%A5%9E%2F</url>
    <content type="text"><![CDATA[近来3天读完了《亮剑》一书。说来奇怪，平时读书无不是强忍困意的煎熬，唯独这本书，里面的情节，人物，仿佛有莫大的吸引力。把我带入那个战火纷飞的年代……我对李云龙的理解，仅限于电视剧中的那个形象，鲁莽，草率，但却勇敢，敢作敢当，思维已与常人。甚至当我刚读到原著时，我也这么认为，因为电视剧几乎是忠于原文，没有做改动，确是都梁笔下的那个李云龙。 但也是当我读到后来我才发现，电视剧未免有些片面，只塑造了一个能征善战的李云龙，这恐怕不是都梁的本意，也是由于敏感原因，导演无法将都梁笔下的那个李云龙活生生塑造出来。不过在我看来，李云龙这个人物的关键就在于后面的部分，前面的部分塑造了他的英勇，而后面李云龙的改变与他的坚持正是这个人物的灵魂所在。他在成长，却也有他坚持的信条！ 当他岳父谈及党内出现错误之时，他严厉的表示反对，因为他认为他跟及的共产党是不可能犯错误的，错在岳父根深蒂固的资产阶级思想。甚至在他的岳父岳母被拉到农村进行改造之时他仍认为这是他们的错误所对应的惩罚。 他信念的动摇是在赵刚死之后，作为搭档十几年的老战友，他相信赵刚是不会犯这种错误的，但他还是不明白到底是谁的错，他要去打死害死赵刚的人，被田雨制止，从这里他开始了他的思考，到底是谁的错误，使这些原本无罪的人受到非人的待遇。 当时他已是一军之长，管理着一个军的庞大队伍，而这一个军队却被两派所谓的左系革命派骑在头上，当其中一派要求得到他的支持时，他装病躲进来医院，以此来避开，而新来的副军长马天生确实一个极其“聪明”之人，他在李云龙“养病”之时，选着了其中一方支持，而另一方却得到省军区的支持。两派系随之进入了军事级别的斗争，若不是书中描述，我怎么也不会想到两个工人组成的团体可以在一座城市中兵戎相见，动辄就是大炮相见，甚至想要夺取军库，拿取大型榴弹炮，而这种榴弹炮的攻击半径几乎是半个城市。 李云龙不敢抵抗，因为一旦抵抗，毫无疑问，下场和赵刚没有区别。李云龙是个聪明人，他一忍再忍，企图想到一个两全其美的办法，但还没等到他想出来，他的一个师部就被革命派占领，军事机密，武器全落入他人之手，他明白只意味着什么，一旦不加以制止，整个城市都将毁于一旦。 李云龙还是那个李云龙，他亮剑了。就如同他在平安城下的那句“开炮！”。他开始下达了命令。这命令也代表这李云龙的灭亡，一颗流星的陨落，一个时代的结束。 最终，李云龙在他家里的阁楼上用那把楚云飞送他的勃朗宁手枪结束了自己的一生。 赵刚在临终的信中写着死亡也是一种反抗，他是对自己信条的坚持，所不同的是，李云龙坚持的是他的军人尊严！宁死不屈的精神！ 原文中对李云龙自杀前用了大量的文笔，无非是为了诠释，李云龙一生戎马，可倾尽一生，也无法想出，到底是谁的错，毛主席不会错，共产党不会错，那可能就是他李云龙的错误吧。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>读书</tag>
        <tag>感情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在ESC服务器上搭建静态网站]]></title>
    <url>%2F2018%2F07%2F22%2FecsAndWebsite%2F</url>
    <content type="text"><![CDATA[开始前面在连接上服务器后，紧接着我想测试一下服务器的网站搭建，下面就把简单的教程贴出来。 1.首先要要在服务器管理页面对服务器进行配置（我最开始就是忘了配置服务器的端口，结果怎么都不对!!!）由于我们HTTP的对应端口是80，所以我们在安全组规则中添加对80端口的开放。 添加好之后: 2.我的windows服务器中是没有自带IIS的，所以先从IIS的安装开始，点击左下角的服务器管理图标进入服务器管理页面。 3.在服务器管理中点击角色并点击右面的添加角色。 4.进入添加角色向导。 5.钩选Web服务器(IIS),点击安装。 6.点击安装后会弹出是否添加，点击“添加必需的功能”。 7.然后会弹出角色服务，由于我们搭建的静态网页，所以勾选常见的HTTTP功能，如果需要构建动态网站，可够相爱U呢引用程序开发下的相应功能。 8.然后等待角色安装完成。 9.然后就可以输入服务器的公网IP查看是否成功安装IIS服务。看到上面这张图就代表安装成功了。 10.添加应用池。 11.添加站点，注意，IP地址要选择全部未分配 *12.最后是默认文档的修改，服务器中默认的主页是default.htm,你可以把它改成你的主页名。 13.在浏览器输入你的ip地址。查看你的网页。 结尾至此，一个静态网站就搭建好了。其中容易发生错误的点主要有： 安全规则没有配置或者没有配置正确。 创建新站点的IP地址要选择全部未分配。 借鉴资料： 部分图片取自csdn博主bestself_iot的文章IIS 静态页面网站搭建]]></content>
      <categories>
        <category>website</category>
      </categories>
      <tags>
        <tag>esc</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xhellAnEcsd]]></title>
    <url>%2F2018%2F07%2F22%2Fxhellandcsd%2F</url>
    <content type="text"><![CDATA[关于ecs服务器的连接问题最近看阿里云有一个学生优惠，就申请了一个优惠的ecs服务器，一个月9.9,2G内存，40G云盘，血赚不亏。然后我就开始配置服务器，发现这个廉价的服务器是没办法更换操作系统的，自带的是一个Windows Server 2008 32位。然后我就开始准备连接服务器。阿里云自带有连接服务，但每天都要登陆网页会很麻烦。 然后我就下载了xshell，但一直连接不上，查看服务器端口配置，发现ssh端口22是打开的。后来我在网上查了很多资料，发现还是连接不上。最后我才意识到可能是操作系统的问题。果然我查询了sxhell支持的操作系统。得到如下结果： xshell等软件仅支持Linux，UNIX，centos等。 对于windows系统，需要用RDCMan或者windows自带的远程桌面连接。]]></content>
      <categories>
        <category>ecs</category>
      </categories>
      <tags>
        <tag>ecs</tag>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客啊]]></title>
    <url>%2F2018%2F07%2F20%2Fblog%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客啊！折腾了3天了，不过算起来也只是几个小时，还没弄好，心态有点爆炸啊，js也几天没有学了。这是百度的链接emmmm,暂时就这样！123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;fuck you&quot;); return 0;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
