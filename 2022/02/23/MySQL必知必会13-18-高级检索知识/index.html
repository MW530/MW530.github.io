<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>mysql必知必会13-18-高级检索知识 | My Wonderland</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="数据库MySQL高级检索知识" />
  
  
  
  
  <meta name="description" content="分组数据分组数据可以用于按照某一列数据作为分类标准来统计数据。所以其一般与聚集函数一起用。 创建分组分组是使用SELECT子句和GROUP BY子句建立。 例如：统计每个vend_id的数据数量： 1SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id; 将语句分为两部分，  SELECT vend_id, COU">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL必知必会13-18-高级检索知识">
<meta property="og:url" content="http://yoursite.com/2022/02/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A13-18-%E9%AB%98%E7%BA%A7%E6%A3%80%E7%B4%A2%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="My Wonderland">
<meta property="og:description" content="分组数据分组数据可以用于按照某一列数据作为分类标准来统计数据。所以其一般与聚集函数一起用。 创建分组分组是使用SELECT子句和GROUP BY子句建立。 例如：统计每个vend_id的数据数量： 1SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id; 将语句分为两部分，  SELECT vend_id, COU">
<meta property="article:published_time" content="2022-02-23T07:08:21.000Z">
<meta property="article:modified_time" content="2022-02-23T07:09:17.412Z">
<meta property="article:author" content="Michael Wang">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="高级检索知识">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="My Wonderland" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>

  
<script src="/js/bootstrap.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    
<link rel="stylesheet" href="/css/dialog.css">

  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

<meta name="generator" content="Hexo 4.2.1"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Home</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">Categories</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-MySQL必知必会13-18-高级检索知识" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      MySQL必知必会13-18-高级检索知识
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2022/02/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A13-18-%E9%AB%98%E7%BA%A7%E6%A3%80%E7%B4%A2%E7%9F%A5%E8%AF%86/" class="article-date">
	  <time datetime="2022-02-23T07:08:21.000Z" itemprop="datePublished">2022-02-23</time>
	</a>

      
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><p>分组数据可以用于按照某一列数据作为分类标准来统计数据。所以其一般与聚集函数一起用。</p>
<h2 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h2><p>分组是使用<code>SELECT</code>子句和<code>GROUP BY</code>子句建立。</p>
<p>例如：统计每个<code>vend_id</code>的数据数量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods <span class="keyword">FROM</span> products <span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure>
<p>将语句分为两部分，</p>
<ul>
<li><code>SELECT vend_id, COUNT(*) AS num_prods FROM products</code></li>
<li><code>GROUP BY vend_id</code></li>
</ul>
<p>可以看作是先统计了总数，然后将总数按照<code>vend_id</code>分类。其结果可能如下：</p>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>num_prods</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>3</td>
</tr>
<tr>
<td>1002</td>
<td>2</td>
</tr>
<tr>
<td>1003</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>因为使用了<code>GROUP BY</code>，就不必指定要计算和估值的每个组了。系统会自动完成。<code>GROUP BY</code>子句指示<code>MySQL</code>分组数据，然后对每个组而不是整个结果集进行聚集。</p>
<p>在具体使用<code>GROUP BY</code>子句前，需要知道一些重要的规定。</p>
<ul>
<li><code>GROUP BY</code>子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更加细致的控制。</li>
<li>如果在<code>GROUP BY</code>子句中嵌套了分组，数据将在最后规定的分组上进行汇总，换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li><code>GROUP BY</code>子句中列出的每个列都必须是检索列或有效的表达式（但不能时聚集函数）。<strong>如果在<code>SELECT</code>中使用表达式，则必须在<code>GROUP BY</code>子句中指定相同的表达式。不能使用别名。</strong></li>
<li>除聚集计算语句外，<code>SELECT</code>语句中的每个列都必须在<code>GROUP BY</code>子句中给出。</li>
<li>如果分组列中具有NULL值，则NULL值将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>
<li><code>GROUP BY</code>子句必须出现在<code>WHERE</code>子句之后，<code>ORDER BY</code>子句之前。</li>
</ul>
<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>分组过滤允许<code>GROUP BY</code>得出的分组进行过滤，规定得到哪些分组，排除哪些分组。</p>
<p><code>WHERE</code>子句不能对其进行过滤，因为分组是针对行的，而不是针对分组的。事实上，<code>WHERE</code>没有分组的概念。</p>
<p>MySQL提供了<code>HAVING</code>子句，<code>HAVING</code>非常类似于<code>WHERE</code>。只不过<code>WHERE</code>过滤行，<code>HAVING</code>过滤分组。</p>
<h3 id="HAVING和WHERE"><a href="#HAVING和WHERE" class="headerlink" title="HAVING和WHERE"></a><code>HAVING</code>和<code>WHERE</code></h3><ul>
<li>实际上有关<code>WHERE</code>的所有这些技术和选项都适用于<code>HAVING</code>。它们的句法是相同的，只是关键字有差别。</li>
<li>另一种理解方式是<code>WHERE</code>在数据分组前进行过滤，<code>HAVING</code>在数据分组后进行过滤。</li>
<li><strong>基于上面一条，可以得：<code>WHERE</code>用于筛选数据表中的字段，而<code>HAVING</code>用于筛选前面确定的字段（临时表的一部分）。</strong></li>
</ul>
<h3 id="分组过滤例子"><a href="#分组过滤例子" class="headerlink" title="分组过滤例子"></a>分组过滤例子</h3><ol>
<li><p>单使用<code>HAVING</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> orders <span class="keyword">FROM</span> orders <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>该语句增加了一个<code>HAVING COUNT(*) &gt;= 2</code>子句。所以其意义是按照<code>cust_id</code>分组然后筛选分组中总数<code>COUNT(*)</code>大于等于2的分组。</p>
</li>
<li><p>同时使用<code>WHERE</code>和<code>HAVING</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &gt;= <span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这里在前面加了<code>WHERE prod_price &gt;= 10</code>子句，如上所说，<code>WHERE</code>在分组统计之前进行计算，所以后面的统计中就不再包含<code>prod_price &lt; 10</code>的数据。然后将统计出的数据按照<code>COUNT(*) &gt; 2</code>进行分组过滤。</p>
</li>
</ol>
<h3 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h3><p><code>GROUP BY</code>和<code>ORDERED BY</code>子句的区别：</p>
<table>
<thead>
<tr>
<th>OEDERED BY</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody>
<tr>
<td>排序产生的输出</td>
<td>分组行。但输出可能不是分组的顺序</td>
</tr>
<tr>
<td>任意行都可以使用（甚至非选择的列也可以使用）</td>
<td>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td>
</tr>
<tr>
<td>不一定需要</td>
<td>如果于聚集函数一起使用列（或表达式），则必须使用</td>
</tr>
</tbody>
</table>
<p><code>GROUP BY</code>和<code>ORDERED BY</code>可以一起使用，可以先将数据筛选出来，然后按某列数据（可能是聚集的那列数据）对筛选的数据进行排序。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="keyword">SUM</span>(quantity * itenm_price) <span class="keyword">AS</span> ordertotal <span class="keyword">FROM</span> orderitems <span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num <span class="keyword">HAVING</span> <span class="keyword">SUM</span>(quantity * itenm_price) &gt;= <span class="number">50</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ordertotal;</span><br></pre></td></tr></table></figure>
<h2 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h2><p>下表中从上到小是<code>SELECT</code>中子句的出现顺序。</p>
<table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody>
</table>
<h1 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h1><p>MySQL在4.1版本引入了子查询功能。</p>
<p>SELECT语句是单个SQL的查询。迄今为止我们看到的SELECT语句都是简单查询，即从单个数据表中检索数据的单条语句。</p>
<p>SQL还允许创建子查询，即嵌套在其他查询中的查询。</p>
<h2 id="使用子查询进行过滤"><a href="#使用子查询进行过滤" class="headerlink" title="使用子查询进行过滤"></a>使用子查询进行过滤</h2><p>本书所有章中使用的数据库表都是关系表（关于每个表及关系的描述，请参阅附录B)。订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。</p>
<p>现在，假如需要列出订购物品TNT2的所有客户，应该怎样检索?下面列出具体的步骤。</p>
<p>(1)检索包含物品TNT2的所有订单的编号。</p>
<p>(2)检索具有前一步骤列出的订单编号的所有客户的ID。</p>
<p>(3)检索前一步骤返回的所有客户ID的客户信息。</p>
<p>上述每个步骤都可以单独作为一个查询来执行。可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。</p>
<ol>
<li><p><code>SELECT order_num FROM orderitems WHERE prod_id = &#39;TNT2&#39;</code></p>
<p>| order_num |<br>| ——— |<br>| 20005     |<br>| 20007     |</p>
</li>
</ol>
<ol start="2">
<li><p><code>SELECT cust_id FROM orders WHERE order_num IN (20005, 20007)</code></p>
<p>| cust_id |<br>| ——- |<br>| 10001   |<br>| 10004   |</p>
</li>
<li><p><code>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001, 10004)</code></p>
<p>| cust_name      | cust_contact |<br>| ————– | ———— |<br>| Coyote Inc.    | Y Lee        |<br>| Yosemite Plcae | Y sam        |</p>
</li>
</ol>
<h3 id="合并子句"><a href="#合并子句" class="headerlink" title="合并子句"></a>合并子句</h3><ol>
<li><p>合并子句1和子句2得到子句4</p>
<p>现在考虑合并第一个第二个子句。实际上就是将第二个子句中的数据用第一个子句来替换，并且用括号使之先进行计算。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>)</span><br></pre></td></tr></table></figure>
<p>| cust_id |<br>| ——- |<br>| 10001   |<br>| 10004   |</p>
</li>
<li><p>合并子句4和子句3</p>
<p>用同样的方法得到合并子句4和子句3：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> cust_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span></span><br><span class="line">    ));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为了执行上面的语句，MySQL实际上必须执行3条<code>SELECT</code>语句。最里面返回订单号列表，此列表用于最外面的子查询的<code>WHERE</code>子句。次外面的子查询返回客户ID列表。此客户ID列表用于最外层查询的<code>WHERE</code>子句。最外层查询才返回所需的数据。    </p>
<p>可见，在WHERE子句中使用子查询能够编写出功能强大并且很灵活的SQL语句。对于嵌套子查询的数目没有限制，不过在实际使用时由于性能的限制，最好不要嵌套太多的子查询。</p>
<p>注意：在<code>WHERE</code>子句中使用子查询，应该保证<code>SELECT</code>语句具有与<code>WHERE</code>子句中相同数目的列。通常，子查询将返回当单个列并且与单个列匹配，但如果需要也可以使用多个列。</p>
<p>虽然子查询一般与IN操作符相结合，但也可以用于测试等于（=）、不等于（&lt;&gt;）等。</p>
<h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><p>使用子查询的另一方法是创建计算字段。假设需要显示customers表中的每个客户的订单总数。订单与相应的客户ID存储在orders表中。</p>
<p>为了执行整个操作，遵循下面的步骤：</p>
<ol>
<li>从costumers表中检测客户列表。</li>
<li>对于检索出的每个客户，统计其在orders表中的订单数目。</li>
</ol>
<p>同样写出如果分开查询的步骤：</p>
<ol>
<li><p><code>SELECT COUNT(*) AS orders FROM orders WHERE cust_id = 10001</code></p>
<p>| orders |<br>| —— |<br>| 2      |</p>
</li>
<li><p><code>SELECT cust_name, cust_state FROM customers ORDER BY cust_name</code></p>
<p>| cust_name   | cust_status |<br>| ———– | ———– |<br>| Coyote Inc. | MI          |<br>| E fudd      | IL          |<br>| Mouse House | IN          |</p>
</li>
</ol>
<h3 id="合并子句-1"><a href="#合并子句-1" class="headerlink" title="合并子句"></a>合并子句</h3><p>现在将1，2合并，与上面不同，子句不作为筛选条件，而是一个计算属性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_state, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> orders.cust_id = customers.cust_id) <span class="keyword">AS</span> orders <span class="keyword">FROM</span> customers <span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>cust_name</th>
<th>cust_status</th>
<th>oders</th>
</tr>
</thead>
<tbody>
<tr>
<td>Coyote Inc.</td>
<td>MI</td>
<td>2</td>
</tr>
<tr>
<td>E fudd</td>
<td>IL</td>
<td>1</td>
</tr>
<tr>
<td>Mouse House</td>
<td>IN</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>注意这里的第三个属性是通过一个子查询得到的一个计算属性，注意这里子查询中的<code>WHERE</code>语句的条件，其会自动判断当前外层筛选出<code>oders</code>表中的行的<code>cust_id</code>，然后和<code>customers</code>表的<code>cust_id</code>进行比较。且必须加上限定名，如果不加上限定名，MySQL就会假设是将<code>oders</code>表中的<code>cust_id</code>进行自身匹配。</p>
<p>所以注意：虽然子查询在构造<code>SELECT</code>语句时极其有用，但必须注意限制有歧义性的列名。</p>
<p>技巧：对于子查询这种技术，可以嵌套很多层进行很强大的查询。但是为了在很多嵌套时其仍然保持正确，可以按照从内向外的调试技巧，即先从内部查询开始调试，一层层的增加，可以有效减少错误率。</p>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。</p>
<h2 id="为什么要联结表"><a href="#为什么要联结表" class="headerlink" title="为什么要联结表"></a>为什么要联结表</h2><p>分解数据为多个表能够有效地存储、更方便地处理，并且具有更加强大的可伸缩性。但是分解后数据也随之分解，为检索制造了很多麻烦。</p>
<p>而使用联结可以将多个表结合在一起。可以在一条<code>SELECT</code>语句中关联表。</p>
<h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price <span class="keyword">FROM</span> vendors, products <span class="keyword">WHERE</span> venders.vend_id = products.vend_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>vend_name</th>
<th>prod_name</th>
<th>prod_price</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACME</td>
<td>Bird seed</td>
<td>10.00</td>
</tr>
<tr>
<td>ACME</td>
<td>Carrots</td>
<td>2.50</td>
</tr>
<tr>
<td>ACME</td>
<td>Detonator</td>
<td>13.00</td>
</tr>
</tbody>
</table>
<p>这条语句的关键是<code>WHERE</code>子句，其指定了联立表的条件。</p>
<p>注意要匹配的两个列以<code>venders.vend_id</code>和<code>products.vend_id</code>来指定。这里需要这种完全限定名，因为如果只给出<code>vend_id</code>，则MySQL不知道指定的是两张表中的哪一个。</p>
<p>在列可能出现二义性的时候，必须使用完全限定名。如果引用一个没有用表名限定的具有二义性的列名，则MySQL经返回错误结果。</p>
<h2 id="WHERE子句的重要性"><a href="#WHERE子句的重要性" class="headerlink" title="WHERE子句的重要性"></a><code>WHERE</code>子句的重要性</h2><p>利用WHERE子句建立联结关系似乎有点奇怪，但实际上，有一个很充分的理由。请记住，在一条SELECT语句中联结几个表时，相应的关系是 在运行中构造的。在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。你必须自己做这件事情。在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管 它们逻辑上是否可以配在一起。</p>
<p>笛卡尔积：由没有联结条件的表返回的结果为笛卡尔积。检索出的行数将是第一个表中的行数乘以第二个表中的行数（即将第一张表中的所有数据与第二张表中所有数据进行组合，因为没有限定条件指定两张表中的哪些数据应该被指定）。</p>
<h2 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h2><p>目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的 相等测试。<strong>这种联结也称为内部联结</strong>。其实，对于这种联结可以使用稍 微不同的语法来明确指定联结的类型。下面的SELECT语句返回与前面例<br>子完全相同的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name，prod_name，prod_price <span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<p>这种语法将联结条件通过<code>ON</code>关键词来指定，并且由<code>INNER JOIN</code>给出要联立的两张表。</p>
<h2 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h2><p>SQL对一条<code>SELECT</code>语句可以联结的表的数目没有限制。创建多张表联结的规则基本相同：首先列出所有的表，然后定义表的关系，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, vend_name, prod_price, quantity <span class="keyword">FROM</span> orderitems, products, vendors <span class="keyword">WHERE</span> products.vend_id = vendors.vend_id <span class="keyword">AND</span> orderitems.prod_id = products.pord_id <span class="keyword">AND</span> order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<p>此语句联立了3张表，<code>orderitems</code>、<code>products</code>和<code>vendors</code>。并且通过<code>WHERE</code>指定了两个联立条件和一个值限定条件。</p>
<p>性能考虑：MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常消耗资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。</p>
<p>考虑子查询中的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (    <span class="keyword">SELECT</span> cust_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span>(        <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>    ));</span><br></pre></td></tr></table></figure>
<p>此时就可以用联立表来进行查询，而不需要进行子查询，子查询消耗的性能往往比联立更高：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers. orders, orderitems <span class="keyword">WHERE</span> customers.cust_id = orders.cust_id <span class="keyword">AND</span> orderitems.order_num = orders.order_num <span class="keyword">AND</span> pord_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
<p>通过两个限定条件来联立三张表，然后通过一个值限定来确定返回的是要求的产品。</p>
<h1 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h1><p>还有其他类型的表联结方式，也可以对被联结的表使用别名和聚集函数。</p>
<h2 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h2><p>SQL中不仅允许给列起别名，还允许给表取别名。这样做主要有以下两个理由：</p>
<ul>
<li>缩短SQL语句。</li>
<li>允许在单挑<code>SELECT</code>语句中多次使用相同的表。</li>
</ul>
<p>比如下面的语句使用别名来替代表名来缩短SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi <span class="keyword">WHERE</span> c.cust_id = o.cust_id <span class="keyword">AND</span> oi.order_num = o.order_num <span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到这里使用别名简化了后面的全限定名的写法。</p>
<h2 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h2><p>前面只看到了内部连接（等价联结）的简单联结。实际上一共有4中联结方式：</p>
<ul>
<li>自联结</li>
<li>自然联结</li>
<li>内部连接</li>
<li>外部联结</li>
</ul>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><p>所谓子查询就是表自己和自己联立，一般是为了通过表中的某一个信息来查询该表中的其他信息。</p>
<p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。下面是通过子查询解决此问题的一种方法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pord_id, pord_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id = (<span class="keyword">SELECT</span> vend_id <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_id = <span class="string">'DTNTR'</span>);</span><br></pre></td></tr></table></figure>
<p>同样，其可以用联结来重写子查询的语句。而这时我们是通过一张表得到的信息来查询这张表中的信息，此时就该使用自联结：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name <span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2 <span class="keyword">WHERE</span> p1.vend_id = p2.vend_id <span class="keyword">AND</span> p2.prod_id = <span class="string">'DTNTR'</span>;</span><br></pre></td></tr></table></figure>
<p>此查询中需要的两个表实际上是相同的表，因此<code>products</code>表在<code>FROM</code>子句中出现了两次。虽然这是完全合法的，但对<code>products</code>的引用具有二义性，因此MySQL不知道你引用的<code>products</code>表中的哪个实例。</p>
<p>为解决此问题，使用了表别名。<code>products</code>的第一次出现为别名p1，第二次出现为别名p2。现在可以将这些别名用作表名。例如，<code>SELECT</code>语句使用p1前缀明确地给出所需列的全名。如果不这样，MySQL将返回错误，因为分别存在两个名为<code>prod_id</code>、<code>prod_name</code>的列。MySQL不知道想要的是哪一个列（即使它们事实上是同一个列)。<code>WHERE</code>（通过匹配p1中的<code>vend_id</code>和p2中的<code>vend_id</code>）首先联结两个表，然后按第二个表中的<code>prod_id</code>过滤数据，返回所需的数据。</p>
<p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是 相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。</p>
<p>自然联结是这样一种联结，其中你只能选择那些唯一的列。这一 般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子<br>集来完成的。下面举一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.*, o.order_num，o.order_date,</span><br><span class="line">oi.prod_id，oi.quantity ，o1.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c,orders <span class="keyword">As</span> o，orderitems <span class="keyword">As</span> oilwHERE c.cust_id = o.cust_id</span><br><span class="line"><span class="keyword">AND</span> oi.order_num = o.order_numANDprod_id = <span class="string">'FB'</span> ;</span><br></pre></td></tr></table></figure>
<p>1、自然连接是特殊的内联结（等值联结），自然联结不能有where和on去限制筛选<br>2、等值连接要求相等的分量，不一定是公共属性（即相同的列名）；而自然连接要求相等的公共属性（列名）。　　</p>
<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。</p>
<p>下面的SELECT语句给出一个简单的内部联结。它检索所有客户及其 订单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num <span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customer.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>类似于上一章中所看到的内部联结，这条SELECT语句使用了关 键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没 有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM 子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN，如下例所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num <span class="keyword">FROM</span> customers <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> orders.cust_id = customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>外部联结的类型 存在两种基本的外部联结形式：左外部联结 和右外部联结。它们之间的唯一差别是所关联的表的顺序不<br>同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中。</p>
<h2 id="使用聚集函数"><a href="#使用聚集函数" class="headerlink" title="使用聚集函数"></a>使用聚集函数</h2><p>聚集函数也可以用于联结表的聚集。</p>
<p>例如：如果要检索所有客户及每个客户所下的订单数，下面使用了COUNT()函数的代码可完成此工作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name, customers.cust_id, <span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord <span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> costomers.cust_id = orders.cust_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>此SELECT语句使用<code>INNER JOIN</code>将<code>customers</code>和<code>orders</code>表互相关联。 <code>GROUP BY</code>子句按客户分组数据，因此，函数调用<code>COUNT(orders.order_num)</code>对每个客户的订单计数，将它作为<code>num_ord</code>返回。</p>
<h2 id="使用联结的条件"><a href="#使用联结的条件" class="headerlink" title="使用联结的条件"></a>使用联结的条件</h2><ul>
<li>注意使用联结的类型，根据不同情况选择内还是外。</li>
<li>应该提供联结条件，否则将返回笛卡尔积。</li>
<li>在一个联结中，可以包含多个表，并且不同的表也可以使用不同的联结方式，但是应该先单个测试，防止混乱出错。</li>
</ul>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>MySQL允许执行多个查询操作（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常被称为并（<code>union</code>）或复合查询（<code>compound query</code>）。</p>
<p>有两种基本情况，其中需要使用组合查询：</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据。</li>
<li>对单个表执行多个查询，按单个查询返回数据。</li>
</ul>
<p>组合查询和多个WHERE条件：多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，任何具有多个<code>WHERE</code>子句的<code>SELECT</code>语句都可以作为一个组合查询给出，在以下段落中可以看到这一点。 这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。</p>
<h2 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h2><p>可用UNION操作符来组合数条SQL查询。</p>
<h3 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h3><p><code>UNION</code>的使用很简单。所需做的只是给出每条<code>SELECT</code>语句，在各条语句之间放上关键字<code>UNION</code>。</p>
<p>举一个例子，假如需要价格小于等于5的所有物品的一个列表，而且 还想包括供应商1001和1002生产的所有物品（不考虑价格）。当然，可以利用<code>WHERE</code>子句来完成此工作，不过这次我们将使用<code>UNION</code>。</p>
<p>语句1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>prod_id</code></th>
<th><code>prod_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1003</td>
<td>FC</td>
<td>2.50</td>
</tr>
<tr>
<td>1002</td>
<td>FUI</td>
<td>3.42</td>
</tr>
<tr>
<td>1003</td>
<td>SLING</td>
<td>4.49</td>
</tr>
</tbody>
</table>
<p>语句2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>prod_id</code></th>
<th><code>prod_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>ANV01</td>
<td>5.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV02</td>
<td>9.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV03</td>
<td>14.99</td>
</tr>
</tbody>
</table>
<h4 id="组合查询-1"><a href="#组合查询-1" class="headerlink" title="组合查询"></a>组合查询</h4><p>现在将两条语句组合起来</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span>  vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>prod_id</code></th>
<th><code>prod_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1003</td>
<td>FC</td>
<td>2.50</td>
</tr>
<tr>
<td>1002</td>
<td>FUI</td>
<td>3.42</td>
</tr>
<tr>
<td>1003</td>
<td>SLING</td>
<td>4.49</td>
</tr>
<tr>
<td>1001</td>
<td>ANV01</td>
<td>5.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV02</td>
<td>9.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV03</td>
<td>14.99</td>
</tr>
</tbody>
</table>
<h4 id="WHERE方式"><a href="#WHERE方式" class="headerlink" title="WHERE方式"></a><code>WHERE</code>方式</h4><p>前面提到，一般从同一个表中进行联合查询，也可以用<code>WHERE</code>来替代：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span> <span class="keyword">AND</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>vend_id</code></th>
<th><code>prod_id</code></th>
<th><code>prod_price</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1003</td>
<td>FC</td>
<td>2.50</td>
</tr>
<tr>
<td>1002</td>
<td>FUI</td>
<td>3.42</td>
</tr>
<tr>
<td>1003</td>
<td>SLING</td>
<td>4.49</td>
</tr>
<tr>
<td>1001</td>
<td>ANV01</td>
<td>5.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV02</td>
<td>9.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV03</td>
<td>14.99</td>
</tr>
</tbody>
</table>
<p>这两种方式获得的结果一致。</p>
<h3 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h3><ul>
<li><code>UNION</code>必须由两条或两条以上的<code>SELECT</code>语句组成，语句之间用关 键字<code>UNION</code>分隔（因此，如果组合4条<code>SELECT</code>语句，将要使用3个<code>UNION</code>关键字）。</li>
<li><code>UNION</code>中的每个查询必须包含<strong>相同的列、表达式和聚集函数</strong>（不过各个列不需要以相同的次序列出）。</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以 隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li>
</ul>
<p>如果遵守了这些基本规则或限制，则可以将并用于任何数据检索任务。</p>
<h3 id="包含或取消重复的列"><a href="#包含或取消重复的列" class="headerlink" title="包含或取消重复的列"></a>包含或取消重复的列</h3><p><code>UNION</code>会从查询结果集中自动去除了重复的行（换句话说，它的行为与 单条<code>SELECT</code>语句中使用多个<code>WHERE</code>子句条件一样）。</p>
<p>这是<code>UNION</code>的默认行为，但是如果需要，可以改变它。事实上，如果 想返回所有匹配行，可使用<code>UNION ALL</code>而不是<code>UNION</code>。</p>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<p>此时就会将重复的行保存下来，不会被移除。</p>
<h3 id="对组合查询结果进行排序"><a href="#对组合查询结果进行排序" class="headerlink" title="对组合查询结果进行排序"></a>对组合查询结果进行排序</h3><p><code>SELECT</code>语句的输出用<code>ORDER BY</code>子句排序。在用<code>UNION</code>组合查询时，只 能使用一条<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一<br>部分的情况，因此不允许使用多条<code>ORDER BY</code>子句。</p>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_id, prod_price;</span><br></pre></td></tr></table></figure>
<p>这条<code>UNION</code>在最后一条<code>SELECT</code>语句后使用了<code>ORDER BY</code>子句。虽 然<code>ORDER BY</code>子句似乎只是最后一条<code>SELECT</code>语句的组成部分，但实际上MySQL将用它来排序所有<code>SELECT</code>语句返回的所有结果。</p>
<h1 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h1><p>并非所有引擎都支持全文本搜索：MySQL 支持几种基本的数据库引擎。并非所有的引擎都支持本全文本搜索。两个最常使用的引擎为<code>MyISAM</code>和<code>InnoDB</code>，前者支持全文本搜索，而<strong>后者不支持</strong>。</p>
<p>前文介绍了<code>LIKE</code>关键词和正则表达式，都可以达到检索的目的。但是其有以下的问题：</p>
<ul>
<li>性能：通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行 数不断增加，这些搜索可能非常耗时。</li>
<li>明确控制：使用通配符和正则表达式匹配，很难（而且并不总 是能）明确地控制匹配什么和不匹配什么。</li>
<li>智能化的结果：虽然基于通配符和正则表达式的搜索提供了非 常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。</li>
</ul>
<p>所有这些限制以及更多的限制都可以用全文本搜索来解决。在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理 每个词。MySQL创建指定列中各词的一个<strong>索引</strong>，搜索可以针对这些词进 行。这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率，等等。</p>
<h2 id="使用全文搜索"><a href="#使用全文搜索" class="headerlink" title="使用全文搜索"></a>使用全文搜索</h2><p>使用全文搜索，包含以下两步：</p>
<ul>
<li>索引要被搜索的列，而且要随着数据的改变不断地重新索引（MySQL自动完成）。</li>
<li>使用<code>SELECT</code>子句地<code>Match()</code>和<code>Against()</code>来进行全文搜索。</li>
</ul>
<h3 id="启用全文搜索支持"><a href="#启用全文搜索支持" class="headerlink" title="启用全文搜索支持"></a>启用全文搜索支持</h3><p>启用全文搜索支持，需要在创建表地时候使用<code>FULLTEXT</code>子句来确定要被索引的列，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">	node_id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    prod_id <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    note_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    note_text <span class="built_in">text</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY KEEY(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">)<span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure>
<p>如上，<code>FULLTEXT(note_text)</code>，使用<code>FULLTEXT</code>指定了<code>note_text</code>为要被检索的列。</p>
<blockquote>
<p>不要在导入数据时使用FULLTEXT： 更新索引要花时间，虽然 不是很多，但毕竟要花时间。如果正在导入数据到一个新表， 此时不应该启用FULLTEXT索引。应该首先导入所有数据，然 后再修改表，定义FULLTEXT。这样有助于更快地导入数据（而 且使索引数据的总时间小于在导入每行时分别进行索引所需<br>的总时间）</p>
</blockquote>
<h3 id="进行全文搜索"><a href="#进行全文搜索" class="headerlink" title="进行全文搜索"></a>进行全文搜索</h3><p>在索引之后，使用两个函数<code>Match()</code>和<code>Against()</code>执行全文本搜索，其中<code>Match()</code>指定被搜索的列，<code>Against()</code>指定要使用的搜索表达式。</p>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'rabbit'</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Customer complaint: rabbit has been able to detect trap，foodapparently less effective now .<br/>Quantity varies，sold by the sack load. A11 guaranteed to bebright and orange，and suitable for use as rabbit bait.</td>
</tr>
</tbody>
</table>
<p>此<code>SELECT</code>语句检索单个列<code>note_text</code>。由于<code>WHERE</code>子句，一个全 文本搜索被执行。<code>Match(note_text)</code>指示MySQL针对指定的列进行搜索，<code>Against(&#39;rabbit&#39;)</code>指定词rabbit作为搜索文本。由于有 两行包含词rabbit，这两个行被返回。</p>
<p>实际上刚才的搜索也可以使用LIKE关键字来解决：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> produscts <span class="keyword">WHERE</span> note_text <span class="keyword">LIKE</span> <span class="string">'%rabbit%'</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Quantity varies， sold by the sack load. A11 guaranteed to bebright and orange，and suitable for use as rabbit bait.<br/>Customer complaint: rabbit has been able to detect trap，foodapparently less effective now .</td>
</tr>
</tbody>
</table>
<p>这条SELECT语句同样检索出两行，但次序不同（虽然并不总是这种情况）。</p>
<p>其原因在于全文搜索会将具有较高等级的行先返回。而<code>LIKE</code>则是按照数据库中的顺序来进行返回。</p>
<p>这里的优先级一般是目标词越靠前，目标词越多，优先级越高。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>全文搜索的优点在于：</p>
<ul>
<li>其按照优先级排序</li>
<li>检索速度更快</li>
</ul>
<h3 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h3><p>查询扩展用来设法放宽所返回的全文本搜索结果的范围。考虑下面 的情况。你想找出所有提到anvils的注释。只有一个注释包含词anvils，但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。</p>
<p>这也是查询扩展的一项任务。在使用查询扩展时，MySQL对数据和 索引进行两遍扫描来完成搜索：</p>
<ul>
<li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有 行；</li>
<li>其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简 要地解释MySQL如何断定什么有用，什么无用）。</li>
<li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件， 而且还使用所有有用的词。</li>
</ul>
<p>例如，首先进行一个简单的全文本搜索，没有查询扩展： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productsnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Aganinst(<span class="string">"anvils"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Multiple customer returns，anvils failing to drop fast enough orfa1ling backwards on purchaser. Recommend that customer considersusing heavier anvils.</td>
</tr>
</tbody>
</table>
<p>有一行包含词anvils，因此只返回一行。</p>
<p>现在使用查询扩展：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productsnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Aganinst(<span class="string">"anvils"</span> <span class="keyword">WITH</span> <span class="keyword">QUERY</span> EXPANSION);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Multiple customer returns，anvils failing to drop fast enough orfa1ling backwards on purchaser. Recommend that customer considersusing heavier anvils.<br/>Customer complaint: Sticks not individua1ly wrapped，too easy tomistakenly detonate all at once. Recommend individual wrapping.Customer complaint: Not heavy enough to generate flying starsaround headof victim. If being purchased for dropping，recommend<br />ANV02 or ANV03 instead</td>
</tr>
<tr>
<td>Please note that no returns wil1 be accepted if safe opened usingexplosives .<br/>Customer complaint: rabbit has been able to detect trap，foodapparently less effective now .<br/>Customer complaint: Circular hole in safe floor can apparently beeasily cut with handsaw.<br/>Matches not included，recommend purchase of matches or detonator(item DTNTR) .</td>
</tr>
</tbody>
</table>
<p>这次返回了7行。第一行包含词anvils，因此等级最高。第二行与anvils无关，但因为它包含第一行中的两个词（customer<br>和recommend），所以也被检索出来。第3行也包含这两个相同的词，但它 们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名）。</p>
<h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><p>MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean 170<br>mode）。以布尔方式，可以提供关于如下内容的细节：</p>
<ul>
<li>要匹配的词</li>
<li>拍排斥的词（如果某行包含这个词，则不返回改行，即使它包含其他指定的词也是如此）</li>
<li>排列提示</li>
<li>表达式分组</li>
<li>其他内容</li>
</ul>
<blockquote>
<p>即使没有FULLTEXT索引也可以使用 布尔方式不同于迄今为 止使用的全文本搜索语法的地方在于，即使没有定义 FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作<br>（其性能将随着数据量的增加而降低）。</p>
</blockquote>
<p>例1：检索包含<code>heavy</code>的句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_textFROMproductnotes</span><br><span class="line"><span class="keyword">wHERE</span> <span class="keyword">Match</span>(note_text) Against( <span class="string">'heavy'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Item is extremely heavy. Designed for dropping，not recommendedfor use with slings，ropes，pulleys， or tightropes.Customer complaint: Not heavy enough to generate flying starsaround head of victim. If being purchased for dropping，recommendANV02 or ANV03 instead.</td>
</tr>
</tbody>
</table>
<p>此全文本搜索检索包含词heavy的所有行（有两行）。其中使用 了关键字IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同。</p>
<p>例2：检索包含<code>heavy</code>但不包含任何以<code>rope</code>开头的行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productsnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'heavy -rope*'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>note_text</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Customer complaint: Not heavy enough to generate flying stars around head of victim. If being purchased for dropping，recommend ANVO2 or ANV03 instead.</td>
</tr>
</tbody>
</table>
<p>这次只返回一行。这一次仍然匹配词heavy，但-rope*明确地 指示MySQL排除包含rope*（任何以rope开始的词，包括<br>ropes）的行，这就是为什么上一个例子中的第一行被排除的原因。</p>
<p>下面是所有的全文布尔操作符</p>
<table>
<thead>
<tr>
<th>布尔操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>包含，词必须存在</td>
</tr>
<tr>
<td>-</td>
<td>排除，词必须不出现</td>
</tr>
<tr>
<td>&gt;</td>
<td>包含，而且增加等级值</td>
</tr>
<tr>
<td>&lt;</td>
<td>包含，且减少等级值</td>
</tr>
<tr>
<td>()</td>
<td>把词组成子表达式（允许这些表达式作为一个组被包含、排除、排列等）</td>
</tr>
<tr>
<td>~</td>
<td>取消一个词的排序值</td>
</tr>
<tr>
<td>*</td>
<td>词尾的通配符</td>
</tr>
<tr>
<td>“”</td>
<td>定义一个短语（与单个词的列表不一样，它匹配整个短语以便排除整个短语）</td>
</tr>
</tbody>
</table>
<p>例如</p>
<p>1：搜索包含词<code>rabbit</code>和<code>bait</code>的行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'+rabbit +bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<p>2：搜索匹配包含<code>rabbit</code>和<code>bait</code>中的至少一 个词的行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'rabbit bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<p>3：搜索匹配短语<code>rabbit bait</code>而不是匹配两个词<code>rabbit</code>和 <code>bait</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'"rabbit bait"'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<p>4：匹配<code>rabbit</code>和<code>carrot</code>，增加前者的等级，降低后者的等级。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'&gt;rabbit &lt;bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<h3 id="全文搜索的使用说明"><a href="#全文搜索的使用说明" class="headerlink" title="全文搜索的使用说明"></a>全文搜索的使用说明</h3><ul>
<li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为 那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li>
<li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参 阅MySQL文档以了解如何完成此工作）。</li>
<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。 因此，MySQL规定了一条50%规则，如果一个词出现在50%以上 的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN<br>MODE。</li>
<li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词 或者不出现，或者至少出现在50%的行中）。</li>
<li>忽略词中的单引号。例如，don’t索引为dont。</li>
<li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文 本搜索结果。</li>
<li>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>


<script src="/js/vdonate.js"></script>

<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'http://39.106.203.62:7777/mm_facetoface_collect_qrcode_1532532148519.png',
  alipayImage: 'http://39.106.203.62:7777/1532532158487.jpg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>Post author:  </strong>Michael Wang</a>
          </li>
          <li class="post-copyright-link">
          <strong>Post link:  </strong>
          <a href="/2022/02/23/MySQL必知必会13-18-高级检索知识/" target="_blank" title="MySQL必知必会13-18-高级检索知识">http://yoursite.com/2022/02/23/MySQL必知必会13-18-高级检索知识/</a>
          </li>
          <li class="post-copyright-license">
            <strong>Copyright Notice:   </strong>
            All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            unless stating additionally.
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/02/20/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A1-12-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MySQL必知必会1-12-基础知识</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#分组数据"><span class="nav-number">1.</span> <span class="nav-text">分组数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建分组"><span class="nav-number">1.1.</span> <span class="nav-text">创建分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤分组"><span class="nav-number">1.2.</span> <span class="nav-text">过滤分组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HAVING和WHERE"><span class="nav-number">1.2.1.</span> <span class="nav-text">HAVING和WHERE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组过滤例子"><span class="nav-number">1.2.2.</span> <span class="nav-text">分组过滤例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组和排序"><span class="nav-number">1.2.3.</span> <span class="nav-text">分组和排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SELECT子句顺序"><span class="nav-number">1.3.</span> <span class="nav-text">SELECT子句顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用子查询"><span class="nav-number">2.</span> <span class="nav-text">使用子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用子查询进行过滤"><span class="nav-number">2.1.</span> <span class="nav-text">使用子查询进行过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#合并子句"><span class="nav-number">2.1.1.</span> <span class="nav-text">合并子句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作为计算字段使用子查询"><span class="nav-number">2.2.</span> <span class="nav-text">作为计算字段使用子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#合并子句-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">合并子句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#联结表"><span class="nav-number">3.</span> <span class="nav-text">联结表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要联结表"><span class="nav-number">3.1.</span> <span class="nav-text">为什么要联结表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建联结"><span class="nav-number">3.2.</span> <span class="nav-text">创建联结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WHERE子句的重要性"><span class="nav-number">3.3.</span> <span class="nav-text">WHERE子句的重要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部联结"><span class="nav-number">3.4.</span> <span class="nav-text">内部联结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#联结多个表"><span class="nav-number">3.5.</span> <span class="nav-text">联结多个表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建高级联结"><span class="nav-number">4.</span> <span class="nav-text">创建高级联结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用表别名"><span class="nav-number">4.1.</span> <span class="nav-text">使用表别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用不同类型的联结"><span class="nav-number">4.2.</span> <span class="nav-text">使用不同类型的联结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自联结"><span class="nav-number">4.2.1.</span> <span class="nav-text">自联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自然联结"><span class="nav-number">4.2.2.</span> <span class="nav-text">自然联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部联结"><span class="nav-number">4.2.3.</span> <span class="nav-text">外部联结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用聚集函数"><span class="nav-number">4.3.</span> <span class="nav-text">使用聚集函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用联结的条件"><span class="nav-number">4.4.</span> <span class="nav-text">使用联结的条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合查询"><span class="nav-number">5.</span> <span class="nav-text">组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建组合查询"><span class="nav-number">5.1.</span> <span class="nav-text">创建组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用UNION"><span class="nav-number">5.1.1.</span> <span class="nav-text">使用UNION</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#组合查询-1"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">组合查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WHERE方式"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">WHERE方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNION规则"><span class="nav-number">5.1.2.</span> <span class="nav-text">UNION规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包含或取消重复的列"><span class="nav-number">5.1.3.</span> <span class="nav-text">包含或取消重复的列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对组合查询结果进行排序"><span class="nav-number">5.1.4.</span> <span class="nav-text">对组合查询结果进行排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#全文本搜索"><span class="nav-number">6.</span> <span class="nav-text">全文本搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用全文搜索"><span class="nav-number">6.1.</span> <span class="nav-text">使用全文搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启用全文搜索支持"><span class="nav-number">6.1.1.</span> <span class="nav-text">启用全文搜索支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进行全文搜索"><span class="nav-number">6.1.2.</span> <span class="nav-text">进行全文搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较"><span class="nav-number">6.1.3.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用查询扩展"><span class="nav-number">6.1.4.</span> <span class="nav-text">使用查询扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔文本搜索"><span class="nav-number">6.1.5.</span> <span class="nav-text">布尔文本搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全文搜索的使用说明"><span class="nav-number">6.1.6.</span> <span class="nav-text">全文搜索的使用说明</span></a></li></ol></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2022 My Wonderland All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/scripts.js"></script>





  
<script src="/js/dialog.js"></script>










	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            My Wonderland
          </div>
          <div class="panel-body">
            Copyright © 2022 Michael Wang All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <a id="mwSearch"><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>